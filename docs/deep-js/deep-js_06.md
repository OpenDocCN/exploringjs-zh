# 四、环境：变量的内部工作原理

> 原文：[`exploringjs.com/deep-js/ch_environments.html`](https://exploringjs.com/deep-js/ch_environments.html)

* * *

+   4.1 环境：管理变量的数据结构

+   4.2 通过环境进行递归

    +   4.2.1 执行代码

+   4.3 通过环境进行嵌套作用域

    +   4.3.1 执行代码

+   4.4 闭包和环境

* * *

在本章中，我们将更仔细地研究 ECMAScript 语言规范如何处理变量。

### 4.1 环境：管理变量的数据结构

环境是 ECMAScript 规范用于管理变量的数据结构。它是一个字典，其键是变量名，值是这些变量的值。每个作用域都有其关联的环境。环境必须能够支持与变量相关的以下现象：

+   递归

+   嵌套作用域

+   闭包

我们将使用示例来说明每种现象是如何实现的。

### 4.2 通过环境进行递归

我们首先解决递归。考虑以下代码：

```js
function f(x) {
 return x * 2;
}
function g(y) {
 const tmp = y + 1;
 return f(tmp);
}
assert.equal(g(3), 8);
```

对于每个函数调用，您需要为被调用函数的变量（参数和局部变量）提供新的存储空间。这是通过所谓的*执行上下文*的堆栈来管理的，它们是环境的引用（本章的目的）。环境本身存储在堆上。这是必要的，因为它们偶尔在执行离开其作用域后继续存在（我们将在探索*闭包*时看到）。因此，它们本身不能通过堆栈管理。

#### 4.2.1 执行代码

在执行代码时，我们进行以下暂停：

```js
function f(x) {
 // Pause 3
 return x * 2;
}
function g(y) {
 const tmp = y + 1;
 // Pause 2
 return f(tmp);
}
// Pause 1
assert.equal(g(3), 8);
```

发生了什么：

+   暂停 1 - 在调用`g()`之前（图 1）。

+   暂停 2 - 在执行`g()`时（图 2）。

+   暂停 3 - 在执行`f()`时（图 3）。

+   剩下的步骤：每次有`return`时，一个执行上下文将从堆栈中移除。

![](img/500f606df20758e348b5eab435dca891.png)

图 1：递归，暂停 1 - 在调用`g()`之前：执行上下文堆栈有一个条目，指向顶层环境。在该环境中，有两个条目；一个是`f()`，一个是`g()`。

![](img/5ee98ad9451eb4fc93477cf8fd9ae8cd.png)

图 2：递归，暂停 2 - 在执行`g()`时：执行上下文堆栈的顶部指向为`g()`创建的环境。该环境包含了参数`y`和本地变量`tmp`的条目。

![](img/a99708ba4b44d86dd29a70adbd4f1924.png)

图 3：递归，暂停 3 - 在执行`f()`时：顶部执行上下文现在指向`f()`的环境。

### 4.3 通过环境进行嵌套作用域

我们使用以下代码来探索如何通过环境实现嵌套作用域。

```js
function f(x) {
 function square() {
 const result = x * x;
 return result;
 }
 return square();
}
assert.equal(f(6), 36);
```

在这里，我们有三个嵌套作用域：顶层作用域，`f()`的作用域和`square()`的作用域。观察：

+   作用域是连接的。内部作用域“继承”了外部作用域的所有变量（减去它遮蔽的变量）。

+   作为一种机制，嵌套作用域是独立于递归的。后者最好由独立环境的堆栈管理。前者是每个环境与“创建它的”环境的关系。

因此，每个作用域的环境都通过一个名为`outer`的字段指向周围作用域的环境。当我们查找变量的值时，首先在当前环境中搜索其名称，然后在外部环境中搜索，然后在外部环境的外部环境中搜索，依此类推。整个外部环境链包含了当前可以访问的所有变量（减去被遮蔽的变量）。

当你进行函数调用时，你创建了一个新的环境。该环境的外部环境是函数创建时的环境。为了帮助设置通过函数调用创建的环境的`outer`字段，每个函数都有一个名为`[[Scope]]`的内部属性，指向它的“诞生环境”。

#### 4.3.1 执行代码

这是我们在执行代码时所做的暂停：

```js
function f(x) {
 function square() {
 const result = x * x;
 // Pause 3
 return result;
 }
 // Pause 2
 return square();
}
// Pause 1
assert.equal(f(6), 36);
```

发生了什么：

+   暂停 1 - 在调用`f()`之前（图 4）。

+   暂停 2 - 在执行`f()`时（图 5）。

+   暂停 3 - 在执行`square()`时（图 6）。

+   之后，`return`语句将执行条目从堆栈中弹出。

![](img/fc1f598c8b8a54a968403157d9bdd685.png)

图 4：嵌套作用域，暂停 1 - 在调用`f()`之前：顶层环境只有一个条目，即`f()`。`f()`的诞生环境是顶层环境。因此，`f`的`[[Scope]]`指向它。

![](img/f89abfb174e1547d600b066ac16dd7ad.png)

图 5：嵌套作用域，暂停 2 - 在执行`f()`时：现在有一个用于函数调用`f(6)`的环境。该环境的外部环境是`f()`的诞生环境（索引为 0 的顶层环境）。我们可以看到`outer`字段被设置为`f`的`[[Scope]]`的值。此外，新函数`square()`的`[[Scope]]`是刚刚创建的环境。

![](img/f45a800b437ff88389f3808b333e2a3e.png)

图 6：嵌套作用域，暂停 3 - 在执行`square()`时：重复了之前的模式：最近环境的`outer`是通过我们刚刚调用的函数的`[[Scope]]`设置的。通过`outer`创建的作用域链包含了当前活动的所有变量。例如，我们可以访问`result`、`square`和`f`。环境反映了变量的两个方面。首先，外部环境链反映了嵌套的静态作用域。其次，执行上下文的堆栈反映了动态地进行了哪些函数调用。

### 4.4 闭包和环境

为了看到环境是如何用来实现[闭包](https://exploringjs.com/impatient-js/ch_variables-assignment.html#closures)的，我们使用以下示例：

```js
function add(x) {
 return (y) => { // (A)
 return x + y;
 };
}
assert.equal(add(3)(1), 4); // (B)
```

这里发生了什么？`add()`是一个返回函数的函数。当我们在 B 行进行嵌套函数调用`add(3)(1)`时，第一个参数是给`add()`，第二个参数是给它返回的函数。这是因为在 A 行创建的函数在离开该作用域时不会失去与其诞生作用域的连接。通过该连接，相关环境保持活动状态，函数仍然可以访问该环境中的变量`x`（`x`在函数内部是自由的）。

这种嵌套调用`add()`的方式有一个优势：如果你只进行第一次函数调用，你会得到一个`add()`的版本，其中参数`x`已经填充：

```js
const plus2 = add(2);
assert.equal(plus2(5), 7);
```

将具有两个参数的函数转换为具有一个参数的两个嵌套函数，称为*柯里化*。`add()`是一个柯里化的函数。

只填写函数的一些参数称为*部分应用*（函数尚未完全应用）。[函数的`.bind()`方法](https://exploringjs.com/impatient-js/ch_single-objects.html#function-prototype-bind)执行部分应用。在前面的例子中，我们可以看到，如果一个函数是柯里化的，部分应用是简单的。

##### 4.4.0.1 执行代码

当我们执行以下代码时，我们会做三次暂停：

```js
function add(x) {
 return (y) => {
 // Pause 3: plus2(5)
 return x + y;
 }; // Pause 1: add(2)
}
const plus2 = add(2);
// Pause 2
assert.equal(plus2(5), 7);
```

这就是发生的事情：

+   暂停 1 - 在执行`add(2)`期间（图 7）。

+   暂停 2 - 在执行`add(2)`之后（图 8）。

+   暂停 3 - 在执行`plus2(5)`时（图 9）。

![](img/aed519495eaedebf4fb2c1f3a7bdb579.png)

图 7：闭包，暂停 1 - 在执行`add(2)`期间：我们可以看到`add()`返回的函数已经存在（见右下角），并且它通过其内部属性`[[Scope]]`指向其诞生环境。请注意，`plus2`仍处于其暂时死区并未初始化。

![](img/797baa263d972bfe6f34680109ee7a69.png)

图 8：闭包，暂停 2 - 在执行`add(2)`之后：`plus2`现在指向`add(2)`返回的函数。该函数通过其`[[Scope]]`保持其诞生环境（`add(2)`的环境）的活力。

![](img/0959e9029bc37c6710bb7eb4b184d49b.png)

图 9：闭包，暂停 3 - 在执行`plus2(5)`时：`plus2`的`[[Scope]]`用于设置新环境的`outer`。这就是当前函数如何访问`x`的方式。

接下来：5 全局变量的详细查看
