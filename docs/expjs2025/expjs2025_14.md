# 12   开始使用练习

> [原文](https://exploringjs.com/js/book/ch_exercises.html)

1.  12.1   练习

    1.  12.1.1   安装练习

    1.  12.1.2   运行练习

1.  12.2   JavaScript 中的单元测试

    1.  12.2.1   典型测试

    1.  12.2.2   Mocha 中的异步测试

在大多数章节中，都有指向练习的框。这些是付费功能，但提供了全面的预览。本章解释了如何开始使用它们。

### 12.1   练习

#### 12.1.1   安装练习

要安装练习：

+   下载并解压 `exploring-js-code.zip`

+   按照以下 `README.txt` 中的说明操作。

#### 12.1.2   运行练习

+   本书中的练习通过路径引用。

    +   例如：`exercises/exercises/first_module_test.mjs`

+   在每个文件中：

    +   第一行包含运行练习的命令。

    +   以下行描述了您必须执行的操作。

### 12.2   JavaScript 中的单元测试

本书中的所有练习都是通过测试框架 [Mocha](https://mochajs.org) 运行的测试。本节提供了简要介绍。

#### 12.2.1   典型测试

典型的测试代码分为两部分：

+   第一部分：待测试的代码。

+   第二部分：代码的测试。

以以下两个文件为例：

+   `id.mjs` (待测试的代码)

+   `id_test.mjs` (测试)

##### 12.2.1.1   第一部分：代码

代码本身位于 `id.mjs`：

```js
export function id(x) {
  return x;
}

```

这里关键的是：我们想要测试的所有内容都必须导出。否则，测试代码无法访问它。

##### 12.2.1.2   第二部分：测试

![阅读图标](img/0fb62b2fc33a72829ae9fb174dedd0d2.png) **不要担心测试的详细细节**

您不需要担心测试的详细细节：它们总是为您实现。因此，您只需要阅读它们，而不需要编写它们。

代码的测试位于 `id_test.mjs`：

```js
/* npm t demos/exercises/id_test.mjs

Instructions: Implement id.mjs
*/
suite('id_test.mjs');

import * as assert from 'node:assert/strict';
import {id} from './id.mjs';

test('My test', () => {
  assert.equal(
    id('abc'), 'abc'
  );
});

```

这个文件里有什么？

+   它以运行测试的命令开始。

+   接下来是实施解决方案的说明。

+   `suite()` 为此文件中的测试提供标题。

+   我们在严格模式下使用 Node.js 的 `assert` 模块。

+   函数 `test()` 定义了命名的测试用例。

+   测试的核心是 `assert.equal()` 检查导入的函数 `id()` 的结果。这就是我们必须实现的函数。

要运行测试，我们在 shell 中执行以下命令：

```js
npm t demos/exercises/id_test.mjs

```

`t` 是 `test` 的缩写。也就是说，这个命令的完整版本是：

```js
npm test demos/exercises/id_test.mjs

```

![练习图标](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：您的第一个练习**

以下练习让您首次体验练习的样子：

+   `exercises/exercises/first_module_test.mjs`

#### 12.2.2   Mocha 中的异步测试

![Icon “reading”](img/0fb62b2fc33a72829ae9fb174dedd0d2.png) **阅读**

你可能想等到你读到关于异步编程的章节后再阅读这一节。

为异步代码编写测试需要额外的工作：测试结果会在之后收到，并且当它返回时必须向 Mocha 信号表示它尚未完成。以下小节将探讨三种实现此功能的方法。

##### 12.2.2.1 通过回调实现异步

如果我们传递给 `test()` 的回调函数有一个参数（例如，`done`），Mocha 将切换到基于回调的异步。当我们完成我们的异步工作时，我们必须调用 `done`：

```js
test('divideCallback', (done) => {
  divideCallback(8, 4, (error, result) => {
    if (error) {
      done(error);
    } else {
      assert.strictEqual(result, 2);
      done();
    }
  });
});

```

这就是 `divideCallback()` 的样子：

```js
function divideCallback(x, y, callback) {
  if (y === 0) {
    callback(new Error('Division by zero'));
  } else {
    callback(null, x / y);
  }
}

```

##### 12.2.2.2 通过 Promises 实现异步

如果测试返回一个 Promise，Mocha 将切换到基于 Promise 的异步。如果 Promise 被满足，则测试被认为是成功的；如果 Promise 被拒绝，或者解决时间超过超时，则测试被认为是失败的。

```js
test('dividePromise 1', () => {
  return dividePromise(8, 4)
  .then(result => {
    assert.strictEqual(result, 2);
  });
});

```

`dividePromise()` 的实现如下：

```js
function dividePromise(x, y) {
  return new Promise((resolve, reject) => {
    if (y === 0) {
      reject(new Error('Division by zero'));
    } else {
      resolve(x / y);
    }
  });
}

```

##### 12.2.2.3 异步函数作为测试“主体”

异步函数总是返回 Promises。因此，异步函数是实现异步测试的一种便捷方式。以下代码与上一个示例等价。

```js
test('dividePromise 2', async () => {
  const result = await dividePromise(8, 4);
  assert.strictEqual(result, 2);
  // No explicit return necessary!
});

```

我们不需要显式地返回任何内容：隐式返回的 `undefined` 用于满足此异步函数返回的 Promise。如果测试代码抛出异常，则异步函数会负责拒绝返回的 Promise。
