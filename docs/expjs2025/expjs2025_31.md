# 26 异常处理

> 原文：[`exploringjs.com/js/book/ch_exception-handling.html`](https://exploringjs.com/js/book/ch_exception-handling.html)

1.  26.1 动机：抛出和捕获异常

1.  26.2 `throw`

    1.  26.2.1 我们应该抛出什么值？

1.  26.3 `try`语句

    1.  26.3.1 `try`块

    1.  26.3.2 `catch`子句

    1.  26.3.3 `finally`子句

1.  26.4 所有内置异常类的超类：`Error`

    1.  26.4.1 `Error.prototype.name`

    1.  26.4.2 错误实例属性 `.message`

    1.  26.4.3 错误实例属性 `.stack`

1.  26.5 链式错误：实例属性 `.cause` (ES2022)

    1.  26.5.1 我们为什么要链式错误？

    1.  26.5.2 我们应该在`.cause`中存储上下文数据吗？

1.  26.6 `Error`的子类

    1.  26.6.1 `Error`的内置子类

    1.  26.6.2 子类化`Error`

本章介绍了 JavaScript 如何处理异常。

![图标“详情”](img/38ba63de820aae6f94a019538ae0f222.png) **为什么 JavaScript 不经常抛出异常？**

JavaScript 直到 ES3 才支持异常。这解释了为什么语言及其标准库很少使用它们。

### 26.1 动机：抛出和捕获异常

考虑以下代码。它将存储在文件中的配置文件读取到包含`Profile`类实例的数组中：

```js
function readProfiles(filePaths) {
  const profiles = [];
  for (const filePath of filePaths) {
    try {
      const profile = readOneProfile(filePath);
      profiles.push(profile);
    } catch (err) { // (A)
      console.log('Error in: '+filePath, err);
    }
  }
}
function readOneProfile(filePath) {
  const profile = new Profile();
  const file = openFile(filePath);
  // ··· (Read the data in `file` into `profile`)
  return profile;
}
function openFile(filePath) {
  if (!fs.existsSync(filePath)) {
    throw new Error('Could not find file '+filePath); // (B)
  }
  // ··· (Open the file whose path is `filePath`)
}

```

让我们检查行 B 中发生了什么：发生了错误，但处理问题的最佳位置不是当前位置，而是在行 A。在那里，我们可以跳过当前文件并继续下一个文件。

因此：

+   在行 B 中，我们使用`throw`语句来指示存在问题。

+   在行 A 中，我们使用`try-catch`语句来处理问题。

当我们抛出时，以下结构是活跃的：

```js
readProfiles(···)
  for (const filePath of filePaths)
    try
      readOneProfile(···)
        openFile(···)
          if (!fs.existsSync(filePath))
            throw

```

逐个`throw`退出嵌套结构，直到遇到`try`语句。执行继续在该`try`语句的`catch`子句中。

### 26.2 `throw`

这是`throw`语句的语法：

```js
throw «value»;

```

#### 26.2.1 我们应该抛出什么值？

在 JavaScript 中，任何值都可以被抛出。然而，最好使用`Error`或其子类的实例，因为它们支持额外的功能，如堆栈跟踪和错误链（参见“所有内置异常类的超类：`Error`” (§26.4)）。

这给我们留下了以下选择：

+   直接使用`Error`类。在 JavaScript 中，这比在更静态的语言中限制更少，因为我们可以向实例添加自己的属性：

    ```js
    const err = new Error('Could not find the file');
    err.filePath = filePath;
    throw err;

    ```

+   使用`Error`的子类之一例如`TypeError`或`RangeError`。

+   继承`Error`（更多细节将在后面解释）：

    ```js
    class MyError extends Error {
    }
    function func() {
     throw new MyError('Problem!');
    }
    assert.throws(
     () => func(),
     MyError
    );

    ```

### 26.3 `try`语句

`try`语句的最大版本如下所示：

```js
try {
  «try_statements»
} catch (error) {
  «catch_statements»
} finally {
  «finally_statements»
}

```

我们可以将这些子句组合如下：

+   `try-catch`

+   `try-finally`

+   `try-catch-finally`

#### 26.3.1 `try`块

`try`块可以被认为是语句的主体。这是我们执行常规代码的地方。

#### 26.3.2 `catch`子句

如果在`try`块内部（可能在函数/方法调用的树中深度嵌套）抛出异常，则执行切换到`catch`子句，其中参数引用异常。之后，执行通常在`try`语句之后继续。如果以下情况发生，这可能会改变：

+   在`catch`块内部有一个`return`、`break`或`throw`。

+   有一个`finally`子句（它在`try`语句结束时总是执行）。

以下代码演示了在行 A 抛出的值确实在行 B 中被捕获。

```js
const errorObject = new Error();
function func() {
 throw errorObject; // (A)
}

try {
 func();
} catch (err) { // (B)
 assert.equal(err, errorObject);
}

```

##### 26.3.2.1 省略`catch`绑定^(ES2019)

如果我们不关心抛出的值，我们可以省略`catch`参数：

```js
try {
  // ···
} catch {
  // ···
}

```

这有时可能很有用。例如，Node.js 有一个 API 函数`assert.throws(func)`（[链接](https://nodejs.org/api/assert.html#assert_assert_throws_fn_error_message)），用于检查`func`内部是否抛出错误。它可以如下实现。

```js
function throws(func) {
  try {
    func();
  } catch {
    return; // everything OK
  }
  throw new Error('Function didn’t throw an exception!');
}

```

然而，这个函数的更完整实现将有一个`catch`参数，并且例如，会检查其类型是否符合预期。

#### 26.3.3 `finally`子句

`finally`子句中的代码总是在`try`语句的末尾执行——无论`try`块或`catch`子句中发生什么。

让我们看看`finally`的一个常见用例：我们创建了一个资源，并希望在完成使用后始终销毁它，无论在处理它时发生什么。我们会这样实现：

```js
const resource = createResource();
try {
  // Work with `resource`. Errors may be thrown.
} finally {
  resource.destroy();
}

```

##### 26.3.3.1 `finally`总是执行

即使抛出错误（行 A），`finally`子句也总是执行。

```js
let finallyWasExecuted = false;
assert.throws(
  () => {
    try {
      throw new Error(); // (A)
    } finally {
      finallyWasExecuted = true;
    }
  },
  Error
);
assert.equal(finallyWasExecuted, true);

```

即使有`return`语句（行 A）：

```js
let finallyWasExecuted = false;
function func() {
 try {
 return; // (A)
 } finally {
 finallyWasExecuted = true;
 }
}
func();
assert.equal(finallyWasExecuted, true);

```

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：异常处理**

`exercises/exception-handling/call_function_test.mjs`

### 26.4 所有内置异常类的超类：`Error`

这就是`Error`的实例属性和构造函数的外观：

```js
class Error {
  // Actually a prototype data property
  get name(): string {
    return 'Error';
  }

  // Instance properties
  message: string;
  cause?: unknown; // ES2022
  stack: string; // non-standard but widely supported

  constructor(
 message: string = '',
 options?: ErrorOptions // ES2022
  ) {}
}
interface ErrorOptions {
  cause?: unknown; // ES2022
}

```

构造函数有两个参数：

+   `message`指定错误消息。

+   `options`是在 ECMAScript 2022 中引入的。它包含一个对象，其中目前支持一个属性：

    +   `.cause`指定了（如果有的话）导致当前错误的异常。

下一个子节之后将更详细地解释实例属性`.message`和`.stack`。下一个部分将解释`.cause`。

#### 26.4.1 `Error.prototype.name`

每个内置错误类 `E` 都有一个属性 `E.prototype.name`：

```js
> Error.prototype.name
'Error'
> RangeError.prototype.name
'RangeError'

```

因此，有两种方式来获取内置错误对象的类名：

```js
> new RangeError().name
'RangeError'
> new RangeError().constructor.name
'RangeError'

```

#### 26.4.2 `Error` 实例属性 `.message`

`.message` 只包含错误消息：

```js
const err = new Error('Hello!');
assert.equal(String(err), 'Error: Hello!');
assert.equal(err.message, 'Hello!');

```

如果我们省略了消息，则使用空字符串作为默认值（从 `Error.prototype.message` 继承）：

如果我们省略了消息，它将使用空字符串：

```js
assert.equal(new Error().message, '');

```

#### 26.4.3 `Error` 实例属性 `.stack`

实例属性 `.stack` 不是一个 ECMAScript 功能，但它被 JavaScript 引擎广泛支持。它通常是一个字符串，但它的确切结构没有标准化，并且在不同引擎之间有所不同。

这是在 JavaScript 引擎 V8 中的样子：

```js
function h(z) {
  const error = new Error();
  console.log(error.stack);
}
function g(y) {
  h(y + 1);
}
function f(x) {
  g(x + 1);
}
f(3);

```

输出：

```js
Error
    at h (demos/async-js/stack_trace.mjs:2:17)
    at g (demos/async-js/stack_trace.mjs:6:3)
    at f (demos/async-js/stack_trace.mjs:9:3)
    at demos/async-js/stack_trace.mjs:11:1

```

这个 *堆栈跟踪*（调用栈的跟踪）的第一行显示 `Error` 是在行 2 处创建的。最后一行显示一切始于行 11。

### 26.5 链式错误：实例属性 `.cause` (ES2022)

实例属性 `.cause` 是通过 `new Error()` 的第二个参数中的选项对象创建的。它指定了哪个其他错误导致了当前错误。

```js
const err = new Error('msg', {cause: 'the cause'});
assert.equal(err.cause, 'the cause');

```

#### 26.5.1 我们为什么想要链式错误？

有时，我们会捕获在更深层次的函数调用中抛出的错误，并希望附加更多信息到它：

```js
function readFiles(filePaths) {
  return filePaths.map(
    (filePath) => {
      try {
        const text = readText(filePath);
        const json = JSON.parse(text);
        return processJson(json);
      } catch (error) {
        throw new Error( // (A)
          `While processing ${filePath}`,
          {cause: error}
        );
      }
    });
}

```

`try` 语句块内的语句可能会抛出各种错误。在那些错误被抛出的位置，通常没有意识到导致它们的文件。这就是为什么我们在行 A 处附加那个信息。

如果错误在控制台（例如，因为它被捕获或记录）显示，或者如果我们使用 Node 的 `util.inspect()`（行 A），我们可以看到原因及其堆栈跟踪：

```js
import assert from 'node:assert/strict';
import * as util from 'node:util';

outerFunction();

function outerFunction() {
 try {
 innerFunction();
 } catch (err) {
 const errorWithCause = new Error(
 'Outer error', {cause: err}
 );
 assert.deepEqual(
 util.inspect(errorWithCause).split(/\r?\n/), // (A)
 [
 'Error: Outer error',
 '    at outerFunction (file:///tmp/main.mjs:10:28)',
 '    at file:///tmp/main.mjs:4:1',
 '    ... 2 lines matching cause stack trace ...',
 '  [cause]: TypeError: The cause',
 '      at innerFunction (file:///tmp/main.mjs:31:9)',
 '      at outerFunction (file:///tmp/main.mjs:8:5)',
 '      at file:///tmp/main.mjs:4:1',
 '}',
 ]
 );
 }
}

function innerFunction() {
 throw new TypeError('The cause');
} 
```

殊可惜，如果我们将错误转换为字符串或查看其 `.stack`，就无法看到原因。

#### 26.5.2 我们应该在 `.cause` 中存储上下文数据吗？

`error.cause` 不仅适用于 `Error` 的实例；我们存储在其中的任何数据都会被正确显示：

```js
import assert from 'node:assert/strict';
import * as util from 'node:util';

const error = new Error(
  'Could not reach server', {
    cause: {server: 'https://127.0.0.1'}
  }
);
assert.deepEqual(
  util.inspect(error).split(/\r?\n/),
  [
    "Error: Could not reach server",
    "    at file:///tmp/main.mjs:4:15",
    "  [cause]: { server: 'https://127.0.0.1' }",
    "}",
  ]
);

```

有些人推荐使用 `.cause` 来提供错误的数据上下文。这样做有哪些优点和缺点？

+   优点：上下文数据会与错误一起优雅地显示。

+   缺点：

    +   `.cause` 只支持任意数据，因为在 JavaScript 中，我们可以 `throw` 任意数据。将其用于非抛出数据意味着我们有点误用了这个机制。

    +   如果我们使用 `.cause` 作为上下文数据，就无法再链式抛出异常了。

### 26.6 `Error` 的子类

#### 26.6.1 `Error` 的内置子类

`Error` 有以下子类 – 引用 [ECMAScript 规范](https://tc39.es/ecma262/#sec-native-error-types-used-in-this-standard)：

+   `AggregateError` (ES2021) 表示同时发生的多个错误。在标准库中，只有 `Promise.any()` 使用它。

+   `RangeError` 表示一个不在允许值集合或范围内的值。

+   `ReferenceError` 表示检测到无效的引用值。

+   `SyntaxError` 表示发生了解析错误。

+   `TypeError` 用于指示当其他任何 *NativeError* 对象都不是适当的失败原因指示时，操作不成功。

+   `URIError` 表示在全局 URI 处理函数的使用方式与其定义不兼容。

#### 26.6.2 继承 `Error`

自从 ECMAScript 2022 以来，`Error` 构造函数接受两个参数（参见前一小节）。因此，在继承它时，我们有两种选择：我们可以在我们的子类中省略构造函数，或者我们可以像这样调用 `super()`：

```js
class MyCustomError extends Error {
  constructor(message, options) {
    super(message, options);
    // ···
  }
}

```
