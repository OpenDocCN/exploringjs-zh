# 13 变量和赋值

> 原文：[`exploringjs.com/js/book/ch_variables-assignment.html`](https://exploringjs.com/js/book/ch_variables-assignment.html)

1.  13.1 `let`

1.  13.2 `const`

    1.  13.2.1 `const`和不可变性

    1.  13.2.2 `const`和循环

1.  13.3 在`const`和`let`之间做出选择

1.  13.4 变量的作用域

    1.  13.4.1 变量的遮蔽

1.  13.5 (高级)

1.  13.6 术语：静态与动态

    1.  13.6.1 静态现象：变量的作用域

    1.  13.6.2 动态现象：函数调用

1.  13.7 JavaScript 全局变量的作用域

    1.  13.7.1 `globalThis` (ES2020)

1.  13.8 声明：作用域和激活

    1.  13.8.1 `const`和`let`：临时死区

    1.  13.8.2 函数声明和早期激活

    1.  13.8.3 类声明不会早期激活

    1.  13.8.4 `var`：提升（部分早期激活）

1.  13.9 闭包

    1.  13.9.1 绑定变量与自由变量

    1.  13.9.2 什么是闭包？

    1.  13.9.3 示例：增量器工厂

    1.  13.9.4 闭包的使用场景

这些是 JavaScript 声明变量的主要方式：

+   `let`声明可变变量。

+   `const`声明*常量*（不可变变量）。

在 ES6 之前，也存在`var`。但它有几个怪癖，所以在现代 JavaScript 中最好避免使用它。你可以在[*Speaking JavaScript*](http://exploringjs.com/es5/ch16.html)中了解更多相关信息。

### 13.1 `let`

通过`let`声明的变量是可变的：

```js
let i;
i = 0;
i = i + 1;
assert.equal(i, 1);

```

我们也可以同时声明和赋值：

```js
let i = 0;

```

### 13.2 `const`

通过`const`声明的变量是不可变的。我们必须始终立即初始化：

```js
const i = 0; // must initialize

assert.throws(
  () => { i = i + 1 },
  {
    name: 'TypeError',
    message: 'Assignment to constant variable.',
  }
);

```

#### 13.2.1 `const`和不可变性

在 JavaScript 中，`const`仅意味着*绑定*（变量名与变量值之间的关联）是不可变的。值本身可能是可变的，如下面的示例中的`obj`。

```js
const obj = { prop: 0 };

// Allowed: changing properties of `obj`
obj.prop = obj.prop + 1;
assert.equal(obj.prop, 1);

// Not allowed: assigning to `obj`
assert.throws(
  () => { obj = {} },
  {
    name: 'TypeError',
    message: 'Assignment to constant variable.',
  }
);

```

#### 13.2.2 `const`和循环

我们可以在`for-of`循环中使用`const`，其中为每次迭代创建一个新的绑定：

```js
const arr = ['hello', 'world'];
for (const elem of arr) {
  console.log(elem);
}

```

输出：

```js
hello
world

```

在普通的`for`循环中，我们必须使用`let`，然而：

```js
const arr = ['hello', 'world'];
for (let i=0; i<arr.length; i++) {
  const elem = arr[i];
  console.log(elem);
}

```

### 13.3 在`const`和`let`之间做出选择

我推荐以下规则来决定使用`const`还是`let`：

+   `const`表示不可变的绑定，即变量永远不会改变其值。优先选择它。

+   `let`表示变量的值会改变。只有在你不能使用`const`时才使用它。

![“练习”图标](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：`const`**

`exercises/variables-assignment/const_exrc.mjs`

### 13.4 变量的作用域

变量的**作用域**是指程序中可以访问该变量的区域。考虑以下代码。

```js
{ // // Scope A. Accessible: x
  const x = 0;
  assert.equal(x, 0);
  { // Scope B. Accessible: x, y
    const y = 1;
    assert.equal(x, 0);
    assert.equal(y, 1);
    { // Scope C. Accessible: x, y, z
      const z = 2;
      assert.equal(x, 0);
      assert.equal(y, 1);
      assert.equal(z, 2);
    }
  }
}
// Outside. Not accessible: x, y, z
assert.throws(
  () => console.log(x),
  {
    name: 'ReferenceError',
    message: 'x is not defined',
  }
);

```

+   作用域 A 是`x`的**（直接）作用域**。

+   作用域 B 和 C 是作用域 A 的**内部作用域**。

+   作用域 A 是作用域 B 和作用域 C 的**外部作用域**。

每个变量在其直接作用域以及该作用域嵌套的所有作用域中都是可访问的。

通过`const`和`let`声明的变量被称为**块级作用域**，因为它们的作用域始终是最近的包围块。

#### 13.4.1 遮蔽变量

我们不能在同一级别上声明相同的变量两次：

```js
assert.throws(
  () => {
    eval('let x = 1; let x = 2;');
  },
  {
    name: 'SyntaxError',
    message: "Identifier 'x' has already been declared",
  }
);

```

![图标“详情”](img/38ba63de820aae6f94a019538ae0f222.png) **为什么使用`eval()`？**

`eval()` 延迟解析（因此`SyntaxError`），直到`assert.throws()`的回调执行。如果我们没有使用它，当解析此代码时，我们就会得到错误，而`assert.throws()`甚至不会执行。

然而，我们可以嵌套一个块并使用与块外相同的变量名`x`：

```js
const x = 1;
assert.equal(x, 1);
{
  const x = 2;
  assert.equal(x, 2);
}
assert.equal(x, 1);

```

在块内部，内层的`x`是唯一可访问的具有该名称的变量。内层的`x`被称为*遮蔽*外层的`x`。一旦我们离开块，我们就可以再次访问旧值。

### 13.5 (高级)

所有剩余的部分都是高级内容。

### 13.6 术语：静态与动态

这两个形容词描述了编程语言中的现象：

+   **静态**意味着某物与源代码相关，并且可以在不执行代码的情况下确定。

+   **动态**意味着在运行时。

让我们看看这两个术语的例子。

#### 13.6.1 静态现象：变量的作用域

变量作用域是一种静态现象。考虑以下代码：

```js
function f() {
 const x = 3;
 // ···
}

```

`x`是**静态地**（或**词法地**）**作用域**。也就是说，其作用域是固定的，并且在运行时不改变。

变量作用域形成一个静态树（通过静态嵌套）。

#### 13.6.2 动态现象：函数调用

函数调用是一种动态现象。考虑以下代码：

```js
function g(x) {}
function h(y) {
  if (Math.random()) g(y); // (A)
}

```

行 A 中的函数调用是否发生，只能在运行时决定。

函数调用形成一个动态树（通过动态调用）。

### 13.7 JavaScript 的全局变量作用域

JavaScript 的作用域是嵌套的。它们形成一个树：

+   最外层的作用域是树的根。

+   直接包含在该作用域中的作用域是根的子节点。

+   等等。

根也被称为**全局作用域**。在网页浏览器中，唯一直接处于该作用域的位置是脚本的最顶层。全局作用域的变量被称为**全局变量**，在所有地方都可以访问。有两种类型的全局变量：

+   **全局声明变量**是普通变量：

    +   它们只能在脚本的顶层通过 `const`、`let` 和类声明创建。

+   *全局对象变量*存储在所谓的 *全局对象* 的属性中：

    +   它们在脚本的顶层通过 `var` 和函数声明创建。

    +   可以通过全局变量 `globalThis` 访问全局对象。它可以用来创建、读取和删除全局对象变量。

    +   除了这些，全局对象变量像普通变量一样工作。

以下 HTML 片段演示了 `globalThis` 和两种类型的全局变量。

```js
<script>
 const declarativeVariable = 'd';
 var objectVariable = 'o';
</script>
<script>
 // All scripts share the same top-level scope:
 console.log(declarativeVariable); // 'd'
 console.log(objectVariable); // 'o'

 // Not all declarations create properties of the global object:
 console.log(globalThis.declarativeVariable); // undefined
 console.log(globalThis.objectVariable); // 'o'
</script>

```

每个模块都有自己的变量作用域，它是全局作用域的直接子级。因此，存在于模块顶层的变量不是全局的。图 13.1 展示了各种作用域之间的关系。

![](img/52eed01843eedb709d2fd13429ec233c.png)

图 13.1：全局作用域是 JavaScript 的最外层作用域。它有两种类型的变量：*对象变量*（通过 *全局对象* 管理）和正常的 *声明性变量*。每个 ECMAScript 模块都有自己的作用域，该作用域包含在全局作用域中。

#### 13.7.1 `globalThis` (ES2020)

全局变量 `globalThis` 是访问全局对象的标准方式。它的名字来源于它在全局作用域（脚本作用域，不是模块作用域）中与 `this` 的值相同。

![图标“详情”](img/38ba63de820aae6f94a019538ae0f222.png) **`globalThis` 并不总是直接指向全局对象**

例如，在浏览器中，[存在一个间接引用](https://exploringjs.com/deep-js/ch_global-scope.html#window-proxy)。这种间接引用通常不明显，但它确实存在，并且可以被观察到。

##### 13.7.1.1 `globalThis` 的替代方案

以下全局变量让我们可以在 *某些* 平台上访问全局对象：

+   `window`：引用全局对象的经典方式。但在 Node.js 和 Web Workers 中不起作用。

+   `self`：在 Web Workers 和浏览器中普遍可用。但 Node.js 不支持。

+   `global`：仅在 Node.js 中可用。

|  | 主浏览器线程 | Web Workers | Node.js |
| --- | --- | --- | --- |
| `globalThis` | ✔ | ✔ | ✔ |
| `window` | ✔ |  |  |
| `self` | ✔ | ✔ |  |
| `global` |  |  | ✔ |

##### 13.7.1.2 `globalThis` 的用例

由于向后兼容性，全局对象现在被认为是一个错误，JavaScript 无法摆脱。它对性能产生负面影响，并且通常令人困惑。

ECMAScript 6 引入了一些特性，使得避免全局对象变得更加容易——例如：

+   `const`、`let` 和类声明在全局作用域中使用时不会创建全局对象属性。

+   每个 ECMAScript 模块都有自己的局部作用域。

通常，通过变量而不是通过 `globalThis` 的属性访问全局对象变量会更好。前者在所有 JavaScript 平台上始终表现一致。

网上的教程偶尔会通过 `window.globVar` 访问全局变量 `globVar`。但前缀 “`window.`” 是不必要的，我建议省略它：

```js
window.encodeURIComponent(str); // no
encodeURIComponent(str); // yes

```

因此，`globalThis` 的使用案例相对较少——例如：

+   **Polyfills** 为旧版 JavaScript 引擎添加新功能。

+   功能检测，用于找出 JavaScript 引擎支持哪些功能。

### 13.8 声明：作用域和激活

这些是声明的两个关键方面：

+   作用域：声明的实体在哪里可见？这是一个静态特性。

+   激活：我何时可以访问一个实体？这是一个动态特性。某些实体在我们进入它们的作用域时就可以访问。对于其他实体，我们必须等待执行到达它们的声明。

下表总结了各种声明如何处理这些方面：

|  | 作用域 | 激活 | 重复 | 全局属性 |
| --- | --- | --- | --- | --- |
| `const` | 块 | 声明（TDZ） | ✘ | ✘ |
| `let` | 块 | 声明（TDZ） | ✘ | ✘ |
| `function` | 块 (*) | 开始 | ✔ | ✔ |
| `class` | 块 | 声明（TDZ） | ✘ | ✘ |
| `import` | 模块 | 开始 | ✘ | ✘ |
| `var` | 函数 | 开始（部分） | ✔ | ✔ |

(*) 函数声明通常是块级作用域，但在非严格模式下是函数级作用域。

声明的方面：

+   对于大多数构造，它们的作用域是最内层的周围块。有两个例外：

    +   `import` 只能在模块的最顶层使用。

    +   通过 `var` 声明的变量的作用域是其最内层的周围函数（不是块）。

+   构造函数的激活（当我们能够访问它们时）是变化的，将在稍后进行更详细的描述——例如，*TDZ* 表示 *时间死区*。

+   “重复”描述了声明是否可以使用相同的名称（在每个作用域内）使用两次。

+   “全局属性”描述了当声明在脚本的全球作用域中执行时，它是否向全局对象添加属性。

`import` 在 “ECMAScript 模块” (§29.5) 中进行了描述。以下小节将更详细地描述其他构造和现象。

#### 13.8.1 `const` 和 `let`：时间死区

##### 13.8.1.1 在变量声明之前访问变量时应该做什么？

对于 JavaScript，TC39 需要决定如果我们直接访问一个常量，在它的声明之前会发生什么：

```js
{
  console.log(x); // What happens here?
  const x = 123;
}

```

一些可能的方法是：

1.  名称在当前作用域周围的范围内解析。

1.  我们得到 `undefined`。

1.  存在一个错误。

第一种方法被拒绝，因为没有语言中的先例，因此这对 JavaScript 程序员来说可能不直观。

第二种方法被拒绝，因为这样 `x` 就不会是一个常量——它在声明前后会有不同的值。

`let`使用与`const`相同的方法 3，因此它们的工作方式相似，并且很容易在它们之间切换。

##### 13.8.1.2 时间死区

变量进入其作用域和执行其声明之间的时间被称为该变量的*时间死区* (TDZ)：

+   在这段时间内，变量被认为是未初始化的（就像它有一个特殊值一样）。

+   如果我们访问一个未初始化的变量，我们会得到一个`ReferenceError`。

+   一旦我们到达变量声明，该变量将被设置为初始化器的值（通过赋值符号指定）或`undefined`——如果没有初始化器。

以下代码说明了时间死区：

```js
if (true) { // entering scope of `tmp`, TDZ starts
  // `tmp` is uninitialized:
  assert.throws(() => (tmp = 'abc'), ReferenceError);
  assert.throws(() => console.log(tmp), ReferenceError);

  let tmp; // TDZ ends
  assert.equal(tmp, undefined);
}

```

下一个例子表明时间死区确实是*时间的*（与时间相关）：

```js
if (true) { // entering scope of `myVar`, TDZ starts
  const func = () => {
 console.log(myVar); // executed later
 };

 // We are within the TDZ:
 // Accessing `myVar` causes `ReferenceError`

 let myVar = 3; // TDZ ends
 func(); // OK, called outside TDZ
}

```

即使`func()`位于`myVar`声明之前并使用该变量，我们也可以调用`func()`。但我们必须等待`myVar`的时间死区结束。

#### 13.8.2 函数声明和早期激活

![“阅读”图标](img/0fb62b2fc33a72829ae9fb174dedd0d2.png) **更多关于函数的信息**

在本节中，我们正在使用函数——在我们有机会正确学习它们之前。希望一切仍然有意义。如果它没有，请参阅“可调用值” (§27)。

函数声明总是在进入其作用域时执行，无论它在作用域内的位置如何。这使得我们可以在声明函数`funcDecl()`之前调用它。

```js
assert.equal(funcDecl(), 123); // OK
function funcDecl() { return 123; }

```

`funcDecl()`的早期激活意味着前面的代码等同于：

```js
function funcDecl() { return 123; }
assert.equal(funcDecl(), 123);

```

如果我们通过`const`或`let`声明一个函数，那么它不会早期激活。在下面的例子中，我们只能在声明之后使用`arrowFunc()`。

```js
assert.throws(
  () => arrowFunc(), // before declaration
  ReferenceError
);

const arrowFunc = () => { return 123 };

assert.equal(arrowFunc(), 123); // after declaration 

```

##### 13.8.2.1 无早期激活的提前调用

函数`f()`可以调用后来声明且未早期激活的函数`g()`——只要我们在`g()`声明之后调用`f()`：

```js
const f = () => g();
const g = () => 123;

// We call f() after g() was declared:
assert.equal(f(), 123); // OK 
```

模块中的函数通常在其主体完全执行后调用。因此，在模块中，我们很少需要担心函数的顺序（即使它们不是函数声明）。

##### 13.8.2.2 早期激活的陷阱

如果我们依赖于早期激活在声明之前调用一个函数，那么我们需要小心它不会访问未早期激活的数据。

```js
funcDecl();

const MY_STR = 'abc';
function funcDecl() {
 assert.throws(
 () => MY_STR,
 ReferenceError
 );
}

```

如果我们在`MY_STR`声明之后调用`funcDecl()`，问题就会消失。

##### 13.8.2.3 早期激活的优缺点

我们已经看到早期激活有一个陷阱，并且我们可以在不使用它的情况下获得其大部分好处。因此，最好避免早期激活。但我不对此有强烈的看法，并且如前所述，我经常使用函数声明，因为我喜欢它们的语法。

#### 13.8.3 类声明不会提前激活

尽管它们在某些方面与函数声明相似，但类声明不会提前激活：

```js
assert.throws(
  () => new MyClass(),
  ReferenceError
);

class MyClass {}

assert.equal(new MyClass() instanceof MyClass, true);

```

为什么会这样？考虑以下类声明：

```js
class MyClass extends Object {}

```

`extends`运算符的操作数是一个表达式。因此，我们可以这样做：

```js
const identity = x => x;
class MyClass extends identity(Object) {}

```

评估这样的表达式必须在它被提及的位置进行。其他任何地方都会造成混淆。这也解释了为什么类声明不会提前激活。

#### 13.8.4 `var`：提升（部分提前激活）

`var`是声明变量的一种较老的方式，它早于`const`和`let`（现在是首选）。考虑以下`var`声明。

```js
var x = 123;

```

这个声明有两个部分：

+   声明`var x`：`var`声明的变量的作用域是最近的周围函数，而不是最近的周围块，就像大多数其他声明一样。这样的变量在其作用域的开始就已经激活，并使用`undefined`初始化。

+   赋值`x = 123`：赋值始终在原地执行。

以下代码演示了`var`的效果：

```js
function f() {
 // Partial early activation:
 assert.equal(x, undefined);
 if (true) {
 var x = 123;
 // The assignment is executed in place:
 assert.equal(x, 123);
 }
 // Scope is function, not block:
 assert.equal(x, 123);
}

```

### 13.9 闭包

在我们探索闭包之前，我们需要了解绑定变量和自由变量。

#### 13.9.1 绑定变量与自由变量

在每个作用域中，都有一组提到的变量。在这些变量中，我们区分：

+   **绑定变量**是在作用域内声明的。它们是参数和局部变量。

+   **自由变量**是在外部声明的。它们也被称为**非局部变量**。

考虑以下代码：

```js
function func(x) {
  const y = 123;
  console.log(z);
}

```

在`func()`的主体中，`x`和`y`是绑定变量。`z`是自由变量。

#### 13.9.2 什么是闭包？

那么闭包是什么呢？一个**闭包**是一个函数加上对其“出生地”存在的变量的连接。

保持这种连接有什么意义？它为函数的自由变量提供值——例如：

```js
function funcFactory(value) {
  return () => {
    return value;
  };
}

const func = funcFactory('abc');
assert.equal(func(), 'abc'); // (A)

```

`funcFactory`返回一个闭包，并将其分配给`func`。因为`func`与其出生地处的变量有连接，所以当它在行 A 中被调用时，它仍然可以访问自由变量`value`（即使它“逃离”了其作用域”）。

![图标“提示”](img/8440b17bb8219cda9f9405ac83c36db0.png) **所有 JavaScript 函数都是闭包**

JavaScript 通过闭包支持静态作用域。因此，每个函数都是一个闭包。

#### 13.9.3 示例：增量器工厂

以下函数返回**增量器**（这是我刚刚想出的一个名字）。增量器是一个内部存储数字的函数。当它被调用时，它会通过添加参数来更新那个数字，并返回新的值。

```js
function createInc(startValue) {
  return (step) => { // (A)
    startValue += step;
    return startValue;
  };
}
const inc = createInc(5);
assert.equal(inc(2), 7);

```

我们可以看到，在行 A 中创建的函数在自由变量`startValue`中保留了其内部编号。这次，我们不仅从出生作用域中读取，还用它来存储我们更改的数据，这些数据在函数调用之间持续存在。

我们可以通过局部变量在出生作用域中创建更多的存储槽位：

```js
function createInc(startValue) {
  let index = -1;
  return (step) => {
    startValue += step;
    index++;
    return [index, startValue];
  };
}
const inc = createInc(5);
assert.deepEqual(inc(2), [0, 7]);
assert.deepEqual(inc(2), [1, 9]);
assert.deepEqual(inc(2), [2, 11]);

```

#### 13.9.4 使用闭包的场景

闭包有什么好处？

+   首先，它们只是静态作用域的一种实现。因此，它们为回调提供了上下文数据。

+   它们还可以被函数用来存储在函数调用之间持续存在的状态。`createInc()`就是这样一个例子。

+   它们还可以为对象（通过字面量或类产生）提供私有数据。这一机制的具体工作原理在[*探索 ES6*](https://exploringjs.com/es6/ch_classes.html#_private-data-via-constructor-environments)中有详细解释。
