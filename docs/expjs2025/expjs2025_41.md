# 34 数组（数组）

> 原文：[`exploringjs.com/js/book/ch_arrays.html`](https://exploringjs.com/js/book/ch_arrays.html)

1.  34.1 速查表：数组

    1.  34.1.1 使用数组

    1.  34.1.2 最常用的数组方法

1.  34.2 使用数组的方式：固定布局与序列

1.  34.3 基本数组操作

    1.  34.3.1 创建、读取、写入数组

    1.  34.3.2 数组的 `.length` 属性

    1.  34.3.3 通过负索引引用元素

    1.  34.3.4 清除数组

    1.  34.3.5 展开到数组字面量中

    1.  34.3.6 列出数组的索引和条目

    1.  34.3.7 检查值是否为数组：`Array.isArray()`

1.  34.4 `for-of` 和数组

    1.  34.4.1 `for-of`: 遍历元素

    1.  34.4.2 `for-of`: 遍历索引

    1.  [34.4.3 `for-of`: 遍历 [索引, 元素] 对](#forof-iterating-over-index-element-pairs)

1.  34.5 类似数组的对象

1.  34.6 将可迭代对象、迭代器和类似数组值转换为数组

    1.  34.6.1 通过展开 (`...`) 将可迭代对象转换为数组

    1.  34.6.2 通过 `.toArray()` 将迭代器转换为数组（ES2025）

    1.  34.6.3 通过 `Array.from()` 将可迭代对象和类似数组对象转换为数组

1.  34.7 复制数组

1.  34.8 创建和填充任意长度的数组

    1.  34.8.1 创建数组并在之后添加元素

    1.  34.8.2 创建填充原始值的数组

    1.  34.8.3 创建填充对象的数组

    1.  34.8.4 使用整数范围创建数组

    1.  34.8.5 如果元素都是整数或浮点数，则类型化数组工作得很好

1.  34.9 多维数组

1.  34.10 数组实际上是字典（高级）

    1.  34.10.1 数组索引是（略微特殊的）属性键

    1.  34.10.2 数组可以有空洞

1.  34.11 破坏性操作与非破坏性数组操作

    1.  34.11.1 如何使破坏性数组方法变为非破坏性

    1.  34.11.2 `.reverse()`, `.sort()`, `.splice()` 的非破坏性版本（ES2023）

1.  34.12 在数组的两端添加和移除元素

    1.  34.12.1 在数组的两端破坏性地添加和移除元素

    1.  34.12.2 非破坏性地预加和尾加元素

1.  34.13 接受元素回调的数组方法

1.  34.14 使用元素回调进行转换：`.map()`, `.filter()`, `.flatMap()`

    1.  34.14.1 `.map()`: 每个输出元素都由其输入元素派生

    1.  34.14.2 `.filter()`: 只保留一些元素

    1.  34.14.3 `.flatMap()`: 每个输入元素产生零个或多个输出元素^(ES2019)

1.  34.15 `.reduce()`: 为数组计算摘要

    1.  34.15.1 `.reduce()`工作概述

    1.  34.15.2 如果我们省略`init`会发生什么？

    1.  34.15.3 `.reduceRight()`: `.reduce()`的从尾到头的版本

1.  34.16 `.sort()`: 排序数组

    1.  34.16.1 自定义排序顺序

    1.  34.16.2 排序数字

    1.  34.16.3 排序人类语言字符串

    1.  34.16.4 排序对象

1.  34.17 分组数组元素

1.  34.18 快速参考：`Array`

    1.  34.18.1 `new Array()`

    1.  34.18.2 `Array.*`

    1.  34.18.3 `Array.prototype.*`: 获取、设置和访问单个元素

    1.  34.18.4 `Array.prototype.*`: 键和值

    1.  34.18.5 `Array.prototype.*`: 在数组的两端破坏性地添加或移除元素

    1.  34.18.6 `Array.prototype.*`: 合并、提取和更改元素序列

    1.  34.18.7 `Array.prototype.*`: 搜索元素

    1.  34.18.8 `Array.prototype.*`: 过滤和映射

    1.  34.18.9 `Array.prototype.*`: 计算摘要

    1.  34.18.10 `Array.prototype.*`: 转换为字符串

    1.  34.18.11 `Array.prototype.*`: 排序和反转

    1.  34.18.12 快速参考的来源

### 34.1 速查表：数组

JavaScript 数组是一个非常灵活的数据结构，用作列表、栈、队列、元组（例如，对）等。

一些与数组相关的操作会破坏性地更改数组。其他非破坏性地产生新的数组，将更改应用于原始内容的副本。

#### 34.1.1 使用数组

创建数组，读取和写入元素：

```js
// Creating an Array
const arr = ['a', 'b', 'c']; // Array literal
assert.deepEqual(
  arr,
  [ // Array literal
    'a',
    'b',
    'c', // trailing commas are ignored
  ]
);

// Reading elements
assert.equal(
  arr[0], 'a' // negative indices don’t work
);
assert.equal(
  arr.at(-1), 'c' // negative indices work
);

// Writing an element
arr[0] = 'x';
assert.deepEqual(
  arr, ['x', 'b', 'c']
);

```

数组的长度：

```js
const arr = ['a', 'b', 'c'];
assert.equal(
  arr.length, 3 // number of elements
);
arr.length = 1; // removing elements
assert.deepEqual(
  arr, ['a']
);
arr[arr.length] = 'b'; // adding an element
assert.deepEqual(
  arr, ['a', 'b']
);

```

通过 `.push()` 非破坏性地添加元素：

```js
const arr = ['a', 'b'];

arr.push('c'); // adding an element
assert.deepEqual(
  arr, ['a', 'b', 'c']
);

// Pushing Arrays (used as arguments via spreading (...)):
arr.push(...['d', 'e']);
assert.deepEqual(
  arr, ['a', 'b', 'c', 'd', 'e']
);

```

通过扩展（`...`）非破坏性地添加元素：

```js
const arr1 = ['a', 'b'];
const arr2 = ['c'];
assert.deepEqual(
  [...arr1, ...arr2, 'd', 'e'],
  ['a', 'b', 'c', 'd', 'e']
);

```

遍历元素：

```js
const arr = ['a', 'b', 'c'];
for (const value of arr) {
  console.log(value);
}

```

输出：

```js
a
b
c

```

遍历索引-值对：

```js
const arr = ['a', 'b', 'c'];
for (const [index, value] of arr.entries()) {
  console.log(index, value);
}

```

输出：

```js
0 a
1 b
2 c

```

#### 34.1.2 最常用的数组方法

本节演示了一些常见的数组方法。在本章末尾有一个更全面的快速参考 Array。

在开始或末尾破坏性地添加或删除数组元素：

```js
// Adding and removing at the start
const arr1 = ['■', '●'];
arr1.unshift('▲');
assert.deepEqual(
  arr1, ['▲', '■', '●']
);
arr1.shift();
assert.deepEqual(
  arr1, ['■', '●']
);

// Adding and removing at the end
const arr2 = ['■', '●'];
arr2.push('▲');
assert.deepEqual(
  arr2, ['■', '●', '▲']
);
arr2.pop();
assert.deepEqual(
  arr2, ['■', '●']
);

```

查找数组元素：

```js
> ['■', '●', '■'].includes('■')
true
> ['■', '●', '■'].indexOf('■')
0
> ['■', '●', '■'].lastIndexOf('■')
2
> ['●', '', '▲'].find(x => x.length > 0)
'●'
> ['●', '', '▲'].findLast(x => x.length > 0)
'▲'
> ['●', '', '▲'].findIndex(x => x.length > 0)
0
> ['●', '', '▲'].findLastIndex(x => x.length > 0)
2

```

转换数组（创建新的而不改变原始的）：

```js
> ['▲', '●'].map(x => x+x)
['▲▲', '●●']
> ['■', '●', '■'].filter(x => x === '■') 
['■', '■']
> ['▲', '●'].flatMap(x => [x,x])
['▲', '▲', '●', '●']

```

复制数组的部分：

```js
> ['■', '●', '▲'].slice(1, 3)
['●', '▲']
> ['■', '●', '▲'].slice() // complete copy
['■', '●', '▲']

```

连接数组中的字符串：

```js
> ['■','●','▲'].join('-')
'■-●-▲'
> ['■','●','▲'].join('')
'■●▲'

```

`.sort()` 对其接收者进行排序并返回它（如果我们不想改变接收者，可以使用 `.toSorted()`）：

```js
// By default, string representations of the Array elements
// are sorted lexicographically:
const arr = [200, 3, 10];
arr.sort();
assert.deepEqual(
  arr, [10, 200, 3]
);

// Sorting can be customized via a callback:
assert.deepEqual(
  [200, 3, 10].sort((a, z) => a - z), // sort numerically
  [3, 10, 200]
);

```

### 34.2 使用数组的方式：固定布局与序列

这些是两种在 JavaScript 中使用数组最常见的方式：

+   固定布局数组：以这种方式使用，数组具有固定数量的索引元素。这些元素中的每一个都可以有不同的类型。

+   序列数组：以这种方式使用，数组具有可变数量的索引元素。这些元素中的每一个都具有相同的类型。序列数组非常灵活；我们可以将它们用作（传统的）数组、栈和队列。我们将在后面看到。

作为两种方式之间差异的例子，考虑由 `Object.entries()` 返回的数组：

```js
> Object.entries({ a: 1, b: 2, c: 3 })
[
  [ 'a', 1 ],
  [ 'b', 2 ],
  [ 'c', 3 ],
]

```

它是一系列 *对* – 长度为二的固定布局数组。

### 34.3 基本数组操作

#### 34.3.1 创建、读取、写入数组

创建数组最佳的方式是通过 *数组字面量*：

```js
const arr = ['a', 'b', 'c'];

```

数组字面量以方括号 `[]` 开始和结束。它创建了一个包含三个 *元素* 的数组：`'a'`、`'b'` 和 `'c'`。

数组字面量中最后一个元素之后允许并忽略逗号：

```js
const arr = [
  'a',
  'b',
  'c',
];

```

要读取数组元素，我们在方括号中放置一个索引（索引从零开始）：

```js
const arr = ['a', 'b', 'c'];
assert.equal(arr[0], 'a');

```

要更改数组元素，我们通过索引分配给数组：

```js
const arr = ['a', 'b', 'c'];
arr[0] = 'x';
assert.deepEqual(arr, ['x', 'b', 'c']);

```

数组索引的范围是 32 位（不包括最大长度）：0, 2³²−1)

#### [34.3.2 数组的 `.length`

每个数组都有一个属性 `.length`，可以用来读取和更改（！）数组中的元素数量。

数组的长度始终是最高索引加一：

```js
const arr = ['a', 'b'];
assert.equal(arr.length, 2);

```

如果我们在长度的索引处写入数组，我们将追加一个元素：

```js
arr[arr.length] = 'c';
assert.deepEqual(
  arr, ['a', 'b', 'c']
);
assert.equal(arr.length, 3)

```

如果我们设置 `.length`，我们将修剪数组并移除元素：

```js
arr.length = 1;
assert.deepEqual(
  arr, ['a']
);

```

要（破坏性地）追加一个元素，我们也可以使用数组方法 `.push()`：

```js
const arr = ['a', 'b'];
arr.push('c');
assert.deepEqual(
  arr, ['a', 'b', 'c']
);

```

![练习图标“exercise”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：通过 `.push()` 删除空行**

`exercises/arrays/remove_empty_lines_push_test.mjs`

#### 34.3.3   通过负索引引用元素

大多数数组方法支持负索引。如果索引是负数，则将其添加到数组的长度中，以产生一个可用的索引。因此，以下两个 `.slice()` 调用是等效的：它们都从 `arr` 的最后一个元素开始复制。

```js
> const arr = ['a', 'b', 'c'];
> arr.slice(-1)
[ 'c' ]
> arr.slice(arr.length - 1)
[ 'c' ]

```

##### 34.3.3.1   `.at()`：读取单个元素（支持负索引）^(ES2022)

数组方法 `.at()` 返回给定索引处的元素。它支持正索引和负索引（`-1` 指的是最后一个元素，`-2` 指的是倒数第二个元素等）：

```js
> ['a', 'b', 'c'].at(0)
'a'
> ['a', 'b', 'c'].at(-1)
'c'

```

相比之下，方括号运算符 `[]` 不支持负索引（并且不能更改，因为这会破坏现有代码）。它将它们解释为非元素属性的键：

```js
const arr = ['a', 'b', 'c'];

arr[-1] = 'non-element property';
// The Array elements didn’t change:
assert.deepEqual(
  Array.from(arr), // copy just the Array elements
  ['a', 'b', 'c']
);

assert.equal(
  arr[-1], 'non-element property'
);

```

#### 34.3.4   清除数组

我们可以通过将 `.length` 设置为零来清除数组：

```js
const arr = ['a', 'b', 'c'];
arr.length = 0;
assert.deepEqual(arr, []);

```

我们还可以将一个新的空数组赋值给存储数组的变量：

```js
let arr = ['a', 'b', 'c'];
arr = [];
assert.deepEqual(arr, []);

```

后者方法的优势在于不会影响指向同一数组的其他位置。如果我们确实想为每个人重置共享的数组，则需要使用前者方法。

#### 34.3.5   展开到数组字面量

在数组字面量内部，一个 *展开元素* 由三个点 (`...`) 后跟一个表达式组成。它会导致表达式被评估然后迭代。每个迭代的值都成为额外的数组元素 – 例如：

```js
> const iterable = ['b', 'c'];
> ['a', ...iterable, 'd']
[ 'a', 'b', 'c', 'd' ]

```

这意味着我们可以将任何可迭代对象转换为数组：

```js
const iterable = new Set(['x', 'y']);
assert.deepEqual(
  [...iterable],
  ['x', 'y']
);

```

由于数组是可迭代的，我们可以使用展开来复制它们：

```js
const arr = ['a', 'b', 'c'];
const copy = [...arr];

```

展开对于将数组（和其他可迭代对象）连接到数组中也非常方便：

```js
const arr1 = ['a', 'b'];
const arr2 = ['c', 'd'];

const concatenated = [...arr1, ...arr2, 'e'];
assert.deepEqual(
  concatenated,
  ['a', 'b', 'c', 'd', 'e']
);

```

由于迭代时的展开，它仅在值是可迭代的时才有效：

```js
> [...'abc'] // strings are iterable
[ 'a', 'b', 'c' ]
> [...123]
TypeError: 123 is not iterable
> [...undefined]
TypeError: undefined is not iterable

```

#### 34.3.6   数组：列出索引和条目

方法 `.keys()` 列出数组的索引：

```js
const arr = ['a', 'b'];
arr.prop = true; // needed later

assert.deepEqual(
  arr.keys().toArray(), // (A)
  [0, 1]
);

```

`.keys()` 返回一个迭代器。在行 A 中，我们将该迭代器转换为数组。

列出数组索引与列出属性不同。前者产生数字；后者产生字符串化的数字（以及非索引属性键）：

```js
assert.deepEqual(
  Object.keys(arr),
  ['0', '1', 'prop']
);

```

注意到对象属性 `arr.prop` 出现在结果中。

方法 `.entries()` 列出数组的元素内容，以 [索引, 元素] 对的形式：

```js
assert.deepEqual(
  arr.entries().toArray(),
  [
    [0, 'a'],
    [1, 'b'],
  ]
);

```

`Object.entries()` 列出 [属性键，属性值] 对：

```js
assert.deepEqual(
  Object.entries(arr),
  [
    ['0', 'a'],
    ['1', 'b'],
    ['prop', true],
  ]
);

```

我们再次在结果中看到 `arr.prop`。

#### 34.3.7   检查值是否为数组：`Array.isArray()`

`Array.isArray()` 检查一个值是否为数组：

```js
> Array.isArray([])
true

```

我们还可以使用 `instanceof`：

```js
> [] instanceof Array
true

```

然而，`instanceof` 有一个缺点：如果值来自另一个 *领域*，则它不起作用。大致来说，领域是 JavaScript 全局作用域的一个实例。有些领域是相互隔离的（例如，浏览器中的 Web Workers），但也有一些领域之间可以移动数据——例如，浏览器中的同源 iframe。`x instanceof Array` 检查 `x` 的原型链，因此如果 `x` 是来自另一个领域的数组，则返回 `false`。

`typeof` 将数组视为对象：

```js
> typeof []
'object'

```

### 34.4 `for-of` 和数组

我们在本章前面已经遇到了 `for-of` 循环。本节简要回顾了如何使用它来遍历数组。

#### 34.4.1 `for-of`：遍历元素

以下 `for-of` 循环遍历数组的元素：

```js
for (const element of ['a', 'b']) {
  console.log(element);
}

```

输出：

```js
a
b

```

#### 34.4.2 `for-of`：遍历索引

此 `for-of` 循环遍历数组的索引：

```js
for (const element of ['a', 'b'].keys()) {
  console.log(element);
}

```

输出：

```js
0
1

```

#### [34.4.3 `for-of`：遍历 `[索引, 元素]` 对](#forof-iterating-over-index-element-pairs)

以下 `for-of` 循环遍历 `[索引, 元素]` 对。解构（将在 后面 描述），为我们提供了在 `for-of` 循环头部设置 `索引` 和 `元素` 的便捷语法。

```js
for (const [index, element] of ['a', 'b'].entries()) {
  console.log(index, element);
}

```

输出：

```js
0 a
1 b

```

### 34.5 类似数组的对象

一些与数组一起工作的操作只需要最基本的内容：值必须是 *类似数组的*。类似数组的值是一个具有以下属性的对象：

+   `.length`：包含类似数组的对象的长度。如果此属性不存在，则使用值 `0`。

+   `[0]`：包含索引 0 处的元素（等等）。注意，如果我们使用数字作为属性名，它们总是被强制转换为字符串。因此，`[0]` 获取键为 `'0'` 的属性的值。

例如，`Array.from()` 接受类似数组的对象并将它们转换为数组：

```js
// .length is implicitly 0 in this case
assert.deepEqual(
  Array.from({}),
  []
);

assert.deepEqual(
  Array.from({length: 2, 0: 'a', 1: 'b'}),
  [ 'a', 'b' ]
);

```

TypeScript 中类似数组的对象的接口是：

```js
interface ArrayLike<T> {
  length: number;
  [n: number]: T;
}

```

![图标“详情”](img/38ba63de820aae6f94a019538ae0f222.png) **类似数组的对象在现代 JavaScript 中相对较少**

在 ES6 之前，类似数组的对象更为常见；现在我们很少看到它们。

### 34.6 将可迭代对象、迭代器和类似数组的值转换为数组

在本节中，我们将探讨如何将各种值转换为数组：

+   通过展开（`...`）将可迭代对象转换为数组

+   通过 `.toArray()` 将迭代器转换为数组

+   通过 `Array.from()` 将可迭代对象和类似数组的对象转换为数组

#### 34.6.1 通过展开（`...`）将可迭代对象转换为数组

在数组字面量内部，通过 `...` 展开，可以将任何可迭代对象转换为一系列数组元素。例如：

```js
const iterable = new Set(['a', 'b']);
assert.deepEqual(
  [...iterable],
  ['a', 'b']
);

```

#### 34.6.2 通过 `.toArray()` 将迭代器转换为数组（ES2025）

如果我们有一个迭代器，我们可以使用方法 `.toArray()` 将其值存储在数组中：

```js
const iterable = new Set(['a', 'b']);
assert.deepEqual(
  Iterator.from(iterable).toArray(),
  ['a', 'b']
);

```

除了 `Iterator.from()`，我们还可以使用返回迭代器的方法（例如 `.keys()`、`.values()` 和 `.entries()`）：

```js
assert.deepEqual(
  iterable.values().toArray(),
  ['a', 'b']
);

```

#### 34.6.3 通过 `Array.from()` 将可迭代和类似数组的对象转换为数组

`Array.from()` 可以在两种模式下使用。

##### 34.6.3.1 `Array.from()` 的第一种模式：转换

第一种模式具有以下类型签名：

```js
.from<T>(iterable: Iterable<T> | ArrayLike<T>): Array<T>

```

接口 `Iterable` 在同步迭代章节中展示。接口 `ArrayLike` 在本章较早的部分出现。

使用单个参数，`Array.from()` 将任何可迭代或类似数组的对象转换为数组：

```js
> Array.from(new Set(['a', 'b'])) // iterable
[ 'a', 'b' ]
> Array.from({length: 2, 0:'a', 1:'b'}) // Array-like
[ 'a', 'b' ]

```

##### 34.6.3.2 `Array.from()` 的第二种模式：转换和映射

`Array.from()` 的第二种模式涉及两个参数：

```js
.from<T, U>(
  iterable: Iterable<T> | ArrayLike<T>,
  mapFunc: (v: T, i: number) => U,
  thisArg?: any
): Array<U>

```

在这种模式下，`Array.from()` 做了几件事情：

+   它遍历 `iterable`。

+   它使用每个迭代的值调用 `mapFunc`。可选参数 `thisArg` 指定了 `mapFunc` 的 `this`。

+   它将 `mapFunc` 应用到每个迭代的值上。

+   它将结果收集到一个新数组中并返回它。

换句话说：我们从一个元素类型为 `T` 的可迭代对象转换到一个元素类型为 `U` 的数组。

这是一个示例：

```js
> Array.from(new Set(['a', 'b']), x => x + x)
[ 'aa', 'bb' ]

```

### 34.7 复制数组

以下代码展示了复制数组 `arr` 的五种方式：

```js
const arr = ['a', 'b'];

const shallowCopy1 = arr.slice();
const shallowCopy2 = Array.from(arr);
const shallowCopy3 = [...arr];
const shallowCopy4 = arr.values().toArray();

const deepCopy = structuredClone(arr);

const copies = [
  shallowCopy1, shallowCopy2, shallowCopy3, shallowCopy4, deepCopy
];
for (const copy of copies) {
  assert.deepEqual(copy, arr);
}

```

只有 `structuredClone()` 产生一个 *深拷贝*。在其他情况下，拷贝是 *浅拷贝*：它包含 [索引，元素] 条目的副本，但元素本身与原始数组共享。有关更多信息，包括 `structuredClone()` 的限制，请参阅“复制对象：展开与 `Object.assign()` 与 `structuredClone()`”（§30.5）。

### 34.8 创建和填充任意长度的数组

创建数组的最佳方式是通过数组字面量。然而，我们并不总是可以使用它：数组可能太大，我们在开发过程中可能不知道它的长度，或者我们可能希望保持其长度灵活。那么，我推荐以下技术来创建，并可能填充，数组。

#### 34.8.1 创建数组并在之后添加元素

创建数组并在之后添加元素的最常见技术是先从一个空数组开始，然后将值推入其中：

```js
const arr = [];
for (let i=0; i<3; i++) {
  arr.push('*'.repeat(i));
}
assert.deepEqual(
  arr, ['', '*', '**']
);

```

#### 34.8.2 创建填充了原始值的数组

以下代码创建了一个填充了原始值的数组：

```js
> new Array(3).fill(0)
[ 0, 0, 0 ]

```

`.fill()` 将每个数组元素或空位替换为给定的值。我们用它来填充一个有 3 个空位的数组：

```js
> new Array(3)
[ , , ,]

```

注意，结果有三个 *空位*（空槽）- 数组字面量中的最后一个逗号总是被忽略。

#### 34.8.3 创建填充了对象的数组

如果我们使用 `.fill()` 与一个对象，那么每个数组元素都将引用这个相同的单个对象：

```js
const arr = new Array(3).fill({});
arr[0].prop = true;
assert.deepEqual(
  arr, [
    {prop: true},
    {prop: true},
    {prop: true},
  ]);

```

我们该如何解决这个问题？我们可以使用 `Array.from()`：

```js
> Array.from(new Array(3), () => ({}))
[{}, {}, {}]

```

使用两个参数调用 `Array.from()`：

+   提取第一个参数（必须是可迭代的或类似数组的）的元素，

+   通过第二个参数中的回调函数映射它们，

+   将结果返回为数组。

与 `.fill()` 不同，它多次重用同一个对象，之前的代码为每个元素创建了一个新对象。

在这种情况下，我们能否使用 `.map()`？不幸的是，不能，因为 `.map()` 忽略但保留空位（而 `Array.from()` 将它们视为 `undefined` 元素）：

```js
> new Array(3).map(() => ({}))
[ , , ,]

```

对于较大的尺寸，第一个参数中的临时数组可能会消耗相当多的内存。以下方法没有这个缺点，但描述性较差：

```js
> Array.from({length: 3}, () => ({}))
[{}, {}, {}]

```

我们不是使用临时数组，而是使用一个临时的 类似数组的对象。

#### 34.8.4 使用一系列整数创建数组

要创建一个包含一系列整数的数组，我们使用 `Array.from()` 的方式与之前小节中的用法类似：

```js
function createRange(start, end) {
  return Array.from({length: end-start}, (_, i) => i+start);
}
assert.deepEqual(
  createRange(2, 5),
  [2, 3, 4]);

```

这里有一个创建从零开始的整数范围的替代方法，稍微有点技巧性：

```js
/** Returns an iterable */
function createRange(end) {
  return new Array(end).keys();
}
assert.deepEqual(
  Array.from(createRange(4)),
  [0, 1, 2, 3]
);

```

这之所以有效，是因为 `.keys()` 将 *空位* 当作 `undefined` 元素处理，并列出它们的索引。

#### 34.8.5 如果元素都是整数或浮点数，则类型化数组工作得很好

当处理整数或浮点数数组时，我们应该考虑 *类型化数组*，它们是为了这个目的而创建的。

### 34.9 多维数组

JavaScript 没有真正的多维数组；我们需要求助于元素也是数组的数组：

```js
function initMultiArray(...dimensions) {
  function initMultiArrayRec(dimIndex) {
    if (dimIndex >= dimensions.length) {
      return 0;
    } else {
      const dim = dimensions[dimIndex];
      const arr = [];
      for (let i=0; i<dim; i++) {
        arr.push(initMultiArrayRec(dimIndex+1));
      }
      return arr;
    }
  }
  return initMultiArrayRec(0);
}

const arr = initMultiArray(4, 3, 2);
arr[3][2][1] = 'X'; // last in each dimension
assert.deepEqual(arr, [
  [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ],
  [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ],
  [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ],
  [ [ 0, 0 ], [ 0, 0 ], [ 0, 'X' ] ],
]);

```

### 34.10 数组实际上是字典（高级）

在本节中，我们考察数组如何确切地存储它们的元素：在属性中。我们通常不需要知道这一点，但它有助于理解一些较少见的数组现象。

#### 34.10.1 数组索引是（稍微特殊一点的）属性键

你可能会认为数组元素是特殊的，因为我们通过数字访问它们。但用于这样做的方括号运算符 `[]` 与用于访问属性的运算符相同。它将任何非符号值强制转换为字符串。因此，数组元素（几乎）是正常属性（行 A），我们使用数字或字符串作为索引（行 B 和行 C）并没有关系：

```js
const arr = ['a', 'b'];
arr.prop = 123;
assert.deepEqual(
  Object.keys(arr),
  ['0', '1', 'prop'] // (A)
);

assert.equal(arr[0], 'a');  // (B)
assert.equal(arr['0'], 'a'); // (C)

```

用于数组元素的属性键（字符串！）被称为 [*索引*](https://tc39.es/ecma262/#integer-index)。一个字符串 `str` 是索引，如果将其转换为 32 位无符号整数再转换回来，结果仍然是原始值。用公式表示：

```js
ToString(ToUint32(str)) === str

```

##### 34.10.1.1 内部，JavaScript 引擎优化了数组的管理方式

在使用 JavaScript 和 ECMAScript 规范时，数组元素是属性，数组索引是字符串值属性键。

然而，在内部，几乎所有的 JavaScript 引擎都优化了数组的管理方式：它们按顺序存储元素，并使用索引作为数字偏移量。如果数组的元素不是连续的，引擎可能会切换到更类似字典的表示形式 – 如果它们之间有空位。关于数组中空位的更多内容将在后面介绍。

##### 34.10.1.2 列出索引

当列出属性键时，索引被特别处理 – 它们总是排在最前面，并且像数字一样排序（`'2'` 在 `'10'` 之前）：

```js
const arr = [];
arr.prop = true;
arr[1] = 'b';
arr[0] = 'a';

assert.deepEqual(
  Object.keys(arr),
  ['0', '1', 'prop']
);
assert.deepEqual(
  Object.entries(arr),
  [['0', 'a'], ['1', 'b'], ['prop', true]]
);

```

注意，`.keys()` 和 `.entries()` 将数组索引视为数字，并忽略非索引属性：

```js
assert.deepEqual(
  Array.from(arr.keys()),
  [0, 1]
);
assert.deepEqual(
  Array.from(arr.entries()),
  [[0, 'a'], [1, 'b']]
);

```

我们使用了 `Array.from()` 来将 `.keys()` 和 `.entries()` 返回的可迭代对象转换为数组。

#### 34.10.2 数组可以有空位

在 JavaScript 中，我们区分两种数组：

+   如果所有索引 `i`（其中 0 ≤ `i` < `arr.length`）都存在，数组 `arr` 就是 *密集的*。也就是说，索引形成一个连续的范围。

+   如果索引范围中有空位，数组就是 *稀疏的*。也就是说，某些索引缺失。

由于数组实际上是索引到值的字典，JavaScript 中的数组可以是稀疏的。

![图标“提示”](img/8440b17bb8219cda9f9405ac83c36db0.png) **建议：避免空位**

到目前为止，我们只看到了密集数组，并且确实建议避免空位：它们使我们的代码更复杂，并且数组方法处理它们的方式并不一致。此外，JavaScript 引擎优化密集数组，使它们更快。

##### 34.10.2.1 创建数组空位

我们可以通过在分配元素时跳过索引来创建空位：

```js
const arr = [];
arr[0] = 'a';
arr[2] = 'c';

assert.deepEqual(Object.keys(arr), ['0', '2']); // (A)

assert.equal(0 in arr, true); // element
assert.equal(1 in arr, false); // hole

```

在行 A 中，我们使用 `Object.keys()`，因为 `arr.keys()` 将空位视为 `undefined` 元素，并且不会揭示它们。

创建空位的另一种方法是省略数组字面量中的元素：

```js
const arr = ['a', , 'c'];

assert.deepEqual(Object.keys(arr), ['0', '2']);

```

我们也可以通过增加 `.length` 来在末尾添加空位：

```js
const arr = ['a'];
assert.deepEqual(Object.keys(arr), ['0']);
assert.equal(arr.length, 1);
arr.length = 3;
arr.push('x');
assert.deepEqual(Object.keys(arr), ['0', '3']);
assert.deepEqual(arr, ['a', /*hole*/, /*hole*/, 'x']);

```

删除数组元素也会创建空位：

```js
const arr = ['a', 'b', 'c'];
assert.deepEqual(Object.keys(arr), ['0', '1', '2']);
delete arr[1];
assert.deepEqual(Object.keys(arr), ['0', '2']);
assert.deepEqual(arr, ['a', , 'c']);

```

##### 34.10.2.2 数组操作如何处理空位？

然而，数组操作处理空位的方式有很多种。

一些数组操作会移除空位：

```js
> ['a',,'b'].filter(x => true)
[ 'a', 'b' ]

```

一些数组操作会忽略空位：

```js
> ['a', ,'a'].every(x => x === 'a')
true

```

一些数组操作忽略但保留空位：

```js
> ['a',,'b'].map(x => 'c')
[ 'c', , 'c' ]

```

一些数组操作将空位视为 `undefined` 元素：

```js
> Array.from(['a',,'b'])
[ 'a', undefined, 'b' ]
> Array.from(['a',,'b'], x => x + '!') // mapping
[ 'a!', 'undefined!', 'b!' ]
> ['a',,'b'].entries().toArray()
[[0, 'a'], [1, undefined], [2, 'b']]

```

`Object.keys()` 的工作方式与 `.keys()` 不同（字符串 vs. 数字，空位没有键）：

```js
> ['a',,'b'].keys().toArray()
[ 0, 1, 2 ]
> Object.keys(['a',,'b'])
[ '0', '2' ]

```

这里没有共同的规则可以记住。如果某个数组操作如何处理空位很重要，最佳方法是快速在控制台中测试。

### 34.11 数组操作：破坏性 vs. 非破坏性

一些数组操作是 *破坏性的*：它们会改变它们操作的数组 – 例如，设置一个元素：

```js
const arr = ['a', 'b', 'c'];

arr[1] = 'x';
assert.deepEqual(
  // The original was modified
  arr, ['a', 'x', 'c']
);

```

其他数组操作是非破坏性的：它们产生包含所需更改的新数组，而不触及原始数组 – 例如，方法 `.with()` 是设置元素的不可破坏版本：

```js
const arr = ['a', 'b', 'c'];

assert.deepEqual(
  // Produces a copy with changes
  arr.with(1, 'x'),
  ['a', 'x', 'c']
);
assert.deepEqual(
  // The original is unchanged
  arr, [ 'a', 'b', 'c' ]
);

```

#### 34.11.1 如何使破坏性数组方法变为非破坏性

这些是三个常见的破坏性数组方法：

+   `.reverse()`

+   `.sort()`

+   `.splice()`

我们将在本章后面讨论 `.sort()` 和 `.splice()`。`.reverse()` 重新排列数组，使其元素的顺序颠倒：之前最后的元素现在排在第一位；倒数第二个元素排在第二位；等等：

```js
const original = ['a', 'b', 'c'];
const reversed = original.reverse();

assert.deepEqual(reversed, ['c', 'b', 'a']);
assert.ok(reversed === original); // .reverse() returned `this`
assert.deepEqual(original, ['c', 'b', 'a']);

```

为了防止破坏性方法改变数组，我们可以在使用之前创建一个副本 - 例如：

```js
const original = ['a', 'b', 'c'];

const reversed1 = original.slice().reverse();
const reversed2 = Array.from(original).reverse();
const reversed3 = [...original].reverse();
const reversed4 = original.values().toArray().reverse();

assert.deepEqual(original, ['a', 'b', 'c']);

```

另一个选项是使用破坏性方法的非破坏性版本。这正是我们将要探讨的。

#### 34.11.2 `.reverse()`, `.sort()`, `.splice()` 的非破坏性版本 (ES2023)

这些是非破坏性版本的破坏性数组方法 `.reverse()`, `.sort()` 和 `.splice()`：

+   `.toReversed(): Array`

+   `.toSorted(compareFn): Array`

+   `.toSpliced(start, deleteCount, ...items): Array`

我们在前面的小节中使用了 `.reverse()`。它的非破坏性版本的使用方式如下：

```js
const original = ['a', 'b', 'c'];
const reversed = original.toReversed();

assert.deepEqual(reversed, ['c', 'b', 'a']);
// The original is unchanged
assert.deepEqual(original, ['a', 'b', 'c']);

```

### 34.12 在数组两端添加和删除元素

#### 34.12.1 破坏性地在数组两端添加和删除元素

JavaScript 的 `Array` 非常灵活，更像是数组、栈和队列的组合。让我们探讨破坏性地添加和删除数组元素的方法。

`.push()` 在数组的末尾添加元素：

```js
const arr1 = ['a', 'b'];
arr1.push('x', 'y'); // append single elements
assert.deepEqual(arr1, ['a', 'b', 'x', 'y']);

const arr2 = ['a', 'b'];
arr2.push(...['x', 'y']); // (A) append Array
assert.deepEqual(arr2, ['a', 'b', 'x', 'y']);

```

展开参数 (`...`) 是函数调用中的一个特性。在行 A 中，我们使用它来推入一个数组。

`.pop()` 是 `.push()` 的逆操作，并从数组的末尾删除元素：

```js
const arr2 = ['a', 'b', 'c'];
assert.equal(arr2.pop(), 'c');
assert.deepEqual(arr2, ['a', 'b']);

```

`.shift()` 从数组的开头删除元素：

```js
const arr1 = ['a', 'b', 'c'];
assert.equal(arr1.shift(), 'a');
assert.deepEqual(arr1, ['b', 'c']);

```

`.unshift()` 是 `.shift()` 的逆操作，并在数组的开头添加元素：

```js
const arr1 = ['a', 'b'];
arr1.unshift('x', 'y'); // prepend single elements
assert.deepEqual(arr1, ['x', 'y', 'a', 'b']);

const arr2 = ['a', 'b'];
arr2.unshift(...['x', 'y']); // prepend Array
assert.deepEqual(arr2, ['x', 'y', 'a', 'b']);

```

![图标“提示”](img/8440b17bb8219cda9f9405ac83c36db0.png) **提示：记住 `push`、`pop`、`shift` 和 `unshift` 的功能**

我的建议是专注于记住以下两个方法：

+   `.push()` 是这四种方法中最常用的。一个常见的用例是组装输出数组：我们首先将索引 0 的元素推入；然后是索引 1 的元素；等等。

+   `.shift()` 可以用来消耗数组的元素：第一次 shift，我们得到索引 0 的元素；然后是索引 1 的元素；等等。

剩下的两个方法 `pop` 和 `unshift` 是这两个方法的逆操作。

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：通过数组实现队列**

`exercises/arrays/queue_via_array_test.mjs`

#### 34.12.2 非破坏性地在数组两端添加和删除元素

展开元素 (`...`) 是数组字面量的一项特性。在本节中，我们将使用它来非破坏性地向数组前缀和后缀添加元素。

非破坏性前缀：

```js
const arr1 = ['a', 'b'];
assert.deepEqual(
  ['x', 'y', ...arr1], // prepend single elements
  ['x', 'y', 'a', 'b']);
assert.deepEqual(arr1, ['a', 'b']); // unchanged!

const arr2 = ['a', 'b'];
assert.deepEqual(
  [...['x', 'y'], ...arr2], // prepend Array
  ['x', 'y', 'a', 'b']);
assert.deepEqual(arr2, ['a', 'b']); // unchanged!

```

非破坏性追加：

```js
const arr1 = ['a', 'b'];
assert.deepEqual(
  [...arr1, 'x', 'y'], // append single elements
  ['a', 'b', 'x', 'y']);
assert.deepEqual(arr1, ['a', 'b']); // unchanged!

const arr2 = ['a', 'b'];
assert.deepEqual(
  [...arr2, ...['x', 'y']], // append Array
  ['a', 'b', 'x', 'y']);
assert.deepEqual(arr2, ['a', 'b']); // unchanged!

```

### 34.13 接受元素回调的数组方法

以下数组方法接受回调函数，并将数组元素传递给它们：

+   查找：

    +   `.find`

    +   `.findLast`

    +   `.findIndex`

    +   `.findLastIndex`

+   转换：

    +   `.map`

    +   `.flatMap`

    +   `.filter`

+   计算数组的摘要：

    +   `.every`

    +   `.some`

    +   `.reduce`

    +   `.reduceRight`

+   遍历数组：

    +   `.forEach`

元素回调的类型签名如下所示：

```js
callback: (value: T, index: number, array: Array<T>) => boolean

```

即，回调函数得到三个参数（它可以自由忽略任何一个）：

+   `value` 是最重要的一个。此参数持有当前正在处理的数组元素。

+   `index` 可以额外告诉回调函数元素的索引。

+   `array` 指向当前数组（方法调用的接收者）。某些算法需要引用整个数组 - 例如，为了搜索其他数据。此参数使我们能够为这样的算法编写可重用的回调函数。

回调函数预期返回的内容取决于传递给它的方法。可能包括：

+   `.map()` 使用其回调函数返回的值填充其结果：

    ```js
    > ['a', 'b', 'c'].map(x => x + x)
    [ 'aa', 'bb', 'cc' ]

    ```

+   `.find()` 返回第一个回调返回 `true` 的数组元素：

    ```js
    > ['a', 'bb', 'ccc'].find(str => str.length >= 2)
    'bb'

    ```

### 34.14 使用元素回调进行转换：`.map()`, `.filter()`, `.flatMap()`

在本节中，我们探讨接受 元素回调 的方法，这些回调告诉它们如何将输入数组转换为输出数组。

#### 34.14.1 `.map()`: 每个输出元素是从其输入元素派生出来的

输出数组的每个元素都是将回调应用于相应输入元素的结果：

```js
> [1, 2, 3].map(x => x * 3)
[ 3, 6, 9 ]
> ['how', 'are', 'you'].map(str => str.toUpperCase())
[ 'HOW', 'ARE', 'YOU' ]
> [true, true, true].map((_x, index) => index)
[ 0, 1, 2 ]

```

`.map()` 可以实现如下：

```js
function map(arr, mapFunc) {
  const result = [];
  for (const [i, x] of arr.entries()) {
    result.push(mapFunc(x, i, arr));
  }
  return result;
}

```

![Icon “exercise”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：通过 `.map()` 编号行**

`exercises/arrays/number_lines_test.mjs`

#### 34.14.2 `.filter()`: 只保留一些元素

数组方法 `.filter()` 返回一个数组，收集所有回调返回真值（truthy value）的元素。

例如：

```js
> [-1, 2, 5, -7, 6].filter(x => x >= 0)
[ 2, 5, 6 ]
> ['a', 'b', 'c', 'd'].filter((_x,i) => (i%2)===0)
[ 'a', 'c' ]

```

`.filter()` 可以实现如下：

```js
function filter(arr, filterFunc) {
  const result = [];
  for (const [i, x] of arr.entries()) {
    if (filterFunc(x, i, arr)) {
      result.push(x);
    }
  }
  return result;
}

```

![Icon “exercise”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：通过 `.filter()` 删除空行**

`exercises/arrays/remove_empty_lines_filter_test.mjs`

#### 34.14.3 `.flatMap()`: 每个输入元素产生零个或多个输出元素 (ES2019)

`Array<T>.prototype.flatMap()` 的类型签名是：

```js
.flatMap<U>(
  callback: (value: T, index: number, array: Array<T>) => U|Array<U>,
  thisValue?: any
): Array<U>

```

`.map()` 和 `.flatMap()` 都接受一个 `callback` 函数作为参数，该参数控制如何将输入数组转换为输出数组：

+   使用 `.map()`，每个输入数组元素被转换为恰好一个输出元素。也就是说，`callback` 返回一个值。

+   使用 `.flatMap()`，每个输入数组元素被转换为零个或多个输出元素。也就是说，`callback` 返回一个值数组（它也可以返回非数组值，但这很少见）。

下面是 `.flatMap()` 的实际应用：

```js
> ['a', 'b', 'c'].flatMap(x => [x,x])
[ 'a', 'a', 'b', 'b', 'c', 'c' ]
> ['a', 'b', 'c'].flatMap(x => [x])
[ 'a', 'b', 'c' ]
> ['a', 'b', 'c'].flatMap(x => [])
[]

```

在探讨这个方法如何实现之前，我们将考虑一些用例。

##### 34.14.3.1 用例：同时进行过滤和映射

数组方法 `.map()` 的结果总是与它调用的数组具有相同的长度。也就是说，它的回调不能跳过它不感兴趣的数组元素。`.flatMap()` 能够这样做在下一个示例中很有用。

假设，我们从 `Promise.allSettled()`（ch_promises.html#Promise.allSettled）得到了以下结果：

```js
const result = [
  { status: 'fulfilled', value: 'sunshine.jpg' },
  { status: 'rejected', reason: 'FILE NOT FOUND' },
  { status: 'fulfilled', value: 'dog.jpg' },
  { status: 'rejected', reason: 'NOT AUTHORIZED' },
];

```

我们可以使用 `.flatMap()` 从 `results` 中提取仅值或仅错误：

```js
const values = result.flatMap(
  r => r.status === 'fulfilled' ? [r.value] : []
);
assert.deepEqual(
  values, ['sunshine.jpg', 'dog.jpg']
);

const reasons = result.flatMap(
  r => r.status === 'rejected' ? [r.reason] : []
);
assert.deepEqual(
  reasons, ['FILE NOT FOUND', 'NOT AUTHORIZED']
);

```

##### 34.14.3.2 用例：将单个输入值映射到多个输出值

数组方法 `.map()` 将每个输入数组元素映射到一个输出元素。但如果我们想将其映射到多个输出元素呢？

在以下示例中，这变得必要：

```js
> stringsToCodePoints(['many', 'a', 'moon'])
['m', 'a', 'n', 'y', 'a', 'm', 'o', 'o', 'n']

```

我们希望将字符串数组转换为 Unicode 字符数组（代码点）。以下函数通过 `.flatMap()` 实现了这一点：

```js
function stringsToCodePoints(strs) {
  return strs.flatMap(str => Array.from(str));
}

```

##### 34.14.3.3 简单实现

我们可以按以下方式实现 `.flatMap()`。注意：此实现比内置版本简单，例如，它执行了更多的检查。

```js
function flatMap(arr, mapFunc) {
  const result = [];
  for (const [index, elem] of arr.entries()) {
    const x = mapFunc(elem, index, arr);
    // We allow mapFunc() to return non-Arrays
    if (Array.isArray(x)) {
      result.push(...x);
    } else {
      result.push(x);
    }
  }
  return result;
}

```

![Icon “exercise”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：`.flatMap()`**

+   `exercises/arrays/convert_to_numbers_test.mjs`

+   `exercises/arrays/replace_objects_test.mjs`

### 34.15 `.reduce()`: 计算数组的总结

方法 `.reduce()` 是计算数组 `arr` 的“总结”的强大工具。总结可以是任何类型的值：

+   一个数字。例如，`arr` 中所有元素的总和。

+   一个数组。例如，`arr` 的一个副本，其中每个元素是原始元素的两倍。

+   等等。

在函数式编程中，`reduce` 也被称为 `foldl`（“左折叠”），在那里很受欢迎。一个需要注意的问题是，它可能会使代码难以理解。

#### 34.15.1 `.reduce()` 的工作原理概述

我们将从 `.reduce()` 的工作原理概述开始。如果你觉得概述难以理解，你可以跳到示例，稍后再回来。

`.reduce()` 具有以下类型签名（在 `Array<T>` 内部）：

```js
.reduce<U>(
  callback: (accumulator: U, elem: T, idx: number, arr: Array<T>) => U,
  init?: U
): U

```

`T` 是数组元素的类型，`U` 是总结的类型。这两个可能相同，也可能不同。`accumulator` 只是“总结”的另一个名称。

要计算数组 `arr` 的总结，`.reduce()` 将所有数组元素逐个传递给其回调：

```js
const accumulator_0 = callback(init, arr[0]);
const accumulator_1 = callback(accumulator_0, arr[1]);
const accumulator_2 = callback(accumulator_1, arr[2]);
// Etc.

```

+   `init` 为 `accumulator` 提供初始值。

+   累加器包含减法操作的初步结果。当回调函数被调用时，它将累加器与当前数组元素结合并返回结果。该结果成为下一个累加器。

+   `.reduce()` 的结果是最终的累加器——在访问所有元素后 `callback` 的最后一个结果。

换句话说：`callback` 执行了大部分工作；`.reduce()` 只是按有用方式调用它。

我们可以说回调将数组元素折叠到累加器中。这就是为什么在函数式编程中这个操作被称为“折叠”。

#### 示例：对整个数组应用二元运算符

让我们看看 `.reduce()` 的一个实际例子：函数 `addAll()` 计算数组 `arr` 中所有数字的总和。

```js
function addAll(arr) {
  return arr.reduce(
    (sum, element) => sum + element,
    0 // `init` value
  );
}
assert.equal(addAll([1,  2, 3]), 6); // (A)
assert.equal(addAll([7, -4, 2]), 5);

```

在这种情况下，累加器包含 `callback` 已经访问过的所有数组元素的总和。

如何从 A 行的数组中推导出结果 `6`？通过以下 `callback` 的调用：

```js
callback(0, 1) --> 1
callback(1, 2) --> 3
callback(3, 3) --> 6

```

注意：

+   首先的参数是当前累加器（从 `.reduce()` 的参数 `init` 开始）。

+   第二个参数是当前数组元素。

+   结果是下一个累加器。

+   `callback` 的最后一个结果也是 `.reduce()` 的结果。

或者，我们也可以通过 `for-of` 循环来实现 `addAll()`：

```js
function addAll(arr) {
  let sum = 0;
  for (const element of arr) {
    sum = sum + element;
  }
  return sum;
}

```

很难说哪一种实现方式是“更好”的：基于 `.reduce()` 的实现方式稍微简洁一些，而基于 `for-of` 的实现可能更容易理解——特别是如果某人不太熟悉函数式编程的话。

#### 34.15.2 如果省略 `init` 会发生什么？

如果我们将参数 `init` 传递给 `.reduce()`，它就是累加器的初始值：

```js
> [1, 2].reduce((acc, elem) => acc + elem, 100)
103
> [1].reduce((acc, elem) => acc + elem, 100)
101
> [].reduce((acc, elem) => acc + elem, 100)
100

```

如果数组为空，`.reduce()` 的结果就是 `init`。

如果我们省略 `init`，那么 `.reduce()` 将使用第一个数组元素初始化累加器：

```js
> [1, 2].reduce((acc, elem) => acc + elem)
3
> [1].reduce((acc, elem) => acc + elem)
1
> [].reduce((acc, elem) => acc + elem)
TypeError: Reduce of empty array with no initial value

```

如果数组只有一个元素，`.reduce()` 的结果就是该元素。如果数组为空，`.reduce()` 没有返回值，并抛出异常。

以下交互演示了带有和没有 `init` 的 `accumulator` 的初始值：

```js
> ['x', 'a', 'b'].reduce((acc, elem) => acc)
'x'
> ['a', 'b'].reduce((acc, elem) => acc, 'x')
'x'

```

#### 示例：通过 `.reduce()` 查找索引

以下函数是数组方法 `.indexOf()` 的一个实现。它返回给定 `searchValue` 在数组 `arr` 中首次出现的位置索引：

```js
const NOT_FOUND = -1;
function indexOf(arr, searchValue) {
  return arr.reduce(
    (result, elem, index) => {
      if (result !== NOT_FOUND) {
        // We have already found something: don’t change anything
        return result;
      } else if (elem === searchValue) {
        return index;
      } else {
        return NOT_FOUND;
      }
    },
    NOT_FOUND);
}
assert.equal(indexOf(['a', 'b', 'c'], 'b'), 1);
assert.equal(indexOf(['a', 'b', 'c'], 'x'), -1);

```

`.reduce()` 的一个限制是我们不能提前结束。在 `for-of` 循环中，一旦找到结果，我们就可以立即返回。

#### 示例：加倍数组元素

函数 `double(arr)` 返回 `inArr` 的一个副本，其元素都乘以 2：

```js
function double(inArr) {
  return inArr.reduce(
    (outArr, element) => {
      outArr.push(element * 2);
      return outArr;
    },
    []);
}
assert.deepEqual(
  double([1, 2, 3]),
  [2, 4, 6]);

```

我们通过向其中推送来修改初始值 `[]`。`double()` 的一个非破坏性、更函数式的版本如下：

```js
function double(inArr) {
  return inArr.reduce(
    // Don’t change `outArr`, return a fresh Array
    (outArr, element) => [...outArr, element * 2],
    []);
}
assert.deepEqual(
  double([1, 2, 3]),
  [2, 4, 6]);

```

这个版本更优雅，但速度更慢，并且使用更多的内存。

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：`.reduce()`**

+   `map()` 通过 `.reduce()`：`exercises/arrays/map_via_reduce_test.mjs`

+   `filter()` 通过 `.reduce()`：`exercises/arrays/filter_via_reduce_test.mjs`

+   `countMatches()` 通过 `.reduce()`：`exercises/arrays/count_matches_via_reduce_test.mjs`

#### 34.15.3 `.reduceRight()`：`.reduce()` 的末尾到开头版本

`.reduce()` 从开始到结束访问元素：

```js
> ['a', 'b', 'c'].reduce((acc, x) => acc + x)
'abc'

```

`.reduceRight()` 具有相同的功能，但按从末尾到开头的顺序访问元素：

```js
> ['a', 'b', 'c'].reduceRight((acc, x) => acc + x)
'cba'

```

### 34.16 `.sort()`：排序数组

`.sort()` 有以下类型定义：

```js
sort(compareFunc?: (a: T, b: T) => number): this

```

默认情况下，`.sort()` 对元素的字符串表示进行排序。这些表示通过 `<` 进行比较。此运算符按字典顺序比较代码单元值（字符码）：

`.sort()` 在原地排序；它改变并返回其接收者：

```js
> const arr = ['a', 'c', 'b'];
> arr.sort() === arr
true
> arr
[ 'a', 'b', 'c' ]

```

![图标“细节”](img/38ba63de820aae6f94a019538ae0f222.png) **`.sort()` 是稳定的**

自从 ECMAScript 2019 以来，排序保证是稳定的：如果元素在排序中被认为是相等的，那么排序不会改变这些元素的顺序（相对于彼此）。

#### 34.16.1 自定义排序顺序

我们可以通过参数 `compareFunc` 自定义排序顺序，该参数必须返回一个数字，该数字是：

+   如果 `a` 小于 `b`，则返回负数

+   如果 `a` 等于 `b`，则返回零

+   如果 `a` 大于 `b`，则返回正数

我们将在下一小节中看到一个比较函数的例子。

![图标“提示”](img/8440b17bb8219cda9f9405ac83c36db0.png) **记住这些规则的提示**

负数小于零（等等）。

#### 34.16.2 按数字排序数组

字典序排序对数字来说效果不佳：

```js
> [200, 3, 10].sort()
[ 10, 200, 3 ]

```

我们可以通过编写一个比较函数来解决这个问题：

```js
function compareNumbers(a, b) {
  if (a < b) {
    return -1; // any negative number will do
  } else if (a === b) {
    return 0;
  } else {
    return 1; // any positive number will do
  }
}
assert.deepEqual(
  [200, 3, 10].sort(compareNumbers),
  [3, 10, 200]
);

```

![图标“问题”](img/3decb3ca67c240d2bb04742c1f28af18.png) **为什么 `.sort()` 不会自动选择正确的排序方法来处理数字？**

它必须检查所有数组元素并确保它们是数字，然后才能从字典序排序切换到数值排序。

##### 34.16.2.1 排序数字的一个技巧

以下技巧利用了（例如）“小于”的结果可以是任何负数的事实：

```js
> [200, 3, 10].sort((a, z) => a - z)
[ 3, 10, 200 ]

```

+   这次，我们称参数为 `a` 和 `z`，因为这可以提供一个助记符：回调函数按升序排序，“从 `a` 到 `z`” (`a - z`)。

+   这种技巧的缺点是，如果比较一个大的正数和一个大的负数，我们可能会得到算术溢出。

#### 34.16.3 按人类语言字符串排序

当排序人类语言字符串时，我们需要意识到它们是根据它们的代码单元值（字符码）进行比较的：

```js
> ['pie', 'cookie', 'éclair', 'Pie', 'Cookie', 'Éclair'].sort()
[ 'Cookie', 'Pie', 'cookie', 'pie', 'Éclair', 'éclair' ]

```

所有无重音的大写字母都排在所有无重音的小写字母之前，而所有带重音的字母都排在无重音字母之前。如果我们想要为人类语言进行适当的排序，可以使用 `Intl`，[JavaScript 国际化 API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl)：

```js
const arr = ['pie', 'cookie', 'éclair', 'Pie', 'Cookie', 'Éclair'];
assert.deepEqual(
  arr.sort(new Intl.Collator('en').compare),
  ['cookie', 'Cookie', 'éclair', 'Éclair', 'pie', 'Pie']
);

```

#### 34.16.4 排序对象

如果我们想要对对象进行排序，我们还需要使用比较函数。以下代码示例展示了如何按年龄对对象进行排序。

```js
const arr = [ {age: 200}, {age: 3}, {age: 10} ];
assert.deepEqual(
  arr.sort((obj1, obj2) => obj1.age - obj2.age),
  [{ age: 3 }, { age: 10 }, { age: 200 }]
);

```

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：按名称排序对象**

`exercises/arrays/sort_objects_test.mjs`

### 34.17 分组数组元素

通过 `Object.groupBy()` 和 `Map.groupBy()` 进行分组适用于任何可迭代对象，因此也适用于数组：

```js
assert.deepEqual(
  Object.groupBy(
    [0, -5, 3, -4, 8, 9],
    x => Math.sign(x)
  ),
  {
    '0': [0],
    '-1': [-5,-4],
    '1': [3,8,9],
    __proto__: null,
  }
);

```

更多信息：“分组可迭代对象 (ES2024)” (§32.8)

### 34.18 快速参考：`Array`

图例：

+   `R`：方法不改变数组（非破坏性）。

+   `W`：方法改变数组（破坏性）。

**负索引**：如果一个方法支持负索引，这意味着在它们被使用之前，这些索引会被添加到 `.length` 上：`-1` 变为 `this.length-1` 等。换句话说：`-1` 指的是最后一个元素，`-2` 指的是倒数第二个元素，等等。`.at()` 是支持负索引的一个方法：

```js
const arr = ['a', 'b', 'c'];
assert.equal(
  arr.at(-1), 'c'
);

```

#### 34.18.1 `new Array()`

+   `new Array(len = 0)` ES1

    创建一个长度为 `len` 的数组，其中只包含空位：

    ```js
    // Trailing commas are always ignored.
    // Therefore: number of commas = number of holes
    assert.deepEqual(new Array(3), [,,,]);

    ```

#### 34.18.2 `Array.*`

+   `Array.from(iterableOrArrayLike, mapFunc?)` ES6

    ```js
    Array.from<T>(
      iterableOrArrayLike: Iterable<T> | ArrayLike<T>
    ): Array<T>
    Array.from<T, U>(
      iterableOrArrayLike: Iterable<T> | ArrayLike<T>,
      mapFunc: (v: T, k: number) => U, thisArg?: any
    ): Array<U>

    ```

    +   将可迭代对象或 类似数组的对象 转换为数组。

    +   输入值可以通过 `mapFunc` 在它们被添加到输出数组之前进行翻译。

    示例：

    ```js
    > Array.from(new Set(['a', 'b'])) // iterable
    [ 'a', 'b' ]
    > Array.from({length: 2, 0:'a', 1:'b'}) // Array-like object
    [ 'a', 'b' ]

    ```

+   `Array.of(...items)` ES6

    ```js
    Array.of<T>(
      ...items: Array<T>
    ): Array<T>

    ```

    这个静态方法主要用于 `Array` 的子类，其中它充当自定义数组字面量：

    ```js
    class MyArray extends Array {}

    assert.equal(
      MyArray.of('a', 'b') instanceof MyArray, true
    );

    ```

#### 34.18.3 `Array.prototype.*`：获取、设置和访问单个元素

+   `Array.prototype.at(index)`

    ES2022 | 非破坏性

    +   返回 `index` 处的数组元素。如果没有这样的元素，则返回 `undefined`。

    这种方法基本上等同于通过方括号获取元素：

    ```js
    arr[index] === arr.at(index)

    ```

    使用 `.at()` 的一个原因是因为它支持 负索引：

    ```js
    > ['a', 'b', 'c'].at(0)
    'a'
    > ['a', 'b', 'c'].at(-1)
    'c'

    ```

+   `Array.prototype.with(index, value)`

    ES2023 | 非破坏性

    +   返回方法调用接收者的一个不同元素：在 `index` 处现在有 `value`。

    这种方法是通过方括号设置元素的不可破坏版本。它支持负索引：

    ```js
    > ['a', 'b', 'c'].with(2, 'x')
    [ 'a', 'b', 'x' ]
    > ['a', 'b', 'c'].with(-1, 'x')
    [ 'a', 'b', 'x' ]

    ```

+   `Array.prototype.forEach(callback)`

    ES5 | 非破坏性

    ```js
    Array<T>.prototype.forEach(
      callback: (value: T, index: number, array: Array<T>) => void,
      thisArg?: any
    ): void

    ```

    为每个元素调用 `callback`。

    ```js
    ['a', 'b'].forEach(
      (elem) => console.log(elem)
    );
    ['a', 'b'].forEach(
      (elem, index) => console.log(elem, index)
    );

    ```

    输出：

    ```js
    a
    b
    a 0
    b 1

    ```

    `for-of` 循环通常是一个更好的选择：它更快，支持 `break`，并且可以遍历任意可迭代对象。

#### 34.18.4 `Array.prototype.*`：键和值

+   `Array.prototype.keys()`

    ES6 | 非破坏性

    返回接收者键的可迭代对象。

    ```js
    > Array.from(['a', 'b'].keys())
    [ 0, 1 ]

    ```

+   `Array.prototype.values()`

    ES6 | 非修改

    返回接收者值的可迭代对象。

    ```js
    > Array.from(['a', 'b'].values())
    [ 'a', 'b' ]

    ```

+   `Array.prototype.entries()`

    ES6 | 非修改

    返回一个包含接收者元素的索引对的可迭代对象。

    ```js
    > Array.from(['a', 'b'].entries())
    [ [ 0, 'a' ], [ 1, 'b' ] ]

    ```

#### 34.18.5 `Array.prototype.*`: 在数组的两端破坏性地添加或删除元素

+   `Array.prototype.pop()`

    ES3 | 修改

    移除并返回接收者的最后一个元素。也就是说，它将接收者的末尾视为栈。是 `.push()` 的相反操作。

    ```js
    > const arr = ['a', 'b', 'c'];
    > arr.pop()
    'c'
    > arr
    [ 'a', 'b' ]

    ```

+   `Array.prototype.push(...items)`

    ES3 | 修改

    向接收者的末尾添加零个或多个 `items`。也就是说，它将接收者的末尾视为栈。这是 `.pop()` 的相反操作。

    ```js
    > const arr = ['a', 'b'];
    > arr.push('c', 'd')
    4
    > arr
    [ 'a', 'b', 'c', 'd' ]

    ```

    我们可以通过将数组展开（`...`）到参数中来推送一个数组：

    ```js
    > const arr = ['x'];
    > arr.push(...['y', 'z'])
    3
    > arr
    [ 'x', 'y', 'z' ]  

    ```

+   `Array.prototype.shift()`

    ES3 | 修改

    移除并返回接收者的第一个元素。是 `.unshift()` 的逆操作。

    ```js
    > const arr = ['a', 'b', 'c'];
    > arr.shift()
    'a'
    > arr
    [ 'b', 'c' ]

    ```

+   `Array.prototype.unshift(...items)`

    ES3 | 修改

    在 `start` 索引处插入 `items` 并返回修改后的长度。

    ```js
    > const arr = ['c', 'd'];
    > arr.unshift('e', 'f')
    4
    > arr
    [ 'e', 'f', 'c', 'd' ]

    ```

    我们可以通过将数组展开（`...`）到参数中来推送一个数组：

    ```js
    > const arr = ['c'];
    > arr.unshift(...['a', 'b'])
    3
    > arr
    [ 'a', 'b', 'c' ]

    ```

#### 34.18.6 `Array.prototype.*`: 合并、提取和更改元素序列

![图标“提示”](img/8440b17bb8219cda9f9405ac83c36db0.png) **提示：区分 `.slice()` 和 `.splice()`**

+   `.slice()` 更常用。动词“slice”也比动词“splice”更常见。

+   使用 `.splice()` 很少见：元素通常通过 `.filter()`（非破坏性）移除。“Splice” 比 “slice” 多一个字母，该方法也做了更多。

+   `Array.prototype.concat(...items)`

    ES3 | 非修改

    返回一个新的数组，它是接收者和所有 `items` 的连接。非数组参数（如以下示例中的 `'b'`）被视为具有单个元素的数组。

    ```js
    > ['a'].concat('b', ['c', 'd'])
    [ 'a', 'b', 'c', 'd' ]

    ```

+   `Array.prototype.slice(start?, end?)`

    ES3 | 非修改

    返回一个新的数组，包含接收者的元素，其索引在（包括）`start` 和（不包括）`end` 之间。

    ```js
    > ['a', 'b', 'c', 'd'].slice(1, 3)
    [ 'b', 'c' ]
    > ['a', 'b'].slice() // shallow copy
    [ 'a', 'b' ]

    ```

    `.slice()` 支持 负索引：

    ```js
    > ['a', 'b', 'c'].slice(-2)
    [ 'b', 'c' ]

    ```

    它可以用作（浅度）复制数组：

    ```js
    const copy = original.slice();

    ```

+   `Array.prototype.splice(start?, deleteCount?, ...items)`

    ES3 | 修改

    +   在索引 `start`，

    +   移除 `deleteCount` 个元素（默认：所有剩余元素），

    +   将它们替换为 `items`。

    +   它返回被删除的元素。

    +   此方法的非破坏性版本是 `.toSpliced()`。

    ```js
    > const arr = ['a', 'b', 'c', 'd'];
    > arr.splice(1, 2, 'x', 'y')
    [ 'b', 'c' ]
    > arr
    [ 'a', 'x', 'y', 'd' ]

    ```

    如果缺少 `deleteCount`，`.splice()` 会删除直到数组末尾：

    ```js
    > const arr = ['a', 'b', 'c', 'd'];
    > arr.splice(2)
    [ 'c', 'd' ]
    > arr
    [ 'a', 'b' ]

    ```

    `start` 可以是 负数：

    ```js
    > ['a', 'b', 'c'].splice(-2)
    [ 'b', 'c' ]

    ```

+   `Array.prototype.toSpliced(start?, deleteCount?, ...items)`

    ES2023 | 非修改

    +   创建一个新的数组，从索引 `start` 开始，`deleteCount` 个元素被 `items` 替换。

    +   如果 `deleteCount` 缺失，则删除从 `start` 到末尾的所有元素。

    +   此方法的破坏性版本是 `.splice()`。

    ```js
    > const arr = ['a', 'b', 'c', 'd'];
    > arr.toSpliced(1, 2, 'x', 'y')
    [ 'a', 'x', 'y', 'd' ]

    ```

    `start` 可以是 负数：

    ```js
    > ['a', 'b', 'c'].toSpliced(-2)
    [ 'a' ]

    ```

+   `Array.prototype.fill(start=0, end=this.length)`

    ES6 | 修改

    +   返回 `this`。

    +   将 `value` 赋值给从（包括）`start` 到（不包括）`end` 之间的每个索引。

    ```js
    > [0, 1, 2].fill('a')
    [ 'a', 'a', 'a' ]

    ```

    注意：不要使用此方法用对象 `obj` 填充数组；然后每个元素都将引用相同的值（共享它）。在这种情况下，最好 使用 `Array.from()`。

+   `Array.prototype.copyWithin(target, start, end=this.length)`

    ES6 | 修改

    +   返回 `this`。

    将索引范围从（包括）`start` 到（不包括）`end` 的元素复制到以 `target` 开始的索引。正确处理重叠。

    ```js
    > ['a', 'b', 'c', 'd'].copyWithin(0, 2, 4)
    [ 'c', 'd', 'c', 'd' ]

    ```

    `start` 或 `end` 可以是 负数。

#### 34.18.7 `Array.prototype.*`: 搜索元素

+   `Array.prototype.includes(searchElement, fromIndex)`

    ES2016 | 非修改

    如果接收器有一个元素的值是 `searchElement`，则返回 `true`，否则返回 `false`。搜索从索引 `fromIndex` 开始。

    ```js
    > [0, 1, 2].includes(1)
    true
    > [0, 1, 2].includes(5)
    false

    ```

+   `Array.prototype.indexOf(searchElement, fromIndex)`

    ES5 | 非修改

    返回第一个严格等于 `searchElement` 的元素的索引。如果没有这样的元素，则返回 `-1`。从索引 `fromIndex` 开始搜索，然后访问更高的索引。

    ```js
    > ['a', 'b', 'a'].indexOf('a')
    0
    > ['a', 'b', 'a'].indexOf('a', 1)
    2
    > ['a', 'b', 'a'].indexOf('c')
    -1

    ```

+   `Array.prototype.lastIndexOf(searchElement, fromIndex)`

    ES5 | 非修改

    返回最后一个严格等于 `searchElement` 的元素的索引。如果没有这样的元素，则返回 `-1`。从索引 `fromIndex` 开始搜索，然后访问较低的索引。

    ```js
    > ['a', 'b', 'a'].lastIndexOf('a')
    2
    > ['a', 'b', 'a'].lastIndexOf('a', 1)
    0
    > ['a', 'b', 'a'].lastIndexOf('c')
    -1

    ```

+   `Array.prototype.find(predicate, thisArg?)`

    ES6 | 非修改

    ```js
    Array<T>.prototype.find(
      predicate: (value: T, index: number, obj: Array<T>) => boolean,
      thisArg?: any
    ): T | undefined

    ```

    +   从数组的开始到末尾遍历。

    +   返回第一个使 `predicate` 返回真值的元素的值。

    +   如果没有这样的元素，则返回 `undefined`。

    ```js
    > [-1, 2, -3].find(x => x < 0)
    -1
    > [1, 2, 3].find(x => x < 0)
    undefined

    ```

+   `Array.prototype.findLast(predicate, thisArg?)`

    ES2023 | 非修改

    ```js
    Array<T>.prototype.findLast(
      predicate: (value: T, index: number, obj: Array<T>) => boolean,
      thisArg?: any
    ): T | undefined

    ```

    +   从数组的末尾开始遍历数组。

    +   返回第一个使 `predicate` 返回真值的元素的值。

    +   如果没有这样的元素，则返回 `undefined`。

    ```js
    > [-1, 2, -3].findLast(x => x < 0)
    -3
    > [1, 2, 3].findLast(x => x < 0)
    undefined

    ```

+   `Array.prototype.findIndex(predicate, thisArg?)`

    ES6 | 非修改

    ```js
    Array<T>.prototype.findIndex(
      predicate: (value: T, index: number, obj: Array<T>) => boolean,
      thisArg?: any
    ): number

    ```

    +   从数组的开始到末尾遍历。

    +   返回第一个使 `predicate` 返回真值的元素的索引。

    +   如果没有这样的元素，则返回 `-1`。

    ```js
    > [-1, 2, -3].findIndex(x => x < 0)
    0
    > [1, 2, 3].findIndex(x => x < 0)
    -1

    ```

+   `Array.prototype.findLastIndex(predicate, thisArg?)`

    ES2023 | 非修改

    ```js
    Array<T>.prototype.findLastIndex(
      predicate: (value: T, index: number, obj: Array<T>) => boolean,
      thisArg?: any
    ): number

    ```

    +   从数组的末尾开始遍历。

    +   返回第一个使 `predicate` 返回真值的元素的索引。

    +   如果没有这样的元素，则返回 `-1`。

    ```js
    > [-1, 2, -3].findLastIndex(x => x < 0)
    2
    > [1, 2, 3].findLastIndex(x => x < 0)
    -1

    ```

#### 34.18.8 `Array.prototype.*`: 过滤和映射

+   `Array.prototype.filter(predicate, thisArg?)`

    ES5 | 非修改

    ```js
    Array<T>.prototype.filter(
      predicate: (value: T, index: number, array: Array<T>) => boolean,
      thisArg?: any
    ): Array<T>

    ```

    返回一个只包含那些使 `predicate` 返回真值的元素的数组。

    ```js
    > [1, -2, 3].filter(x => x > 0)
    [ 1, 3 ]

    ```

+   `Array.prototype.map(callback, thisArg?)`

    ES5 | 非修改

    ```js
    Array<T>.prototype.map<U>(
      mapFunc: (value: T, index: number, array: Array<T>) => U,
      thisArg?: any
    ): Array<U>

    ```

    返回一个新的数组，其中每个元素都是将 `mapFunc` 应用到接收器相应元素的结果。

    ```js
    > [1, 2, 3].map(x => x * 2)
    [ 2, 4, 6 ]
    > ['a', 'b', 'c'].map((x, i) => i)
    [ 0, 1, 2 ]

    ```

+   `Array.prototype.flatMap(callback, thisArg?)`

    ES2019 | 非修改

    ```js
    Array<T>.prototype.flatMap<U>(
      callback: (value: T, index: number, array: Array<T>) => U|Array<U>,
      thisValue?: any
    ): Array<U>

    ```

    结果是通过为原始数组的每个元素调用 `callback()` 并连接它返回的数组来生成的。

    ```js
    > ['a', 'b', 'c'].flatMap(x => [x,x])
    [ 'a', 'a', 'b', 'b', 'c', 'c' ]
    > ['a', 'b', 'c'].flatMap(x => [x])
    [ 'a', 'b', 'c' ]
    > ['a', 'b', 'c'].flatMap(x => [])
    []

    ```

+   `Array.prototype.flat(depth = 1)`

    ES2019 | 非修改

    “扁平化”一个数组：它进入输入数组内部嵌套的数组，并创建一个副本，其中所有在 `depth` 级别或以下找到的值都移动到顶层。

    ```js
    > [ 1,2, [3,4], [[5,6]] ].flat(0) // no change
    [ 1, 2, [3,4], [[5,6]] ]

    > [ 1,2, [3,4], [[5,6]] ].flat(1)
    [1, 2, 3, 4, [5,6]]

    > [ 1,2, [3,4], [[5,6]] ].flat(2)
    [1, 2, 3, 4, 5, 6]

    ```

#### 34.18.9 `Array.prototype.*`: 计算摘要

+   `Array.prototype.every(predicate, thisArg?)`

    ES5 | 非修改

    ```js
    Array<T>.prototype.every(
      predicate: (value: T, index: number, array: Array<T>) => boolean,
      thisArg?: any
    ): boolean

    ```

    如果 `predicate` 对每个元素都返回一个真值，则返回 `true`。否则，返回 `false`：

    ```js
    > [1, 2, 3].every(x => x > 0)
    true
    > [1, -2, 3].every(x => x > 0)
    false

    ```

    +   如果 `predicate` 返回一个假值，则停止遍历数组（因为结果保证为 `false`）。

    +   对应于数学中的全称量化（“所有”，∀）。

    +   相关方法：`.some()`（“存在”）。

+   `Array.prototype.some(predicate, thisArg?)`

    ES5 | 非修改

    ```js
    Array<T>.prototype.some(
      predicate: (value: T, index: number, array: Array<T>) => boolean,
      thisArg?: any
    ): boolean

    ```

    如果 `predicate` 对至少一个元素返回一个真值，则返回 `true`。否则，返回 `false`。

    ```js
    > [1, 2, 3].some(x => x < 0)
    false
    > [1, -2, 3].some(x => x < 0)
    true

    ```

    +   如果 `predicate` 返回一个真值，则停止遍历数组（因为结果保证为 `true`）。

    +   对应于存在量化（“存在”，∃）在数学中。

    +   相关方法：`.every()`（“所有”）。

+   `Array.prototype.reduce(callback, initialValue?)`

    ES5 | 非修改

    ```js
    Array<T>.prototype.reduce<U>(
      callback: (accumulator: U, elem: T, idx: number, arr: Array<T>) => U,
      initialValue?: U
    ): U

    ```

    此方法生成接收器的摘要：它将所有数组元素传递给 `callback`，该 `callback` 将当前摘要（在参数 `accumulator` 中）与当前数组元素结合，并返回下一个 `accumulator`：

    ```js
    const accumulator_0 = callback(initialValue, arr[0]);
    const accumulator_1 = callback(accumulator_0, arr[1]);
    const accumulator_2 = callback(accumulator_1, arr[2]);
    // Etc.

    ```

    `.reduce()` 的结果是 `callback` 访问所有数组元素后的最后一个结果。

    ```js
    > [1, 2, 3].reduce((accu, x) => accu + x, 0)
    6
    > [1, 2, 3].reduce((accu, x) => accu + String(x), '')
    '123'

    ```

    如果没有提供 `initialValue`，则使用索引 0 的数组元素，并首先访问索引 1 的元素。因此，数组必须至少有长度 1。

+   `Array.prototype.reduceRight(callback, initialValue?)`

    ES5 | 非修改

    ```js
    Array<T>.prototype.reduceRight<U>(
      callback: (accumulator: U, elem: T, idx: number, arr: Array<T>) => U,
      initialValue?: U
    ): U

    ```

    与 `.reduce()` 类似，但按反向顺序遍历数组元素，从最后一个元素开始。

    ```js
    > [1, 2, 3].reduceRight((accu, x) => accu + String(x), '')
    '321'

    ```

#### 34.18.10 `Array.prototype.*`: 转换为字符串

+   `Array.prototype.join(separator = ',')`

    ES1 | 非修改

    通过将所有元素的字符串表示连接起来，并用 `separator` 分隔它们来创建一个字符串。

    ```js
    > ['a', 'b', 'c'].join('##')
    'a##b##c'
    > ['a', 'b', 'c'].join()
    'a,b,c'

    ```

+   `Array.prototype.toString()`

    ES1 | 非修改

    通过 `String()` 将所有元素转换为字符串，在用逗号分隔的同时连接它们，并返回结果。

    ```js
    > [1, 2, 3].toString()
    '1,2,3'
    > ['1', '2', '3'].toString()
    '1,2,3'
    > [].toString()
    ''

    ```

+   `Array.prototype.toLocaleString()`

    ES3 | 非修改

    与 `.toString()` 类似，但在将元素通过逗号分隔并连接成单个字符串之前，通过 `.toLocaleString()` 将其元素转换为字符串（而不是通过 `.toString()`）。

#### 34.18.11 `Array.prototype.*`: 排序和反转

+   `Array.prototype.sort(compareFunc?)`

    ES1 | 破坏性

    ```js
    Array<T>.prototype.sort(
      compareFunc?: (a: T, b: T) => number
    ): this

    ```

    +   对接收者进行排序并返回它。

    +   此方法的非破坏性版本是`.toSorted()`。

    +   按字典顺序对元素的字符串表示进行排序。

    排序数字：

    ```js
    // Default: lexicographical sorting
    assert.deepEqual(
      [200, 3, 10].sort(),
      [10, 200, 3]
    );

    // Ascending numerical sorting (“from a to z”)
    assert.deepEqual(
      [200, 3, 10].sort((a, z) => a - z),
      [3, 10, 200]
    );

    ```

    排序字符串：默认情况下，字符串按代码单元值（字符码）排序，例如，所有无重音的大写字母都排在所有无重音的小写字母之前：

    ```js
    > ['pie', 'cookie', 'éclair', 'Pie', 'Cookie', 'Éclair'].sort()
    [ 'Cookie', 'Pie', 'cookie', 'pie', 'Éclair', 'éclair' ]

    ```

    对于人类语言，我们可以使用[`Intl.Collator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Collator)：

    ```js
    const arr = ['pie', 'cookie', 'éclair', 'Pie', 'Cookie', 'Éclair'];
    assert.deepEqual(
      arr.sort(new Intl.Collator('en').compare),
      ['cookie', 'Cookie', 'éclair', 'Éclair', 'pie', 'Pie']
    );

    ```

+   `Array.prototype.toSorted(compareFunc?)`

    ES2023 | 非破坏性

    ```js
    Array<T>.prototype.toSorted.toSorted(
      compareFunc?: (a: T, b: T) => number
    ): Array<T>

    ```

    +   返回当前数组的排序副本。

    +   此方法的破坏性版本是`.sort()`。

    ```js
    const original = ['y', 'z', 'x'];
    const sorted = original.toSorted();
    assert.deepEqual(
      // The original is unchanged
      original, ['y', 'z', 'x']
    );
    assert.deepEqual(
      // The copy is sorted
      sorted, ['x', 'y', 'z']
    );

    ```

    有关如何使用此方法的更多信息，请参阅`.sort()`的描述。

+   `Array.prototype.reverse()`

    ES1 | 破坏性

    将接收者的元素重新排列，使它们按逆序排列，然后返回接收者。

    ```js
    > const arr = ['a', 'b', 'c'];
    > arr.reverse()
    [ 'c', 'b', 'a' ]
    > arr
    [ 'c', 'b', 'a' ]

    ```

    此方法的非破坏性版本是`.toReversed()`。

+   `Array.prototype.toReversed()`

    ES2023 | 非破坏性

    +   返回当前数组的反转副本。

    +   此方法的破坏性版本是`.reverse()`。

    ```js
    const original = ['x', 'y', 'z'];
    const reversed = original.toReversed();
    assert.deepEqual(
      // The original is unchanged
      original, ['x', 'y', 'z']
    );
    assert.deepEqual(
      // The copy is reversed
      reversed, ['z', 'y', 'x']
    );

    ```

#### 34.18.12 快速参考的来源

+   [ECMAScript 语言规范](https://tc39.es/ecma262/)

+   [TypeScript 内置类型定义](https://github.com/microsoft/TypeScript/tree/main/src/lib/)

+   [MDN 网络文档 for JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)
