# 29 模块 ES6

> 原文：[`exploringjs.com/js/book/ch_modules.html`](https://exploringjs.com/js/book/ch_modules.html)

1.  29.1 模块速查表

    1.  29.1.1 命名导出、命名导入、命名空间导入

    1.  29.1.2 通过 `import()` 动态导入（ES2020）

    1.  29.1.3 默认导出和导入

    1.  29.1.4 模块指定符的类型

1.  29.2 JavaScript 的源代码单元：脚本和模块

    1.  29.2.1 在内置模块之前编写的代码是 ECMAScript 5

1.  29.3 在我们有模块之前，我们有脚本

1.  29.4 在 ES6 之前创建的模块系统

    1.  29.4.1 服务器端：CommonJS 模块

    1.  29.4.2 客户端：AMD（异步模块定义）模块

    1.  29.4.3 JavaScript 模块的特点

1.  29.5 ECMAScript 模块

    1.  29.5.1 ES 模块：语法、语义、加载器 API

1.  29.6 命名导出和导入

    1.  29.6.1 命名导出

    1.  29.6.2 命名导入

    1.  29.6.3 命名空间导入

    1.  29.6.4 命名导出风格：内联与子句（高级）

1.  29.7 默认导出和默认导入

    1.  29.7.1 两种默认导出风格

    1.  29.7.2 默认导出作为命名导出（高级）

    1.  29.7.3 建议：命名导出与默认导出

1.  29.8 重新导出

1.  29.9 导出和导入的更多细节

    1.  29.9.1 导入是导出的只读视图

    1.  29.9.2 ESM 对循环导入的透明支持（高级）

1.  29.10 包：JavaScript 的软件分发单元

    1.  29.10.1 发布包：包注册表、包管理器、包名称

    1.  29.10.2 包的文件系统布局

    1.  29.10.3 `package.json`

    1.  29.10.4 包导出：控制其他包可见的内容

    1.  29.10.5 包导入

1.  29.11 模块命名

1.  29.12 模块指定符

    1.  29.12.1 模块指定符的类型

    1.  29.12.2 模块指定符中的文件扩展名

    1.  29.12.3 Node.js 中的模块指定符

    1.  29.12.4 浏览器中的模块指定符

1.  29.13 `import.meta` – 当前模块的元数据 (ES2020)

    1.  29.13.1‌ `import.meta.url`

    1.  29.13.2 `import.meta.url` 和 `URL` 类

    1.  29.13.3‌ Node.js 上的 `import.meta.url`

1.  29.14‌ 通过 `import()` 动态加载模块 (ES2020) (高级)

    1.  29.14.1 静态 `import` 语句的限制

    1.  29.14.2‌ 通过 `import()` 操作符动态导入

    1.  29.14.3 `import()` 的用例

1.  29.15 模块中的顶层 `await` (ES2022) (高级)

    1.  29.15.1 顶层 `await` 的用例

    1.  29.15.2 顶层 `await` 在底层是如何工作的？

    1.  29.15.3 顶层 `await` 的优缺点

1.  29.16 导入属性：导入非 JavaScript 艺术品 (ES2025)

    1.  29.16.1‌ 导入非 JavaScript 艺术品的历史

    1.  29.16.2 导入非 JavaScript 艺术品的用例

    1.  29.16.3 导入属性

    1.  29.16.4 导入属性的语法

    1.  29.16.5 JSON 模块 (ES2025)

1.  29.17‌ Polyfills：模拟原生 Web 平台功能 (高级)

    1.  29.17.1 本节的来源

### 29.1 速查表：模块

#### 29.1.1 命名导出、命名导入、命名空间导入

如果我们在模块内的一个命名实体前加上 `export`，它就变成了该模块的 *命名导出*。所有其他实体对该模块都是私有的。

```js
//===== lib.mjs =====
// Named exports
export const one = 1, two = 2;
export function myFunc() {
 return 3;
}

```

```js
//===== main.mjs =====
// Named imports
import {one, myFunc as f} from './lib.mjs';
assert.equal(one, 1);
assert.equal(f(), 3);

// Namespace import
import * as lib from './lib.mjs';
assert.equal(lib.one, 1);
assert.equal(lib.myFunc(), 3);

```

`from` 后面的字符串被称为 *模块指定符*。它标识了我们想从哪个模块导入。

#### 29.1.2 通过 `import()` 动态导入 (ES2020)

到目前为止，我们看到的所有导入都是 *静态的*，具有以下约束：

+   它们必须出现在模块的最顶层。

+   模块指定符是固定的。

通过 `import()` 的动态导入没有这些约束：

```js
//===== lib.mjs =====
// Named exports
export const one = 1, two = 2;
export function myFunc() {
 return 3;
}

```

```js
//===== main.mjs =====
function importLibrary(moduleSpecifier) {
  return import(moduleSpecifier)
  .then((lib) => {
    assert.equal(lib.one, 1);
    assert.equal(lib.myFunc(), 3);
  });
}
await importLibrary('./lib.mjs');

```

#### 29.1.3‌ 默认导出和导入

当模块只包含单个实体时，最常使用 *默认导出*（即使它可以与命名导出结合使用）：

```js
//===== lib1.mjs =====
export default function getHello() {
 return 'hello';
}

```

至多只能有一个默认导出。这就是为什么 `const` 或 `let` 不能作为默认导出（行 A）：

```js
//===== lib2.mjs =====
export default 123; // (A) instead of `const`

```

这是导入默认导出的语法：

```js
//===== main.mjs =====
import lib1 from './lib1.mjs';
assert.equal(lib1(), 'hello');

import lib2 from './lib2.mjs';
assert.equal(lib2, 123);

```

#### 29.1.4 模块指定符的类型

模块指定符标识模块。它们有三种类型：

+   *绝对指定符* 是完整的 URL – 例如：

    ```js
    'https://www.unpkg.com/browse/yargs@17.3.1/browser.mjs'
    'file:///opt/nodejs/config.mjs'

    ```

    绝对指定符主要用于访问直接托管在网上的库。

+   *相对指定符* 是相对 URL（以 `'/'`、`'./'` 或 `'../'` 开头）——例如：

    ```js
    './sibling-module.js'
    '../module-in-parent-dir.mjs'
    '../../dir/other-module.js'

    ```

    每个模块都有一个 URL，其协议取决于其位置（`file:`, `https:` 等）。如果它使用相对指定符，JavaScript 会通过解析它来将指定符转换为完整的 URL。

    相对指定符主要用于访问同一代码库中的其他模块。

+   *裸指定符* 是路径（没有协议和域名），不以斜杠或点开头。它们以包的名称开始。这些名称可以可选地后面跟有 *子路径*：

    ```js
    'some-package'
    'some-package/sync'
    'some-package/util/files/path-tools.js'

    ```

    裸指定符也可以引用具有作用域名称的包：

    ```js
    '@some-scope/scoped-name'
    '@some-scope/scoped-name/async'
    '@some-scope/scoped-name/dir/some-module.mjs'

    ```

    每个裸指定符恰好指向一个包内的一个模块；如果没有子路径，它指向其包的指定“主”模块。

    裸指定符永远不会直接使用，但总是 *解析* —— 转换为绝对指定符。解析的工作方式取决于平台。

### 29.2 JavaScript 的源代码单元：脚本和模块

在 JavaScript 的世界中，“源代码单元”是什么意思？

+   一段 JavaScript 源代码（文本）

+   通常一个单元存储在一个单独的文件中。

+   我们还可以在一个单独的 HTML 文件中嵌入多个单元。

JavaScript 拥有丰富的源代码单元历史：ES6 带来了内置模块，但较旧的格式仍然存在。了解后者有助于理解前者，因此让我们来调查。接下来的几节将描述以下交付 JavaScript 源代码的方式：

+   *脚本* 是浏览器在全局范围内运行的代码片段。它们是模块的先驱。

+   *CommonJS 模块* 是为服务器设计的模块格式（例如，通过 Node.js）。

+   *AMD 模块* 是为浏览器设计的模块格式。

+   *ECMAScript 模块* 是 JavaScript 的内置模块格式。它取代了所有之前的格式。

表 29.1 提供了这些源代码单元的概述。请注意，我们可以选择两种文件扩展名用于 CommonJS 模块和 ECMAScript 模块。选择哪种取决于我们如何使用文件。详细信息将在本章后面给出。

|  | 用途 | 运行在 | 加载 | 文件名扩展名 |
| --- | --- | --- | --- | --- |
| 脚本 | 传统 | 浏览器 | 异步 | `.js` |
| CommonJS 模块 | 下降 | 服务器 | 同步 | `.js .cjs` |
| AMD 模块 | 传统 | 浏览器 | 异步 | `.js` |
| ECMAScript 模块 | 现代 | 浏览器、服务器 | 异步 | `.js .mjs` |

表 29.1：交付 JavaScript 源代码的方式。

#### 29.2.1 内置模块之前的代码是用 ECMAScript 5 编写的

在我们接触到内置模块（ES6 引入的）之前，我们将看到的所有代码都将使用 ES5 编写。其中之一是：

+   ES5 没有使用 `const` 和 `let`；只有 `var`。

+   ES5 没有箭头函数；只有函数表达式。

### 29.3 在我们拥有模块之前，我们有脚本

最初，浏览器只有 *脚本* – 在全局作用域中执行的代码片段。例如，考虑一个通过以下 HTML 加载脚本文件的 HTML 文件：

```js
<script src="other-module1.js"></script>
<script src="other-module2.js"></script>
<script src="my-module.js"></script>

```

主文件是 `my-module.js`，在那里我们模拟一个模块：

```js
var myModule = (function () { // Open IIFE
 // Imports (via global variables)
 var importedFunc1 = otherModule1.importedFunc1;
 var importedFunc2 = otherModule2.importedFunc2;

 // Body
 function internalFunc() {
 // ···
 }
 function exportedFunc() {
 importedFunc1();
 importedFunc2();
 internalFunc();
 }

 // Exports (assigned to global variable `myModule`)
 return {
 exportedFunc: exportedFunc,
 };
})(); // Close IIFE 
```

`myModule` 是一个全局变量，它被分配给立即调用函数表达式的结果。函数表达式从第一行开始。它在最后一行被调用。

这种封装代码片段的方式被称为“立即执行函数表达式”（IIFE，由 Ben Alman 提出）。我们从 IIFE 中获得了什么？`var` 不是块级作用域（像 `const` 和 `let`），它是函数级作用域：创建 `var` 声明变量新作用域的唯一方法是通过函数或方法（对于 `const` 和 `let`，我们可以使用函数、方法或块 `{`）。因此，示例中的 IIFE 隐藏了以下所有变量，从而最小化了名称冲突：`importedFunc1`、`importedFunc2`、`internalFunc`、`exportedFunc`。

注意，我们以一种特定的方式使用 IIFE：在最后，我们选择我们想要导出的内容，并通过对象字面量返回它。这被称为 *揭示模块模式*（由 Christian Heilmann 提出）。

这种模拟模块的方式有几个问题：

+   脚本文件中的库通过全局变量导出和导入功能，这可能导致名称冲突。

+   依赖关系没有明确声明，也没有内置的方法让脚本加载它所依赖的脚本。因此，网页不仅要加载页面需要的脚本，还要加载这些脚本的依赖项、依赖项的依赖项等，并且必须按正确的顺序加载！

### 29.4 在 ES6 之前创建的模块系统

在 ECMAScript 6 之前，JavaScript 没有内置的模块。因此，语言的灵活语法被用来在语言内部实现自定义模块系统。其中两个流行的是：

+   CommonJS（面向服务器端）

+   AMD (异步模块定义，面向客户端)

#### 29.4.1 服务器端：CommonJS 模块

原始的 CommonJS 模块标准是为服务器和桌面平台创建的。它是原始 Node.js 模块系统的基础，在那里它获得了巨大的流行度。对这种流行度的贡献包括 Node 的 npm 包管理器和能够使用 Node 模块在客户端（browserify、webpack 等）上使用的工具。

从现在起，*CommonJS 模块* 指的是该标准的 Node.js 版本（它有一些额外的功能）。这是一个 CommonJS 模块的例子：

```js
// Imports
var importedFunc1 = require('./other-module1.js').importedFunc1;
var importedFunc2 = require('./other-module2.js').importedFunc2;

// Body
function internalFunc() {
 // ···
}
function exportedFunc() {
 importedFunc1();
 importedFunc2();
 internalFunc();
}

// Exports
module.exports = {
 exportedFunc: exportedFunc,
}; 
```

CommonJS 可以描述如下：

+   专为服务器设计。

+   模块旨在 *同步* 加载（导入者等待导入的模块加载和执行）。

+   紧凑的语法。

#### 29.4.2 客户端：AMD（异步模块定义）模块

AMD 模块格式被创建出来是为了在浏览器中使用比 CommonJS 格式更容易。它最流行的实现是[RequireJS](https://requirejs.org)。以下是一个 AMD 模块的示例。

```js
define(['./other-module1.js', './other-module2.js'],
  function (otherModule1, otherModule2) {
    var importedFunc1 = otherModule1.importedFunc1;
    var importedFunc2 = otherModule2.importedFunc2;

    function internalFunc() {
 // ···
 }
 function exportedFunc() {
 importedFunc1();
 importedFunc2();
 internalFunc();
 }

 return {
 exportedFunc: exportedFunc,
 };
 }); 
```

AMD 可以这样描述：

+   为浏览器设计。

+   模块旨在**异步**加载。这对于浏览器来说是一个关键要求，因为代码不能等待模块下载完成。一旦模块可用，就必须通知它。

+   语法稍微复杂一些。

AMD 模块的好处（以及为什么它们在浏览器中表现良好）：它们可以直接执行。相比之下，CommonJS 模块必须在部署前编译，或者必须生成和动态评估自定义源代码（例如`eval()`）。这在网上并不总是允许的。

#### 29.4.3 JavaScript 模块的特性

观察 CommonJS 和 AMD，JavaScript 模块系统之间的相似性显现出来：

+   每个文件有一个模块。

+   这样的文件基本上是一段要执行的代码：

    +   局部作用域：代码在局部“模块作用域”中执行。因此，默认情况下，其中声明的所有变量、函数和类都是内部的，而不是全局的。

    +   导出：如果我们想导出任何声明的实体，我们必须明确将其标记为导出。

    +   导入：每个模块都可以从其他模块导入导出的实体。这些其他模块通过**模块指定符**（通常是路径，偶尔是完整 URL）来识别。

+   模块是**单例**的：即使一个模块被导入多次，也只有一个“实例”存在。

+   不使用全局变量。相反，模块指定符作为全局 ID。

### 29.5 ECMAScript 模块

*ECMAScript 模块*（*ES 模块*或*ESM*）随着 ES6 的引入而出现。它们继续了 JavaScript 模块的传统，并具有上述所有特性。此外：

+   在 CommonJS 中，ES 模块共享紧凑的语法和对循环依赖的支持。

+   在 AMD 中，ES 模块共享为异步加载而设计的特性。

ES 模块也有新的好处：

+   语法比 CommonJS 的更紧凑。

+   模块具有**静态**结构（在运行时无法更改）。这有助于静态检查、优化导入访问、删除死代码等。

+   对循环导入的支持是完全透明的。

这是一个 ES 模块语法的示例：

```js
import {importedFunc1} from './other-module1.mjs';
import {importedFunc2} from './other-module2.mjs';

function internalFunc() {
 ···
}

export function exportedFunc() {
 importedFunc1();
 importedFunc2();
 internalFunc();
} 
```

从现在开始，“模块”指的是“ECMAScript 模块”。

#### 29.5.1 ES 模块：语法、语义、加载器 API

ES 模块的完整标准包括以下部分：

1.  语法（代码的编写方式）：什么是模块？如何声明导入和导出？等等。

1.  语义（代码的执行方式）：变量绑定是如何导出的？导入是如何与导出连接的？等等。

1.  用于配置模块加载的程序化加载器 API。

第一部分和第二部分是在 ES6 中引入的。第三部分的工作正在进行中。

### 29.6 命名导出和导入

#### 29.6.1 命名导出

每个模块可以有零个或多个**命名导出**。

作为例子，考虑以下两个文件：

```js
lib/my-math.mjs
main.mjs

```

模块 `my-math.mjs` 有两个命名导出：`square` 和 `LIGHT_SPEED`。

```js
// Not exported, private to module
function times(a, b) {
  return a * b;
}
export function square(x) {
  return times(x, x);
}
export const LIGHT_SPEED = 299792458;

```

要导出某些内容，我们在声明前放置关键字 `export`。未导出的实体对模块是私有的，并且不能从外部访问。

#### 29.6.2 命名导入

模块 `main.mjs` 有一个命名导入，`square`：

```js
import {square} from './lib/my-math.mjs';
assert.equal(square(3), 9);

```

它也可以重命名其导入：

```js
import {square as sq} from './lib/my-math.mjs';
assert.equal(sq(3), 9);

```

##### 29.6.2.1 语法陷阱：命名导入不是解构

命名导入和解构看起来很相似：

```js
import {func} from './util.mjs'; // import
const {func} = require('./util.mjs'); // destructuring

```

但它们相当不同：

+   导入与其导出保持连接。

+   我们可以在解构模式内部再次解构，但导入语句中的 `{}` 不能嵌套。

+   重命名的语法不同：

    ```js
    import {func as f} from './util.mjs'; // importing
    const {func: f} = require('./util.mjs'); // destructuring

    ```

    理由：解构让人联想到对象字面量（包括嵌套），而导入则唤起了重命名的想法。

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：命名导出**

`exercises/modules/export_named_test.mjs`

#### 29.6.3 命名空间导入

**命名空间导入**是命名导入的替代方案。如果我们命名空间导入一个模块，它将变成一个对象，其属性是命名导出。这是如果我们使用命名空间导入的 `main.mjs` 的样子：

```js
import * as myMath from './lib/my-math.mjs';
assert.equal(myMath.square(3), 9);

assert.deepEqual(
  Object.keys(myMath), ['LIGHT_SPEED', 'square']
);

```

#### 29.6.4 命名导出风格：内联与子句（高级）

我们之前看到的命名导出风格是**内联**的：我们通过在实体前添加关键字 `export` 来导出实体。

但我们也可以使用独立的**导出子句**。例如，这是使用导出子句的 `lib/my-math.mjs` 的样子：

```js
function times(a, b) {
  return a * b;
}
function square(x) {
  return times(x, x);
}
const LIGHT_SPEED = 299792458;

export { square, LIGHT_SPEED }; // semicolon!

```

使用导出子句，我们可以在导出之前重命名，并在内部使用不同的名称：

```js
function times(a, b) {
  return a * b;
}
function sq(x) {
  return times(x, x);
}
const LS = 299792458;

export {
  sq as square,
  LS as LIGHT_SPEED, // trailing comma is optional
};

```

### 29.7 默认导出和默认导入

每个模块最多只能有一个**默认导出**。其想法是模块**就是**默认导出的值。

作为默认导出的例子，考虑以下两个文件：

```js
my-func.mjs
main.mjs

```

模块 `my-func.mjs` 有一个默认导出：

```js
const GREETING = 'Hello!';
export default function () {
 return GREETING;
}

```

模块 `main.mjs` 默认导入导出的函数：

```js
import myFunc from './my-func.mjs';
assert.equal(myFunc(), 'Hello!');

```

注意语法差异：命名导入周围的括号表示我们正在进入模块内部，而默认导入**就是**模块。

![图标“问题”](img/3decb3ca67c240d2bb04742c1f28af18.png) **默认导出的用例有哪些？**

默认导出的最常见用例是包含单个函数或单个类的模块。

#### 29.7.1 推荐项：两种默认导出方式

有两种进行默认导出的方式。

首先，我们可以使用 `export default` 标记现有的声明：

```js
export default function myFunc() {} // no semicolon!
export default class MyClass {} // no semicolon!

```

其次，我们可以直接默认导出值。这种 `export default` 的风格与声明非常相似。

```js
export default myFunc; // defined elsewhere
export default MyClass; // defined previously
export default Math.sqrt(2); // result of invocation is default-exported
export default 'abc' + 'def';
export default { no: false, yes: true };

```

##### 29.7.1.1 为什么有两种默认导出方式？

原因是 `export default` 不能用来标记 `const`：`const` 可以定义多个值，但 `export default` 需要正好一个值。考虑以下假设代码：

```js
// Not legal JavaScript!
export default const a = 1, b = 2, c = 3;

```

使用此代码，我们不知道三个值中的哪一个才是默认导出。

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：默认导出**

`exercises/modules/export_default_test.mjs`

#### 29.7.2 默认导出作为命名导出（高级）

内部，默认导出只是一个名为 `default` 的命名导出。例如，考虑之前具有默认导出的模块 `my-func.mjs`：

```js
const GREETING = 'Hello!';
export default function () {
 return GREETING;
}

```

以下模块 `my-func2.mjs` 与该模块等价：

```js
const GREETING = 'Hello!';
function greet() {
 return GREETING;
}

export {
 greet as default,
};

```

对于导入，我们可以使用正常的默认导入：

```js
import myFunc from './my-func2.mjs';
assert.equal(myFunc(), 'Hello!');

```

或者我们可以使用命名导入：

```js
import {default as myFunc} from './my-func2.mjs';
assert.equal(myFunc(), 'Hello!');

```

默认导出也可以通过命名空间导入的 `.default` 属性访问：

```js
import * as mf from './my-func2.mjs';
assert.equal(mf.default(), 'Hello!');

```

![图标“问题”](img/3decb3ca67c240d2bb04742c1f28af18.png) **`default`作为变量名不合法吗？**

`default` 不能作为变量名，但它可以作为导出名和属性名：

```js
const obj = {
  default: 123,
};
assert.equal(obj.default, 123);

```

#### 29.7.3 推荐项：命名导出与默认导出

这些是我的推荐：

+   避免混合命名导出和默认导出：一个模块可以同时有命名导出和默认导出，但通常最好每个模块只坚持一种导出风格。

    +   有一个例外：对于单元测试，将内部函数（等）命名为导出，以补充默认导出（模块的公共 API）是有意义的。

+   在某些情况下，你可能确信该模块只会导出一个值（通常是函数或类）。也就是说，从概念上讲，模块 *就是* 该值——类似于一个变量。那么默认导出是一个不错的选择。

+   只使用命名导出永远不会出错。

### 29.8 重新导出

一个模块 `library.mjs` 可以将另一个模块 `internal.mjs` 的一个或多个导出作为它自己的导出导出。这被称为 *重新导出*。

```js
//===== internal.mjs =====
export function internalFunc() {}
export const INTERNAL_DEF = 'hello';
export default 123;

```

```js
//===== library.mjs =====
// Named re-export [ES6]
export {internalFunc as func, INTERNAL_DEF as DEF} from './internal.mjs';
// Wildcard re-export [ES6]
export * from './internal.mjs';
// Namespace re-export [ES2020]
export * as ns from './internal.mjs';

```

+   通配符重新导出将模块 `internal.mjs` 的所有导出转换为 `library.mjs` 的导出，除了默认导出。

+   命名空间重新导出将模块 `internal.mjs` 的所有导出转换为成为 `library.mjs` 的命名导出 `ns` 的对象。因为 `internal.mjs` 有默认导出，所以 `ns` 有一个属性 `.default`。

以下代码演示了上述两个要点：

```js
//===== main.mjs =====
import * as library from './library.mjs';

assert.deepEqual(
  Object.keys(library),
  ['DEF', 'INTERNAL_DEF', 'func', 'internalFunc', 'ns']
);
assert.deepEqual(
  Object.keys(library.ns),
  ['INTERNAL_DEF', 'default', 'internalFunc']
);

```

### 29.9 更多关于导出和导入的细节

#### 29.9.1 导入是导出的只读视图

到目前为止，我们直观地使用了导入和导出，一切似乎都按预期工作。但现在，是时候更深入地了解导入和导出是如何真正关联的了。

考虑以下两个模块：

```js
counter.mjs
main.mjs

```

`counter.mjs`导出一个（可变的！）变量和一个函数：

```js
export let counter = 3;
export function incCounter() {
 counter++;
}

```

`main.mjs`同时命名导出。当我们使用`incCounter()`时，我们发现与`counter`的连接是活跃的——我们总能访问该变量的实时状态：

```js
import { counter, incCounter } from './counter.mjs';

// The imported value `counter` is live
assert.equal(counter, 3);
incCounter();
assert.equal(counter, 4);

```

注意，虽然连接是活跃的，我们可以读取`counter`，但我们不能改变这个变量（例如，通过`counter++`）。

以这种方式处理导入有两个好处：

+   由于之前共享的变量可以成为导出，因此更容易拆分模块。

+   这种行为对于支持透明的循环导入至关重要。继续阅读以获取更多信息。

#### 29.9.2 ESM 对循环导入的透明支持（高级）

ESM 透明地支持循环导入。为了理解这是如何实现的，考虑以下示例：图 29.1 显示了模块导入其他模块的有向图。在这种情况下，P 导入 M 是一个循环。

![](img/e021933bd9279348226080408fab73a2.png)

图 29.1：模块导入模块的有向图：M 导入 N 和 O，N 导入 P 和 Q 等。

解析后，这些模块在两个阶段被设置：

+   实例化：每个模块都被访问，并且其导入与导出连接。在父模块实例化之前，必须先实例化所有子模块。

+   评估：模块的主体被执行。再次强调，子模块在父模块之前被评估。

这种方法正确处理了循环导入，归功于 ES 模块的两个特性：

+   由于 ES 模块的静态结构，解析后导出就已经知道了。这使得在 M 之前实例化 P 成为可能：P 已经可以查找 M 的导出。

+   当 P 被评估时，M 还没有被评估。然而，P 中的实体已经可以提及来自 M 的导入。它们只是还不能使用，因为导入的值稍后才会填充。例如，P 中的一个函数可以访问来自 M 的导入。唯一的限制是我们必须等待 M 评估完毕后，才能调用该函数。

    导入被填充是通过它们成为导出的“活跃不可变视图”来实现的。

### 29.10 包：JavaScript 的软件分发单元

在 JavaScript 生态系统中，一个*包*是组织软件项目的一种方式：它是一个具有标准化布局的目录。一个包可以包含各种文件——例如：

+   一个用 JavaScript 编写的 Web 应用程序，将被部署到服务器上

+   JavaScript 库（用于 Node.js、浏览器、所有 JavaScript 平台等）

+   除了 JavaScript 之外的其他编程语言的库：TypeScript、Rust 等。

+   单元测试（例如，针对软件包中的库）

+   基于 Node.js 的 shell 脚本 - 例如，编译器、测试运行器和文档生成器等开发工具

+   许多其他类型的工件

一个软件包可以*依赖于*其他软件包（这些称为其*依赖项*）：

+   软件包的 JavaScript 代码所需的库

+   开发期间使用的 shell 脚本

+   等等。

软件包的依赖项将安装在该软件包内部（我们很快就会看到）。

软件包之间的一种常见区别是：

+   *已发布的软件包*可以被我们安装：

    +   全局安装：我们可以全局安装它们，这样它们的 shell 脚本就可以在命令行中使用了。

    +   本地安装：我们可以将它们作为依赖项安装到我们自己的软件包中。

+   *未发布的软件包*永远不会成为其他软件包的依赖项，但它们本身也有依赖项。例如，部署到服务器的 Web 应用程序。

下一个子节将解释如何发布软件包。

#### 29.10.1 发布软件包：软件包注册表、软件包管理器、软件包名称

发布软件包的主要方式是将它上传到软件包注册表 - 一个在线软件仓库。两个流行的公共注册表是：

+   [npm 注册表](https://www.npmjs.com)是最广泛使用的，并且在使用 Node.js 时是默认的。

+   [开源软件包注册表 JSR](https://jsr.io)为 TypeScript 提供了特殊支持，并由 JavaScript 运行时 Deno 的制作者创建。

公司也可以托管他们自己的私有注册表。

*软件包管理器*是一个命令行工具，它从注册表（或其他来源）下载软件包，并将它们作为 shell 脚本和/或作为依赖项安装。最受欢迎的软件包管理器称为*npm*，它捆绑在 Node.js 中。其名称最初代表“Node Package Manager”。后来，当 npm 和 npm 注册表不仅用于 Node.js 软件包时，这个含义被改为“npm 不是软件包管理器”([来源](https://en.wikipedia.org/wiki/Npm_(software)#Acronym))。还有其他流行的软件包管理器，如 jsr、vlt、pnpm 和 yarn。所有这些软件包管理器都支持 npm 注册表和 JSR 中的任何一个或两个。

让我们探索 npm 注册表是如何工作的。每个软件包都有一个名称。有两种类型的名称：

+   *全局名称*在整个注册表中是唯一的。以下是一些示例：

    ```js
    minimatch
    mocha

    ```

+   *范围名称*由两部分组成：一个范围和一个名称。范围是全球唯一的，名称在每个范围内是唯一的。以下是一些示例：

    ```js
    @babel/core
    @rauschma/iterable

    ```

    范围以一个`@`符号开始，并用斜杠与名称分开。

#### 29.10.2 软件包的文件系统布局

一旦软件包`my-package`完全安装，它通常看起来是这样的：

```js
my-package/
  package.json
  node_modules/
  [More files]

```

这些文件系统条目的目的是什么？

+   `package.json`是每个软件包都必须拥有的文件：

    +   它包含描述软件包的元数据（其名称、版本、作者等）。

    +   它列出了包的依赖项：它需要的其他包，例如库和工具。对于每个依赖项，我们记录：

        +   一系列版本号。不指定特定版本允许升级以及依赖项之间的代码共享。

        +   默认情况下，依赖项来自 npm 注册表。但我们也可以指定其他来源：本地目录、GZIP 文件、指向 GZIP 文件的 URL、除 npm 之外的其他注册表、git 仓库等。

+   `node_modules/` 是一个目录，其中安装了包的依赖项。每个依赖项也有一个包含其依赖项的 `node_modules` 文件夹，等等。结果是依赖项的树状结构。

大多数包也都有一个名为 `package-lock.json` 的文件，它位于 `package.json` 旁边：它记录了已安装依赖项的确切版本，并且如果通过 npm 添加更多依赖项，它将保持更新。

#### 29.10.3 `package.json`

这是一个可以通过 npm 创建的初始 `package.json`：

```js
{
  "name": "my-package",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}

```

这些属性的目的是什么？

+   一些属性对于公共包（发布在 npm 注册表中）是必需的：

    +   `name` 指定此包的名称。

    +   `version` 用于版本管理，并遵循 [语义化版本控制](https://semver.org)，由三个点分隔的数字组成：

        +   当进行不兼容的 API 变更时，会递增 *主版本*。

        +   当以向后兼容的方式添加功能时，会递增 *次要版本*。

        +   当进行的小改动不会真正改变功能时，会递增 *修补版本*。

+   公共包的其他属性是可选的：

    +   `description`、`keywords`、`author` 是可选的，这使得查找包变得更加容易。

    +   `license` 阐明了如何使用此包。如果包以任何方式是公共的，提供此值是有意义的。[“选择开源许可”](https://choosealicense.com) 可以帮助做出这个选择。

+   `main` 是一个遗留属性，已被 `exports` 取代。它指向库包的代码。

+   `scripts` 是一个用于设置开发时 shell 命令缩写的属性。这些可以通过 `npm run` 执行。例如，`test` 脚本可以通过 `npm run test` 执行。

更有用的属性：

+   通常，`name` 和 `version` 属性是必需的，如果它们缺失，npm 会警告我们。但是，我们可以通过以下设置来更改这一点：

    ```js
    "private": true

    ```

    这防止了包意外发布，并允许我们省略名称和版本。

+   `exports` 用于 *包导出* – 指定导入者如何看到此包的内容。我们将在 稍后 了解更多关于包导出的内容。

+   `imports` 用于 *包导入* – 定义了包可以内部使用的模块指定符别名。我们将在 稍后 了解更多关于包导入的内容。

+   `dependencies` 列出了包的依赖项。

+   `devDependencies` 是仅在开发期间安装的依赖项（不是当包作为依赖项添加时）。

+   以下设置意味着所有以 `.js` 为扩展名的文件都被解释为 ECMAScript 模块。除非我们正在处理遗留代码，否则添加它是合理的：

    ```js
    "type": "module"

    ```

+   `bin` 列出作为 shell 脚本安装的包内的模块。

![图标“外部”](img/38e6ff55e8d602659f3cdb8893e63f62.png)  **关于 `package.json` 的更多信息**

查看 [npm 文档](https://docs.npmjs.com/files/package.json)。

#### 29.10.4 包导出：控制其他包可见的内容

[*包导出*](https://nodejs.org/api/packages.html#packages_package_entry_points) 通过 `package.json` 中的 `"exports"` 属性指定，并支持三个重要特性：

+   隐藏包的内部结构：

    +   如果不存在 `"exports"` 属性，则包 `my-lib` 中的每个模块都可以通过包名后的相对路径访问——例如：

        ```js
        'my-lib/dist/src/internal/internal-module.js'

        ```

    +   一旦存在该属性，就只能使用其中列出的指定符。其他所有内容对外部都是隐藏的。

+   更好的模块指定符：包导出允许我们更改导入包模块的裸指定符子路径：它们可以更短，无扩展名等。

+   条件导出：相同的模块指定符导出不同的模块——这取决于导入者使用的 JavaScript 平台（浏览器、Node.js 等）。

接下来，我们将查看一些例子。要更详细地了解包导出是如何工作的，请参阅“使用 Node.js 的 Shell 脚本”中的[“包导出：控制其他包可见的内容”](https://exploringjs.com/nodejs-shell-scripting/ch_packages.html#package-exports-controlling-what-other-packages-see)部分。

##### 29.10.4.1 例子：包导出

例子——指定通过包的裸指定符导入的模块（过去，这是通过 `main` 属性指定的）：

```js
"exports": {
  ".": "./dist/src/main.js"
}

```

例子——指定模块更好的路径：

```js
"exports": {
  // With filename extension
  "./util/errors.js": "./dist/src/util/errors.js",

  // Without filename extension
  "./util/errors": "./dist/src/util/errors.js"
}

```

例子——指定模块树更好的路径：

```js
"exports": {
  // With filename extensions
  "./*": "./dist/src/*",

  // Without filename extensions
  "./*": "./dist/src/*.js"
}

```

##### 29.10.4.2 例子：条件包导出

本小节中的例子展示了 `package.json` 的摘录。

例子——为 Node.js、浏览器和其他平台导出不同的模块：

```js
"exports": {
  ".": {
    "node": "./main-node.js",
    "browser": "./main-browser.js",
    "default": "./main-browser.js"
  }
}

```

例子——开发与生产：

```js
"exports": {
  ".": {
    "development": "./main-development.js",
    "production": "./main-production.js",
  }
}

```

在 Node.js 中，我们可以指定一个环境如下：

```js
node --conditions development app.mjs

```

#### 29.10.5 包导入

[包导入](https://nodejs.org/api/packages.html#imports) 允许一个包定义它自己内部使用的模块指定符的缩写。这是一个例子：

`package.json`：

```js
{
  "imports": {
    "#some-pkg": {
      "node": "some-pkg-node-native",
      "default": "./polyfills/some-pkg-polyfill.js"
    }
  },
  "dependencies": {
    "some-pkg-node-native": "¹.2.3"
  }
}

```

`"imports"` 的每个键都必须以井号（`#`）开头。键 `"#some-pkg"` 是**条件性的**（具有与条件包导出相同的特性）：

+   如果当前包在 Node.js 上使用，模块指定符 `'#some-pkg'` 指的是 `some-pkg-node-native` 包。

+   在其他地方，`'#some-pkg'`指的是当前包内`./polyfills/some-pkg-polyfill.js`文件。

注意，只有包导入可以引用外部包，包导出不能这样做。

包导入有哪些用例？

+   通过相同的模块指定符引用不同平台特定的实现模块（如上所示）。

+   当前包内模块的别名 – 以避免相对指定符（在深层嵌套目录中可能会变得复杂）。

##### 29.10.5.1 示例：通过包导入访问 `package.json`

让我们探讨两种通过包导入访问`package.json`的方法。

首先，我们可以为包的根级别定义一个包导入：

```js
"imports": {
  "#root/*": "./*"
},

```

然后，导入语句看起来像这样：

```js
import pkg from '#root/package.json' with { type: 'json' };
console.log(pkg.version);

```

其次，我们可以为`package.json`定义一个包导入：

```js
"imports": {
  "#pkg": "./package.json"
},

```

然后，导入语句看起来像这样：

```js
import pkg from '#pkg' with { type: 'json' };
console.log(pkg.version);

```

### 29.11 命名模块

对于命名模块文件及其导入的变量，没有建立最佳实践。

在本章中，我使用以下命名风格：

+   模块文件的名称是破折号命名，并且只有小写字母：

    ```js
    ./my-module.mjs
    ./some-func.mjs

    ```

+   命名空间导入的名称是驼峰式，并且以小写字母开头：

    ```js
    import * as myModule from './my-module.mjs';

    ```

+   默认导入的名称是驼峰式，并且以小写字母开头：

    ```js
    import someFunc from './some-func.mjs';

    ```

这种风格的背后是什么思考？我们希望模块文件名与包名相似：

+   在包名中，破折号比下划线更常用。这可能受到下划线在域名中非常罕见的影响。

+   npm 不允许包名中使用大写字母（[来源](https://docs.npmjs.com/cli/v11/configuring-npm/package-json#name)）。

多亏了 CSS，有明确的规则将破折号命名转换为驼峰命名。我们可以使用这些规则来处理命名空间导入和默认导入。

### 29.12 模块指定符

*模块指定符*是标识模块的字符串。它们在浏览器和 Node.js 中的工作方式略有不同。在我们能够查看这些差异之前，我们需要了解不同类别的模块指定符。

#### 29.12.1 模块指定符的类型

模块指定符有三种类型：

+   *绝对指定符*是完整的 URL – 例如：

    ```js
    'https://www.unpkg.com/browse/yargs@17.3.1/browser.mjs'
    'file:///opt/nodejs/config.mjs'

    ```

    绝对指定符主要用于访问直接托管在网上的库。

+   *相对指定符*是相对 URL（以`'/'`, `'./'`或`'../'`开头） – 例如：

    ```js
    './sibling-module.js'
    '../module-in-parent-dir.mjs'
    '../../dir/other-module.js'

    ```

    每个模块都有一个 URL，其协议取决于其位置（`file:`, `https:`等）。如果它使用相对指定符，JavaScript 会将该指定符转换为完整的 URL，通过解析模块的 URL 来实现。

    相对指定符主要用于访问同一代码库中的其他模块。

+   *裸指定符*是不带协议和域的路径，不以斜杠或点开头。它们以包的名称开始。这些名称可以可选地后面跟有*子路径*：

    ```js
    'some-package'
    'some-package/sync'
    'some-package/util/files/path-tools.js'

    ```

    裸露指定符也可以指向具有范围名称的包：

    ```js
    '@some-scope/scoped-name'
    '@some-scope/scoped-name/async'
    '@some-scope/scoped-name/dir/some-module.mjs'

    ```

    每个裸露指定符恰好指向包内部的一个模块；如果没有子路径，它指向其包指定的“主”模块。

    裸露指定符永远不会直接使用，而是始终*解析* – 转换为绝对指定符。解析的工作方式取决于平台。我们很快就会了解更多。

#### 29.12.2 模块指定符中的文件扩展名

+   绝对指定符和相对指定符始终具有文件扩展名 – 主要为 `.js` 或 `.mjs`。

+   裸露指定符有三种样式：

    +   样式 1：没有子路径

        ```js
        'my-library'

        ```

    +   样式 2：没有文件扩展名的子路径。在这种情况下，子路径类似于对包名的修饰符：

        ```js
        'my-parser/sync'
        'my-parser/async'

        'assertions'
        'assertions/strict'

        ```

    +   样式 3：具有文件扩展名的子路径。在这种情况下，包被视为模块集合，子路径指向其中之一：

        ```js
        'large-package/misc/util.js'
        'large-package/main/parsing.js'
        'large-package/main/printing.js'

        ```

样式 3 裸露指定符的注意事项：文件扩展名的解释取决于依赖项，可能与导入包不同。例如，导入包可能使用 `.mjs` 用于 ESM 模块和 `.js` 用于 CommonJS 模块，而依赖项导出的 ESM 模块可能具有带有文件扩展名 `.js` 的裸路径。

#### 29.12.3 在 Node.js 中的模块指定符

让我们看看模块指定符在 Node.js 中的工作方式。特别是裸露指定符的处理方式与浏览器不同。

##### 29.12.3.1 在 Node.js 中解析模块指定符

[*Node.js 解析算法*](https://nodejs.org/api/esm.html#resolution-algorithm) 的工作方式如下：

+   参数：

    +   导入模块的 URL

    +   模块指定符

+   结果：模块指定符的解析 URL

这是算法：

+   如果指定符是绝对的，解析已经完成。最常见的协议有三个：

    +   `file:` 用于本地文件

    +   `https:` 用于远程文件

    +   `node:` 用于内置模块

+   如果指定符是相对的，它将相对于导入模块的 URL 进行解析。

+   如果指定符是裸露的：

    +   如果它以 `'#'` 开头，它将通过查找*包导入*（这将在稍后解释）并解析结果来解析。

    +   否则，它是一个具有以下格式之一的裸露指定符（子路径是可选的）：

        +   `«package»/sub/path`

        +   `@«scope»/«scoped-package»/sub/path`

        解析算法遍历当前目录及其父目录，直到找到一个包含与裸露指定符开头匹配的子目录 `node_modules`，即：

        +   `node_modules/«package»/`

        +   `node_modules/@«scope»/«scoped-package»/`

        该目录是包的目录。默认情况下，包 ID 之后的（可能为空）子路径被解释为相对于包目录。默认值可以通过*包导出*来覆盖，这将在下文中解释。

解析算法的结果必须指向一个文件。这解释了为什么绝对指定符和相对指定符始终具有文件扩展名。裸指定符通常没有，因为它们是查找包导出的缩写。

模块文件通常具有以下文件扩展名：

+   如果文件具有`.mjs`扩展名，它始终是 ES 模块。

+   如果最接近的`package.json`有此条目，则具有`.js`扩展名的文件是 ES 模块：

    +   `"type": "module"`

如果 Node.js 执行通过 stdin、`--eval`或`--print`提供的代码，我们使用[以下命令行选项](https://nodejs.org/api/cli.html#--input-typetype)以便将其解释为 ES 模块：

```js
--input-type=module

```

#### 29.12.4 浏览器中的模块指定符

在浏览器中，我们可以这样编写内联模块：

```js
<script type="module">
 // Inline module
</script>

```

`type="module"`告诉浏览器这是一个 ES 模块，而不是浏览器脚本。

我们只能使用两种模块指定符：

```js
<!-- Absolute module specifier -->
<script type="module" src="https://unpkg.com/lodash"></script>

<!-- Relative module specifier -->
<script type="module" src="bundle.js"></script>

```

继续阅读以了解如何绕过此限制并使用 npm 包。

##### 29.12.4.1 浏览器中的文件扩展名

浏览器不关心文件扩展名，只关心内容类型。

因此，只要它们以[JavaScript 内容类型](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#textjavascript)（推荐使用`text/javascript`）提供，我们可以为 ECMAScript 模块使用任何文件扩展名。

##### 29.12.4.2 在浏览器中使用 npm 包

在 Node.js 上，npm 包被下载到`node_modules`目录，并通过裸模块指定符访问。Node.js 遍历文件系统以查找包。我们无法在 Web 浏览器中这样做。将 npm 包带到浏览器中的三种常见方法。

###### 29.12.4.2.1 方法 1：使用内容分发网络

内容分发网络（CDN）如[`unpkg.com`](https://unpkg.com)和[`esm.sh`](https://esm.sh)允许我们通过 URL 导入 npm 包。这是`unpkg.com` URL 的示例：

```js
https://unpkg.com/«package»@«version»/«file»

```

例如：

```js
https://unpkg.com/lodash@4.17.21/lodash.js

```

CDN 的一个缺点是它们引入了一个额外的故障点：

+   CDN 可能会离线。

+   CDN 提供恶意代码的风险存在——例如，如果它们被黑客攻击或被新的维护者接管。

###### 29.12.4.2.2 方法 2：使用带有裸指定符和打包器的`node_modules`

打包器是一个构建工具。它大致工作如下：

+   给定一个包含 Web 应用的目录。我们将打包器指向应用的*入口点*——执行开始的模块。

+   它收集该模块导入的所有内容（它的导入、导入的导入等）。

+   它生成一个*bundle*，一个包含所有代码的单个文件。该文件可以从 HTML 页面中使用。

如果一个应用有多个入口点，打包器会生成多个包。也可以指示它为按需加载的应用部分创建包。

在打包时，我们可以在文件中使用裸导入指定符，因为打包器知道如何在 `node_modules` 中找到相应的模块。打包器还尊重包导出和包导入。

为什么需要打包？

+   加载单个文件通常比加载多个文件更快 – 尤其是当有很多小文件时。

+   打包器只包含文件中实际使用的代码（这对于库尤其相关）。这节省了存储空间，也加快了加载速度。

打包的一个缺点是每次我们想要运行应用时都需要打包整个应用。

###### 29.12.4.2.3 方法 3：将 npm 包转换为浏览器兼容文件

浏览器有包管理器，允许我们下载作为单个打包文件使用的模块。例如，考虑以下 Web 应用的目录：

```js
my-web-app/
  assets/
    lodash-es.js
  src/
    main.js

```

我们使用打包器将包 `lodash-es` 安装到单个文件中。模块 `main.js` 可以这样导入它：

```js
import {pick} from '../assets/lodash-es.js';

```

为了部署此应用，`assets/` 和 `src/` 目录的内容被复制到生产服务器（除了非 JavaScript 艺术品之外）。

与使用打包器相比，这种方法的优点是什么？

+   我们安装外部依赖项一次，然后可以始终立即运行我们的应用 – 不需要先打包（这可能很耗时）。

+   未打包的代码更容易调试。

###### 29.12.4.2.4 改进方法 3：导入映射

方法 3 可以进一步改进：[*导入映射*](https://2ality.com/2022/01/esm-specifiers.html#import-maps) 是一种浏览器技术，允许我们为模块指定符定义缩写 – 例如，`'lodash-es'` 对应 `'../assets/lodash-es.js'`。

如果我们将导入映射存储在 HTML 文件中，它会看起来像这样：

```js
<script type="importmap">
{
 "imports": {
 "lodash-es": "./assets/lodash-es.js"
 }
}
</script>

```

我们还可以将导入映射存储在外部文件中（内容类型必须是 `application/importmap+json`）：

```js
<script type="importmap" src="imports.importmap"></script>

```

现在 `main.js` 中的导入看起来是这样的：

```js
import {pick} from 'lodash-es';

```

### 29.13 `import.meta` – 当前模块的元数据 (ES2020)

对象 `import.meta` 包含当前模块的元数据。

#### 29.13.1 `import.meta.url`

`import.meta` 的最重要的属性是 `.url`，它包含一个字符串，包含当前模块文件的 URL – 例如：

```js
'https://example.com/code/main.mjs'

```

#### 29.13.2 `import.meta.url` 和 `URL` 类

`URL` 类在浏览器和 Node.js 中通过全局变量可用。我们可以在 [Node.js 文档](https://nodejs.org/api/url.html#url_class_url) 中查找其完整功能。当使用 `import.meta.url` 时，其构造函数特别有用：

```js
new URL(input: string, base?: string|URL)

```

参数 `input` 包含要解析的 URL。如果提供了第二个参数 `base`，则可以是相对路径。

换句话说，这个构造函数允许我们相对于基本 URL 解析相对路径：

```js
> new URL('other.mjs', 'https://example.com/code/main.mjs').href
'https://example.com/code/other.mjs'
> new URL('../other.mjs', 'https://example.com/code/main.mjs').href
'https://example.com/other.mjs'

```

这是我们如何获取一个指向当前模块旁边 `data.txt` 文件的 `URL` 实例：

```js
const urlOfData = new URL('data.txt', import.meta.url);

```

#### 29.13.3 在 Node.js 上的 `import.meta.url`

在 Node.js 上，`import.meta.url` 总是一个带有 `file:` URL 的字符串 – 例如：

```js
'file:///Users/rauschma/my-module.mjs'

```

##### 29.13.3.1 示例：读取模块的兄弟文件

许多 Node.js 文件系统操作接受路径的字符串或 `URL` 实例。这使得我们可以读取当前模块的兄弟文件 `data.txt`：

```js
import * as fs from 'node:fs';
function readData() {
 // data.txt sits next to current module
 const urlOfData = new URL('data.txt', import.meta.url);
 return fs.readFileSync(urlOfData, {encoding: 'UTF-8'});
}

```

##### 29.13.3.2 模块 `fs` 和 URLs

对于 `fs` 模块的大多数函数，我们可以通过以下方式引用文件：

+   路径 – 字符串或 `Buffer` 实例。

+   URLs – 在 `URL` 实例中（协议为 `file:`）

关于这个主题的更多信息，请参阅[Node.js API 文档](https://nodejs.org/api/fs.html#fs_file_paths)。

##### 29.13.3.3 在 `file:` URLs 和路径之间转换

[Node.js 模块 `url`](https://nodejs.org/api/url.html) 有两个函数用于在 `file:` URLs 和路径之间进行转换：

+   `fileURLToPath(url: URL|string): string`

    将 `file:` URL 转换为路径。

+   `pathToFileURL(path: string): URL`

    将路径转换为 `file:` URL。

如果我们需要可以在本地文件系统中使用的路径，那么 `URL` 实例的 `.pathname` 属性并不总是有效：

```js
assert.equal(
  new URL('file:///tmp/with%20space.txt').pathname,
  '/tmp/with%20space.txt');

```

因此，最好使用 `fileURLToPath()`：

```js
import * as url from 'node:url';
assert.equal(
  url.fileURLToPath('file:///tmp/with%20space.txt'),
  '/tmp/with space.txt'); // result on Unix

```

类似地，`pathToFileURL()` 不仅将 `'file://'` 前缀添加到绝对路径。

### 29.14 通过 `import()` 动态加载模块 (ES2020) (高级)

![图标“阅读”](img/0fb62b2fc33a72829ae9fb174dedd0d2.png) **`import()` 操作符返回 Promises**

Promises 是处理异步计算结果（即，不是立即）的技术。可能有必要在理解它们之后再阅读这一节。更多信息：

+   “异步编程的 Promises (ES6)” (§43)

+   “异步函数 (ES2017)” (§44)（解释了用于 Promises 的 `await` 操作符，我们将在本节中使用它）

#### 29.14.1 静态 `import` 语句的限制

到目前为止，导入模块的唯一方法是通过 `import` 语句。该语句有几个限制：

+   我们必须在模块的最顶层使用它。也就是说，例如，当我们处于函数内部或 `if` 语句内部时，我们不能导入任何东西。

+   模块指定符始终是固定的。也就是说，我们不能根据条件更改我们导入的内容。我们也不能动态地组装指定符。

#### 29.14.2 通过 `import()` 操作符进行动态导入

`import()` 操作符没有 `import` 语句的限制。它看起来像这样：

```js
const namespaceObject = await import(moduleSpecifierStr);
console.log(namespaceObject.namedExport);

```

这个操作符的使用方式类似于函数，接收一个包含模块指定符的字符串，并返回一个解析为命名空间对象的 Promise。该对象的属性是导入模块的导出。

注意，`await` 可以在模块的最高级别使用（参见 下一节）。

##### 29.14.2.1 示例：动态加载模块

考虑以下文件：

```js
lib/my-math.mjs
main1.mjs
main2.mjs

```

我们已经看到了模块 `my-math.mjs`：

```js
// Not exported, private to module
function times(a, b) {
  return a * b;
}
export function square(x) {
  return times(x, x);
}
export const LIGHT_SPEED = 299792458;

```

我们可以使用 `import()` 按需加载此模块：

```js
// main1.mjs
const moduleSpecifier = './lib/my-math.mjs';

async function getLightSpeedAsync() {
 const myMath = await import(moduleSpecifier);
 return myMath.LIGHT_SPEED;
}

const result = await getLightSpeedAsync();
assert.equal(result, 299792458);

```

以下代码中的两个操作无法使用 `import` 语句完成：

+   我们在函数内部导入（而不是在顶层）。

+   模块指定符来自一个变量。

![图标“问题”](img/3decb3ca67c240d2bb04742c1f28af18.png) **为什么 `import()` 是一个操作符而不是一个函数？**

`import()` 看起来像一个函数，但无法作为一个函数实现：

+   它需要知道当前模块的 URL，以便解析相对模块指定符。

+   如果 `import()` 是一个函数，我们就必须显式地传递这个信息给它（例如，通过参数）。

+   相比之下，操作符是一个核心语言构造，并且可以隐式访问更多数据，包括当前模块的 URL。

#### 29.14.3 `import()` 的用例

##### 29.14.3.1 按需加载代码

一些 Web 应用的功能在它们启动时不必存在，可以在需要时加载。这时 `import()` 就很有用，因为我们可以将这些功能放入模块中——例如：

```js
button.addEventListener('click', async (event) => {
  const dialogBox = await import('./dialogBox.mjs');
  dialogBox.open();
});

```

##### 29.14.3.2 条件加载模块

我们可能想要根据条件是否为真来加载模块。例如，一个包含 polyfill 的模块，该 polyfill 在旧平台上提供新功能：

```js
if (isLegacyPlatform()) {
  await import('./my-polyfill.mjs');
}

```

##### 29.14.3.3 计算模块指定符

对于国际化等应用，如果我们能够动态计算模块指定符，那就很有帮助：

```js
const message = await import(`messages_${getLocale()}.mjs`);

```

### 29.15 模块中的顶层 `await` (ES2022) (高级)

![图标“阅读”](img/0fb62b2fc33a72829ae9fb174dedd0d2.png) **`await` 是异步函数的一个特性**

`await` 在 “异步函数 (ES2017)” (§44) 中进行了解释。可能有必要在理解异步函数之后再阅读这一节。

我们可以在模块的最高级别使用 `await` 操作符。如果我们这样做，模块就会变为异步，并且工作方式不同。幸运的是，作为程序员，我们通常不会看到这种情况，因为它由语言透明地处理。

#### 29.15.1 顶层 `await` 的用例

为什么我们想在模块的最高级别使用 `await` 操作符呢？它允许我们使用异步加载数据初始化模块。接下来的三个小节展示了这种用法在哪些情况下是有用的。

##### 29.15.1.1 动态加载模块

```js
const params = new URLSearchParams(location.search);
const language = params.get('lang');
const messages = await import(`./messages-${language}.mjs`); // (A)

console.log(messages.welcome);

```

在行 A 中，我们动态导入了一个模块。多亏了顶层 `await`，这几乎与使用正常的静态导入一样方便。

##### 29.15.1.2 如果模块加载失败，使用回退

```js
let mylib;
try {
  mylib = await import('https://primary.example.com/mylib');
} catch {
  mylib = await import('https://secondary.example.com/mylib');
}

```

##### 29.15.1.3 使用加载最快的资源

```js
const resource = await Promise.any([
  fetch('http://example.com/first.txt')
    .then(response => response.text()),
  fetch('http://example.com/second.txt')
    .then(response => response.text()),
]);

```

由于 `Promise.any()`，变量 `resource` 通过最先完成的下载进行初始化。

#### 29.15.2 顶层 `await` 在底层是如何工作的？

考虑以下两个文件。

`first.mjs`:

```js
const response = await fetch('http://example.com/first.txt');
export const first = await response.text();

```

`main.mjs`:

```js
import {first} from './first.mjs';
import {second} from './second.mjs';
assert.equal(first, 'First!');
assert.equal(second, 'Second!');

```

这两种方法大致等同于以下代码：

`first.mjs`:

```js
export let first;
export const promise = (async () => { // (A)
  const response = await fetch('http://example.com/first.txt');
  first = await response.text();
})();

```

`main.mjs`:

```js
import {promise as firstPromise, first} from './first.mjs';
import {promise as secondPromise, second} from './second.mjs';
export const promise = (async () => { // (B)
  await Promise.all([firstPromise, secondPromise]); // (C)
  assert.equal(first, 'First!');
  assert.equal(second, 'Second!');
})();

```

一个模块如果成为异步的：

1.  它直接使用顶层 `await` (`first.mjs`）。

1.  它导入一个或多个异步模块（`main.mjs`）。

每个异步模块导出一个 Promise（行 A 和行 B），在它的主体执行完毕后得到满足。到那时，可以安全地访问该模块的导出。

在情况 (2) 中，导入模块会等待所有导入的异步模块的 Promise 被满足，然后才进入其主体（行 C）。同步模块按常规处理。

等待拒绝和同步异常的管理方式与异步函数中相同。

#### 29.15.3 顶层 `await` 的优缺点

顶层 `await` 的优缺点是什么？

+   优点：

    +   在模块的顶层有这个操作符是非常方便的，尤其是对于动态导入的模块。

    +   这避免了需要复杂的技术来确保导入者不会在数据准备好之前访问数据。

    +   它透明地支持异步性：导入者不需要知道导入的模块是否是异步的。

+   缺点：

    +   顶层 `await` 延迟导入模块的初始化。因此，最好谨慎使用。耗时较长的异步任务最好在需要时再执行。然而，即使没有顶层 `await` 的模块也可以阻塞导入者（例如，通过顶层无限循环），所以阻塞本身并不是反对它的理由。

    +   在 Node.js 上，使用顶层 `await` 的 ESM 模块不能从 CommonJS 中导入。如果你编写了一个基于 ESM 的包，并希望它可以从 CommonJS 代码库中使用，这很重要。更多信息，请参阅 Node.js 文档中的[“使用 `require()` 加载 ECMAScript 模块”](https://nodejs.org/api/modules.html#loading-ecmascript-modules-using-require)部分。

### 29.16 导入属性：导入非 JavaScript 艺术品 (ES2025)

#### 29.16.1 导入非 JavaScript 艺术品的历程

将非 JavaScript 代码作为模块导入，在 JavaScript 生态系统中有着悠久的历史。例如，JavaScript 模块加载器 RequireJS 支持所谓的[*插件*](https://requirejs.org/docs/plugins.html)。为了给您一个关于 RequireJS 多么古老的感觉：版本 1.0.0 于 2009 年发布。通过插件导入的模块的指定符看起来如下：

```js
'«specifier-of-plugin-module»!«specifier-of-artifact»'

```

例如，以下模块指定符将文件作为 JSON 导入：

```js
'json!./data/config.json'

```

受 RequireJS 启发，webpack 支持相同的模块指定符语法来支持其[*加载器*](https://webpack.js.org/loaders/)。

#### 29.16.2 导入非 JavaScript 艺术品的用例

这些是导入非 JavaScript 艺术品的几个用例：

+   导入 JSON 配置数据

+   将 WebAssembly 代码作为 JavaScript 模块导入

+   将 CSS 导入以构建用户界面

对于更多用例，您可以查看[webpack 的加载器列表](https://webpack.js.org/loaders/)。

#### 29.16.3 导入属性

导入属性的激励用例是将 JSON 数据作为模块导入。这看起来如下所示：

```js
import configData from './config-data.json' with { type: 'json' };

```

`type` 是一个导入属性（关于语法的更多内容很快就会介绍）。

您可能会想知道为什么 JavaScript 引擎不能使用文件扩展名 `.json` 来确定这是 JSON 数据。然而，网络的核心架构原则是永远不要使用文件扩展名来确定文件内部的内容。相反，使用内容类型。

如果服务器设置正确，为什么不进行正常的导入并省略导入属性呢？

+   服务器可能故意配置错误——例如，一个不由编写代码的人控制的第三方服务器。它可能会用一个将被导入器执行的代码替换导入的 JSON 文件。

+   服务器可能意外配置错误。使用导入属性，我们可以更快地获得反馈。

+   由于预期的内容类型在代码中不是明确的，属性也记录了程序员的期望。

#### 29.16.4 导入属性的语法

让我们更详细地检查导入属性的外观。

##### 29.16.4.1 静态导入语句

我们已经看到了一个正常的（静态）导入语句：

```js
import configData from './config-data.json' with { type: 'json' };

```

导入属性以`with`关键字开头。该关键字后面跟着一个对象字面量。目前，支持以下对象字面量特性：

+   未引用的键和引用的键

+   值必须是字符串

没有对键和值的语法进行其他限制，但如果引擎不支持某个键和/或值，则应抛出异常：

+   属性会改变导入的内容，因此简单地忽略它们是危险的，因为这会改变代码的运行时行为。

+   一个副作用是，这使得将来更容易添加更多功能，因为没有人会以意想不到的方式使用键和值。

##### 29.16.4.2 动态导入

为了支持导入属性，动态导入 获得了第二个参数——一个包含配置数据的对象：

```js
const configData = await import(
  './config-data.json', { with: { type: 'json' } }
);

```

导入属性不在顶层；它们通过 `with` 属性指定。这使得将来能够添加更多的配置选项。

##### 29.16.4.3 重新导出语句

重新导出在单个步骤中导入和导出。对于前者，我们需要属性：

```js
export { default as config } from './config-data.json' with { type: 'json' };

```

#### 29.16.5 JSON 模块 (ES2025)

导入属性实际上只是语法。它们为使用该语法的实际功能奠定了基础。第一个基于导入属性的 ECMAScript 功能是 JSON 模块——我们已经在实际操作中看到了它：

这是一个文件 `config-data.json`：

```js
{
  "version": "1.0.0",
  "maxCount": 20
}

```

它紧邻以下 ECMAScript 模块 `main.js`：

```js
import configData from './config-data.json' with { type: 'json' };
assert.deepEqual(
  configData,
  {
    version: '1.0.0',
    maxCount: 20
  }
);

```

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：导入 JSON**

`exercises/modules/get-version_test.mjs`

### 29.17 Polyfills：模拟原生 Web 平台功能（高级）

![图标“详情”](img/38ba63de820aae6f94a019538ae0f222.png) **后端也有 polyfills**

本节是关于前端开发和 Web 浏览器的，但类似的想法也适用于后端开发。

*Polyfills* 帮助我们在用 JavaScript 开发 Web 应用程序时遇到的冲突：

+   一方面，我们希望使用使应用程序更好和/或开发更简单的现代 Web 平台功能。

+   另一方面，应用程序应该在尽可能多的浏览器上运行。

给定一个 Web 平台功能 X：

+   X 的 *polyfill* 是一段代码。如果它在已经内置了对 X 的支持的平台上执行，则不会做任何事情。否则，它使该功能在平台上可用。在后一种情况下，polyfill 的功能（主要）与原生实现不可区分。为了实现这一点，polyfill 通常会进行全局更改。例如，它可能会修改全局数据或配置全局模块加载器。Polyfills 通常被打包成模块。

    +   术语 [*polyfill*](https://remysharp.com/2010/10/08/what-is-a-polyfill) 是由 Remy Sharp 提出的。

+   *推测性 polyfill* 是针对提议的 Web 平台功能（尚未标准化）的 polyfill。

    +   术语：*prollyfill*

+   X 的 *复制品* 是一个库，它在本地上重现了 X 的 API 和功能。这样的库独立于 X 的本地（和全局）实现。

    +   *复制品* 是本节中引入的新术语。术语：*ponyfill*

+   此外，还有术语 *shim*，但它没有普遍认同的定义。它通常意味着与 *polyfill* 大致相同。

每次我们的 Web 应用程序启动时，它必须首先执行所有可能不在所有地方都有的功能的 polyfills。之后，我们可以确信那些功能是原生可用的。

#### 29.17.1 本节来源

+   [“什么是 Polyfill？”](https://remysharp.com/2010/10/08/what-is-a-polyfill) —— 由 Remy Sharp 撰写

+   “副本”一词的灵感来源：[拉斯维加斯的埃菲尔铁塔](https://en.wikipedia.org/wiki/Paris_Las_Vegas)

+   对“polyfill”及相关术语的有用解释：[“Polyfills and the evolution of the Web”](https://www.w3.org/2001/tag/doc/polyfills/). 编辑：Andrew Betts.
