# 39 WeakSet（WeakSet）ES6（高级）

> 原文：[`exploringjs.com/js/book/ch_weaksets.html`](https://exploringjs.com/js/book/ch_weaksets.html)

1.  39.1 WeakSet 与 Set 有何不同？

1.  39.2 WeakSet 的使用场景：标记对象

    1.  39.2.1 示例：使用方法标记对象为安全使用

1.  39.3 WeakSet API

### 39.1 WeakSet 与 Set 有何不同？

WeakSet 与 Set 类似，但有以下区别：

+   它们可以持有对象，而不会阻止这些对象被垃圾回收。

+   它们是黑盒：我们只有在拥有 WeakSet 和值的情况下才能从 WeakSet 中获取任何数据。支持的方法只有`.add()`、`.delete()`和`.has()`。请参阅 WeakMaps 作为黑盒部分，了解为什么 WeakSet 不允许迭代、循环和清除的原因。

### 39.2 WeakSet 的使用场景：标记对象

由于我们无法遍历 WeakSet 的元素，因此它们的使用场景并不多。

我们可以使用 WeakSet 来标记对象——例如：

```js
const isSaved = new WeakSet();
{
  const obj = {};
  isSaved.add(obj); // (A)
  assert.equal(
    isSaved.has(obj), // (B)
    true
  );
}
// (C)

```

+   在行 A 中，我们将`obj`标记为已保存。

+   在行 B 中，我们检查`obj`是否已保存。

+   在行 C 中，即使`obj`是数据结构`isSaved`的一个元素，它也可以被垃圾回收。

从某种意义上说，我们为`obj`创建了一个布尔属性，但将其外部存储。如果`isSaved`是一个属性，那么前面的代码将如下所示：

```js
{
  const obj = {};
  obj.isSaved = true;
  assert.equal(
    obj.isSaved,
    true
  );
}

```

#### 39.2.1 示例：使用方法标记对象为安全使用

以下代码演示了如何确保一个类只对其由其创建的实例应用其方法（基于[Domenic Denicola 的代码](https://esdiscuss.org/topic/actual-weakset-use-cases#content-1)）：

```js
const instancesOfSafeClass = new WeakSet();

class SafeClass {
  constructor() {
 instancesOfSafeClass.add(this);
 }

 method() {
 if (!instancesOfSafeClass.has(this)) {
 throw new TypeError('Incompatible object!');
 }
 }
}

const safeInstance = new SafeClass();
safeInstance.method(); // works

assert.throws(
 () => {
 const obj = {};
 SafeClass.prototype.method.call(obj); // throws an exception
 },
 TypeError
); 
```

### 39.3 WeakSet API

构造函数和`WeakSet`的三个方法与它们的`Set`等价物的工作方式相同[参考 ch_sets.html#quickref-sets]：

+   `new WeakSet<T>(values?: Iterable<T>)` ^（ES6）

+   `.add(value: T): this` ^（ES6）

+   `.delete(value: T): boolean` ^（ES6）

+   `.has(value: T): boolean` ^（ES6）
