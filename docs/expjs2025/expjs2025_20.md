# 16 非值 `undefined` 和 `null`

> 原文：[`exploringjs.com/js/book/ch_undefined-null.html`](https://exploringjs.com/js/book/ch_undefined-null.html)

1.  16.1 `undefined` 与 `null` 的比较

1.  16.2 `undefined` 和 `null` 的出现情况

    1.  16.2.1 `undefined` 的出现情况

    1.  16.2.2 `null` 的出现情况

1.  16.3 检查 `undefined` 或 `null`

1.  16.4 用于默认值的空值合并运算符 (`??`) (ES2020)

    1.  16.4.0.1 `??` 是短路操作

    1.  16.4.1 示例：计算匹配项

    1.  16.4.2 示例：为属性指定默认值

    1.  16.4.3 传统方法：使用逻辑或 (`||`) 设置默认值

    1.  16.4.4 空值合并赋值运算符 (`??=`) (ES2021)

1.  16.5 `undefined` 和 `null` 没有属性

1.  16.6 `undefined` 和 `null` 的历史

许多编程语言都有一个名为 `null` 的“非值”。它表示变量当前不指向对象——例如，当它尚未初始化时。

相比之下，JavaScript 有两个这样的值：`undefined` 和 `null`。

### 16.1 `undefined` 与 `null` 的比较

这两个值非常相似，通常可以互换使用。它们之间的区别因此很微妙。语言本身做出了以下区分：

+   `undefined` 表示“未初始化”（例如，一个变量）或“不存在”（例如，一个对象的属性）。

+   `null` 表示“任何对象值的故意缺失”（来自 [语言规范](https://tc39.es/ecma262/#sec-null-value) 的引用）。

程序员有时会做出以下区分：

+   `undefined` 是语言中使用的非值（当某物未初始化时等）。

+   `null` 表示“显式关闭”。也就是说，它有助于实现一种包含有意义的值和表示“无有意义的值”的元值的类型。这种类型在函数式编程中称为 [*选项类型* 或 *可能类型*](https://en.wikipedia.org/wiki/Option_type)。

### 16.2 `undefined` 和 `null` 的出现情况

以下小节描述了 `undefined` 和 `null` 在语言中的出现位置。我们将在本书的后续部分更详细地解释几个机制。

#### 16.2.1 `undefined` 的出现情况

未初始化的变量 `myVar`:

```js
let myVar;
assert.equal(myVar, undefined);

```

参数 `x` 未提供:

```js
function func(x) {
  return x;
}
assert.equal(func(), undefined);

```

属性 `.unknownProp` 缺失:

```js
const obj = {};
assert.equal(obj.unknownProp, undefined);

```

如果我们没有通过 `return` 语句显式指定函数的结果，JavaScript 会为我们返回 `undefined`：

```js
function func() {}
assert.equal(func(), undefined);

```

#### 16.2.2 `null` 的出现情况

对象的原型要么是一个对象，要么是原型链末尾的 `null`。`Object.prototype` 没有原型：

```js
> Object.getPrototypeOf(Object.prototype)
null

```

如果我们将正则表达式（例如 `/a/`）与字符串（例如 `'x'`）匹配，我们要么得到一个包含匹配数据的对象（如果匹配成功），要么得到 `null`（如果匹配失败）：

```js
> /a/.exec('x')
null

```

JSON 数据格式 不支持 `undefined`，只支持 `null`：

```js
> JSON.stringify({a: undefined, b: null})
'{"b":null}'

```

### 16.3 检查 `undefined` 或 `null`

检查以下任一：

```js
if (x === null) ···
if (x === undefined) ···

```

`x` 有值吗？

```js
if (x !== undefined && x !== null) {
  // ···
}
if (x) { // truthy?
  // x is neither: undefined, null, false, 0, NaN, 0n, ''
}

```

`x` 是 `undefined` 或 `null` 吗？

```js
if (x === undefined || x === null) {
  // ···
}
if (!x) { // falsy?
  // x is: undefined, null, false, 0, NaN, 0n, ''
}

```

*真值*意味着“如果转换为布尔值则为 `true`”。*假值*意味着“如果转换为布尔值则为 `false`”。这两个概念在“假值和真值” (§17.2) 中得到了适当的解释。

### 16.4 空值合并运算符 (`??`) 用于默认值 (ES2020)

空值合并运算符（`??`）允许我们在值是 `undefined` 或 `null` 时使用默认值：

```js
value ?? defaultValue

```

+   如果 `value` 不是 `undefined` 或 `null`，则评估 `defaultValue` 并返回结果。

+   否则，返回 `value`。

示例：

```js
> undefined ?? 'default'
'default'
> null ?? 'default'
'default'
> false ?? 'default'
false
> 0 ?? 'default'
0
> '' ?? 'default'
''
> {} ?? 'default'
{}

```

##### 16.4.0.1 `??` 是短路操作

`??` 是短路操作 – 只有当右侧实际上被使用时，它才会被评估：

```js
let evaluated = false;

// Right-hand side is not used
123 ?? (evaluated = true);
assert.equal(evaluated, false);

// Right-hand side is used
undefined ?? (evaluated = true);
assert.equal(evaluated, true);

```

#### 16.4.1 示例：计数火柴

以下代码展示了现实世界的一个例子：

```js
function countMatches(regex, str) {
  const matchResult = str.match(regex); // null or Array
  return (matchResult ?? []).length;
}

assert.equal(
  countMatches(/a/g, 'ababa'), 3
);
assert.equal(
  countMatches(/b/g, 'ababa'), 2
);
assert.equal(
  countMatches(/x/g, 'ababa'), 0
);

```

如果 `regex` 在 `str` 内有一个或多个匹配项，则 `.match()` 返回一个数组。如果没有匹配项，它不幸地返回 `null`（而不是空数组）。我们通过 `??` 运算符来修复这个问题。

我们也可以使用 可选链：

```js
return matchResult?.length ?? 0;

```

#### 16.4.2 示例：为属性指定默认值

```js
function getTitle(fileDesc) {
  return fileDesc.title ?? '(Untitled)';
}

const files = [
  { path: 'index.html', title: 'Home' },
  { path: 'tmp.html' },
];
assert.deepEqual(
  files.map(f => getTitle(f)),
  ['Home', '(Untitled)']
);

```

#### 16.4.3 旧方法：使用逻辑或 (`||`) 作为默认值

在 ECMAScript 2020 和空值合并运算符之前，逻辑或用于默认值。这有一个缺点。

`||` 对 `undefined` 和 `null` 的处理是预期的：

```js
> undefined || 'default'
'default'
> null || 'default'
'default'

```

但它也返回所有其他假值（例如）的默认值：

```js
> false || 'default'
'default'
> 0 || 'default'
'default'
> 0n || 'default'
'default'
> '' || 'default'
'default'

```

将此与 `??` 的工作方式进行比较：

```js
> undefined ?? 'default'
'default'
> null ?? 'default'
'default'

> false ?? 'default'
false
> 0 ?? 'default'
0
> 0n ?? 'default'
0n
> '' ?? 'default'
''

```

#### 16.4.4 空值合并赋值运算符 (`??=`) (ES2021)

空值合并赋值运算符（`??=`）在值是 `undefined` 或 `null` 时分配一个默认值：

```js
value ??= defaultValue

```

+   如果 `value` 是 `undefined` 或 `null`，则评估 `defaultValue` 并将其分配给 `value`。

+   否则，不发生任何操作。

示例：

```js
let value;

value = undefined;
value ??= 'DEFAULT';
assert.equal(
  value, 'DEFAULT'
);

value = 0;
value ??= 'DEFAULT';
assert.equal(
  value, 0
);

```

##### 16.4.4.1 `??=` 是短路操作

以下两个表达式大致等价：

```js
a ??= b
a ?? (a = b)

```

这意味着 `??=` 是短路操作 – 只有当 `a` 是 `undefined` 或 `null` 时，以下两个操作才会发生：

+   `b` 被评估。

+   结果被分配给 `a`。

```js
let value;

value = undefined;
value ??= console.log('evaluated');

value = 0;
value ??= console.log('NOT EVALUATED');

```

```js
evaluated

```

##### 16.4.4.2 示例：使用 `??=` 添加缺失的属性

```js
const books = [
  {
    isbn: '123',
  },
  {
    title: 'ECMAScript Language Specification',
    isbn: '456',
  },
];

// Add property .title where it’s missing
for (const book of books) {
  book.title ??= '(Untitled)';
}

assert.deepEqual(
  books,
  [
    {
      isbn: '123',
      title: '(Untitled)',
    },
    {
      title: 'ECMAScript Language Specification',
      isbn: '456',
    },
  ]);

```

### 16.5 `undefined` 和 `null` 没有属性

`undefined` 和 `null` 是 JavaScript 中唯一两个尝试读取属性时会抛出异常的值。为了探索这一现象，让我们使用以下函数，该函数读取（获取）属性 `.prop` 并返回结果。

```js
function getProp(x) {
  return x.prop;
}

```

如果我们将 `getProp()` 应用到各种值上，我们可以看到它只对 `undefined` 和 `null` 失败：

```js
> getProp(undefined)
TypeError: Cannot read properties of undefined (reading 'prop')
> getProp(null)
TypeError: Cannot read properties of null (reading 'prop')

> getProp(true)
undefined
> getProp({})
undefined

```

### 16.6 `undefined` 和 `null` 的历史

在 Java（它启发了 JavaScript 的许多方面）中，初始化值取决于变量的静态类型：

+   对象类型的变量使用 `null` 进行初始化。

+   每个原始类型都有自己的初始化值。例如，`int` 类型的变量初始化为 `0`。

JavaScript 借用了 `null` 并在期望对象的地方使用它。它意味着“不是一个对象”。

然而，JavaScript 中的存储位置（变量、属性等）可以存储原始值或对象。它们需要一个表示“既不是对象也不是原始值”的初始化值。这就是为什么引入了 `undefined` 的原因。
