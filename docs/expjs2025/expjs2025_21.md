# 17 布尔值

> 原文：[`exploringjs.com/js/book/ch_booleans.html`](https://exploringjs.com/js/book/ch_booleans.html)

1.  17.1 转换为布尔值

1.  17.2 假值和真值

    1.  17.2.1 检查真值或假值

1.  17.3 基于真值的检查

    1.  17.3.1 陷阱：基于真值的存在检查是不精确的

    1.  17.3.2 用例：是否提供了参数？

    1.  17.3.3 用例：属性是否存在？

1.  17.4 条件运算符(`? :`)

1.  17.5 二元逻辑运算符：与(`x && y`)，或(`x || y`)

    1.  17.5.1 值保留

    1.  17.5.2 短路

    1.  17.5.3 逻辑与 (`x && y`)

    1.  17.5.4 逻辑或 (`||`)

1.  17.6 逻辑非(`!`)

原始类型*布尔*包含两个值——`false`和`true`：

```js
> typeof false
'boolean'
> typeof true
'boolean'

```

### 17.1 转换为布尔值

![图标“详情”](img/38ba63de820aae6f94a019538ae0f222.png) **“转换为[type]”的含义**

“转换为[type]”是“将任意值转换为[type]类型值”的简称。

这是我们将任意值`x`转换为布尔值的三种方式。

+   `Boolean(x)`

    最具描述性；推荐。

+   `x ? true : false`

    使用条件运算符（将在本章后面解释条件运算符）。

+   `!!x`

    使用逻辑非运算符(`!`)。此运算符将操作数强制转换为布尔值。它被第二次应用以获取非取反的结果。

表 17.1 描述了各种值如何转换为布尔值。

| `x` | `Boolean(x)` |
| --- | --- |
| `undefined` | `false` |
| `null` | `false` |
| 布尔 | `x`（无变化） |
| 数字 | `0` → `false`，`NaN` → `false` |
|  | 其他数字 → `true` |
| 大整数 | `0` → `false` |
|  | 其他数字 → `true` |
| 字符串 | `''` → `false` |
|  | 其他字符串 → `true` |
| 符号 | `true` |
| 对象 | 总是`true` |

表 17.1：将值转换为布尔值。

### 17.2 假值和真值

在 JavaScript 期望布尔值的大多数位置，我们可以使用任意值，JavaScript 会在使用之前将其转换为布尔值。例如包括：

+   `if` 语句的条件

+   `while` 循环的条件

+   `do-while` 循环的条件

考虑以下 `if` 语句：

```js
if (value) {}

```

在许多编程语言中，此条件等同于：

```js
if (value === true) {}

```

然而，在 JavaScript 中，它等同于：

```js
if (Boolean(value) === true) {}

```

即，JavaScript 检查`value`转换为布尔值时是否为`true`。这种检查非常常见，因此引入了以下名称：

+   当一个值转换为布尔值时，如果它是`true`，则称为*真值*。

+   当一个值转换为布尔值时，如果它是`false`，则称为*假值*。

每个值要么是真值，要么是假值。这是假值的不完全列表：

+   `undefined`

+   `null`

+   布尔：`false`

+   数字：`0`，`NaN`

+   BigInt: `0n`

+   String: `''`

所有其他值（包括所有对象）都是真值：

```js
> Boolean('abc')
true
> Boolean([])
true
> Boolean({})
true

```

#### 17.2.1 检查真值或假值

```js
if (x) {
  // x is truthy
}

if (!x) {
  // x is falsy
}

if (x) {
  // x is truthy
} else {
  // x is falsy
}

const result = x ? 'truthy' : 'falsy';

```

在最后一行使用的条件操作符，将在本章后面解释条件操作符。

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：真值**

`exercises/booleans/truthiness_exrc.mjs`

### 17.3 基于真值的存在检查

在 JavaScript 中，如果我们读取不存在的某个值（例如，缺失的参数或缺失的属性），我们通常得到`undefined`作为结果。在这些情况下，存在检查相当于比较一个值与`undefined`。例如，以下代码检查对象`obj`是否有属性`.prop`：

```js
if (obj.prop !== undefined) {
  // obj has property .prop
}

```

由于`undefined`是假值，我们可以将这个检查简化为：

```js
if (obj.prop) {
  // obj has property .prop
}

```

#### 17.3.1 陷阱：基于真值的存在检查是不精确的

基于真值的存在检查有一个陷阱：它们不是很精确。考虑这个先前的例子：

```js
if (obj.prop) {
  // obj has property .prop
}

```

如果以下条件成立，则跳过`if`语句的主体：

+   `obj.prop`缺失（在这种情况下，JavaScript 返回`undefined`）。

然而，如果以下条件成立，它也会被跳过：

+   `obj.prop`是`undefined`。

+   `obj.prop`是任何其他假值（`null`，`0`，`''`等）。

在实践中，这很少引起问题，但我们必须意识到这个陷阱。

#### 17.3.2 用例：参数是否提供？

真值检查常用于确定函数的调用者是否提供了参数：

```js
function func(x) {
  if (!x) {
    throw new Error('Missing parameter x');
  }
  // ···
}

```

优点在于，这种模式已经建立并且简短。它正确地抛出`undefined`和`null`的错误。

缺点在于，之前提到的陷阱：代码也会为所有其他假值抛出错误。

另一个选择是检查`undefined`：

```js
if (x === undefined) {
  throw new Error('Missing parameter x');
}

```

#### 17.3.3 用例：属性是否存在？

真值检查也常用于确定属性是否存在：

```js
function readFile(fileDesc) {
  if (!fileDesc.path) {
    throw new Error('Missing property: .path');
  }
  // ···
}
readFile({ path: 'foo.txt' }); // no error

```

这种模式已经建立，并且有通常的注意事项：它不仅会在属性缺失时抛出错误，而且如果属性存在并且具有任何假值也会抛出错误。

如果我们真正想检查属性是否存在，我们必须使用`in`操作符：

```js
if (! ('path' in fileDesc)) {
  throw new Error('Missing property: .path');
}

```

### 17.4 条件操作符（`? :`）

条件操作符是`if`语句的表达式版本。其语法是：

```js
«condition» ? «thenExpression» : «elseExpression»

```

它的评估方式如下：

+   如果`condition`是真值，则评估并返回`thenExpression`。

+   否则，评估并返回`elseExpression`。

条件操作符也被称为*三元操作符*，因为它有三个操作数。

示例：

```js
> true ? 'yes' : 'no'
'yes'
> false ? 'yes' : 'no'
'no'
> '' ? 'yes' : 'no'
'no'

```

以下代码演示了无论通过条件选择的是“then”分支还是“else”分支，只有那个分支会被评估。另一个分支则不会。

```js
const x = (true ? console.log('then') : console.log('else'));

```

输出：

```js
then

```

### 17.5 二元逻辑运算符：与（`x && y`）、或（`x || y`）

JavaScript 有两种二元逻辑运算符：

+   逻辑与（`x && y`）

+   逻辑或（`x || y`）

它们是*值保留*和*短路*的。

#### 17.5.1 值保留

*值保留*意味着操作数被解释为布尔值，但返回时不改变：

```js
> 12 || 'hello'
12
> 0 || 'hello'
'hello'

```

#### 17.5.2 短路

*短路*意味着如果第一个操作数已经决定了结果，则不会评估第二个操作数。唯一其他延迟评估其操作数的运算符是条件运算符。通常，在执行操作之前，所有操作数都会被评估。

例如，逻辑与（`&&`）如果第一个操作数是假值，则不会评估其第二个操作数：

```js
const x = false && console.log('hello');
// No output

```

如果第一个操作数是真值，则执行`console.log()`：

```js
const x = true && console.log('hello');

```

输出：

```js
hello

```

#### 17.5.3 逻辑与（`x && y`）

表达式`a && b`（“`a` 与 `b`”）的评估如下：

1.  评估`a`。

1.  结果是否为假值？返回它。

1.  否则，评估`b`并返回结果。

换句话说，以下两个表达式大致等价：

```js
a && b
!a ? a : b

```

示例：

```js
> false && true
false
> false && 'abc'
false

> true && false
false
> true && 'abc'
'abc'

> '' && 'abc'
''

```

#### 17.5.4 逻辑或（`||`）

表达式`a || b`（“`a` 或 `b`”）的评估如下：

1.  评估`a`。

1.  结果是否为真值？返回它。

1.  否则，评估`b`并返回结果。

换句话说，以下两个表达式大致等价：

```js
a || b
a ? a : b

```

示例：

```js
> true || false
true
> true || 'abc'
true

> false || true
true
> false || 'abc'
'abc'

> 'abc' || 'def'
'abc'

```

##### 17.5.4.1 逻辑或（`||`）的遗留用例：提供默认值

ECMAScript 2020 引入了空值合并运算符（`??`）用于默认值。在此之前，逻辑或用于此目的：

```js
const valueToUse = receivedValue || defaultValue;

```

有关`??`和在此情况下`||`的缺点，请参阅“用于默认值的空值合并运算符（`??`）^(ES2020)”（§16.4）以获取更多信息。

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **遗留练习：通过或运算符（`||`）提供默认值**

`exercises/booleans/default_via_or_exrc.mjs`

### 17.6 逻辑非（`!`）

表达式`!x`（“非`x`”）的评估如下：

1.  评估`x`。

1.  将结果强制转换为布尔值。

1.  那个结果是否为`true`？返回`false`。

1.  返回`true`。

示例：

```js
> !false
true
> !true
false

> !0
true
> !123
false

> !''
true
> !'abc'
false

```
