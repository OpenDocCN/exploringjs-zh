# 14 值

> 原文：[`exploringjs.com/js/book/ch_values.html`](https://exploringjs.com/js/book/ch_values.html)

1.  14.1 什么是类型？

1.  14.2 JavaScript 的类型层次

1.  14.3 语言规范中的类型

1.  14.4 原始值与对象

1.  14.5 原始值（简称原始类型）

    1.  14.5.1 原始类型是不可变的

    1.  14.5.2 原始类型是*按值传递*的

    1.  14.5.3 原始类型是*按值比较*的

1.  14.6 对象

    1.  14.6.1 对象默认是可变的

    1.  14.6.2 对象是*按身份传递*的

    1.  14.6.3 对象是*按身份比较*的

    1.  14.6.4 按引用传递与按身份传递（高级）

    1.  14.6.5 ECMAScript 规范中的身份（高级）

1.  14.7 运算符 `typeof` 和 `instanceof`：值的类型是什么？

    1.  14.7.1 `typeof`运算符

    1.  14.7.2 `instanceof`运算符

1.  14.8 类和构造函数

    1.  14.8.1 与原始类型关联的构造函数

1.  14.9 在类型之间进行转换

    1.  14.9.1 类型之间的显式转换

    1.  14.9.2 类型转换（类型之间的自动转换）

在本章中，我们将探讨 JavaScript 有哪些类型的值。

![图标“阅读”](img/0fb62b2fc33a72829ae9fb174dedd0d2.png) **支持工具：`===`**

在本章中，我们偶尔会使用严格相等运算符。`a === b` 如果 `a` 和 `b` 相等，则计算结果为 `true`。这究竟意味着什么将在“严格相等（`===` 和 `!==`）”（§15.5.1）中解释。

### 14.1 什么是类型？

对于本章，我认为类型是值集的集合——例如，类型 `boolean` 是集合 `{ `false`, `true` }`。

### 14.2 JavaScript 的类型层次

![图片](img/86e9cf484c901c5e9bd1b2ee4a0d1ba7.png)

图 14.1：JavaScript 类型的一个部分层次结构。缺失的是错误类、与原始类型关联的类以及更多。

图 14.1 展示了 JavaScript 的类型层次结构：

+   JavaScript 区分两种类型的值：原始值和对象。我们很快就会看到它们之间的区别。

+   图表暗示了一个重要的事实：某些对象不是 `Object` 类的实例（更多信息）。然而，这样的对象很少见。我们几乎会遇到的所有对象确实是 `Object` 的实例。

### 14.3 语言规范中的类型

ECMAScript 规范只知道总共八种类型。这些类型的名称是（我使用 TypeScript 的名称，而不是规范中的名称）：

+   `undefined` 类型，其唯一元素为 `undefined`

+   `null` 类型，其唯一元素为 `null`

+   `boolean` 类型，其元素为 `false` 和 `true`

+   `number` 类型，所有数字的类型（例如，`-123`、`3.141`）

+   `bigint` 类型，所有大整数的类型（例如，`-123n`）

+   `string` 类型，所有字符串的类型（例如，`'abc'`）

+   `symbol` 类型，所有符号的类型（例如，`Symbol('My Symbol')`）

+   `object` 类型，所有对象的类型（不同于 `Object` 类型，它是所有 `Object` 类及其子类的实例的类型）

### 14.4 原始值与对象

规范在值之间做出了重要的区分：

+   *原始值* 是类型 `undefined`、`null`、`boolean`、`number`、`bigint`、`string`、`symbol` 的元素。

+   所有其他值都是 *对象*。

与 Java（在这里启发了 JavaScript）相比，原始值不是二等公民。它们与对象之间的区别更为微妙。简而言之：

+   原始值：是 JavaScript 中数据的原子构建块。

    +   它们是通过值传递的：当原始值被赋给变量或传递给函数时，它们的内容会被复制。

    +   它们是通过值来比较的：当比较两个原始值时，比较的是它们的值内容。

+   对象：是复合数据块。

    +   它们是通过标识传递的（新术语）：当对象被赋给变量或传递给函数时，它们的标识（想想指针）会被复制。

    +   它们是通过标识来比较的（新术语）：当比较两个对象时，比较的是它们的标识。

除了这些，原始值和对象相当相似：它们都有 *属性*（键值对）并且可以在相同的位置使用。

接下来，我们将更深入地探讨原始值和对象。

### 14.5 原始值（简称：原始值）

#### 14.5.1 原始值是不可变的

我们不能改变、添加或删除原始值的属性：

```js
const str = 'abc';
assert.equal(str.length, 3);
assert.throws(
  () => { str.length = 1 },
  /^TypeError: Cannot assign to read only property 'length'/
);

```

#### 14.5.2 原始值是通过值传递的

原始值是通过值传递的：变量（包括参数）存储原始值的值。当将原始值赋给变量或将它作为函数的参数传递时，其内容会被复制。

```js
const x = 123;
const y = x;
// `y` is the same as any other number 123
assert.equal(y, 123);

```

![图标“详情”](img/38ba63de820aae6f94a019538ae0f222.png) **观察值传递和标识传递之间的差异**

由于原始值是不可变的并且按值比较（见下一小节），因此无法观察到按值传递和按标识符传递（如 JavaScript 中用于对象的）之间的区别。

#### 14.5.3 原始值通过值比较

原始值通过值比较：当比较两个原始值时，我们比较它们的内部内容。

```js
assert.equal(123 === 123, true);
assert.equal('abc' === 'abc', true);

```

要了解这种比较方式有何特别之处，请继续阅读并了解对象是如何比较的。

### 14.6 对象

对象在“对象”（§30）和下一章中进行了详细说明。在这里，我们主要关注它们与原始值的不同之处。

让我们先探索两种常见的创建对象的方法：

+   对象字面量：

    ```js
    const obj = {
      first: 'Jane',
      last: 'Doe',
    };

    ```

    对象字面量以花括号 `{}` 开头和结尾。它创建一个具有两个属性的对象。第一个属性具有键 `'first'`（一个字符串）和值 `'Jane'`。第二个属性具有键 `'last'` 和值 `'Doe'`。有关对象字面量的更多信息，请参阅“对象字面量：属性”（§30.3.1）。

+   数组字面量：

    ```js
    const fruits = ['strawberry', 'apple'];

    ```

    数组字面量以方括号 `[]` 开头和结尾。它创建一个包含两个 *元素* 的数组：`'strawberry'` 和 `'apple'`。有关数组字面量的更多信息，请参阅“创建、读取、写入数组”（§34.3.1）。

#### 14.6.1 对象默认是可变的

默认情况下，我们可以自由地更改、添加和删除对象的属性：

```js
const obj = {};

obj.count = 2; // add a property
assert.equal(obj.count, 2);

obj.count = 3; // change a property
assert.equal(obj.count, 3);

```

#### 14.6.2 对象通过标识符传递

对象通过标识符传递（新术语）：变量（包括参数）存储对象的 *标识符*。对象的标识符是对对象实际数据在 *堆*（JavaScript 进程的共享主内存）上的 *透明引用*（想想指针）。当将对象赋给变量或将它作为函数的参数传递时，其标识符被复制。

每个对象字面量在堆上创建一个新的对象并返回其标识符：

```js
const a = {}; // fresh empty object
// Pass the identity in `a` to `b`:
const b = a;

// Now `a` and `b` point to the same object
// (they “share” that object):
assert.equal(a === b, true);

// Changing `a` also changes `b`:
a.name = 'Tessa';
assert.equal(b.name, 'Tessa');

```

JavaScript 使用 *垃圾回收* 来自动管理内存：

```js
let obj = { prop: 'value' };
obj = {};

```

现在，`obj` 的旧值 `{ prop: 'value' }` 是 *垃圾*（不再使用）。JavaScript 将自动 *垃圾回收* 它（在某个时间点从内存中删除），（可能永远不会，如果内存足够的话）。

#### 14.6.3 对象通过标识符比较

对象通过标识符比较（新术语）：只有当两个变量包含相同的对象标识符时，它们才相等。如果它们引用的是具有相同内容的不同对象，则它们不相等。

```js
const obj = {}; // fresh empty object
assert.equal(obj === obj, true); // same identity
assert.equal({} === {}, false); // different identities, same content

```

#### 14.6.4 按引用传递与按标识符传递（高级）

如果一个参数是 *按引用传递*，它指向一个变量，对参数的赋值会改变该变量 - 例如，在以下 C++ 代码中，参数 `x` 和 `y` 是按引用传递的。行 A 中的调用会影响调用者的变量 `a` 和 `b`。

```js
void swap_ints(int &x, int &y) {
  int temp = x;
  x = y;
  y = temp;
}
int main() {
  int a = 1;
  int b = 2;

  swap_ints(a, b); // (A)
  // Now `a` is 2 and `b` is 1

  return 0;
}

```

如果一个参数是 *按身份传递*（这是一个新术语），则对象的身份（一个透明引用）是按值传递的。对参数的赋值只有局部影响。这种方法也称为 [*按共享传递*](https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing)。

**认可：** 术语 *按身份传递* 是由 Allen Wirfs-Brock 在 2019 年 [建议](https://x.com/awbjs/status/1086919101635801088) 的。

#### 14.6.5 ECMAScript 规范中的身份（高级）

ECMAScript 规范如下使用术语 *身份* ([来源](https://tc39.es/ecma262/#sec-identity))：

+   *没有身份的值* 如果它们的所有固有特征都相同，则等于其他没有身份的值 - 例如整数的幅度或序列的长度。

    +   没有身份的值可以通过完全描述其特征来在没有先前引用的情况下显现。

+   相反，每个 *具有身份的值* 都是唯一的，因此仅等于自身。具有身份的值类似于没有身份的值，但有一个额外的不可猜测的、不可更改的、普遍唯一的特征，称为身份。

    +   对现有具有身份的值的引用不能仅仅通过描述它们来显现，因为身份本身是不可描述的；相反，这些值的引用必须明确地从一处传递到另一处。

    +   一些具有身份的值是可变的，因此它们的特点（除了它们的身份）可以在原地更改，导致所有持有该值的对象观察到新的特点。

在语言级别上：

+   具有身份的值：通过 `Symbol()` 创建的对象和符号

+   没有身份的值：原始值和通过 `Symbol.for()` 创建的符号

### 14.7 运算符 `typeof` 和 `instanceof`：值的类型是什么？

两个运算符 `typeof` 和 `instanceof` 允许我们确定给定值 `x` 的类型：

```js
if (typeof x === 'string') ···
if (x instanceof Array) ···

```

它们有何不同？

+   `typeof` 区分了规范中的 7 种类型（减去一个省略，加上一个增加）。

+   `instanceof` 测试哪个类创建了给定的值。

![图标“提示”](img/8440b17bb8219cda9f9405ac83c36db0.png) **经验法则：`typeof` 用于原始值；`instanceof` 用于对象**

#### 14.7.1 `typeof` 操作符

| `x` | `typeof x` |
| --- | --- |
| `undefined` | `'undefined'` |
| `null` | `'object'` |
| 布尔值 | `'boolean'` |
| 数字 | `'number'` |
| 大整数 | `'bigint'` |
| 字符串 | `'string'` |
| 符号 | `'symbol'` |
| 函数 | `'function'` |
| 所有其他对象 | `'object'` |

表 14.1：`typeof` 操作符的结果。

表 14.1 列出了 `typeof` 的所有结果。它们大致对应于语言规范的 7 种类型。遗憾的是，有两个差异，它们是语言的怪癖：

+   `typeof null` 返回 `'object'` 而不是 `'null'`。这是一个错误。不幸的是，它无法修复。TC39 尝试这样做，但它破坏了网络上太多的代码。

+   函数的 `typeof` 应该是 `'object'`（函数是对象）。引入一个单独的函数类别会让人困惑。

这些是使用 `typeof` 的几个示例：

```js
> typeof undefined
'undefined'
> typeof 123n
'bigint'
> typeof 'abc'
'string'
> typeof {}
'object'

```

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：关于 `typeof` 的两个练习**

+   `exercises/values/typeof_exrc.mjs`

+   奖励：`exercises/values/is_object_test.mjs`

#### 14.7.2 `instanceof` 操作符

这个操作符回答的问题是：类 `C` 是否创建了一个值 `x`？

```js
x instanceof C

```

例如：

```js
> (function() {}) instanceof Function
true
> ({}) instanceof Object
true
> [] instanceof Array
true 
```

原始值不是任何事物的实例：

```js
> 123 instanceof Number
false
> '' instanceof String
false
> '' instanceof Object
false

```

关于此操作符的更多信息，请参阅“`instanceof` 操作符的详细说明（高级）”（§31.7.3）。

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：`instanceof`**

`exercises/values/instanceof_exrc.mjs`

### 14.8 类和构造函数

JavaScript 的原始对象工厂是 *构造函数*：普通函数，如果我们通过 `new` 操作符调用它们，它们会返回“自身”的“实例”。

ES6 引入了 *类*，这主要是构造函数的更好语法。

在这本书中，我使用术语 *构造函数* 和 *类* 互换。

类可以将规范中的单个类型 `object` 划分为子类型——它们为我们提供了比规范中有限的 7 个类型更多的类型。每个类都是它所创建的对象的类型。

#### 14.8.1 与原始类型相关的构造函数

每个原始类型（除了 `undefined` 和 `null` 类型）都有一个相关的 *构造函数*（想想类）：

+   构造函数 `Boolean` 与布尔值相关联。

+   构造函数 `Number` 与数字相关联。

+   构造函数 `String` 与字符串相关联。

+   构造函数 `Symbol` 与符号相关联。

这些函数都扮演着几个角色——例如，`Number`：

+   我们可以用它作为函数并将值转换为数字：

    ```js
    assert.equal(Number('123'), 123);

    ```

+   `Number.prototype` 提供了数字的属性——例如，方法 `.toString()`：

    ```js
    assert.equal((123).toString, Number.prototype.toString);

    ```

+   `Number` 是数字工具函数的命名空间/容器对象——例如：

    ```js
    assert.equal(Number.isInteger(123), true);

    ```

+   最后，我们还可以使用 `Number` 作为类来创建数字对象。这些对象与实数不同，应该避免使用。它们几乎从未出现在正常代码中。更多信息请参见下一小节。

##### 14.8.1.1 原始值的包装类（高级）

如果我们使用与原始类型关联的构造函数进行 new 调用，它返回一个所谓的 *包装对象*。这是将原始值转换为对象的标准方式——通过“包装”它。

原始值不是包装类的实例：

```js
const prim = true;
assert.equal(typeof prim, 'boolean');
assert.equal(prim instanceof Boolean, false);

```

包装对象不是一个原始值：

```js
const wrapper = Object(prim);
assert.equal(typeof wrapper, 'object'); // not 'boolean'
assert.equal(wrapper instanceof Boolean, true);

```

我们可以解包包装对象以获取原始值：

```js
assert.equal(wrapper.valueOf(), prim); // unwrap

```

### 14.9 类型之间的转换

在 JavaScript 中，有两种方式可以将值转换为其他类型：

+   显式转换：通过如 `String()` 这样的函数。

+   *强制转换*（自动转换）：当操作接收它无法处理的操作数/参数时发生。

#### 14.9.1 显式类型转换

与原始类型关联的函数会显式地将值转换为该类型：

```js
> Boolean(0)
false
> Number('123')
123
> String(123)
'123'

```

我们还可以使用 `Object()` 将值转换为对象：

```js
> typeof Object(123)
'object'

```

下表更详细地描述了这种转换的工作方式：

| `x` | `Object(x)` |
| --- | --- |
| `undefined` | `{}` |
| `null` | `{}` |
| 布尔值 | `new Boolean(x)` |
| 数字 | `new Number(x)` |
| 大整数 | `BigInt` 的实例 (`new` 抛出 `TypeError`) |
| 字符串 | `new String(x)` |
| 符号 | `Symbol` 的实例 (`new` 抛出 `TypeError`) |
| 对象 | `x` |

#### 14.9.2 强制转换（类型之间的自动转换）

对于许多操作，如果操作数/参数的类型不匹配，JavaScript 会自动转换它们。这种自动转换称为 *强制转换*。

例如，乘法运算符会将其操作数强制转换为数字：

```js
> '7' * '3'
21

```

许多内置函数也会进行强制转换。例如，`Number.parseInt()` 在解析之前将其参数强制转换为字符串。这也解释了以下结果：

```js
> Number.parseInt(123.45)
123

```

在解析之前，数字 `123.45` 被转换为字符串 `'123.45'`。解析在第一个非数字字符之前停止，这就是为什么结果是 `123`。

![“练习”图标](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：将值转换为原始类型**

`exercises/values/conversion_exrc.mjs`
