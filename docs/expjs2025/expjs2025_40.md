# 33 同步生成器 ES6（高级）

> 原文：[`exploringjs.com/js/book/ch_sync-generators.html`](https://exploringjs.com/js/book/ch_sync-generators.html)

1.  33.1 什么是同步生成器？

    1.  33.1.1 生成器函数返回迭代器并通过 `yield` 填充它们

    1.  33.1.2 `yield` 暂停生成器函数

    1.  33.1.3 为什么 `yield` 会暂停执行？

    1.  33.1.4 示例：遍历可迭代对象

1.  33.2 从生成器中调用生成器（高级）

    1.  33.2.1 通过 `yield*` 调用生成器

    1.  33.2.2 示例：遍历树

1.  33.3 生成器的用例：重用遍历

    1.  33.3.1 背景：外部迭代与内部迭代

    1.  33.3.2 要重用的遍历

    1.  33.3.3 示例：内部迭代（推送）

    1.  33.3.4 外部迭代（拉取）

1.  33.4 生成器的高级功能

### 33.1 什么是同步生成器？

同步生成器是函数定义和方法定义的特殊版本，有助于处理同步可迭代对象和同步迭代器。它们总是返回同步迭代器（也是可迭代的）：

```js
// Generator function declaration
function* genFunc1() { /*···*/ }

// Generator function expression
const genFunc2 = function* () { /*···*/ };

// Generator method definition in an object literal
const obj = {
 * generatorMethod() {
 // ···
 }
};

// Generator method definition in a class definition
// (class declaration or class expression)
class MyClass {
 * generatorMethod() {
 // ···
 }
} 
```

星号 (`*`) 将函数和方法标记为生成器：

+   函数：伪关键字 `function*` 是 `function` 关键字和一个星号的组合。

+   方法：`*` 是一个修饰符（类似于 `static` 和 `get`）。

#### 33.1.1 生成器函数返回迭代器并通过 `yield` 填充它们

如果我们调用一个生成器函数，它将返回一个迭代器（该迭代器也是可迭代的——因为所有内置迭代器都是）。生成器通过 `yield` 操作符填充该迭代器：

```js
function* createIterator() {
 yield 'a';
 yield 'b';
}

// Converting the result to an Array
assert.deepEqual(
 // Using an Iterator method
 createIterator().toArray(),
 ['a', 'b']
);
assert.deepEqual(
 // The iterator is iterable, so Array.from() works
 Array.from(createIterator()),
 ['a', 'b']
);

// We can use for-of because the iterator is iterable
for (const x of createIterator()) {
 console.log(x);
}

```

输出：

```js
a
b

```

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：创建一个整数范围的迭代器**

`exercises/sync-generators/integer-range_test.mjs`

#### 33.1.2 `yield` 暂停生成器函数

使用生成器函数涉及以下步骤：

+   函数调用它返回一个迭代器 `iter`。

+   重复遍历 `iter` 将多次调用 `iter.next()`。每次，我们都会跳入生成器函数的体内，直到有一个 `yield` 返回一个值。

因此，`yield` 不仅向迭代器添加值，还暂停并退出生成器函数：

+   与 `return` 类似，`yield` 退出函数体并返回一个值（通过 `.next()`）。

+   与 `return` 不同，如果我们重复调用（`.next()`），执行将直接在 `yield` 之后恢复。

让我们通过以下生成器函数来检查这意味着什么。

```js
let location = 0;
function* genFunc2() {
 location = 1;
 yield 'a';
 location = 2;
 yield 'b';
 location = 3;
}

```

为了使用 `genFunc2()`，我们首先必须创建迭代器/可迭代对象 `iter`。`genFunc2()` 现在暂停在其主体“之前”。

```js
const iter = genFunc2();
// genFunc2() is now paused “before” its body:
assert.equal(location, 0);

```

`iter` 实现了迭代协议。因此，我们通过 `iter.next()` 控制执行 `genFunc2()`。调用该方法会恢复暂停的 `genFunc2()` 并执行它，直到出现 `yield`。然后执行暂停，`.next()` 返回 `yield` 的操作数：

```js
assert.deepEqual(
  iter.next(), {value: 'a', done: false});
// genFunc2() is now paused directly after the first `yield`:
assert.equal(location, 1);

```

注意，返回的值 `'a'` 被封装在一个对象中，这是迭代器始终传递其值的方式。

我们再次调用 `iter.next()`，执行继续到我们之前暂停的地方。一旦我们遇到第二个 `yield`，`genFunc2()` 暂停，`.next()` 返回返回的值 `'b'`。

```js
assert.deepEqual(
  iter.next(), {value: 'b', done: false});
// genFunc2() is now paused directly after the second `yield`:
assert.equal(location, 2);

```

我们再次调用 `iter.next()`，执行继续，直到它离开 `genFunc2()` 的主体：

```js
assert.deepEqual(
  iter.next(), {value: undefined, done: true});
// We have reached the end of genFunc2():
assert.equal(location, 3);

```

这次，`.next()` 的结果属性 `.done` 为 `true`，这意味着迭代器已结束。

#### 33.1.3 为什么 `yield` 会暂停执行？

`yield` 暂停执行的好处是什么？为什么它不像数组方法 `.push()` 那样简单地工作，在暂停之前填充迭代器中的值？

由于暂停，生成器提供了许多 *协程* 的功能（想想那些在合作中多任务处理的进程）。例如，当我们请求迭代器的下一个值时，该值是按需计算的（懒加载）。以下两个生成器函数演示了这意味着什么。

```js
/**
 * Returns an iterator over lines
 */
function* genLines() {
 yield 'A line';
 yield 'Another line';
 yield 'Last line';
}

/**
 * Input: iterable over lines
 * Output: iterator over numbered lines
 */
function* numberLines(lineIterable) {
 let lineNumber = 1;
 for (const line of lineIterable) { // input
 yield lineNumber + ': ' + line; // output
 lineNumber++;
 }
}

```

注意，`numberLines()` 中的 `yield` 出现在 `for-of` 循环内部。`yield` 可以在循环中使用，但不能在回调函数中使用（稍后会有更多介绍）。

让我们将两个生成器结合起来产生迭代器 `numberedLines`：

```js
const numberedLines = numberLines(genLines());
assert.deepEqual(
  numberedLines.next(),
  {value: '1: A line', done: false}
);
assert.deepEqual(
  numberedLines.next(),
  {value: '2: Another line', done: false}
);

```

使用生成器的关键好处是，一切都可以增量工作：通过 `numberedLines.next()`，我们只请求 `numberedLines()` 一个编号的行。反过来，它只请求 `genLines()` 一个未编号的行。

如果例如 `genLines()` 从大文本文件中读取其行，这种增量工作方式将继续有效：如果我们请求 `numberedLines()` 一个编号的行，一旦 `genLines()` 从文本文件中读取其第一行，我们就会得到一个编号的行。

没有生成器，`genLines()` 会首先读取所有行并返回它们。然后 `numberLines()` 会编号所有行并返回它们。因此，我们必须等待更长的时间才能得到第一个编号的行。

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：将普通函数转换为生成器**

`exercises/sync-generators/fib_seq_test.mjs`

#### 33.1.4 示例：映射到可迭代对象

以下函数 `mapIter()` 与数组方法 `.map()` 类似，但它返回一个迭代器，而不是数组，并且按需产生结果。

```js
function* mapIter(iterable, func) {
  let index = 0;
  for (const x of iterable) {
    yield func(x, index);
    index++;
  }
}

const iterator = mapIter(['a', 'b'], x => x + x);
assert.deepEqual(
  Array.from(iterator), ['aa', 'bb']
);

```

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：过滤可迭代对象**

`exercises/sync-generators/filter_iter_gen_test.mjs`

### 33.2 从生成器中调用生成器（高级）

#### 33.2.1 通过`yield*`调用生成器

`yield`仅在生成器内部直接使用——到目前为止，我们还没有看到将 yield 委托给另一个函数或方法的方法。

让我们先看看什么是不起作用的：在以下示例中，我们希望`compute()`调用`helper()`，以便后者为前者产生两个值。然而，一种天真方法失败了：

```js
function* helper() {
 yield 'a';
 yield 'b';
}
function* compute() {
 // Nothing happens if we call `helper()`:
 helper();
}
assert.deepEqual(
 Array.from(compute()), []
); 
```

为什么这不起作用？函数调用`helper()`返回一个迭代器，但我们忽略了它。

我们希望`compute()`产生`helper()`产生的所有值。这正是`yield*`操作符的作用：

```js
function* helper() {
 yield 'a';
 yield 'b';
}
function* compute() {
 yield* helper();
}
assert.deepEqual(
 Array.from(compute()), ['a', 'b']
); 
```

换句话说，之前的`compute()`大致等同于：

```js
function* compute() {
 for (const x of helper()) {
 yield x;
 }
}

```

注意，`yield*`与任何可迭代对象一起工作：

```js
function* gen() {
 yield* [1, 2];
}
assert.deepEqual(
 Array.from(gen()), [1, 2]
);

```

#### 33.2.2 示例：遍历树

`yield*`允许我们在生成器中进行递归调用，这在迭代递归数据结构（如树）时非常有用。以以下二叉树数据结构为例。

```js
class BinaryTree {
  constructor(value, left=null, right=null) {
    this.value = value;
    this.left = left;
    this.right = right;
  }

  /** Prefix iteration: parent before children */
  * [Symbol.iterator]() {
    yield this.value;
    if (this.left) {
      // Same as yield* this.left[Symbol.iterator]()
      yield* this.left;
    }
    if (this.right) {
      yield* this.right;
    }
  }
}

```

方法`[Symbol.iterator]()`添加了对迭代协议的支持，这意味着我们可以使用`for-of`循环来迭代`BinaryTree`的实例：

```js
const tree = new BinaryTree('a',
  new BinaryTree('b',
    new BinaryTree('c'),
    new BinaryTree('d')),
  new BinaryTree('e'));

for (const x of tree) {
  console.log(x);
}

```

输出：

```js
a
b
c
d
e

```

![练习图标“exercise”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：遍历嵌套数组**

`exercises/sync-generators/iter_nested_arrays_test.mjs`

### 33.3 生成器的用例：重用遍历

生成器的一个重要用例是提取和重用遍历。

#### 33.3.1 背景信息：外部迭代与内部迭代

在准备下一小节之前，我们需要了解两种不同的迭代对象“内部”值的方式：

+   外部迭代（拉取）：我们的代码通过迭代协议向对象请求值。例如，`for-of`循环基于 JavaScript 的迭代协议：

    ```js
    for (const x of ['a', 'b']) {
      console.log(x);
    }

    ```

    输出：

    ```js
    a
    b

    ```

+   内部迭代（推送）：我们将回调函数传递给对象的方法，该方法将值传递给回调。例如，数组有`.forEach()`方法：

    ```js
    ['a', 'b'].forEach((x) => {
      console.log(x);
    });

    ```

    输出：

    ```js
    a
    b

    ```

下一小节将提供两种迭代风格的示例。

#### 33.3.2 要重用的遍历

例如，考虑以下函数，它遍历文件树并记录它们的路径（它使用[Node.js API](https://nodejs.org/docs/latest/api/)来完成此操作）：

```js
function logPaths(dir) {
  for (const fileName of fs.readdirSync(dir)) {
    const filePath = path.join(dir, fileName);
    console.log(filePath);
    const stats = fs.statSync(filePath);
    if (stats.isDirectory()) {
      logPaths(filePath); // recursive call
    }
  }
}

```

考虑以下目录：

```js
mydir/
  a.txt
  b.txt
  subdir/
    c.txt

```

让我们在`mydir/`内部记录路径：

```js
logPaths('mydir');

```

输出：

```js
mydir/a.txt
mydir/b.txt
mydir/subdir
mydir/subdir/c.txt

```

我们如何重用这个遍历并做些其他的事情，而不仅仅是记录路径？

#### 33.3.3 示例：内部迭代（推送）

重用遍历代码的另一种方式是通过*内部迭代*：每个遍历的值都传递给一个回调（行 A）。

```js
function visitPaths(dir, callback) {
  for (const fileName of fs.readdirSync(dir)) {
    const filePath = path.join(dir, fileName);
    callback(filePath); // (A)
    const stats = fs.statSync(filePath);
    if (stats.isDirectory()) {
      visitPaths(filePath, callback);
    }
  }
}
const paths = [];
visitPaths('mydir', p => paths.push(p));
assert.deepEqual(
  paths,
  [
    'mydir/a.txt',
    'mydir/b.txt',
    'mydir/subdir',
    'mydir/subdir/c.txt',
  ]);

```

#### 33.3.4 外部迭代（拉取）

重用遍历代码的另一种方式是通过*外部迭代*：我们可以编写一个生成器，它产生所有遍历的值（行 A）。

```js
function* iterPaths(dir) {
  for (const fileName of fs.readdirSync(dir)) {
    const filePath = path.join(dir, fileName);
    yield filePath; // (A)
    const stats = fs.statSync(filePath);
    if (stats.isDirectory()) {
      yield* iterPaths(filePath);
    }
  }
}
const paths = Array.from(iterPaths('mydir'));

```

### 33.4 生成器的高级功能

*《探索 ES6》*中的[生成器章节](https://exploringjs.com/es6/ch_generators.html)涵盖了本书范围之外的两个特性：

+   `yield`也可以通过`.next()`的参数来`接收`数据。

+   生成器也可以`返回`值（而不仅仅是`yield`它们）。这些值不会成为迭代值，但可以通过`yield*`来检索。
