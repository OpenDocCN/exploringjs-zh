# 42 JavaScript 异步编程基础

> 原文：[`exploringjs.com/js/book/ch_async-js.html`](https://exploringjs.com/js/book/ch_async-js.html)

1.  42.1 事件循环

1.  42.2 如何避免阻塞 JavaScript 进程

    1.  42.2.1 浏览器用户界面可能会被阻塞

    1.  42.2.2 如何避免阻塞浏览器？

    1.  42.2.3 通过 `setTimeout()` 调度新任务

    1.  42.2.4 完成到运行语义

1.  42.3 异步结果传递模式

    1.  42.3.1 通过事件传递异步结果

    1.  42.3.2 通过回调传递异步结果

1.  42.4 异步代码的缺点

1.  42.5 资源

本章解释了 JavaScript 异步编程的基础。

### 42.1 事件循环

通常 JavaScript 在单个进程中运行 – 在网页浏览器和 Node.js 中都是如此。在这个单个进程中，*任务* 依次运行。一个 *任务* 是一段代码 – 想象一下没有参数的函数。任务通过队列进行管理：

+   *事件循环* 在 JavaScript 进程内部持续运行。在每次循环迭代中，它从队列中取出一个任务（如果队列为空，则等待直到不为空）并执行它。任务完成后，控制权返回到事件循环，然后从队列中检索下一个任务并执行它。如此循环。

+   *任务来源* 将任务添加到队列中。其中一些来源与 JavaScript 进程并发运行。例如，一个任务来源负责用户界面事件：如果用户点击某处并且注册了点击监听器，那么对该监听器的调用就会被添加到任务队列中。

以下 JavaScript 代码是事件循环的近似表示：

```js
while (true) {
  const task = taskQueue.dequeue();
  task(); // run task
}

```

事件循环在 图 42.1 中表示。

![](img/74ee57a8c7fc965c57f47cc602fdd8cf.png)

图 42.1：*任务来源* 将要运行的代码添加到 *任务队列* 中，该队列由 *事件循环* 清空。

### 42.2 如何避免阻塞 JavaScript 进程

#### 42.2.1 浏览器用户界面可能会被阻塞

浏览器的许多用户界面机制也在 JavaScript 进程中运行（作为任务）。因此，长时间运行的 JavaScript 代码可能会阻塞用户界面。让我们看看一个演示这一点的网页。我们可以通过两种方式尝试这个页面：

+   我们可以在 [在线运行它](http://rauschma.github.io/async-examples/blocking.html)。

+   我们可以在存储库中打开以下文件进行练习：`demos/async-js/blocking.html`

以下 HTML 是页面的用户界面：

```js
<a id="block" href="">Block</a>
<div id="statusMessage"></div>
<button>Click me!</button>

```

理念是点击“Block”，通过 JavaScript 执行一个长时间运行的循环。在循环期间，我们无法点击按钮，因为浏览器/JavaScript 进程被阻塞。

简化的 JavaScript 代码看起来像这样：

```js
document.getElementById('block')
  .addEventListener('click', doBlock); // (A)

function doBlock(event) {
  // ···
  displayStatus('Blocking...');
  // ···
  sleep(5000); // (B)
  displayStatus('Done');
}

function sleep(milliseconds) {
  const start = Date.now();
  while ((Date.now() - start) < milliseconds);
}
function displayStatus(status) {
  document.getElementById('statusMessage')
    .textContent = status;
}

```

这些是代码的关键部分：

+   行 A：我们告诉浏览器在点击 ID 为 `block` 的 HTML 元素时调用 `doBlock()`。

+   `doBlock()` 显示状态信息，然后调用 `sleep()` 以阻塞 JavaScript 进程 5000 毫秒（行 B）。

+   `sleep()` 通过循环直到经过足够的时间来阻塞 JavaScript 进程。

+   `displayStatus()` 在 ID 为 `statusMessage` 的 `<div>` 内显示状态消息。

#### 42.2.2 如何避免阻塞浏览器？

我们如何防止长时间运行的操作阻塞浏览器？

+   操作可以异步地提供其结果：一些操作，如下载文件，在 JavaScript 进程外部运行，并与它并发。如果我们调用这样的操作，我们向它提供一个回调。一旦操作完成，它将通过向队列中添加任务的方式调用回调并返回结果。这种提供结果的方式被称为异步，因为调用者等待结果时不会被阻塞：它可以做其他事情，并在结果准备好时得到通知。正常函数调用同步地提供其结果。我们的代码也可以异步地提供结果。我们很快就会了解更多关于异步代码的内容。

+   操作可以在单独的进程中执行：这可以通过所谓的 *Web Workers* 实现。Web Worker 是一个重量级进程，它与主进程并发运行。它有自己的运行时环境（全局变量等）。它是完全隔离的；通信通过消息传递进行。有关更多信息，请参阅 [MDN 网络文档](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)。

+   操作可以暂停并给队列中的挂起任务运行的机会——这可以解除浏览器的阻塞。下一小节将解释这是如何实现的。

#### 42.2.3 通过 `setTimeout()` 调度新任务

以下全局函数在延迟 `ms` 毫秒后执行其参数 `callback`（类型签名已简化 - `setTimeout()` 有更多功能）：

```js
function setTimeout(callback: () => void, ms: number): any

```

函数返回一个 *句柄*（一个 ID），可以用来 *清除* 超时（在回调执行之前取消执行）的以下全局函数：

```js
function clearTimeout(handle?: any): void

```

`setTimeout()` 在浏览器和 Node.js 中都可用。我们可以将 `setTimeout()` 视为为稍后执行的任务进行调度：

```js
console.log('First task starts');
setTimeout(
  () => { // (A)
    console.log('Second task starts');
  },
  0 // (B)
);
console.log('First task ends');

```

在第一个任务中，我们正在调度一个新的任务（从行 A 开始的回调）在零毫秒的延迟后运行（行 B）。

输出：

```js
First task starts
First task ends
Second task starts

```

另一种看待发生情况的方式是：**第一个任务暂停了一下，然后继续执行第二个任务**。

+   第一个任务运行。在它运行的同时，可能会触发事件，如点击事件，并导致任务被添加到队列中。这些任务只能在当前任务完成后才能运行。

+   第一个任务结束。现在其他任务可以运行。我们使用了零毫秒的延迟，所以所有在第二个任务之前添加到队列中的任务都将接下来运行。

+   第二个任务运行，继续第一个任务的工作。

换句话说：任务休息了一下，给了其他任务运行的机会。

#### 42.2.4 运行到完成语义

JavaScript 为任务提供保证：

> 每个任务总是在执行下一个任务之前完成（“运行到完成”）。

因此，任务在处理数据时不必担心数据被更改（*并发修改*）。这简化了 JavaScript 中的编程。

我们可以在前面的例子中观察到运行到完成：

```js
console.log('First task starts');
setTimeout(
  () => {
    console.log('Second task starts');
  },
  0
);
console.log('First task ends');

```

第一个任务在下一个任务开始之前就结束了。

### 42.3 异步传递结果的模式

为了避免在等待长时间运行的操作完成时阻塞主进程，结果通常在 JavaScript 中以异步方式传递。以下是三种流行的实现方式：

+   Events

+   Callbacks

+   Promises

前两个模式将在接下来的两个小节中解释。Promises 将在下一章中解释。

#### 42.3.1 通过事件传递异步结果

事件作为模式的工作方式如下：

+   它们用于异步传递值。

+   它们零次或多次这样做。

+   在这个模式中有三个角色：

    +   事件（一个对象）携带要传递的数据。

    +   *事件监听器*是一个通过参数接收事件的函数。

    +   *事件源*发送事件并允许我们注册事件监听器。

在 JavaScript 的世界中，存在多种这种模式的变体。我们将在下面看三个例子。

##### 42.3.1.1 事件：IndexedDB

IndexedDB 是内置在网页浏览器中的数据库。这是一个使用它的例子：

```js
const openRequest = indexedDB.open('MyDatabase', 1); // (A)

openRequest.onsuccess = (event) => {
  const db = event.target.result;
  // ···
};

openRequest.onerror = (error) => {
  console.error(error);
};

```

`indexedDB`调用操作的方式不寻常：

+   每个操作都有一个关联的方法来创建*请求对象*。例如，在行 A 中，操作是“open”，方法是`.open()`，请求对象是`openRequest`。

+   操作的参数通过请求对象提供，而不是通过方法参数提供。例如，事件监听器（函数）存储在属性`.onsuccess`和`.onerror`中。

+   通过方法（在行 A 中）将操作的调用添加到任务队列中。也就是说，我们在调用已经添加到队列之后配置操作。只有运行到完成语义才能让我们避免竞态条件，并确保操作在当前代码片段完成后运行。

##### 42.3.1.2 事件：`XMLHttpRequest`

`XMLHttpRequest` API 允许我们在网页浏览器内进行下载。这是下载文件 `http://example.com/textfile.txt` 的方法：

```js
const xhr = new XMLHttpRequest(); // (A)
xhr.open('GET', 'http://example.com/textfile.txt'); // (B)
xhr.onload = () => { // (C)
  if (xhr.status == 200) {
    processData(xhr.responseText);
  } else {
    assert.fail(new Error(xhr.statusText));
  }
};
xhr.onerror = () => { // (D)
  assert.fail(new Error('Network error'));
};
xhr.send(); // (E)

function processData(str) {
  assert.equal(str, 'Content of textfile.txt\n');
}

```

使用此 API，我们首先创建一个请求对象（行 A），然后配置它，然后激活它（行 E）。配置包括：

+   指定要使用的 HTTP 请求方法（行 B）："GET"、"POST"、"PUT" 等。

+   注册一个监听器（行 C），当可以下载某些内容时被通知。在监听器内部，我们仍然需要确定下载的内容是否包含我们请求的内容或是否通知我们错误。请注意，一些结果数据是通过请求对象 `xhr` 传递的。（我不是这种输入和输出数据混合的粉丝。）

+   注册一个监听器（行 D），当发生网络错误时被通知。

##### 42.3.1.3 事件：DOM

我们已经在 “浏览器用户界面的阻塞”（§42.2.1） 中看到了 DOM 事件的实际应用。以下代码也处理 `click` 事件：

```js
const element = document.getElementById('my-link'); // (A)
element.addEventListener('click', clickListener); // (B)

function clickListener(event) {
  event.preventDefault(); // (C)
  console.log(event.shiftKey); // (D)
}

```

我们首先要求浏览器检索 ID 为 `'my-link'` 的 HTML 元素（行 A）。然后我们添加对所有 `click` 事件的监听器（行 B）。在监听器中，我们首先告诉浏览器不要执行其默认操作（行 C）——即前往链接的目标。然后我们记录当前是否按下了 shift 键（行 D）。

#### 42.3.2 通过回调传递异步结果

回调是处理异步结果的一种模式。它们仅用于一次性结果，并且比事件更简洁。

例如，考虑一个名为 `readFile()` 的函数，它异步读取一个文本文件并返回其内容。如果它使用 Node.js 风格的回调，我们这样调用 `readFile()`：

```js
readFile('some-file.txt', {encoding: 'utf-8'},
  (error, data) => {
    if (error) {
      assert.fail(error);
      return;
    }
    assert.equal(data, 'The content of some-file.txt');
  });

```

有一个回调同时处理成功和失败。如果第一个参数不是 `null`，则发生了错误。否则，结果可以在第二个参数中找到。

![练习图标 “exercise”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：基于回调的代码**

以下练习使用异步代码的测试，这些测试与同步代码的测试不同。有关更多信息，请参阅 “Mocha 中的异步测试”（§12.2.2）。

+   从同步到基于回调的代码：`exercises/async-js/read_file_cb_exrc.mjs`

+   实现 `.map()` 的基于回调版本：`exercises/async-js/map_cb_test.mjs`

### 42.4 异步代码：缺点

在许多情况下，无论是在浏览器还是 Node.js 中，我们别无选择：我们必须使用异步代码。在本章中，我们看到了这种代码可以使用的一些模式。所有这些模式都有两个缺点：

+   异步代码比同步代码更冗长。

+   如果我们调用异步代码，我们的代码也必须变为异步。这是因为我们不能同步地等待异步结果。异步代码具有传染性。

第一个缺点在 Promise（下一章介绍）中变得不那么严重，而在异步函数（下一章介绍）中几乎消失。

然而，异步代码的传染性并没有消失。但通过异步函数，在同步和异步之间切换变得容易，这减轻了这种传染性。

### 42.5 资源

+   [“帮助，我卡在事件循环中”](https://vimeo.com/96425312) by Philip Roberts（视频）。

+   [“事件循环”](https://www.w3.org/TR/html5/webappapis.html#event-loops)，HTML5 规范中的章节。
