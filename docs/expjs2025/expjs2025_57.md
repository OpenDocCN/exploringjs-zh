# 48 创建和解析 JSON（JSON）

> 原文：[`exploringjs.com/js/book/ch_json.html`](https://exploringjs.com/js/book/ch_json.html)

1.  48.1 JSON 的发现和标准化

    1.  48.1.1 JSON 的语法已冻结

1.  48.2 JSON 语法

1.  48.3 `JSON` API

    1.  48.3.1 `JSON.stringify(data, replacer?, space?)`

    1.  48.3.2 `JSON.parse(text, reviver?)`

    1.  48.3.3 示例：转换为和从 JSON 转换

1.  48.4 自定义序列化和解析（高级）

    1.  48.4.1 `.stringify()`: 指定要序列化对象的哪些属性

    1.  48.4.2 `.stringify()`和`.parse()`: 值访问者

    1.  48.4.3 示例：访问值

    1.  48.4.4 示例：序列化不受支持的价值

    1.  48.4.5 示例：解析不受支持的价值

1.  48.5 常见问题解答

    1.  48.5.1 为什么 JSON 不支持注释？

JSON（“JavaScript 对象表示法”）是一种使用文本编码数据的存储格式。其语法是 JavaScript 表达式的子集。例如，考虑以下存储在文件`jane.json`中的文本：

```js
{
  "first": "Jane",
  "last": "Porter",
  "married": true,
  "born": 1890,
  "friends": [ "Tarzan", "Cheeta" ]
}

```

JavaScript 有一个全局命名空间对象`JSON`，它提供了创建和解析 JSON 的方法。

### 48.1 JSON 的发现和标准化

2001 年，Douglas Crockford 发布了 JSON 规范，在[`json.org`](http://json.org/)。他解释说：

> 我发现了 JSON。我并不声称发明了 JSON，因为它在自然界中已经存在。我所做的是我发现它，我为它命名，我描述了它的用途。我不声称自己是第一个发现它的人；我知道至少有其他人在我之前一年就发现了它。我找到的最早记录是，早在 1996 年，有人在 Netscape 使用 JavaScript 数组字面量进行数据通信，这至少比我偶然想到这个想法早五年。

后来，JSON 被标准化为[ECMA-404](https://ecma-international.org/publications-and-standards/standards/ecma-404/)：

+   第 1 版：2013 年 10 月

+   第 2 版：2017 年 12 月

#### 48.1.1 JSON 的语法已冻结

引用 ECMA-404 标准：

> 由于它非常简单，因此预计 JSON 语法永远不会改变。这使得作为基础符号的 JSON 具有巨大的稳定性。

因此，JSON 永远不会得到像可选尾随逗号、注释或未引用键这样的改进——无论它们是否被认为是可取的。然而，这仍然为创建编译为纯 JSON 的超集留出了空间。

### 48.2 JSON 语法

JSON 由以下 JavaScript 部分组成：

+   复合：

    +   对象字面量：

        +   属性键是双引号字符串。

        +   属性值是 JSON 值。

        +   不允许有尾随逗号。

    +   数组字面量：

        +   元素是 JSON 值。

        +   不允许有孔或尾随逗号。

+   原子：

    +   `null`（但不是 `undefined`）

    +   布尔值

    +   数字（不包括 `NaN`，`+Infinity`，`-Infinity`）

    +   字符串（必须使用双引号）

因此，我们无法（直接）在 JSON 中表示循环结构。

### 48.3 JSON API

全局命名空间对象 `JSON` 包含两个用于处理 JSON 数据的方法：

+   `JSON.stringify(data, replacer?, space?)`

+   `JSON.parse(text, reviver?)`

下面的章节将解释这些方法是如何工作的。

#### 48.3.1 `JSON.stringify(data, replacer?, space?)`

此方法将 JavaScript `data` 转换为 JSON 字符串。在本节中，我们忽略参数 `replacer`；它将在“自定义序列化和解析（高级）”中解释（§48.4）。

##### 48.3.1.1 结果：单行文本

如果我们只提供第一个参数，`.stringify()` 返回单行文本：

```js
assert.equal(
  JSON.stringify({prop: ['a', 'b']}),
  '{"prop":["a","b"]}'
);

```

##### 48.3.1.2 结果：缩进行树

如果你提供一个非负整数作为 `space`，那么 `.stringify()` 会返回一行或多行，并且每层嵌套缩进 `space` 个空格：

```js
assert.equal(
JSON.stringify({prop: ['a', 'b']}, null, 2),
`{
 "prop": [
 "a",
 "b"
 ]
}`
);

```

##### 48.3.1.3 数据转换为 JSON 的细节

**原始值**：

+   支持的基本值会按预期序列化：

    ```js
    > JSON.stringify(null)
    'null'
    > JSON.stringify(true)
    'true'
    > JSON.stringify(123)
    '123'
    > JSON.stringify('abc')
    '"abc"'

    ```

+   不支持的数字：字符串 `'null'`

    ```js
    > JSON.stringify(NaN)
    'null'
    > JSON.stringify(Infinity)
    'null'

    ```

+   大整数（无论它们出现在哪里）：`TypeError`

    ```js
    > JSON.stringify(123n)
    TypeError: Do not know how to serialize a BigInt

    ```

+   其他不支持的原始值不会被序列化；它们产生结果 `undefined`：

    ```js
    > JSON.stringify(undefined)
    undefined
    > JSON.stringify(Symbol())
    undefined

    ```

**对象**：

+   如果一个对象有 `.toJSON()` 方法，那么该方法的结果会被序列化：

    ```js
    > JSON.stringify({toJSON() {return true}})
    'true' 
    ```

    日期有一个 `.toJSON()` 方法，它返回一个字符串：

    ```js
    > JSON.stringify(new Date(2999, 11, 31))
    '"2999-12-30T23:00:00.000Z"'

    ```

+   包装的基本值会被解包并序列化：

    ```js
    > JSON.stringify(new Boolean(true))
    'true'
    > JSON.stringify(new Number(123))
    '123'

    ```

+   产生 `undefined` 的不支持的值在数组内部会被序列化为 `null`：

    ```js
    > JSON.stringify([undefined, 123, Symbol()])
    '[null,123,null]'

    ```

+   所有其他对象（除了函数）都会被序列化为对象字面量。如果属性有产生 `undefined` 的不支持的值，则该属性会被省略：

    ```js
    > JSON.stringify({a: undefined, b: true, c: Symbol()})
    '{"b":true}'

    ```

+   函数不会被序列化：

    ```js
    > JSON.stringify(() => {})
    undefined

    ```

**循环数据**：如果数据是循环的，`JSON.stringify()` 会抛出异常：

```js
const cycle = {};
cycle.prop = cycle;
assert.throws(
  () => JSON.stringify(cycle),
  /^TypeError: Converting circular structure to JSON/
);

```

#### 48.3.2 `JSON.parse(text, reviver?)`

此方法将 JSON `text` 转换为 JavaScript 值。在本节中，我们忽略参数 `reviver`；它将在“自定义序列化和解析（高级）”中解释（§48.4）。

示例：

```js
> JSON.parse('{"prop":["a","b"]}')
{ prop: [ 'a', 'b' ] }

```

#### 48.3.3 示例：转换为和从 JSON

以下类实现了从（行 A）到（行 B）JSON 的转换。

```js
class Point {
  static fromJson(jsonObj) { // (A)
    return new Point(jsonObj.x, jsonObj.y);
  }

  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toJSON() { // (B)
 return {x: this.x, y: this.y};
 }
}

```

+   将 JSON 转换为点：我们使用静态方法 `Point.fromJson()` 解析 JSON 并创建 `Point` 实例。

    ```js
    assert.deepEqual(
      Point.fromJson(JSON.parse('{"x":3,"y":5}')),
      new Point(3, 5) );

    ```

+   将点转换为 JSON：`JSON.stringify()` 内部调用之前提到的 `.toJSON()` 方法（#json-stringify-details）。

    ```js
    assert.equal(
      JSON.stringify(new Point(3, 5)),
      '{"x":3,"y":5}' );

    ```

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：将对象转换为 JSON 并从 JSON 转换**

`exercises/json/to_from_json_test.mjs`

### 48.4 自定义字符串化和解析（高级）

字符串化和解析可以按以下方式自定义：

+   `JSON.stringify(data, replacer?, space?)`

    可选参数 `replacer` 包含以下内容之一：

    +   一个包含属性名称的数组。如果 `data` 中的值被转换为对象字面量，则仅考虑提到的属性。所有其他属性都将被忽略。

    +   一个 *值访问者*，一个可以在数据被转换为字符串之前对其进行转换的函数。

+   `JSON.parse(text, reviver?)`

    可选参数 `reviver` 包含一个值访问者，可以在返回之前转换解析后的 JSON 数据。

#### 48.4.1 `.stringfy()`：指定要转换为字符串的对象属性

如果 `.stringify()` 的第二个参数是一个数组，那么只有名称在该数组中提到的对象属性会被包含在结果中：

```js
const obj = {
  a: 1,
  b: {
    c: 2,
    d: 3,
  }
};
assert.equal(
  JSON.stringify(obj, ['b', 'c']),
  '{"b":{"c":2}}');

```

#### 48.4.2 `.stringify()` 和 `.parse()`：值访问者

我所说的 *值访问者* 是一个转换 JavaScript 数据的函数：

+   `JSON.stringify()` 允许其参数 `replacer` 中的值访问者在数据被转换为字符串之前对其进行转换。

+   `JSON.parse()` 允许其参数 `reviver` 中的值访问者在返回之前转换解析后的 JavaScript 数据。

在本节中，JavaScript 数据被视为值的树。如果数据是原子的，它只有一个根的树。树中的所有值都依次传递给值访问者。根据访问者返回的内容，当前值将被省略、更改或保留。

一个值访问者有以下类型签名：

```js
type ValueVisitor = (key: string, value: any) => any;

```

参数包括：

+   `value`: 当前值。

+   `this`: 当前值的父级。根值 `r` 的父级是 `{'': r}`。

    +   注意：`this` 是一个隐式参数，仅在值访问者是一个普通函数时才可用。

+   `key`: 当前值在其父级中的键或索引。根值的键是 `''`。

值访问者可以返回：

+   `value`: 表示不会有任何变化。

+   一个不同的值 `x`：导致输出树中的 `value` 被替换为 `x`。

+   `undefined`: 导致输出树中省略 `value`。

#### 48.4.3 示例：访问值

以下代码显示了值访问者看到值的顺序：

```js
const log = [];
function valueVisitor(key, value) {
  log.push({this: this, key, value});
  return value; // no change
}

const root = {
  a: 1,
  b: {
    c: 2,
    d: 3,
  }
};
JSON.stringify(root, valueVisitor);
assert.deepEqual(log, [
  { this: { '': root }, key: '',  value: root   },
  { this: root        , key: 'a', value: 1      },
  { this: root        , key: 'b', value: root.b },
  { this: root.b      , key: 'c', value: 2      },
  { this: root.b      , key: 'd', value: 3      },
]);

```

如我们所见，`JSON.stringify()` 的替换器是自顶向下访问值（先根后叶）。这样做的原因是我们正在将 JavaScript 值转换为 JSON 值。一个单一的 JavaScript 对象可能扩展为一个 JSON 兼容值的树。

与之相反，`JSON.parse()` 的恢复者是从下往上访问值的（先访问叶子节点，后访问根节点）。选择这种方向的逻辑是我们正在将 JSON 值组装成 JavaScript 值。因此，我们需要在转换整体之前先转换部分。

#### 48.4.4 示例：将不支持的数据类型转换为字符串

`JSON.stringify()` 对正则表达式对象没有特殊支持——它将它们当作普通对象来序列化：

```js
const obj = {
  name: 'abc',
  regex: /abc/ui,
};
assert.equal(
  JSON.stringify(obj),
  '{"name":"abc","regex":{}}');

```

我们可以通过一个替换者来修复这个问题：

```js
function replacer(key, value) {
  if (value instanceof RegExp) {
    return {
      __type__: 'RegExp',
      source: value.source,
      flags: value.flags,
    };
  } else {
    return value; // no change
  }
}
assert.equal(
JSON.stringify(obj, replacer, 2),
`{
 "name": "abc",
 "regex": {
 "__type__": "RegExp",
 "source": "abc",
 "flags": "iu"
 }
}`);

```

#### 48.4.5 示例：解析不支持的数据类型

要 `JSON.parse()` 上一个节点的结果，我们需要一个恢复者：

```js
function reviver(key, value) {
  // Very simple check
  if (value && value.__type__ === 'RegExp') {
    return new RegExp(value.source, value.flags);
  } else {
    return value;
  }
}
const str = `{
 "name": "abc",
 "regex": {
 "__type__": "RegExp",
 "source": "abc",
 "flags": "iu"
 }
}`;
assert.deepEqual(
  JSON.parse(str, reviver),
  {
    name: 'abc',
    regex: /abc/ui,
  });

```

### 48.5 常见问题解答

#### 48.5.1 为什么 JSON 不支持注释？

Douglas Crockford 在 [2012 年 5 月 1 日的一篇 Google+ 帖子](https://web.archive.org/web/20190308024153/https://plus.google.com/+DouglasCrockfordEsq/posts/RK8qyGVaGSr)中解释了原因：

> 我从 JSON 中移除了注释，因为我看到人们正在使用它们来保存解析指令，这种做法会破坏互操作性。我知道缺少注释会让一些人感到难过，但这不应该。
> 
> 假设你正在使用 JSON 来保存配置文件，你希望对其进行注释。你可以插入所有喜欢的注释。然后通过 JSMin [一个 JavaScript 压缩器] 处理它，然后再将其交给你的 JSON 解析器。
