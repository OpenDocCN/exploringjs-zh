# 15 运算符

> 原文：[`exploringjs.com/js/book/ch_operators.html`](https://exploringjs.com/js/book/ch_operators.html)

1.  15.1 理解运算符

    1.  15.1.1 运算符将它们的操作数转换为适当的类型

    1.  15.1.2 大多数运算符仅与原始值一起工作

1.  15.2 将值转换为原始值（高级）

1.  15.3 加号运算符（`+`）

1.  15.4 赋值运算符

    1.  15.4.1 普通赋值运算符

    1.  15.4.2 复合赋值运算符

1.  15.5 相等：`==` 与 `===` 与 `Object.is()`

    1.  15.5.1 严格相等（`===` 和 `!==`）

    1.  15.5.2 宽松相等（`==` 和 `!=`）

    1.  15.5.3 建议：始终使用严格相等

    1.  15.5.4 比 `===` 更严格：`Object.is()`（高级）

1.  15.6 排序运算符

1.  15.7 其他各种运算符

    1.  15.7.1 逗号运算符

    1.  15.7.2 `void` 运算符

### 15.1 理解运算符

JavaScript 的运算符有时会产生不直观的结果。以下两个规则使它们更容易理解：

+   运算符会将它们的操作数强制转换为适当的类型。

+   大多数运算符仅与原始值一起工作。

#### 15.1.1 运算符将它们的操作数转换为适当的类型

如果运算符接收到不正确的类型的操作数，它很少抛出异常。相反，它会*强制转换*（自动转换）操作数，以便可以与它们一起工作。让我们看看两个例子。

首先，乘法运算符只能与数字一起工作。因此，在计算结果之前，它会将字符串转换为数字。

```js
> '7' * '3'
21

```

其次，用于访问对象属性的方括号运算符（`[ ]`）只能处理字符串和符号。所有其他值都会被强制转换为字符串：

```js
const obj = {};
obj['true'] = 123;

// Coerce true to the string 'true'
assert.equal(obj[true], 123);

```

#### 15.1.2 大多数运算符仅与原始值一起工作

如前所述，大多数运算符仅与原始值一起工作。如果一个操作数是对象，它通常会被强制转换为原始值——例如：

```js
> [1,2,3] + [4,5,6]
'1,2,34,5,6'

```

为什么？加号运算符首先将它的操作数强制转换为原始值：

```js
> String([1,2,3])
'1,2,3'
> String([4,5,6])
'4,5,6'

```

然后，它连接这两个字符串：

```js
> '1,2,3' + '4,5,6'
'1,2,34,5,6'

```

### 15.2 将值转换为原始值（高级）

以下 JavaScript 代码解释了任意值是如何转换为原始值的：

```js
import assert from 'node:assert/strict';

/**
 * @param {any} input 
 * @param {'STRING'|'NUMBER'} [preferredType] optional
 * @returns {primitive}
 * @see https://tc39.es/ecma262/#sec-toprimitive
 */
function ToPrimitive(input, preferredType) {
  if (isObject(input)) {
    // `input` is an object
    const exoticToPrim = input[Symbol.toPrimitive]; // (A)
    if (exoticToPrim !== undefined) {
      let hint;
      if (preferredType === undefined) {
        hint = 'default';
      } else if (preferredType === 'STRING') {
        hint = 'string';
      } else {
        assert(preferredType === 'NUMBER');
        hint = 'number';
      }
      const result = exoticToPrim.apply(input, [hint]);
      if (!isObject(result)) return result;
      throw new TypeError();
    }
    if (preferredType === undefined) {
      preferredType = 'NUMBER';
    }
    return OrdinaryToPrimitive(input, preferredType);
  }
  // `input` is primitive
  return input;
}

/**
 * @param {object} O 
 * @param {'STRING'|'NUMBER'} hint 
 * @returns {primitive}
 */
function OrdinaryToPrimitive(O, hint) {
  let methodNames;
  if (hint === 'STRING') {
    methodNames = ['toString', 'valueOf'];
  } else {
    methodNames = ['valueOf', 'toString'];
  }
  for (const name of methodNames) {
    const method = O[name];
    if (isCallable(method)) {
      const result = method.apply(O);
      if (!isObject(result)) return result;
    }
  }
  throw new TypeError();
}

function isObject(value) {
  return typeof value === 'object' && value !== null;
}

function isCallable(value) {
  return typeof value === 'function';
}

```

只有以下对象定义了具有键 `Symbol.toPrimitive` 的方法：

+   `Symbol.prototype[Symbol.toPrimitive]`

+   `Date.prototype[Symbol.toPrimitive]`

因此，让我们关注 `OrdinaryToPrimitive()`：如果我们更喜欢字符串，则首先调用 `.toString()`。如果我们更喜欢数字，则首先调用 `.valueOf()`。我们可以在以下代码中看到这一点。

```js
const obj = {
  toString() {
 return '1';
 },
 valueOf() {
 return 2;
 },
};
assert.equal(
 String(obj), '1'
);
assert.equal(
 Number(obj), 2
); 
```

### 15.3 加号运算符 (`+`)

加号运算符在 JavaScript 中的工作方式如下：

+   首先，它将两个操作数都转换为原始值（默认情况下，转换为原始值优先于数字）。然后它切换到两种模式之一：

    +   字符串模式：如果两个原始值中有一个是字符串，则将另一个转换为字符串，将两个字符串连接起来，并返回结果。

    +   数字模式：否则，它将两个操作数都转换为数字，将它们相加，并返回结果。

字符串模式允许我们使用 `+` 来拼接字符串：

```js
> 'There are ' + 3 + ' items'
'There are 3 items'

```

数字模式意味着如果两个操作数都不是字符串（或变成字符串的对象）则将所有内容强制转换为数字：

```js
> 4 + true
5

```

`Number(true)` 是 `1`。

### 15.4 赋值运算符

#### 15.4.1 简单赋值运算符

简单赋值运算符用于更改存储位置：

```js
x = value; // assign to a previously declared variable
obj.propKey = value; // assign to a property
arr[index] = value; // assign to an Array element

```

变量声明中的初始化器也可以视为一种赋值形式：

```js
const x = value;
let y = value;

```

#### 15.4.2 复合赋值运算符

JavaScript 支持以下赋值运算符：

+   算术赋值运算符：`+= -= *= /= %=` (ES1)

    +   `+=` 也可以用于字符串连接

    +   后续引入：`**=` (ES2016)

+   位运算赋值运算符：`&= ^= |=` (ES1)

+   位运算移位赋值运算符：`<<= >>= >>>=` (ES1)

+   逻辑赋值运算符：`||= &&= ??=` (ES2021)

##### 15.4.2.1 逻辑赋值运算符 (ES2021)

逻辑赋值运算符与其他复合赋值运算符的工作方式不同：

| 赋值运算符 | 等价于 | 只有当 `a` 是 |
| --- | --- | --- |
| `a ??= b` | `a ?? (a = b)` | Falsy |
| `a &&= b` | `a && (a = b)` | Truthy |
| `a ??= b` | `a ?? (a = b)` | Nullish |

为什么 `a ||= b` 等价于以下表达式？

> `a || (a = b)`

为什么不使用这个表达式？

> `a = a || b`

前一个表达式的好处是 短路：只有当 `a` 评估为 `false` 时才进行赋值。因此，只有当必要时才执行赋值。相比之下，后一个表达式总是执行赋值。

更多关于 `??=` 的信息，请参阅 [“nullish 合并赋值运算符 (`??=`) (§16.4.4)” (ch_undefined-null.html#nullish-coalescing-assignment-operator)]。

##### 15.4.2.2 剩余的复合赋值运算符

对于 `op` 除了 `|| && ??` 的运算符，以下两种赋值方式是等价的：

```js
myvar op= value
myvar = myvar op value

```

例如，如果 `op` 是 `+`，则我们得到以下工作方式的运算符 `+=`。

```js
let str = '';
str += '<b>';
str += 'Hello!';
str += '</b>';

assert.equal(str, '<b>Hello!</b>');

```

### 15.5 相等：`==` vs. `===` vs. `Object.is()`

JavaScript 有两种类型的相等运算符：

+   (`==`) 松散相等（“双等号”）

+   （`===`）严格相等（“三等号”）

![图标“提示”](img/8440b17bb8219cda9f9405ac83c36db0.png) **建议：始终使用严格相等（`===`**）

松散相等有很多怪癖，难以理解。我的建议是始终使用严格相等。我将解释松散相等是如何工作的，但这不是值得记住的事情。

#### 15.5.1 严格相等（`===` 和 `!==`）

只有当两个值具有相同的类型时，它们才严格相等。严格相等从不进行转换。

原始值（包括字符串，但不包括符号）通过值进行比较：

```js
> undefined === null
false
> null === null
true

> true === false
false
> true === true
true

> 1 === 2
false
> 3 === 3
true

> 'a' === 'b'
false
> 'c' === 'c'
true

```

所有其他值都必须具有相同的标识符：

```js
> {} === {} // two different empty objects
false

> const obj = {};
> obj === obj
true

```

符号的比较方式类似于对象：

```js
> Symbol() === Symbol() // two different symbols
false
> const sym = Symbol();
> sym === sym
true

```

`number` 错误值 `NaN` 著名地不严格等于自身（因为，在内部，它不是一个单一值）：

```js
> typeof NaN
'number'
> NaN === NaN
false

```

#### 15.5.2 松散相等（`==` 和 `!=`）

松散相等是 JavaScript 的怪癖之一。让我们探索其行为。

##### 15.5.2.1 如果两个操作数具有相同的类型

如果两个操作数具有相同的原始类型，松散相等的行为类似于严格相等：

```js
> 1 == 2
false
> 3 == 3
true
> 'a' == 'b'
false
> 'c' == 'c'
true

```

如果两个操作数都是对象，则适用相同的规则：松散相等的行为类似于严格相等，并且它们只有在具有相同的标识符时才相等。

```js
> [1, 2, 3] == [1, 2, 3] // two different objects
false

> const arr = [1, 2, 3];
> arr == arr
true

```

符号的比较方式类似。

##### 15.5.2.2 转换

如果操作数具有不同的类型，松散相等通常会进行转换。其中一些类型转换是有意义的：

```js
> '123' == 123
true
> false == 0
true

```

其他情况较少：

```js
> 0 == '\r\n\t ' // only whitespace
true

```

如果另一个操作数是原始值，则对象会被转换为原始值（仅限）：

```js
> [1, 2, 3] == '1,2,3'
true
> ['17'] == 17
true

```

##### 15.5.2.3 `==` 与 `Boolean()`

与布尔值的比较与通过 `Boolean()` 转换为布尔值不同：

```js
> Boolean(0)
false
> Boolean(2)
true

> 0 == false
true
> 2 == true
false
> 2 == false
false

> Boolean('')
false
> Boolean('abc')
true

> '' == false
true
> 'abc' == true
false
> 'abc' == false
false

```

##### 15.5.2.4 `undefined == null`

`==` 将 `undefined` 和 `null` 视为相等：

```js
> undefined == null
true

```

##### 15.5.2.5 松散相等是如何工作的？（高级）

在 ECMAScript 规范中，松散相等是通过以下操作定义的：[以下操作](https://tc39.es/ecma262/#sec-islooselyequal)。

`IsLooselyEqual(x: any, y: any): boolean`

+   如果两个操作数具有相同的类型，则返回 `IsStrictlyEqual(x, y)` 的结果（此处未解释）。

+   如果一个操作数是 `null` 而另一个是 `undefined`，则返回 `true`。

+   如果一个操作数是数字而另一个是字符串，则将字符串转换为数字，并返回应用 `IsLooselyEqual()` 的结果。

+   如果一个操作数是 `bigint` 而另一个是字符串，则将字符串转换为 `bigint` 并返回应用 `IsLooselyEqual()` 的结果。

+   如果一个操作数是布尔值，则将其转换为数字，并返回应用 `IsLooselyEqual()` 的结果。

+   如果一个操作数是对象而另一个是字符串、数字、`bigint` 或符号，则通过 `ToPrimitive()` 将对象转换为原始值，并返回应用 `IsLooselyEqual()` 的结果。

+   如果一个操作数是 `bigint` 而另一个操作数是数字：

    +   如果任一操作数不是有限的，则返回 `false`。

    +   如果两个操作数表示相同的数学值，则返回 `true`；否则返回 `false`。

+   返回 `false`。

如您所见，这个算法并不完全直观。因此有以下建议。

#### 15.5.3 建议：始终使用严格相等

我建议始终使用 `===`。这使得我们的代码更容易理解，并使我们免于思考 `==` 的怪癖。

让我们看看 `==` 的两个用例以及我建议的替代方案。

##### 15.5.3.1 `==` 的用例：与数字或字符串比较

`==` 允许我们检查值 `x` 是否为数字或该数字的字符串表示——只需一次比较：

```js
if (x == 123) {
  // x is either 123 or '123'
}

```

我更喜欢以下两种替代方案之一：

```js
if (x === 123 || x === '123') ···
if (Number(x) === 123) ···

```

我们也可以在我们第一次遇到 `x` 时将其转换为数字。

##### 15.5.3.2 `==` 的用例：与 `undefined` 或 `null` 比较

`==` 的另一个用例是检查值 `x` 是否为 `undefined` 或 `null`：

```js
if (x == null) {
  // x is either null or undefined
}

```

这段代码的问题是我们无法确定某人是否有意这样编写，还是他们打字错误，本意是 `=== null`。

我更喜欢这个替代方案：

```js
if (x === undefined || x === null) ···

```

#### 15.5.4 比严格等于 `===` 更严格：`Object.is()`（高级）

方法 `Object.is()` 比较两个值：

```js
> Object.is(3, 3)
true
> Object.is(3, 4)
false
> Object.is(3, '3')
false

```

`Object.is()` 比严格等于 `===` 更严格——例如：

+   它将 涉及数字的计算的错误值 `NaN` 视为等于自身：

    ```js
    > Object.is(NaN, NaN)
    true
    > NaN === NaN
    false

    ```

+   它区分正零和负零（这两个值通常被认为是相同的，因此此功能并不那么有用）：

    ```js
    > Object.is(0, -0)
    false
    > 0 === -0
    true

    ```

##### 15.5.4.1 通过 `Object.is()` 检测 `NaN`

`Object.is()` 将 `NaN` 视为等于自身，偶尔很有用。例如，我们可以用它来实现数组方法 `.indexOf()` 的改进版本：

```js
const myIndexOf = (arr, elem) => {
  return arr.findIndex(x => Object.is(x, elem));
};

```

`myIndexOf()` 在数组中查找 `NaN`，而 `.indexOf()` 则不：

```js
> myIndexOf([0,NaN,2], NaN)
1
> [0,NaN,2].indexOf(NaN)
-1

```

结果 `-1` 表示 `.indexOf()` 在数组中找不到其参数。

### 15.6 排序运算符

| 运算符 | 名称 |
| --- | --- |
| `<` | 小于 |
| `<=` | 小于等于 |
| `>` | 大于 |
| `>=` | 大于等于 |

表 15.1：JavaScript 的排序运算符。

JavaScript 的排序运算符（表 15.1）适用于数字和字符串：

```js
> 5 >= 2
true
> 'bar' < 'foo'
true

```

`<=` 和 `>=` 基于严格相等。

![图标“警告”](img/5aa4bf88dc66ecb2bac6be4022a1fed4.png) **排序运算符在处理人类语言时效果不佳**

排序运算符在比较人类语言文本时效果不佳，例如，当涉及大小写或重音符号时。详情请见“比较字符串”（§22.6）。

### 15.7 其他各种运算符

以下运算符在其他章节中有所介绍：

+   用于布尔值、数字、字符串、对象的运算符

+   用于默认值的空值合并运算符（`??`）

下两个小节讨论了两个很少使用的运算符。

#### 15.7.1 逗号运算符

逗号运算符有两个操作数，评估它们并返回第二个：

```js
const result = (console.log('evaluated'), 'YES');
assert.equal(
  result, 'YES'
);

```

输出：

```js
evaluated

```

关于此运算符的更多信息，请参阅[*Speaking JavaScript*](http://exploringjs.com/es5/ch09.html#comma_operator)。

#### 15.7.2 `void`运算符

`void`运算符评估其操作数并返回`undefined`：

```js
const result = void console.log('evaluated');
assert.equal(
  result, undefined
);

```

输出：

```js
evaluated

```

关于此运算符的更多信息，请参阅[*Speaking JavaScript*](http://exploringjs.com/es5/ch09.html#void_operator)。
