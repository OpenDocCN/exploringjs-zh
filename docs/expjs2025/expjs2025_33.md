# 28 动态评估代码：eval()，new Function()（高级）

> 原文：[`exploringjs.com/js/book/ch_dynamic-code-evaluation.html`](https://exploringjs.com/js/book/ch_dynamic-code-evaluation.html)

1.  28.1 `eval()`

1.  28.2 `new Function()`

1.  28.3 推荐事项

在本章中，我们将探讨两种动态评估代码的方式：`eval()` 和 `new Function()`。

### 28.1 `eval()`

给定一个包含 JavaScript 代码的字符串 `str`，`eval(str)` 评估该代码并返回结果：

```js
> eval('2 ** 4')
16

```

调用 `eval()` 有两种方式：

+   *直接地*，通过函数调用。然后，其参数中的代码在当前作用域内被评估。

+   *间接地*，不是通过函数调用。然后它在全局作用域中评估其代码。

“不是通过函数调用”意味着“任何看起来与 `eval(···)` 不同的东西”：

+   `eval.call(undefined, '···')`（使用函数的 `.call()` 方法）

+   `eval?.('···')`（使用可选链）

+   `(0, eval)('···')`（使用逗号操作符）

+   `globalThis.eval('···')`

+   `const e = eval; e('···')`

+   等等。

以下代码说明了这种差异：

```js
globalThis.myVariable = 'global';
function func() {
 const myVariable = 'local';

 // Direct eval
 assert.equal(eval('myVariable'), 'local');

 // Indirect eval
 assert.equal(eval.call(undefined, 'myVariable'), 'global');
}

```

在全局上下文中评估代码更安全，因为代码可以访问的内部信息更少。

### 28.2 `new Function()`

`new Function()` 创建一个函数对象，并如下调用：

```js
const func = new Function('«param_1»', ···, '«param_n»', '«func_body»');

```

前一个语句等同于下一个语句。注意，`«param_1」`等，不再位于字符串字面量内部。

```js
const func = function («param_1», ···, «param_n») {
  «func_body»
};

```

在下一个示例中，我们两次创建相同的函数，首先是通过 `new Function()`，然后是通过函数表达式：

```js
const times1 = new Function('a', 'b', 'return a * b');
const times2 = function (a, b) { return a * b };

```

![图标“警告”](img/5aa4bf88dc66ecb2bac6be4022a1fed4.png) **`new Function()` 创建非严格模式函数**

默认情况下，通过 `new Function()` 创建的函数是宽松的。如果我们想使函数体处于严格模式，我们必须手动开启它。

### 28.3 推荐事项

尽可能避免代码的动态评估：

+   这是一个安全风险，因为它可能允许攻击者以您的代码的权限执行任意代码。

+   它可能被关闭——例如，在浏览器中，通过[内容安全策略](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)。

很频繁地，JavaScript 足够动态，以至于您不需要 `eval()` 或类似的东西。在以下示例中，我们使用 `eval()`（行 A）所做的事情，也可以在不使用它的情况下（行 B）实现。

```js
const obj = {a: 1, b: 2};
const propKey = 'b';

assert.equal(eval('obj.' + propKey), 2); // (A)
assert.equal(obj[propKey], 2); // (B)

```

如果您必须动态评估代码：

+   相比 `eval()`，更倾向于使用 `new Function()`：它始终在全局上下文中执行其代码，并且函数提供了一个干净的接口来访问评估后的代码。

+   相比直接 `eval()`，更倾向于间接 `eval`：在全局上下文中评估代码更安全。
