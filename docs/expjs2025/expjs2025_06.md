# 5 JavaScript 的历史和演变

> 原文：[`exploringjs.com/js/book/ch_history.html`](https://exploringjs.com/js/book/ch_history.html)

1.  5.1 JavaScript 的创建过程

1.  5.2 标准化：JavaScript 与 ECMAScript

1.  5.3 ECMAScript 版本的时间线

1.  5.4 JavaScript 的发展：TC39

1.  5.5 提案 ECMAScript 特性的 TC39 流程

    1.  5.5.1 小贴士：思考单个特性和阶段，而不是 ECMAScript 版本

    1.  5.5.2 TC39 流程的细节（高级）

1.  5.6 如何在更改 JavaScript 的同时不破坏网络

1.  5.7 常见问题解答：ECMAScript 和 TC39

    1.  5.7.1 我在哪里可以查找给定 ECMAScript 版本中添加了哪些特性？

    1.  5.7.2 我的 favorite 提案 JavaScript 特性进展如何？

    1.  5.7.3 为什么阶段 2.7 有这样一个奇特的数量？

### 5.1 JavaScript 的创建过程

JavaScript 是由 Brendan Eich 在 1995 年 5 月用 10 天时间创建的。Eich 在 Netscape 工作，并为他们的网络浏览器 *Netscape Navigator* 实现了 JavaScript。

想法是，客户端 Web 的主要交互部分应该用 Java 实现。JavaScript 应该是这些部分的粘合语言，并使 HTML 略微更具交互性。鉴于其辅助 Java 的角色，JavaScript 必须看起来像 Java。这排除了像 Perl、Python、TCL 等现有的解决方案。

初始时，JavaScript 的名称更改了好几次：

+   它的代号是 *Mocha*。

+   在 Netscape Navigator 2.0 测试版（1995 年 9 月），它被称为 *LiveScript*。

+   在 Netscape Navigator 2.0 测试版 3（1995 年 12 月），它获得了最终名称，*JavaScript*。

### 5.2 标准化：JavaScript 与 ECMAScript

有两个 JavaScript 标准：

+   ECMA-262 由 Ecma International 托管。它是主要标准。

+   ISO/IEC 16262 由国际标准化组织（ISO）和国际电工委员会（IEC）托管。这是一个二级标准。

这些标准所描述的语言被称为 *ECMAScript*，而不是 *JavaScript*。选择了一个不同的名称，因为 Sun（现在是 Oracle）对后者名称拥有商标。ECMAScript 中的“ECMA”来自托管主要标准的组织。

该组织的原始名称是 *ECMA*，代表 *European Computer Manufacturers Association*。后来它被改为 *Ecma International*（“Ecma”是一个专有名词，不是一个缩写），因为该组织的活动已经扩展到欧洲之外。最初的全部大写缩写解释了 ECMAScript 的拼写。

**通常，JavaScript 和 ECMAScript 是同义的。**有时会做出以下区分：

+   术语*JavaScript*指的是语言及其实现。

+   术语*ECMAScript*指的是语言标准和语言版本。

因此，*ECMAScript 6*是语言的版本（其第 6 版）。

### 5.3 ECMAScript 版本时间线

这是一份 ECMAScript 版本的简要时间线：

+   ECMAScript 1（1997 年 6 月）：标准的第一个版本。

+   ECMAScript 2（1998 年 6 月）：对 ECMA-262 的小更新，以保持与 ISO 标准同步。

+   ECMAScript 3（1999 年 12 月）：增加了许多核心功能——“[...]正则表达式、更好的字符串处理、新的控制语句[do-while、switch]、try/catch 异常处理[...]”

+   ECMAScript 4（2008 年 7 月废弃）：本应是一次重大的升级（具有静态类型、模块、命名空间等），但最终过于雄心勃勃，导致语言管理者之间产生分歧。

+   ECMAScript 5（2009 年 12 月）：带来了一些小的改进——一些标准库功能和*严格模式*。

+   ECMAScript 5.1（2011 年 6 月）：对 Ecma 和 ISO 标准的又一次小更新，以保持同步。

+   ECMAScript 6（2015 年 6 月）：这是一次重大的更新，实现了 ECMAScript 4 的许多承诺。这个版本的官方名称——*ECMAScript 2015*——是基于出版年份命名的。

+   ECMAScript 2016（2016 年 6 月）：第一个年度发布。较短的发布生命周期导致与大型 ES6 相比，新功能较少。

+   ECMAScript 2017（2017 年 6 月）。第二个年度发布。

+   后续的 ECMAScript 版本（ES2018 等）总是在 6 月获得批准。

### 5.4 JavaScript 的发展：TC39

TC39（Ecma 技术委员会 39）是推动 JavaScript 发展的委员会。其成员严格来说都是公司：Adobe、Apple、Facebook、Google、Microsoft、Mozilla、Opera、Twitter 以及其他公司。也就是说，通常是竞争对手的公司正在一起合作开发 JavaScript。

每两个月，TC39 都会举行会议，由成员指定的代表和受邀的专家参加。这些会议的纪要公开在[GitHub 仓库](https://github.com/tc39/notes)中。

在会议之外，TC39 还与 JavaScript 社区的各个成员和团体合作。

### 5.5 提议的 ECMAScript 特性的 TC39 流程

在 ECMAScript 6 中，当时使用的发布流程出现了两个问题：

+   如果发布之间的时间过长，那么准备较早的功能必须等待很长时间才能发布。而准备较晚的功能则面临匆忙赶工以完成截止日期的风险。

+   功能通常在实现和使用之前就已经设计好。因此，与实现和使用相关的设计缺陷发现得太晚。

针对这些问题，TC39 实施了新的*TC39 流程*：

+   ECMAScript 特性是独立设计的，并经过六个阶段：一个草稿阶段 0 和五个“成熟”阶段（1、2、2.7、3、4）。

+   尤其是后期阶段需要原型实现和实际测试，导致设计和实现之间的反馈循环。

+   ECMAScript 版本每年发布一次，包括在发布截止日期前达到阶段 4 的所有特性。

结果：更小、更渐进的发布，其特性已经过现场测试。

ES2016 是第一个按照 TC39 流程设计的 ECMAScript 版本。

#### 5.5.1 提示：思考个体特性和阶段，而非 ECMAScript 版本

直到包括 ES6 在内，人们通常根据 ECMAScript 版本来考虑 JavaScript – 例如，“这个浏览器支持 ES6 吗？”

从 ES2016 开始，最好考虑个体特性：一旦特性达到阶段 4，我们就可以安全地使用它（如果它是我们目标 JavaScript 引擎所支持的）。我们不必等到下一个 ECMAScript 发布。

#### 5.5.2 TC39 流程的细节（高级）

ECMAScript 特性是通过 *提案* 设计的，这些提案经过所谓的 *TC39 流程*。该流程包括六个阶段：

+   阶段 0 表示提案尚未进入实际流程。大多数提案都是从这里开始的。

+   然后，提案将经过五个成熟阶段 1、2、2.7、3 和 4。如果它达到阶段 4，它就是完整的，并准备好包含在 ECMAScript 标准中。

##### 5.5.2.1 与 ECMAScript 提案相关的工件

以下工件与 ECMAScript 提案相关：

+   **提案文档**：用英文散文和代码示例描述提案给 JavaScript 程序员，通常是 GitHub 仓库的 README。

+   **规范**：用 [*Ecmarkup*](https://tc39.es/ecmarkup/) 编写，这是一个由工具链支持的 HTML 和 Markdown 方言。该工具链检查 Ecmarkup，并将其渲染为具有针对阅读规范的功能的 HTML（交叉引用、变量出现的突出显示等）。

    +   HTML 也可以打印成 PDF。

    +   如果一个提案达到阶段 4，其规范将被集成到完整的 ECMAScript 规范中（该规范也用 Ecmarkup 编写）。

+   **测试**：用 JavaScript 编写的代码，用于检查实现是否符合规范。

    +   如果一个提案达到阶段 4，其测试将被集成到 [Test262](https://github.com/tc39/test262)，这是官方 ECMAScript 兼容性测试套件。

+   **实现**：提案的功能，在引擎和转换器（如 Babel 和 TypeScript）中实现。

每个阶段都有关于工件状态的进入标准：

| 阶段 | 提案 | 规范 | 测试 | 实现 |
| --- | --- | --- | --- | --- |
| 0 |  |  |  |  |
| 1 | 草稿 |  |  |  |
| 2 | 完成 | 草稿 |  |  |
| 2.7 |  | 完成 |  |  |
| 3 |  |  | 完成 | 原型 |
| 4 |  |  |  | 2 个实现 |

##### 5.5.2.2 管理提案的人员角色

+   **作者**：由一个或多个作者撰写提案。

+   **倡导者**：每个提案都有一名或多名 TC39 代表，他们指导提案通过 TC39 流程。如果作者没有流程经验，这一点尤为重要。

+   **审稿人**：审稿人在第二阶段对规范提供反馈，并在提案达到 2.7 阶段之前必须签署它。他们由 TC39 任命（不包括提案的作者和倡导者）。

+   **编辑**：负责管理 ECMAScript 规范的人员。当前编辑人员列在[ECMAScript 规范的开始处](https://tc39.es/ecma262/)。

##### 5.5.2.3 提案的阶段

+   **阶段 0**：构思和探索

    +   不属于常规推进流程的一部分。任何作者都可以创建一个草案提案并将其分配到阶段 0。

+   **阶段 1**：设计解决方案

    +   进入标准：

        +   选择倡导者

        +   包含提案的仓库

    +   状态：

        +   提案正在考虑中。

+   **阶段 2**：完善解决方案

    +   进入标准：

        +   提案已完成。

        +   规范草案。

    +   状态：

        +   提案可能（但不保证）会被标准化。

+   **阶段 2.7**：测试和验证

    +   进入标准：

        +   规范已完成并获得审稿人和编辑的批准。

    +   状态：

        +   规范已完成。现在是时候通过测试和符合规范的原型来验证它了。

        +   除了通过验证发现的问题外，不再进行更多更改。

+   **阶段 3**：获得实施经验

    +   进入标准：

        +   测试已完成。

    +   状态：

        +   提案准备就绪，可以实施。

        +   除非发现 Web 不兼容性，否则没有变化。

+   **阶段 4**：集成到草案规范并最终纳入标准

    +   进入标准：

        +   两个通过测试的实现

        +   在航运实施方面具有显著的实际经验

        +   向 TC39 仓库提交的拉取请求，已由编辑批准

    +   状态：

        +   提出的功能完整：

            +   其规范准备就绪，可包含在 ECMAScript 规范中。

            +   其测试准备就绪，可包含在 ECMAScript 一致性测试套件 Test262 中。

图 5.1 说明了 TC39 流程。

![](img/442c1a8ae435e1c23dd25637dd60c88d.png)

图 5.1：每个 ECMAScript 功能提案都要经过从 0 到 4 编号的阶段。

本节来源：

+   [“TC39 流程”](https://tc39.es/process-document/)（TC39 的官方文件）

+   [TC39 GitHub 仓库 `how-we-work` 的说明](https://github.com/tc39/how-we-work)，特别是[解释提案倡导者工作的文档](https://github.com/tc39/how-we-work/blob/main/champion.md)。

+   [ECMAScript 规范的 *扉页*](https://tc39.es/ecma262/#sec-colophon)。扉页是书籍结尾的内容。它通常包含有关书籍制作的信息。

### 5.6 如何在更改 JavaScript 的同时不破坏网络

有时候会提出一个想法，即通过移除旧特性和怪癖来清理 JavaScript。虽然这个想法的吸引力很明显，但它有显著的缺点。

假设我们创建了一个不向后兼容且修复了所有缺陷的新版本的 JavaScript。结果，我们会遇到以下问题：

+   JavaScript 引擎变得臃肿：它们需要支持旧版本和新版本。对于 IDE 和构建工具等工具也是如此。

+   程序员需要了解，并且持续意识到版本之间的差异。

+   我们可以选择将现有的所有代码库迁移到新版本（这可能是一项大量工作）。或者我们可以混合版本，重构变得更加困难，因为我们不能在不更改代码的情况下在版本之间移动代码。

+   我们必须以某种方式指定每段代码的版本——无论是文件还是嵌入网页中的代码——每个可行的解决方案都有其优缺点。例如，*严格模式* 是 ES5 的一个稍微干净一点的版本。它没有像应该的那样受欢迎的原因之一是：通过文件或函数开头的指令进行选择加入是一个麻烦。

那么，解决方案是什么？这是 JavaScript 的发展方式：

+   新版本总是完全向后兼容（但偶尔可能会有一些微小的、几乎察觉不到的清理）。

+   旧特性不会被移除或修复。相反，会引入它们的更好版本。一个例子是通过 `let` 和 `const` 声明变量——它们是 `var` 的改进版本。

+   如果语言的一些方面发生了变化，它是在新的语法结构中完成的。也就是说，我们隐式地选择加入——例如：

    +   `yield` 只是在生成器（在 ES6 中引入）内部的关键字。

    +   所有在模块和类（两者都是在 ES6 中引入）内部的代码都隐式地处于严格模式。

### 5.7 FAQ：ECMAScript 和 TC39

#### 5.7.1 在哪个地方可以查找给定 ECMAScript 版本中添加了哪些特性？

你可以在几个地方查找每个 ECMAScript 版本中的新特性：

+   在这本书中，有一个章节列出了每个 ECMAScript 版本中的新特性[（ch_new-javascript-features.html#ch_new-javascript-features）]。它还提供了链接到解释。

+   TC39 存储库有一个表格，列出了[完成的提案](https://github.com/tc39/proposals/blob/main/finished-proposals.md)，说明它们是在哪个 ECMAScript 版本中（或将要）引入的。

+   [ECMAScript 语言规范“引言”部分的“介绍”](https://tc39.es/ecma262/#sec-intro)列出了每个 ECMAScript 版本的新特性。

+   ECMA-262 仓库有一个 [发布页面](https://github.com/tc39/ecma262/releases)。

#### 5.7.2 我的最爱提议的 JavaScript 功能进展如何？

如果你想知道各种提议的功能处于哪个阶段，请参阅 [GitHub 仓库的提议部分](https://github.com/tc39/proposals)。

#### 5.7.3 为什么第 2.7 阶段有这样一个奇特的数量？

第 2.7 阶段是在 [2023 年晚些时候](https://github.com/tc39/process-document/pull/37/commits)加入的，在 0、1、2、3、4 阶段已经使用多年之后。

+   Q: 为什么不重新编号阶段？

    +   A: 重新编号不在计划之中，因为这会使旧文档难以阅读。

+   Q: 为什么不使用另一个数字，比如 2.5？

    +   .7 反映出阶段 2.7 比阶段 2 更接近阶段 3。

+   Q: 新阶段用 3a，旧阶段 3 用 3b 怎么样？

    +   A: 如果你在旧文档中看到“阶段 3”，可能会弄不清楚这是指新的阶段 3a 还是新的阶段 3b。

来源：[TC39 2023-11-30 讨论记录](https://github.com/tc39/notes/blob/main/meetings/2023-11/november-30.md#continuation-of-the-new-stage-discussion)
