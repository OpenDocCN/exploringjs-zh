# 9 语法

> [`exploringjs.com/js/book/ch_syntax.html`](https://exploringjs.com/js/book/ch_syntax.html)

1.  9.1 JavaScript 语法的概述

    1.  9.1.1 基本结构

    1.  9.1.2 模块

    1.  9.1.3 类

    1.  9.1.4 异常处理

    1.  9.1.5 合法的变量和属性名

    1.  9.1.6 命名风格

    1.  9.1.7 名称的大小写

    1.  9.1.8 更多的命名约定

    1.  9.1.9 分号应该放在哪里？

1.  9.2 （高级）

1.  9.3 哈希行（Unix shell 脚本）

1.  9.4 标识符

    1.  9.4.1 有效的标识符（变量名等）

    1.  9.4.2 保留字

1.  9.5 语句与表达式

    1.  9.5.1 语句

    1.  9.5.2 表达式

    1.  9.5.3 在哪里允许什么？

1.  9.6 模糊语法

    1.  9.6.1 相同的语法：函数声明和函数表达式

    1.  9.6.2 相同的语法：对象字面量和代码块

    1.  9.6.3 消除歧义

1.  9.7 分号

    1.  9.7.1 分号规则

    1.  9.7.2 分号：控制语句

1.  9.8 自动分号插入（ASI）

    1.  9.8.1 自动分号插入意外触发

    1.  9.8.2 自动分号插入（ASI）意外未触发

1.  9.9 分号：最佳实践

1.  9.10 严格模式与宽松模式

    1.  9.10.1 开启严格模式

    1.  9.10.2 严格模式中的改进

### 9.1 JavaScript 语法的概述

这是 JavaScript 语法的第一次全面了解。如果有些东西现在还不明白，不用担心。它们将在本书的后面部分详细解释。

这个概述也不是详尽的。它专注于基本内容。

#### 9.1.1 基本结构

##### 9.1.1.1 注释

```js
// single-line comment

/*
Comment with
multiple lines
*/

```

##### 9.1.1.2 *原始*（原子）值

**布尔值：**

```js
true
false

```

**数字：**

```js
1.141
-123

```

基本数字类型用于浮点数（双精度）和整数。

**大整数：**

```js
17n
-49n

```

基本数字类型只能正确表示 53 位加符号范围内的整数。大整数可以任意增长大小。

**字符串：**

```js
'abc'
"abc"
`String with interpolated values: ${256} and ${true}`

```

JavaScript 没有额外的字符类型。它使用字符串来表示它们。

##### 9.1.1.3 断言

*断言*描述了计算结果预期应该是什么样子，如果那些期望不正确，则会抛出异常。例如，以下断言指出，计算 7 加 1 的结果必须是 8：

```js
assert.equal(7 + 1, 8);

```

`assert.equal()`是一个方法调用（对象是`assert`，方法是`.equal()`），带有两个参数：实际结果和预期结果。它是 Node.js 断言 API 的一部分，该 API 将在本书后面解释。

还有`assert.deepEqual()`，它可以深度比较对象。

##### 9.1.1.4 记录到控制台

将日志记录到浏览器的控制台或 Node.js：

```js
// Printing a value to standard out (another method call)
console.log('Hello!');

// Printing error information to standard error
console.error('Something went wrong!');

```

##### 9.1.1.5 运算符

```js
// Operators for booleans
assert.equal(true && false, false); // And
assert.equal(true || false, true); // Or

// Operators for numbers
assert.equal(3 + 4, 7);
assert.equal(5 - 1, 4);
assert.equal(3 * 4, 12);
assert.equal(10 / 4, 2.5);

// Operators for bigints
assert.equal(3n + 4n, 7n);
assert.equal(5n - 1n, 4n);
assert.equal(3n * 4n, 12n);
assert.equal(10n / 4n, 2n);

// Operators for strings
assert.equal('a' + 'b', 'ab');
assert.equal('I see ' + 3 + ' monkeys', 'I see 3 monkeys');

// Comparison operators
assert.equal(3 < 4, true);
assert.equal(3 <= 4, true);
assert.equal('abc' === 'abc', true);
assert.equal('abc' !== 'def', true);

```

JavaScript 还有一个`==`比较运算符。我建议避免使用它——原因在“建议：始终使用严格相等”（§15.5.3）中解释。

##### 9.1.1.6 声明变量

`const`创建*不可变变量绑定*：每个变量必须立即初始化，以后不能分配不同的值。然而，值本身可能是可变的，我们可能能够更改其内容。换句话说：`const`并不使值不可变。

```js
// Declaring and initializing x (immutable binding):
const x = 8;

// Would cause a TypeError:
// x = 9;

```

`let`创建*可变变量绑定*：

```js
// Declaring y (mutable binding):
let y;

// We can assign a different value to y:
y = 3 * 5;

// Declaring and initializing z:
let z = 3 * 5;

```

##### 9.1.1.7 普通函数声明

```js
// add1() has the parameters a and b
function add1(a, b) {
  return a + b;
}
// Calling function add1()
assert.equal(add1(5, 2), 7);

```

##### 9.1.1.8 箭头函数表达式

箭头函数表达式特别用于函数调用和方法调用的参数：

```js
const add2 = (a, b) => { return a + b };
// Calling function add2()
assert.equal(add2(5, 2), 7);

// Equivalent to add2:
const add3 = (a, b) => a + b;

```

之前的代码包含以下两个箭头函数（术语*表达式*和*语句*将在本章后面解释）：

```js
// An arrow function whose body is a code block
(a, b) => { return a + b }

// An arrow function whose body is an expression
(a, b) => a + b

```

##### 9.1.1.9 普通对象

```js
// Creating a plain object via an object literal
const obj = {
  first: 'Jane', // property
  last: 'Doe', // property
  getFullName() { // property (method)
 return this.first + ' ' + this.last;
 },
};

// Getting a property value
assert.equal(obj.first, 'Jane');
// Setting a property value
obj.first = 'Janey';

// Calling the method
assert.equal(obj.getFullName(), 'Janey Doe');

```

##### 9.1.1.10 数组

```js
// Creating an Array via an Array literal
const arr = ['a', 'b', 'c'];
assert.equal(arr.length, 3);

// Getting an Array element
assert.equal(arr[1], 'b');
// Setting an Array element
arr[1] = 'β';

// Adding an element to an Array:
arr.push('d');

assert.deepEqual(
  arr, ['a', 'β', 'c', 'd']);

```

##### 9.1.1.11 控制流语句

条件语句：

```js
if (x < 0) {
  x = -x;
}

```

`for-of`循环：

```js
const arr = ['a', 'b'];
for (const element of arr) {
  console.log(element);
}

```

输出：

```js
a
b

```

#### 9.1.2 模块

每个模块都是一个单独的文件。例如，考虑以下包含模块的两个文件：

```js
file-tools.mjs
main.mjs

```

`file-tools.mjs`中的模块导出其函数`isTextFilePath()`：

```js
export function isTextFilePath(filePath) {
  return filePath.endsWith('.txt');
}

```

`main.mjs`中的模块导入了整个模块`path`和函数`isTextFilePath()`：

```js
// Import whole module as namespace object `path`
import * as path from 'node:path';
// Import a single export of module file-tools.mjs
import {isTextFilePath} from './file-tools.mjs';

```

#### 9.1.3 类

```js
class Person {
  constructor(name) {
    this.name = name;
  }
  describe() {
 return `Person named ${this.name}`;
 }
 static logNames(persons) {
 for (const person of persons) {
 console.log(person.name);
 }
 }
}

class Employee extends Person {
 constructor(name, title) {
 super(name);
 this.title = title;
 }
 describe() {
 return super.describe() +
 ` (${this.title})`;
 }
}

const jane = new Employee('Jane', 'CTO');
assert.equal(
 jane.describe(),
 'Person named Jane (CTO)'); 
```

#### 9.1.4 异常处理

```js
function throwsException() {
 throw new Error('Problem!');
}

function catchesException() {
 try {
 throwsException();
 } catch (err) {
 assert.ok(err instanceof Error);
 assert.equal(err.message, 'Problem!');
 }
} 
```

注意：

+   支持`try-finally`和`try-catch-finally`。

+   我们可以抛出任何值，但只有`Error`及其子类支持堆栈跟踪等特性。

#### 9.1.5 合法变量和属性名称

变量名和属性名的语法类别称为*标识符*。

标识符允许包含以下字符：

+   Unicode 字母：`A`–`Z`、`a`–`z`（等等）

+   `$`, `_`

+   Unicode 数字：`0`–`9`（等等）

    +   变量名不能以数字开头

一些单词在 JavaScript 中有特殊含义，被称为*保留字*。例如：`if`、`true`、`const`。

保留字不能用作变量名：

```js
const if = 123;
  // SyntaxError: Unexpected token if

```

但它们可以用作属性名：

```js
> const obj = { if: 123 };
> obj.if
123

```

#### 9.1.6 大小写风格

拼接单词的常见大小写风格有：

+   驼峰式：`threeConcatenatedWords`

+   下划线大小写（也称为 *snake case*）：`three_concatenated_words`

+   破折号大小写（也称为 *kebab case*）：`three-concatenated-words`

#### 9.1.7 名称的资本化

通常，JavaScript 使用驼峰式，但常量除外。

小写：

+   函数、变量：`myFunction`

+   方法：`obj.myMethod`

+   CSS：

    +   CSS 名称：`my-utility-class`（破折号大小写）

    +   对应的 JavaScript 名称：`myUtilityClass`

+   模块文件名通常是破折号大小写：

    ```js
    import * as theSpecialLibrary from './the-special-library.mjs';

    ```

大写：

+   类：`MyClass`

全大写：

+   常量（如模块之间的共享等）：`MY_CONSTANT`（下划线大小写）

#### 9.1.8 更多命名约定

以下命名约定在 JavaScript 中很流行。

如果参数的名称以下划线开头（或本身就是下划线），则表示该参数未使用——例如：

```js
arr.map((_x, i) => i)

```

如果对象的属性名称以下划线开头，则该属性被认为是私有的：

```js
class ValueWrapper {
  constructor(value) {
    this._value = value;
  }
}

```

#### 9.1.9 分号放置的位置？

在语句的末尾：

```js
const x = 123;
func();

```

但如果该语句以花括号结尾，则不是这样：

```js
while (false) {
  // ···
} // no semicolon

function func() {
 // ···
} // no semicolon

```

然而，在这样一个语句后添加分号并不是语法错误——它被解释为一个空语句：

```js
// Function declaration followed by empty statement:
function func() {
 // ···
};

```

### 9.2 （高级）

本章的其余部分都是高级内容。

### 9.3 Hashbang 行（Unix shell 脚本）

在 Unix shell 脚本中，我们可以添加一个以 `#!` 开头的第一行，以告诉 Unix 应使用哪个可执行文件来运行脚本。这两个字符有几个名字，包括 *hashbang*、*sharp-exclamation*、*sha-bang*（“sha”就像“sharp”）和 *shebang*。否则，大多数 shell 脚本语言和 JavaScript 都将其视为注释。这是 Node.js 的常见 hashbang 行：

```js
#!/usr/bin/env node

```

如果我们要向 `node` 传递参数，我们必须使用 `env` 选项 `-S`（为了安全起见，某些 Unix 系统可能不需要它）：

```js
#!/usr/bin/env -S node --enable-source-maps --no-warnings=ExperimentalWarning

```

### 9.4 标识符

#### 9.4.1 有效标识符（变量名等）

第一个字符：

+   Unicode 字母（包括带重音的字符，如 `é` 和 `ü` 以及来自非拉丁字母表的字符，如 `α`）

+   `$`

+   `_`

后续字符：

+   合法的第一个字符

+   Unicode 数字（包括东阿拉伯数字）

+   一些其他的 Unicode 标记和标点符号

例子：

```js
const ε = 0.0001;
const строка = '';
let _tmp = 0;
const $foo2 = true;

```

#### 9.4.2 保留字

保留字不能是变量名，但可以是属性名。

所有 JavaScript *关键字* 都是保留字：

> `await` `break` `case` `catch` `class` `const` `continue` `debugger` `default` `delete` `do` `else` `export` `extends` `finally` `for` `function` `if` `import` `in` `instanceof` `let` `new` `return` `static` `super` `switch` `this` `throw` `try` `typeof` `var` `void` `while` `with` `yield`

以下标记也是关键字，但目前未在语言中使用：

> `enum` `implements` `package` `protected` `interface` `private` `public`

以下字面量是保留字：

> `true` `false` `null`

从技术上讲，这些词不是保留的，但你应该避免使用它们，因为它们实际上也是关键字：

> `Infinity` `NaN` `undefined` `async`

你也不应该使用全局变量的名称（`String`、`Math`等）来为自己的变量和参数命名。

### 9.5 语句与表达式

在本节中，我们探讨 JavaScript 如何区分两种语法结构：*语句*和*表达式*。之后，我们将看到这可能会引起问题，因为相同的语法在不同的上下文中可能意味着不同的事情。

![图标“详情”](img/38ba63de820aae6f94a019538ae0f222.png) **我们假装只有语句和表达式**

为了简化起见，我们假装 JavaScript 中只有语句和表达式。

#### 9.5.1 语句

*语句*是一段可以执行并执行某种动作的代码。例如，`if`是一个语句：

```js
let myStr;
if (myBool) {
  myStr = 'Yes';
} else {
  myStr = 'No';
}

```

另一个语句的例子：函数声明。

```js
function twice(x) {
  return x + x;
}

```

#### 9.5.2 表达式

*表达式*是一段可以*评估*以产生值的代码。例如，括号之间的代码是一个表达式：

```js
let myStr = (myBool ? 'Yes' : 'No');

```

在括号之间使用的操作符`_?_:_`被称为*三元操作符*。它是`if`语句的表达式版本。

让我们看看更多表达式的例子。我们输入表达式，REPL 会为我们评估它们：

```js
> 'ab' + 'cd'
'abcd'
> Number('123')
123
> true || false
true

```

#### 9.5.3 允许在哪里？

JavaScript 源代码中的当前位置决定了你可以使用哪种语法结构：

+   函数体必须是一系列语句：

    ```js
    function max(x, y) {
      if (x > y) {
        return x;
      } else {
        return y;
      }
    }

    ```

+   函数调用或方法调用的参数必须是表达式：

    ```js
    console.log('ab' + 'cd', Number('123'));

    ```

然而，表达式可以用作语句。这时，它们被称为*表达式语句*。相反的情况不成立：当上下文需要表达式时，你不能使用语句。

以下代码演示了任何表达式`bar()`可以是表达式或语句——这取决于上下文：

```js
function f() {
 console.log(bar()); // bar() is expression
 bar(); // bar(); is (expression) statement 
}

```

### 9.6 混淆的语法

JavaScript 有几个在语法上模糊的编程结构：相同的语法在不同的上下文中被解释为不同，这节将探讨这种现象及其带来的问题。

#### 9.6.1 同样的语法：函数声明和函数表达式

*函数声明*是一个语句：

```js
function id(x) {
  return x;
}

```

*函数表达式*是一个表达式（等号的右侧）：

```js
const id = function me(x) {
  return x;
};

```

#### 9.6.2 同样的语法：对象字面量和代码块

在以下代码中，`{}`是一个*对象字面量*：一个创建空对象的表达式。

```js
const obj = {};

```

这是一个空的代码块（一个语句）：

```js
{
}

```

#### 9.6.3 消歧义

这些歧义仅在语句上下文中是问题：如果 JavaScript 解析器遇到歧义性语法，它不知道它是一个普通语句还是一个表达式语句。例如：

+   如果一个语句以 `function` 开头：它是函数声明还是函数表达式？

+   如果一个语句以 `{` 开头：它是对象字面量还是代码块？

为了解决歧义，以 `function` 或 `{` 开头的语句永远不会被解释为表达式。如果你想使一个表达式语句以这两个标记之一开始，你必须将其括在括号中：

```js
(function (x) { console.log(x) })('abc');

```

输出：

```js
abc

```

在此代码中：

1.  我们首先通过函数表达式创建一个函数：

    ```js
    function (x) { console.log(x) }

    ```

1.  然后我们调用该函数：`('abc')`

在（1）中显示的代码片段仅被解释为表达式，因为我们将其括在括号中。如果我们没有这样做，我们会得到一个语法错误，因为那时 JavaScript 期望一个函数声明并抱怨缺少函数名。此外，你不能在函数声明后立即放置一个函数调用。

在本书的后面部分，我们将看到更多由语法歧义引起的陷阱示例：

+   通过对象解构赋值

+   从箭头函数返回对象字面量

### 9.7 分号

#### 9.7.1 分号的经验法则

每个语句都以分号结束：

```js
const x = 3;
someFunction('abc');
i++;

```

除了以块结尾的语句：

```js
function foo() {
 // ···
}
if (y > 0) {
 // ···
}

```

以下情况稍微有些棘手：

```js
const func = () => {}; // semicolon!

```

整个 `const` 声明（一个语句）以分号结束，但其中包含一个箭头函数表达式。也就是说，结束于花括号的不是语句本身，而是嵌入的箭头函数表达式。这就是为什么在末尾有一个分号的原因。

#### 9.7.2 分号：控制语句

控制语句的主体本身就是一个语句。例如，这是 `while` 循环的语法：

```js
while (condition)
  statement

```

主体可以是一个单独的语句：

```js
while (a > 0) a--;

```

但块也是语句，因此是控制语句的有效主体：

```js
while (a > 0) {
  a--;
}

```

如果你想让循环有一个空的主体，你的第一个选项是一个空语句（它只是一个分号）：

```js
while (processNextItem() > 0);

```

你的第二个选项是一个空块：

```js
while (processNextItem() > 0) {}

```

### 9.8 自动分号插入（ASI）

虽然我建议始终写分号，但在 JavaScript 中大多数情况下它们是可选的。使这成为可能的是称为 *自动分号插入*（ASI）的机制。从某种意义上说，它纠正了语法错误。

ASI 的工作原理如下。语句的解析继续进行，直到以下情况之一：

+   一个分号

+   一个行终止符后面跟着一个非法标记

换句话说，自动分号插入（ASI）可以看作是在行尾插入分号。接下来的小节将介绍 ASI 的陷阱。

#### 9.8.1 意外触发的 ASI

关于自动分号插入（ASI）的好消息是——如果你不依赖它并且总是写分号——你只需要注意一个陷阱。那就是 JavaScript 禁止在某些标记后换行。如果你插入换行，也会插入分号。

这在`return`标记中最为实用。例如，考虑以下代码：

```js
return
{
  first: 'jane'
};

```

这段代码被解析为：

```js
return;
{
  first: 'jane';
}
;

```

那就是：

+   没有操作数的返回语句：`return;`

+   代码块开始：`{`

+   表达式语句`'jane';`带有标签 `first:`

+   代码块结束：`}`

+   空语句：`;`

为什么 JavaScript 要这样做？它是为了防止在`return`语句之后的行中意外返回一个值。

#### 9.8.2 ASI 意外未触发

在某些情况下，当你认为应该触发 ASI 时，它并没有触发。这使得不喜欢分号的人的生活更加复杂，因为他们需要意识到这些情况。以下有三个例子。还有更多。

**示例 1**：意外的函数调用。

```js
a = b + c
(d + e).print()

```

解析为：

```js
a = b + c(d + e).print();

```

**示例 2**：意外的除法。

```js
a = b
/hi/g.exec(c).map(d)

```

解析为：

```js
a = b / hi / g.exec(c).map(d);

```

**示例 3**：意外的属性访问。

```js
someFunction()
['ul', 'ol'].map(x => x + x)

```

执行为：

```js
const propKey = ('ul','ol'); // comma operator
assert.equal(propKey, 'ol');

someFunction()[propKey].map(x => x + x);

```

### 9.9 分号：最佳实践

我建议你总是写分号：

+   我喜欢它给代码带来的视觉结构——你可以清楚地看到一个语句在哪里结束。

+   需要记住的规则更少。

+   大多数 JavaScript 程序员使用分号。

然而，也有很多人不喜欢分号带来的额外视觉混乱。如果你是其中之一：没有分号的代码*是合法的*。我建议你使用工具来帮助你避免错误。以下有两个例子：

+   自动代码格式化工具[Prettier](https://prettier.io)可以配置为不使用分号。然后它会自动修复问题。例如，如果它遇到以方括号开头的行，它会在该行前加上分号。

+   静态检查器[ESLint](https://eslint.org)有一个[规则](https://eslint.org/docs/rules/semi)，你可以告诉你的首选样式（总是分号或尽可能少的分号），并且会警告你关于关键问题。

### 9.10 strict 模式与宽松模式

从 ECMAScript 5 开始，JavaScript 有两种*模式*，JavaScript 可以在其中执行：

+   正常的“宽松”模式在脚本中是默认的（模块的前身，由浏览器支持）。

+   在模块和类中，strict 模式是默认的，可以在脚本中打开（如何操作将在后面解释）。在这种模式下，消除了正常模式的一些陷阱，并抛出了更多异常。

在现代 JavaScript 代码中，你很少会遇到宽松模式，它几乎总是位于模块中。在这本书中，我假设始终打开 strict 模式。

#### 9.10.1 打开 strict 模式

在脚本文件和 CommonJS 模块中，你通过在第一行放置以下代码来为一个完整的文件打开 strict 模式：

```js
'use strict';

```

这个“指令”的妙处在于，ECMAScript 5 之前的版本简单地忽略它：它是一个什么也不做的表达式语句。

你也可以只为单个函数切换到严格模式：

```js
function functionInStrictMode() {
 'use strict';
}

```

#### 9.10.2 严格模式中的改进

让我们看看严格模式比宽松模式做得更好的三个方面。仅仅在这一节中，所有代码片段都是在宽松模式下执行的。

##### 9.10.2.1 宽松模式陷阱：更改未声明的变量会创建全局变量

在非严格模式下，更改未声明的变量会创建一个全局变量。

```js
function sloppyFunc() {
 undeclaredVar1 = 123;
}
sloppyFunc();
// Created global variable `undeclaredVar1`:
assert.equal(undeclaredVar1, 123);

```

严格模式做得更好，并抛出一个`ReferenceError`。这使得检测拼写错误变得更容易。

```js
function strictFunc() {
 'use strict';
 undeclaredVar2 = 123;
}
assert.throws(
 () => strictFunc(),
 {
 name: 'ReferenceError',
 message: 'undeclaredVar2 is not defined',
 });

```

`assert.throws()`表明其第一个参数，一个函数，在调用时会抛出一个`ReferenceError`。

##### 9.10.2.2 严格模式中函数声明是块作用域的，宽松模式中是函数作用域的

在严格模式下，通过函数声明创建的变量仅存在于最内层的封装块中：

```js
function strictFunc() {
 'use strict';
 {
 function foo() { return 123 }
 }
 return foo(); // ReferenceError
}
assert.throws(
 () => strictFunc(),
 {
 name: 'ReferenceError',
 message: 'foo is not defined',
 }); 
```

在宽松模式下，函数声明是函数作用域的：

```js
function sloppyFunc() {
 {
 function foo() { return 123 }
 }
 return foo(); // works
}
assert.equal(sloppyFunc(), 123); 
```

##### 9.10.2.3 宽松模式在更改不可变数据时不会抛出异常

在严格模式下，如果你尝试更改不可变数据，你会得到一个异常：

```js
function strictFunc() {
 'use strict';
 true.prop = 1; // TypeError
}
assert.throws(
 () => strictFunc(),
 {
 name: 'TypeError',
 message: "Cannot create property 'prop' on boolean 'true'",
 });

```

在宽松模式下，赋值操作会静默失败：

```js
function sloppyFunc() {
 true.prop = 1; // fails silently
 return true.prop;
}
assert.equal(sloppyFunc(), undefined);

```

![图标“外部”](img/38e6ff55e8d602659f3cdb8893e63f62.png) **进一步阅读：宽松模式**

更多关于宽松模式与严格模式差异的信息，请参阅[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)。
