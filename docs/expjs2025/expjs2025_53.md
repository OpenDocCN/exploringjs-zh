# 45 异步迭代 ES2018

> 原文：[`exploringjs.com/js/book/ch_async-iteration.html`](https://exploringjs.com/js/book/ch_async-iteration.html)

1.  45.1 基本异步迭代

    1.  45.1.1 协议：异步迭代

    1.  45.1.2 直接使用异步迭代

    1.  45.1.3 通过`for-await-of`使用异步迭代

1.  45.2 异步生成器

    1.  45.2.1 示例：通过异步生成器创建异步可迭代对象

    1.  45.2.2 示例：将同步可迭代对象转换为异步可迭代对象

    1.  45.2.3 示例：将异步可迭代对象转换为数组

    1.  45.2.4 示例：转换异步可迭代对象

    1.  45.2.5 示例：映射异步可迭代对象

1.  45.3 Node.js 流的异步迭代

    1.  45.3.1 Node.js 流：通过回调（推送）进行异步操作

    1.  45.3.2 Node.js 流：通过异步迭代（拉取）进行异步操作

    1.  45.3.3 示例：从块到行

![阅读图标](img/0fb62b2fc33a72829ae9fb174dedd0d2.png) **所需知识**

对于本章，你应该熟悉：

+   Promise

+   异步函数

### 45.1 基本异步迭代

#### 45.1.1 协议：异步迭代

要理解异步迭代是如何工作的，让我们首先回顾一下同步迭代。它包括以下接口：

```js
interface Iterable<T> {
  [Symbol.iterator]() : Iterator<T>;
}
interface Iterator<T> {
  next() : IteratorResult<T>;
}
interface IteratorResult<T> {
  value: T;
  done: boolean;
}

```

+   `Iterable`是一个可以通过迭代访问其内容的数据结构。它是一个迭代器的工厂。

+   `Iterator`是一个迭代结果的工厂，我们通过调用`.next()`方法来检索它。

+   每个`IterationResult`包含迭代的`.value`和一个布尔值`.done`，在最后一个元素之后为`true`，在之前为`false`。

对于异步迭代的协议，我们只想改变一件事：`.next()`产生的值应该异步传递。有两种可行的选择：

+   `.value`可能包含一个`Promise<T>`。

+   `.next()`可能返回`Promise<IteratorResult<T>>`。

换句话说，问题在于是否将值或整个迭代器结果包裹在 Promise 中。

必须是后者，因为当`.next()`返回一个结果时，它开始一个异步计算。该计算是否产生值或指示迭代结束，只能在计算完成后确定。因此，`.done`和`.value`都需要被包裹在一个 Promise 中。

异步迭代的接口如下所示。

```js
interface AsyncIterable<T> {
  [Symbol.asyncIterator]() : AsyncIterator<T>;
}
interface AsyncIterator<T> {
  next() : Promise<IteratorResult<T>>; // (A)
}
interface IteratorResult<T> {
  value: T;
  done: boolean;
}

```

与同步接口的唯一区别是 `.next()` 的返回类型（行 A）。

#### 45.1.2 直接使用异步迭代

以下代码直接使用异步迭代协议：

```js
const asyncIterable = syncToAsyncIterable(['a', 'b']); // (A)
const asyncIterator = asyncIterable[Symbol.asyncIterator]();

// Call .next() until .done is true:
asyncIterator.next() // (B)
.then(iteratorResult => {
  assert.deepEqual(
    iteratorResult,
    { value: 'a', done: false });
  return asyncIterator.next(); // (C)
})
.then(iteratorResult => {
  assert.deepEqual(
    iteratorResult,
    { value: 'b', done: false });
  return asyncIterator.next(); // (D)
})
.then(iteratorResult => {
  assert.deepEqual(
    iteratorResult,
     { value: undefined, done: true });
})
;

```

在行 A 中，我们创建了一个异步可迭代对象，它遍历值 `'a'` 和 `'b'`。我们将在后面看到 `syncToAsyncIterable()` 的实现。

我们在行 B、行 C 和行 D 中调用 `.next()`。每次，我们使用 `.then()` 来解包 Promise 并使用 `assert.deepEqual()` 来检查解包的值。

如果我们使用异步函数，我们可以简化此代码。现在我们通过 `await` 解包 Promise，代码看起来几乎就像我们正在进行同步迭代：

```js
async function f() {
 const asyncIterable = syncToAsyncIterable(['a', 'b']);
 const asyncIterator = asyncIterable[Symbol.asyncIterator]();

 // Call .next() until .done is true:
 assert.deepEqual(
 await asyncIterator.next(),
 { value: 'a', done: false });
 assert.deepEqual(
 await asyncIterator.next(),
 { value: 'b', done: false });
 assert.deepEqual(
 await asyncIterator.next(),
 { value: undefined, done: true });
}

```

#### 45.1.3 通过 `for-await-of` 使用异步迭代

异步迭代协议不打算直接使用。支持它的语言结构之一是 `for-await-of` 循环，它是 `for-of` 循环的异步版本。它可以在异步函数和 *异步生成器*（在本章后面介绍）中使用。以下是一个 `for-await-of` 的使用示例：

```js
for await (const x of syncToAsyncIterable(['a', 'b'])) {
  console.log(x);
}

```

输出：

```js
a
b

```

`for-await-of` 相对灵活。除了异步可迭代对象外，它还支持同步可迭代对象：

```js
for await (const x of ['a', 'b']) {
  console.log(x);
}

```

输出：

```js
a
b

```

它还支持在 Promise 中包装的值上的同步可迭代对象：

```js
const arr = [Promise.resolve('a'), Promise.resolve('b')];
for await (const x of arr) {
  console.log(x);
}

```

输出：

```js
a
b

```

![练习图标“exercise”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：异步迭代**

+   将异步可迭代对象转换为数组：`exercises/async-iteration/async_iterable_to_array_test.mjs`

    +   警告：我们将在本章中很快看到这个练习的解决方案。

+   实现异步可迭代队列：`exercises/async-iteration/async-iter-queue_test.mjs`

### 45.2 异步生成器

异步生成器与同步生成器非常相似；特别是 `yield` 和 `yield*` 操作符。因此，这里不再解释。有关更多信息，请参阅同步生成器章节。

异步生成器同时是两件事：

+   异步函数（输入）：我们可以使用 `await` 和 `for-await-of` 来检索数据。

+   返回异步可迭代对象的生成器（输出）：我们可以使用 `yield` 和 `yield*` 来产生数据。

因此，异步生成器的输入和输出是：

+   输入可以是：

    +   同步（单个值，同步可迭代对象）

    +   异步（Promise，异步可迭代对象）

+   输出是一个异步迭代器（也是可迭代的）。

它看起来如下所示：

```js
// Input: Promise and async iterable
async function* asyncGen(somePromise, someAsyncIterable) {
  const x = await somePromise;
  for await (const y of someAsyncIterable) {
    // ···
  }

  // Output: iterable async iterator
  yield someValue;
  yield* otherAsyncGen();
}

```

#### 45.2.1 示例：通过异步生成器创建异步可迭代对象

让我们来看一个例子。以下代码创建了一个包含三个数字的异步可迭代对象：

```js
async function* yield123() {
 for (let i=1; i<=3; i++) {
 yield i;
 }
}

```

`yield123()` 的结果是否符合异步迭代协议？

```js
async function check() {
 const asyncIterable = yield123();
 const asyncIterator = asyncIterable[Symbol.asyncIterator]();
 assert.deepEqual(
 await asyncIterator.next(),
 { value: 1, done: false });
 assert.deepEqual(
 await asyncIterator.next(),
 { value: 2, done: false });
 assert.deepEqual(
 await asyncIterator.next(),
 { value: 3, done: false });
 assert.deepEqual(
 await asyncIterator.next(),
 { value: undefined, done: true });
}
check();

```

#### 45.2.2 示例：将同步可迭代对象转换为异步可迭代对象

下面的异步生成器将同步迭代器转换为异步迭代器。它实现了我们之前使用的`syncToAsyncIterable()`函数。

```js
async function* syncToAsyncIterable(syncIterable) {
  for (const elem of syncIterable) {
    yield elem;
  }
}

```

注意：在这种情况下，输入是同步的（不需要`await`）。

#### 45.2.3 示例：将异步迭代器转换为数组

下面的函数是之前一个练习的解决方案。它将异步迭代器转换为数组（想象一下展开，但用于异步迭代器而不是同步迭代器）。

```js
async function asyncIterableToArray(asyncIterable) {
  const result = [];
  for await (const value of asyncIterable) {
    result.push(value);
  }
  return result;
}

```

注意，在这种情况下我们不能使用异步生成器：我们通过`for-await-of`获取输入，并返回一个被 Promise 包装的数组。后者的要求排除了异步生成器。

这是一个对`asyncIterableToArray()`的测试：

```js
async function* createAsyncIterable() {
 yield 'a';
 yield 'b';
}
const asyncIterable = createAsyncIterable();
assert.deepEqual(
 await asyncIterableToArray(asyncIterable), // (A)
 ['a', 'b']
);

```

注意行 A 中的`await`，这是展开`asyncIterableToArray()`返回的 Promise 所必需的。为了使`await`能够工作，这段代码必须在一个异步函数内部运行。

#### 45.2.4 示例：转换异步迭代器

让我们实现一个异步生成器，它通过转换现有的异步迭代器来生成一个新的异步迭代器。

```js
async function* timesTwo(asyncNumbers) {
  for await (const x of asyncNumbers) {
    yield x * 2;
  }
}

```

为了测试这个函数，我们使用上一节中的`asyncIterableToArray()`。

```js
async function* createAsyncIterable() {
 for (let i=1; i<=3; i++) {
 yield i;
 }
}
assert.deepEqual(
 await asyncIterableToArray(timesTwo(createAsyncIterable())),
 [2, 4, 6]
);

```

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：异步生成器**

警告：我们很快将在本章中看到这个练习的解决方案。

+   `exercises/async-iteration/number_lines_test.mjs`

#### 45.2.5 示例：异步迭代器上的映射

作为提醒，这是如何在同步迭代器上映射：

```js
function* mapSync(iterable, func) {
  let index = 0;
  for (const x of iterable) {
    yield func(x, index);
    index++;
  }
}
const syncIterable = mapSync(['a', 'b', 'c'], s => s.repeat(3));
assert.deepEqual(
  Array.from(syncIterable),
  ['aaa', 'bbb', 'ccc']);

```

异步版本如下所示：

```js
async function* mapAsync(asyncIterable, func) { // (A)
  let index = 0;
  for await (const x of asyncIterable) { // (B)
    yield func(x, index);
    index++;
  }
}

```

注意同步实现和异步实现是多么相似。唯一的两个区别是行 A 中的`async`和行 B 中的`await`。这相当于从同步函数到异步函数的转变——我们只需要添加关键字`async`和偶尔的`await`。

为了测试`mapAsync()`，我们使用辅助函数`asyncIterableToArray()` (本章前面展示)：

```js
async function* createAsyncIterable() {
 yield 'a';
 yield 'b';
}
const mapped = mapAsync(
 createAsyncIterable(), s => s.repeat(3));
assert.deepEqual(
 await asyncIterableToArray(mapped), // (A)
 ['aaa', 'bbb']);

```

再次强调，我们使用`await`来展开 Promise（行 A），并且这段代码必须在一个异步函数内部运行。

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：`filterAsyncIter()`**

`exercises/async-iteration/filter_async_iter_test.mjs`

### 45.3 Node.js 流上的异步迭代

由于数据流的异步特性，异步迭代很好地作为它们的抽象。特别是，异步生成器是转换数据流（输入和输出都是流）的一个优雅工具。

#### 45.3.1 Node.js 流：通过回调的异步（推送）

传统上，从 Node.js 流异步读取是通过回调完成的：

```js
function main(inputFilePath) {
  const readStream = fs.createReadStream(inputFilePath,
    { encoding: 'utf-8', highWaterMark: 1024 });
  readStream.on('data', (chunk) => {
    console.log('>>> '+chunk);
  });
  readStream.on('end', () => {
    console.log('### DONE ###');
  });
}

```

也就是说，流控制着并推动数据到读取器。

#### 45.3.2 Node.js 流：通过异步迭代（拉取）

从 Node.js 10 开始，我们也可以使用异步迭代从流中读取：

```js
async function main(inputFilePath) {
  const readStream = fs.createReadStream(inputFilePath,
    { encoding: 'utf-8', highWaterMark: 1024 });

  for await (const chunk of readStream) {
    console.log('>>> '+chunk);
  }
  console.log('### DONE ###');
}

```

这次，读取器处于控制地位，并从流中拉取数据。

#### 45.3.3 示例：从数据块到行

Node.js 流包含 *数据块*（任意长度的数据片段）。以下异步生成器将异步可迭代的数据块转换为异步可迭代的行：

```js
/**
 * @param chunkIterable An asynchronous or synchronous iterable
 * over “chunks” (arbitrary strings)
 * @returns An asynchronous iterable over “lines”
 * (strings with at most one newline that always appears at the end)
 */
async function* chunksToLines(chunkIterable) {
  let previous = '';
  for await (const chunk of chunkIterable) {
    let startSearch = previous.length;
    previous += chunk;
    while (true) {
      // Works for EOL === '\n' and EOL === '\r\n'
      const eolIndex = previous.indexOf('\n', startSearch);
      if (eolIndex < 0) break;
      // Line includes the EOL
      const line = previous.slice(0, eolIndex+1);
      yield line;
      previous = previous.slice(eolIndex+1);
      startSearch = 0;
    }
  }
  if (previous.length > 0) {
    yield previous;
  }
}

```

让我们将 `chunksToLines()` 应用到一个异步可迭代的数据块上（由 `chunkIterable()` 生成）：

```js
async function* chunkIterable() {
 yield 'First\nSec';
 yield 'ond\nThird\nF';
 yield 'ourth';
}
const linesIterable = chunksToLines(chunkIterable());
assert.deepEqual(
 await asyncIterableToArray(linesIterable),
 [
 'First\n',
 'Second\n',
 'Third\n',
 'Fourth',
 ]);

```

现在我们有了异步可迭代的行，我们可以使用之前练习中的解决方案 `numberLines()` 来编号这些行：

```js
async function* numberLines(linesAsync) {
  let lineNumber = 1;
  for await (const line of linesAsync) {
    yield lineNumber + ': ' + line;
    lineNumber++;
  }
}
const numberedLines = numberLines(chunksToLines(chunkIterable()));
assert.deepEqual(
  await asyncIterableToArray(numberedLines),
  [
    '1: First\n',
    '2: Second\n',
    '3: Third\n',
    '4: Fourth',
  ]);

```
