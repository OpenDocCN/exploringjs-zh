# 38 集合（Set）ES6

> 原文：[`exploringjs.com/js/book/ch_sets.html`](https://exploringjs.com/js/book/ch_sets.html)

1.  38.1 基本集合操作

    1.  38.1.1 创建集合

    1.  38.1.2 添加、删除、检查成员资格

    1.  38.1.3 确定集合的大小并清空它

1.  38.2 组合集合：并集、交集、差集、对称差集 (ES2025)

    1.  38.2.1 并集：`set.union(other)` (ES2025)

    1.  38.2.2 交集：`set.intersection(other)` (ES2025)

    1.  38.2.3 差集：`set.difference(other)` (ES2025)

    1.  38.2.4 对称差集：`set.symmetricDifference(other)` (ES2025)

1.  38.3 检查集合关系：子集、超集、不相交 (ES2025)

    1.  38.3.1 子集：`set.isSubsetOf(other)` (ES2025)

    1.  38.3.2 超集：`set.isSupersetOf(other)` (ES2025)

    1.  38.3.3 不相交：`set.isDisjointFrom(other)` (ES2025)

1.  38.4 类似集合的对象（高级）

    1.  38.4.1 示例：有限类似集合对象

    1.  38.4.2 示例：无限类似集合数据

    1.  38.4.3 常见问题解答：类似集合对象

1.  38.5 遍历集合

    1.  38.5.1 将集合转换为数组

    1.  38.5.2 通过迭代方法映射和过滤集合

    1.  38.5.3 示例：通过迭代组合集合 (ES2025)

    1.  38.5.4 对集合元素进行分组 (ES2024)

1.  38.6 使用集合的示例

    1.  38.6.1 从数组中删除重复项

    1.  38.6.2 创建一个包含 Unicode 字符（代码点）的集合

1.  38.7 集合 API 的详细信息（高级）

    1.  38.7.1 哪些集合元素被认为是相等的？

    1.  38.7.2 常见问题解答：集合 API

1.  38.8 快速参考：`Set`

    1.  38.8.1 `new Set()`

    1.  38.8.2 `Set.prototype.*`: 与单个集合元素一起工作

    1.  38.8.3 `Set.prototype.*`: 与所有集合元素一起工作

    1.  38.8.4 `Set.prototype.*`: 迭代和循环

    1.  38.8.5 `Set.prototype.*`: 合并两个集合 (ES2025)

    1.  38.8.6 `Set.prototype.*`: 检查集合关系 (ES2025)

数据结构 `Set` 管理一个无重复值的集合，并提供快速的成员资格检查等功能。

### 38.1 基本集合操作

#### 38.1.1 创建集合

有三种常见的方法来创建集合。

首先，我们可以使用无参数的构造函数来创建一个空集合：

```js
const emptySet = new Set();
assert.equal(emptySet.size, 0);

```

第二，我们可以将可迭代对象（例如，一个数组）传递给构造函数。迭代的值成为新集合的元素：

```js
const set = new Set(['red', 'green', 'blue']);

```

第三，`.add()` 方法向集合中添加元素，并且是可链式的：

```js
const set = new Set()
.add('red')
.add('green')
.add('blue');

```

#### 38.1.2 添加、删除、检查成员资格

`.add()` 向集合中添加一个元素。

```js
const set = new Set();
set.add('red');

```

`.has()` 检查一个元素是否是集合的成员。

```js
assert.equal(set.has('red'), true);

```

`.delete()` 从集合中删除一个元素。

```js
assert.equal(set.delete('red'), true); // there was a deletion
assert.equal(set.has('red'), false);

```

#### 38.1.3 确定集合的大小和清除集合

`.size` 包含集合中的元素数量。

```js
const set = new Set()
  .add('foo')
  .add('bar');
assert.equal(set.size, 2)

```

`.clear()` 移除集合中的所有元素。

```js
set.clear();
assert.equal(set.size, 0)

```

### 38.2 组合集合：并集、交集、差集、对称差 (ES2025)

有四种方法可以组合两个集合。

#### 38.2.1 并集：`set.union(other)` (ES2025)

![图片](img/466ab17df8ce9bada54b76b314e6dec4.png)

`set.union(other)` 的结果是包含 `set` 和 `other` 的值的集合：

```js
assert.deepEqual(
  new Set(['a', 'b']).union(new Set(['b', 'c'])),
  new Set(['a', 'b', 'c'])
);

```

#### 38.2.2 交集：`set.intersection(other)` (ES2025)

![图片](img/177acd08f608df8b69590d67b803378a.png)

`set.intersection(other)` 的结果是包含 `set` 和 `other` 共同拥有的值的集合：

```js
assert.deepEqual(
  new Set(['a', 'b']).intersection(new Set(['b', 'c'])),
  new Set(['b'])
);

```

#### 38.2.3 差集：`set.difference(other)` (ES2025)

![图片](img/f64428582010ac4f391a4145f2014ec6.png)

`set.difference(other)` 的结果是包含只存在于 `set` 的值的集合：

```js
assert.deepEqual(
  new Set(['a', 'b']).difference(new Set(['b', 'c'])),
  new Set(['a'])
);

```

![练习图标](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：实现 `set.union()`、`set.intersection()` 和 `set.difference()`**

`exercises/sets/set-union-intersection-difference_test.mjs`

#### 38.2.4 对称差：`set.symmetricDifference(other)` (ES2025)

![图片](img/752ee7e59a3e2b58f55fc196e668112f.png)

`set.symmetricDifference(other)` 的结果是包含只存在于 `set` 或只存在于 `other` 的值的集合：

```js
assert.deepEqual(
  new Set(['a', 'b']).symmetricDifference(new Set(['b', 'c'])),
  new Set(['a', 'c'])
);
assert.deepEqual(
  new Set(['a', 'b']).symmetricDifference(new Set(['c', 'd'])),
  new Set(['a', 'b', 'c', 'd'])
);

```

*对称差*是什么意思？以下是对称差的等效定义：

+   (`set` − `other`) ∪ (`other` − `set`)

    +   只存在于 `set` 或只存在于 `other` 的元素。该公式清楚地说明了对称差既是对称的，又是差异。

+   (`set` ∪ `other`) − (`set` ∩ `other`)

    +   `set` 和 `other` 的元素——除了同时存在于两个集合中的元素。

+   `set` 与 `other`

    +   排他或——直观上：`set` 区域内的所有内容都被反转。`set` 区域外的所有内容保持不变。

![练习图标](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：实现 `set.symmetricDifference()`**

`exercises/sets/set-symmetric-difference_test.mjs`

### 38.3 检查集合关系：子集、超集、不相交 (ES2025)

有三种方法用于检查两个集合之间的关系。

#### 38.3.1 子集：`set.isSubsetOf(other)` (ES2025)

`set.isSubsetOf(other)` 返回 `true` 如果 `set` 的所有元素都在 `other` 中：

```js
assert.deepEqual(
  new Set(['a', 'b']).isSubsetOf(new Set(['a', 'b', 'c'])),
  true
);

```

#### 38.3.2 超集：`set.isSupersetOf(other)` (ES2025)

`set.isSupersetOf(other)` 返回 `true` 如果 `set` 包含 `other` 的所有元素：

```js
assert.deepEqual(
  new Set(['a', 'b', 'c']).isSupersetOf(new Set(['a', 'b'])),
  true
);

```

#### 38.3.3 不相交：`set.isDisjointFrom(other)` (ES2025)

`set.isDisjointFrom(other)` 返回 `true` 如果 `set` 和 `other` 没有共同元素：

```js
assert.deepEqual(
  new Set(['a', 'b', 'c']).isDisjointFrom(new Set(['x'])),
  true
);

```

![练习图标](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Set 关系方法练习**

+   实现 Set 相等性：`exercises/sets/set-is-equal-to_test.mjs`

+   实现 `set.isSubsetOf()`：`exercises/sets/is-subset-of_test.mjs`

+   实现 `set.isDisjointFrom()`：`exercises/sets/is-disjoint-from_test.mjs`

### 38.4 Set-like 对象（高级）

一个参数为另一个 Set `other` 的 Set 方法不需要 `other` 真的是 Set；它只需要是 Set-like 并具有以下方法：

```js
interface SetLike<T> {
  /** Can be `Infinity` (see next section). */
  size: number;

  has(key: T): boolean;

  /** Returns an iterator for the elements in `this`. */
  keys(): Iterator<T>; // only method `.next()` is required
}

```

#### 38.4.1 示例：有限 Set-like 对象

让我们实现一个简单的 Set-like 对象，并使用具有“其他 Set”参数的方法：

```js
const setLike = {
  size: 1,
  has(x) { return x === 'b' },
  * keys() { yield 'b' },
};

assert.deepEqual(
 new Set(['a', 'b', 'c']).difference(setLike),
 new Set(['a', 'c']),
);
assert.deepEqual(
 new Set(['a', 'b', 'c']).difference(setLike),
 new Set(['a', 'c']),
);
assert.equal(
 new Set(['a', 'b', 'c']).isSupersetOf(setLike),
 true,
);
assert.equal(
 new Set(['b']).isSubsetOf(setLike),
 true,
);

```

Maps 也是 Set-like：

```js
const setLike = new Map([['b', true]]);
assert.deepEqual(
  new Set(['a', 'b', 'c']).difference(setLike),
  new Set(['a', 'c']),
);
assert.equal(
  new Set(['a', 'b', 'c']).isSupersetOf(setLike),
  true,
);

```

#### 38.4.2 示例：无限 Set-like 数据

`other` 的 `.size` 可以是 `Infinity`。这意味着我们可以处理无限 Set：

```js
const evenNumbers = {
  has(elem) {
    return (elem % 2) === 0;
  },
  size: Infinity,
  keys() {
 throw new TypeError();
 }
};
assert.deepEqual(
 new Set([0, 1, 2, 3]).difference(evenNumbers),
 new Set([1, 3])
);
assert.deepEqual(
 new Set([0, 1, 2, 3]).intersection(evenNumbers),
 new Set([0, 2])
);

```

这之所以有效，是因为这些方法仅在 `other.size` 小于 `this.size` 时调用 `other.keys()`。

只有两种方法不支持 `other` 是无限 Set：

+   `union`

+   `symmetricDifference`

#### 38.4.3 常见问题解答：Set-like 对象

+   为什么使用 `SetLike` 接口来处理 `other`？

    +   由于接口，`other` 可以是一个不是 Set 的数据结构。它被选为只接受 Set 和所有可迭代对象的折衷方案。

+   为什么 JavaScript 总是强制执行 `other` 的完整接口 `SetLike` 并在属性缺失或动态类型错误时抛出异常？

    +   这使得 API 更简单，并隐藏了实现细节。

+   为什么选择 `.keys()` 方法来遍历元素？

    +   这是因为与标准库中当前唯一的 Set-like 数据结构 `Map` 兼容。另外两种 Set 方法会更好，但不能与 Maps 一起使用：

        +   Map 方法 `.[Symbol.iterator]()` 返回键值对。

        +   Map 方法 `.values()` 与 Map 方法 `.has()`（接受键而不是值）不兼容。

来源：[TC39 提案](https://github.com/tc39/proposal-set-methods/blob/main/details.md)

### 38.5 遍历 Set

Set 是可迭代的，`for-of` 循环按预期工作：

```js
const set = new Set(['red', 'green', 'blue']);
for (const x of set) {
  console.log(x);
}

```

输出：

```js
red
green
blue

```

如我们所见，Sets 保留 *插入顺序*。也就是说，元素总是按它们被添加的顺序迭代。

#### 38.5.1 将 Set 转换为数组

集合是可迭代的，这就是为什么我们可以使用 `Array.from()` 将集合转换为数组：

```js
const set = new Set(['red', 'green', 'blue']);

assert.deepEqual(
  Array.from(set),
  ['red', 'green', 'blue']
);

```

我们也可以通过迭代器执行转换：

```js
assert.deepEqual(
  set.values().toArray(),
  ['red', 'green', 'blue']
);

```

+   `set.values()` 返回 `set` 的值的迭代器。

+   迭代器方法 `.toArray()` 创建一个包含迭代值的数组。

#### 38.5.2 通过迭代器方法映射和过滤集合

集合没有 `.map()` 方法。但我们可以借用迭代器拥有的那个方法：

```js
const set = new Set([1, 2, 3]);
const mappedSet = new Set( // (A)
  set.values().map(x => x * 2) // (B)
);
assert.deepEqual(
  mappedSet,
  new Set([2, 4, 6])
);

```

之前的代码展示了使用集合的迭代器方法的常见模式：

+   `set.values()` 返回 `set` 的迭代器（行 B）。

+   `.map()` 是一个迭代器方法，它返回一个迭代器（行 B）。

+   上一步的结果是一个可迭代的迭代器。它被传递给接受任何可迭代对象作为参数的构造函数 `Set`，并使用它填充新的集合。

过滤集合的工作方式相同：

```js
const set = new Set([1, 2, 3, 4, 5]);
const filteredSet = new Set(
  set.values().filter(x => (x % 2) === 0)
);
assert.deepEqual(
  filteredSet,
  new Set([2, 4])
);

```

如果我们不能使用迭代器方法怎么办？那么我们可以切换到数组方法：

+   我们使用 `Array.from(set)`

+   而不是 `set.values()`。

#### 38.5.3 示例：通过迭代组合集合（ES2025）

我们也可以使用迭代来代替集合方法结合集合：

```js
const a = new Set([1, 2, 3]);
const b = new Set([2, 3, 4]);

// Union
assert.deepEqual(
  new Set([...a, ...b]),
  new Set([1, 2, 3, 4])
);

// Intersection
assert.deepEqual(
  new Set(a.values().filter(x => b.has(x))),
  new Set([2, 3])
);

// Difference
assert.deepEqual(
  new Set(a.values().filter(x => !b.has(x))),
  new Set([1])
);

```

#### 38.5.4 分组集合元素（ES2024）

通过 `Object.groupBy()` 和 `Map.groupBy()` 进行分组适用于任何可迭代对象，因此也适用于集合：

```js
assert.deepEqual(
  Object.groupBy(
    new Set([0, -5, 3, -4, 8, 9]),
    x => Math.sign(x)
  ),
  {
    '0': [0],
    '-1': [-5,-4],
    '1': [3,8,9],
    __proto__: null,
  }
);

```

更多信息：“分组可迭代对象（ES2024）” (§32.8)

### 38.6 使用集合的示例

#### 38.6.1 从数组中删除重复项

将数组转换为集合再转换回来，会从数组中删除重复项：

```js
const arr = [1, 2, 1, 2, 3, 3, 3];
const noDuplicates = Array.from(new Set(arr));
assert.deepEqual(
  noDuplicates, [1, 2, 3]
);

```

#### 38.6.2 创建 Unicode 字符集（代码点）

字符串是可迭代的，因此可以用作 `new Set()` 的参数：

```js
assert.deepEqual(
  new Set('abc'),
  new Set(['a', 'b', 'c'])
);

```

### 38.7 集合 API 的详细信息（高级）

#### 38.7.1 哪些集合元素被认为是相等的？

与 Map 键类似，集合元素与 `===` 进行类似比较，除了 `NaN` 等于自身。

```js
> const set = new Set([NaN, NaN, NaN]);
> set.size
1
> set.has(NaN)
true

```

与 `===` 类似，两个不同的对象永远不会被认为是相等的（目前也没有办法改变这一点）：

```js
> const set = new Set();

> set.add({});
> set.size
1

> set.add({});
> set.size
2

```

#### 38.7.2 常见问题解答：集合 API

+   为什么集合有 `.size`，而数组有 `.length`？

    +   这个问题的答案在“为什么 Map 有`.size`，而数组有`.length`？”（§36.7.4）中给出。

+   为什么有些方法名是动词，而有些是名词？这是一个粗略的一般规则：

    +   动词方法会修改 `this` – 例如：`set.add()` 和 `set.clear()`

    +   名词方法返回新数据 – 例如：`set.values()` 和 `set.union()`

### 38.8 快速参考：`Set`

#### 38.8.1 `new Set()`

+   `new Set(iterable)` ES6

    +   如果我们不提供参数 `values`，则创建一个空集合。

    +   如果我们这样做，那么迭代的值将被添加为集合的元素。

    ```js
    const set = new Set(['red', 'green', 'blue']);

    ```

#### 38.8.2 `Set.prototype.*`: 处理单个集合元素

+   `Set.prototype.add(value)` ES6

    +   向这个集合添加 `value`。

    +   此方法返回 `this`，这意味着它可以被链式调用。

    ```js
    const set = new Set(['red']);
    set.add('green').add('blue');
    assert.deepEqual(
      Array.from(set), ['red', 'green', 'blue']
    );

    ```

+   `Set.prototype.delete(value)` ES6

    +   从这个集合中移除 `value`。

    +   如果有东西被删除，则返回 `true`，否则返回 `false`。

    ```js
    const set = new Set(['red', 'green', 'blue']);
    assert.equal(set.delete('red'), true); // there was a deletion
    assert.deepEqual(
      Array.from(set), ['green', 'blue']
    );

    ```

+   `Set.prototype.has(value)` ES6

    如果 `value` 在这个集合中，则返回 `true`，否则返回 `false`。

    ```js
    const set = new Set(['red', 'green']);
    assert.equal(set.has('red'), true);
    assert.equal(set.has('blue'), false);

    ```

#### 38.8.3 `Set.prototype.*`: 处理所有集合元素

+   `get Set.prototype.size` ES6

    返回这个集合中有多少个元素。

    ```js
    const set = new Set(['red', 'green', 'blue']);
    assert.equal(set.size, 3);

    ```

+   `Set.prototype.clear()` ES6

    从这个集合中移除所有元素。

    ```js
    const set = new Set(['red', 'green', 'blue']);
    assert.equal(set.size, 3);
    set.clear();
    assert.equal(set.size, 0);

    ```

#### 38.8.4 `Set.prototype.*`: 遍历和循环

+   `Set.prototype.values()` ES6

    返回一个遍历这个集合所有元素的迭代器。

    ```js
    const set = new Set(['red', 'green']);
    for (const x of set.values()) {
      console.log(x);
    }

    ```

    输出：

    ```js
    red
    green

    ```

+   `Set.prototype[Symbol.iterator]()` ES6

    遍历集合的默认方式。与 `.values()` 相同。

    ```js
    const set = new Set(['red', 'green']);
    for (const x of set) {
      console.log(x);
    }

    ```

    输出：

    ```js
    red
    green

    ```

+   `Set.prototype.forEach(callback, thisArg?)` ES6

    ```js
    forEach(
      callback: (value: T, key: T, theSet: Set<T>) => void,
      thisArg?: any
    ): void

    ```

    将这个集合的每个元素传递给 `callback()`。`value` 和 `key` 都包含当前元素。这种冗余是为了使这个 `callback` 与 `Map.prototype.forEach()` 的 `callback` 具有相同的类型签名。

    我们可以通过 `thisArg` 指定 `callback` 的 `this`。如果我们省略它，则 `this` 是 `undefined`。

    ```js
    const set = new Set(['red', 'green']);
    set.forEach(x => console.log(x));

    ```

    输出：

    ```js
    red
    green

    ```

##### 38.8.4.1 与 `Map` 的对称性

以下方法使 `Set` 的接口与 `Map` 的接口对称。

+   `Set.prototype.entries(): Iterable<[T,T]>` ES6

    主要存在是为了使集合和映射具有相似的接口：每个集合元素被视为一个键值对，其键和值都是该元素：

    ```js
    > new Set(['a', 'b', 'c']).entries().toArray()
    [ [ 'a', 'a' ], [ 'b', 'b' ], [ 'c', 'c' ] ]

    ```

    `.entries()` 允许我们将集合转换为映射：

    ```js
    const set = new Set(['a', 'b', 'c']);
    const map = new Map(set.entries());
    assert.deepEqual(
      Array.from(map.entries()),
      [['a','a'], ['b','b'], ['c','c']]
    );

    ```

+   `Set.prototype.keys(): Iterable<T>` ES6

    主要存在是为了使集合和映射具有相似的接口：每个集合元素被视为一个键值对，其键和值都是该元素。因此 `.keys()` 的结果与 `.values()` 的结果相同：

    ```js
    > new Set(['a', 'b', 'c']).keys().toArray()
    [ 'a', 'b', 'c' ]

    ```

#### 38.8.5 `Set.prototype.*`: 合并两个集合 (ES2025)

+   `Set.prototype.union(other)` ES2025

    ```js
    Set<T>.prototype.union(other: SetLike<T>): Set<T>

    ```

    此方法返回一个集合，它是 `this` 和 `other` 的并集。如果它在 `this` 或 `other` 中，则包含该值。

    ```js
    assert.deepEqual(
      new Set(['a', 'b']).union(new Set(['b', 'c'])),
      new Set(['a', 'b', 'c'])
    );

    ```

    `other` 不必是集合，它只需要是 *类似集合* 并具有属性 `.size` 和方法 `.has(key)` 以及 `.keys()`。集合和映射都满足这些要求。

+   `Set.prototype.intersection(other)` ES2025

    ```js
    Set<T>.prototype.intersection(other: SetLike<T>): Set<T>

    ```

    此方法返回一个集合，它是 `this` 和 `other` 的交集。如果它在 `this` 或 `other` 中，则包含该值。

    ```js
    assert.deepEqual(
      new Set(['a', 'b']).intersection(new Set(['b', 'c'])),
      new Set(['b'])
    );

    ```

    `other` 不必是集合，它只需要是 *类似集合* 并具有属性 `.size` 和方法 `.has(key)` 以及 `.keys()`。集合和映射都满足这些要求。

+   `Set.prototype.difference(other)` ES2025

    ```js
    Set<T>.prototype.difference(other: SetLike<T>): Set<T>

    ```

    此方法返回一个集合，它是`this`和`other`的差集。如果该值在`this`中但不在`other`中，则包含该值。

    ```js
    assert.deepEqual(
      new Set(['a', 'b']).difference(new Set(['b', 'c'])),
      new Set(['a'])
    );

    ```

    `other`不必是集合，它只需要是*类似集合的*对象，并具有`.size`属性以及`.has(key)`和`.keys()`方法。集合和映射都满足这些要求。

+   `Set.prototype.symmetricDifference(other)` ES2025

    ```js
    Set<T>.prototype.symmetricDifference(other: SetLike<T>): Set<T>

    ```

    此方法返回一个集合，它是`this`和`other`的对称差集。如果该值仅在`this`或仅在`other`中，则包含该值。

    ```js
    assert.deepEqual(
      new Set(['a', 'b']).symmetricDifference(new Set(['b', 'c'])),
      new Set(['a', 'c'])
    );

    ```

    `other`不必是集合，它只需要是*类似集合的*对象，并具有`.size`属性以及`.has(key)`和`.keys()`方法。集合和映射都满足这些要求。

    关于此方法的更多信息，请参阅本章中的相关部分。

#### 38.8.6 `Set.prototype.*`: 检查集合关系^(ES2025)

+   `Set.prototype.isSubsetOf(other)` ES2025

    ```js
    Set<T>.prototype.isSubsetOf(other: SetLike<T>): boolean

    ```

    如果`this`的所有元素都在`other`中，则返回`true`：

    ```js
    assert.deepEqual(
      new Set(['a', 'b']).isSubsetOf(new Set(['a', 'b', 'c'])),
      true
    );

    ```

+   `Set.prototype.isSupersetOf(other)` ES2025

    ```js
    Set<T>.prototype.isSupersetOf(other: SetLike<T>): boolean

    ```

    如果`this`包含`other`的所有元素，则返回`true`：

    ```js
    assert.deepEqual(
      new Set(['a', 'b', 'c']).isSupersetOf(new Set(['a', 'b'])),
      true
    );

    ```

+   `Set.prototype.isDisjointFrom(other)` ES2025

    ```js
    Set<T>.prototype.isDisjointFrom(other: SetLike<T>): boolean

    ```

    如果`this`和`other`没有共同元素，则返回`true`：

    ```js
    assert.deepEqual(
      new Set(['a', 'b', 'c']).isDisjointFrom(new Set(['x'])),
      true
    );

    ```
