# 32 同步迭代 ES6

> 原文：[`exploringjs.com/js/book/ch_sync-iteration.html`](https://exploringjs.com/js/book/ch_sync-iteration.html)

1.  32.1 同步迭代是什么？

1.  32.2 核心迭代角色：可迭代对象和迭代器

1.  32.3 遍历数据

    1.  32.3.1 手动遍历数据

    1.  32.3.2 使用 `while` 手动迭代

    1.  32.3.3 通过 `Iterator.from()` 获取迭代器 (ES2024)

    1.  32.3.4 通过基于迭代的语言结构进行迭代

    1.  [32.3.5 将可迭代对象转换为数组：`[...i]` 和 `Array.from(i)`](#converting-iterables-to-arrays-i-and-arrayfromi)

1.  32.4 通过生成器处理可迭代对象

1.  32.5 迭代 API 的继承（高级）

    1.  32.5.1 数组迭代器

    1.  32.5.2 生成器对象

1.  32.6 可迭代迭代器

    1.  32.6.1 为什么内置迭代器是可迭代的？

    1.  32.6.2 当请求迭代器时，迭代器返回自身

    1.  32.6.3 迭代怪癖：两种可迭代对象

1.  32.7 `Iterator` 类和迭代器辅助方法 (ES2025)

    1.  32.7.1 `Iterator.prototype.*` 方法

    1.  32.7.2 迭代器辅助方法的好处

    1.  32.7.3 `Iterator.from()`：创建 API 迭代器

    1.  32.7.4 迭代器方法改变我们使用迭代的方式

    1.  32.7.5 将遗留的可迭代对象升级到 `Iterator` API

1.  32.8 分组可迭代对象 (ES2024)

    1.  32.8.1 在 `Map.groupBy()` 和 `Object.groupBy()` 之间选择

    1.  32.8.2 示例：处理情况

    1.  32.8.3 示例：按属性值分组

1.  32.9 快速参考：同步迭代

    1.  32.9.1 同步迭代：数据生产者

    1.  32.9.2 同步迭代：数据消费者

1.  32.10 快速参考：类 `Iterator` (ES2025)

    1.  32.10.1 创建迭代器

    1.  32.10.2 `Iterator.*`

    1.  32.10.3 `Iterator.prototype.*`：将索引传递给回调的方法

    1.  32.10.4 `Iterator.prototype.*`：返回迭代器的方法

    1.  32.10.5 `Iterator.prototype.*`: 返回布尔值的方法

    1.  32.10.6 `Iterator.prototype.*`: 返回其他类型值的方法

    1.  32.10.7 `Iterator.prototype.*`: 其他方法

### 32.1 关于同步迭代的什么？

同步迭代是一种*协议*（接口及其使用规则），它将 JavaScript 中的两组实体连接起来：

+   **数据源：**一方面，数据以各种形状和大小存在。在 JavaScript 的标准库中，我们有线性数据结构数组（Array）、有序集合（Set，元素按添加时间排序）、有序字典（Map，条目按添加时间排序）等。在库中，我们可能还会找到树形数据结构等。

+   **数据消费者：**另一方面，我们有一类只需要按顺序访问其输入的构造和算法：例如`for-of`循环和将值展开到数组字面量中（通过`...`）。

迭代协议通过接口`Iterable`连接这两组对象：数据源通过它顺序地“传递”其内容；数据消费者从它那里获取输入。

![](img/52bbdbeebda7e97eed377dd5c6cf02df.png)

图 32.1：如`for-of`循环这样的数据消费者使用接口`Iterable`。如`Arrays`这样的数据源实现该接口。

图 32.1 说明了迭代是如何工作的：数据消费者使用接口`Iterable`；数据源实现它。

![图标“详情”](img/38ba63de820aae6f94a019538ae0f222.png) **JavaScript 实现接口的方式**

在 JavaScript 中，一个对象如果实现了它所描述的所有方法，则认为它实现了接口。本章中提到的接口仅存在于 ECMAScript 规范中。

数据的提供者和消费者都从这种安排中受益：

+   如果我们开发一个新的数据结构，我们只需要实现`Iterable`，然后就可以立即将其应用于一系列工具。

+   如果我们编写使用迭代的代码，它将自动与许多数据源一起工作。

### 32.2 核心迭代角色：可迭代对象和迭代器

两个角色（由接口描述）构成了迭代的核心（图 32.2）：

+   一个*可迭代对象*是一个其内容可以被顺序遍历的对象。

+   一个*迭代器*是用于遍历的指针。

![](img/18a5343baba7051a9127cee5ee460844.png)

图 32.2：迭代有两个主要接口：`Iterable`和`Iterator`。前者有一个返回后者的方法。

这些是迭代协议接口的类型定义（以 TypeScript 的表示法）：

```js
interface Iterable<T> {
  [Symbol.iterator]() : Iterator<T>;
}

abstract class Iterator<T> {
  abstract next() : IteratorResult<T>;
}

interface IteratorResult<T> {
  value: T;
  done: boolean;
}

```

接口的使用方法如下：

+   我们通过`Symbol.iterator`键的方法来请求一个`Iterable`。

+   一个迭代器扩展了抽象类 `Iterator`，并通过其方法 `.next()` 返回迭代值。

    +   注意：在 ECMAScript 2025 之前，`Iterator` 只是一个接口。不存在全局可访问的类 `Iterator`。

+   值不是直接返回的，而是被包裹在具有两个属性的对象中：

    +   `.value` 是迭代值。

    +   `.done` 表示迭代是否已到达末尾。在最后一个迭代值之后为 `true`，在此之前为 `false`。

### 32.3 遍历数据

#### 32.3.1 手动遍历数据

这就是使用迭代协议的一个例子：

```js
const iterable = ['a', 'b'];

// The iterable is a factory for iterators:
const iterator = iterable[Symbol.iterator]();

// Call .next() until .done is true:
assert.deepEqual(
  iterator.next(), { value: 'a', done: false }
);
assert.deepEqual(
  iterator.next(), { value: 'b', done: false }
);
assert.deepEqual(
  iterator.next(), { value: undefined, done: true }
);

```

#### 32.3.2 使用 `while` 手动迭代

以下代码演示了如何使用 `while` 循环遍历可迭代对象：

```js
function logAll(iterable) {
  const iterator = iterable[Symbol.iterator]();
  while (true) {
    const {value, done} = iterator.next();
    if (done) break;
    console.log(value);
  }
}
logAll(['a', 'b']);

```

输出：

```js
a
b

```

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：手动使用同步迭代**

`exercises/sync-iteration/sync_iteration_manually_exrc.mjs`

#### 32.3.3 通过 `Iterator.from()` 获取迭代器 (ES2024)

内置的静态方法 `Iterator.from()` 提供了一种更优雅的方式来检索迭代器：

```js
> const iterable = ['a', 'b'];
> iterable[Symbol.iterator]() instanceof Iterator
true
> Iterator.from(iterable) instanceof Iterator
true

```

#### 32.3.4 通过基于迭代的语言结构进行迭代

我们已经看到了如何手动使用迭代协议，这相对比较繁琐。但协议并不是直接使用的目的——它是通过在其之上构建的高级语言结构来使用的。我们会注意到，当我们这样做时，我们从未看到迭代器。它们仅用于内部。

##### 32.3.4.1 遍历数组

基于迭代的最重要的语言结构是 `for-of` 循环：

```js
const iterable = ['hello', 'beautiful', 'world'];
for (const x of iterable) {
  console.log(x);
}

```

输出：

```js
hello
beautiful
world

```

另一个基于迭代的结构是将值扩展到数组字面量中：

```js
assert.deepEqual(
  ['BEFORE', ...iterable, 'AFTER'],
  ['BEFORE', 'hello', 'beautiful', 'world', 'AFTER']
);

```

通过数组模式解构也使用底层的迭代：

```js
const [first, second] = iterable;
assert.equal(first, 'hello');
assert.equal(second, 'beautiful');

```

##### 32.3.4.2 遍历集合

集合也是可迭代的。请注意，迭代代码是相同的：它既看不到数组，也看不到集合，只看到可迭代对象。

```js
const iterable = ['hello', 'beautiful', 'world'];

for (const x of iterable) {
  console.log(x);
}

assert.deepEqual(
  ['BEFORE', ...iterable, 'AFTER'],
  ['BEFORE', 'hello', 'beautiful', 'world', 'AFTER']
);

const [first, second] = iterable;
assert.equal(first, 'hello');
assert.equal(second, 'beautiful');

```

#### [32.3.5 将可迭代对象转换为数组：`[...i]` 和 `Array.from(i)`](#converting-iterables-to-arrays-i-and-arrayfromi)

这些是将可迭代对象转换为数组的方法：

```js
const iterable = new Set().add('a').add('b').add('c');
assert.deepEqual(
  [...iterable],
  ['a', 'b', 'c']
);
assert.deepEqual(
  Array.from(iterable),
  ['a', 'b', 'c']
);

```

我倾向于更喜欢 `Array.from()`，因为它更具自描述性。

更多信息：“将可迭代对象、迭代器和类似数组的值转换为数组” (§34.6)

我们还可以创建一个迭代器，并使用迭代器方法来创建一个数组。迭代器方法将在后面解释。

```js
assert.deepEqual(
  Iterator.from(iterable).toArray(),
  ['a', 'b', 'c']
);

```

### 32.4 通过生成器处理可迭代对象

同步生成器函数和方法通过它们返回的迭代器（也是可迭代的）来暴露它们的生成值：

```js
/** Synchronous generator function */
function* createSyncIterable() {
 yield 'a';
 yield 'b';
 yield 'c';
}

```

生成器产生可迭代对象，但它们也可以消费它们。这使得它们成为转换可迭代对象的通用工具：

```js
function* map(iterable, callback) {
  for (const x of iterable) {
    yield callback(x);
  }
}
assert.deepEqual(
  Array.from(
    map([1, 2, 3, 4], x => x ** 2)
  ),
  [1, 4, 9, 16]
);

function* filter(iterable, callback) {
  for (const x of iterable) {
    if (callback(x)) {
      yield x;
    }
  }
}
assert.deepEqual(
  Array.from(
    filter([1, 2, 3, 4], x => (x % 2) === 0
  )),
  [2, 4]
);

```

更多信息：“同步生成器（ES6）(高级)”（§33）

### 32.5 迭代 API 的继承（高级）

JavaScript 标准库创建的所有迭代器都有一个共同的原型，ECMAScript 规范将其称为`[%IteratorPrototype%](https://tc39.es/ecma262/#sec-%iteratorprototype%-object)`并在内部使用。我们可以通过`Iterator.prototype`从 JavaScript 中访问它。

#### 32.5.1 数组迭代器

我们可以这样创建一个数组迭代器：

```js
const arrayIterator = [][Symbol.iterator]();

```

这个对象有一个具有两个属性的原型。我们可以称它为`ArrayIteratorPrototype`：

```js
const ArrayIteratorPrototype = Object.getPrototypeOf(arrayIterator);
assert.deepEqual(
  Reflect.ownKeys(ArrayIteratorPrototype),
  [ 'next', Symbol.toStringTag ]
);
assert.equal(
  ArrayIteratorPrototype[Symbol.toStringTag],
  'Array Iterator'
);

```

`ArrayIteratorPrototype`的原型是`%IteratorPrototype%`。这个对象有一个键名为`Symbol.iterator`的方法。因此，所有内置迭代器都是可迭代的。

```js
const IteratorPrototype = Object.getPrototypeOf(ArrayIteratorPrototype);
assert.equal(
  IteratorPrototype, Iterator.prototype
);
assert.equal(
  Object.hasOwn(Iterator.prototype, Symbol.iterator),
  true
);
assert.equal(
  typeof Iterator.prototype[Symbol.iterator],
  'function'
);

```

`Iterator.prototype`的原型是`Object.prototype`。

```js
assert.equal(
  Object.getPrototypeOf(Iterator.prototype) === Object.prototype,
  true
);

```

图 32.3 包含了这个原型链的图示。

![](img/7114dc60cff41ea48eb99d0bb278db66.png)

图 32.3：原型链（从下到上）：

+   首先是`[][Symbol.iterator]()`的结果（`%ArrayIterator%`的一个实例）

+   然后`%ArrayIteratorPrototype%`

+   然后`%IteratorPrototype%`

+   最后`Object.prototype`

#### 32.5.2 生成器对象

大概来说，生成器对象是生成器函数`genFunc()`产生的值的迭代器。我们通过调用`genFunc()`来创建它：

```js
function* genFunc() {
 yield 'a';
 yield 'b';
}
const genObj = genFunc();

```

生成器对象是一个迭代器：

```js
assert.deepEqual(
  genObj.next(),
  { value: 'a', done: false }
);
assert.equal(
  genObj instanceof Iterator,
  true
);
assert.equal(
  Iterator.prototype.isPrototypeOf(genObj),
  true
);

```

### 32.6 可迭代迭代器

#### 32.6.1 为什么内置迭代器是可迭代的？

正如我们所见，所有内置迭代器都是可迭代的：

```js
// Array iterator
const arrayIterator = ['a', 'b'].values();
assert.equal(
  // arrayIterator is a built-in iterator
  arrayIterator instanceof Iterator, true
);
assert.equal(
  // arrayIterator is iterable
  Symbol.iterator in arrayIterator, true
);

// Generator object
function* gen() { yield 'hello' }
const genObj = gen();
assert.equal(
 genObj instanceof Iterator, true
);
assert.equal(
 Symbol.iterator in genObj, true
);

// Iterator returned by `Iterator` method
const iter = Iterator.from([1, 2]).map(x => x * 2);
assert.equal(
 iter instanceof Iterator, true
);
assert.equal(
 Symbol.iterator in iter, true
);

```

它的好处是我们能够遍历迭代器的值——例如，通过`for-of`和`Array.from()`。

另一个好处是生成器变得更加灵活。一方面，我们可以使用它们来实现迭代器：

```js
class MyIterable {
  /** This method must return an iterator */
  * [Symbol.iterator]() {
    yield 'good';
    yield 'morning';
  }
}
assert.deepEqual(
  Array.from(new MyIterable()),
  ['good', 'morning']
);

```

另一方面，我们可以使用它们来实现可迭代对象：

```js
function* createIterable() {
 yield 'a';
 yield 'b';
}
assert.deepEqual(
 Array.from(createIterable()),
 ['good', 'morning']
);

```

#### 32.6.2 迭代器在请求迭代器时返回自身

如果一个迭代器是可迭代的：它产生的迭代器是什么？当请求迭代器时，它简单地返回自身：

```js
const iterator = Iterator.from(['a', 'b'])
assert.equal(
  iterator[Symbol.iterator](),
  iterator
);

```

#### 32.6.3 迭代怪癖：两种类型的可迭代对象

可惜，可迭代迭代器意味着存在两种类型的可迭代对象：

1.  一个可迭代迭代器是*一次性可迭代的*：当调用`[Symbol.iterator]()`时，它总是返回相同的迭代器（自身）（迭代继续）。

1.  一个普通的可迭代对象（一个数组、一个集合等）是*多次可迭代的*：它总是返回一个新的迭代器（迭代重新开始）。

对于一次性可迭代，每次迭代都会移除更多元素，直到最终没有更多元素为止：

```js
const oneTime = ['a', 'b', 'c'].values();
for (const x of oneTime) {
  assert.equal(
    x, 'a'
  );
  break;
}
assert.deepEqual(
  Array.from(oneTime),
  ['b', 'c']
);
assert.deepEqual(
  Array.from(oneTime),
  []
);

```

使用多次可迭代的，每次迭代都是从新开始：

```js
const manyTimes = ['a', 'b', 'c'];
for (const x of manyTimes) {
  assert.equal(
    x, 'a'
  );
  break;
}
assert.deepEqual(
  Array.from(manyTimes),
  ['a', 'b', 'c']
);
assert.deepEqual(
  Array.from(manyTimes),
  ['a', 'b', 'c']
);

```

以下代码是差异的另一个示例：

```js
const oneTime = ['a', 'b', 'c'].values();
assert.deepEqual(
  [...oneTime, ...oneTime, ...oneTime],
  ['a', 'b', 'c']
);

const manyTimes = ['a', 'b', 'c'];
assert.deepEqual(
  [...manyTimes, ...manyTimes, ...manyTimes],
  ['a','b','c', 'a','b','c', 'a','b','c']
);

```

### 32.7 类`Iterator`和迭代器辅助方法（ES2025）

我们已经看到 `%IteratorPrototype%` 是所有内置迭代器的原型。ECMAScript 2025 引入了一个名为 `Iterator` 的类：

+   `Iterator.prototype` 指的是 `%IteratorPrototype%`。

+   `%IteratorPrototype%.constructor` 指的是 `Iterator`。

该类提供了以下功能：

+   `Iterator.from(iterable)` 返回 `iterable` 的迭代器。我们将在后面详细探讨它。稍后。

+   `Iterator.prototype` 包含各种辅助方法，这些方法由迭代器继承。

#### 32.7.1 `Iterator.prototype.*` 方法

以下迭代器辅助方法与具有相同名称的数组方法类似：

+   返回迭代器的函数：

    +   `iterator.filter(filterFn)`

    +   `iterator.map(mapFn)`

    +   `iterator.flatMap(mapFn)`

+   返回布尔值的函数：

    +   `iterator.some(fn)`

    +   `iterator.every(fn)`

+   返回其他值的函数：

    +   `iterator.find(fn)`

    +   `iterator.reduce(reducer, initialValue?)`

+   不返回值的函数：

    +   `iterator.forEach(fn)`

这些辅助方法仅适用于迭代器：

+   `iterator.drop(limit)`

    +   返回没有前 `limit` 个元素的 `iterator` 的迭代器。

+   `iterator.take(limit)`

    +   返回具有 `iterator` 的前 `limit` 个元素的迭代器。

+   `iterator.toArray()`

    +   将 `iterator` 的所有剩余元素收集到一个数组中并返回它。

每个方法的简要说明，请参阅“快速参考：类 `Iterator` (ES2025)”（§32.10）。以下是这些方法实际应用的示例：

```js
assert.deepEqual(
  ['a', 'b', 'c'].values().map(x => `=${x}=`).toArray(),
  ['=a=', '=b=', '=c=']
);
assert.deepEqual(
  ['a', 'b', 'c'].values().drop(1).toArray(),
  ['b', 'c']
);
assert.deepEqual(
  ['a', 'b', 'c'].values().take(2).toArray(),
  ['a', 'b']
);

```

数组方法 `arr.values()` 返回 `arr` 元素的迭代器。

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：使用迭代器**

+   为迭代器实现 `.at()`：`exercises/sync-iteration/iterator-at_test.mjs`

+   为迭代器实现 `.findIndex()`：`exercises/sync-iteration/iterator-find-index_test.mjs`

+   为迭代器实现 `.slice()`：`exercises/sync-iteration/slice-iterator_test.mjs`

+   为迭代器元素添加索引：`exercises/sync-iteration/add-index-to-iterator_test.mjs`

+   使用 `iterator.reduce()` 计算迭代器的长度：`exercises/sync-iteration/iterator-length_test.mjs`

#### 32.7.2 迭代器辅助方法的益处

##### 32.7.2.1 利益：支持迭代的数组的更多操作

使用迭代器辅助方法，任何支持迭代的数结构自动获得功能。

例如，集合不支持 `filter` 和 `map` 操作，但我们可以通过迭代器方法获得它们：

```js
assert.deepEqual(
  new Set( // (A)
    new Set([-5, 2, 6, -3]).values().filter(x => x >= 0)
  ),
  new Set([2, 6])
);
assert.deepEqual(
  new Set( // (B)
    new Set([-5, 2, 6, -3]).values().map(x => x / 2)
  ),
  new Set([-2.5, 1, 3, -1.5])
);

```

注意，`new Set()` 接受可迭代对象，因此可迭代的迭代器（行 A 和行 B）。

DOM 集合也没有 `.filter()` 和 `.map()` 方法：

```js
const domCollection = document.querySelectorAll('a');

// Alas, the collection doesn’t have a method .map()
assert.equal('map' in domCollection, false);

// Solution: use an iterator
assert.deepEqual(
  domCollection.values().map(x => x.href).toArray(),
  ['https://2ality.com', 'https://exploringjs.com']
);

```

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：通过迭代器方法实现 `.filter()` 和 `.map()`**

`exercises/sync-iteration/set-operations-via-iterators_test.mjs`

##### 32.7.2.2 优势：没有中间数组，增量处理

如果我们链式操作返回数组的操作（行 A、行 B、行 C），那么每个操作都会产生一个新的数组：

```js
function quoteNonEmptyLinesArray(str) {
  return str
    .split(/(?<=\r?\n)/) // (A)
    .filter(line => line.trim().length > 0) // (B)
    .map(line => '> ' + line) // (C)
    ;
}

```

行 A 中的正则表达式包含一个后视断言，这确保了`.split()`返回的行包括行终止符。

相比之下，以下代码中的每个操作（行 A、行 B、行 C）都返回一个迭代器，并且不会创建任何中间数组：

```js
function quoteNonEmptyLinesIter(str) {
  return splitLinesIter(str) // (A)
    .filter(line => line.trim().length > 0) // (B)
    .map(line => '> ' + line) // (C)
    ;
}

function* splitLinesIter(str) {
  let prevIndex = 0;
  while (true) {
    const eolIndex = str.indexOf('\n', prevIndex);
    if (eolIndex < 0) break;
    // Including EOL
    const line = str.slice(prevIndex, eolIndex + 1);
    yield line;
    prevIndex = eolIndex + 1;
  }
  if (prevIndex < str.length) {
    yield str.slice(prevIndex);
  }
}

```

使用`quoteNonEmptyLinesIter()`的示例：

```js
assert.deepEqual(
  Array.from(quoteNonEmptyLinesIter('have\n\na nice\n\nday')),
  [
    '> have\n',
    '> a nice\n',
    '> day',
  ]
);

```

注意，三行文本之间的空行已被过滤掉。

除了不创建中间数组之外，迭代器还提供了增量处理：

```js
> const iter = quoteNonEmptyLinesIter('have\n\na nice\n\nday');
> iter.next()
{ value: '> have\n', done: false }
> iter.next()
{ value: '> a nice\n', done: false }
> iter.next()
{ value: '> day', done: false }
> iter.next()
{ value: undefined, done: true }

```

相比之下，`quoteNonEmptyLinesArray()`首先拆分所有行，然后过滤所有行，最后映射所有行。在处理大量数据时，增量处理很重要。迭代器辅助方法作为增量处理工具补充了生成器。

#### 32.7.3 `Iterator.from()`: 创建 API 迭代器

所有内置的可迭代对象都自动支持新的 API，因为它们的迭代器已经具有`Iterator.prototype`作为原型（因此是`Iterator`的实例）。然而，并非所有库和用户代码中的可迭代对象都是这样。

术语：

+   支持`Iterator` API 的实体：*API 迭代器*和*API 可迭代对象*

+   不支持的实体：*遗留迭代器*和*遗留可迭代对象*

`Iterator.from(obj)`是如何工作的？

+   如果`obj`是可迭代的，那么它通过调用`obj[Symbol.iterator]()`来创建一个迭代器。

    +   如果新的迭代器是一个`Iterator`实例，它将按原样返回。

    +   否则，它会包装起来，使其成为一个`Iterator`实例。

+   如果`obj`是一个迭代器，`Iterator.from()`确保它是一个`Iterator`实例，并返回它。

在以下示例中，我们使用`Iterator.from()`将遗留迭代器转换为 API 迭代器：

```js
// Not an instance of `Iterator`
const legacyIterator = {
  next() {
 // Infinite iterator (never done)
 return { done: false, value: '#' };
 }
};
assert.equal(
 Iterator.from(legacyIterator) instanceof Iterator,
 true
);
assert.deepEqual(
 Iterator.from(legacyIterator).take(3).toArray(),
 ['#', '#', '#']
);

```

#### 32.7.4 迭代器方法改变了我们使用迭代的方式

迭代器方法改变了我们使用迭代的方式：

+   以前，我们从未见过迭代器，总是与可迭代对象一起工作，例如通过`for-of`或`Array.from()`。

+   现在，使用迭代器也是有用的，我们必须注意如何创建它们。

有趣的是，我们的关注点如何随着`Array.prototype.keys()`等方法的改变而转移，这些方法返回可迭代迭代器：在迭代器方法之前，我们使用结果作为可迭代对象。使用迭代器方法时，我们也将它们用作迭代器：

```js
> Array.from(['a', 'b'].keys()) // iterable
[ 0, 1 ]
> ['a', 'b'].keys().toArray() // iterator
[ 0, 1 ]

```

更多信息，请参阅“创建迭代器”（§32.10.1）。

#### 32.7.5 将遗留可迭代对象升级到`Iterator` API

这是一个遗留可迭代对象的示例：

```js
class ValueIterable {
  #values;
  #index = 0;
  constructor(...values) {
    this.#values = values;
  }
  [Symbol.iterator]() {
    return {
      // Arrow function so that we can use the outer `this`
      next: () => {
        if (this.#index >= this.#values.length) {
          return {done: true};
        }
        const value = this.#values[this.#index];
        this.#index++;
        return {done: false, value};
      },
    };
  }
}

// legacyIterable is an iterable
const legacyIterable = new ValueIterable('a', 'b', 'c');
assert.deepEqual(
  Array.from(new ValueIterable('a', 'b', 'c')),
  ['a', 'b', 'c']
);

// But its iterators are not instances of Iterator
const legacyIterator = legacyIterable[Symbol.iterator]();
assert.equal(
  legacyIterator instanceof Iterator, false
);

```

如果我们想让`ValueIterable`支持`Iterator` API，我们必须使其迭代器成为`Iterator`实例：

```js
class ValueIterable {
  // ···
  [Symbol.iterator]() {
    return {
      __proto__: Iterator.prototype,
      next: () => {
        // ···
      },
    };
  }
}

```

这又是一个选项（尽管效率较低）：

```js
class ValueIterable {
  // ···
  [Symbol.iterator]() {
    return Iterator.from({
      next: () => {
        // ···
      },
    });
  }
}

```

我们还可以为迭代器创建一个类：

```js
class ValueIterable {
  #values;
  #index = 0;
  constructor(...values) {
    this.#values = values;
  }
  [Symbol.iterator]() {
    const outerThis = this;
    // Because ValueIterator is nested, it can access the private fields of
    // ValueIterable
    class ValueIterator extends Iterator {
      next() {
 if (outerThis.#index >= outerThis.#values.length) {
 return {done: true};
 }
 const value = outerThis.#values[outerThis.#index];
 outerThis.#index++;
 return {done: false, value};
 }
 }
 return new ValueIterator();
 }
}

```

### 32.8 分组可迭代对象（ES2024）

`Map.groupBy()` 将可迭代对象的项分组到 Map 条目中，其键由回调函数提供：

```js
assert.deepEqual(
  Map.groupBy([0, -5, 3, -4, 8, 9], x => Math.sign(x)),
  new Map().set(0, [0]).set(-1, [-5,-4]).set(1, [3,8,9])
);

```

要分组的项可以来自任何可迭代对象：

```js
function* generateNumbers() {
 yield 2;
 yield -7;
 yield 4;
}
assert.deepEqual(
 Map.groupBy(generateNumbers(), x => Math.sign(x)),
 new Map().set(1, [2,4]).set(-1, [-7])
);

```

此外还有 `Object.groupBy()`，它生成一个对象而不是 Map：

```js
assert.deepEqual(
  Object.groupBy([0, -5, 3, -4, 8, 9], x => Math.sign(x)),
  {'0': [0], '-1': [-5,-4], '1': [3,8,9], __proto__: null}
);

```

#### 32.8.1 在 `Map.groupBy()` 和 `Object.groupBy()` 之间选择

+   你想按字符串和符号以外的键进行分组吗？

    +   然后你需要一个 Map。对象只能有字符串和符号作为键。

+   你想解构 `.groupBy()` 的结果（请参阅本节后面的示例）吗？

    +   然后你需要一个对象。

+   否则，你可以自由选择你喜欢的。

#### 32.8.2 示例：处理情况

Promise 组合器 `Promise.allSettled()`（Promise.allSettled()）返回如下数组：

```js
const settled = [
  { status: 'rejected', reason: 'Jhon' },
  { status: 'fulfilled', value: 'Jane' },
  { status: 'fulfilled', value: 'John' },
  { status: 'rejected', reason: 'Jaen' },
  { status: 'rejected', reason: 'Jnoh' },
];

```

我们可以按如下方式对数组元素进行分组：

```js
const {fulfilled, rejected} = Object.groupBy(settled, x => x.status); // (A)

// Handle fulfilled results
assert.deepEqual(
  fulfilled,
  [
    { status: 'fulfilled', value: 'Jane' },
    { status: 'fulfilled', value: 'John' },
  ]
);

// Handle rejected results
assert.deepEqual(
  rejected,
  [
    { status: 'rejected', reason: 'Jhon' },
    { status: 'rejected', reason: 'Jaen' },
    { status: 'rejected', reason: 'Jnoh' },
  ]
);

```

对于此用例，`Object.groupBy()` 工作得更好，因为我们可以在 Map 中使用任意键，而在对象中，键仅限于字符串和符号。

#### 32.8.3 示例：按属性值分组

在下一个示例中，我们想要按国家分组人员：

```js
const persons = [
  { name: 'Louise', country: 'France' },
  { name: 'Felix', country: 'Germany' },
  { name: 'Ava', country: 'USA' },
  { name: 'Léo', country: 'France' },
  { name: 'Oliver', country: 'USA' },
  { name: 'Leni', country: 'Germany' },
];

assert.deepEqual(
  Map.groupBy(persons, (person) => person.country),
  new Map([
    [
      'France',
      [
        { name: 'Louise', country: 'France' },
        { name: 'Léo', country: 'France' },
      ]
    ],
    [
      'Germany',
      [
        { name: 'Felix', country: 'Germany' },
        { name: 'Leni', country: 'Germany' },
      ]
    ],
    [
      'USA',
      [
        { name: 'Ava', country: 'USA' },
        { name: 'Oliver', country: 'USA' },
      ]
    ],
  ])
);

```

对于此用例，`Map.groupBy()` 是更好的选择，因为我们可以在 Map 中使用任意键，而在对象中，键仅限于字符串和符号。

![“练习”图标](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：使用 `Map.groupBy()` 对对象数组进行分组**

`exercises/sync-iteration/count-cities_test.mjs`

### 32.9 快速参考：同步迭代

#### 32.9.1 同步迭代：数据生产者

这些数据结构是可迭代的：

+   字符串

+   数组

+   集合

+   Map

+   （浏览器：DOM 数据结构）

以下数据结构具有 `.keys()`、`.values()` 和 `.entries()` 方法，这些方法返回的不是数组：

+   数组

+   集合

+   Map

顺便提一下 - 以下静态方法列出属性键、值和条目（它们不是普通方法，因为那些可能会意外覆盖）。它们返回数组。

+   `Object.keys(obj)`

+   `Object.values(obj)`

+   `Object.entries(obj)`

同步生成器函数和方法通过它们返回的可迭代对象暴露其产生的值：

```js
/** Synchronous generator function */
function* createSyncIterable() {
 yield 'a';
 yield 'b';
 yield 'c';
}

assert.deepEqual(
 Array.from(createSyncIterable()),
 ['a', 'b', 'c']
);

```

#### 32.9.2 同步迭代：数据消费者

本节列出了通过同步迭代消耗数据的结构。

##### 32.9.2.1 语言迭代结构

+   `for-of` 循环：

    ```js
    for (const x of iterable) { /*···*/ }

    ```

+   通过（`...`）扩展到数组字面量和函数调用：

    ```js
    const arr = ['a', ...iterable, 'z'];
    func('a', ...iterable, 'z');

    ```

+   通过数组模式进行解构：

    ```js
    const [x, y] = iterable;

    ```

+   `yield*`:

    ```js
    function* generatorFunction() {
     yield* iterable;
    }

    ```

##### 32.9.2.2 将可迭代对象转换为数据结构

+   Object.fromEntries():

    ```js
    const obj = Object.fromEntries(iterableOverKeyValuePairs);

    ```

+   Array.from():

    ```js
    const arr = Array.from(iterable);

    ```

    替代方案 - 扩展:

    ```js
    const arr = [...iterable];

    ```

+   `new Map()`和`new WeakMap()`：

    ```js
    const m  = new Map(iterableOverKeyValuePairs);
    const wm = new WeakMap(iterableOverKeyValuePairs);

    ```

+   `new Set()`和`new WeakSet()`：

    ```js
    const s  = new Set(iterableOverElements);
    const ws = new WeakSet(iterableOverElements);

    ```

##### 32.9.2.3 将 Promise 的可迭代对象转换为 Promises

+   Promise 组合函数: `Promise.all()`等。

    ```js
    const promise1 = Promise.all(iterableOverPromises);
    const promise2 = Promise.race(iterableOverPromises);
    const promise3 = Promise.any(iterableOverPromises);
    const promise4 = Promise.allSettled(iterableOverPromises);

    ```

##### 32.9.2.4 将可迭代对象分组到 Map 或对象中

+   “`Map.groupBy(items, computeGroupKey)`”

+   “`Object.groupBy(items, computeGroupKey)`”

### 32.10 快速参考：`Iterator`类 (ES2025)

#### 32.10.1 创建迭代器

`Iterator`类的这些方法允许我们增量地处理数据。让我们看看我们可以在哪里使用它们。

##### 32.10.1.1 从可迭代对象获取迭代器

+   `Iterator.from(iterable)`总是返回`Iterator`的实例（在需要时将非实例转换为实例）。

+   `iterable[Symbol.iterator]()`返回一个迭代器：

    +   所有内置的数据结构的结果都是一个`Iterator`的实例。

    +   使用其他较旧的可迭代对象时，结果可能不是`Iterator`的实例。

##### 32.10.1.2 内置方法返回迭代器

数组、类型化数组、集合和 Map 有额外的返回迭代器的方法：

+   数组（类似地：类型化数组）：

    +   `Array.prototype.keys()`返回一个数字的迭代器。

    +   `Array.prototype.values()`返回一个迭代器。

    +   `Array.prototype.entries()`返回一个键值对的迭代器。键是数字。

+   集合：

    +   `Set.prototype.values()`返回一个迭代器。

    +   `Set.prototype.keys()`返回一个迭代器。等同于`.values()`。

    +   `Set.prototype.entries()`返回一个值值对的迭代器（即，对的两个组件都是相同的值）。

+   Map：

    +   `Map.prototype.keys()`返回一个迭代器。

    +   `Map.prototype.values()`返回一个迭代器。

    +   `Map.prototype.entries()`返回一个键值对的迭代器。

以下方法返回迭代器：

+   `String.prototype.matchAll()`返回一个匹配对象的迭代器。

##### 32.10.1.3 迭代器的其他来源

生成器也返回迭代器：

```js
function* gen() {}

assert.equal(
 gen() instanceof Iterator,
 true
);

```

#### 32.10.2 `Iterator.*`

+   `Iterator.from(iterableOrIterator)`返回一个保证是`Iterator`实例的迭代器。如果参数是旧的可迭代对象或旧迭代器，它将包装结果，使其成为`Iterator`的实例。

#### 32.10.3 `Iterator.prototype.*`: 将索引传递给回调的方法

一些迭代器方法会为迭代的值保持一个计数器，并将其传递给它们的回调：

+   `.every()`

+   `.filter()`

+   `.find()`

+   `.flatMap()`

+   `.forEach()`

+   `.map()`

+   `.reduce()`

+   `.some()`

#### 32.10.4 `Iterator.prototype.*`: 返回迭代器的函数

+   `Iterator.prototype.drop(limit)` ES2025

    ```js
    Iterator<T>.prototype.drop(limit: number): Iterator<T>

    ```

    此方法返回一个迭代器，包含 `iterator` 的所有值，除了前 `limit` 个。也就是说，迭代从迭代计数器为 `limit` 时开始。

    ```js
    assert.deepEqual(
      Iterator.from(['a', 'b', 'c', 'd']).drop(1).toArray(),
      ['b', 'c', 'd']
    );

    ```

+   `Iterator.prototype.filter(filterFn)`

    ES2025 | 回调获取计数器

    ```js
    Iterator<T>.prototype.filter(
      filterFn: (value: T, counter: number) => boolean
    ): Iterator<T>

    ```

    此方法返回一个迭代器，其值是 `iterator` 中 `filterFn` 返回 `true` 的值。

    ```js
    assert.deepEqual(
      Iterator.from(['a', 'b', 'c', 'd']).filter(x => x <= 'b').toArray(),
      ['a', 'b']
    );

    ```

+   `Iterator.prototype.flatMap(mapFn)`

    ES2025 | 回调获取计数器

    ```js
    Iterator<T>.prototype.flatMap<U>(
      mapFn: (value: T, counter: number) => Iterable<U> | Iterator<U>
    ): Iterator<U>

    ```

    此方法返回一个迭代器，其值是应用 `mapFn` 到 `iterator` 的值的结果的迭代器或可迭代对象。

    ```js
    assert.deepEqual(
      Iterator.from(['a', 'b', 'c', 'd'])
      .flatMap((value, counter) => new Array(counter).fill(value))
      .toArray(),
      ['b', 'c', 'c', 'd', 'd', 'd']
    );

    ```

    更多信息请参阅具有相同名称的数组方法部分：“`.flatMap()`: 每个输入元素产生零个或多个输出元素 (ES2019)” (§34.14.3)[(ch_arrays.html#Array.prototype.flatMap)]。

+   `Iterator.prototype.map(mapFn)`

    ES2025 | 回调获取计数器

    ```js
    Iterator<T>.prototype.map<U>(
      mapFn: (value: T, counter: number) => U
    ): Iterator<U>

    ```

    此方法返回一个迭代器，其值是应用 `mapFn` 到 `iterator` 的值的结果。

    ```js
    assert.deepEqual(
      Iterator.from(['a', 'b', 'c', 'd']).map(x => x + x).toArray(),
      ['aa', 'bb', 'cc', 'dd']
    );

    ```

+   `Iterator.prototype.take(limit)` ES2025

    ```js
    Iterator<T>.prototype.take(limit: number): Iterator<T>

    ```

    此方法返回一个迭代器，包含 `iterator` 的前 `limit` 个值。

    ```js
    assert.deepEqual(
      Iterator.from(['a', 'b', 'c', 'd']).take(1).toArray(),
      ['a']
    );

    ```

#### 32.10.5 `Iterator.prototype.*`: 返回布尔值的函数

+   `Iterator.prototype.every(fn)`

    ES2025 | 回调获取计数器

    ```js
    Iterator<T>.prototype.every(
      fn: (value: T, counter: number) => boolean
    ): boolean

    ```

    如果 `fn` 对 `iterator` 的每个值都返回 `true`，则此方法返回 `true`。否则，它返回 `false`。

    ```js
    assert.equal(
      Iterator.from(['a', 'b', 'c', 'd']).every(x => x === 'c'),
      false
    );

    ```

+   `Iterator.prototype.some(fn)`

    ES2025 | 回调获取计数器

    ```js
    Iterator<T>.prototype.some(
      fn: (value: T, counter: number) => boolean
    ): boolean

    ```

    如果 `fn` 对 `iterator` 的至少一个值返回 `true`，则此方法返回 `true`。否则，它返回 `false`。

    ```js
    assert.equal(
      Iterator.from(['a', 'b', 'c', 'd']).some(x => x === 'c'),
      true
    );

    ```

#### 32.10.6 `Iterator.prototype.*`: 返回其他类型值的函数

+   `Iterator.prototype.find(fn)`

    ES2025 | 回调获取计数器

    ```js
    Iterator<T>.prototype.find(
      fn: (value: T, counter: number) => boolean
    ): T

    ```

    此方法返回 `iterator` 中 `fn` 返回 `true` 的第一个值。如果没有这样的值，则返回 `undefined`。

    ```js
    assert.equal(
      Iterator.from(['a', 'b', 'c', 'd']).find((_, counter) => counter === 1),
      'b'
    );

    ```

+   `Iterator.prototype.reduce(reducer, initialValue?)`

    ES2025 | 回调获取计数器

    ```js
    Iterator<T>.prototype.reduce<U>(
      reducer: (accumulator: U, value: T, counter: number) => U,
      initialValue?: U
    ): U

    ```

    此方法使用函数 `reducer` 将 `iterator` 的值合并成一个单一值。

    示例 - 连接迭代器的字符串：

    ```js
    assert.deepEqual(
      Iterator.from(['a', 'b', 'c', 'd']).reduce((acc, v) => acc + v),
      'abcd'
    );

    ```

    示例 - 计算一组数字的最小值：

    ```js
    const set = new Set([3, -2, -5, 4]);
    assert.equal(
      set.values().reduce((min, cur) => cur < min ? cur : min, Infinity),
      -5
    );

    ```

    更多信息请参阅具有相同名称的数组方法部分：“`.reduce()`: 计算数组的摘要” (§34.15)[(ch_arrays.html#Array.prototype.reduce)]。

+   `Iterator.prototype.toArray()` ES2025

    ```js
    Iterator<T>.prototype.toArray(): Array<T>

    ```

    此方法返回 `iterator` 的值在数组中的值。

    ```js
    assert.deepEqual(
      Iterator.from(['a', 'b', 'c', 'd']).toArray(),
      ['a', 'b', 'c', 'd']
    );

    ```

#### 32.10.7 `Iterator.prototype.*`: 其他方法

+   `Iterator.prototype.forEach(fn)`

    ES2025 | 回调获取计数器

    ```js
    Iterator<T>.prototype.forEach(
      fn: (value: T, counter: number) => void
    ): void

    ```

    此方法将 `fn` 应用到 `iterator` 的每个值上。

    ```js
    const result = [];
    Iterator.from(['a', 'b', 'c', 'd']).forEach(x => result.unshift(x))
    assert.deepEqual(
      result,
      ['d', 'c', 'b', 'a']
    );

    ```
