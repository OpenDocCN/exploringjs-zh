# 44 异步函数 ES2017

> 原文：[`exploringjs.com/js/book/ch_async-functions.html`](https://exploringjs.com/js/book/ch_async-functions.html)

1.  44.1 异步函数：基础知识

    1.  44.1.1 `await`运算符使 Promise 同步

    1.  44.1.2 从异步函数返回值解析函数的结果

    1.  44.1.3 异步可调用实体

1.  44.2 `await`可以使用哪些值？

    1.  44.2.1 等待被解决的 Promise

    1.  44.2.2 等待被拒绝的 Promise

    1.  44.2.3 等待非 Promise 值

1.  44.3 `await`在哪里可以使用？

    1.  44.3.1 在模块的最高级别使用`await`^(ES2022)

    1.  44.3.2 等待是浅层的

    1.  44.3.3 示例：使用异步函数作为回调的`.map()`

1.  44.4 异步函数中的`return`

    1.  44.4.1 异步函数的结果始终是一个 Promise

    1.  44.4.2 返回一个 Promise 解析结果 Promise

1.  44.5 异步函数同步开始，异步解决

1.  44.6 使用异步函数的技巧

    1.  44.6.1 如果我们“发射并忘记”，则不需要`await`

    1.  44.6.2 有时可以`await`并忽略结果

    1.  44.6.3 `return await`的优缺点

1.  44.7 并发和`await`（高级）

    1.  44.7.1 `await`：按顺序运行基于 Promise 的函数

    1.  44.7.2 `await`：并发运行基于 Promise 的函数

*异步函数*提供了更好的语法来编写使用 Promise 的代码。因此，Promise 是理解异步函数的必备知识。它们在上一章中有解释。

### 44.1 异步函数：基础知识

考虑以下异步函数：

```js
async function fetchJsonAsync(url) {
  try {
    const request = await fetch(url); // async
    const text = await request.text(); // async
    return JSON.parse(text); // sync
  }
  catch (error) {
    assert.fail(error);
  }
}

```

两个关键字很重要：

+   在`function`之前的`async`关键字表示这是一个异步函数。

+   `await`运算符应用于 Promise，要么提取履行值，要么抛出拒绝值。关于它的更多信息将在后面介绍。

之前的代码看起来相当同步，等价于以下直接使用 Promise 的代码：

```js
function fetchJsonViaPromises(url) {
  return fetch(url) // async
  .then(request => request.text()) // async
  .then(text => JSON.parse(text)) // sync
  .catch((error) => {
    assert.fail(error);
  });
}

```

`fetchJsonAsync()`和`fetchJsonViaPromises()`的调用方式完全相同——例如，像这样：

```js
fetchJsonAsync('http://example.com/person.json')
.then((obj) => {
  assert.deepEqual(obj, {
    first: 'Jane',
    last: 'Doe',
  });
});

```

![图标“详情”](img/38ba63de820aae6f94a019538ae0f222.png) **异步函数与直接使用 Promise 的函数一样基于 Promise**

从外部来看，几乎无法区分 async 函数和返回 Promise 的函数之间的差异。

#### 44.1.1 `await`运算符使 Promise 同步

在 async 函数的主体内部，我们像同步代码一样编写基于 Promise 的代码。我们只需要在值是 Promise 时应用`await`运算符。该运算符暂停 async 函数，并在 Promise 解决后恢复：

+   如果 Promise 被解决，`await`返回解决值。

    ```js
    async function f() {
     assert.equal(
     await Promise.resolve('fulfilled'),
     'fulfilled'
     );
    }

    ```

+   如果 Promise 被拒绝，`await`会抛出拒绝值。

    ```js
    async function f() {
     try {
     await Promise.reject('rejected');
     } catch (err) {
     assert.equal(err, 'rejected');
     }
    }

    ```

#### 44.1.2 从 async 函数返回值解决函数的结果

async 函数的结果始终是一个 Promise：

+   任何返回的值（显式或隐式）都用于解决那个 Promise：

    ```js
    async function f1() { return 'fulfilled' }
    f1().then(
     result => assert.equal(result, 'fulfilled')
    );

    ```

+   任何抛出的异常都用于拒绝 Promise：

    ```js
    async function f() { throw 'rejected' }
    f().catch(
     error => assert.equal(error, 'rejected')
    );

    ```

#### 44.1.3 异步可调用实体

JavaScript 有以下同步可调用实体的异步版本。它们的作用始终是真实函数或方法。

```js
// Async function declaration
async function func1() {}

// Async function expression
const func2 = async function () {};

// Async arrow function
const func3 = async () => {};

// Async method definition in an object literal
const obj = { async m() {} };

// Async method definition in a class definition
class MyClass { async m() {} } 
```

![Icon “details”](img/38ba63de820aae6f94a019538ae0f222.png) **异步函数与 async 函数的比较**

“异步函数”和“async 函数”这两个术语之间的区别细微但很重要：

+   **异步函数**是指任何异步传递其结果的函数——例如，基于回调的函数或基于 Promise 的函数。

+   **async 函数**通过特殊语法定义，涉及关键字`async`和`await`。由于这两个关键字，它也被称为 async/await。Async 函数基于 Promise，因此也是异步函数（这有点令人困惑）。

也就是说：这两个术语也经常互换使用。

![Icon “exercise”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：通过 async 函数使用 Fetch API**

`exercises/async-functions/fetch_json2_test.mjs`

### 44.2 `await`可以使用哪些值？

`await`运算符只能在 async 函数和 async 生成器（在“异步生成器”（§45.2）中解释）内部使用。其操作数通常是 Promise，并导致以下步骤执行：

+   当前 async 函数处于暂停状态。

+   当 Promise 解决时，async 函数会恢复：

    +   如果 Promise 被解决，`await`返回解决值。

    +   如果 Promise 被拒绝，`await`会抛出拒绝值。

关于暂停和恢复的确切含义的更多信息，请参阅“异步函数同步开始，异步解决”（§44.5）。

继续阅读以了解`await`如何处理各种值。

#### 44.2.1 等待解决的 Promise

如果其操作数是一个已解决的 Promise，`await`返回其解决值：

```js
assert.equal(
  await Promise.resolve('fulfilled'), 'fulfilled'
);

```

`await`的值异步传递：

```js
async function awaitPromise() {
 queueMicrotask( // (A)
 () => console.log('OTHER TASK')
 );
 console.log('before');
 await Promise.resolve('fulfilled');
 console.log('after');
}
await awaitPromise();

```

输出：

```js
before
OTHER TASK
after

```

在行 A 中，我们不能使用`setTimeout()`。我们必须使用`queueMicrotask()`，因为与 Promise 相关的任务被称为所谓的*微观任务*，它们与正常任务不同，并且总是先于它们处理（通过一个*微观任务队列*）。更多信息，请参阅 MDN 文章[“深入：微观任务和 JavaScript 运行时环境”](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth)。

#### 44.2.2 等待拒绝的 Promises

如果其操作数是一个拒绝的 Promise，那么`await`会抛出拒绝值：

```js
try {
  await Promise.reject(
    new Error('Problem!')
  );
  assert.fail(); // we never get here
} catch (err) {
  assert.deepEqual(err, new Error('Problem!'));
}

```

#### 44.2.3 等待非 Promise 值

非 Promise 值也可以被`await`，并且简单地传递：

```js
assert.equal(
  await 'non-Promise value', 'non-Promise value'
);

```

即使在这种情况下，`await`的结果也是异步传递的：

```js
async function awaitNonPromiseValue() {
 queueMicrotask(() => console.log('OTHER TASK'));
 console.log('before');
 await 'non-Promise value';
 console.log('after');
}
await awaitNonPromiseValue();

```

输出：

```js
before
OTHER TASK
after

```

### 44.3 `await`在哪里可以使用？

#### 44.3.1 在模块的最高级别使用`await`^(ES2022)

我们可以在模块的最高级别使用`await`——例如：

```js
let mylib;
try {
  mylib = await import('https://primary.example.com/mylib');
} catch {
  mylib = await import('https://secondary.example.com/mylib');
}

```

关于这个特性的更多信息，请参阅“模块中的顶级`await`^(ES2022)（高级）”（§29.15）。

#### 44.3.2 `await`是浅层的

如果我们在异步函数内部，并想通过`await`暂停它，我们必须直接在该函数内部这样做；我们无法在嵌套函数（如回调）内部使用它。也就是说，暂停是*浅层的*。

让我们来看看这意味着什么。在下面的代码中，我们尝试在嵌套函数内部使用`await`：

```js
async function f() {
 const nestedFunc = () => {
 const result = await Promise.resolve('abc'); // SyntaxError!
 return 'RESULT: ' + result;
 };
 return [ nestedFunc() ];
} 
```

然而，这甚至不是一个有效的语法，因为`await`不允许在同步函数（如`nestedFunc()`）内部使用。如果我们把`nestedFunc()`变成一个异步函数会发生什么？

```js
async function f() {
 const nestedFunc = async () => {
 const result = await Promise.resolve('abc'); // (A)
 return 'RESULT: ' + result;
 };
 return [ nestedFunc() ]; // (B)
}
const arr = await f(); // (C)
assert.equal(
 arr[0] instanceof Promise, true
); 
```

这次，行 A 中的`await`暂停了`nestedFunc()`，而不是`f()`。`nestedFunc()`返回一个 Promise，它在行 B 中被包裹在一个数组中。注意行 C 中的顶级`await`。

要使此代码工作，我们必须等待`nestedFunc()`的结果：

```js
async function f() {
 const nestedFunc = async () => {
 const result = await Promise.resolve('abc');
 return 'RESULT: ' + result;
 };
 return [ await nestedFunc() ];
}
assert.deepEqual(
 await f(), ['RESULT: abc']
); 
```

总结一下：`await`只影响立即周围的函数（该函数必须是异步函数）。

#### 44.3.3 示例：使用异步函数作为回调的`.map()`

如果我们将异步函数用作`.map()`的回调会发生什么？那么结果是一个 Promise 数组：

```js
const arrayOfPromises = arr.map(
  async (x) => { /*···*/ }
);

```

我们可以使用`Promise.all()`将 Promise 数组转换为 Promise 数组，并等待该 Promise：

```js
const array = await Promise.all(
  arr.map(
    async (x) => { /*···*/ }
  )
);

```

我们在以下代码中使用这种技术，该代码通过`fetch()`下载文件。每个文件的内容是其文件名。

```js
const urls = [
  'http://example.com/file1.txt',
  'http://example.com/file2.txt',
];
const uppercaseTexts = await Promise.all( // (A)
  urls.map(async (url) => {
    const response = await fetch(url);
    const text = await response.text();
    return text.toUpperCase();
  })
);
assert.deepEqual(
  uppercaseTexts,
  ['FILE1.TXT', 'FILE2.TXT']
);

```

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：异步映射和过滤**

`exercises/async-functions/map_async_test.mjs`

### 44.4 异步函数中的`return`

#### 44.4.1 异步函数的结果始终是 Promise

如果我们调用一个异步函数，结果总是一个 Promise - 即使异步函数抛出异常。在异步函数内部，我们可以通过返回非 Promise 值（行 A）来履行结果 Promise：

```js
async function asyncFunc() {
 return 123; // (A)
}

asyncFunc()
.then((result) => {
 assert.equal(result, 123);
});

```

通常，如果我们没有明确返回任何内容，则会自动返回 `undefined`：

```js
async function asyncFunc() {}

asyncFunc()
.then((result) => {
 assert.equal(result, undefined);
});

```

我们通过 `throw`（行 A）拒绝结果 Promise：

```js
async function asyncFunc() {
 throw new Error('Problem!'); // (A)
}

asyncFunc()
.catch((err) => {
 assert.deepEqual(err, new Error('Problem!'));
});

```

#### 44.4.2 返回一个 Promise 解决结果 Promise

如果我们返回一个 Promise `q`，那么它将解决异步函数的结果 Promise `p`：`p` 采用 `q` 的状态（`q` 实际上替换了 `p`）。解决永远不会嵌套 Promise。

返回一个已解决的 Promise 会履行结果 Promise：

```js
async function asyncFunc1() {
 return Promise.resolve('fulfilled');
}
const p1 = asyncFunc1();
p1.then(
 result => assert.equal(result, 'fulfilled')
);

```

返回一个拒绝的 Promise 与抛出异常具有相同的效果：

```js
async function asyncFunc2() {
 return Promise.reject('rejected');
}
const p2 = asyncFunc2();
p2.catch(
 error => assert.equal(error, 'rejected')
);

```

`return` 的行为与以下情况中如何处理 Promise `q` 类似：

+   `return q` 在 `promise.then((result) => { ··· })` 内部

+   `return q` 在 `promise.catch((err) => { ··· })` 内部

+   `resolve(q)` 在 `new Promise((resolve, reject) => { ··· })` 内部

### 44.5 异步函数同步启动，异步解决

异步函数的执行如下：

+   当异步函数开始时，会创建结果 Promise `resultPromise`。

+   然后执行主体。执行可以离开主体的两种方式：

    +   当 `resultPromise` 解决时，会发生**永久退出**：

        +   `return` 解决 `resultPromise`。

        +   `throw` 拒绝 `resultPromise`。

    +   当存在一个操作数为 Promise `p` 的 `await` 时，会发生**临时退出**：

        +   异步函数暂停，执行离开它（类似于 同步生成器 中的 `yield` 的工作方式）。

        +   一旦 `p` 解决，它就会异步地（在一个新任务中）恢复。

+   在第一次（永久或临时）退出后返回 Promise `resultPromise`。

注意，`resultPromise` 解决的通知是异步发生的，这与 Promise 总是如此的情况一样。

以下代码演示了异步函数是同步启动的（行 A），然后当前任务完成（行 C），然后结果 Promise 解决 - 异步（行 B）。

```js
async function asyncFunc() {
 console.log('asyncFunc() starts'); // (A)
 return 'abc';
}
asyncFunc().
then((x) => { // (B)
 console.log(`Resolved: ${x}`);
});
console.log('Task ends'); // (C)

```

输出：

```js
asyncFunc() starts
Task ends
Resolved: abc

```

### 44.6 使用异步函数的技巧

#### 44.6.1 如果我们“发射并忘记”，则不需要 `await`

在使用基于 Promise 的函数时，不需要 `await`；我们只需要它来暂停并等待返回的 Promise 解决。如果我们只想启动一个异步操作，那么我们不需要它：

```js
async function asyncFunc() {
 const writer = openFile('someFile.txt');
 writer.write('hello'); // don’t wait
 writer.write('world'); // don’t wait
 await writer.close(); // wait for file to close
}

```

在此代码中，我们没有等待 `.write()`，因为我们不关心它何时完成。然而，我们确实想要等待 `.close()` 完成。

注意：每次调用 `.write()` 都是同步开始的。这防止了竞争条件。

#### 44.6.2 它可以在 `await` 和忽略结果时有意义

有时使用 `await` 是有意义的，即使我们忽略了它的结果 – 例如：

```js
await longRunningAsyncOperation();
console.log('Done!');

```

在这里，我们使用 `await` 来连接一个长时间运行的异步操作。这确保了日志确实是在该操作完成后发生的。

#### 44.6.3 `return await` 的优缺点

如果我们在返回之前等待一个 Promise，我们会在立即重新包装之前先解包它：

```js
async function f() {
 return await Promise.resolve('result');
}

```

由于 `return` 解决了 `f()` 的结果 Promise，以下代码更简单且等效：

```js
async function f() {
 return Promise.resolve('result');
}

```

然而，有三个原因让我们坚持使用 `return await`：

+   代码片段更容易移动。

+   我们不依赖于 Promise 的一个稍微晦涩的功能：解析解包 Promise。

+   它在 `try-catch` 语句（见下文）中表现更好。

让我们探索最后一个原因。如果我们在线 A 等待被拒绝的 Promise 返回之前，它会导致异常：

```js
async function f() {
 try {
 return await Promise.reject('error'); // (A)
 } catch (err) {
 return 'Caught an error: ' + err;
 }
}
f().then((result) => {
 assert.equal(result, 'Caught an error: error');
});

```

相反地，如果我们不使用 `await` 返回，则不会抛出异常，并且 `f()` 的结果 Promise 会采用被拒绝的 Promise 的状态：

```js
async function f() {
 try {
 return Promise.reject('error');
 } catch (err) {
 return 'Caught an error: ' + err;
 }
}
f().catch((reason) => {
 assert.equal(reason, 'error');
});

```

### 44.7 并发和 `await`（高级）

在接下来的两个小节中，我们将使用辅助函数 `returnAfterPause()`：

```js
async function returnAfterPause(id) {
  console.log('START ' + id);
  await delay(10); // pause
  console.log('END ' + id);
  return id;
}

/**
 * Resolves after `ms` milliseconds
 */
function delay(ms) {
  return new Promise((resolve, _reject) => {
    setTimeout(resolve, ms);
  });
}

```

#### 44.7.1 `await`：按顺序运行基于 Promise 的函数

如果我们在多个基于 Promise 的函数调用前加上 `await`，那么这些函数将按顺序执行：

```js
async function sequentialAwait() {
 const result1 = await returnAfterPause('first');
 assert.equal(result1, 'first');

 const result2 = await returnAfterPause('second');
 assert.equal(result2, 'second');
}

```

输出结果：

```js
START first
END first
START second
END second

```

即，`returnAfterPause('second')` 仅在 `returnAfterPause('first')` 完全完成后才开始。

#### 44.7.2 `await`：并发运行基于 Promise 的函数

如果我们想要并发运行多个基于 Promise 的函数，我们可以使用实用方法 `Promise.all()`：

```js
async function concurrentPromiseAll() {
 const result = await Promise.all([
 returnAfterPause('first'),
 returnAfterPause('second'),
 ]);
 assert.deepEqual(result, ['first', 'second']);
}

```

输出结果：

```js
START first
START second
END first
END second

```

在这里，两个异步函数同时启动。一旦两者都确定，`await` 会给我们一个满足值的数组，或者 – 如果至少有一个 Promise 被拒绝 – 一个异常。

回想一下 之前，重要的是我们何时启动基于 Promise 的计算；而不是我们如何处理其结果。因此，以下代码与之前的代码一样“并发”：

```js
async function concurrentAwait() {
 const resultPromise1 = returnAfterPause('first');
 const resultPromise2 = returnAfterPause('second');

 assert.equal(await resultPromise1, 'first');
 assert.equal(await resultPromise2, 'second');
}

```

输出结果：

```js
START first
START second
END first
END second

```
