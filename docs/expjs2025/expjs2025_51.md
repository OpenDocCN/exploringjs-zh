# 43 异步编程的 Promises ES6

> 原文：[`exploringjs.com/js/book/ch_promises.html`](https://exploringjs.com/js/book/ch_promises.html)

1.  43.1 使用 Promises 的基础

    1.  43.1.1 使用基于 Promise 的函数

    1.  43.1.2 Promises 与事件

    1.  43.1.3 实现基于 Promise 的函数

    1.  43.1.4 Promise 的三个基本状态

    1.  43.1.5 通过 `Promise.resolve()` 和 `Promise.reject()` 创建已解决和拒绝的 Promises

    1.  43.1.6 在 `.then()` 回调中返回和抛出

    1.  43.1.7 `.catch()` 及其回调

    1.  43.1.8 链式方法调用

    1.  43.1.9 `Promise.try()`: 开始一个 Promise 链^(ES2025)

    1.  43.1.10 `Promise.prototype.finally()`^(ES2018)

    1.  43.1.11 `Promise.withResolvers()`^(ES2024)

    1.  43.1.12 Promise 相对于普通回调的优势

1.  43.2 示例

    1.  43.2.1 Node.js: 异步读取文件

    1.  43.2.2 浏览器：将 `XMLHttpRequest` 转换为 Promise

    1.  43.2.3 Fetch API

1.  43.3 错误处理的技巧：不要混合拒绝和异常

1.  43.4 基于 Promise 的函数同步开始，异步解决

1.  43.5 Promise 组合函数：处理 Promise 数组

    1.  43.5.1 什么是 Promise 组合函数？

    1.  43.5.2 `Promise.all()`

    1.  43.5.3 `Promise.race()`

    1.  43.5.4 `Promise.any()`^(ES2021)

    1.  43.5.5 `Promise.allSettled()`^(ES2020)

    1.  43.5.6 短路 (高级)

1.  43.6 并发和 `Promise.all()` (高级)

    1.  43.6.1 顺序执行与并发执行

    1.  43.6.2 并发技巧：关注操作何时开始

    1.  43.6.3 `Promise.all()` 是分叉-连接

1.  43.7 链式 Promises 的技巧

    1.  43.7.1 链式错误：丢失尾部

    1.  43.7.2 链式错误：嵌套

    1.  43.7.3 链式错误：不必要的嵌套过多

    1.  43.7.4 并非所有嵌套都是不好的

    1.  43.7.5 链式错误：创建 Promise 而不是链式调用

1.  43.8 Thenables (类似 Promise 的对象) (高级)

    1.  43.8.1 示例：已解决的 thenable

    1.  43.8.2 示例：被拒绝的 thenable

1.  43.9 快速参考：`Promise`

    1.  43.9.1 `new Promise()`

    1.  43.9.2 `Promise.*`：创建 Promises

    1.  43.9.3 `Promise.*`：其他功能

    1.  43.9.4 `Promise.*`：Promise 组合器

    1.  43.9.5 `Promise.prototype.*`

![图标“阅读”](img/0fb62b2fc33a72829ae9fb174dedd0d2.png) **推荐阅读**

本章基于上一章的内容，介绍了 JavaScript 中的异步编程背景。

### 43.1 使用 Promise 的基本知识

#### 43.1.1 使用基于 Promise 的函数

Promises 是一种异步交付结果的技术。而不是直接返回一个结果，基于 Promise 的函数返回一个*Promise*：一个最初为空的容器对象。如果函数最终完成，它会将结果或错误放入 Promise 中。

以下代码展示了如何使用基于 Promise 的函数`addAsync()`。我们很快就会看到该函数的实现方式。

```js
const promise = addAsync(3, 4);
promise.then((result) => { // success
    assert.equal(result, 7);
  })
  .catch((error) => { // failure
    assert.fail(error);
  })
;

```

要访问 Promise 内部的内容（如果内部有内容的话），我们注册回调函数：

+   `.then()`方法注册了当有结果（如果有）时被调用的回调函数。

+   `.catch()`方法注册了当有错误（如果有）时被调用的回调函数。

Promises 的这个方面与事件模式类似。

#### 43.1.2 Promise 与事件

Promises 与事件在两个方面有所不同：

+   它们最多交付一个结果，并且针对该用例进行了优化：

    +   如果我们在 Promise 为空时注册`.then()`回调，当 Promise 收到结果时会通知我们。如果我们在 Promise 为空时注册`.catch()`回调，当 Promise 收到错误时会通知我们。

    +   一旦 Promise 收到结果或错误，该值就会被缓存。因此，如果我们在此之后注册回调，它会获取缓存的值（取决于它是否有资格接收它）。这意味着注册回调太晚的风险不存在。

    +   Promise 接收到的第一个值永久性地*解决*该 Promise：之后接收到的值将被忽略。

+   我们可以链式调用 Promise 方法`.then()`和`.catch()`，因为它们都返回 Promises。这有助于顺序调用多个异步函数。关于这一点，稍后还会详细介绍。

#### 43.1.3 实现基于 Promise 的函数

这是一个基于 Promise 的函数实现，用于添加两个数字`x`和`y`：

```js
function addAsync(x, y) {
  return new Promise( // (A)
    (resolve, reject) => { // (B)
      if (x === undefined || y === undefined) {
        reject(new Error('Must provide two parameters'));
      } else {
        resolve(x + y);
      }
    }
  );
}

```

`addAsync()`通过调用`Promise`构造函数立即创建并返回一个 Promise（行 A）。它只能通过将其传递给构造函数的回调（行 B）来改变新 Promise 的状态：

+   回调参数`resolve`是一个函数，它将结果放入 Promise 中（在成功的情况下）。

+   回调参数`reject`是一个函数，它将错误放入 Promise 中（在失败的情况下）。

一旦我们调用了这些函数，后续的调用就没有任何效果了。

##### 43.1.3.1 揭示构造函数模式（高级）

Promise 构造函数使用*揭示构造函数模式*：

```js
const promise = new Promise(
  (resolve, reject) => {
    // ···
  }
);

```

引用 Domenic Denicola（JavaScript 的 Promise API 背后的其中一人）的话：

> 我称之为*揭示构造函数模式*，因为`Promise`构造函数揭示了其内部能力，但仅限于构建相关 Promise 的代码。解析或拒绝 Promise 的能力仅对构建代码可见，并且关键的是*不*对任何使用 Promise 的人可见。所以如果我们把`p`传递给另一个消费者，比如说
> 
> ```js
> doThingsWith(p);
> 
> ```
> 
> 那么，我们可以确信这个消费者无法干扰构造函数向我们揭示的任何内部机制。这与，例如，在`p`上放置`resolve`和`reject`方法形成对比，任何人都可以调用这些方法。

#### 43.1.4 Promise 的三个基本状态

图 43.1 描述了 Promise 可能处于的三个状态。

![](img/06c68bd8e345f2ccc6d4e27fffb6f694.png)

图 43.1：Promise 最初处于“挂起”状态。它后来可以转换到“已履行”或“已拒绝”状态（但它可能永远不会这样做）。如果一个 Promise 处于最终（非挂起）状态，它被称为*已解决*。

##### 43.1.4.1 一些 Promise 永远不会解决

这是一个永远不会解决且永远挂起的 Promise 的例子：

```js
new Promise(() => {})

```

##### 43.1.4.2 解析 Promise 和履行 Promise 之间的区别是什么？

一个 Promise 只能用非 Promise 值来履行。相比之下，我们可以用非 Promise 值或另一个 Promise 来解析一个 Promise。如果`new Promise()`的回调调用`resolve(x)`，那么新创建的 Promise `p`的结果取决于`x`：

+   如果`x`是一个非 Promise 值，那么`p`会以`x`来履行。

+   如果`x`是一个 Promise，那么`p`会采用`x`的状态（这基本上意味着`x`会替换`p`）。换句话说：

    +   当`x`处于挂起状态时，`p`也处于挂起状态。

    +   如果`x`被履行，`p`也会被履行。

    +   如果`x`被拒绝，`p`也会被拒绝。

换句话说：解析只决定了 Promise 的命运；它可能履行也可能不履行。这种行为有助于 Promise 方法的链式调用。关于这一点，稍后还会详细介绍。

#### 43.1.5 通过`Promise.resolve()`和`Promise.reject()`创建满足和拒绝的 Promise

如果`x`是一个非 Promise 值，则`Promise.resolve(x)`创建一个以该值满足的 Promise：

```js
Promise.resolve(123)
  .then((x) => {
    assert.equal(x, 123);
  });

```

如果参数已经是 Promise，则返回不变：

```js
const abcPromise = Promise.resolve('abc');
assert.equal(
  Promise.resolve(abcPromise), abcPromise
);

```

`Promise.reject(err)`接受一个值`err`（通常不是 Promise）并返回一个以它拒绝的 Promise：

```js
const myError = new Error('My error!');
Promise.reject(myError)
  .catch((err) => {
    assert.equal(err, myError);
  });

```

这有什么用？

+   一方面，我们可以使用`Promise.resolve()`将可能或可能不是 Promise 的值转换为保证是 Promise 的值。

+   另一方面，我们可能想要创建一个以给定非 Promise 值来满足或拒绝的 Promise。然后我们可以使用`Promise.resolve()`和`Promise.reject()` – 如以下示例所示。

```js
function convertToNumber(stringOrNumber) {
  if (typeof stringOrNumber === 'number') {
    return Promise.resolve(stringOrNumber);
  } else if (typeof stringOrNumber === 'string') {
    return stringToNumberAsync(stringOrNumber);
  } else {
    return Promise.reject(new TypeError());
  }
}

```

#### 43.1.6 `.then()`回调中的返回和抛出

`.then()`为 Promise 满足注册回调函数。它还返回一个新的 Promise。这样做使得方法链式调用成为可能：我们可以在结果上调用`.then()`和`.catch()`，并保持异步计算的进行。

`.then()`返回的 Promise 是如何解决的，取决于其回调函数内部发生的事情。让我们看看三个常见的情况。

##### 43.1.6.1 从`.then()`回调返回非 Promise 值

首先，回调函数可以返回一个非 Promise 值（行 A）。因此，`.then()`返回的 Promise 以该值满足（如行 B 中检查的那样）：

```js
Promise.resolve('abc')
  .then((str) => {
    return str + str; // (A)
  })
  .then((str2) => {
    assert.equal(str2, 'abcabc'); // (B)
  });

```

##### 43.1.6.2 `.then()`回调返回 Promise

其次，回调函数可以返回一个 Promise `q`（行 A）。因此，`.then()`返回的 Promise `p`以`q`来满足。换句话说：`p`实际上被`q`替换了。

```js
Promise.resolve('abc')
  .then((str) => {
    return Promise.resolve(123); // (A)
  })
  .then((num) => {
    assert.equal(num, 123);
  });

```

这有什么用？我们可以返回基于 Promise 的操作的结果，并通过一个“扁平”（非嵌套）的`.then()`来处理其满足值。比较：

```js
// Flat
asyncFunc1()
  .then((result1) => {
    /*···*/
    return asyncFunc2();
  })
  .then((result2) => {
    /*···*/
  });

// Nested
asyncFunc1()
  .then((result1) => {
    /*···*/
    asyncFunc2()
    .then((result2) => {
      /*···*/
    });
  });

```

##### 43.1.6.3 `.then()`回调中抛出异常

第三，回调函数可以抛出异常。因此，`.then()`返回的 Promise 以该异常拒绝。也就是说，同步错误被转换为异步错误。

```js
const myError = new Error('My error!');
Promise.resolve('abc')
  .then((str) => {
    throw myError;
  })
  .catch((err) => {
    assert.equal(err, myError);
  });

```

#### 43.1.7 `.catch()`及其回调

`.then()`和`.catch()`之间的区别在于，后者是由拒绝触发的，而不是由满足触发的。然而，两种方法都以相同的方式将回调函数的动作转换为 Promise。例如，在以下代码中，行 A 中`.catch()`回调函数返回的值成为满足值：

```js
const err = new Error();

Promise.reject(err)
  .catch((e) => {
    assert.equal(e, err);
    // Something went wrong, use a default value
    return 'default value'; // (A)
  })
  .then((str) => {
    assert.equal(str, 'default value');
  });

```

#### 43.1.8 链式调用方法

`.then()`和`.catch()`总是返回 Promise，使我们能够创建任意长的方法调用链：

```js
function myAsyncFunc() {
 return asyncFunc1() // (A)
 .then((result1) => {
 // ···
 return asyncFunc2(); // a Promise
 })
 .then((result2) => {
 // ···
 return result2 ?? '(Empty)'; // not a Promise
 })
 .then((result3) => {
 // ···
 return asyncFunc4(); // a Promise
 });
}

```

由于链式调用，行 A 中的`return`返回了最后一个`.then()`的结果。

在某种程度上，`.then()`是同步分号异步版本：

+   `asyncFunc1().then(asyncFunc2)`

    依次执行异步操作`asyncFunc1`和`asyncFunc2`。

+   `syncFunc1(); syncFunc2()`

    依次执行同步操作`syncFunc1`和`syncFunc2`。

我们还可以添加`.catch()`到混合中，并让它同时处理多个错误源：

```js
asyncFunc1()
  .then((result1) => {
    // ···
    return asyncFunc2();
  })
  .then((result2) => {
    // ···
  })
  .catch((error) => {
    // Failure: handle errors of asyncFunc1(), asyncFunc2()
    // and any (sync) exceptions thrown in previous callbacks
  });

```

#### 43.1.9 `Promise.try()`：启动 Promise 链（ES2025）

当 Promise 方法`.then(cb)`继续 Promise 链时，`Promise.try(cb)`开始一个 Promise 链——同时以类似的方式处理回调`cb`：

+   它调用`cb`。

+   如果`cb`抛出异常，`Promise.try()`会返回一个带有该异常的拒绝。

+   如果`cb`返回一个值，`Promise.try()`将那个值解析为一个 Promise（如果没有嵌套，该值已经是 Promise）。

##### 43.1.9.1 `Promise.try()`的使用场景：使用非纯异步代码启动 Promise 链

我们需要`Promise.try()`来启动一个包含同步和异步功能的代码的 Promise 链：

+   为什么是混合的？如果代码完全是异步的，我们可以用它来启动一个 Promise 链。如果代码完全是同步的，则不需要 Promise。

+   为什么在开始时？在 Promise 链的后期，Promise 函数如`.then()`是处理混合代码的好工具。

让我们看看一个例子：

```js
function computeAsync() {
 return Promise.try(() => {
 const value = syncFuncMightThrow(); // (A)
 return asyncFunc(value); // (B)
 });
}

```

我们有一个同步功能（行 A）和异步功能（行 B）的混合。

为什么要在回调中包裹代码呢？如果我们在行 A 中调用的同步函数抛出异常，这会有帮助：然后`Promise.try()`捕获那个异常并将其转换为为我们提供的拒绝的 Promise。因此，前面的代码基本上等同于：

```js
function computeAsync() {
 try {
 const value = syncFuncMightThrow();
 return asyncFunc(value);
 } catch (err) {
 return Promise.reject(err);
 }
}

```

##### 43.1.9.2 为什么不使用异步函数？

只有当我们直接与 Promise 一起工作时，`Promise.try()`才是必需的。异步函数（在下一章中解释异步函数）已经提供了很好的支持来处理同步和异步代码的混合（任何地方）。

##### 43.1.9.3 `Promise.try()`的替代方案

以下代码是`Promise.try()`的替代方案：

```js
function countPlusOneAsync() {
 return Promise.resolve().then(
 () => countSyncOrAsync() // (A)
 )
 .then((result) => {
 return result + 1;
 });
}

```

`Promise.resolve()`创建一个被`undefined`实现的 Promise。这个结果对我们来说并不重要。重要的是我们刚刚启动了一个 Promise 链，并且可以将要尝试的代码放入行 A 的回调中。

与`Promise.try()`相比，主要缺点是这种模式将在下一个 tick 上执行代码行 A（而不是立即执行）。

#### 43.1.10 `Promise.prototype.finally()`（ES2018）

Promise 方法`.finally()`通常如下使用：

```js
somePromise
  .then((result) => {
    // ···
  })
  .catch((error) => {
    // ···
  })
  .finally(() => {
    // ···
  })
;

```

`.finally()`回调始终执行——独立于`somePromise`和`.then()`和/或`.catch()`返回的值。相比之下：

+   只有当`somePromise`被实现时，`.then()`回调才会执行。

+   只有在以下情况下，`.catch()`回调才会执行：

    +   要么`somePromise`被拒绝，

    +   或者 `.then()` 回调返回一个被拒绝的 Promise，

    +   或者 `.then()` 回调抛出异常。

如果回调返回一个非 Promise 值或一个已解决的 Promise，`.finally()` 将忽略该结果，并简单地传递在调用之前存在的结算：

```js
Promise.resolve(123)
  .finally(() => {})
  .then((result) => {
    assert.equal(result, 123);
  });

Promise.reject('error')
  .finally(() => {})
  .catch((error) => {
    assert.equal(error, 'error');
  });

```

然而，如果 `.finally()` 回调抛出异常或返回一个被拒绝的 Promise，则 `.finally()` 返回的 Promise 将被拒绝：

```js
Promise.reject('error (previously)')
  .finally(() => {
    throw 'error (finally)';
  })
  .catch((error) => {
    assert.equal(error, 'error (finally)');
  });

Promise.reject('error (previously)')
  .finally(() => {
    return Promise.reject('error (finally)');
  })
  .catch((error) => {
    assert.equal(error, 'error (finally)');
  });

```

##### 43.1.10.1 `.finally()` 的用例：清理

`.finally()` 的一个常见用例类似于同步 `finally` 子句的常见用例：在完成资源使用后进行清理。这应该始终发生，无论一切是否顺利或出现错误 – 例如：

```js
let connection;
db.open()
.then((conn) => {
  connection = conn;
  return connection.select({ name: 'Jane' });
})
.then((result) => {
  // Process result
  // Use `connection` to make more queries
})
// ···
.catch((error) => {
  // handle errors
})
.finally(() => {
  connection.close();
});

```

##### 43.1.10.2 `.finally()` 的用例：在任何类型的结算之后首先执行某些操作

我们也可以在 `.then()` 和 `.catch()` 之前使用 `.finally()`。那么在 `.finally()` 回调中执行的操作总是先于其他两个回调执行。以下是一个示例函数 `handleAsyncResult()`：

```js
function handleAsyncResult(promise) {
  return promise
    .finally(() => {
      console.log('finally');
    })
    .then((result) => {
      console.log('then ' + result);
    })
    .catch((error) => {
      console.log('catch ' + error);
    })
  ;
}

```

这就是已解决的 Promise 发生的情况：

```js
handleAsyncResult(Promise.resolve('fulfilled'));

```

输出：

```js
finally
then fulfilled

```

这就是被拒绝的 Promise 发生的情况：

```js
handleAsyncResult(Promise.reject('rejected'));

```

输出：

```js
finally
catch rejected

```

#### 43.1.11 `Promise.withResolvers()` (ES2024)

创建和解析 Promise 最常见的方式是通过 `Promise` 构造函数：

```js
new Promise(
  (resolve, reject) => { ··· }
);

```

创建像那样的 Promise 的一个限制是，解决函数 `resolve` 和 `reject` 只意味着在回调内部使用。有时我们想在它之外使用它们。这就是以下静态工厂方法有用的原因：

```js
const { promise, resolve, reject } = Promise.withResolvers();

```

这就是使用那个工厂方法的样子：

```js
{
  const { promise, resolve, reject } = Promise.withResolvers();
  resolve('fulfilled');
  assert.equal(
    await promise,
    'fulfilled'
  );
}
{
  const { promise, resolve, reject } = Promise.withResolvers();
  reject('rejected');
  try {
    await promise;
  } catch (err) {
    assert.equal(err, 'rejected');
  }
}

```

![图标“问题”](img/3decb3ca67c240d2bb04742c1f28af18.png) **为什么叫 `withResolvers`？为什么不叫，例如，`withSettlers`？**

+   `resolve()` 可能不会解决 `promise` – 它只解决它。

+   ECMAScript 规范使用 [“解析函数”的名称](https://tc39.es/ecma262/#sec-createresolvingfunctions) 来表示 `resolve` 和 `reject`。

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：通过链表实现一个由 Promise 组成的异步队列，其元素是 Promise**

`exercises/promises/promise-queue_test.mjs`

##### 43.1.11.1 实现

我们可以如下实现 `Promise.withResolvers()`：

```js
function promiseWithResolvers() {
 let resolve;
 let reject;
 const promise = new Promise(
 (res, rej) => {
 // Executed synchronously!
 resolve = res;
 reject = rej;
 });
 return {promise, resolve, reject};
}

```

##### 43.1.11.2 示例：单元素队列

```js
class OneElementQueue {
  #promise = null;
  #resolve = null;
  constructor() {
 const { promise, resolve } = Promise.withResolvers();
 this.#promise = promise;
 this.#resolve = resolve;
 }
 get() {
 return this.#promise;
 }
 put(value) {
 this.#resolve(value);
 }
}

{ // Putting before getting
 const queue = new OneElementQueue();
 queue.put('one');
 assert.equal(
 await queue.get(),
 'one'
 );
}
{ // Getting before putting
 const queue = new OneElementQueue();
 setTimeout(
 // Runs after `await` pauses the current execution context
 () => queue.put('two'),
 0
 );
 assert.equal(
 await queue.get(),
 'two'
 );
} 
```

#### 43.1.12 Promise 相对于普通回调的优点

这些是处理一次性结果时，Promise 相对于普通回调的一些优点：

+   基于 Promise 的函数和方法的类型签名更简洁：如果函数是基于回调的，一些参数是关于输入的，而最后的那个或两个回调是关于输出的。使用 Promises，所有与输出相关的操作都通过返回值处理。

+   连接异步处理步骤更加方便。

+   Promise 处理异步错误（通过拒绝）和同步错误：在 `new Promise()`、`.then()` 和 `.catch()` 的回调中，异常被转换为拒绝。相比之下，如果我们使用回调来处理异步性，通常不会为我们处理异常；我们必须自己处理。

+   Promise 是一个单一的标准，它正在逐渐取代几个相互不兼容的替代方案。例如，在 Node.js 中，现在许多函数都有基于 Promise 的版本。而新的异步浏览器 API 通常也是基于 Promise 的。

Promise 最大的优点之一是无需直接操作它们：它们是 *async 函数* 的基础，这是一种用于执行异步计算的同步外观语法。异步函数将在 下一章 中介绍。

### 43.2 示例

通过观察 Promise 的实际应用来理解它们很有帮助。让我们看看一些例子。

#### 43.2.1 Node.js: 异步读取文件

考虑以下包含 JSON 数据 的文本文件 `person.json`：

```js
{
  "first": "Jane",
  "last": "Doe"
}

```

让我们看看两种读取此文件并将其解析为对象的代码版本。首先是一个基于回调的版本。其次是一个基于 Promise 的版本。

##### 43.2.1.1 基于回调的版本

以下代码读取该文件的内容并将其转换为 JavaScript 对象。它基于 Node.js 风格的回调：

```js
import * as fs from 'node:fs';
fs.readFile('person.json',
  (error, text) => {
    if (error) { // (A)
      // Failure
      assert.fail(error);
    } else {
      // Success
      try { // (B)
        const obj = JSON.parse(text); // (C)
        assert.deepEqual(obj, {
          first: 'Jane',
          last: 'Doe',
        });
      } catch (e) {
        // Invalid JSON
        assert.fail(e);
      }
    }
  });

```

`fs` 是 Node.js 用于文件系统操作的内置模块。我们使用基于回调的函数 `fs.readFile()` 来读取名为 `person.json` 的文件。如果我们成功，内容将通过参数 `text` 作为字符串传递。在行 C 中，我们将该字符串从基于文本的数据格式 JSON 转换为 JavaScript 对象。`JSON` 是一个具有消费和生成 JSON 方法的对象。它是 JavaScript 标准库的一部分，并在本书的 后续章节 中有文档说明。

注意，有两种错误处理机制：行 A 中的 `if` 负责处理由 `fs.readFile()` 报告的异步错误，而行 B 中的 `try` 负责处理由 `JSON.parse()` 报告的同步错误。

##### 43.2.1.2 基于 Promise 的版本

以下代码使用 `node:fs/promises` 中的 `readFile()`，这是 `fs.readFile()` 的基于 Promise 的版本：

```js
import {readFile} from 'node:fs/promises';
readFile('person.json')
  .then((text) => { // (A)
    // Success
    const obj = JSON.parse(text);
    assert.deepEqual(obj, {
      first: 'Jane',
      last: 'Doe',
    });
  })
  .catch((err) => { // (B)
    // Failure: file I/O error or JSON syntax error
    assert.fail(err);
  });

```

函数 `readFile()` 返回一个 Promise。在行 A 中，我们通过该 Promise 的 `.then()` 方法指定一个成功回调。`then` 的回调函数中的剩余代码是同步的。

`.then()` 返回一个 Promise，这使得在行 B 中可以调用 Promise 方法 `.catch()`。我们用它来指定一个失败回调。

注意，`.catch()` 允许我们处理 `readFile()` 的异步错误和 `JSON.parse()` 的同步错误，因为 `.then()` 回调中的异常成为拒绝。

#### 43.2.2 Browsers: 将 `XMLHttpRequest` 转换为 Promise

我们之前已经看到了在网页浏览器中下载数据的基于事件的 `XMLHttpRequest` API。以下函数将这个 API 转换为 Promise：

```js
function httpGet(url) {
  return new Promise(
    (resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.onload = () => {
        if (xhr.status === 200) {
          resolve(xhr.responseText); // (A)
        } else {
          // Something went wrong (404, etc.)
          reject(new Error(xhr.statusText)); // (B)
        }
      }
      xhr.onerror = () => {
        reject(new Error('Network error')); // (C)
      };
      xhr.open('GET', url);
      xhr.send();
    });
}

```

注意 `XMLHttpRequest` 的结果和错误是如何通过 `resolve()` 和 `reject()` 处理的：

+   成功的结果会导致返回的 Promise 被它本身（行 A）满足。

+   错误会导致 Promise 被拒绝（行 B 和 C）。

这是使用 `httpGet()` 的方法：

```js
httpGet('http://example.com/textfile.txt')
  .then((content) => {
    assert.equal(content, 'Content of textfile.txt\n');
  })
  .catch((error) => {
    assert.fail(error);
  });

```

![Icon “exercise”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：Promise 超时**

`exercises/promises/promise_timeout_test.mjs`

#### 43.2.3 Fetch API

大多数 JavaScript 平台支持 Fetch，这是一个基于 Promise 的 API，用于下载数据。将其视为 `XMLHttpRequest` 的基于 Promise 的版本。以下是该 API 的摘录[API](https://fetch.spec.whatwg.org/#fetch-api)：

```js
interface Body {
  text() : Promise<string>;
  ···
}
interface Response extends Body {
  ···
}
declare function fetch(str) : Promise<Response>;

```

这意味着我们可以这样使用 `fetch()`：

```js
fetch('http://example.com/textfile.txt')
  .then(response => response.text())
  .then((text) => {
    assert.equal(text, 'Content of textfile.txt');
  });

```

`fetch()` 也在这里使用：“示例：`.map()` 与异步函数作为回调” (§44.3.3)。

![Icon “exercise”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：使用 fetch API**

`exercises/promises/fetch_json_test.mjs`

### 43.3 错误处理的技巧：不要混合拒绝和异常

实现函数和方法的技巧：

> 不要混合（异步）拒绝和（同步）异常。

这使得我们的同步和异步代码更加可预测和简单，因为我们总能专注于单一的错误处理机制。

对于基于 Promise 的函数和方法，这个规则意味着它们永远不应该抛出异常。然而，很容易不小心出错——例如：

```js
// Don’t do this
function asyncFunc() {
 doSomethingSync(); // (A)
 return doSomethingAsync()
 .then((result) => {
 // ···
 });
}

```

问题在于，如果行 A 中抛出异常，那么 `asyncFunc()` 将抛出异常。该函数的调用者只期望拒绝，并没有准备好处理异常。我们可以通过三种方式来解决这个问题。

我们可以在函数的整个主体中包裹一个 `try-catch` 语句，并在抛出异常时返回一个拒绝的 Promise。

```js
// Solution 1
function asyncFunc() {
 try {
 doSomethingSync();
 return doSomethingAsync()
 .then((result) => {
 // ···
 });
 } catch (err) {
 return Promise.reject(err);
 }
}

```

由于 `.then()` 将异常转换为拒绝，我们可以在 `.then()` 回调中执行 `doSomethingSync()`。为此，我们通过 `Promise.resolve()` 启动一个 Promise 链。我们忽略那个初始 Promise 的满足值 `undefined`。

```js
// Solution 2
function asyncFunc() {
 return Promise.resolve()
 .then(() => {
 doSomethingSync();
 return doSomethingAsync();
 })
 .then((result) => {
 // ···
 });
}

```

最后，`new Promise()` 也会将异常转换为拒绝。因此，使用这个构造函数与之前的解决方案类似：

```js
// Solution 3
function asyncFunc() {
 return new Promise((resolve, reject) => {
 doSomethingSync();
 resolve(doSomethingAsync());
 })
 .then((result) => {
 // ···
 });
}

```

### 43.4 基于 Promise 的函数开始同步，解决异步

大多数基于 Promise 的函数都是这样执行的：

+   它们的执行立即开始，同步（在当前任务中）。

+   但它们返回的 Promise 保证会在异步（稍后的任务）中解决——如果有的话。

以下代码演示了这一点：

```js
function asyncFunc() {
 console.log('asyncFunc');
 return new Promise(
 (resolve, _reject) => {
 console.log('new Promise()');
 resolve();
 }
 );
}
console.log('START');
asyncFunc()
 .then(() => {
 console.log('.then()'); // (A)
 });
console.log('END');

```

输出：

```js
START
asyncFunc
new Promise()
END
.then()

```

我们可以看到，`new Promise()` 的回调在代码结束之前执行，而结果稍后才会传递（行 A）。

此方法的好处：

+   从同步开始有助于避免竞争条件，因为我们依赖于基于 Promise 的函数开始时的顺序。在下一章中有一个例子在这里，其中文本被写入文件，并避免了竞争条件。

+   在一个 Promise 解决之前，链式调用 Promise 不会使其他任务处理时间不足，因为在 Promise 解决之前，总会有一个中断，在这段时间内事件循环可以运行。

+   基于 Promise 的函数总是异步返回结果；我们可以确信永远不会同步返回。这种可预测性使得代码更容易处理。

![图标“外部”](img/38e6ff55e8d602659f3cdb8893e63f62.png) **关于此方法的更多信息**

[“为异步设计 API”](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony) by Isaac Z. Schlueter

### 43.5 Promise 组合函数：处理 Promise 数组

#### 43.5.1 Promise 组合函数是什么？

[*组合模式*](https://wiki.haskell.org/Combinator_pattern)是函数式编程中用于构建结构的模式。它基于两种类型的函数：

+   *原始函数*（简称：*原始*）创建原子部分。

+   *组合函数*（简称：*组合器*）将原子和/或复合部分组合成复合部分。

当涉及到 JavaScript 的 Promise 时：

+   原始函数包括：`Promise.resolve()`、`Promise.reject()`

+   组合器包括：`Promise.all()`、`Promise.race()`、`Promise.any()`、`Promise.allSettled()`。在这些情况下：

    +   输入是零个或多个 Promise 的可迭代对象。

    +   输出是一个单独的 Promise。

接下来，我们将更详细地研究提到的 Promise 组合器。

#### 43.5.2 `Promise.all()`

这是`Promise.all()`的类型签名：

```js
Promise.all<T>(promises: Iterable<Promise<T>>): Promise<Array<T>>

```

`Promise.all()`返回一个 Promise，它是：

+   如果所有`promises`都得到履行，则满足条件。

    +   然后，其履行值是一个包含`promises`履行值的数组。

+   如果至少有一个 Promise 被拒绝，则拒绝。

    +   然后，其拒绝值是那个 Promise 的拒绝值。

这是一个输出 Promise 被履行的快速演示：

```js
const promises = [
  Promise.resolve('result a'),
  Promise.resolve('result b'),
  Promise.resolve('result c'),
];
Promise.all(promises)
  .then((arr) => assert.deepEqual(
    arr, ['result a', 'result b', 'result c']
  ));

```

以下示例演示了如果至少有一个输入 Promise 被拒绝会发生什么：

```js
const promises = [
  Promise.resolve('result a'),
  Promise.resolve('result b'),
  Promise.reject('ERROR'),
];
Promise.all(promises)
  .catch((err) => assert.equal(
    err, 'ERROR'
  ));

```

图 43.2 说明了`Promise.all()`的工作原理。

![](img/304b67c9d82e5f471ff49a4f60ee10e2.png)

图 43.2：Promise 组合器`Promise.all()`。

##### 43.5.2.1 通过`Promise.all()`实现异步`.map()`

数组转换方法，如`.map()`、`.filter()`等，是为了同步计算而设计的。例如：

```js
function timesTwoSync(x) {
  return 2 * x;
}
const arr = [1, 2, 3];
const result = arr.map(timesTwoSync);
assert.deepEqual(result, [2, 4, 6]);

```

如果 `.map()` 的回调是一个基于 Promise 的函数（将正常值映射到 Promise 的函数），那么 `.map()` 的结果是一个 Promise 数组。不幸的是，这不是普通代码可以处理的数据。幸运的是，我们可以通过 `Promise.all()` 来修复这个问题：它将 Promise 数组转换为解决为正常值数组的 Promise。

```js
function timesTwoAsync(x) {
  return new Promise(resolve => resolve(x * 2));
}
const arr = [1, 2, 3];
const promiseArr = arr.map(timesTwoAsync);
Promise.all(promiseArr)
  .then((result) => {
    assert.deepEqual(result, [2, 4, 6]);
  });

```

##### 43.5.2.2 一个更现实的 `.map()` 示例

接下来，我们将使用 `.map()` 和 `Promise.all()` 从网络下载文本文件。为此，我们需要以下工具函数：

```js
function downloadText(url) {
  return fetch(url)
    .then((response) => { // (A)
      if (!response.ok) { // (B)
        throw new Error(response.statusText);
      }
      return response.text(); // (C)
    });
}

```

`downloadText()` 使用基于 Promise 的 [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) 将文本文件作为字符串下载：

+   首先，它异步检索一个 `response`（行 A）。

+   `response.ok`（行 B）检查是否存在错误，例如“文件未找到”。

+   如果没有，我们使用 `.text()`（行 C）来检索文件的内容作为字符串。

在以下示例中，我们下载了两个文本文件：

```js
const urls = [
  'http://example.com/first.txt',
  'http://example.com/second.txt',
];

const promises = urls.map(
  url => downloadText(url));

Promise.all(promises)
  .then(
    (arr) => assert.deepEqual(
      arr, ['First!', 'Second!']
    ));

```

##### 43.5.2.3 `Promise.all()` 的简单实现

这是 `Promise.all()` 的简化实现（例如，它不执行安全检查）：

```js
function all(iterable) {
  return new Promise((resolve, reject) => {
    let elementCount = 0;
    let result;

    let index = 0;
    for (const promise of iterable) {
      // Preserve the current value of `index`
      const currentIndex = index;
      promise.then(
        (value) => {
          result[currentIndex] = value;
          elementCount++;
          if (elementCount === result.length) {
            resolve(result); // (A)
          }
        },
        (err) => {
          reject(err); // (B)
        });
      index++;
    }
    if (index === 0) {
      // Resolution is normally done in line A
      resolve([]);
      return;
    }
    // Now we know how many Promises there are in `iterable`.
    // We can wait until now with initializing `result` because
    // the callbacks of .then() are executed asynchronously.
    result = new Array(index);
  });
}

```

结果 Promise 解决的两个主要位置是行 A 和行 B。在其中一个解决之后，另一个不能再改变解决值，因为 Promise 只能解决一次。

#### 43.5.3 `Promise.race()`

这是 `Promise.race()` 的类型签名：

```js
Promise.race<T>(promises: Iterable<Promise<T>>): Promise<T>

```

`Promise.race()` 返回一个 Promise `q`，它在 `promises` 中的第一个 Promise `p` 解决时立即解决。`q` 具有与 `p` 相同的解决值。

在下面的示例中，已解决的 Promise（行 A）的解决发生在拒绝的 Promise（行 B）的解决之前。因此，结果也是已解决的（行 C）。

```js
const promises = [
  new Promise((resolve, reject) =>
    setTimeout(() => resolve('result'), 100)), // (A)
  new Promise((resolve, reject) =>
    setTimeout(() => reject('ERROR'), 200)), // (B)
];
Promise.race(promises)
  .then((result) => assert.equal( // (C)
    result, 'result'));

```

在下一个示例中，拒绝首先发生：

```js
const promises = [
  new Promise((resolve, reject) =>
    setTimeout(() => resolve('result'), 200)),
  new Promise((resolve, reject) =>
    setTimeout(() => reject('ERROR'), 100)),
];
Promise.race(promises)
  .then(
    (result) => assert.fail(),
    (err) => assert.equal(
      err, 'ERROR'));

```

注意，`Promise.race()` 返回的 Promise 在其输入的 Promise 中第一个解决时立即解决。这意味着 `Promise.race([])` 的结果永远不会解决。

图 43.3 展示了 `Promise.race()` 的工作原理。

![](img/3728be0c72a2536ecd233d4e9ef7d204.png)

图 43.3：Promise 组合器 `Promise.race()`。

##### 43.5.3.1 使用 `Promise.race()` 来超时一个 Promise

在本节中，我们将使用 `Promise.race()` 来超时 Promise。我们将使用以下辅助函数：

```js
/**
 * Returns a Promise that is resolved with `value`
 * after `ms` milliseconds.
 */
function resolveAfter(ms, value=undefined) {
  return new Promise((resolve, _reject) => {
    setTimeout(() => resolve(value), ms);
  });
}

/**
 * Returns a Promise that is rejected with `reason`
 * after `ms` milliseconds.
 */
function rejectAfter(ms, reason=undefined) {
  return new Promise((_resolve, reject) => {
    setTimeout(() => reject(reason), ms);
  });
}

```

这个函数超时一个 Promise：

```js
function timeout(timeoutInMs, promise) {
  return Promise.race([
    promise,
    rejectAfter(timeoutInMs,
      new Error('Operation timed out')
    ),
  ]);
}

```

`timeout()` 返回一个 Promise，其解决与以下两个 Promise 中首先解决的 Promise 相同。

1.  参数 `promise`

1.  在 `timeoutInMs` 毫秒后拒绝的 Promise

为了产生第二个 Promise，`timeout()` 使用了这样一个事实：用拒绝的 Promise 解决挂起的 Promise 会导致前者被拒绝。

让我们看看 `timeout()` 的实际效果。在这里，输入 Promise 在超时之前被解决。因此，输出 Promise 被解决。

```js
timeout(200, resolveAfter(100, 'Result!'))
  .then(result => assert.equal(result, 'Result!'));

```

在这里，超时发生在输入 Promise 被解决之前。因此，输出 Promise 被拒绝。

```js
timeout(100, resolveAfter(200, 'Result!'))
  .catch(err => assert.deepEqual(err, new Error('Operation timed out')));

```

理解“Promise 超时”的真正含义很重要：

+   如果输入 Promise 足够快地解决，其解决会被传递到输出 Promise。

+   如果它没有足够快地解决，输出 Promise 会被拒绝。

也就是说，超时仅阻止输入 Promise 影响输出（因为 Promise 只能解决一次）。但它不会停止产生输入 Promise 的异步操作。

##### 43.5.3.2 `Promise.race()` 的简单实现

这是一个 `Promise.race()` 的简化实现（例如，它不执行任何安全检查）：

```js
function race(iterable) {
  return new Promise((resolve, reject) => {
    for (const promise of iterable) {
      promise.then(
        (value) => {
          resolve(value); // (A)
        },
        (err) => {
          reject(err); // (B)
        });
    }
  });
}

```

结果 Promise 在 A 行或 B 行解决。一旦解决，解决值就不能再更改。

#### 43.5.4 `Promise.any()` (ES2021)

这是 `Promise.any()` 的类型签名：

```js
Promise.any<T>(promises: Iterable<Promise<T>>): Promise<T>

```

`Promise.any()` 返回一个 Promise `p`。它如何解决取决于参数 `promises`（它指的是一个 Promise 的可迭代对象）：

+   如果第一个 Promise 被解决，`p` 就会使用那个 Promise 解决。

+   如果所有 Promise 都被拒绝，`p` 会使用包含所有拒绝值的 `AggregateError` 实例被拒绝。

图 43.4 展示了 `Promise.any()` 的工作原理。

![](img/e8a5def71f107f982eeb0cdeee8e7f86.png)

图 43.4：Promise 组合器 `Promise.any()`。

##### 43.5.4.1 `AggregateError` (ES2021)

这是 `AggregateError` 的类型签名（`Error` 类的子类）：

```js
class AggregateError extends Error {
  // Instance properties (complementing the ones of Error)
  errors: Array<any>;

  constructor(
 errors: Iterable<any>,
 message: string = '',
 options?: ErrorOptions // ES2022
  );
}
interface ErrorOptions {
  cause?: any; // ES2022
}

```

##### 43.5.4.2 两个初始示例

如果一个 Promise 被解决会发生这种情况：

```js
const promises = [
  Promise.reject('ERROR A'),
  Promise.reject('ERROR B'),
  Promise.resolve('result'),
];
Promise.any(promises)
  .then((result) => assert.equal(
    result, 'result'
  ));

```

如果所有 Promise 都被拒绝会发生这种情况：

```js
const promises = [
  Promise.reject('ERROR A'),
  Promise.reject('ERROR B'),
  Promise.reject('ERROR C'),
];
Promise.any(promises)
  .catch((aggregateError) => assert.deepEqual(
    aggregateError.errors,
    ['ERROR A', 'ERROR B', 'ERROR C']
  ));

```

##### 43.5.4.3 `Promise.any()` 与 `Promise.all()`

`Promise.any()` 和 `Promise.all()` 可以从两种方式进行比较：

+   它们是彼此的逆：

    +   `Promise.all()`：第一个输入拒绝会拒绝结果 Promise 或其解决值是一个包含输入解决值的数组。

    +   `Promise.any()`：第一个输入解决会解决结果 Promise 或其拒绝值是一个包含输入拒绝值的数组（在错误对象内部）。

+   它们有不同的焦点：

    +   `Promise.all()` 关注的是 *所有* 解决。相反的情况（至少一个拒绝）会导致拒绝。

    +   `Promise.any()` 关注第一个解决。相反的情况（只有拒绝）会导致拒绝。

##### 43.5.4.4 `Promise.any()` 与 `Promise.race()`

`Promise.any()` 和 `Promise.race()` 也有关联，但关注点不同：

+   `Promise.race()` 对解决感兴趣。首先解决的 Promise，“获胜”。换句话说：我们想知道哪个异步计算首先终止。

+   `Promise.any()` 对实现感兴趣。首先实现的 Promise，“获胜”。换句话说：我们想知道哪个异步计算首先成功。

`.race()` 的主要 – 相对罕见 – 用例是超时 Promise。`.any()` 的用例更广泛。我们将在下一节中查看它们。

##### 43.5.4.5 `Promise.any()` 的用例

当我们有多个异步计算并且只对第一个成功的一个感兴趣时，我们使用 `Promise.any()`。从某种意义上说，我们让计算相互竞争，并使用最快的那个。

以下代码演示了在下载资源时的样子：

```js
const resource = await Promise.any([
  fetch('http://example.com/first.txt')
    .then(response => response.text()),
  fetch('http://example.com/second.txt')
    .then(response => response.text()),
]);

```

同样的模式使我们能够使用下载速度更快的模块：

```js
const mylib = await Promise.any([
  import('https://primary.example.com/mylib'),
  import('https://secondary.example.com/mylib'),
]);

```

为了比较，如果次要服务器只是作为后备 – 以防主服务器失败，我们会使用以下代码：

```js
let mylib;
try {
  mylib = await import('https://primary.example.com/mylib');
} catch {
  mylib = await import('https://secondary.example.com/mylib');
}

```

##### 43.5.4.6 我们如何实现 `Promise.any()`？

`Promise.any()` 的简单实现基本上是 `Promise.all()` 实现的镜像版本。

#### 43.5.5 `Promise.allSettled()` (ES2020)

这次，类型签名稍微复杂一些。您可以自由地跳到第一个演示，它应该更容易理解。

这是 `Promise.allSettled()` 的类型签名：

```js
Promise.allSettled<T>(promises: Iterable<Promise<T>>)
  : Promise<Array<SettlementObject<T>>>

```

它返回一个 Promise，其元素具有以下类型签名：

```js
type SettlementObject<T> = FulfillmentObject<T> | RejectionObject;

interface FulfillmentObject<T> {
  status: 'fulfilled';
  value: T;
}

interface RejectionObject {
  status: 'rejected';
  reason: unknown;
}

```

`Promise.allSettled()` 返回一个 Promise `out`。一旦所有 `promises` 都已解决，`out` 就会通过一个数组来实现。该数组中的每个元素 `e` 都对应于 `promises` 中的一个 Promise `p`：

+   如果 `p` 被实现，实现值为 `v`，那么 `e` 是

    ```js
    { status: 'fulfilled', value:  v }

    ```

+   如果 `p` 被拒绝，拒绝值为 `r`，那么 `e` 是

    ```js
    { status: 'rejected',  reason: r }

    ```

除非在迭代 `promises` 时出现错误，否则输出 Promise `out` 从不会被拒绝。

图 43.5 阐述了 `Promise.allSettled()` 的工作原理。

![](img/3bb559e958e51edd426fc59d90d5a465.png)

图 43.5：Promise 组合器 `Promise.allSettled()`。

##### 43.5.5.1 `Promise.allSettled()` 的第一个演示

这是对 `Promise.allSettled()` 如何工作的快速初步演示：

```js
Promise.allSettled([
  Promise.resolve('value'),
  Promise.reject('ERROR'),
])
.then(arr => assert.deepEqual(arr, [
  { status: 'fulfilled', value: 'value' },
  { status: 'rejected',  reason: 'ERROR' },
]));

```

##### 43.5.5.2 `Promise.allSettled()` 的更长时间示例

以下示例类似于 `.map()` 加 `Promise.all()` 的示例（我们从其中借用函数 `downloadText()`）：我们正在下载存储在数组中的多个文本文件。然而，这次我们不希望在出现错误时停止，我们希望继续进行。`Promise.allSettled()` 允许我们这样做：

```js
function downloadText(url) {
  return fetch(url)
    .then((response) => {
      if (!response.ok) {
        throw new Error(response.statusText);
      }
      return response.text();
    });
}

const urls = [
  'http://example.com/exists.txt',
  'http://example.com/missing.txt',
];

const result = Promise.allSettled(
  urls.map(url => downloadText(url))
);
result.then(
  (arr) => {
    assert.deepEqual(
      arr,
      [
        {
          status: 'fulfilled',
          value: 'Hello!',
        },
        {
          status: 'rejected',
          reason: new Error('Not Found'),
        },
      ]
    )
  }
);

```

##### 43.5.5.3 `Promise.allSettled()` 的简单实现

这是 `Promise.allSettled()` 的简化实现（例如，它不执行任何安全检查）：

```js
function allSettled(iterable) {
  return new Promise((resolve, reject) => {
    let elementCount = 0;
    let result;

    function addElementToResult(i, elem) {
      result[i] = elem;
      elementCount++;
      if (elementCount === result.length) {
        resolve(result);
      }
    }

    let index = 0;
    for (const promise of iterable) {
      // Capture the current value of `index`
      const currentIndex = index;
      promise.then(
        (value) => addElementToResult(
          currentIndex, {
            status: 'fulfilled',
            value
          }
        ),
        (reason) => addElementToResult(
          currentIndex, {
            status: 'rejected',
            reason
          }
        )
      );
      index++;
    }
    if (index === 0) {
      // Resolution is normally triggered by addElementToResult()
      resolve([]);
      return;
    }
    // Now we know how many Promises there are in `iterable`.
    // We can wait until now with initializing `result` because
    // the callbacks of .then() are executed asynchronously.
    result = new Array(index);
  });
}

```

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：Promise 组合方法**

+   获取 Promise 可迭代对象中的最高满足值：`exercises/promises/get-highest-fulfillment_test.mjs`

+   实现 `Promise.anySettled()`：`exercises/promises/promise-any-settled_test.mjs`

#### 43.5.6 短路（高级）

对于 Promise 组合器，*短路*意味着输出 Promise 提前解决——在所有输入 Promise 解决之前。以下组合器会短路：

+   `Promise.all()`：只要有一个输入 Promise 被拒绝，输出 Promise 就会被拒绝。

+   `Promise.race()`：只要有一个输入 Promise 被解决，输出 Promise 就会被解决。

+   `Promise.any()`：只要有一个输入 Promise 被满足，输出 Promise 就会被满足。

再次强调，提前解决并不意味着忽略的 Promises 后面的操作停止。它只是意味着它们的解决被忽略。

### 43.6 并发和 `Promise.all()`（高级）

#### 43.6.1 顺序执行与并发执行

考虑以下代码：

```js
const asyncFunc1 = () => Promise.resolve('one');
const asyncFunc2 = () => Promise.resolve('two');

asyncFunc1()
 .then((result1) => {
 assert.equal(result1, 'one');
 return asyncFunc2();
 })
 .then((result2) => {
 assert.equal(result2, 'two');
 }); 
```

以这种方式使用 `.then()` 会顺序执行基于 Promise 的函数：只有当 `asyncFunc1()` 的结果解决后，`asyncFunc2()` 才会执行。

`Promise.all()` 有助于更并发地执行基于 Promise 的函数：

```js
Promise.all([asyncFunc1(), asyncFunc2()])
  .then((arr) => {
    assert.deepEqual(arr, ['one', 'two']);
  });

```

#### 43.6.2 并发技巧：关注操作开始的时间

确定异步代码“并发”程度的技巧：关注异步操作开始的时间，而不是它们 Promise 的处理方式。

例如，以下每个函数都是并发执行 `asyncFunc1()` 和 `asyncFunc2()`，因为它们几乎同时开始。

```js
function concurrentAll() {
 return Promise.all([asyncFunc1(), asyncFunc2()]);
}

function concurrentThen() {
 const p1 = asyncFunc1();
 const p2 = asyncFunc2();
 return p1.then(r1 => p2.then(r2 => [r1, r2]));
} 
```

另一方面，以下两个函数都是顺序执行 `asyncFunc1()` 和 `asyncFunc2()`：`asyncFunc2()` 只有在 `asyncFunc1()` 的 Promise 被满足后才会被调用。

```js
function sequentialThen() {
 return asyncFunc1()
 .then(r1 => asyncFunc2()
 .then(r2 => [r1, r2]));
}

function sequentialAll() {
 const p1 = asyncFunc1();
 const p2 = p1.then(() => asyncFunc2());
 return Promise.all([p1, p2]);
} 
```

#### 43.6.3 `Promise.all()` 是分叉-合并

`Promise.all()` 与并发模式“分叉-合并”松相关。让我们回顾一下我们之前遇到的例子 之前：

```js
Promise.all([
    // (A) fork
    downloadText('http://example.com/first.txt'),
    downloadText('http://example.com/second.txt'),
  ])
  // (B) join
  .then(
    (arr) => assert.deepEqual(
      arr, ['First!', 'Second!']
    ));

```

+   分叉：在行 A 中，我们正在分叉两个异步计算并并发执行它们。

+   合并：在行 B 中，我们将这些计算合并成一个“线程”，一旦它们都完成，这个线程就会启动。

### 43.7 链式 Promise 的技巧

本节提供了链式 Promise 的技巧。

#### 43.7.1 链式错误：丢失尾部

问题：

```js
// Don’t do this
function foo() {
 const promise = asyncFunc();
 promise.then((result) => {
 // ···
 });

 return promise;
}

```

计算从 `asyncFunc()` 返回的 Promise 开始。但之后，计算继续，并通过 `.then()` 创建另一个 Promise。`foo()` 返回前一个 Promise，但应该返回后一个。这是如何修复它的：

```js
function foo() {
 const promise = asyncFunc();
 return promise.then((result) => {
 // ···
 });
}

```

#### 43.7.2 链式错误：嵌套

问题：

```js
// Don’t do this
asyncFunc1()
  .then((result1) => {
    return asyncFunc2()
    .then((result2) => { // (A)
      // ···
    });
  });

```

行 A 中的`.then()`是嵌套的。一个扁平的结构会更好：

```js
asyncFunc1()
  .then((result1) => {
    return asyncFunc2();
  })
  .then((result2) => {
    // ···
  });

```

#### 43.7.3 链式错误：不必要的嵌套过多

这又是另一个可避免嵌套的例子：

```js
// Don’t do this
asyncFunc1()
  .then((result1) => {
    if (result1 < 0) {
      return asyncFuncA()
      .then(resultA => 'Result: ' + resultA);
    } else {
      return asyncFuncB()
      .then(resultB => 'Result: ' + resultB);
    }
  });

```

我们可以再次得到一个扁平的结构：

```js
asyncFunc1()
  .then((result1) => {
    return result1 < 0 ? asyncFuncA() : asyncFuncB();
  })
  .then((resultAB) => {
    return 'Result: ' + resultAB;
  });

```

#### 43.7.4 并非所有嵌套都是不好的

在以下代码中，我们实际上受益于嵌套：

```js
db.open()
  .then((connection) => { // (A)
    return connection.select({ name: 'Jane' })
      .then((result) => { // (B)
        // Process result
        // Use `connection` to make more queries
      })
      // ···
      .finally(() => {
        connection.close(); // (C)
      });
  })

```

我们在行 A 中接收异步结果。在行 B 中，我们进行了嵌套，以便在行 C 中访问回调内部的变量`connection`。

#### 43.7.5 链式错误：创建 Promise 而不是链式

问题：

```js
// Don’t do this
class Model {
  insertInto(db) {
    return new Promise((resolve, reject) => { // (A)
      db.insert(this.fields)
        .then((resultCode) => {
          this.notifyObservers({event: 'created', model: this});
          resolve(resultCode);
        }).catch((err) => {
          reject(err);
        })
    });
  }
  // ···
}

```

在行 A 中，我们创建了一个 Promise 来传递`db.insert()`的结果。这是不必要的冗长，可以简化：

```js
class Model {
  insertInto(db) {
    return db.insert(this.fields)
      .then((resultCode) => {
        this.notifyObservers({event: 'created', model: this});
        return resultCode;
      });
  }
  // ···
}

```

关键思想是我们不需要创建一个 Promise；我们可以返回`.then()`调用的结果。一个额外的优点是我们不需要捕获并重新拒绝`db.insert()`的失败。我们只需将它的拒绝传递给`.insertInto()`的调用者。

### 43.8 Thenables (Promise-like objects) (高级)

当在 ES6（2015 年）中向 JavaScript 的标准库添加 Promise 时，几个 Promise 库很受欢迎并且被广泛使用。为了使这些库与内置 API 互操作，TC39 定义了一个最小的接口，用于 Promise-like 对象，该接口与大多数这些库兼容。尽可能多的情况下，API 不需要对象是 Promise – 它们只需要是 Promise-like。如果需要，API 会透明地将 Promise-like 对象转换为 API Promise。

那么什么最小接口描述了 Promise 的本质？它只需要一个`.then()`方法，让我们可以注册回调：

```js
const promiseLikeObject = {
  then(onFulfilled, onRejected) {
    // ···
  },
};

```

这是 TypeScript 中 Promise-like 对象的类型的一个简化版本：

```js
interface PromiseLike<T> {
  then<TResult1, TResult2>(
    onFulfilled?: (value: T) => TResult1 | PromiseLike<TResult1>,
    onRejected?: (reason: any) => TResult2 | PromiseLike<TResult2>
  ): PromiseLike<TResult1 | TResult2>;
}

```

这个接口是足够的，因为`.catch()`实际上只是调用`.then()`（我们之前忽略了其第二个参数）的一个方便方式 – 以下两个调用是等效的：

```js
promise.catch(onRejected)
promise.then(undefined, onRejected)

```

因为 Promise-like 对象只有一个`.then()`方法，所以它们也被称为*thenables*。

#### 43.8.1 示例：一个已解决的 thenable

下面的对象是一个已解决的 thenable：

```js
const fulfilledThenable = {
  then(onFulfilled, onRejected) {
    onFulfilled('Success!');
  },
};

```

如果我们将 thenable 传递给`Promise.resolve()`，它将其转换为 Promise：

```js
const promise = Promise.resolve(fulfilledThenable);
assert.equal(
  promise instanceof Promise, true
);

```

从回调中返回 thenable 相当于返回一个 Promise：

```js
Promise.resolve()
  .then(() => fulfilledThenable)
  .then((value) => {
    assert.equal(value, 'Success!');
  });

```

我们也可以用 thenable 解决一个新的 Promise：

```js
new Promise((resolve) => {
  resolve(fulfilledThenable);
}).then((value) => {
  assert.equal(value, 'Success!');
});

```

#### 43.8.2 示例：一个被拒绝的 thenable

以下代码演示了一个被拒绝的 thenable：

```js
const rejectedThenable = {
  then(onFulfilled, onRejected) {
    onRejected('Error!');
  },
};

Promise.resolve(rejectedThenable)
  .catch((reason) => {
    assert.equal(reason, 'Error!');
  });

Promise.resolve()
  .then(() => rejectedThenable)
  .catch((reason) => {
    assert.equal(reason, 'Error!');
  });

new Promise((resolve) => {
  resolve(rejectedThenable);
}).catch((reason) => {
  assert.equal(reason, 'Error!');
});

```

### 43.9 快速参考：`Promise`

#### 43.9.1 `new Promise()`

+   `new Promise(executor)` ES6

    ```js
    new Promise<T>(
      executor: (
     resolve: (value: T | PromiseLike<T>) => void,
     reject: (reason?: any) => void
     ) => void
    ): Promise<T>

    ```

    这个构造函数创建了一个新的 Promise。它将函数传递给其回调，这样 Promise 就可以被解决或拒绝：

    ```js
    // Create a Promise and resolve it
    new Promise((resolve, reject) => {
      resolve('Result');
    }).then((value) => {
      assert.equal(value, 'Result');
    });

    // Create a Promise and reject it
    new Promise((resolve, reject) => {
      reject('Error');
    }).catch((reason) => {
      assert.equal(reason, 'Error');
    });

    ```

#### 43.9.2 `Promise.*`: 创建 Promise

+   `Promise.withResolvers()` ES2024

    ```js
    Promise.withResolvers<T>(): PromiseWithResolvers<T>;
    interface PromiseWithResolvers<T> {
      promise: Promise<T>;
      resolve: (value: T | PromiseLike<T>) => void;
      reject: (reason?: any) => void;
    }

    ```

    此方法创建一个 Promise，并返回一个包含该 Promise 以及用于解决或拒绝它的函数的对象。

+   `Promise.resolve(value?)` ES6

    创建一个 Promise，用`value`解决它并返回它：

    ```js
    Promise.resolve('Yes')
    .then((value) => {
      assert.equal(value, 'Yes');
    });

    ```

+   `Promise.reject(reason?)` ES6

    创建一个 Promise，用`value`拒绝它并返回它：

    ```js
    Promise.reject('No')
    .catch((reason) => {
      assert.equal(reason, 'No');
    });

    ```

#### 43.9.3 `Promise.*`: 附加功能

+   `Promise.try(callback, ...args)` ES2025

    通过将`callback`视为`.then()`回调来创建 Promise：

    +   它使用零个或多个参数调用`callback`。

    +   如果`callback`抛出异常，`Promise.try()`将其转换为拒绝的 Promise 并返回它。

    +   如果`callback`返回一个值，`Promise.try()`将其解决为 Promise 并返回它。

    此方法的用例是使用非纯异步代码开始 Promise 链 - 例如：

    ```js
    function computeAsync() {
     return Promise.try(() => {
     const value = syncFuncMightThrow();
     return asyncFunc(value);
     });
    }

    ```

#### 43.9.4 `Promise.*`: Promise 组合器

术语表：

+   *短路*：在某些情况下，输出 Promise 可以提前解决（在所有输入 Promise 解决之前）。这被称为短路。

这些是 Promise 组合器：

+   `Promise.all(promises)` ES6

    ```js
    Promise.all<T>(
      promises: Iterable<Promise<T>>
    ): Promise<Array<T>>

    ```

    +   **P 的解决**：如果所有输入 Promise 都已解决。

        +   值：包含输入 Promise 的解决值的数组

    +   **P 的拒绝**：如果有一个输入 Promise 被拒绝。

        +   值：输入 Promise 的拒绝值

    +   短路：是

    +   用例：使用 Promise 处理数组（拒绝会终止处理）

+   `Promise.race(promises)` ES6

    ```js
    Promise.race<T>(
      promises: Iterable<Promise<T>>
    ): Promise<T>

    ```

    +   **P 的解决**：如果第一个输入 Promise 已解决。

        +   值：输入 Promise 的解决值

    +   短路：是

    +   用例：对多个 Promise 中的第一个解决做出反应

+   `Promise.any(promises)` ES2021

    ```js
    Promise.any<T>(
      promises: Iterable<Promise<T>>
    ): Promise<T>

    ```

    +   **P 的解决**：如果有一个输入 Promise 被解决。

        +   值：输入 Promise 的解决值

    +   **P 的拒绝**：如果所有输入 Promise 都被拒绝。

        +   值：包含输入 Promise 拒绝值的`AggregateError`。

    +   短路：是

    +   用例：在多个异步计算中，我们只对第一个成功的结果感兴趣。也就是说，我们尝试了多种方法，最快的一个应该获胜。

    这是`AggregateError`的类型签名（省略了一些成员）：

    ```js
    class AggregateError {
      constructor(errors: Iterable<any>, message: string);
      get errors(): Array<any>;
      get message(): string;
    }

    ```

+   `Promise.allSettled(promises)` ES2020

    ```js
    Promise.allSettled<T>(
      promises: Iterable<Promise<T>>
    ): Promise<Array<SettlementObject<T>>>

    ```

    +   **P 的解决**：如果所有输入 Promise 都已解决。

        +   值：包含每个输入 Promise 的一个*解决对象*的数组。解决对象包含解决类型和解决值。

    +   **P 的拒绝**：如果在迭代输入 Promise 时发生错误。

    +   短路：否

    +   用例：使用 Promise 处理数组（拒绝不会终止处理）

    这是`SettlementObject`的类型签名：

    ```js
    type SettlementObject<T> = FulfillmentObject<T> | RejectionObject;

    interface FulfillmentObject<T> {
      status: 'fulfilled';
      value: T;
    }

    interface RejectionObject {
      status: 'rejected';
      reason: unknown;
    }

    ```

#### 43.9.5 `Promise.prototype.*`

+   `Promise.prototype.then(onFulfilled?, onRejected?)` ES6

    ```js
    interface Promise<T> {
      then<TResult1, TResult2>(
        onFulfilled?: (value: T) => TResult1 | PromiseLike<TResult1>,
        onRejected?: (reason: any) => TResult2 | PromiseLike<TResult2>
      ): Promise<TResult1 | TResult2>;
    }

    ```

    为 Promise 的实现值和/或拒绝值注册回调。通常，只使用第一个参数 `onFulfilled`。`.catch()` 提供了一个更具描述性的替代方案，用于使用第二个参数 `onRejected`。

    ```js
    Promise.resolve('Yes')
    .then((value) => {
      assert.equal(value, 'Yes');
    });

    ```

+   `Promise.prototype.catch(onRejected)` ES6

    ```js
    interface Promise<T> {
      catch<TResult>(
        onrejected?: (reason: any) => TResult2 | PromiseLike<TResult2>
      ): Promise<T | TResult>;
    }

    ```

    为 Promise 的拒绝值注册回调。这是使用 `.then()` 实现该目的的一个更具描述性的替代方案——以下两种调用是等效的：

    ```js
    promise.catch(onRejected)
    promise.then(undefined, onRejected)

    ```

    示例：

    ```js
    Promise.reject('No')
    .catch((reason) => {
      assert.equal(reason, 'No');
    });

    ```

+   `Promise.prototype.finally(onFinally)` ES2018

    ```js
    interface Promise<T> {
      // Returning a rejected Promise from onFinally does have an effect!
      finally(onFinally?: () => void);
    }

    ```

    通常如下使用：

    ```js
    somePromise
      .then((result) => {
        // ···
      })
      .catch((error) => {
        // ···
      })
      .finally(() => {
        // ···
      })
    ;

    ```

    `.finally()` 回调始终会被执行——无论 `somePromise` 的结果如何，以及 `.then()` 和/或 `.catch()` 返回的值。回调只有在其返回一个拒绝的 Promise 或抛出异常时才会产生效果。然后最终的 Promise 会因为拒绝值或异常而被拒绝。
