# 25 控制流语句

> 原文：[`exploringjs.com/js/book/ch_control-flow.html`](https://exploringjs.com/js/book/ch_control-flow.html)

1.  25.1 控制循环：`break` 和 `continue`

    1.  25.1.1 `break`

    1.  25.1.2 带有标签的 `break`：离开任何带标签的语句

    1.  25.1.3 `continue`

1.  25.2 控制流语句的条件

1.  25.3 `if` 语句 (ES1)

    1.  25.3.1 `if` 语句的语法

1.  25.4 `switch` 语句 (ES3)

    1.  25.4.1 `switch` 语句的第一个示例

    1.  25.4.2 不要忘记 `return` 或 `break`！

    1.  25.4.3 空的情况子句

    1.  25.4.4 通过 `default` 子句检查非法值

    1.  25.4.5 `switch` 的陷阱：所有情况都存在于相同的变量作用域中

1.  25.5 `while` 循环 (ES1)

    1.  25.5.1 `while` 循环的示例

1.  25.6 `do-while` 循环 (ES3)

1.  25.7 `for` 循环 (ES1)

    1.  25.7.1 `for` 循环的示例

1.  25.8 `for-of` 循环 (ES6)

    1.  25.8.1 `const`：`for-of` 与 `for` 的比较

    1.  25.8.2 遍历可迭代对象

    1.  [25.8.3 遍历数组的 [索引，元素] 对](#for-of-iterating-index-element)

1.  25.9 `for-await-of` 循环 (ES2018)

1.  25.10 `for-in` 循环（避免）(ES1)

1.  25.11 循环的建议

本章涵盖了以下控制流语句：

+   `if` 语句 [ES1]

+   `switch` 语句 [ES3]

+   `while` 循环 [ES1]

+   `do-while` 循环 [ES3]

+   `for` 循环 [ES1]

+   `for-of` 循环 [ES6]

+   `for-await-of` 循环 [ES2018]

+   `for-in` 循环 [ES1]

### 25.1 控制循环：`break` 和 `continue`

两个运算符 `break` 和 `continue` 可以在我们处于循环或其他语句内部时控制它们。

#### 25.1.1 `break`

`break` 有两种版本：

+   没有操作数的一个。

+   带有 *标签* 作为操作数的一个。

前者版本可以在以下语句中使用：`while`、`do-while`、`for`、`for-of`、`for-await-of`、`for-in` 和 `switch`。它立即离开当前语句：

```js
for (const x of ['a', 'b', 'c']) {
  console.log(x);
  if (x === 'b') break;
  console.log('---')
}

```

输出：

```js
a
---
b

```

#### 25.1.2 带有标签的 `break`：离开任何带标签的语句

带有操作数的 `break` 在任何地方都有效。其操作数是一个 *标签*。标签可以放在任何语句之前，包括块。`break myLabel` 将离开标签为 `myLabel` 的语句：

```js
myLabel: { // label
  if (condition) break myLabel; // labeled break
  // ···
}

```

##### 25.1.2.1 示例：带有标签的 `break`

在以下示例中，搜索可以：

+   失败：循环结束而没有找到 `result`。这将在循环之后直接处理（行 B）。

+   成功：在循环过程中，我们找到了 `result`。然后我们使用带有标签的 `break`（行 A）来跳过处理失败的代码。

```js
function findSuffix(stringArray, suffix) {
  let result;
  searchBlock: {
    for (const str of stringArray) {
      if (str.endsWith(suffix)) {
        // Success:
        result = str;
        break searchBlock; // (A)
      }
    } // for
    // Failure:
    result = '(Untitled)'; // (B)
  } // searchBlock

  return { suffix, result };
    // Same as: {suffix: suffix, result: result}
}
assert.deepEqual(
  findSuffix(['notes.txt', 'index.html'], '.html'),
  { suffix: '.html', result: 'index.html' }
);
assert.deepEqual(
  findSuffix(['notes.txt', 'index.html'], '.mjs'),
  { suffix: '.mjs', result: '(Untitled)' }
);

```

#### 25.1.3 `continue`

`continue`仅在`while`、`do-while`、`for`、`for-of`、`for-await-of`和`for-in`内部有效。它立即离开当前的循环迭代，并继续下一个——例如：

```js
const lines = [
  'Normal line',
  '# Comment',
  'Another normal line',
];
for (const line of lines) {
  if (line.startsWith('#')) continue;
  console.log(line);
}

```

输出：

```js
Normal line
Another normal line

```

### 25.2 控制流语句的条件

`if`、`while`和`do-while`的条件在原则上都是布尔值。然而，条件只需是*真值*（如果转换为布尔值则为`true`）即可被接受。换句话说，以下两个控制流语句是等价的：

```js
if (value) {}
if (Boolean(value) === true) {}

```

这是一个所有*假值*的列表：

+   `undefined`, `null`

+   `false`

+   `0`, `NaN`

+   `0n`

+   `''`

所有其他值都是真值。有关更多信息，请参阅“假值和真值” (§17.2)。

### 25.3 `if`语句^(ES1)

这些是两个简单的`if`语句：一个只有一个“then”分支，另一个既有“then”分支又有“else”分支：

```js
if (cond) {
  // then branch
}

if (cond) {
  // then branch
} else {
  // else branch
}

```

除了块之外，`else`也可以跟另一个`if`语句：

```js
if (cond1) {
  // ···
} else if (cond2) {
  // ···
}

if (cond1) {
  // ···
} else if (cond2) {
  // ···
} else {
  // ···
}

```

我们可以用更多的`else if`继续这个链。

#### 25.3.1 `if`语句的语法

`if`语句的一般语法是：

```js
if («cond») «then_statement»
else «else_statement»

```

到目前为止，`then_statement`始终是一个块，但我们可以使用任何语句。该语句必须以分号结束：

```js
if (true) console.log('Yes'); else console.log('No');

```

这意味着`else if`不是它自己的构造；它只是一个`if`语句，其`else_statement`是另一个`if`语句。

### 25.4 `switch`语句^(ES3)

一个`switch`语句看起来如下：

```js
switch («switch_expression») {
  «switch_body»
}

```

`switch`的主体由零个或多个`case`子句组成：

```js
case «case_expression»:
  «statements»

```

并且，可选地，一个默认子句：

```js
default:
  «statements»

```

`switch`的执行方式如下：

+   它评估`switch`表达式。

+   它跳转到第一个表达式结果与`switch`表达式相同的`case`子句。

+   否则，如果没有这样的子句，则跳转到默认子句。

+   否则，如果没有默认子句，则不执行任何操作。

#### 25.4.1 `switch`语句的第一个例子

让我们看看一个例子：以下函数将数字 1-7 转换为星期几的名称。

```js
function dayOfTheWeek(num) {
  switch (num) {
    case 1:
      return 'Monday';
    case 2:
      return 'Tuesday';
    case 3:
      return 'Wednesday';
    case 4:
      return 'Thursday';
    case 5:
      return 'Friday';
    case 6:
      return 'Saturday';
    case 7:
      return 'Sunday';
  }
}
assert.equal(dayOfTheWeek(5), 'Friday');

```

#### 25.4.2 不要忘记`return`或`break`!

在`case`子句的末尾，执行将继续到下一个`case`子句，除非我们`return`或`break`——例如：

```js
function englishToFrench(english) {
  let french;
  switch (english) {
    case 'hello':
      french = 'bonjour';
    case 'goodbye':
      french = 'au revoir';
  }
  return french;
}
// The result should be 'bonjour'!
assert.equal(englishToFrench('hello'), 'au revoir');

```

也就是说，我们的`dayOfTheWeek()`实现之所以有效，仅仅是因为我们使用了`return`。我们可以通过使用`break`来修复`englishToFrench()`：

```js
function englishToFrench(english) {
  let french;
  switch (english) {
    case 'hello':
      french = 'bonjour';
      break;
    case 'goodbye':
      french = 'au revoir';
      break;
  }
  return french;
}
assert.equal(englishToFrench('hello'), 'bonjour'); // ok

```

#### 25.4.3 空`case`子句

`case`子句的语句可以省略，这实际上为我们提供了每个`case`子句的多个`case`表达式：

```js
function isWeekDay(name) {
  switch (name) {
    case 'Monday':
    case 'Tuesday':
    case 'Wednesday':
    case 'Thursday':
    case 'Friday':
      return true;
    case 'Saturday':
    case 'Sunday':
      return false;
  }
}
assert.equal(isWeekDay('Wednesday'), true);
assert.equal(isWeekDay('Sunday'), false);

```

#### 25.4.4 通过`default`子句检查非法值

如果`switch`表达式没有其他匹配项，则跳转到默认子句。这使得它对于错误检查很有用：

```js
function isWeekDay(name) {
  switch (name) {
    case 'Monday':
    case 'Tuesday':
    case 'Wednesday':
    case 'Thursday':
    case 'Friday':
      return true;
    case 'Saturday':
    case 'Sunday':
      return false;
    default:
      throw new Error('Illegal value: '+name);
  }
}
assert.throws(
  () => isWeekDay('January'),
  {message: 'Illegal value: January'});

```

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：`switch`**

+   `exercises/control-flow/number_to_month_test.mjs`

+   奖励：`exercises/control-flow/is_object_via_switch_test.mjs`

#### 25.4.5 `switch` 的陷阱：所有情况都存在于相同的变量作用域

假设我们想要实现一个 `main()` 函数，它的工作方式如下：

```js
assert.equal(
  main(['repeat', '3', 'ho']),
  'hohoho'
);
assert.equal(
  main(['once', 'hello']),
  'hello'
);

```

我们可以将 `main()` 实现如下（为了减少冗余，省略了错误消息）：

```js
function main(args) {
  const command = args[0];
  if (command === undefined) {
    throw new Error();
  }
  switch (command) {
    case 'once':
      const text = args[1];
      if (text === undefined) {
        throw new Error();
      }
      return text;
    case 'repeat':
      const timesStr = args[1];
      const text = args[2]; // (A)
      if (timesStr === undefined || text === undefined) {
        throw new Error();
      }
      const times = Number(timesStr);
      return text.repeat(times);
    default:
      throw new Error();
  }
}

```

然而，在行 A 中，我们得到以下语法错误：

```js
SyntaxError: Identifier 'text' has already been declared

```

为什么是这样？`switch` 的完整主体是一个单独的变量作用域，并且在这个作用域内部，有两个关于变量 `text` 的声明。

但这个问题很容易解决——我们可以通过将代码包裹在大括号中来为每个 `switch` 情况创建一个变量作用域：

```js
function main(args) {
  const command = args[0];
  if (command === undefined) {
    throw new Error();
  }
  switch (command) {
    case 'once': {
      const text = args[1];
      if (text === undefined) {
        throw new Error();
      }
      return text;
    }
    case 'repeat': {
      const timesStr = args[1];
      const text = args[2]; // (A)
      if (timesStr === undefined || text === undefined) {
        throw new Error();
      }
      const times = Number(timesStr);
      return text.repeat(times);
    }
    default:
      throw new Error();
  }
}

```

### 25.5 `while` 循环^(ES1)

`while` 循环有以下语法：

```js
while («condition») {
  «statements»
}

```

在每次循环迭代之前，`while` 评估 `condition`：

+   如果结果是假值，则循环结束。

+   如果结果是真值，则 `while` 主体将再执行一次。

#### 25.5.1 `while` 循环的示例

以下代码使用 `while` 循环。在每次循环迭代中，它通过 `.shift()` 移除 `arr` 的第一个元素并记录它。

```js
const arr = ['a', 'b', 'c'];
while (arr.length > 0) {
  const elem = arr.shift(); // remove first element
  console.log(elem);
}

```

输出：

```js
a
b
c

```

如果条件始终评估为 `true`，则 `while` 是一个无限循环：

```js
while (true) {
  if (Math.random() === 0) break;
}

```

### 25.6 `do-while` 循环^(ES3)

`do-while` 循环的工作方式与 `while` 类似，但它是在每次循环迭代之后而不是之前检查其条件。

```js
let input;
do {
  input = prompt('Enter text:');
  console.log(input);
} while (input !== ':q');

```

`do-while` 也可以被视为至少运行一次的 `while` 循环。

[`prompt()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt) 是一个在网页浏览器中可用的全局函数。它提示用户输入文本并返回它。

### 25.7 `for` 循环^(ES1)

`for` 循环有以下语法：

```js
for («initialization»; «condition»; «post_iteration») {
  «statements»
}

```

第一行是循环的 *头部*，它控制循环体（循环的其余部分）执行的频率。它有三个部分，每个部分都是可选的：

+   `initialization`：为循环设置变量等。在这里通过 `let` 或 `const` 声明的变量仅存在于循环内部。

+   `condition`：在每次循环迭代之前检查此条件。如果它是假值，则循环停止。

+   `post_iteration`: 此代码在每个循环迭代后执行。

因此，`for` 循环大致等价于以下 `while` 循环：

```js
«initialization»
while («condition») {
  «statements»
  «post_iteration»
}

```

#### 25.7.1 `for` 循环的示例

例如，以下是如何通过 `for` 循环从零计数到二的：

```js
for (let i=0; i<3; i++) {
  console.log(i);
}

```

输出：

```js
0
1
2

```

这就是如何通过 `for` 循环记录数组内容的方法：

```js
const arr = ['a', 'b', 'c'];
for (let i=0; i<arr.length; i++) {
  console.log(arr[i]);
}

```

输出：

```js
a
b
c

```

如果我们省略头部所有三个部分，就会得到一个无限循环：

```js
for (;;) {
  if (Math.random() === 0) break;
}

```

### 25.8 `for-of` 循环^(ES6)

`for-of` 循环遍历任何 *可迭代* 对象——一个支持 迭代协议 的数据容器。每个迭代的值都存储在一个变量中，如头部指定：

```js
for («iteration_variable» of «iterable») {
  «statements»
}

```

迭代变量通常通过变量声明创建：

```js
const iterable = ['hello', 'world'];
for (const elem of iterable) {
  console.log(elem);
}

```

输出：

```js
hello
world

```

但我们也可以使用一个已经存在的（可变的）变量：

```js
const iterable = ['hello', 'world'];
let elem;
for (elem of iterable) {
  console.log(elem);
}

```

#### 25.8.1 `const`：`for-of` 与 `for` 的比较

注意，在`for-of`循环中我们可以使用`const`。迭代变量仍然可以在每次迭代中不同（但它不能在迭代过程中改变）。想象一下，每次在新的作用域中执行一个新的`const`声明。

相比之下，在`for`循环中，如果变量的值会改变，我们必须通过`let`或`var`来声明变量。

#### 25.8.2 遍历可迭代对象

如前所述，`for-of`与任何可迭代对象一起工作，而不仅仅是数组 - 例如，与集合一起：

```js
const set = new Set(['hello', 'world']);
for (const elem of set) {
  console.log(elem);
}

```

#### [25.8.3 遍历数组的 [索引，元素] 对](#for-of-iterating-index-element)

最后，我们还可以使用`for-of`来遍历数组的 [索引，元素] 条目：

```js
const arr = ['a', 'b', 'c'];
for (const [index, element] of arr.entries()) {
  console.log(`${index} -> ${element}`);
}

```

输出：

```js
0 -> a
1 -> b
2 -> c

```

使用`[索引，元素]`，我们正在使用 *解构赋值* 来访问数组元素。

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：`for-of`**

`exercises/control-flow/array_to_string_test.mjs`

### 25.9 `for-await-of`循环（ES2018）

`for-await-of`类似于`for-of`，但它与异步可迭代对象一起工作，而不是同步的。它只能在异步函数和异步生成器内部使用。

```js
for await (const item of asyncIterable) {
  // ···
}

```

`for-await-of`在关于异步迭代的章节中有详细描述 在异步迭代章节中描述了`for-await-of`。

### 25.10 `for-in`循环（避免）

`for-in`循环访问一个对象的所有（包括自身的和继承的）可枚举属性键。当遍历数组时，它很少是一个好的选择：

+   它访问属性键，而不是值。

+   作为属性键，数组元素的索引是字符串，而不是数字 (关于数组元素如何工作的更多信息)。

+   它访问所有可枚举属性键（包括自身的和继承的），而不仅仅是数组元素的属性键。

以下代码演示了这些要点：

```js
const arr = ['a', 'b', 'c'];
arr.propKey = 'property value';

for (const key in arr) {
  console.log(key);
}

```

输出：

```js
0
1
2
propKey

```

### 25.11 循环建议

+   如果你想要遍历一个 异步可迭代对象（在 ES2018+中），你必须使用`for-await-of`。

+   对于遍历任何同步可迭代对象（包括数组），你必须使用`for-of`。在 ES6+中可用。

+   在 ES5+中，你可以使用 数组的`.forEach()`方法来遍历数组。

+   在 ES5 之前，你可以使用普通的`for`循环来遍历数组。

+   不要使用`for-in`来遍历数组。
