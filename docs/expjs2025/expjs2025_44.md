# 37 WeakMap (WeakMap) ES6 (高级)

> 原文：[`exploringjs.com/js/book/ch_weakmaps.html`](https://exploringjs.com/js/book/ch_weakmaps.html)

1.  37.1 WeakMap 与 Map 有何不同？

1.  37.2 WeakMap 是黑盒

1.  37.3 WeakMap 的键是**弱持有**的

    1.  37.3.1 WeakMap 中可以作为键的值有哪些？

    1.  37.3.2 为什么符号作为 WeakMap 键有趣？^(ES2023)

1.  37.4 WeakMap 的用例：将值附加到对象上

    1.  37.4.1 示例：缓存计算结果

    1.  37.4.2 示例：在 WeakMap 中保持对象私有数据

1.  37.5 快速参考：`WeakMap`

### 37.1 WeakMap 与 Map 有何不同？

WeakMap 与 Map 类似，但有以下区别：

+   它们是黑盒，只有当我们同时拥有 WeakMap 和键时，才能访问值。

+   WeakMap 的键是**弱持有**的：如果一个值是 WeakMap 的键，它仍然可以被垃圾回收。这使两个重要的用例成为可能：

    +   我们可以将数据附加到我们拥有的值上——例如，缓存计算结果。

    +   我们可以通过不公开包含该部分的 WeakMap 来保持部分值的私有性。

下两个部分将更详细地探讨这意味着什么。

### 37.2 WeakMap 是黑盒

无法检查 WeakMap 内部的内容：

+   例如，我们无法对键、值或条目进行迭代或循环。我们也不能计算大小。

+   此外，我们也不能清除 WeakMap，我们必须创建一个新的实例。

这些限制使得具有安全性属性。引用 [Mark Miller](https://github.com/tc39/notes/blob/main/meetings/2014-11/nov-19.md#412-should-weakmapweakset-have-a-clear-method-markm)：

> 只有同时拥有 weakmap 和键的人才能观察或影响 weakmap/key 对值映射。使用 `clear()`，只有 WeakMap 的人原本能够影响 WeakMap 和键到值的映射。

### 37.3 WeakMap 的键是**弱持有**的

WeakMap 的键被称为**弱持有**：通常情况下，如果一个对象引用了另一个对象，那么后一个对象只要前一个对象存在，就不能被垃圾回收。使用 WeakMap，情况就不同了：如果一个对象是键并且没有其他引用，它可以在 WeakMap 存在的情况下被垃圾回收。这也导致相应的条目被移除（但无法观察到这一点）。

#### 37.3.1 WeakMap 中可以作为键的值有哪些？

WeakMap 中可以作为键的值在 ECMAScript 规范中有记录，通过规范函数 `CanBeHeldWeakly()` 实现（[`tc39.es/ecma262/#sec-canbeheldweakly`](https://tc39.es/ecma262/#sec-canbeheldweakly)）：

+   对象 (ES6)

+   符号^(ES2023)——只要它们没有被注册（通过`Symbol.for()`创建）

所有的键有一个共同点——它们有*身份语义*：

1.  当通过`===`比较时，如果两个键具有相同的身份，则认为它们相等——它们不是通过比较它们的内容（它们的值）来比较的。这意味着永远不会有两个或更多不同的键（“不同”意味着“在内存中的不同位置”）都被认为是相等的。每个键都是唯一的。

1.  它们被垃圾回收了。

这两个条件都很重要，这样 WeakMaps 才能在键消失时销毁条目，避免内存泄漏。

让我们看看例子：

+   非注册符号可以用作 WeakMap 键：它们是原始类型，但它们通过身份比较，并且会被垃圾回收。

+   以下两种类型的值不能用作 WeakMap 键：

    +   字符串会被垃圾回收，但它们是通过值进行比较的。

    +   [已注册的符号](https://exploringjs.com/es6/ch_symbols.html#sec_symbols-crossing-realms)与普通符号不同——它们没有身份语义([来源](https://tc39.es/ecma262/#sec-canbeheldweakly))。这是已注册符号的使用方式：

    ```js
    // Get a symbol from the registry
    const mySymbol = Symbol.for('key-in-symbol-registry');
    assert.equal(
      // Retrieve that symbol again
      Symbol.for('key-in-symbol-registry'),
      mySymbol
    );

    ```

#### 37.3.2 为什么将符号作为 WeakMap 键有趣？^(ES2023)

符号作为 WeakMap 键解决了即将到来的 JavaScript 功能的重要问题：

+   我们可以在[记录和元组](https://2ality.com/2020/05/records-tuples-first-look.html)中放置对象的引用。

+   我们可以在[ShadowRealms](https://2ality.com/2022/04/shadow-realms.html)中传递对象的引用。

### 37.4 WeakMaps 的使用场景：附加值到对象

我们可以使用 WeakMaps 来外部附加值到对象上——例如：

```js
const externalId = new WeakMap();
{
  const obj = {};
  externalId.set(obj, 'x3cdw5am'); // (A)
  assert.equal(
    externalId.get(obj), // (B)
    'x3cdw5am'
  );
}
// (C)

```

+   在行 A 中，我们为`obj`设置了一个外部 ID。

+   在行 B 中，我们获取`obj`的外部 ID。

+   在行 C 中，即使`obj`是数据结构`externalId`中的键，它也可以被垃圾回收。

从某种意义上说，我们为`obj`创建了一个属性，但将其外部存储。如果`externalId`是一个属性，则之前的代码将如下所示：

```js
{
  const obj = {};
  obj.externalId = 'x3cdw5am';
  assert.equal(
    obj.externalId,
    'x3cdw5am'
  );
}

```

#### 37.4.1 示例：缓存计算结果

使用 WeakMaps，我们可以将之前计算的结果与对象关联起来，而无需担心内存管理。以下函数`countOwnKeys()`是一个例子：它在 WeakMap `cache`中缓存了之前的结果。

```js
const cache = new WeakMap();
function countOwnKeys(obj) {
  if (cache.has(obj)) {
    return [cache.get(obj), 'cached'];
  } else {
    const count = Object.keys(obj).length;
    cache.set(obj, count);
    return [count, 'computed'];
  }
}

```

如果我们使用这个函数与对象`obj`一起使用，我们可以看到结果只对第一次调用进行了计算，而第二次调用则使用了缓存的值：

```js
> const obj = { foo: 1, bar: 2};
> countOwnKeys(obj)
[2, 'computed']
> countOwnKeys(obj)
[2, 'cached']

```

#### 37.4.2 示例：在 WeakMaps 中保持对象数据私有

在以下代码中，WeakMaps `_counter`和`_action`被用来存储`Countdown`实例的虚拟属性值。

```js
const _counter = new WeakMap();
const _action = new WeakMap();

class Countdown {
  constructor(counter, action) {
    _counter.set(this, counter);
    _action.set(this, action);
  }
  dec() {
 let counter = _counter.get(this);
 counter--;
 _counter.set(this, counter);
 if (counter === 0) {
 _action.get(this)();
 }
 }
}

// The two pseudo-properties are truly private:
assert.deepEqual(
 Object.keys(new Countdown()),
 []);

```

这就是`Countdown`的使用方式：

```js
let invoked = false;

const cd = new Countdown(3, () => invoked = true);

cd.dec(); assert.equal(invoked, false);
cd.dec(); assert.equal(invoked, false);
cd.dec(); assert.equal(invoked, true);

```

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：WeakMaps 用于私有数据**

`exercises/weakmaps/weakmaps_private_data_test.mjs`

### 37.5 快速参考：`WeakMap`

构造函数和 `WeakMap` 的四个方法与它们的 `Map` 等价物工作方式相同：

+   `new WeakMap<K, V>(entries?: Iterable<[K, V]>)` (ES6)

+   `WeakMap.prototype.delete(key: K) : boolean` (ES6)

+   `WeakMap.prototype.get(key: K) : V` (ES6)

+   `WeakMap.prototype.has(key: K) : boolean` (ES6)

+   `WeakMap.prototype.set(key: K, value: V) : this` (ES6)
