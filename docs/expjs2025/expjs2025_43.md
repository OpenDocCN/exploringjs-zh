# 36 Maps (Map) ES6

> 原文：[`exploringjs.com/js/book/ch_maps.html`](https://exploringjs.com/js/book/ch_maps.html)

1.  36.1 使用 Maps

    1.  36.1.1 创建 Maps

    1.  36.1.2 处理单个条目

    1.  36.1.3 确定 Maps 的大小并清除它

    1.  36.1.4 示例：计数字符

1.  36.2 在 Map 上迭代

    1.  36.2.1 在 Map 上循环

    1.  36.2.2 按插入顺序列出：条目、键、值

1.  36.3 从 Maps 转换到和从 Maps 转换

    1.  36.3.1 将键、值、条目转换为 Arrays

    1.  36.3.2 在 Maps 和 Objects 之间转换

1.  36.4 处理 Maps

    1.  36.4.1 复制 Maps

    1.  36.4.2 将多个 Maps 合并成一个单一 Map

    1.  36.4.3 通过迭代器方法映射和过滤 Maps（ES2025）

1.  36.5 关于 Maps 键的一些更多细节（高级）

    1.  36.5.1 哪些键被认为是相等的？

1.  36.6 快速参考：`Map`

    1.  36.6.1 `new Map()`

    1.  36.6.2 `Map.*`

    1.  36.6.3 `Map.prototype.*`：处理单个条目

    1.  36.6.4 `Map.prototype`：处理所有条目

    1.  36.6.5 `Map.prototype`：迭代和循环

1.  36.7 FAQ: Maps

    1.  36.7.1 应该何时使用 Map，何时使用对象？

    1.  36.7.2 当何时在 Map 中使用对象作为键？

    1.  36.7.3 为什么 Maps 保留条目的插入顺序？

    1.  36.7.4 为什么 Maps 有 `.size`，而 Arrays 有 `.length`？

在 ES6 之前，JavaScript 没有字典数据结构，而是将对象从字符串到任意值作为字典（滥用）使用。ES6 引入了 Maps，它是一种从任意值到任意值的字典。

### 36.1 使用 Maps

`Map` 的一个实例将键映射到值。单个键值映射称为 *条目*。

#### 36.1.1 创建 Maps

创建 Maps 有三种常见方式。

首先，我们可以使用无参数的构造函数来创建一个空的 Map：

```js
const emptyMap = new Map();
assert.equal(emptyMap.size, 0);

```

其次，我们可以将可迭代的（例如，一个数组）传递给构造函数，作为键值“对”（包含两个元素的数组）：

```js
const map = new Map([
  [1, 'one'],
  [2, 'two'],
  [3, 'three'], // trailing comma is ignored
]);

```

第三，`.set()` 方法向 Map 添加条目，并且是可链式的：

```js
const map = new Map()
  .set(1, 'one')
  .set(2, 'two')
  .set(3, 'three')
;

```

#### 36.1.2 处理单个条目

`map.set()` 和 `map.get()` 用于写入和读取值（给定键）。

```js
const map = new Map();

map.set('foo', 123);

assert.equal(map.get('foo'), 123);
// Unknown key:
assert.equal(map.get('bar'), undefined);
// Use the default value '' if an entry is missing:
assert.equal(map.get('bar') ?? '', '');

```

`map.has()` 检查 Map 是否包含具有给定键的条目。`map.delete()` 删除条目。

```js
const map = new Map([['foo', 123]]);

assert.equal(map.has('foo'), true);
assert.equal(map.delete('foo'), true)
assert.equal(map.has('foo'), false)

```

#### 36.1.3 确定 Map 的大小和清除它

`map.size` 包含 Map 中的条目数量。`map.clear()` 删除 Map 中的所有条目。

```js
const map = new Map()
  .set('foo', true)
  .set('bar', false)
;
assert.equal(map.size, 2)
map.clear();
assert.equal(map.size, 0)

```

#### 36.1.4 示例：计数字符

`countChars()` 返回一个将字符映射到出现次数的 Map。

```js
function countChars(chars) {
  const charCounts = new Map();
  for (let ch of chars) {
    ch = ch.toLowerCase();
    const prevCount = charCounts.get(ch) ?? 0;
    charCounts.set(ch, prevCount+1);
  }
  return charCounts;
}

const result = countChars('AaBccc');
assert.deepEqual(
  countChars('AaBccc'),
  new Map([
    ['a', 2],
    ['b', 1],
    ['c', 3],
  ])
);

```

### 36.2 遍历 Map

这就是 Map 如何支持迭代的方式：

+   `new Map()` 接受一个键值对的可迭代。这将在我们查看处理 Map 和从 Map 转换时很有用。

+   以下方法返回可迭代的迭代器——其方法将在我们查看处理 Map 时很有用。

    +   `map.keys()`: `map` 的键

    +   `map.values()`: `map` 的值

    +   `map.entries()`: `map` 的条目（键值对）

    +   `map[Symbol.iterator]()`: 与 `map.entries()` 相同

        +   此方法使 `Map` 的实例可迭代。

#### 36.2.1 遍历 Map

Map 可以通过键值对进行迭代。这是遍历它们的一种常见方式：

```js
const map = new Map()
  .set(false, 'no')
  .set(true, 'yes')
;
for (const [key, value] of map) { // (A)
  console.log(JSON.stringify(key) + ' = ' + JSON.stringify(value));
}

```

在行 A 中，我们使用解构来访问迭代器返回的键值对的组件。

输出：

```js
false = "no"
true = "yes"

```

以下示例演示了如何遍历由方法 `.keys()` 返回的可迭代迭代器：

```js
for (const key of map.keys()) {
  console.log(JSON.stringify(key));
}

```

输出：

```js
false
true

```

#### 36.2.2 按插入顺序列出：条目、键、值

Map 记录条目创建的顺序，并在列出键、值或条目时尊重该顺序：

```js
const map1 = new Map([
  ['a', 1],
  ['b', 2],
]);
for (const key of map1.keys()) {
  console.log(JSON.stringify(key));
}

```

输出：

```js
"a"
"b"

```

```js
const map2 = new Map([
  ['b', 2],
  ['a', 1],
]);
for (const key of map2.keys()) {
  console.log(JSON.stringify(key));
}

```

输出：

```js
"b"
"a"

```

按插入顺序列出内容的 Map 有两个好处：

+   当插入顺序很重要时，我们可以使用 Map。

+   在测试中，结果变得更加确定，更容易检查。

### 36.3 从和到 Map 的转换

#### 36.3.1 将键、值、条目转换为数组

一方面，`.keys()`、`.values()` 和 `.entries()` 返回的值是可迭代的——这使我们能够使用 `Array.from()`：

```js
const map = new Map()
  .set(false, 'no')
  .set(true, 'yes')
;

assert.deepEqual(
  Array.from(map.keys()),
  [false, true]
);
assert.deepEqual(
  Array.from(map.values()),
  ['no', 'yes']
);
assert.deepEqual(
  Array.from(map.entries()),
  [
    [false, 'no'],
    [true, 'yes'],
  ]
);

```

另一方面，`.keys()`、`.values()` 和 `.entries()` 返回的值也是迭代器——这使我们能够使用迭代器方法 `.toArray()`：

```js
const map = new Map()
  .set(false, 'no')
  .set(true, 'yes')
;

assert.deepEqual(
  map.keys().toArray(),
  [false, true]
);
assert.deepEqual(
  map.values().toArray(),
  ['no', 'yes']
);
assert.deepEqual(
  map.entries().toArray(),
  [
    [false, 'no'],
    [true, 'yes'],
  ]
);

```

#### 36.3.2 在 Map 和对象之间转换

只要 Map 只使用字符串和符号作为键，我们就可以将其转换为对象（通过 `Object.fromEntries()`）：

```js
const map = new Map([
  ['a', 1],
  ['b', 2],
]);
const obj = Object.fromEntries(map);
assert.deepEqual(
  obj, {a: 1, b: 2}
);

```

我们还可以通过 `Object.entries()` 将对象转换为具有字符串或符号键的 Map：

```js
const obj = {
  a: 1,
  b: 2,
};
const map = new Map(Object.entries(obj));
assert.deepEqual(
  map, new Map([['a', 1], ['b', 2]])
);

```

### 36.4 处理 Map

#### 36.4.1 复制 Map

正如我们所见，Map 可以通过键值对进行迭代。因此，我们可以使用构造函数来创建一个 Map 的副本。这个副本是**浅拷贝**：键和值是相同的；它们自身没有被复制/克隆。

```js
const original = new Map()
  .set(false, 'no')
  .set(true, 'yes')
;
const copy = new Map(original);
assert.deepEqual(original, copy);

```

#### 36.4.2 将多个 Map 合并为单个 Map

没有合并 Maps 的方法，这就是为什么我们必须使用一种解决方案。让我们合并以下两个 Maps：

```js
const map1 = new Map()
  .set(1, '1a')
  .set(2, '1b')
  .set(3, '1c')
;

const map2 = new Map()
  .set(2, '2b')
  .set(3, '2c')
  .set(4, '2d')
;

```

要合并 `map1` 和 `map2`，我们创建一个新的数组，并将 `map1` 和 `map2` 的条目（键值对）展开到其中（通过迭代）。然后我们将数组转换回 Map。所有这些都在行 A 中完成：

```js
const combinedMap = new Map([...map1, ...map2]); // (A)
assert.deepEqual(
  Array.from(combinedMap), // convert to Array for comparison
  [
    [ 1, '1a' ],
    [ 2, '2b' ],
    [ 3, '2c' ],
    [ 4, '2d' ],
  ]
);

```

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：合并 Maps**

`exercises/maps/combine_maps_test.mjs`

#### 36.4.3 通过迭代器方法映射和过滤 Maps (ES2025)

我们可以对数组进行 `.map()` 和 `.filter()` 操作，但对于 Map 没有这样的操作。解决方案是：

1.  将 Map 转换为 [键，值] 对的迭代器。

1.  Map 或过滤迭代器。

1.  将结果转换回 Map。

我们将使用以下 Map 来探索它是如何工作的。

```js
const originalMap = new Map()
  .set(1, 'a')
  .set(2, 'b')
  .set(3, 'c')
;

```

映射 `originalMap`：

```js
const mappedMap = new Map( // step 3
  originalMap.entries() // step 1
  .map(([k, v]) => [k * 2, '_' + v]) // step 2
);
assert.deepEqual(
  mappedMap,
  new Map([[2,'_a'], [4,'_b'], [6,'_c']])
);

```

过滤 `originalMap`：

```js
const filteredMap = new Map( // step 3
  originalMap.entries() // step 1
  .filter(([k, v]) => k < 3) // step 2
);
assert.deepEqual(
  filteredMap,
  new Map([[1,'a'], [2,'b']])
);

```

如果我们不能使用迭代器方法怎么办？那么我们可以通过

+   替换 `originalMap.entries()`

+   使用 `Array.from(originalMap)`。

### 36.5 关于 Maps 键的一些更多细节（高级）

任何值都可以作为键，甚至是一个对象：

```js
const map = new Map();

const KEY1 = {};
const KEY2 = {};

map.set(KEY1, 'hello');
map.set(KEY2, 'world');

assert.equal(map.get(KEY1), 'hello');
assert.equal(map.get(KEY2), 'world');

```

#### 36.5.1 哪些键被认为是相等的？

大多数 Map 操作都需要检查一个值是否等于键之一。它们通过内部操作 [SameValueZero](https://tc39.es/ecma262/#sec-samevaluezero) 来这样做，它的工作方式类似于 `===`，但将 `NaN` 视为等于自身。

因此，我们可以像任何其他值一样在 Maps 中使用 `NaN` 作为键：

```js
> const map = new Map();

> map.set(NaN, 123);
> map.get(NaN)
123

```

不同的对象始终被认为是不同的。这是无法改变的事情（尚无法改变 - 配置键相等性是 TC39 长期路线图上的一个项目）。

```js
> new Map().set({}, 1).set({}, 2).size
2

```

### 36.6 快速参考：`Map`

注意：为了简洁起见，我假设所有键都具有相同的类型 `K`，并且所有值都具有相同的类型 `V`。

#### 36.6.1 `new Map()`

+   `new Map(entries?)` ES6

    ```js
    new Map<K, V>(
      entries?: Iterable<[K, V]>
    )

    ```

    如果我们不提供参数 `entries`，则创建一个空 Map。如果我们提供 [键，值] 对的可迭代对象，则将这些对作为条目添加到 Map 中。例如：

    ```js
    const map = new Map([
      [ 1, 'one' ],
      [ 2, 'two' ],
      [ 3, 'three' ], // trailing comma is ignored
    ]);

    ```

#### 36.6.2 `Map.*`

+   `Map.groupBy(items, computeGroupKey)` ES2024

    ```js
    Map.groupBy<K, T>(
      items: Iterable<T>,
      computeGroupKey: (item: T, index: number) => K,
    ): Map<K, Array<T>>;

    ```

    +   回调 `computeGroupKey` 为每个 `items` 返回一个 *分组键*。

    +   `Map.groupBy()` 的结果是包含以下内容的 Map：

        +   每个条目的键是一个分组键，

        +   其值是一个包含所有具有该分组键的项的数组。

    ```js
    assert.deepEqual(
      Map.groupBy(
        ['orange', 'apricot', 'banana', 'apple', 'blueberry'],
        (str) => str[0] // compute group key
      ),
      new Map()
        .set('o', ['orange'])
        .set('a', ['apricot', 'apple'])
        .set('b', ['banana', 'blueberry'])
    );

    ```

#### 36.6.3 `Map.prototype.*`：处理单个条目

+   `Map.prototype.get(key)` ES6

    返回 `key` 在此 Map 中映射到的 `value`。如果没有在此 Map 中找到键 `key`，则返回 `undefined`。

    ```js
    const map = new Map([[1, 'one'], [2, 'two']]);
    assert.equal(map.get(1), 'one');
    assert.equal(map.get(5), undefined);

    ```

+   `Map.prototype.set(key, value)` ES6

    +   将给定的键映射到给定的值。

    +   如果已经存在一个键为 `key` 的条目，则它将被更新。否则，将创建一个新的条目。

    +   此方法返回 `this`，这意味着我们可以将其链接。

    ```js
    const map = new Map([[1, 'one'], [2, 'two']]);
    map.set(1, 'ONE!') // update an existing entry
       .set(3, 'THREE!') // create a new entry
    ;
    assert.deepEqual(
      Array.from(map.entries()),
      [[1, 'ONE!'], [2, 'two'], [3, 'THREE!']]
    );

    ```

+   `Map.prototype.has(key)` ES6

    返回给定的键是否存在于此 Map 中。

    ```js
    const map = new Map([[1, 'one'], [2, 'two']]);
    assert.equal(map.has(1), true); // key exists
    assert.equal(map.has(5), false); // key does not exist

    ```

+   `Map.prototype.delete(key)` ES6

    如果存在一个键为 `key` 的条目，则该条目被移除并返回 `true`。否则，不发生任何操作并返回 `false`。

    ```js
    const map = new Map([[1, 'one'], [2, 'two']]);
    assert.equal(map.delete(1), true);
    assert.equal(map.delete(5), false); // nothing happens
    assert.deepEqual(
      Array.from(map.entries()),
      [[2, 'two']]
    );

    ```

#### 36.6.4 `Map.prototype`：处理所有条目

+   `get Map.prototype.size` ES6

    返回此 Map 有多少条目。

    ```js
    const map = new Map([[1, 'one'], [2, 'two']]);
    assert.equal(map.size, 2);

    ```

+   `Map.prototype.clear()` ES6

    从此 Map 中移除所有条目。

    ```js
    const map = new Map([[1, 'one'], [2, 'two']]);
    assert.equal(map.size, 2);
    map.clear();
    assert.equal(map.size, 0);

    ```

#### 36.6.5 `Map.prototype`：迭代和循环

在 Map 中迭代和循环发生时，顺序与条目添加到 Map 中的顺序一致。

+   `Map.prototype.entries()` ES6

    返回一个包含此 Map 中每个条目的一个 [键，值] 对的可迭代对象。对是长度为 2 的数组。

    ```js
    const map = new Map([[1, 'one'], [2, 'two']]);
    for (const entry of map.entries()) {
      console.log(entry);
    }

    ```

    输出：

    ```js
    [ 1, 'one' ]
    [ 2, 'two' ]

    ```

+   `Map.prototype.forEach(callback, thisArg?)` ES6

    ```js
    Map.prototype.forEach(
      callback: (value: V, key: K, theMap: Map<K,V>) => void,
      thisArg?: any
    ): void

    ```

    +   第一个参数是一个回调函数，它为 Map 中的每个条目调用一次。

    +   如果提供了 `thisArg`，则对于每次调用，`this` 被设置为它。否则，`this` 被设置为 `undefined`。

    ```js
    const map = new Map([[1, 'one'], [2, 'two']]);
    map.forEach((value, key) => console.log(value, key));

    ```

    输出：

    ```js
    one 1
    two 2

    ```

+   `Map.prototype.keys()` ES6

    返回一个遍历此 Map 中所有键的可迭代对象。

    ```js
    const map = new Map([[1, 'one'], [2, 'two']]);
    for (const key of map.keys()) {
      console.log(key);
    }

    ```

    输出：

    ```js
    1
    2

    ```

+   `Map.prototype.values()` ES6

    返回一个遍历此 Map 中所有值的可迭代对象。

    ```js
    const map = new Map([[1, 'one'], [2, 'two']]);
    for (const value of map.values()) {
      console.log(value);
    }

    ```

    输出：

    ```js
    one
    two

    ```

+   `Map.prototype[Symbol.iterator]()` ES6

    遍历 Maps 的默认方式。与 `map.entries()` 相同。

    ```js
    const map = new Map([[1, 'one'], [2, 'two']]);
    for (const [key, value] of map) {
      console.log(key, value);
    }

    ```

    输出：

    ```js
    1 one
    2 two

    ```

### 36.7 FAQ: Maps

#### 36.7.1 我应该在何时使用 Map，何时使用对象？

如果我们需要一个类似字典的数据结构，其键既不是字符串也不是符号，我们别无选择：我们必须使用 Map。

然而，如果我们的键是字符串或符号，我们必须决定是否使用对象。一个粗略的一般性指南是：

+   是否有一个固定的键集合（在开发时已知）？

    然后使用一个对象 `obj` 并通过固定的键访问值：

    ```js
    const value = obj.key;

    ```

+   键的集合在运行时可以改变吗？

    然后使用一个 Map `map` 并通过存储在变量中的键访问值：

    ```js
    const theKey = 123;
    map.get(theKey);

    ```

#### 36.7.2 当我应该使用对象作为 Map 的键时？

我们通常希望 Map 键通过值进行比较（如果两个键的内容相同，则认为它们相等）。这排除了对象。然而，对象作为键有一个用例：将数据外部附加到对象上。但这个用例更适合 WeakMaps，其中条目不会阻止键被垃圾回收（有关详细信息，请参阅下一章)。

#### 36.7.3 为什么 Maps 保留条目的插入顺序？

原则上，Map 条目是无序的。排序条目的主要原因是为了使列出条目、键或值的操作是确定的。这有助于，例如，测试。

#### 36.7.4 为什么 Maps 有 `.size`，而 Arrays 有 `.length`？

在 JavaScript 中，可索引序列（如数组和字符串）有 `.length`，而不索引集合（如 Maps 和 Sets）有 `.size`：

+   `.length` 基于索引；它始终是最高索引加一。

+   `.size` 计算集合中元素的数量。
