# 6 新 JavaScript 特性

> 原文：[`exploringjs.com/js/book/ch_new-javascript-features.html`](https://exploringjs.com/js/book/ch_new-javascript-features.html)

1.  6.1 ECMAScript 2025 中的新特性

1.  6.2 ECMAScript 2024 中的新特性

1.  6.3 ECMAScript 2023 中的新特性

1.  6.4 ECMAScript 2022 中的新特性

1.  6.5 ECMAScript 2021 中的新特性

1.  6.6 ECMAScript 2020 中的新特性

1.  6.7 ECMAScript 2019 中的新特性

1.  6.8 ECMAScript 2018 中的新特性

1.  6.9 ECMAScript 2017 中的新特性

1.  6.10 ECMAScript 2016 中的新特性

1.  6.11 本章来源

本章按时间顺序反向列出最近 ECMAScript 版本的新特性。它结束于 ES6（ES2015）之前：ES2016 是 ECMAScript 的第一个真正增量发布版本——这就是为什么 ES6 在这里列出的功能太多。如果您想了解更早的版本：

+   我的书[“Exploring ES6”](https://exploringjs.com/es6.html)描述了 ES6（ES2015）中添加了哪些内容。

+   我的书[“Speaking JavaScript”](https://exploringjs.com/es5/)描述了 ES5 的所有特性——因此它是一个有用的时间胶囊。

### 6.1 ECMAScript 2025 中的新特性

+   导入属性为导入非 JavaScript 工件提供了语法基础。首先支持的这类工件是 JSON 模块：

    ```js
    // Static import
    import configData1 from './config-data.json' with { type: 'json' };

    // Dynamic import
    const configData2 = await import(
      './config-data.json', { with: { type: 'json' } }
    );

    ```

    `with`之后的对象字面量语法用于指定导入属性。`type`是一个导入属性。

+   迭代器辅助方法让我们可以更灵活地使用迭代器：

    ```js
    const arr = ['a', '', 'b', '', 'c', '', 'd', '', 'e'];
    assert.deepEqual(
      arr.values() // creates an iterator
        .filter(x => x.length > 0)
        .drop(1)
        .take(3)
        .map(x => `=${x}=`)
        .toArray()
      ,
      ['=b=', '=c=', '=d=']
    );

    ```

    迭代器方法是如何在数组方法之上进行改进的？

    +   迭代器方法可以与任何可迭代数据结构一起使用——例如，它们允许我们过滤和映射`Set`和`Map`数据结构。

    +   迭代器方法不会创建中间数组并增量计算数据。这对于大量数据来说很有用：

        +   使用迭代器方法，所有方法都应用于第一个值，然后是第二个值，依此类推。

        +   使用数组方法，首先将第一个方法应用于所有值，然后第二个方法应用于所有结果，依此类推。

+   用于合并集合和检查集合关系的方法：

    +   合并集合：

        +   `Set.prototype.intersection(other)`

        +   `Set.prototype.union(other)`

        +   `Set.prototype.difference(other)`

        +   `Set.prototype.symmetricDifference(other)`

    +   检查集合关系：

        +   `Set.prototype.isSubsetOf(other)`

        +   `Set.prototype.isSupersetOf(other)`

        +   `Set.prototype.isDisjointFrom(other)`

    示例：

    ```js
    assert.deepEqual(
      new Set(['a', 'b', 'c']).union(new Set(['b', 'c', 'd'])),
      new Set(['a', 'b', 'c', 'd'])
    );
    assert.deepEqual(
      new Set(['a', 'b', 'c']).intersection(new Set(['b', 'c', 'd'])),
      new Set(['b', 'c'])
    );
    assert.deepEqual(
      new Set(['a', 'b']).isSubsetOf(new Set(['a', 'b', 'c'])),
      true
    );
    assert.deepEqual(
      new Set(['a', 'b', 'c']).isSupersetOf(new Set(['a', 'b'])),
      true
    );

    ```

+   `RegExp.escape()`将文本转义，以便可以在正则表达式中使用——例如，以下代码移除了`str`中所有未引用的`text`出现：

    ```js
    function removeUnquotedText(str, text) {
      const regExp = new RegExp(
        `(?<!“)${RegExp.escape(text)}(?!”)`,
        'gu'
      );
      return str.replaceAll(regExp, '•');
    }
    assert.equal(
      removeUnquotedText('“yes” and yes and “yes”', 'yes'),
      '“yes” and • and “yes”'
    );

    ```

+   正则表达式模式修饰符（内联标志） 允许我们将标志应用于正则表达式的部分（而不是整个正则表达式）——例如，在以下正则表达式中，标志 `i` 仅应用于“HELLO”：

```js
> /^x(?i:HELLO)x$/.test('xHELLOx')
true
> /^x(?i:HELLO)x$/.test('xhellox')
true
> /^x(?i:HELLO)x$/.test('XhelloX')
false

```

+   重复命名的捕获组：我们现在可以使用相同的组名两次——只要它出现在不同的备选方案中：

    ```js
    const RE = /(?<chars>a+)|(?<chars>b+)/v;
    assert.deepEqual(
      RE.exec('aaa').groups,
      {
        chars: 'aaa',
        __proto__: null,
      }
    );
    assert.deepEqual(
      RE.exec('bb').groups,
      {
        chars: 'bb',
        __proto__: null,
      }
    );

    ```

+   Promise.try() 允许我们以非纯异步的代码开始 Promise 链——例如：

    ```js
    function computeAsync() {
     return Promise.try(() => {
     const value = syncFuncMightThrow();
     return asyncFunc(value);
     });
    }

    ```

+   支持 16 位浮点数（float16）：

    +   Math.f16round() 方法

    +   Typed Arrays API 的新元素类型:

        +   `Float16Array`

        +   `DataView.prototype.getFloat16()`

        +   `DataView.prototype.setFloat16()`

### 6.2 新增于 ECMAScript 2024

+   分组同步可迭代对象:

    `Map.groupBy()` 将可迭代对象的项分组到 Map 条目中，其键由回调函数提供：

    ```js
    assert.deepEqual(
      Map.groupBy([0, -5, 3, -4, 8, 9], x => Math.sign(x)),
      new Map()
        .set(0, [0])
        .set(-1, [-5,-4])
        .set(1, [3,8,9])
    );

    ```

    此外，还有 `Object.groupBy()`，它生成一个对象而不是 Map：

    ```js
    assert.deepEqual(
      Object.groupBy([0, -5, 3, -4, 8, 9], x => Math.sign(x)),
      {
        '0': [0],
        '-1': [-5,-4],
        '1': [3,8,9],
        __proto__: null,
      }
    );

    ```

+   Promise.withResolvers() 提供了一种创建我们想要解决的 Promise 的新方法：

    ```js
    const { promise, resolve, reject } = Promise.withResolvers();

    ```

+   新的正则表达式标志 `/v`（`.unicodeSets`） 启用这些功能：

    +   Unicode 字符串属性的转义（😵‍💫 由三个代码点组成）：

        ```js
        // Previously: Unicode code point property `Emoji` via /u
        assert.equal(
          /^\p{Emoji}$/u.test('😵‍💫'), false
        );
        // New: Unicode string property `RGI_Emoji` via /v
        assert.equal(
          /^\p{RGI_Emoji}$/v.test('😵‍💫'), true
        );

        ```

    +   字符类中的字符串字面量通过 `\q{}`：

        ```js
        > /^[\q{😵‍💫}]$/v.test('😵‍💫')
        true
        > /^[\q{abc|def}]$/v.test('abc')
        true

        ```

    +   字符类集合的集合操作：

        ```js
        > /^[\w--[a-g]]$/v.test('a')
        false
        > /^[\p{Number}--[0-9]]$/v.test('٣')
        true
        > /^[\p{RGI_Emoji}--\q{😵‍💫}]$/v.test('😵‍💫')
        false

        ```

    +   如果通过 `[^···]` 取消了 Unicode 属性转义，则与 `/i` 的匹配得到改进

+   ArrayBuffer 获得了两个新功能：

    +   它们可以在原地 调整大小：

        ```js
        const buf = new ArrayBuffer(2, {maxByteLength: 4});
        // `typedArray` starts at offset 2
        const typedArray = new Uint8Array(buf, 2);
        assert.equal(
          typedArray.length, 0
        );
        buf.resize(4);
        assert.equal(
          typedArray.length, 2
        );

        ```

    +   它们获得一个 `.transfer()` 方法来 转让 它们。

+   SharedArrayBuffers 可以调整大小，但它们只能增长，不能缩小。它们不可转让，因此不获得 `ArrayBuffers` 获得的方法 `.transfer()`。

+   两个新方法帮助我们确保字符串格式良好（与 UTF-16 代码单元相关）：

    +   String 方法 `.isWellFormed()` 检查 JavaScript 字符串是否格式良好，并且不包含任何 *单独的代理字符*。

    +   String 方法 `.toWellFormed()` 返回一个副本，其中每个单独的代理字符被代码单元 0xFFFD 替换（它代表具有相同数字的代码点，其名称为“替换字符”）。因此，结果是格式良好的。

+   `Atomics.waitAsync()` 允许我们异步等待共享内存的变化。其功能超出了本书的范围。有关更多信息，请参阅 [MDN 网络文档](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/waitAsync)。

### 6.3 新增于 ECMAScript 2023

+   “通过复制更改数组”：数组和类型化数组获得新的非破坏性方法，在更改之前复制接收器：

    +   `.toReversed()` 是 `.reverse()` 的非破坏性版本：

        ```js
        const original = ['a', 'b', 'c'];
        const reversed = original.toReversed();
        assert.deepEqual(reversed, ['c', 'b', 'a']);
        // The original is unchanged
        assert.deepEqual(original, ['a', 'b', 'c']);

        ```

    +   `.toSorted()` 是 `.sort()` 的非破坏性版本：

        ```js
        const original = ['c', 'a', 'b'];
        const sorted = original.toSorted();
        assert.deepEqual(sorted, ['a', 'b', 'c']);
        // The original is unchanged
        assert.deepEqual(original, ['c', 'a', 'b']);

        ```

    +   `.toSpliced()` 是 `.splice()` 的非破坏性版本：

        ```js
        const original = ['a', 'b', 'c', 'd'];
        const spliced = original.toSpliced(1, 2, 'x');
        assert.deepEqual(spliced, ['a', 'x', 'd']);
        // The original is unchanged
        assert.deepEqual(original, ['a', 'b', 'c', 'd']);

        ```

    +   `.with()` 是使用方括号设置值的非破坏性版本：

        ```js
        const original = ['a', 'b', 'c'];
        const updated = original.with(1, 'x');
        assert.deepEqual(updated, ['a', 'x', 'c']);
        // The original is unchanged
        assert.deepEqual(original, ['a', 'b', 'c']);

        ```

+   “从数组末尾开始查找数组”：数组和类型化数组获得两个新方法：

    +   `.findLast()` 与 `.find()` 类似，但开始从数组的末尾搜索：

        ```js
        > ['', 'a', 'b', ''].findLast(s => s.length > 0)
        'b'

        ```

    +   `.findLastIndex()` 与 `.findIndex()` 类似，但开始从数组的末尾搜索：

        ```js
        > ['', 'a', 'b', ''].findLastIndex(s => s.length > 0)
        2

        ```

+   符号作为 WeakMap 键：在此功能之前，只有对象可以用作 WeakMap 中的键。此功能还允许我们使用符号——除了 *已注册的符号*（通过 `Symbol.for()` 创建）。

+   “Hashbang 语法”：JavaScript 现在忽略文件的第一行，如果它以哈希 (`#`) 和感叹号 (`!`) 开头。一些 JavaScript 运行时，如 Node.js，已经这样做了很长时间。现在它也成为语言本身的一部分。这是一个“hashbang”行的例子：

    ```js
    #!/usr/bin/env node

    ```

### 6.4 新增于 ECMAScript 2022

+   类的新成员：

    +   属性（公共槽）现在可以通过以下方式创建：

        +   实例公共字段

        +   静态公共字段

    +   私有槽是新的，可以通过以下方式创建：

        +   私有字段（实例私有字段和静态私有字段）

        +   私有方法和访问器（非静态和静态）

    +   静态初始化块

+   私有槽检查（“私有字段的舒适品牌检查”）：以下表达式检查 `obj` 是否有一个私有槽 `#privateSlot`：

    ```js
    #privateSlot in obj

    ```

+   模块中的顶层 `await`：我们现在可以在模块的顶层使用 `await`，不再需要进入异步函数或方法。

+   错误原因：`Error` 及其子类现在允许我们指定哪个错误导致了当前错误：

    ```js
    new Error('Something went wrong', {cause: otherError})

    ```

+   索引值的方法 `.at()` 允许我们在给定的索引处读取一个元素（类似于中括号操作符 `[]`），并支持负索引（与中括号操作符不同）。

    ```js
    > ['a', 'b', 'c'].at(0)
    'a'
    > ['a', 'b', 'c'].at(-1)
    'c'

    ```

    以下“可索引”类型具有 `.at()` 方法：

    +   `string`

    +   `Array`

    +   所有类型化数组类：`Uint8Array` 等。

+   正则表达式匹配索引：如果我们向正则表达式添加一个标志，使用它会产生记录每个分组捕获的起始和结束索引的匹配对象。

+   `Object.hasOwn(obj, propKey)` 提供了一种安全的方式来检查对象 `obj` 是否具有键 `propKey` 的自有属性。

### 6.5 ECMAScript 2021 新特性

+   `String.prototype.replaceAll()` 允许我们替换正则表达式或字符串的所有匹配项（`.replace()` 只替换字符串的第一个出现）：

    ```js
    > 'abbbaab'.replaceAll('b', 'x')
    'axxxaax'

    ```

+   `Promise.any()` 和 `AggregateError`：`Promise.any()` 返回一个 Promise，当可迭代中的第一个 Promise 完成（fulfilled）时，它就会完成。如果只有拒绝（rejections），它们会被放入一个 `AggregateError` 中，该错误成为拒绝值。

    当我们只对多个 Promise 中第一个完成的 Promise 感兴趣时，我们使用 `Promise.any()`。

+   逻辑赋值运算符：

    ```js
    a ||= b
    a &&= b
    a ??= b

    ```

+   下划线 (`_`) 作为分隔符在：

    +   数字字面量：`123_456.789_012`

    +   大整数字面量：`6_000_000_000_000_000_000_000_000n`

+   WeakRefs：这个特性超出了本书的范围。引用其提案[（https://github.com/tc39/proposal-weakrefs）]表示：

    +   [此提案] 包含两个主要的新功能：

        +   使用 `WeakRef` 类创建对对象的弱引用

        +   在对象被垃圾回收后运行用户定义的终结器，使用 `FinalizationRegistry` 类

    +   正确使用需要仔细思考，如果可能的话，最好避免使用。

+   `Array.prototype.sort` 自 ES2019 起就是稳定的。在 ES2021 中，“[它]变得更加精确，减少了导致实现定义排序顺序的情况数量” [[来源](https://tc39.es/ecma262/#sec-intro)]。更多信息，请参阅[此改进的 pull request](https://github.com/tc39/ecma262/pull/1585)。

### 6.6 ECMAScript 2020 新特性

+   新模块功能：

    +   通过 `import()` 动态导入：正常的 `import` 语句是静态的：我们只能在模块的顶层使用它，并且其模块指定器是一个固定的字符串。`import()` 改变了这一点。它可以在任何地方使用（包括条件语句），并且我们可以计算其参数。

    +   `import.meta` 包含当前模块的元数据。它第一个广泛支持的属性是 `import.meta.url`，其中包含当前模块文件的 URL。

    +   命名空间重新导出：以下表达式将模块 `'mod'` 的所有导出导入到命名空间对象 `ns` 中，并导出该对象。

        ```js
        export * as ns from 'mod';

        ```

+   可选链用于属性访问和方法调用。可选链的一个例子是：

    ```js
    value?.prop

    ```

    如果 `value` 是 `undefined` 或 `null`，则此表达式求值为 `undefined`。否则，它求值为 `value.prop`。这个特性在属性读取链中特别有用，其中一些属性可能不存在。

+   空值合并运算符（`??`）:

    ```js
    value ?? defaultValue

    ```

    如果 `value` 是 `undefined` 或 `null`，则此表达式为 `defaultValue`，否则为 `value`。这个运算符允许我们在某些东西缺失时使用默认值。

    之前在这个情况下使用的是逻辑或运算符（`||`），但在这里它有缺点，因为它在左侧是假值时返回默认值（这并不总是正确的）。

+   大整数 – 可任意精度的整数：BigInt 是一种新的原始类型。它支持可以任意大的整数（它们的存储空间会根据需要增长）。

+   `String.prototype.matchAll()`：如果标志 `/g` 没有设置，这个方法会抛出异常，并返回一个包含给定字符串中所有匹配对象的可迭代对象。

+   `Promise.allSettled()` 接收一个 Promise 的可迭代对象。它返回一个 Promise，一旦所有输入的 Promise 都已解决，它就会实现。实现值是一个包含每个输入 Promise 的对象的数组 - 要么是：

    +   `{ status: 'fulfilled', value: «fulfillment value» }`

    +   `{ status: 'rejected', reason: «rejection value» }`

+   `globalThis` 提供了一种在浏览器和服务器端平台（如 Node.js 和 Deno）上访问全局对象的方法。

+   `for-in` 机制：这个特性超出了本书的范围。有关更多信息，请参阅[其提案](https://github.com/tc39/proposal-for-in-order)。

+   命名空间重新导出:

    ```js
    export * as ns from './internal.mjs';

    ```

### 6.7 新增于 ECMAScript 2019

+   数组方法 `.flatMap()` 的行为类似于 `.map()`，但允许回调返回包含零个或多个值的数组。然后返回的数组会被连接，成为 `.flatMap()` 的结果。用例包括：

    +   同时进行过滤和映射

    +   将单个输入值映射到多个输出值

+   数组方法 `.flat()` 将嵌套数组转换为扁平数组。可选地，我们可以告诉它应该在哪个嵌套深度停止扁平化。

+   `Object.fromEntries()` 从一个遍历 *entries* 的可迭代对象创建一个对象。每个条目是一个包含属性键和属性值的两个元素的数组。

+   字符串方法：`.trimStart()` 和 `.trimEnd()` 的行为类似于 `.trim()`，但只删除字符串开头或结尾的空白字符。

+   可选的 `catch` 绑定：如果我们不使用它，现在可以省略 `catch` 子句的参数。

+   Symbol.prototype.description 是一个用于读取符号描述的 getter。之前，描述包含在 `.toString()` 的结果中，但无法单独访问。

+   `.sort()` 方法对于数组和类型化数组现在是**稳定的**：如果元素在排序时被认为是相等的，那么排序不会改变这些元素的顺序（相对于彼此）。

这些 ES2019 功能超出了本书的范围：

+   JSON 超集：参见 [2ality 博客文章](https://2ality.com/2019/01/json-superset.html)。

+   有效的 `JSON.stringify()`：参见 [2ality 博客文章](https://2ality.com/2019/01/well-formed-stringify.html)。

+   `Function.prototype.toString()` 修订：参见 [2ality 博客文章](https://2ality.com/2016/08/function-prototype-tostring.html)。

### 6.8 新增于 ECMAScript 2018

+   异步迭代 是同步迭代的异步版本。它基于 Promises：

    +   对于同步迭代器，我们可以立即访问每个项目。对于异步迭代器，我们必须 `await` 之后才能访问一个项目。

    +   对于同步迭代器，我们使用 `for-of` 循环。对于异步迭代器，我们使用 `for-await-of` 循环。

+   对象字面量扩展：通过在对象字面量中使用扩展（`...`），我们可以将另一个对象的属性复制到当前对象中。一个用例是创建对象 `obj` 的浅拷贝：

    ```js
    const shallowCopy = {...obj};

    ```

+   剩余属性（解构）：当对值进行对象解构时，我们现在可以使用剩余语法（`...`）来获取对象中所有之前未提及的属性。

    ```js
    const {a, ...remaining} = {a: 1, b: 2, c: 3};
    assert.deepEqual(remaining, {b: 2, c: 3});

    ```

+   Promise.prototype.finally() 与 try-catch-finally 语句的 `finally` 子句相关——类似于 Promise 方法 `.then()` 与 `try` 子句以及 `.catch()` 与 `catch` 子句的关系。

    换句话说：`.finally()` 的回调无论 Promise 是否被实现或拒绝都会执行。

+   新的正则表达式功能：

    +   正则表达式命名字符组：除了通过数字访问组之外，我们现在可以命名它们并通过名称访问：

        ```js
        const matchObj = '---756---'.match(/(?<digits>[0-9]+)/)
        assert.equal(matchObj.groups.digits, '756');

        ```

    +   正向前瞻断言的 `RegExp` 补充了前瞻断言：

        +   正向前瞻：`(?<=X)` 匹配如果当前位置之前是 `'X'`。

        +   负向前瞻：`(?<!X)` 匹配如果当前位置不是由 `'(?<!X)'` 预先。

    +   正则表达式的 `s`（点全部）标志。如果此标志处于活动状态，点匹配行终止符（默认情况下不匹配）。

    +   RegExp Unicode 属性转义 在匹配 Unicode 代码点集合时赋予我们更多能力 - 例如：

        ```js
        > /^\p{Lowercase_Letter}+$/u.test('aüπ')
        true
        > /^\p{White_Space}+$/u.test('\n \t')
        true
        > /^\p{Script=Greek}+$/u.test('ΩΔΨ')
        true

        ```

+   模板字面量修订 允许在标记模板中使用包含反斜杠的文本，这在字符串字面量中是非法的 - 例如：

    ```js
    windowsPath`C:\uuu\xxx\111`
    latex`\unicode`

    ```

### 6.9 新增于 ECMAScript 2017

+   异步函数 (`async/await`) 允许我们使用类似同步的语法来编写异步代码。

+   Object.values() 返回一个包含给定对象所有可枚举字符串键属性值的数组。

+   Object.entries() 返回一个包含给定对象所有可枚举字符串键属性键值对的数组。每个键值对编码为一个包含两个元素的数组。

+   字符串填充：字符串方法 `.padStart()` 和 `.padEnd()` 在接收器足够长之前插入填充文本：

    ```js
    > '7'.padStart(3, '0')
    '007'
    > 'yes'.padEnd(6, '!')
    'yes!!!'

    ```

+   函数参数列表和调用中的尾随逗号：自 ES3 起允许在数组字面量中使用尾随逗号，自 ES5 起允许在对象字面量中使用，现在也允许在函数调用和方法调用中使用。

+   Object.getOwnPropertyDescriptors() 允许我们通过具有属性描述符的对象来定义属性：

+   功能“共享内存和原子操作”超出了本书的范围。有关更多信息，请参阅：

    +   MDN Web Docs 上的 [SharedArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) 和 [Atomics](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics) 文档。

    +   [ECMAScript 提案“共享内存和原子操作”](https://github.com/tc39/proposal-ecmascript-sharedmem)

### 6.10 新增于 ECMAScript 2016

+   Array.prototype.includes() 检查数组是否包含指定的值。

+   指数运算符 (`**`)：

    ```js
    > 4 ** 2
    16

    ```

### 6.11 本章来源

ECMAScript 功能列表来自 [TC39 完成提案页面](https://github.com/tc39/proposals/blob/main/finished-proposals.md)。
