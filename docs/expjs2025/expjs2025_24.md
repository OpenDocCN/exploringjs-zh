# 20 大整数 – ES2020 的任意精度整数（高级）

> 原文：[`exploringjs.com/js/book/ch_bigints.html`](https://exploringjs.com/js/book/ch_bigints.html)

1.  20.1 为什么使用大整数?

1.  20.2 大整数

    1.  20.2.1 超过 53 位整数的范围

    1.  20.2.2 示例：使用大整数

1.  20.3 大整数字面量

    1.  20.3.1 大整数字面量中的下划线（`_`）作为分隔符（ES2021）

1.  20.4 重用数字运算符用于大整数（重载）

    1.  20.4.1 算术运算符

    1.  20.4.2 松散相等（`==`）和不相等（`!=`）

    1.  20.4.3 严格相等（`===`）和不相等（`!==`）

    1.  20.4.4 排序运算符

    1.  20.4.5 位运算符（高级）

1.  20.5 包装构造函数 `BigInt`

    1.  20.5.1 `BigInt` 作为构造函数和函数

    1.  20.5.2 `BigInt.prototype.*` 方法

    1.  20.5.3 `BigInt.*` 方法：类型转换

1.  20.6 将大整数强制转换为其他原始类型

1.  20.7 64 位值的 Typed Array 和 DataView 操作

1.  20.8 大整数与 JSON

    1.  20.8.1 将大整数转换为字符串

    1.  20.8.2 解析大整数

1.  20.9 常见问题：大整数

    1.  20.9.1 我如何决定何时使用数字和何时使用大整数？

    1.  20.9.2 为什么不能像大整数那样简单地增加数字的精度？

在本章中，我们将探讨 *大整数*，JavaScript 中的整数，其存储空间根据需要增长和缩小。

### 20.1 为什么使用大整数?

在 ECMAScript 2020 之前，JavaScript 处理整数的方式如下：

+   在那时，只有一种浮点数和整数的类型：64 位浮点数（IEEE 754 双精度）。

+   在底层，大多数 JavaScript 引擎透明地支持整数：如果一个数字没有小数位并且在一个特定的范围内，它可以在内部作为一个真正的整数存储。这种表示称为 *小整数*，通常适合 32 位。例如，V8 引擎 64 位版本的整数范围是从 −2³¹ 到 2³¹−1 ([来源](https://medium.com/fhinkel/v8-internals-how-small-is-a-small-integer-e0badc18b6da))。

+   JavaScript 数字也可以表示小整数范围之外的整数，作为浮点数。在这里，安全范围是±53 位。有关此主题的更多信息，请参阅“安全整数”（§18.9.4）。

有时，我们需要比有符号的 53 位更多的位数 – 例如：

+   X（以前是 Twitter）使用 64 位整数作为帖子的 ID（[来源](https://developer.x.com/en/docs/twitter-ids)）。在 JavaScript 中，这些 ID 必须以字符串的形式存储。

+   金融技术使用所谓的*大整数*（任意精度的整数）来表示货币金额。内部，金额被乘以，使得小数点消失。例如，美元金额乘以 100，使得美分消失。

### 20.2 大整数

*大整数*是整数的一个原始数据类型。大整数没有固定的位存储大小；它们的大小适应于它们所表示的整数：

+   小整数用比大整数更少的位表示。

+   可表示的整数没有负的下限或正的上限。

大整数字面量是一系列一个或多个数字，后跟一个 `n` – 例如：

```js
123n

```

`-` 和 `*` 等运算符被重载，并可以与大整数一起使用：

```js
> 123n * 456n
56088n

```

大整数是原始值。`typeof` 对它们返回一个不同的结果：

```js
> typeof 123n
'bigint'

```

#### 20.2.1 整数超过 53 位

JavaScript 数字在内部表示为一个分数乘以一个指数（有关详细信息，请参阅“背景：浮点精度”（§18.8））。因此，如果我们超过最高的*安全整数* 2⁵³−1，仍然还有*一些*整数可以表示，但它们之间有间隔：

```js
> 2**53 // can be represented but same as next number
9007199254740992
> 2**53 + 1 // wrong
9007199254740992

```

大整数使我们能够超过 53 位：

```js
> 2n**53n
9007199254740992n
> 2n**53n + 1n
9007199254740993n

```

#### 20.2.2 示例：使用大整数

这就是使用大整数的样子（基于提案中的示例的代码）：

```js
/**
 * Takes a bigint as an argument and returns a bigint
 */
function nthPrime(nth) {
  if (typeof nth !== 'bigint') {
    throw new TypeError();
  }
  function isPrime(p) {
    for (let i = 2n; i < p; i++) {
      if (p % i === 0n) return false;
    }
    return true;
  }
  for (let i = 2n; ; i++) {
    if (isPrime(i)) {
      if (--nth === 0n) return i;
    }
  }
}

assert.deepEqual(
  [1n, 2n, 3n, 4n, 5n].map(nth => nthPrime(nth)),
  [2n, 3n, 5n, 7n, 11n]
);

```

### 20.3 大整数字面量

与数字字面量类似，大整数字面量支持多种基数：

+   十进制：`123n`

+   十六进制：`0xFFn`

+   二进制：`0b1101n`

+   八进制：`0o777n`

负大整数通过在前面加一元减号运算符产生：`-0123n`

#### 20.3.1 大整数字面量中的下划线（`_`）作为分隔符（ES2021）

与数字字面量类似，我们可以在大整数字面量中使用下划线（`_`）作为分隔符：

```js
const massOfEarthInKg = 6_000_000_000_000_000_000_000_000n;

```

大整数常用于金融技术领域表示货币。分隔符在这里也有帮助：

```js
const priceInCents = 123_000_00n; // 123 thousand dollars

```

与数字字面量一样，有两个限制：

+   我们只能在两个数字之间放置一个下划线。

+   我们在一行中最多只能使用一个下划线。

### 20.4 为大整数重用数字运算符（重载）

对于大多数运算符，我们不允许混合大整数和数字。如果我们这样做，会抛出异常：

```js
> 2n + 1
TypeError: Cannot mix BigInt and other types, use explicit conversions

```

这条规则的原因是，没有一种通用的方法可以将数字和大整数强制转换为同一类型：数字无法表示超过 53 位的整数，大整数无法表示分数。因此，这些异常警告我们注意可能引起意外结果的错误。

考虑以下表达式：

```js
2**53 + 1n

```

结果应该是 `9007199254740993n` 还是 `9007199254740992`？

也不清楚以下表达式的结果应该是什么：

```js
2n**53n * 3.3

```

#### 20.4.1 算术运算符

二进制 `+`、二进制 `-`、`*`、`**` 的工作方式符合预期：

```js
> 7n * 3n
21n

```

混合大整数和字符串是可以的：

```js
> 6n + ' apples'
'6 apples'

```

`/` 和 `%` 通过去除小数部分进行四舍五入（类似于 `Math.trunc()`）：

```js
> 1n / 2n
0n

```

一元 `-` 的工作方式符合预期：

```js
> -(-64n)
64n

```

一元 `+` 不支持大整数，因为许多代码依赖于它将操作数强制转换为数字：

```js
> +23n
TypeError: Cannot convert a BigInt value to a number

```

#### 20.4.2 宽松相等（`==`）和不相等（`!=`）

宽松相等（`==`）和不相等（`!=`）强制转换值：

```js
> 0n == false
true
> 1n == true
true

> 123n == 123
true

> 123n == '123'
true

```

#### 20.4.3 严格相等（`===`）和不相等（`!==`）

严格相等（`===`）和不相等（`!==`）只有在它们具有相同类型时才认为值相等：

```js
> 123n === 123
false
> 123n === 123n
true

```

#### 20.4.4 排序运算符

排序运算符 `<`、`>`、`>=`、`<=` 的工作方式符合预期：

```js
> 17n <= 17n
true
> 3n > -1n
true

```

比较大整数和数字不会造成任何风险。因此，我们可以混合大整数和数字：

```js
> 3n > -1
true

```

![“练习”图标](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：将基于数字的代码转换为大整数**

`exercises/bigints/gcd-bigint_test.mjs`

#### 20.4.5 位运算符（高级）

##### 20.4.5.1 数字的位运算符

位运算符将数字解释为 32 位整数。这些整数要么是无符号的，要么是有符号的。如果它们是有符号的，整数的负数是其二进制补码：如果我们将其整数与其二进制补码相加并忽略溢出（32 位之外的数字），则结果是零。

```js
> 2**32 - 1 >> 0 // 0b11111111111111111111111111111111
-1

```

如果我们将由 32 个 1 组成的二进制数加 1，我们得到一个 1 后面跟着 32 个 0。超过 32 位的所有内容都是溢出，这意味着那个数字是零。

我们使用了有符号右移运算符（`>>`）：我们将左操作数左移了 0 位，将其转换为 Int32（有符号）并再次转换为数字。

由于这些整数具有固定的大小，它们的最高位表示它们的符号：

```js
> 2**31 >> 0 // highest bit is 1
-2147483648
> 2**31 - 1 >> 0 // highest bit is 0
2147483647

```

##### 20.4.5.2 大整数的位运算符

对于大整数，位运算符将负号解释为无限大的二进制补码 – 例如：

+   `-1` 是 `···111111`（1 无限向左扩展）

+   `-2` 是 `···111110`

+   `-3` 是 `···111101`

+   `-4` 是 `···111100`

也就是说，负号更像是一个外部标志，而不是作为实际的位来表示。

##### 20.4.5.3 位非运算符（`~`）

位非运算符（`~`）反转所有位：

```js
assert.equal(
  ~0b10n,
  -3n // ···111101
);
assert.equal(
  ~-2n, // ···111110
  1n
);

```

##### 20.4.5.4 二进制位运算符（`&`、`|`、`^`）

将二进制位运算符应用于大整数的工作方式与应用于数字类似：

```js
> (0b1010n |  0b0111n).toString(2)
'1111'
> (0b1010n &  0b0111n).toString(2)
'10'

> (0b1010n | -1n).toString(2)
'-1'
> (0b1010n & -1n).toString(2)
'1010'

```

##### 20.4.5.5 位有符号移位运算符 (`<<` 和 `>>`)

大整数的有符号移位运算符保留数字的符号：

```js
> 2n << 1n
4n
> -2n << 1n
-4n

> 2n >> 1n
1n
> -2n >> 1n
-1n

```

回想一下，`-1n` 是一个无限向左延伸的 1 的序列。这就是为什么左移它不会改变它的原因：

```js
> -1n >> 20n
-1n

```

##### 20.4.5.6 位无符号右移运算符 (`>>>`)

大整数没有无符号右移运算符：

```js
> 2n >>> 1n
TypeError: BigInts have no unsigned right shift, use >> instead

```

为什么？无符号右移位背后的想法是将一个零从“左边”移入。换句话说，假设二进制位是有限数量的。

然而，对于负大整数（尤其是负数），没有“左边”；它们的二进制位无限延伸。

有符号右移位即使对于无限数量的数字也能正常工作，因为最高位被保留。因此，它可以适应大整数。

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：通过大整数实现位集**

`exercises/bigints/bit-set_test.mjs`

### 20.5 大整数包装构造函数 `BigInt`

与数字类似，大整数有相关的包装构造函数 `BigInt`。

#### 20.5.1 大整数作为构造函数和函数

+   `new BigInt()`：抛出 `TypeError`。

+   `BigInt(x)` 将任意值 `x` 转换为大整数。这与 `Number()` 类似，但有几个不同之处，这些不同之处在表 20.1 中总结，并在以下小节中详细解释。

| `x` | `BigInt(x)` |
| --- | --- |
| `undefined` | 抛出 `TypeError` |
| `null` | 抛出 `TypeError` |
| 布尔值 | `false` → `0n`，`true` → `1n` |
| 数字 | 示例：`123` → `123n` |
|  | 非整数 → 抛出 `RangeError` |
| 大整数 | `x`（无变化） |
| 字符串 | 示例：`'123'` → `123n` |
|  | 不可解析 → 抛出 `SyntaxError` |
| 符号 | 抛出 `TypeError` |
| 对象 | 可配置（例如，通过 `.valueOf()`） |

表 20.1：将值转换为大整数。

##### 20.5.1.1 转换 `undefined` 和 `null`

如果 `x` 是 `undefined` 或 `null`，则抛出 `TypeError`：

```js
> BigInt(undefined)
TypeError: Cannot convert undefined to a BigInt
> BigInt(null)
TypeError: Cannot convert null to a BigInt

```

##### 20.5.1.2 转换字符串

如果一个字符串不表示整数，`BigInt()` 抛出 `SyntaxError`（而 `Number()` 返回错误值 `NaN`）：

```js
> BigInt('abc')
SyntaxError: Cannot convert abc to a BigInt

```

不允许使用后缀 `'n'`：

```js
> BigInt('123n')
SyntaxError: Cannot convert 123n to a BigInt

```

大整数字面量的所有基数都是允许的：

```js
> BigInt('123')
123n
> BigInt('0xFF')
255n
> BigInt('0b1101')
13n
> BigInt('0o777')
511n

```

##### 20.5.1.3 非整数数字产生异常

```js
> BigInt(123.45)
RangeError: The number 123.45 cannot be converted to a BigInt because
it is not an integer
> BigInt(123)
123n

```

##### 20.5.1.4 转换对象

对象转换为大整数的转换方式可以配置——例如，通过重写 `.valueOf()`：

```js
> BigInt({valueOf() {return 123n}})
123n 
```

#### 20.5.2 `BigInt.prototype.*` 方法

`BigInt.prototype` 包含原始大整数“继承”的方法：

+   `BigInt.prototype.toLocaleString(locales?, options?)`

+   `BigInt.prototype.toString(radix?)`

+   `BigInt.prototype.valueOf()`

#### 20.5.3 `BigInt.*` 方法：类型转换

+   `BigInt.asIntN(width, theInt)`

    将`theInt`转换为`width`位的整数（有符号）。这会影响值在内部如何表示。

+   `BigInt.asUintN(width, theInt)`

    将`theInt`转换为`width`位的整数（无符号）。

##### 20.5.3.1 示例：使用 64 位整数

转换允许我们创建具有特定位数的大整数值 - 例如，如果我们想限制自己使用 64 位整数，我们总是必须进行转换：

```js
const uint64a = BigInt.asUintN(64, 12345n);
const uint64b = BigInt.asUintN(64, 67890n);
const result = BigInt.asUintN(64, uint64a * uint64b);

```

![练习图标](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png)　**练习：为大整数实现`Number.parseInt()`的类似功能**

`exercises/bigints/parse-bigint_test.mjs`

### 20.6 将大整数转换为其他原始类型

此表显示了如果我们将大整数转换为其他原始类型会发生什么：

| 转换为 | 显式转换 | 诱导（隐式转换） |
| --- | --- | --- |
| 布尔值 | `Boolean(0n)` → `false` | `!0n` → `true` |
|  | `Boolean(int)` → `true` | `!int` → `false` |
| 数字 | `Number(7n)` → `7` (示例) | `+int` → `TypeError` (1) |
| 字符串 | `String(7n)` → `'7'` (示例) | `''+7n` → `'7'` (示例) |

脚注：

+   (1) 一元`+`不支持大整数，因为许多代码依赖于它将操作数强制转换为数字。

### 20.7 类型化数组和数据视图的 64 位值操作

多亏了大整数，类型化数组和数据视图可以支持 64 位值：

+   类型化数组构造函数：

    +   `BigInt64Array`

    +   `BigUint64Array`

+   数据视图方法：

    +   `DataView.prototype.getBigInt64()`

    +   `DataView.prototype.setBigInt64()`

    +   `DataView.prototype.getBigUint64()`

    +   `DataView.prototype.setBigUint64()`

### 20.8 大整数和 JSON

JSON 标准是固定的，不会改变。好处是旧的 JSON 解析代码永远不会过时。坏处是 JSON 不能扩展以包含大整数。

将大整数转换为字符串会抛出异常：

```js
> JSON.stringify(123n)
TypeError: Do not know how to serialize a BigInt
> JSON.stringify([123n])
TypeError: Do not know how to serialize a BigInt

```

#### 20.8.1 将大整数转换为字符串

因此，我们最好的选择是将大整数存储为字符串：

```js
const bigintPrefix = '[[bigint]]';

function bigintReplacer(_key, value) {
  if (typeof value === 'bigint') {
    return bigintPrefix + value;
  }
  return value;
}

const data = { value: 9007199254740993n };
assert.equal(
  JSON.stringify(data, bigintReplacer),
  '{"value":"[[bigint]]9007199254740993"}'
);

```

#### 20.8.2 解析大整数

以下代码展示了如何解析类似于我们在上一个示例中产生的字符串。

```js
function bigintReviver(_key, value) {
  if (typeof value === 'string' && value.startsWith(bigintPrefix)) {
    return BigInt(value.slice(bigintPrefix.length));
  }
  return value;
}

const str = '{"value":"[[bigint]]9007199254740993"}';
assert.deepEqual(
  JSON.parse(str, bigintReviver),
  { value: 9007199254740993n }
);

```

### 20.9 常见问题解答：大整数

#### 20.9.1 我该如何决定何时使用数字和何时使用大整数？

我的建议：

+   使用数字表示最多 53 位和数组索引。理由：它们已经无处不在，并且大多数引擎（尤其是如果它们适合 31 位）可以有效地处理它们。出现的情况包括：

    +   `Array.prototype.forEach()`

    +   `Array.prototype.entries()`

+   使用大整数表示大数值：如果你的无小数值不适合 53 位，你除了转向大整数别无选择。

所有现有的 Web API 都只返回和接受数字，并且仅在特定情况下升级到大整数。

#### 20.9.2 为什么不就像处理大整数（bigints）那样增加数字的精度？

理论上可以将`number`分为`integer`和`double`，但这会给语言增加许多新的复杂性（例如，几个仅限整数的运算符等）。我在[一个 Gist](https://gist.github.com/rauschma/13d48d1c49615ce2396ce7c9e45d4cd1)中概述了这些后果。

* * *

**致谢：**

+   感谢丹尼尔·埃伦伯格（Daniel Ehrenberg）审阅了此内容的早期版本。

+   感谢丹·卡拉汉（Dan Callahan）审阅了此内容的早期版本。
