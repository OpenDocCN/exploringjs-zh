# 41 异步编程路线图

> 原文：[`exploringjs.com/js/book/ch_async-roadmap.html`](https://exploringjs.com/js/book/ch_async-roadmap.html)

1.  41.1 下一章

1.  41.2 同步函数

1.  41.3 JavaScript 在单个进程中按顺序执行任务

1.  41.4 基于回调的异步函数

1.  41.5 基于 Promise 的异步函数

1.  41.6 异步函数

这章是异步编程的简要路线图。

### 41.1 下一章

下一章将解释 JavaScript 中的异步编程：

+   “JavaScript 异步编程基础” (§42):

    +   我们将了解同步函数调用是如何工作的。

    +   我们还将探索 JavaScript 在单个进程中执行代码的方式，通过其 *事件循环*。

    +   通过回调实现异步 在该章节中也有描述。

+   “异步编程的 Promises^(ES6)” (§43)

+   “Async 函数^(ES2017)” (§44)

+   “异步迭代^(ES2018)” (§45) 总结了这一系列关于异步编程的章节。异步迭代类似于 同步迭代，但迭代值是异步提供的。

本章的剩余部分将给你一些关于这一切意味着什么的初步想法。

![阅读图标](img/0fb62b2fc33a72829ae9fb174dedd0d2.png) **不必担心细节！**

如果你现在还不完全理解，不要担心。这只是对即将发生的事情的一个快速预览。所有内容将在下一章中详细解释。

### 41.2 同步函数

正常函数是 *同步的*：调用者等待被调用者完成其计算。行 A 中的 `divideSync()` 是一个同步函数调用：

```js
function main() {
 try {
 const result = divideSync(12, 3); // (A)
 assert.equal(result, 4);
 } catch (err) {
 assert.fail(err);
 }
}

```

### 41.3 JavaScript 在单个进程中按顺序执行任务

默认情况下，JavaScript *任务* 是在单个进程中按顺序执行的函数。这看起来是这样的：

```js
while (true) {
  const task = taskQueue.dequeue();
  task(); // run task
}

```

这个循环也被称为 *事件循环*，因为事件，例如点击鼠标，会将任务添加到队列中。

由于这种协作多任务处理风格，我们不希望任务在等待来自服务器的结果时阻塞其他任务的执行。下一小节将探讨如何处理这种情况。

### 41.4 基于回调的异步函数

如果 `divide()` 需要服务器来计算其结果呢？那么结果应该以不同的方式交付：调用者不需要（同步地）等待结果准备就绪；它应该在结果就绪时被通知（异步地）。异步交付结果的一种方式是给 `divide()` 提供一个回调函数，它使用该回调函数来通知调用者。

```js
function main() {
 divideCallback(12, 3,
 (err, result) => {
 if (err) {
 assert.fail(err);
 } else {
 assert.equal(result, 4);
 }
 });
}

```

当有异步函数调用时：

```js
divideCallback(x, y, callback)

```

然后发生以下步骤：

+   `divideCallback()` 向服务器发送请求。

+   然后当前任务 `main()` 完成，其他任务可以执行。

+   当服务器响应到达时，它要么是：

    +   一个错误 `err`：然后以下任务被添加到队列中。

        ```js
        taskQueue.enqueue(() => callback(err));

        ```

    +   一个 `result` 值：然后以下任务被添加到队列中。

        ```js
        taskQueue.enqueue(() => callback(null, result));

        ```

### 41.5 基于 Promise 的异步函数

Promise 是两件事：

+   一种标准模式，使得使用回调函数变得更加容易。

+   异步函数（下一小节的主题）所基于的机制。

调用一个基于 Promise 的函数看起来如下。

```js
function main() {
 dividePromise(12, 3)
 .then(result => assert.equal(result, 4))
 .catch(err => assert.fail(err));
}

```

### 41.6 异步函数

观察异步函数的一种方式是将其视为基于 Promise 代码的更好语法：

```js
async function main() {
 try {
 const result = await dividePromise(12, 3); // (A)
 assert.equal(result, 4);
 } catch (err) {
 assert.fail(err);
 }
}

```

在第 A 行调用的 `dividePromise()` 与前一部分中的相同，是基于 Promise 的函数。但现在我们有了一种看起来同步的语法来处理调用。`await` 只能在一种特殊类型的函数中使用，即 *异步函数*（注意 `function` 关键字前的 `async` 关键字）。`await` 会暂停当前的异步函数并从中返回。一旦等待的结果准备就绪，函数的执行将继续从上次停止的地方继续。
