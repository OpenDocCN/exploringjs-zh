# 23 使用模板字面量和标记模板 ES6

> 原文：[`exploringjs.com/js/book/ch_template-literals.html`](https://exploringjs.com/js/book/ch_template-literals.html)

1.  23.1 消除歧义：“模板”

1.  23.2 模板字面量

1.  23.3 标记模板

    1.  23.3.1 烹饪与原始模板字符串（高级）

1.  23.4 标记模板的示例（通过库提供）

    1.  23.4.1 标记函数库：lit-html

    1.  23.4.2 标记函数库：regex

    1.  23.4.3 标记函数库：graphql-tag

1.  23.5 通过模板标签`String.raw`的原始字符串字面量

1.  23.6 多行模板字面量和缩进

    1.  23.6.1 修复：缩进文本并通过模板标签移除缩进

    1.  23.6.2 修复：不缩进文本并通过`.trim()`移除前导和尾随空白

1.  23.7 通过模板字面量进行简单模板化（高级）

    1.  23.7.1 一个更复杂的例子

    1.  23.7.2 简单的 HTML 转义

在我们深入探讨“模板字面量”和“标记模板”这两个特性之前，让我们首先考察一下“模板”一词的多种含义。

### 23.1 消除歧义：“模板”

尽管这三个名称中都有“模板”，并且它们看起来很相似，但以下三者在本质上却有着显著的不同：

+   **文本模板**是从数据到文本的函数。它在 Web 开发中经常被使用，通常通过文本文件定义。例如，以下文本定义了一个用于库[Handlebars](https://handlebarsjs.com)的模板：

    ```js
    <div class="entry">
      <h1>{{title}}</h1>
      <div class="body">
        {{body}}
      </div>
    </div>

    ```

    此模板有两个空白需要填写：`title`和`body`。它被这样使用：

    ```js
    // First step: retrieve the template text, e.g. from a text file.
    const tmplFunc = Handlebars.compile(TMPL_TEXT); // compile string
    const data = {title: 'My page', body: 'Welcome to my page!'};
    const html = tmplFunc(data);

    ```

+   **模板字面量**类似于字符串字面量，但具有额外的功能——例如，插值。它由反引号分隔：

    ```js
    const num = 5;
    assert.equal(`Count: ${num}!`, 'Count: 5!');

    ```

+   从语法上讲，一个**标记模板**是一个跟随函数（或者更确切地说，是一个评估为函数的表达式）的模板字面量。这会导致函数被调用。它的参数来自模板字面量的内容。

    ```js
    const getArgs = (...args) => args;
    assert.deepEqual(
      getArgs`Count: ${5}!`,
      [['Count: ', '!'], 5] );

    ```

    注意，`getArgs()`接收来自字面量的文本以及通过`${}`插值的数据。

### 23.2 模板字面量

与普通字符串字面量相比，模板字面量有两个新特性。

首先，它支持**字符串插值**：如果我们把一个动态计算出的值放在`${}`中，它会被转换为字符串并插入到字面量返回的字符串中。

```js
const MAX = 100;
function doSomeWork(x) {
  if (x > MAX) {
    throw new Error(`At most ${MAX} allowed: ${x}!`);
  }
  // ···
}
assert.throws(
  () => doSomeWork(101),
  {message: 'At most 100 allowed: 101!'});

```

第二，模板字面量可以跨越多行：

```js
const str = `this is
a text with
multiple lines`;

```

模板字面量总是产生字符串。

### 23.3 标记模板

行 A 中的表达式是一个*标记模板*。它相当于调用 `tagFunc()` 并使用行 A 以下显示的参数。

```js
function tagFunc(templateStrings, ...substitutions) {
  return {templateStrings, substitutions};
}

const setting = 'dark mode';
const value = true;

assert.deepEqual(
  tagFunc`Setting ${setting} is ${value}!`, // (A)
  {
    templateStrings: ['Setting ', ' is ', '!'],
    substitutions: ['dark mode', true],
  }
  // tagFunc(['Setting ', ' is ', '!'], 'dark mode', true)
);

```

在第一个反引号之前调用的函数 `tagFunc` 被称为*标记函数*。它的参数是：

+   *模板字符串*（第一个参数）：一个包含围绕插值 `${}` 的文本片段的数组。

    +   在示例中：`['Setting ', ' is ', '!']`

+   *替换*（剩余参数）：插值值。

    +   在示例中：`'dark mode'` 和 `true`

文字（字面量）的静态（固定）部分（模板字符串）与动态部分（替换）是分开的。

标记函数可以返回任意值。

#### 23.3.1 烹饪与原始模板字符串（高级）

到目前为止，我们只看到了模板字符串的*烹饪解释*。但实际上，标记函数实际上得到两种解释：

+   一个*烹饪解释*，其中反斜杠具有特殊意义。例如，`\t` 产生一个制表符字符。这种解释的模板字符串存储在第一个参数（一个数组）中。

+   一个*原始解释*，其中反斜杠没有特殊意义。例如，`\t` 产生两个字符——一个反斜杠和一个 `t`。这种解释的模板字符串存储在第一个参数（一个数组）的 `.raw` 属性中。

原始解释通过 `String.raw` (稍后描述) 和类似的应用程序启用原始字符串字面量。

以下标记函数 `cookedRaw` 使用了两种解释：

```js
function cookedRaw(templateStrings, ...substitutions) {
  return {
    cooked: Array.from(templateStrings), // copy only Array elements
    raw: templateStrings.raw,
    substitutions,
  };
}
assert.deepEqual(
  cookedRaw`\tab${'subst'}\newline\\`,
  {
    cooked: ['\tab', '\newline\\'],
    raw:    ['\\tab', '\\newline\\\\'],
    substitutions: ['subst'],
  });

```

我们还可以在标记模板中使用 Unicode 代码点转义（`\u{1F642}`）、Unicode 代码单元转义（`\u03A9`）和 ASCII 转义（`\x52`）：

```js
assert.deepEqual(
  cookedRaw`\u{54}\u0065\x78t`,
  {
    cooked: ['Text'],
    raw:    ['\\u{54}\\u0065\\x78t'],
    substitutions: [],
  });

```

如果其中一个转义的语法不正确，相应的烹饪模板字符串是 `undefined`，而原始版本仍然是字面量：

```js
assert.deepEqual(
  cookedRaw`\uu\xx ${1} after`,
  {
    cooked: [undefined, ' after'],
    raw:    ['\\uu\\xx ', ' after'],
    substitutions: [1],
  });

```

不正确的转义会在模板字面量和字符串字面量中产生语法错误。在 ES2018 之前，它们甚至在标记模板中产生错误。为什么会有这样的改变？现在我们可以使用标记模板来处理之前非法的文本——例如：

```js
windowsPath`C:\uuu\xxx\111`
latex`\unicode`

```

### 23.4 标记模板的示例（通过库提供）

标记模板非常适合支持小型嵌入式语言（所谓的*领域特定语言*）。我们将继续使用一些示例。

#### 23.4.1 标记函数库：lit-html

[Lit](https://lit.dev) 是一个用于构建网页组件的库，它使用标记模板进行 HTML 模板化：

```js
@customElement('my-element')
class MyElement extends LitElement {

  // ···

  render() {
 return html`
 <ul>
 ${repeat(
 this.items,
 (item) => item.id,
 (item, index) => html`<li>${index}: ${item.name}</li>`
 )}
 </ul>
 `;
 }
}

```

`repeat()` 是一个用于循环的自定义函数。它的第二个参数为第三个参数返回的值生成唯一的键。注意该参数使用的嵌套标记模板。

#### 23.4.2 标记函数库：正则表达式

由 Steven Levithan 编写的“regex”库（https://github.com/slevithan/regex）提供了模板标签，有助于创建正则表达式并启用高级功能。以下示例演示了它是如何工作的：

```js
import {regex, pattern} from 'regex';

const RE_YEAR = pattern`(?<year>[0-9]{4})`;
const RE_MONTH = pattern`(?<month>[0-9]{2})`;
const RE_DAY = pattern`(?<day>[0-9]{2})`;
const RE_DATE = regex('g')`
 ${RE_YEAR} # 4 digits
 -
 ${RE_MONTH} # 2 digits
 -
 ${RE_DAY} # 2 digits
`;

const match = RE_DATE.exec('2017-01-27');
assert.equal(match.groups.year, '2017');

```

默认启用的以下标志：

+   标记 `/v`

+   标记 `/x`（模拟）通过 `#` 启用不重要的空白和行注释。

+   标记 `/n`（模拟）启用*仅命名捕获模式*，这阻止了分组元字符 `(···)` 的捕获。

#### 23.4.3 标签函数库：graphql-tag

[graphql-tag 库](https://github.com/apollographql/graphql-tag)让我们可以通过标签模板创建 GraphQL 查询：

```js
import gql from 'graphql-tag';

const query = gql`
 {
 user(id: 5) {
 firstName
 lastName
 }
 }
 `;

```

此外，还有插件可以在 Babel、TypeScript 等中预编译此类查询。

### 23.5 通过模板标签 `String.raw` 的原始字符串字面量

原始字符串字面量通过标签函数 `String.raw` 实现。它们是字符串字面量，其中反斜杠不执行任何特殊操作（例如转义字符等）：

```js
assert.equal(
  String.raw`\back`,
  '\\back'
);

```

这有助于数据包含反斜杠时——例如，包含正则表达式的字符串：

```js
const regex1 = /^\./;
const regex2 = new RegExp('^\\.');
const regex3 = new RegExp(String.raw`^\.`);

```

所有三个正则表达式都是等效的。使用普通字符串字面量时，我们必须写两次反斜杠，以转义该字面量。使用原始字符串字面量时，我们不必这样做。

原始字符串字面量也用于指定 Windows 文件名路径：

```js
const WIN_PATH = String.raw`C:\Users\Robin\Documents`;
assert.equal(
  WIN_PATH, 'C:\\Users\\Robin\\Documents'
);

```

### 23.6 多行模板字面量和缩进

如果我们在模板字面量中放置多行文本，两个目标就产生了冲突：一方面，模板字面量应该缩进以适应源代码。另一方面，其内容行应该从最左侧列开始。

例如：

```js
function div(text) {
  return `
 <div>
 ${text}
 </div>
 `;
}
console.log('Output:');
console.log(
  div('Hello!')
  // Replace spaces with mid-dots:
  .replace(/ /g, '·')
  // Replace \n with #\n:
  .replace(/\n/g, '#\n')
);

```

由于缩进，模板字面量很好地融入了源代码。然而，输出也是缩进的。我们不想在开头有返回，在结尾有返回加两个空格。

```js
Output:
#
····<div>#
······Hello!#
····</div>#
··

```

有两种方法可以修复这个问题：通过标签模板或通过修剪模板字面量的结果。

#### 23.6.1 修复：通过模板标签缩进文本并移除缩进

第一个修复是使用自定义模板标签来删除不需要的空白。它使用初始换行符之后的第一行来确定文本开始的列，并在所有地方缩短缩进。它还删除了非常开始的换行符和非常结束的缩进。这样的模板标签之一是 [Desmond Brand 的 `dedent`](https://github.com/dmnd/dedent)：

```js
import dedent from 'dedent';
function divDedented(text) {
  return dedent`
 <div>
 ${text}
 </div>
 `;
}
console.log('Output:');
console.log(divDedented('Hello!'));

```

输出没有缩进：

```js
Output:
<div>
  Hello!
</div>

```

#### 23.6.2 修复：不缩进文本并通过 `.trim()` 移除前导和尾随空白

第二个修复更快，但也更脏：

```js
function divDedented(text) {
  return `
<div>
 ${text}
</div>
 `.trim();
}
console.log('Output:');
console.log(divDedented('Hello!'));

```

字符串方法`.trim()`移除了开头和结尾的冗余空白字符，但内容本身不能缩进 - 它必须从最左侧列开始。这种解决方案的优势是我们不需要自定义标签函数。缺点是未缩进的文本与周围环境不太搭配。

输出与`dedent`相同：

```js
Output:
<div>
  Hello!
</div>

```

### 23.7 通过模板字面量进行简单模板化（高级）

虽然模板字面量看起来像文本模板，但它们用于（文本）模板化的方法并不立即明显：文本模板从对象中获取数据，而模板字面量从变量中获取数据。解决方案是在一个函数体中使用模板字面量，该函数的参数接收模板数据 - 例如：

```js
const tmpl = (data) => `Hello ${data.name}!`;
assert.equal(tmpl({name: 'Jane'}), 'Hello Jane!');

```

#### 23.7.1 更复杂的示例

作为更复杂的示例，我们希望从一个地址数组中生成一个 HTML 表格。这是数组：

```js
const addresses = [
  { first: '<Jane>', last: 'Bond' },
  { first: 'Lars', last: '<Croft>' },
];

```

生成 HTML 表格的函数`tmpl()`看起来如下：

```js
const tmpl = (addrs) => `
<table>
 ${addrs.map(
 (addr) => `
 <tr>
 <td>${escapeHtml(addr.first)}</td>
 <td>${escapeHtml(addr.last)}</td>
 </tr>
 `.trim()
 ).join('')}
</table>
`.trim();

```

此代码包含两个模板函数：

+   第一个（第 1 行）接受`addrs`，一个包含地址的数组，并返回一个包含表格的字符串。

+   第二个（第 4 行）接受`addr`，一个包含地址的对象，并返回一个包含表格行的字符串。注意最后的`.trim()`，它移除了不必要的空白字符。

第一个模板函数通过将表格元素包裹在一个它连接成字符串的数组周围来生成结果（第 10 行）。这个数组是通过将第二个模板函数映射到`addrs`（第 3 行）的每个元素上产生的。因此，它包含带有表格行的字符串。

辅助函数`escapeHtml()`用于转义特殊的 HTML 字符（第 6 行和第 7 行）。其实现将在下一小节中展示。

让我们用地址调用`tmpl()`并记录结果：

```js
console.log(tmpl(addresses));

```

输出是：

```js
<table>
  <tr>
        <td>&lt;Jane&gt;</td>
        <td>Bond</td>
      </tr><tr>
        <td>Lars</td>
        <td>&lt;Croft&gt;</td>
      </tr>
</table>

```

#### 23.7.2 简单的 HTML 转义

以下函数用于转义纯文本，以便在 HTML 中以纯文本形式显示：

```js
function escapeHtml(str) {
  return str
    .replace(/&/g, '&amp;') // first!
    .replace(/>/g, '&gt;')
    .replace(/</g, '&lt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;')
    .replace(/`/g, '&#96;')
    ;
}
assert.equal(
  escapeHtml('Rock & Roll'), 'Rock &amp; Roll');
assert.equal(
  escapeHtml('<blank>'), '&lt;blank&gt;');

```

![“练习”图标](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：HTML 模板化**

练习（带额外挑战）：`exercises/template-literals/templating_test.mjs`
