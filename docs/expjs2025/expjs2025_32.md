# 27 可调用值

> 原文：[`exploringjs.com/js/book/ch_callables.html`](https://exploringjs.com/js/book/ch_callables.html)

1.  27.1 函数类型

1.  27.2 普通函数

    1.  27.2.1 命名函数表达式（高级）

    1.  27.2.2 术语：函数定义和函数表达式

    1.  27.2.3 函数声明的组成部分

    1.  27.2.4 普通函数扮演的角色

    1.  27.2.5 术语：实体、语法与角色（高级）

1.  27.3 专用函数（ES6）

    1.  27.3.1 专用函数仍然是函数

    1.  27.3.2 箭头函数

    1.  27.3.3 方法、普通函数和箭头函数中的特殊变量 `this`

    1.  27.3.4 建议：优先使用专用函数而不是普通函数

1.  27.4 总结：可调用值的类型

1.  27.5 从函数和方法返回值

1.  27.6 参数处理

    1.  27.6.1 术语：参数与参数

    1.  27.6.2 术语：回调函数

    1.  27.6.3 参数过多或不足

    1.  27.6.4 参数默认值（ES6）

    1.  27.6.5 剩余参数（ES6）

    1.  27.6.6 命名参数

    1.  27.6.7 模拟命名参数（ES6）

    1.  27.6.8 将展开（`...`）应用于函数调用（ES6）

1.  27.7 函数方法：`.call()`、`.apply()`、`.bind()`

    1.  27.7.1 函数方法 `.call()`

    1.  27.7.2 函数方法 `.apply()`

    1.  27.7.3 函数方法 `.bind()`

在本章中，我们将探讨 JavaScript 中可以调用的值：函数、方法和类。

### 27.1 函数类型

JavaScript 有两种函数类别：

+   一个 *普通函数* 可以扮演多个角色：

    +   真实函数

    +   方法

    +   构造函数

+   一个 *专用函数* 只能扮演以下角色之一——例如：

    +   一个 *箭头函数* 只能是一个真正的函数。

    +   一个 *方法* 只能是一个方法。

    +   一个 *类* 只能是一个构造函数。

    专用函数是在 ECMAScript 6 中添加到语言中的。

继续阅读以了解所有这些术语的含义。

### 27.2 普通函数

以下代码展示了两种（大致）做同样事情的方法：创建一个普通函数。

```js
// Function declaration (a statement)
function ordinary1(a, b, c) {
  // ···
}

// const plus anonymous (nameless) function expression
const ordinary2 = function (a, b, c) {
  // ···
};

```

在一个作用域内，函数声明会提前激活（参见“声明：作用域和激活”§13.8），可以在声明之前调用。这偶尔是有用的。

变量声明，如 `ordinary2` 的声明，不会提前激活。

#### 27.2.1 命名函数表达式（高级）

到目前为止，我们只看到了匿名函数表达式——它们没有名字：

```js
const anonFuncExpr = function (a, b, c) {
  // ···
};

```

但也存在**命名函数表达式**：

```js
const namedFuncExpr = function myName(a, b, c) {
  // `myName` is only accessible in here
};

```

`myName` 只在函数体内可访问。函数可以使用它来引用自身（用于自递归等），而不论它被分配给哪个变量：

```js
const func = function funcExpr() { return funcExpr };
assert.equal(func(), func);

// The name `funcExpr` only exists inside the function body:
assert.throws(() => funcExpr(), ReferenceError);

```

即使它们没有被分配给变量，命名函数表达式也有名字（行 A）：

```js
function getNameOfCallback(callback) {
  return callback.name;
}

assert.equal(
  getNameOfCallback(function () {}), '' // anonymous
);

assert.equal(
 getNameOfCallback(function named() {}), 'named' // (A)
); 
```

注意，通过函数声明或变量声明创建的函数总是有名字的：

```js
function funcDecl() {}
assert.equal(
 getNameOfCallback(funcDecl), 'funcDecl'
);

const funcExpr = function () {};
assert.equal(
 getNameOfCallback(funcExpr), 'funcExpr'
); 
```

函数有名字的一个好处是，这些名字会出现在错误堆栈跟踪中。

#### 27.2.2 术语：函数定义和函数表达式

**函数定义**是创建函数的语法：

+   函数声明（一个语句）

+   函数表达式

函数声明总是产生普通函数。函数表达式可以产生普通函数或特殊函数：

+   普通函数表达式（我们之前已经遇到过）：

    +   匿名函数表达式

    +   命名函数表达式

+   特殊函数表达式（我们稍后会看到）：

    +   箭头函数（它们总是表达式）

虽然函数声明在 JavaScript 中仍然很受欢迎，但现代代码中函数表达式几乎总是箭头函数。

#### 27.2.3 函数声明的各个部分

让我们通过以下示例来检查函数声明的各个部分。大多数术语也适用于函数表达式。

```js
function add(x, y) {
  return x + y;
}

```

+   `add` 是函数声明的**名字**。

+   `add(x, y)` 是函数声明的**头部**。

+   `x` 和 `y` 是**参数**。

+   大括号（`{` 和 `}`）及其之间的一切都是函数声明的**主体**。

+   `return` 语句明确地从函数中返回一个值。

##### 27.2.3.1 参数列表中的尾随逗号（ES2017）

JavaScript 一直允许并忽略数组字面量中的尾随逗号。自 ES5 以来，它们也被允许在对象字面量中使用。自 ES2017 以来，我们可以在参数列表（声明和调用）中添加尾随逗号。

```js
// Declaration
function retrieveData(
 contentText,
 keyword,
 {unique, ignoreCase, pageSize}, // trailing comma
) {
  // ···
}

// Invocation
retrieveData(
  '',
  null,
  {ignoreCase: true, pageSize: 10}, // trailing comma
);

```

#### 27.2.4 普通函数所扮演的角色

考虑以下来自上一节的函数声明：

```js
function add(x, y) {
  return x + y;
}

```

此函数声明创建了一个名为 `add` 的普通函数。作为一个普通函数，`add()` 可以扮演三个角色：

+   实际函数：通过函数调用执行。

    ```js
    assert.equal(add(2, 1), 3);

    ```

+   方法：存储在属性中，通过方法调用执行。

    ```js
    const obj = { addAsMethod: add };
    assert.equal(obj.addAsMethod(2, 4), 6); // (A)

    ```

    在行 A 中，`obj` 被称为方法调用的 *接收者*。

+   构造函数：通过 `new` 调用。

    ```js
    const inst = new add();
    assert.equal(inst instanceof add, true);

    ```

    作为旁白，构造函数（包括类）的名称通常以大写字母开头。

#### 27.2.5 术语：实体 vs. 语法 vs. 角色（高级）

*语法*、*实体* 和 *角色* 之间的区别很微妙，通常并不重要。但了解这一点仍然很有用：

+   *实体* 是一种 JavaScript 特性，因为它“存在于”RAM 中。普通函数是一个实体。

    +   实体包括：普通函数、箭头函数、方法和类。

+   *语法* 是我们用来创建实体的代码。函数声明和匿名函数表达式是语法。它们都创建被称为普通函数的实体。

    +   语法包括：函数声明和匿名函数表达式。产生箭头函数的语法也称为 *箭头函数*。对于方法和类也是如此。

+   *角色* 描述了如何使用实体。实体 *普通函数* 可以扮演 *真实函数* 的角色，或者 *方法* 的角色，或者 *类* 的角色。实体 *箭头函数* 也可以扮演 *真实函数* 的角色。

    +   函数的角色包括：真实函数、方法和构造函数。

许多其他编程语言只有一个实体扮演 *真实函数* 的角色。然后它们可以使用 *函数* 这个名字来指代这个角色和实体。

### 27.3 特殊函数 (ES6)

特殊函数是普通函数的单用途版本。每个都专注于单一角色：

+   *箭头函数* 的目的是成为一个真实函数：

    ```js
    const arrow = () => {
     return 123;
    };
    assert.equal(arrow(), 123);

    ```

+   *方法* 的目的是成为一个方法：

    ```js
    const obj = {
      myMethod() {
     return 'abc';
     }
    };
    assert.equal(obj.myMethod(), 'abc');

    ```

+   *类* 的目的是成为一个构造函数：

    ```js
    class MyClass {
      /* ··· */
    }
    const inst = new MyClass();

    ```

除了更简洁的语法外，每种特殊函数也支持新特性，使它们在各自的工作中比普通函数表现得更好。

+   箭头函数将在后面解释。

+   方法在 对象章节 中进行解释。

+   类在 类章节 中进行解释。

表 27.1 列出了普通函数和特殊函数的能力。

|  | 函数调用 | 方法调用 | 构造函数调用 |
| --- | --- | --- | --- |
| 普通函数 | (`this === undefined`) | ✔ | ✔ |
| 箭头函数 | ✔ | (词法 `this`) | ✘ |
| 方法 | (`this === undefined`) | ✔ | ✘ |
| 类 | ✘ | ✘ | ✔ |

表 27.1：四种函数的能力。如果单元格值在括号中，则表示某种限制。特殊变量 `this` 在 “方法、普通函数和箭头函数中的特殊变量 `this`”（§27.3.3） 中进行解释。

#### 27.3.1 特殊函数仍然是函数

重要的是要注意，箭头函数、方法和类仍然被归类为函数：

```js
> (() => {}) instanceof Function
true
> ({ method() {} }.method) instanceof Function
true
> (class SomeClass {}) instanceof Function
true 
```

#### 27.3.2 箭头函数

箭头函数被添加到 JavaScript 中有两个原因：

1.  为了提供一个更简洁的创建函数的方法。

1.  它们在方法内部作为真正的函数表现更好：方法可以通过特殊变量 `this` 来引用接收方法调用的对象。箭头函数可以访问周围方法的 `this`，普通函数则不能（因为它们有自己的 `this`）。

我们将首先检查箭头函数的语法，然后讨论 `this` 在各种函数中的工作方式。

##### 27.3.2.1 箭头函数的语法

让我们回顾一下匿名函数表达式的语法：

```js
const f = function (x, y, z) { return 123 };

```

箭头函数的（大致）等效形式如下。箭头函数是表达式。

```js
const f = (x, y, z) => { return 123 };

```

在这里，箭头函数的主体是一个代码块。但它也可以是一个表达式。下面的箭头函数与上一个完全相同。

```js
const f = (x, y, z) => 123;

```

如果一个箭头函数只有一个参数，并且这个参数是一个标识符（不是 解构模式），那么我们可以省略参数周围的括号：

```js
const id = x => x;

```

当将箭头函数作为参数传递给其他函数或方法时，这很方便：

```js
> [1,2,3].map(x => x+1)
[ 2, 3, 4 ]

```

这个先前的例子展示了箭头函数的一个优点 – 简洁性。如果我们用函数表达式执行相同的任务，我们的代码会更冗长：

```js
[1,2,3].map(function (x) { return x+1 });

```

##### 27.3.2.2 箭头函数返回对象字面量的语法陷阱

如果我们想让箭头函数的表达式主体是一个对象字面量，我们必须在字面量周围加上括号：

```js
const func1 = () => ({a: 1});
assert.deepEqual(func1(), { a: 1 });

```

如果我们不这样做，JavaScript 会认为箭头函数有一个代码块主体（不返回任何内容）：

```js
const func2 = () => {a: 1};
assert.deepEqual(func2(), undefined);

```

`{a: 1}` 被解释为一个带有 标签 `a:` 的代码块和表达式语句 `1`。如果没有显式的 `return` 语句，代码块主体返回 `undefined`。

这个陷阱是由 语法歧义 引起的：对象字面量和代码块有相同的语法。我们使用括号来告诉 JavaScript，主体是一个表达式（对象字面量），而不是一个语句（代码块）。

#### 27.3.3 方法、普通函数和箭头函数中的特殊变量 `this`

![“阅读”图标](img/0fb62b2fc33a72829ae9fb174dedd0d2.png) **特殊变量 `this` 是面向对象的一个特性**

我们在这里快速查看特殊变量 `this`，以便了解为什么箭头函数比普通函数更像是真正的函数。

但这个特性只在面向对象编程中才有意义，在“方法和特殊变量 `this`”（§30.6）中有更深入的介绍。因此，如果你现在还没有完全理解它，请不要担心。

在方法内部，特殊变量 `this` 允许我们访问 *接收者* – 被方法调用的对象：

```js
const obj = {
  myMethod() {
 assert.equal(this, obj);
 }
};
obj.myMethod();

```

普通函数可以是方法，因此也具有隐式参数`this`：

```js
const obj = {
  myMethod: function () {
 assert.equal(this, obj);
 }
};
obj.myMethod();

```

即使当我们使用普通函数作为实函数时，`this`也是一个隐式参数。然后其值是`undefined`（如果严格模式处于活动状态，这几乎总是如此）：

```js
function ordinaryFunc() {
 assert.equal(this, undefined);
}
ordinaryFunc();

```

这意味着一个作为实函数使用的普通函数无法访问周围方法的`this`（行 A）。相比之下，箭头函数没有`this`作为隐式参数。它们将其视为任何其他变量，因此可以访问周围方法的`this`（行 B）：

```js
const jill = {
  name: 'Jill',
  someMethod() {
 function ordinaryFunc() {
 assert.throws(
 () => this.name, // (A)
 /^TypeError: Cannot read properties of undefined \(reading 'name'\)$/
 );
 }
 ordinaryFunc();

 const arrowFunc = () => {
 assert.equal(this.name, 'Jill'); // (B)
 };
 arrowFunc();
 },
};
jill.someMethod(); 
```

在此代码中，我们可以观察到两种处理`this`的方式：

+   动态`this`：在行 A 中，我们尝试从一个普通函数中访问`.someMethod()`的`this`。在那里，它被函数自己的`this`所掩盖，该`this`是`undefined`（由函数调用填充）。鉴于普通函数通过（动态）函数或方法调用接收它们的`this`，它们的`this`被称为*动态*。

+   词法`this`：在行 B 中，我们再次尝试访问`.someMethod()`的`this`。这次我们成功了，因为箭头函数没有自己的`this`。`this`是按词法解析的，就像任何其他变量一样。这就是为什么箭头函数的`this`被称为*词法*。

#### 27.3.4 推荐方案：优先使用专用函数而非普通函数

通常，我们应该优先使用专用函数而非普通函数，尤其是类和方法。

当涉及到真实函数时，箭头函数和普通函数之间的选择并不那么明确：

+   对于匿名内联函数表达式，箭头函数由于其紧凑的语法和没有`this`作为隐式参数，是明显的赢家：

    ```js
    const twiceOrdinary = [1, 2, 3].map(function (x) {return x * 2});
    const twiceArrow = [1, 2, 3].map(x => x * 2);

    ```

+   对于独立的命名函数声明，箭头函数仍然得益于词法`this`。但函数声明（产生普通函数）具有很好的语法，早期激活偶尔也很有用（参见“声明：作用域和激活”（§13.8）)。如果`this`在普通函数体中未出现，使用它作为实函数没有缺点。静态检查工具 ESLint 可以在开发过程中通过[内置规则](https://eslint.org/docs/rules/no-invalid-this)警告我们这种错误的使用。

    ```js
    function timesOrdinary(x, y) {
      return x * y;
    }
    const timesArrow = (x, y) => {
      return x * y;
    };

    ```

### 27.4 摘要：可调用值的种类

![图标“阅读”](img/0fb62b2fc33a72829ae9fb174dedd0d2.png) **本节涉及即将到来的内容**

本节主要作为当前和即将到来的章节的参考。如果你没有完全理解，请不要担心。

到目前为止，我们所看到的所有（真实）函数和方法都是：

+   单一结果

+   同步

后续章节将涵盖其他编程模式：

+   *迭代*将对象视为数据容器（所谓*可迭代*）并提供了一种标准化的方式来检索其中的内容。如果一个函数或方法返回一个可迭代对象，它将返回多个值。

+   *异步编程*处理长时间运行的计算。当计算完成时，我们会收到通知，并在其间做其他事情。异步传递单个结果的标准模式称为*Promise*。

这些模式可以组合——例如，存在同步可迭代和异步可迭代。

几种新的函数和方法有助于处理一些模式组合：

+   *异步函数*帮助实现返回 Promise 的函数。也有*异步方法*。

+   *同步生成器函数*帮助实现返回同步可迭代的函数。也有*同步生成器方法*。

+   *异步生成器函数*帮助实现返回异步可迭代的函数。也有*异步生成器方法*。

这就留下了 4 种（2×2）函数和方法：

+   同步与异步

+   生成器与单结果

表 27.2 概述了创建这些 4 种函数和方法的语法。

|  |  | **结果** | **#** |
| --- | --- | --- | --- |
| **同步函数** | **同步方法** |  |  |
| `function f() {}` | `{ m() {} }` | 值 | 1 |
| `f = function () {}` |  |  |  |
| `f = () => {}` |  |  |  |
| **同步生成器函数** | **同步生成器方法** |  |  |
| `function* f() {}` | `{ * m() {} }` | 可迭代 | 0+ |
| `f = function* () {}` |  |  |  |
| **异步函数** | **异步方法** |  |  |
| `async function f() {}` | `{ async m() {} }` | Promise | 1 |
| `f = async function () {}` |  |  |  |
| `f = async () => {}` |  |  |  |
| **异步生成器函数** | **异步生成器方法** |  |  |
| `async function* f() {}` | `{ async * m() {} }` | 异步可迭代 | 0+ |
| `f = async function* () {}` |  |  |  |

表 27.2：创建函数和方法的语法。最后一列指定实体产生的值的数量。

### 27.5 函数和方法的返回值

（本节中提到的所有内容都适用于函数和方法。）

`return`语句明确地从函数中返回一个值：

```js
function func() {
 return 123;
}
assert.equal(func(), 123);

```

另一个例子：

```js
function boolToYesNo(bool) {
  if (bool) {
    return 'Yes';
  } else {
    return 'No';
  }
}
assert.equal(boolToYesNo(true), 'Yes');
assert.equal(boolToYesNo(false), 'No');

```

如果在函数的末尾我们没有明确返回任何内容，JavaScript 会为我们返回`undefined`：

```js
function noReturn() {
 // No explicit return
}
assert.equal(noReturn(), undefined);

```

### 27.6 参数处理

再次强调，本节中我只提到函数，但所有内容也适用于方法。

#### 27.6.1 术语：参数与参数

术语*参数*和术语*参数*基本上意味着同一件事。如果我们愿意，我们可以做出以下区分：

+   *参数*是函数定义的一部分。它们也被称为*形式参数*和*形式参数*。

+   *参数*是函数调用的一部分。它们也被称为*实际参数*和*实际参数*。

#### 27.6.2 术语：回调

*回调*或*回调函数*是函数或方法调用的参数。

以下是一个回调示例：

```js
const myArray = ['a', 'b'];
const callback = (x) => console.log(x);
myArray.forEach(callback);

```

输出：

```js
a
b

```

#### 27.6.3 过多或不足的参数

如果函数调用提供的参数数量与函数定义期望的不同，JavaScript 不会报错：

+   额外的参数会被忽略。

+   缺少的参数会被设置为`undefined`。

例如：

```js
function foo(x, y) {
  return [x, y];
}

// Too many arguments:
assert.deepEqual(foo('a', 'b', 'c'), ['a', 'b']);

// The expected number of arguments:
assert.deepEqual(foo('a', 'b'), ['a', 'b']);

// Not enough arguments:
assert.deepEqual(foo('a'), ['a', undefined]);

```

#### 27.6.4 参数默认值（ES6）

参数默认值指定了如果未提供参数应使用的值——例如：

```js
function f(x, y=0) {
  return [x, y];
}

assert.deepEqual(f(1), [1, 0]);
assert.deepEqual(f(), [undefined, 0]);

```

`undefined`也会触发默认值：

```js
assert.deepEqual(
  f(undefined, undefined),
  [undefined, 0]
);

```

#### 27.6.5 剩余参数（ES6）

剩余参数通过在标识符前加三个点（`...`）来声明。在函数或方法调用期间，它接收一个包含所有剩余参数的数组。如果没有额外的参数在末尾，它是一个空数组——例如：

```js
function f(x, ...y) {
  return [x, y];
}
assert.deepEqual(
  f('a', 'b', 'c'), ['a', ['b', 'c']]
);
assert.deepEqual(
  f(), [undefined, []]
);

```

与我们如何使用剩余参数相关的有两个限制：

+   我们不能在函数定义中使用多个剩余参数。

    ```js
    assert.throws(
      () => eval('function f(...x, ...y) {}'),
      /^SyntaxError: Rest parameter must be last formal parameter$/
    );

    ```

+   剩余参数必须始终放在最后。因此，我们不能像这样访问最后一个参数：

    ```js
    assert.throws(
      () => eval('function f(...restParams, lastParam) {}'),
      /^SyntaxError: Rest parameter must be last formal parameter$/
    );

    ```

##### 27.6.5.1 通过剩余参数强制指定一定数量的参数

我们可以使用剩余参数来强制指定一定数量的参数。例如，以下是一个函数：

```js
function createPoint(x, y) {
  return {x, y};
    // same as {x: x, y: y}
}

```

这是我们强制调用者始终提供两个参数的方式：

```js
function createPoint(...args) {
  if (args.length !== 2) {
    throw new Error('Please provide exactly 2 arguments!');
  }
  const [x, y] = args; // (A)
  return {x, y};
}

```

在行 A 中，我们通过*解构赋值*访问`args`的元素。

#### 27.6.6 命名参数

当有人调用一个函数时，调用者提供的参数会被分配给接收者接收的参数。执行映射的两种常见方式是：

1.  位置参数：如果一个参数与一个参数具有相同的位置，则将其分配给该参数。只有位置参数的函数调用看起来如下。

    ```js
    selectEntries(3, 20, 2)

    ```

1.  命名参数：如果一个参数与一个参数具有相同的名称，则将其分配给该参数。JavaScript 没有命名参数，但我们可以模拟它们。例如，这是一个只有（模拟的）命名参数的函数调用：

    ```js
    selectEntries({start: 3, end: 20, step: 2})

    ```

命名参数有几个优点：

+   它们导致代码更具自解释性，因为每个参数都有一个描述性的标签。只需比较`selectEntries()`的两个版本：在第二个版本中，更容易看到发生了什么。

+   参数的顺序无关紧要（只要名称正确）。

+   处理多个可选参数更方便：调用者可以轻松提供所有可选参数的任何子集，而无需了解他们省略了哪些（使用位置参数时，我们必须填写前面的可选参数，使用`undefined`）。

#### 27.6.7 模拟命名参数 (ES6)

JavaScript 没有真正的命名参数。官方模拟它们的方式是通过对象字面量：

```js
function selectEntries({start=0, end=-1, step=1}) {
  return {start, end, step};
}

```

这个函数使用*解构赋值*来访问其单个参数的属性。它使用的模式是以下模式的缩写：

```js
{start: start=0, end: end=-1, step: step=1}

```

这种解构模式适用于空对象字面量：

```js
> selectEntries({})
{ start: 0, end: -1, step: 1 }

```

但如果我们不带任何参数调用函数，则不起作用：

```js
> selectEntries()
TypeError: Cannot read properties of undefined (reading 'start')

```

我们可以通过为整个模式提供默认值来修复这个问题。这个默认值与更简单的参数定义中的默认值作用相同：如果参数缺失，则使用默认值。

```js
function selectEntries({start=0, end=-1, step=1} = {}) {
  return {start, end, step};
}
assert.deepEqual(
  selectEntries(),
  { start: 0, end: -1, step: 1 }
);

```

#### 27.6.8 将展开 (`...`) 用于函数调用 (ES6)

如果我们在函数调用参数前放置三个点 (`...`)，则我们 *展开* 它。这意味着该参数必须是一个 *可迭代* 对象并且迭代的值都成为参数。换句话说，单个参数被扩展成多个参数——例如：

```js
function func(x, y) {
  console.log(x);
  console.log(y);
}
const someIterable = ['a', 'b'];
func(...someIterable);
  // same as func('a', 'b')

```

输出：

```js
a
b

```

展开和剩余参数使用相同的语法 (`...`)，但它们服务于相反的目的：

+   剩余参数用于定义函数或方法时。它们将参数收集到数组中。

+   展开参数用于调用函数或方法时。它们将可迭代对象转换为参数。

##### 27.6.8.1 示例：将展开用于 `Math.max()`

`Math.max()` 返回其零个或多个参数中的最大值。然而，它不能用于数组，但展开操作为我们提供了一条出路：

```js
> Math.max(-1, 5, 11, 3)
11
> Math.max(...[-1, 5, 11, 3])
11
> Math.max(-1, ...[-5, 11], 3)
11

```

##### 27.6.8.2 示例：将展开用于 `Array.prototype.push()`

同样，数组方法 `.push()` 会破坏性地将其零个或多个参数添加到数组的末尾。JavaScript 没有方法可以破坏性地将一个数组追加到另一个数组中。又一次，我们通过展开操作得以幸免：

```js
const arr1 = ['a', 'b'];
const arr2 = ['c', 'd'];

arr1.push(...arr2);
assert.deepEqual(arr1, ['a', 'b', 'c', 'd']);

```

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：参数处理**

+   位置参数：`exercises/callables/positional_parameters_test.mjs`

+   命名参数：`exercises/callables/named_parameters_test.mjs`

### 27.7 函数方法：`.call()`、`.apply()`、`.bind()`

函数是对象，并且具有方法。在本节中，我们将探讨其中三种方法：`.call()`、`.apply()` 和 `.bind()`。

#### 27.7.1 函数方法 `.call()`

每个函数 `someFunc` 都有以下方法：

```js
someFunc.call(thisValue, arg1, arg2, arg3);

```

这个方法调用大致等同于以下函数调用：

```js
someFunc(arg1, arg2, arg3);

```

然而，使用 `.call()`，我们也可以为隐式参数 `this`指定一个值。换句话说：`.call()` 使得隐式参数 `this` 明确化。

以下代码演示了 `.call()` 的使用：

```js
function func(x, y) {
  return [this, x, y];
}

assert.deepEqual(
  func.call('hello', 'a', 'b'),
  ['hello', 'a', 'b']
);

```

如我们之前所见，如果我们对一个普通函数进行函数调用，其 `this` 是 `undefined`：

```js
assert.deepEqual(
  func('a', 'b'),
  [undefined, 'a', 'b']
);

```

因此，前面的函数调用等同于：

```js
assert.deepEqual(
  func.call(undefined, 'a', 'b'),
  [undefined, 'a', 'b']
);

```

在箭头函数中，通过 `.call()`（或其他方式）提供的 `this` 值将被忽略。

#### 27.7.2 函数方法 `.apply()`

每个函数 `someFunc` 都有以下方法：

```js
someFunc.apply(thisValue, [arg1, arg2, arg3]);

```

这种方法调用大致等同于以下函数调用（使用了 展开操作）：

```js
someFunc(...[arg1, arg2, arg3]);

```

然而，使用 `.apply()`，我们还可以指定 隐式参数 `this` 的值。

以下代码演示了 `.apply()` 的使用：

```js
function func(x, y) {
  return [this, x, y];
}

const args = ['a', 'b'];
assert.deepEqual(
  func.apply('hello', args),
  ['hello', 'a', 'b']
);

```

#### 27.7.3 函数方法 `.bind()`

`.bind()` 是函数对象的另一种方法。该方法如下调用：

```js
const boundFunc = someFunc.bind(thisValue, arg1, arg2);

```

`.bind()` 返回一个新的函数 `boundFunc()`。调用该函数时，将使用 `thisValue` 设置 `this` 并使用这些参数：`arg1`、`arg2`，然后是 `boundFunc()` 的参数。

即，以下两个函数调用是等价的：

```js
boundFunc('a', 'b')
someFunc.call(thisValue, arg1, arg2, 'a', 'b')

```

##### 27.7.3.1 `.bind()` 的替代方法

另一种预先填充 `this` 和参数的方法是通过箭头函数：

```js
const boundFunc2 = (...args) =>
  someFunc.call(thisValue, arg1, arg2, ...args);

```

##### 27.7.3.2 `.bind()` 的实现

考虑到上一节，`.bind()` 可以实现为一个真正的函数，如下所示：

```js
function bind(func, thisValue, ...boundArgs) {
  return (...args) =>
    func.call(thisValue, ...boundArgs, ...args);
}

```

##### 27.7.3.3 示例：绑定真正的函数

对于真正的函数使用 `.bind()` 有点不直观，因为我们必须提供一个 `this` 的值。鉴于在函数调用期间它是 `undefined`，通常将其设置为 `undefined` 或 `null`。

在以下示例中，我们创建 `add8()`，一个只有一个参数的函数，通过将 `add()` 的第一个参数绑定到 `8`。

```js
function add(x, y) {
  return x + y;
}

const add8 = add.bind(undefined, 8);
assert.equal(add8(1), 9);

```
