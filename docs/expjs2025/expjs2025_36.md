# 30 对象

> 原文：[`exploringjs.com/js/book/ch_objects.html`](https://exploringjs.com/js/book/ch_objects.html)

1.  30.1 速查表：对象

    1.  30.1.1 速查表：单个对象

    1.  30.1.2 速查表：原型链

1.  30.2 什么是对象？

    1.  30.2.1 使用对象的方式

1.  30.3 固定布局对象

    1.  30.3.1 对象字面量：属性

    1.  30.3.2 对象字面量：属性值简写

    1.  30.3.3 获取属性

    1.  30.3.4 设置属性

    1.  30.3.5 对象字面量：方法

    1.  30.3.6 对象字面量：访问器

1.  30.4 对象字面量中的展开（`...`）（ES2018）

    1.  30.4.1 展开的使用场景：缺失属性的默认值

    1.  30.4.2 展开的使用场景：非破坏性更改属性

    1.  30.4.3 “破坏性展开”：`Object.assign()`（ES6）

1.  30.5 复制对象：展开与`Object.assign()`与`structuredClone()`的比较

    1.  30.5.1 通过展开复制对象是*浅拷贝*

    1.  30.5.2 通过`structuredClone()`深度复制对象

    1.  30.5.3 `structuredClone()`可以复制哪些值？

    1.  30.5.4 复制的对象属性

    1.  30.5.5 没有`structuredClone()`限制的替代方案？

    1.  30.5.6 本节来源

1.  30.6 方法和特殊变量`this`

    1.  30.6.1 方法是其值为函数的属性

    1.  30.6.2 特殊变量`this`

    1.  30.6.3 方法和`.call()`

    1.  30.6.4 方法和`.bind()`

    1.  30.6.5 `this`陷阱：提取方法

    1.  30.6.6 `this`陷阱：意外遮蔽`this`

    1.  30.6.7 不同上下文中`this`的值（高级）

1.  30.7 属性获取和方法调用中的可选链（ES2020）（高级）

    1.  30.7.1 示例：可选固定属性获取

    1.  30.7.2 运算符的详细说明（高级）

    1.  30.7.3 使用可选属性获取进行短路

    1.  30.7.4 可选链的缺点和替代方案

    1.  30.7.5 常见问题

1.  30.8 原型链

    1.  30.8.1 JavaScript 的操作：所有属性与自有属性

    1.  30.8.2 陷阱：只有原型链的第一个成员会被修改

    1.  30.8.3 使用原型的技巧（高级）

    1.  30.8.4 `Object.hasOwn()`: 给定属性是否为自有（非继承的）？

    1.  30.8.5 通过原型共享数据

1.  30.9 字典对象（高级）

    1.  30.9.1 对象字面量中的引号键

    1.  30.9.2 对象字面量中的计算键

    1.  30.9.3 `in` 操作符：是否存在具有给定键的属性？

    1.  30.9.4 删除属性

    1.  30.9.5 可枚举性

    1.  30.9.6 通过 `Object.keys()` 等列出属性键

    1.  30.9.7 通过 `Object.values()` 列出属性值

    1.  30.9.8 通过 `Object.entries()` 列出属性条目（ES2017）

    1.  30.9.9 属性按确定性列出

    1.  30.9.10 通过 `Object.fromEntries()` 组装对象（ES2019）

    1.  30.9.11 具有 `null` 原型的对象是好的字典和查找表

1.  30.10 属性属性和属性描述符（ES5）（高级）

1.  30.11 保护对象不被更改（ES5）（高级）

1.  30.12 快速参考：`Object`

    1.  30.12.1 `Object.*`：创建对象，处理原型

    1.  30.12.2 `Object.*`：属性属性

    1.  30.12.3 `Object.*`：属性键、值、条目

    1.  30.12.4 `Object.*`：保护对象

    1.  30.12.5 `Object.*`：杂项

    1.  30.12.6 `Object.prototype.*`

1.  30.13 快速参考：`Reflect`

    1.  30.13.1 `Reflect.*` 与 `Object.*`

在本书中，JavaScript 的面向对象编程（OOP）风格分四步介绍。本章涵盖第 1 步和第 2 步；下一章涵盖第 3 步和第 4 步。步骤如下（图 30.1）：

1.  **单个对象（本章）：**JavaScript 的基本 OOP 构建块 *对象* 在独立状态下是如何工作的？

1.  **原型链（本章）：**每个对象都有一个零个或多个 *原型对象* 的链。原型是 JavaScript 的核心继承机制。

1.  **类（下一章）：** JavaScript 的*类*是对象的工厂。类与其实例之间的关系基于原型继承（步骤 2）。

1.  **子类化（下一章）：** 子类与其超类之间的关系也是基于原型继承。

![](img/98f9d262c296ae1a67f569088f87168c.png)

图 30.1：本书通过四个步骤介绍了 JavaScript 中的面向对象编程。

### 30.1 速查表：对象

#### 30.1.1 速查表：单个对象

通过*对象字面量*创建对象（以花括号开始和结束）：

```js
const myObject = { // object literal
  myProperty: 1,
  myMethod() {
 return 2;
 }, // comma!
 get myAccessor() {
 return this.myProperty;
 }, // comma!
 set myAccessor(value) {
 this.myProperty = value;
 }, // last comma is optional
};

assert.equal(
 myObject.myProperty, 1
);
assert.equal(
 myObject.myMethod(), 2
);
assert.equal(
 myObject.myAccessor, 1
);
myObject.myAccessor = 3;
assert.equal(
 myObject.myProperty, 3
);

```

能够直接创建对象（而不使用类）是 JavaScript 的一个亮点。

对象的展开操作：

```js
const original = {
  a: 1,
  b: {
    c: 3,
  },
};

// Spreading (...) copies one object “into” another one:
const modifiedCopy = {
  ...original, // spreading
  d: 4,
};

assert.deepEqual(
  modifiedCopy,
  {
    a: 1,
    b: {
      c: 3,
    },
    d: 4,
  }
);

// Caveat: spreading copies shallowly (property values are shared)
modifiedCopy.a = 5; // does not affect `original`
modifiedCopy.b.c = 6; // affects `original`
assert.deepEqual(
  original,
  {
    a: 1, // unchanged
    b: {
      c: 6, // changed
    },
  },
);

```

我们还可以使用展开操作来创建一个未修改的（浅拷贝）对象：

```js
const exactCopy = {...obj};

```

#### 30.1.2 速查表：原型链

原型是 JavaScript 的基本继承机制。即使是类也是基于它。每个对象都有一个`null`或对象作为其原型。后者对象也可以有原型，等等。一般来说，我们得到*原型链*。

原型是这样管理的：

```js
// `obj1` has no prototype (its prototype is `null`)
const obj1 = Object.create(null); // (A)
assert.equal(
  Object.getPrototypeOf(obj1), null // (B)
);

// `obj2` has the prototype `proto`
const proto = {
  protoProp: 'protoProp',
};
const obj2 = {
  __proto__: proto, // (C)
  objProp: 'objProp',
}
assert.equal(
  Object.getPrototypeOf(obj2), proto
);

```

注意事项：

+   在创建对象时设置对象的原型：行 A，行 C

+   获取对象的原型：行 B

每个对象继承其原型的所有属性：

```js
// `obj2` inherits .protoProp from `proto`
assert.equal(
  obj2.protoProp, 'protoProp'
);
assert.deepEqual(
  Reflect.ownKeys(obj2),
  ['objProp'] // own properties of `obj2`
);

```

对象的非继承属性称为其*自有*属性。

原型的最重要用途是，多个对象可以通过从公共原型继承来共享方法。

### 30.2 什么是对象？

JavaScript 中的对象：

+   对象是一组*槽位*（键值对）。

+   公共槽位称为*属性*：

    +   属性键只能是一个字符串或一个符号。

+   私有槽位只能通过类创建，并在“公共槽位（属性）与私有槽位”（§31.2.4）中解释。

#### 30.2.1 使用对象的方式

在 JavaScript 中有两种使用对象的方式：

+   固定布局对象：以这种方式使用，对象就像数据库中的记录。它们有固定数量的属性，其键在开发时已知。它们的值通常具有不同的类型。

    ```js
    const fixedLayoutObject = {
      product: 'carrot',
      quantity: 4,
    };

    ```

+   字典对象：以这种方式使用，对象就像查找表或映射。它们有可变数量的属性，其键在开发时未知。它们的值具有相同的类型。

    ```js
    const dictionaryObject = {
      ['one']: 1,
      ['two']: 2,
    };

    ```

注意，两种方式也可以混合使用：一些对象既是固定布局对象也是字典对象。

使用对象的方式会影响本章中对它们的解释：

+   首先，我们将探索固定布局对象。 尽管在底层属性键是字符串或符号，但它们将对我们显示为固定标识符。

+   稍后我们将探索字典对象。 注意，映射通常比对象更好的字典。然而，我们将遇到的一些操作对于固定布局对象也是有用的。

### 30.3 固定布局对象

让我们先探索**固定布局对象**。

#### 30.3.1 对象字面量：属性

**对象字面量**是创建固定布局对象的一种方式。它是 JavaScript 的一个突出特点：我们可以直接创建对象——不需要类！以下是一个示例：

```js
const jane = {
  first: 'Jane',
  last: 'Doe', // optional trailing comma
};

```

在示例中，我们通过对象字面量创建了一个对象，它以大括号 `{}` 开头和结尾。在其中，我们定义了两个**属性**（键值对）：

+   第一个属性具有键 `first` 和值 `'Jane'`。

+   第二个属性具有键 `last` 和值 `'Doe'`。

自 ES5 以来，对象字面量允许使用尾随逗号。

我们将稍后看到其他指定属性键的方法，但使用这种方法指定时，它们必须遵循 JavaScript 变量名的规则。例如，我们可以使用 `first_name` 作为属性键，但不能使用 `first-name`）。然而，允许使用保留字：

```js
const obj = {
  if: true,
  const: true,
};

```

为了检查各种操作对对象的影响，我们将在本章的这一部分偶尔使用 `Object.keys()`。它列出了属性键：

```js
> Object.keys({a:1, b:2})
[ 'a', 'b' ]

```

#### 30.3.2 对象字面量：属性值简写

当属性的值通过具有与键相同名称的变量定义时，我们可以省略键。

```js
function createPoint(x, y) {
  return {x, y}; // Same as: {x: x, y: y}
}
assert.deepEqual(
  createPoint(9, 2),
  { x: 9, y: 2 }
);

```

#### 30.3.3 获取属性

这是我们如何**获取**（读取）一个属性（行 A）：

```js
const jane = {
  first: 'Jane',
  last: 'Doe',
};

// Get property .first
assert.equal(jane.first, 'Jane'); // (A)

```

获取一个未知属性会产生 `undefined`：

```js
assert.equal(jane.unknownProperty, undefined);

```

#### 30.3.4 设置属性

这是我们如何**设置**（写入）一个属性（行 A）：

```js
const obj = {
  prop: 1,
};
assert.equal(obj.prop, 1);
obj.prop = 2; // (A)
assert.equal(obj.prop, 2);

```

我们通过设置更改了一个现有的属性。如果我们设置一个未知的属性，我们将创建一个新的条目：

```js
const obj = {}; // empty object
assert.deepEqual(
  Object.keys(obj), []);

obj.unknownProperty = 'abc';
assert.deepEqual(
  Object.keys(obj), ['unknownProperty']);

```

#### 30.3.5 对象字面量：方法

以下代码展示了如何通过对象字面量创建方法 `.says()`：

```js
const jane = {
  first: 'Jane', // value property
  says(text) {   // method
    return `${this.first} says “${text}”`; // (A)
  }, // comma as separator (optional at end)
};
assert.equal(jane.says('hello'), 'Jane says “hello”');

```

在方法调用 `jane.says('hello')` 中，`jane` 被称为方法调用的**接收者**，并分配给特殊变量 `this`（关于 `this` 的更多信息请参阅“方法和特殊变量 `this`” (§30.6))。这使得方法 `.says()` 能够访问行 A 中的兄弟属性 `.first`。

![练习图标“exercise”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：通过对象字面量创建对象**

`exercises/objects/color_point_object_test.mjs`

#### 30.3.6 对象字面量：访问器

**访问器**是通过访问属性来调用的方法。它由以下一个或两个组成：

+   **获取器**是通过获取属性来调用的。

+   **设置器**是通过设置属性来调用的。

##### 30.3.6.1 获取器

通过在方法定义前缀添加修饰符 `get` 来创建获取器：

```js
const jane = {
  first: 'Jane',
  last: 'Doe',
  get full() {
    return `${this.first} ${this.last}`;
  },
};

assert.equal(jane.full, 'Jane Doe');
jane.first = 'John';
assert.equal(jane.full, 'John Doe');

```

##### 30.3.6.2 设置器

通过在方法定义前缀添加修饰符 `set` 创建一个设置器：

```js
const jane = {
  first: 'Jane',
  last: 'Doe',
  set full(fullName) {
    const parts = fullName.split(' ');
    this.first = parts[0];
    this.last = parts[1];
  },
};

jane.full = 'Richard Roe';
assert.equal(jane.first, 'Richard');
assert.equal(jane.last, 'Roe');

```

##### 30.3.6.3 getter 的使用场景：值会改变的只读属性

在以下代码中，计数器的实际值是私有的。从外部，它只能通过 getter 读取：

```js
function createCounter() {
 // Private data via closure
 let value = 0;
 return {
 get value() {
 return value;
 },
 inc() {
 value++;
 },
 };
}

const counter = createCounter();
assert.equal(counter.value, 0);

counter.inc();
assert.equal(counter.value, 1);

assert.throws(
 () => counter.value = 5,
 /^TypeError: Cannot set property value of #<Object> which has only a getter$/
); 
```

![Icon “exercise”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：通过对象实现堆栈**

`exercises/objects/stack-via-object_test.mjs`

##### 30.3.6.4 getter 的使用场景：从属性切换到更多封装

在面向对象编程中，我们担心暴露过多的内部状态。访问器使我们能够在不破坏现有代码的情况下改变我们对属性的看法：我们可以从暴露开始，使用正常属性，然后切换到访问器和更多的封装。

### 30.4 将传播应用于对象字面量（`...`）^(ES2018)

在对象字面量内部，一个 *传播属性* 将另一个对象的属性添加到当前对象中：

```js
const obj1 = {a: 1, b: 2};
const obj2 = {c: 3};
assert.deepEqual(
  {...obj1, ...obj2, d: 4},
  {a: 1, b: 2, c: 3, d: 4}
);

```

如果属性键冲突，最后提到的属性“获胜”：

```js
> const obj = {one: 1, two: 2, three: 3};
> {...obj, one: true}
{ one: true, two: 2, three: 3 }
> {one: true, ...obj}
{ one: 1, two: 2, three: 3 }

```

所有值都是可传播的，即使是 `undefined` 和 `null`：

```js
> {...undefined}
{}
> {...null}
{}
> {...123}
{}
> {...'abc'}
{ '0': 'a', '1': 'b', '2': 'c' }
> {...['a', 'b']}
{ '0': 'a', '1': 'b' }

```

字符串和数组中 `.length` 属性对此类操作是隐藏的（它不是 *可枚举的*；有关更多信息，请参阅“属性属性和属性描述符^(ES5) (高级)” (§30.10)）。

传播包括键为符号（由 `Object.keys()`、`Object.values()` 和 `Object.entries()` 忽略）的属性：

```js
const symbolKey = Symbol('symbolKey');
const obj = {
  stringKey: 1,
  [symbolKey]: 2,
};
assert.deepEqual(
  {...obj, anotherStringKey: 3},
  {
    stringKey: 1,
    [symbolKey]: 2,
    anotherStringKey: 3,
  }
);

```

#### 30.4.1 传播的使用场景：缺失属性的默认值

如果我们的代码的输入之一是一个包含数据的对象，我们可以通过指定默认值来使属性可选，如果这些属性缺失，则使用这些默认值。完成此操作的一种技术是通过一个其属性包含默认值的对象。在以下示例中，该对象是 `DEFAULTS`：

```js
const DEFAULTS = {alpha: 'a', beta: 'b'};
const providedData = {alpha: 1};

const allData = {...DEFAULTS, ...providedData};
assert.deepEqual(allData, {alpha: 1, beta: 'b'});

```

结果，对象 `allData` 是通过复制 `DEFAULTS` 并用 `providedData` 的属性覆盖其属性创建的。

但我们不需要对象来指定默认值；我们也可以在对象字面量内部单独指定它们：

```js
const providedData = {alpha: 1};

const allData = {alpha: 'a', beta: 'b', ...providedData};
assert.deepEqual(allData, {alpha: 1, beta: 'b'});

```

#### 30.4.2 传播的使用场景：非破坏性地更改属性

到目前为止，我们已经遇到了一种更改对象属性 `.alpha` 的方法：我们 *设置* 它（行 A）并修改对象。也就是说，这种更改属性的方式是破坏性的。

```js
const obj = {alpha: 'a', beta: 'b'};
obj.alpha = 1; // (A)
assert.deepEqual(obj, {alpha: 1, beta: 'b'});

```

使用传播，我们可以非破坏性地更改 `.alpha` – 我们创建一个 `obj` 的副本，其中 `.alpha` 的值不同：

```js
const obj = {alpha: 'a', beta: 'b'};
const updatedObj = {...obj, alpha: 1};
assert.deepEqual(updatedObj, {alpha: 1, beta: 'b'});

```

![Icon “exercise”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：通过传播（固定键）非破坏性地更新属性**

`exercises/objects/update_name_test.mjs`

#### 30.4.3 “破坏性展开”：`Object.assign()` (ES6)

`Object.assign()` 是一个工具方法：

```js
Object.assign(target, source_1, source_2, ···)

```

这个表达式将 `source_1` 的所有属性赋值给 `target`，然后是 `source_2` 的所有属性，等等。最后，它返回 `target`——例如：

```js
const target = { a: 1 };

const result = Object.assign(
  target,
  {b: 2},
  {c: 3, b: true}
);

assert.deepEqual(
  result, { a: 1, b: true, c: 3 }
);
// target was modified and returned:
assert.equal(result, target);

```

`Object.assign()` 的用例与展开属性的用例相似。在某种程度上，它是破坏性地展开。

### 30.5 复制对象：展开与 `Object.assign()` 与 `structuredClone()`

#### 30.5.1 通过展开复制对象是浅复制

在 JavaScript 中复制数组和普通对象的一种常见方法是使用展开。以下代码演示了后者：

```js
const obj = {id: 'e1fd960b', values: ['a', 'b']};
const shallowCopy = {...obj};

```

可惜，这种复制方式是浅复制：属性（键值对）被复制，但属性值没有被复制。

一方面，键值对 `shallowCopy.id` 是一个复制，所以修改它不会改变 `obj`：

```js
shallowCopy.id = 'yes';
assert.equal(obj.id, 'e1fd960b');

```

另一方面，`shallowCopy.values` 中的数组与 `obj` 共享。如果我们修改它，也会修改 `obj`：

```js
shallowCopy.values.push('x');
assert.deepEqual(
  shallowCopy, {id: 'yes', values: ['a', 'b', 'x']}
);
assert.deepEqual(
  obj, {id: 'e1fd960b', values: ['a', 'b', 'x']}
);

```

通过 `Object.assign()` 复制与通过展开类似，也是浅复制：

```js
const obj = {id: 'e1fd960b', values: ['a', 'b']};
// Copy the properties of `obj` into a new object
const shallowCopy = Object.assign({}, obj);

```

#### 30.5.2 通过 `structuredClone()` 深度复制对象

`structuredClone()` 是一个用于复制的函数。尽管它不是 ECMAScript 的一部分，但它被所有主要的 JavaScript 平台良好支持。[良好支持](https://developer.mozilla.org/en-US/docs/Web/API/Window/structuredClone#browser_compatibility)。它有以下类型签名：

```js
structuredClone(value: any): any

```

`structuredClone()` 深度复制对象：

```js
const obj = {id: 'e1fd960b', values: ['a', 'b']};
const deepCopy = structuredClone(obj);

deepCopy.values.push('x');
assert.deepEqual(
  deepCopy, {id: 'e1fd960b', values: ['a', 'b', 'x']}
);
assert.deepEqual(
  obj, {id: 'e1fd960b', values: ['a', 'b']}
);

```

![图标“详情”](img/38ba63de820aae6f94a019538ae0f222.png) **`structuredClone()` 有第二个参数**

`structuredClone()` 有一个超出本章范围的第二个参数。更多信息，请参阅：

+   “通过 `structuredClone()` 转移 ArrayBuffer”（§35.7.3）

+   [关于 `structuredClone()` 的 MDN 页面](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone)

#### 30.5.3 `structuredClone()` 可以复制哪些值？

+   它可以复制所有原始值，除了符号。

+   它可以复制所有内置对象，除了函数和 DOM 节点。

+   用户定义类的实例变为普通对象。

+   私有字段不会被复制。

+   循环引用被正确复制。

由于 `structuredClone()` 的原始用途是将对象复制到其他进程，这些限制是有意义的。

继续阅读以获取更多信息。

##### 30.5.3.1 大多数原始值都可以复制

```js
> typeof structuredClone(true)
'boolean'
> typeof structuredClone(123)
'number'
> typeof structuredClone(123n)
'bigint'
> typeof structuredClone('abc')
'string'

```

##### 30.5.3.2 大多数内置对象可以被复制

数组和普通对象可以被复制：

```js
> structuredClone({prop: true})
{ prop: true }
> structuredClone(['a', 'b', 'c'])
[ 'a', 'b', 'c' ]

```

大多数内置类的实例可以被复制——即使它们有内部槽位。它们仍然是它们类的一个实例。

```js
> structuredClone(/^a+$/) instanceof RegExp
true
> structuredClone(new Date()) instanceof Date
true

```

##### 30.5.3.3 复制符号和一些对象会产生异常

符号和一些对象不能被复制——如果我们尝试复制它们，或者尝试复制包含它们的对象，`structuredClone()` 会抛出 `DOMException`：

+   符号

+   函数（普通函数、箭头函数、类、方法）

+   DOM 节点

示例——克隆符号：

```js
> structuredClone(Symbol())
DOMException [DataCloneError]: Symbol() could not be cloned.
> structuredClone({[Symbol()]: true}) // property is ignored
{}
> structuredClone({prop: Symbol()})
DOMException [DataCloneError]: Symbol() could not be cloned.

```

示例——克隆函数：

```js
> structuredClone(function () {}) // ordinary function
DOMException [DataCloneError]: function () {} could not be cloned.
> structuredClone(() => {}) // arrow function
DOMException [DataCloneError]: () => {} could not be cloned.
> structuredClone(class {})
DOMException [DataCloneError]: class {} could not be cloned.

> structuredClone({ m(){} }.m) // method
DOMException [DataCloneError]: m(){} could not be cloned.
> structuredClone({ m(){} }) // object with method
DOMException [DataCloneError]: m(){} could not be cloned. 
```

`structuredClone()` 抛出的异常是什么样的？

```js
try {
  structuredClone(() => {});
} catch (err) {
  assert.equal(
    err instanceof DOMException, true
  );
  assert.equal(
    err.name, 'DataCloneError'
  );
  assert.equal(
    err.code, DOMException.DATA_CLONE_ERR
  );
}

```

##### 30.5.3.4 用户定义类的实例变为普通对象

在以下示例中，我们复制了类 `C` 的一个实例。结果 `copy` 不是一个 `C` 的实例。

```js
class C {}
const copy = structuredClone(new C());

assert.equal(copy instanceof C, false);
assert.equal(
  Object.getPrototypeOf(copy),
  Object.prototype
);

```

##### 30.5.3.5 私有字段不会被复制

这种限制与前面的子节有关——私有字段不会被 `structuredClone()` 复制：

```js
class C {
  static hasPrivateField(value) {
    return #privateField in value;
  }
  #privateField = true;
}

const original = new C();
assert.equal(
  C.hasPrivateField(original), true
);
const copy = structuredClone(original);
assert.equal(
  C.hasPrivateField(copy), false
);

```

##### 30.5.3.6 循环引用被正确复制

如果我们复制一个具有引用循环的对象，结果具有相同的结构：

```js
const cycle = {};
cycle.prop = cycle;

const copy = structuredClone(cycle);
assert.equal(
  copy.prop, copy
);

```

#### 30.5.4 复制对象的属性属性

`structuredClone()` 并不总是忠实地复制对象的 属性属性：

+   访问器被转换为数据属性。

+   在复制中，属性属性始终具有默认值。

查看更多信息。

##### 30.5.4.1 访问器变为数据属性

访问器变为数据属性：

```js
const obj = Object.defineProperties(
  {},
  {
    accessor: {
      get: function () {
 return 123;
 },
 set: undefined,
 enumerable: true,
 configurable: true,
 },
 }
);
const copy = structuredClone(obj);
assert.deepEqual(
 Object.getOwnPropertyDescriptors(copy),
 {
 accessor: {
 value: 123,
 writable: true,
 enumerable: true,
 configurable: true,
 },
 }
);

```

##### 30.5.4.2 属性复制具有默认属性值

复制的数据属性始终具有以下属性：

```js
writable: true,
enumerable: true,
configurable: true,

```

```js
const obj = Object.defineProperties(
  {},
  {
    readOnlyProp: {
      value: 'abc',
      writable: false,
      enumerable: true,
      configurable: false,
    },
  }
);
const copy = structuredClone(obj);
assert.deepEqual(
  Object.getOwnPropertyDescriptors(copy),
  {
    readOnlyProp: {
      value: 'abc',
      writable: true,
      enumerable: true,
      configurable: true,
    }
  }
);

```

#### 30.5.5 没有 `structuredClone()` 限制的替代方案？

如果我们不能忍受 `structuredClone()` 的限制，例如将类的实例转换为普通对象，我们可以使用 Lodash 函数 `cloneDeep()`（它具有更少的限制）。

#### 30.5.6 本节来源

+   [“安全传递结构化数据”部分](https://html.spec.whatwg.org/#safe-passing-of-structured-data) 在 WHATWG HTML 标准中

+   [“结构化克隆算法”](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm) 在 MDN

+   [“`structuredClone()`”](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone) 在 MDN

### 30.6 方法和特殊变量 `this`

#### 30.6.1 方法值是函数的属性

让我们回顾一下用于介绍方法的示例：

```js
const jane = {
  first: 'Jane',
  says(text) {
    return `${this.first} says “${text}”`;
  },
};

```

有点令人惊讶，方法实际上是函数：

```js
assert.equal(typeof jane.says, 'function');

```

为什么会这样？我们在关于可调用值的章节（ch_callables.html#roles-of-ordinary-functions）中了解到，普通函数扮演着多个角色。*方法*是其中之一。因此，在内部，`jane` 大概如下所示。

```js
const jane = {
  first: 'Jane',
  says: function (text) {
    return `${this.first} says “${text}”`;
  },
};

```

#### 30.6.2 特殊变量 `this`

考虑以下代码：

```js
const obj = {
  someMethod(x, y) {
    assert.equal(this, obj); // (A)
    assert.equal(x, 'a');
    assert.equal(y, 'b');
  }
};
obj.someMethod('a', 'b'); // (B)

```

在行 B 中，`obj`是方法调用的*接收者*。它通过一个名为`this`的隐式（隐藏）参数传递给存储在`obj.someMethod`中的函数（行 A）。

![图标“提示”](img/8440b17bb8219cda9f9405ac83c36db0.png) **如何理解`this`**

理解`this`的最佳方式是将它视为普通函数和方法的隐式参数。

#### 30.6.3 方法与 `.call()`

方法是函数，函数本身也有方法。其中一种方法是`.call()`。让我们通过一个示例来了解这个方法是如何工作的。

在上一节中，有这个方法调用：

```js
obj.someMethod('a', 'b')

```

这个调用等价于：

```js
obj.someMethod.call(obj, 'a', 'b');

```

这也是等价的：

```js
const func = obj.someMethod;
func.call(obj, 'a', 'b');

```

`.call()`使通常隐式的参数`this`显式：通过`.call()`调用函数时，第一个参数是`this`，后面跟着常规（显式）函数参数。

作为旁注，这意味着实际上存在两个不同的点操作符：

1.  用于访问属性：`obj.prop`

1.  另一个用于调用方法：`obj.prop()`

它们在以下方面不同：（2）不仅仅是（1）后面跟着函数调用操作符`()`。相反，（2）还提供了`this`的值。

#### 30.6.4 方法与 `.bind()`

`.bind()`是函数对象的一种方法。在下面的代码中，我们使用`.bind()`将方法`.says()`转换为独立的函数`func()`：

```js
const jane = {
  first: 'Jane',
  says(text) {
    return `${this.first} says “${text}”`; // (A)
  },
};

const func = jane.says.bind(jane, 'hello');
assert.equal(func(), 'Jane says “hello”');

```

通过`.bind()`将`this`设置为`jane`在这里至关重要。否则，`func()`将无法正常工作，因为`this`在行 A 中使用。在下一节中，我们将探讨这是为什么。

#### 30.6.5 `this`陷阱：提取方法

我们现在对函数和方法有了相当多的了解，准备看看涉及方法和`this`的最大陷阱：如果我们不小心，从对象中提取的方法进行函数调用可能会失败。

在以下示例中，当我们从`jane.says()`中提取方法，将其存储在变量`func`中，并调用`func`时，我们失败了。

```js
const jane = {
  first: 'Jane',
  says(text) {
    return `${this.first} says “${text}”`;
  },
};
const func = jane.says; // extract the method
assert.throws(
  () => func('hello'), // (A)
  {
    name: 'TypeError',
    message: "Cannot read properties of undefined (reading 'first')",
  }
);

```

在行 A 中，我们正在进行正常的函数调用。在正常的函数调用中，`this`是`undefined`（如果严格模式处于活动状态，这几乎总是如此）。因此，行 A 等价于：

```js
assert.throws(
  () => jane.says.call(undefined, 'hello'), // `this` is undefined!
  {
    name: 'TypeError',
    message: "Cannot read properties of undefined (reading 'first')",
  }
);

```

我们如何修复这个问题？我们需要使用`.bind()`来提取方法`.says()`：

```js
const func2 = jane.says.bind(jane);
assert.equal(func2('hello'), 'Jane says “hello”');

```

`.bind()`确保在调用`func()`时`this`始终是`jane`。

我们还可以使用箭头函数来提取方法：

```js
const func3 = text => jane.says(text);
assert.equal(func3('hello'), 'Jane says “hello”');

```

##### 30.6.5.1 示例：提取方法

以下是在实际 Web 开发中可能看到的简化代码版本：

```js
class ClickHandler {
  constructor(id, elem) {
    this.id = id;
    elem.addEventListener('click', this.handleClick); // (A)
  }
  handleClick(event) {
    alert('Clicked ' + this.id);
  }
}

```

在行 A 中，我们没有正确提取方法`.handleClick()`。相反，我们应该这样做：

```js
const listener = this.handleClick.bind(this);
elem.addEventListener('click', listener);

// Later, possibly:
elem.removeEventListener('click', listener);

```

每次调用`.bind()`都会创建一个新的函数。这就是为什么如果我们想在以后删除它，我们需要将结果存储在某个地方的原因。

##### 30.6.5.2 避免提取方法的陷阱

可惜，没有简单的方法可以绕过提取方法的陷阱：每次我们提取一个方法时，我们必须小心并正确地执行它——例如，通过绑定 `this` 或使用箭头函数。

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：提取方法**

`exercises/objects/method_extraction_exrc.mjs`

#### 30.6.6 `this` 陷阱：意外覆盖 `this`

![图标“提示”](img/8440b17bb8219cda9f9405ac83c36db0.png) **意外覆盖 `this` 只是在普通函数中是一个问题**

箭头函数不会覆盖 `this`。

考虑以下问题：当我们处于普通函数内部时，我们无法访问周围作用域的 `this`，因为普通函数有自己的 `this`。换句话说，内层作用域中的变量会隐藏外层作用域中的变量。这被称为*覆盖*。以下代码是一个示例：

```js
const prefixer = {
  prefix: '==> ',
  prefixStringArray(stringArray) {
    return stringArray.map(
      function (x) {
        return this.prefix + x; // (A)
      });
  },
};
assert.throws(
  () => prefixer.prefixStringArray(['a', 'b']),
  {
    name: 'TypeError',
    message: "Cannot read properties of undefined (reading 'prefix')",
  }
);

```

在行 A，我们想要访问 `.prefixStringArray()` 的 `this`。但我们无法做到，因为周围普通函数有自己的 `this`，它会*覆盖*（并阻止访问）方法的 `this`。由于回调是函数调用，前者的 `this` 值是 `undefined`。这解释了错误信息。

解决这个问题的最简单方法是使用箭头函数，它没有自己的 `this`，因此不会覆盖任何内容：

```js
const prefixer = {
  prefix: '==> ',
  prefixStringArray(stringArray) {
    return stringArray.map(
      (x) => {
        return this.prefix + x;
      });
  },
};
assert.deepEqual(
  prefixer.prefixStringArray(['a', 'b']),
  ['==> a', '==> b']);

```

我们也可以将 `this` 存储在不同的变量中（行 A），这样它就不会被覆盖：

```js
prefixStringArray(stringArray) {
  const that = this; // (A)
  return stringArray.map(
    function (x) {
      return that.prefix + x;
    });
},

```

另一个选项是通过 `.bind()` 为回调指定一个固定的 `this`（行 A）：

```js
prefixStringArray(stringArray) {
  return stringArray.map(
    function (x) {
      return this.prefix + x;
    }.bind(this)); // (A)
},

```

最后，`.map()` 允许我们指定一个值作为 `this`（行 A），它在调用回调时使用：

```js
prefixStringArray(stringArray) {
  return stringArray.map(
    function (x) {
      return this.prefix + x;
    },
    this); // (A)
},

```

##### 30.6.6.1 避免意外覆盖 `this` 的陷阱

如果我们遵循“建议：优先使用专用函数而不是普通函数”（§27.3.4）的建议，我们可以避免意外覆盖 `this` 的陷阱。以下是总结：

+   将箭头函数用作匿名内联函数。它们没有 `this` 作为隐式参数，也不会覆盖它。

+   对于命名的独立函数声明，我们可以使用箭头函数或函数声明。如果我们选择后者，我们必须确保在它们的主体中不提及 `this`。

#### 30.6.7 在各种上下文中 `this` 的值（高级）

在各种上下文中 `this` 的值是什么？

在可调用实体内部，`this` 的值取决于如何调用该可调用实体以及它是什么类型：

+   函数调用：

    +   普通函数：`this === undefined`（在严格模式下）

    +   箭头函数：`this` 与周围作用域相同（词法 `this`）

+   方法调用：`this` 是调用的接收者

+   `new`：`this` 指向新创建的实例

我们还可以在所有常见的顶层作用域中访问 `this`：

+   `<script>` 元素：`this === globalThis`

+   ECMAScript 模块：`this === undefined`

+   CommonJS 模块：`this === module.exports`

![图标“提示”](img/8440b17bb8219cda9f9405ac83c36db0.png) **提示：在顶层作用域中假装 `this` 不存在**

我喜欢这样做，因为顶层 `this` 很令人困惑，并且有更好的替代方案来解决其（少数）用例。

### 30.7 可选链用于属性获取和方法调用（ES2020）（高级）

存在以下类型的可选链操作：

```js
obj?.prop     // optional fixed property getting
obj?.[«expr»] // optional dynamic property getting
func?.(«arg0», «arg1», ···) // optional function or method call

```

大致的想法是：

+   如果问号前的值既不是 `undefined` 也不是 `null`，则执行问号后的操作。

+   否则，返回 `undefined`。

三个语法中的每一个都会在稍后更详细地介绍。以下是一些初步示例：

```js
> null?.prop
undefined
> {prop: 1}?.prop
1

> null?.(123)
undefined
> String?.(123)
'123'

```

![图标“提示”](img/8440b17bb8219cda9f9405ac83c36db0.png) **可选链操作符（`?.`）的助记符**

你是否偶尔不确定可选链操作符是以点（`.?`）还是问号（`?.`）开头？那么这个助记符可能对你有帮助：

+   **如果** (`?`) 左侧不是空值

+   **then** (`.`) 访问一个属性。

#### 30.7.1 示例：可选固定属性获取

考虑以下数据：

```js
const persons = [
  {
    surname: 'Zoe',
    address: {
      street: {
        name: 'Sesame Street',
        number: '123',
      },
    },
  },
  {
    surname: 'Mariner',
  },
  {
    surname: 'Carmen',
    address: {
    },
  },
];

```

我们可以使用可选链安全地提取街道名称：

```js
const streetNames = persons.map(
  p => p.address?.street?.name);
assert.deepEqual(
  streetNames, ['Sesame Street', undefined, undefined]
);

```

##### 30.7.1.1 通过空值合并处理默认值

空值合并操作符 允许我们使用默认值 `'(no name)'` 而不是 `undefined`：

```js
const streetNames = persons.map(
  p => p.address?.street?.name ?? '(no name)');
assert.deepEqual(
  streetNames, ['Sesame Street', '(no name)', '(no name)']
);

```

#### 30.7.2 详细介绍操作符（高级）

##### 30.7.2.1 可选固定属性获取

以下两个表达式是等价的：

```js
o?.prop
(o !== undefined && o !== null) ? o.prop : undefined

```

示例：

```js
assert.equal(undefined?.prop, undefined);
assert.equal(null?.prop,      undefined);
assert.equal({prop:1}?.prop,  1);

```

##### 30.7.2.2 可选动态属性获取

以下两个表达式是等价的：

```js
o?.[«expr»]
(o !== undefined && o !== null) ? o[«expr»] : undefined

```

示例：

```js
const key = 'prop';
assert.equal(undefined?.[key], undefined);
assert.equal(null?.[key], undefined);
assert.equal({prop:1}?.[key], 1);

```

##### 30.7.2.3 可选函数或方法调用

以下两个表达式是等价的：

```js
f?.(arg0, arg1)
(f !== undefined && f !== null) ? f(arg0, arg1) : undefined

```

示例：

```js
assert.equal(undefined?.(123), undefined);
assert.equal(null?.(123), undefined);
assert.equal(String?.(123), '123');

```

注意，如果其左侧不是可调用的，则此操作符会产生错误：

```js
assert.throws(
  () => true?.(123),
  TypeError);

```

为什么？这个想法是，操作符只容忍故意的省略。不可调用的值（除了 `undefined` 和 `null`）可能是一个错误，应该报告，而不是绕过。

#### 30.7.3 使用可选属性获取进行短路

在属性获取和方法调用链中，一旦第一个可选操作符在其左侧遇到 `undefined` 或 `null`，评估就会停止：

```js
function invokeM(value) {
  return value?.a.b.m(); // (A)
}

const obj = {
  a: {
    b: {
      m() { return 'result' }
 }
 }
};
assert.equal(
 invokeM(obj), 'result'
);
assert.equal(
 invokeM(undefined), undefined // (B)
);

```

考虑 B 行中的 `invokeM(undefined)`：`undefined?.a` 是 `undefined`。因此我们预计 A 行中的 `.b` 会失败。但它没有：`?.` 操作符遇到值 `undefined`，整个表达式的评估立即返回 `undefined`。

这种行为与正常操作符不同，JavaScript 总是在评估操作符之前评估所有操作数。这被称为*短路*。其他短路操作符包括：

+   `(a && b)`: 只有当 `a` 是真值时，才会评估 `b`。

+   `(a || b)`: 只有当 `a` 是假值时，才会评估 `b`。

+   `(c ? t : e)`: 如果 `c` 是真值，则评估 `t`。否则，评估 `e`。

#### 30.7.4 可选链：缺点和替代方案

可选链也有缺点：

+   深层嵌套的结构更难管理。例如，如果有许多属性名序列，重构会更困难：每个序列都强制多个对象的结构。

+   在访问数据时过于宽容会隐藏出问题，这些问题会在以后显现出来，那时调试会更困难。例如，在一系列可选属性名中早期出现的拼写错误比普通拼写错误有更负面的影响。

可选链的另一种替代方法是提取信息一次，在单个位置：

+   我们可以编写一个辅助函数来提取数据。

+   或者我们可以编写一个函数，其输入是深层嵌套的数据，其输出是更简单、规范化的数据。

使用任何一种方法，如果存在问题，都有可能进行检查并在早期失败。

进一步阅读：

+   “[过度防御性编程](https://blog.vcarl.com/overly-defensive-programming/)” by Carl Vitullo

#### 30.7.5 常见问题

##### [30.7.5.1 为什么 `o?.[x]` 和 `f?.()` 中有点？](#why-are-there-dots-in-ox-and-f)

以下两个可选操作符的语法并不理想：

```js
obj?.[«expr»]          // better: obj?[«expr»]
func?.(«arg0», «arg1») // better: func?(«arg0», «arg1»)

```

可惜，这种不太优雅的语法是必要的，因为区分理想语法（第一个表达式）和条件操作符（第二个表达式）太复杂了：

```js
obj?['a', 'b', 'c'].map(x => x+x)
obj ? ['a', 'b', 'c'].map(x => x+x) : []

```

##### 30.7.5.2 为什么 `null?.prop` 评估为 `undefined` 而不是 `null`？

操作符 `?.` 主要关注其右侧：属性 `.prop` 是否存在？如果不存在，则提前停止。因此，保留其左侧的信息很少是有用的。然而，只有一个“早期终止”值确实简化了事情。

### 30.8 原型链

原型是 JavaScript 的唯一继承机制：每个对象都有一个原型，该原型要么是 `null`，要么是一个对象。在后一种情况下，对象继承原型上的所有属性。

在对象字面量中，我们可以通过特殊属性 `__proto__` 设置原型：

```js
const proto = {
  protoProp: 'a',
};
const obj = {
  __proto__: proto,
  objProp: 'b',
};

// obj inherits .protoProp:
assert.equal(obj.protoProp, 'a');
assert.equal('protoProp' in obj, true);

```

由于原型对象本身可以有原型，我们得到一个对象链——所谓的*原型链*。继承让我们有单对象的印象，但实际上我们处理的是对象链。

图 30.2 展示了 `obj` 的原型链看起来像什么。

![](img/3f6a70b31e906acd64d926d104282b8f.png)

图 30.2：`obj` 开始一个对象链，该链继续与 `proto` 和其他对象相连。

非继承属性被称为*自身属性*。`obj`有一个自身属性，`.objProp`。

#### 30.8.1 JavaScript 的操作：所有属性与自身属性

一些操作考虑所有属性（自身和继承的）——例如，获取属性：

```js
> const obj = { one: 1 };
> typeof obj.one // own
'number'
> typeof obj.toString // inherited
'function'

```

其他操作仅考虑自身属性——例如，`Object.keys()`：

```js
> Object.keys(obj)
[ 'one' ]

```

继续阅读，了解另一个仅考虑自身属性的运算：设置属性。

#### 30.8.2 漏洞：原型链的第一个成员是唯一被修改的

给定一个具有原型对象链的对象`obj`，设置`obj`的自身属性只会改变`obj`是有意义的。然而，通过`obj`设置继承属性也只会改变`obj`。它在`obj`中创建了一个新的自身属性，覆盖了继承属性。让我们通过以下对象来探索它是如何工作的：

```js
const proto = {
  protoProp: 'a',
};
const obj = {
  __proto__: proto,
};

```

在下一个代码片段中，我们设置了继承属性`obj.protoProp`（行 A）。通过创建一个自身属性来“改变”它：当读取`obj.protoProp`时，首先找到自身属性，其值*覆盖*了继承属性的值。

```js
// In the beginning, obj has no own properties
assert.deepEqual(Object.keys(obj), []);

obj.protoProp = 'x'; // (A)

// We created an own property:
assert.deepEqual(Object.keys(obj), ['protoProp']);

// The inherited property itself is unchanged:
assert.equal(proto.protoProp, 'a');

// The own property overrides the inherited property:
assert.equal(obj.protoProp, 'x');

```

`obj`的原型链在图 30.3 中展示。

![](img/a36ba2c417a363309e1b3616c9d7810b.png)

图 30.3：`obj`的自身属性`.protoProp`覆盖了从`proto`继承的属性。

#### 30.8.3 使用原型的技巧（高级）

##### 30.8.3.1 获取和设置原型

关于属性键`__proto__`的建议：

+   不要使用所有`Object`实例都具有的访问器`Object.prototype.__proto__`：

    +   它不能与所有对象一起使用——例如，不是`Object`实例的对象没有它。

    +   它在 ECMAScript 规范中已被弃用。

    有关此功能的更多信息，请参阅“`Object.prototype.__proto__` (访问器) (§31.9.7)”.

+   在对象字面量中使用属性键`__proto__`来指定原型是不同的：这是一个仅适用于对象字面量的特性，碰巧与已弃用的访问器有相同的名称。

获取和设置原型的推荐方法如下：

+   获取对象的原型：

    ```js
    Object.getPrototypeOf(obj: object): object

    ```

+   设置对象原型的最佳时机是在创建对象时。我们可以通过对象字面量中的`__proto__`或以下方式来实现：

    ```js
    Object.create(proto: object): object

    ```

+   如果必须，我们可以使用`Object.setPrototypeOf()`来更改现有对象的原型。但这可能会对该对象的表现产生负面影响。

这是这些功能的使用方式：

```js
// Two objects with null prototypes
const obj1 = {__proto__: null};
const obj2 = Object.create(null);

assert.equal(
  Object.getPrototypeOf(obj1), null
);

const proto = {};
Object.setPrototypeOf(obj1, proto);
assert.equal(
  Object.getPrototypeOf(obj1), proto
);

```

##### 30.8.3.2 检查一个对象是否在另一个对象的原型链中

到目前为止，“`proto` 是 `obj` 的原型”总是意味着“`proto` 是 `obj` 的 *直接* 原型”。但它也可以更宽松地使用，表示 `proto` 是 `obj` 的原型链中的一员。这种更宽松的关系可以通过 `.isPrototypeOf()` 来检查：

例如：

```js
const a = {};
const b = {__proto__: a};
const c = {__proto__: b};

assert.equal(a.isPrototypeOf(b), true);
assert.equal(a.isPrototypeOf(c), true);

assert.equal(c.isPrototypeOf(a), false);
assert.equal(a.isPrototypeOf(a), false);

```

更多关于此方法的信息，请参阅 “`Object.prototype.isPrototypeOf()` (ES3)” (§31.9.5)。

#### 30.8.4 `Object.hasOwn()`: 给定属性是自身的（非继承的）？^(ES2022)

`in` 操作符（行 A）检查对象是否具有给定的属性。相比之下，`Object.hasOwn()`（行 B 和 C）检查属性是否是自身的。

```js
const proto = {
  protoProp: 'protoProp',
};
const obj = {
  __proto__: proto,
  objProp: 'objProp',
}
assert.equal('protoProp' in obj, true); // (A)
assert.equal(Object.hasOwn(obj, 'protoProp'), false); // (B)
assert.equal(Object.hasOwn(proto, 'protoProp'), true); // (C)

```

![图标“提示”](img/8440b17bb8219cda9f9405ac83c36db0.png) **ES2022 之前的替代方案：`.hasOwnProperty()`**

在 ES2022 之前，我们可以使用另一个特性：“`Object.prototype.hasOwnProperty()` (ES3)” (§31.9.8)。这个特性有陷阱，但参考部分解释了如何绕过它们。

#### 30.8.5 通过原型共享数据

考虑以下代码：

```js
const jane = {
  firstName: 'Jane',
  describe() {
 return 'Person named '+this.firstName;
 },
};
const tarzan = {
 firstName: 'Tarzan',
 describe() {
 return 'Person named '+this.firstName;
 },
};

assert.equal(jane.describe(), 'Person named Jane');
assert.equal(tarzan.describe(), 'Person named Tarzan'); 
```

我们有两个非常相似的对象。它们都有两个属性，属性名为 `.firstName` 和 `.describe`。此外，方法 `.describe()` 是相同的。我们如何避免重复该方法？

我们可以将其移动到对象 `PersonProto` 中，并使该对象成为 `jane` 和 `tarzan` 的原型：

```js
const PersonProto = {
  describe() {
 return 'Person named ' + this.firstName;
 },
};
const jane = {
 __proto__: PersonProto,
 firstName: 'Jane',
};
const tarzan = {
 __proto__: PersonProto,
 firstName: 'Tarzan',
};

```

原型的名称反映了 `jane` 和 `tarzan` 都是人的事实。

![](img/54ca73b37654dc412734fbf20bbd28dd.png)

图 30.4：对象 `jane` 和 `tarzan` 通过它们的公共原型 `PersonProto` 共享方法 `.describe()`。

图 30.4 展示了三个对象是如何连接的：底部的对象现在包含 `jane` 和 `tarzan` 特有的属性。顶部的对象包含它们之间共享的属性。

当我们调用方法 `jane.describe()` 时，`this` 指向该方法调用的接收者，即 `jane`（在图的下左角）。这就是为什么该方法仍然有效。`tarzan.describe()` 的工作方式类似。

```js
assert.equal(jane.describe(), 'Person named Jane');
assert.equal(tarzan.describe(), 'Person named Tarzan');

```

预览下一章关于类的章节——这是类是如何在内部组织的：

+   所有实例都共享一个具有方法的公共原型。

+   实例特定的数据存储在每个实例的自身属性中。

“类的内部结构” (§31.3) 更详细地解释了这一点。

### 30.9 字典对象（高级）

对象作为固定布局对象工作得最好。但在 ES6 之前，JavaScript 没有字典数据结构（ES6 带来了 Maps）。因此，对象必须用作字典，这强加了一个显著的约束：字典键必须是字符串（ES6 也引入了符号）。

我们首先看看与字典相关但同时也适用于固定布局对象的对象特性。本节以实际使用对象作为字典的技巧结束。（剧透：如果可能的话，最好使用 Maps。）

#### 30.9.1 对象字面量中的引号键

到目前为止，我们一直使用固定布局对象。属性键是固定的标记，必须是有效的标识符并在内部成为字符串：

```js
const obj = {
  mustBeAnIdentifier: 123,
};

// Get property
assert.equal(obj.mustBeAnIdentifier, 123);

// Set property
obj.mustBeAnIdentifier = 'abc';
assert.equal(obj.mustBeAnIdentifier, 'abc');

```

作为下一步，我们将超越属性键的限制：在本子节中，我们将使用任意的固定字符串作为键。在下一下子节中，我们将动态计算键。

两种语法使我们能够使用任意字符串作为属性键。

首先，在通过对象字面量创建属性键时，我们可以引用属性键（使用单引号或双引号）：

```js
const obj = {
  'Can be any string!': 123,
};

```

其次，在获取或设置属性时，我们可以使用包含字符串的方括号：

```js
// Get property
assert.equal(obj['Can be any string!'], 123);

// Set property
obj['Can be any string!'] = 'abc';
assert.equal(obj['Can be any string!'], 'abc');

```

我们还可以使用这些语法来定义方法：

```js
const obj = {
  'A nice method'() {
    return 'Yes!';
  },
};

assert.equal(obj['A nice method'](), 'Yes!');

```

#### 30.9.2 对象字面量中的计算键

在前面的子节中，属性键是通过对象字面量中的固定字符串指定的。在本节中，我们将学习如何动态计算属性键。这使我们能够使用任意字符串或符号。

对象字面量中动态计算属性键的语法受到了动态访问属性的影响。也就是说，我们可以使用方括号来包裹表达式：

```js
const obj = {
  ['Hello world!']: true,
  ['p'+'r'+'o'+'p']: 123,
  [Symbol.toStringTag]: 'Goodbye', // (A)
};

assert.equal(obj['Hello world!'], true);
assert.equal(obj.prop, 123);
assert.equal(obj[Symbol.toStringTag], 'Goodbye');

```

计算键的主要用途是作为属性键的符号（行 A）。

注意，用于获取和设置属性的方括号运算符与任意表达式一起工作：

```js
assert.equal(obj['p'+'r'+'o'+'p'], 123);
assert.equal(obj['==> prop'.slice(4)], 123);

```

方法也可以有计算属性键：

```js
const methodKey = Symbol();
const obj = {
  [methodKey]() {
    return 'Yes!';
  },
};

assert.equal(obj[methodKey](), 'Yes!');

```

在本章的剩余部分，我们将主要再次使用固定属性键（因为它们在语法上更方便）。但所有功能也适用于任意字符串和符号。

![“练习”图标](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：通过扩展（计算键）非破坏性地更新属性**

`exercises/objects/update_property_test.mjs`

#### 30.9.3 `in`运算符：是否存在具有给定键的属性？

`in`运算符检查对象是否具有给定键的属性：

```js
const obj = {
  alpha: 'abc',
  beta: false,
};

assert.equal('alpha' in obj, true);
assert.equal('beta' in obj, true);
assert.equal('unknownKey' in obj, false);

```

##### 30.9.3.1 通过真值检查检查属性是否存在

我们还可以使用真值检查来确定属性是否存在：

```js
assert.equal(
  obj.alpha ? 'exists' : 'does not exist',
  'exists');
assert.equal(
  obj.unknownKey ? 'exists' : 'does not exist',
  'does not exist');

```

前面的检查之所以有效，是因为`obj.alpha`是真值，并且读取缺失的属性返回`undefined`（这是假值）。

然而，有一个重要的注意事项：如果属性存在但具有假值（`undefined`、`null`、`false`、`0`、`""`等），则真值检查会失败：

```js
assert.equal(
  obj.beta ? 'exists' : 'does not exist',
  'does not exist'); // should be: 'exists'

```

#### 30.9.4 删除属性

我们可以通过`delete`运算符删除属性：

```js
const obj = {
  myProp: 123,
};

assert.deepEqual(Object.keys(obj), ['myProp']);
delete obj.myProp;
assert.deepEqual(Object.keys(obj), []);

```

#### 30.9.5 可枚举性

*可枚举性* 是属性的一个*属性*。非可枚举属性在某些操作中被忽略——例如，在 `Object.keys()` 和属性展开时。默认情况下，大多数属性都是可枚举的。下一个示例将展示如何更改这一点以及它如何影响展开。

```js
const enumerableSymbolKey = Symbol('enumerableSymbolKey');
const nonEnumSymbolKey = Symbol('nonEnumSymbolKey');

// We create enumerable properties via an object literal
const obj = {
  enumerableStringKey: 1,
  [enumerableSymbolKey]: 2,
}

// For non-enumerable properties, we need a more powerful tool
Object.defineProperties(obj, {
  nonEnumStringKey: {
    value: 3,
    enumerable: false,
  },
  [nonEnumSymbolKey]: {
    value: 4,
    enumerable: false,
  },
});

// Non-enumerable properties are ignored by spreading:
assert.deepEqual(
  {...obj},
  {
    enumerableStringKey: 1,
    [enumerableSymbolKey]: 2,
  }
);

```

`Object.defineProperties()` 在本章的后面解释。下一小节将展示这些操作如何受可枚举性的影响：

#### 30.9.6 列出属性键通过 `Object.keys()` 等.

|  | 可枚举 | 不可枚举 | 字符串 | 符号 |
| --- | --- | --- | --- | --- |
| `Object.keys()` | ✔ |  | ✔ |  |
| `Object.getOwnPropertyNames()` | ✔ | ✔ | ✔ |  |
| `Object.getOwnPropertySymbols()` | ✔ | ✔ |  | ✔ |
| `Reflect.ownKeys()` | ✔ | ✔ | ✔ | ✔ |

表 30.1：列出*自有*（非继承）属性键的标准库方法。所有这些方法都返回包含字符串和/或符号的数组。

表 30.1 中的每个方法都返回一个包含参数自有属性键的数组。在方法名称中，我们可以看到以下区分：

+   *属性键* 可以是字符串或符号。（`Object.keys()` 较旧，尚未遵循此约定。）

+   *属性名* 是一个属性键，其值是一个字符串。

+   *属性符号* 是一个属性键，其值是一个符号。

为了演示四种运算，我们回顾前一小节中的示例：

```js
const enumerableSymbolKey = Symbol('enumerableSymbolKey');
const nonEnumSymbolKey = Symbol('nonEnumSymbolKey');

const obj = {
  enumerableStringKey: 1,
  [enumerableSymbolKey]: 2,
}
Object.defineProperties(obj, {
  nonEnumStringKey: {
    value: 3,
    enumerable: false,
  },
  [nonEnumSymbolKey]: {
    value: 4,
    enumerable: false,
  },
});

assert.deepEqual(
  Object.keys(obj),
  ['enumerableStringKey']
);
assert.deepEqual(
  Object.getOwnPropertyNames(obj),
  ['enumerableStringKey', 'nonEnumStringKey']
);
assert.deepEqual(
  Object.getOwnPropertySymbols(obj),
  [enumerableSymbolKey, nonEnumSymbolKey]
);
assert.deepEqual(
  Reflect.ownKeys(obj),
  [
    'enumerableStringKey', 'nonEnumStringKey',
    enumerableSymbolKey, nonEnumSymbolKey,
  ]
);

```

#### 30.9.7 列出属性值通过 `Object.values()`

`Object.values()` 列出对象所有自有可枚举字符串键属性的值：

```js
const firstName = Symbol('firstName');
const obj = {
  [firstName]: 'Jane',
  lastName: 'Doe',
};
assert.deepEqual(
  Object.values(obj),
  ['Doe']);

```

#### 30.9.8 列出属性条目通过 `Object.entries()` (ES2017)

`Object.entries(obj)` 返回一个数组，其中包含每个属性的键值对：

+   每对都编码为一个两元素数组。

+   只包括具有字符串键的自有可枚举属性。

```js
const firstName = Symbol('firstName');
const obj = {
  [firstName]: 'Jane',
  lastName: 'Doe',
};
Object.defineProperty(
  obj, 'city', {value: 'Metropolis', enumerable: false}
);
assert.deepEqual(
  Object.entries(obj),
  [
    ['lastName', 'Doe'],
  ]);

```

##### 30.9.8.1 `Object.entries()` 的简单实现

以下函数是 `Object.entries()` 的简化版本：

```js
function entries(obj) {
  return Object.keys(obj)
  .map(key => [key, obj[key]]);
}

```

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：`Object.entries()`**

`exercises/objects/find_key_test.mjs`

#### 30.9.9 属性按确定性列出

对象的自有（非继承）属性始终按以下顺序列出：

1.  包含整数索引的字符串键属性：

    按升序数值顺序

1.  剩余的字符串键属性：

    按照它们被添加的顺序

1.  具有符号键的属性：

    按照它们被添加的顺序

以下示例演示了属性键是按照这些规则排序的：

```js
const obj = {
  b: true,
  a: true,
  10: true,
  2: true,
};
assert.deepEqual(
  Object.keys(obj),
  ['2', '10', 'b', 'a']
);

```

![图标“详情”](img/38ba63de820aae6f94a019538ae0f222.png) **属性的顺序**

[ECMAScript 规范](https://tc39.es/ecma262/#sec-ordinaryownpropertykeys)更详细地描述了属性是如何排序的。

##### 30.9.9.1 属性顺序为什么是确定的？

作为一种数据结构，对象主要是无序的。因此，我们不会期望，例如，`Object.keys()` 总是按相同的顺序返回属性键。然而，JavaScript 确实为属性定义了一个确定性的顺序，因为这有助于测试和其他用例。

#### 30.9.10 通过 `Object.fromEntries()` 组装对象（ES2019）

给定一个 [键，值] 对的可迭代对象，`Object.fromEntries()` 创建一个对象：

```js
const symbolKey = Symbol('symbolKey');
assert.deepEqual(
  Object.fromEntries(
    [
      ['stringKey', 1],
      [symbolKey, 2],
    ]
  ),
  {
    stringKey: 1,
    [symbolKey]: 2,
  }
);

```

`Object.fromEntries()` 与 `Object.entries()` 的作用相反。然而，虽然 `Object.entries()` 忽略了以符号为键的属性，但 `Object.fromEntries()` 不忽略（参见前一个示例）。

为了演示这两个，我们将使用它们来实现下一个子子节中库 [Underscore](https://underscorejs.org) 的两个工具函数。

##### 30.9.10.1 示例：`pick()`

[Underscore 函数 `pick()`](https://underscorejs.org/#pick) 的签名如下：

```js
pick(object, ...keys)

```

它返回一个 `object` 的副本，其中只包含在尾随参数中提到的键的属性：

```js
const address = {
  street: 'Evergreen Terrace',
  number: '742',
  city: 'Springfield',
  state: 'NT',
  zip: '49007',
};
assert.deepEqual(
  pick(address, 'street', 'number'),
  {
    street: 'Evergreen Terrace',
    number: '742',
  }
);

```

我们可以这样实现 `pick()`：

```js
function pick(object, ...keys) {
  const filteredEntries = Object.entries(object)
    .filter(([key, _value]) => keys.includes(key));
  return Object.fromEntries(filteredEntries);
}

```

##### 30.9.10.2 示例：`invert()`

[Underscore 函数 `invert()`](https://underscorejs.org/#invert) 的签名如下：

```js
invert(object)

```

它返回一个 `object` 的副本，其中所有属性的键和值都被交换：

```js
assert.deepEqual(
  invert({a: 1, b: 2, c: 3}),
  {1: 'a', 2: 'b', 3: 'c'}
);

```

我们可以这样实现 `invert()`：

```js
function invert(object) {
  const reversedEntries = Object.entries(object)
    .map(([key, value]) => [value, key]);
  return Object.fromEntries(reversedEntries);
}

```

##### 30.9.10.3 `Object.fromEntries()` 的简单实现

以下函数是 `Object.fromEntries()` 的简化版本：

```js
function fromEntries(iterable) {
  const result = {};
  for (const [key, value] of iterable) {
    let coercedKey;
    if (typeof key === 'string' || typeof key === 'symbol') {
      coercedKey = key;
    } else {
      coercedKey = String(key);
    }
    result[coercedKey] = value;
  }
  return result;
}

```

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：使用 `Object.entries()` 和 `Object.fromEntries()`**

`exercises/objects/omit_properties_test.mjs`

#### 具有 `null` 原型的对象是好的字典和查找表

如果我们将普通对象（通过对象字面量创建）用作字典，我们必须注意两个陷阱。

##### 30.9.11.1 陷阱 1：获取继承属性

以下字典对象应该是空的。然而，如果我们读取继承属性，我们会得到一个值（而不是 `undefined`）：

```js
const dict = {};
assert.equal(
  typeof dict['toString'], 'function'
);

```

`dict` 是 `Object` 的一个实例，并从 `Object.prototype` 继承了 `.toString()`。

##### 30.9.11.2 陷阱 2：检查属性是否存在

如果我们使用 `in` 操作符来检查属性是否存在，我们再次检测到继承属性：

```js
const dict = {};
assert.equal(
  'toString' in dict, true
);

```

顺便说一句：`Object.hasOwn()` 没有这个陷阱。正如其名称所示，它只考虑 *自己的*（非继承的）属性：

```js
const dict = {};
assert.equal(
  Object.hasOwn(dict, 'toString'), false
);

```

##### 30.9.11.3 陷阱 3：属性键 `'__proto__'`

我们不能使用属性键 `'__proto__'`，因为它具有特殊功能（它设置对象的原型）：

```js
const dict = {};

dict['__proto__'] = 123;
// No property was added to dict:
assert.deepEqual(
  Object.keys(dict), []
);

```

##### 30.9.11.4 作为字典的对象具有 `null` 原型

当涉及到字典时，映射通常是最佳选择：它们有一个方便的方法式 API，并支持字符串和符号之外的键。

然而，具有 `null` 原型的对象也是相当好的字典，并且没有我们刚才遇到的陷阱：

```js
const dict = Object.create(null);

// No inherited properties
assert.equal(
  dict['toString'], undefined
);
assert.equal(
  'toString' in dict, false
);

// No special behavior with key '__proto__'
dict['__proto__'] = true;
assert.deepEqual(
  Object.keys(dict), ['__proto__']
);

```

我们避免了陷阱：

+   没有原型的对象不继承任何内容。因此，获取属性和使用 `in` 操作符总是安全的。

+   `Object.prototype.__proto__` 访问器被关闭，因为 `Object.prototype` 不是 `dict` 的原型链中的一部分。

![“练习”图标](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：对象作为字典**

+   以字典形式作为 `null` 原型对象：`exercises/objects/null-proto-obj-dict_test.mjs`

+   以字典形式作为普通对象：`exercises/objects/plain-obj-dict_test.mjs`

##### 30.9.11.5 作为固定查找表使用的 `null` 原型对象

`null` 原型对于用作固定查找表的对象也很有用：

```js
const htmlToLatex = {
  __proto__: null,
  'i': 'textit',
  'b': 'textbf',
  'u': 'underline',
};

```

##### 30.9.11.6 标准库中的 `null` 原型

因为它们是好的字典，标准库也在某些位置使用具有 `null` 原型的对象 – 例如：

+   `import.meta` 的值：

    ```js
    assert.equal(
      Object.getPrototypeOf(import.meta), null
    );

    ```

+   `Object.groupBy()` 的结果：

    ```js
    const grouped = Object.groupBy([], x => x);
    assert.equal(
      Object.getPrototypeOf(grouped), null
    );

    ```

+   当匹配正则表达式时 – `matchObj.groups` 的值：

    ```js
    const matchObj = /(?<group>x)/.exec('x');
    assert.equal(
      Object.getPrototypeOf(matchObj.groups), null
    );

    ```

### 30.10 属性属性和属性描述符 (ES5) (高级)

正如对象由属性组成一样，属性由 *属性* 组成。属性有两种类型，它们通过其属性来区分：

+   *数据属性*存储数据。其属性 `value` 保存任何 JavaScript 值。

    +   方法是数据属性，其值是函数。

+   *访问器属性*由一个获取器函数和/或一个设置器函数组成。前者存储在属性 `get` 中，后者存储在属性 `set` 中。

此外，还有一些属性两种类型的属性都有。以下表格列出了所有属性及其默认值。

| 属性类型 | 属性名称和类型 | 默认值 |
| --- | --- | --- |
| 所有属性 | `configurable: boolean` | `false` |
|  | `enumerable: boolean` | `false` |
| 数据属性 | `value: any` | `undefined` |
|  | `writable: boolean` | `false` |
| 访问器属性 | `get: (this: any) => any` | `undefined` |
|  | `set: (this: any, v: any) => void` | `undefined` |

我们已经遇到了属性 `value`、`get` 和 `set`。其他属性的工作方式如下：

+   `writable` 决定了数据属性值是否可以被更改。

+   `configurable` 决定了属性的属性是否可以被更改。如果它是 `false`，那么：

    +   我们不能删除该属性。

    +   我们不能将属性从数据属性更改为访问器属性，反之亦然。

    +   我们不能更改除 `value` 之外的任何属性。

    +   然而，还有一个属性更改是允许的：我们可以将 `writable` 从 `true` 更改为 `false`。这种异常背后的原因是[历史原因](https://stackoverflow.com/questions/9829817/why-can-i-set-enumerability-and-writability-of-unconfigurable-property-descrip/9843191#9843191)：数组的 `.length` 属性始终是可写的和非可配置的。允许其 `writable` 属性被更改使我们能够冻结数组。

+   `enumerable` 影响某些操作（例如 `Object.keys()`）。如果它是 `false`，则这些操作会忽略该属性。可枚举性在本章的早期部分有更详细的介绍。

当我们使用处理属性属性的操作之一时，属性通过 *属性描述符* 指定：每个属性代表一个属性的对象。例如，这就是我们读取属性 `obj.myProp` 的属性的方式：

```js
const obj = { myProp: 123 };
assert.deepEqual(
  Object.getOwnPropertyDescriptor(obj, 'myProp'),
  {
    value: 123,
    writable: true,
    enumerable: true,
    configurable: true,
  });

```

这就是改变 `obj.myProp` 属性的属性的方式：

```js
assert.deepEqual(Object.keys(obj), ['myProp']);

// Hide property `myProp` from Object.keys()
// by making it non-enumerable
Object.defineProperty(obj, 'myProp', {
  enumerable: false,
});

assert.deepEqual(Object.keys(obj), []);

```

最后，让我们看看方法和获取器是什么样子：

```js
const obj = {
  myMethod() {},
 get myGetter() {},
};
const propDescs = Object.getOwnPropertyDescriptors(obj);
propDescs.myMethod.value = typeof propDescs.myMethod.value;
propDescs.myGetter.get = typeof propDescs.myGetter.get;
assert.deepEqual(
 propDescs,
 {
 myMethod: {
 value: 'function',
 writable: true,
 enumerable: true,
 configurable: true
 },
 myGetter: {
 get: 'function',
 set: undefined,
 enumerable: true,
 configurable: true
 }
 }
);

```

![图标“外部”](img/38e6ff55e8d602659f3cdb8893e63f62.png) **进一步阅读**

关于属性属性和属性描述符的更多信息，请参阅[*深度 JavaScript*](https://exploringjs.com/deep-js/ch_property-attributes-intro.html)。

### 30.11 保护对象不被更改（ES5）(高级)

JavaScript 有三个级别的对象保护：

+   *防止扩展* 使无法向对象添加新属性和更改其原型成为可能。尽管如此，我们仍然可以删除和更改属性。

    +   应用：`Object.preventExtensions(obj)`

    +   检查：`Object.isExtensible(obj)`

+   *密封* 阻止扩展并使所有属性 *不可配置*（大致上：我们不能再更改属性的工作方式了）。

    +   应用：`Object.seal(obj)`

    +   检查：`Object.isSealed(obj)`

+   *冻结* 在使所有属性不可写后密封对象。也就是说，对象不可扩展，所有属性都是只读的，并且无法更改。

    +   应用：`Object.freeze(obj)`

    +   检查：`Object.isFrozen(obj)`

![图标“警告”](img/5aa4bf88dc66ecb2bac6be4022a1fed4.png) **注意事项：对象仅进行浅层保护**

所述的三个 `Object.*` 方法仅影响对象的顶层，不影响其内部嵌套的对象。

这就是使用 `Object.freeze()` 的样子：

```js
const frozen = Object.freeze({ x: 2, y: 5 });
assert.throws(
  () => frozen.x = 7,
  {
    name: 'TypeError',
    message: /^Cannot assign to read only property 'x'/,
  }
);

```

在严格模式下更改冻结属性只会导致异常。宽松模式中，它将静默失败。

![图标“外部”](img/38e6ff55e8d602659f3cdb8893e63f62.png) **进一步阅读**

关于冻结和其他锁定对象的方法的更多信息，请参阅[*深度 JavaScript*](https://exploringjs.com/deep-js/ch_protecting-objects.html)。

### 30.12 快速参考：`Object`

#### 30.12.1 `Object.*`: 创建对象，处理原型

+   `Object.create(proto, propDescObj?)` ES5

    +   返回一个新的对象，其原型是 `proto`。

    +   可选的`propDescObj`是一个包含属性描述符的对象，用于在新的对象中定义属性。

    ```js
    > const obj = Object.create(null);
    > Object.getPrototypeOf(obj)
    null

    ```

    在以下示例中，我们通过第二个参数定义自身属性：

    ```js
    const obj = Object.create(
      null,
      {
        color: {
          value: 'green',
          writable: true,
          enumerable: true,
          configurable: true,
        },
      }
    );
    assert.deepEqual(
      obj,
      {
        __proto__: null,
        color: 'green',
      }
    );

    ```

+   `Object.getPrototypeOf(obj)` ES5

    返回`obj`的原型——它可以是对象或`null`。

    ```js
    assert.equal(
      Object.getPrototypeOf({__proto__: null}), null
    );
    assert.equal(
      Object.getPrototypeOf({}), Object.prototype
    );
    assert.equal(
      Object.getPrototypeOf(Object.prototype), null
    );

    ```

+   `Object.setPrototypeOf(obj, proto)` ES6

    将`obj`的原型设置为`proto`（必须是`null`或对象）并返回前者。

    ```js
    const obj = {};
    assert.equal(
      Object.getPrototypeOf(obj), Object.prototype
    );
    Object.setPrototypeOf(obj, null);
    assert.equal(
      Object.getPrototypeOf(obj), null
    );

    ```

#### 30.12.2 `Object.*`: 属性属性

+   `Object.defineProperty(obj, propKey, propDesc)` ES5

    +   定义`obj`中的一个属性，由属性键`propKey`和属性描述符 `propDesc`指定。

    +   返回`obj`。

    ```js
    const obj = {};
    Object.defineProperty(
      obj, 'color',
      {
        value: 'green',
        writable: true,
        enumerable: true,
        configurable: true,
      }
    );
    assert.deepEqual(
      obj,
      {
        color: 'green',
      }
    );

    ```

+   `Object.defineProperties(obj, propDescObj)` ES5

    +   定义`obj`中的属性，由包含属性描述符的对象`propDescObj`指定。

    +   返回`obj`。

    ```js
    const obj = {};
    Object.defineProperties(
      obj,
      {
        color: {
          value: 'green',
          writable: true,
          enumerable: true,
          configurable: true,
        },
      }
    );
    assert.deepEqual(
      obj,
      {
        color: 'green',
      }
    );

    ```

+   `Object.getOwnPropertyDescriptor(obj, propKey)` ES5

    +   返回`obj`的自身属性的一个属性描述符，其键是`propKey`。如果不存在这样的属性，则返回`undefined`。

    +   更多关于属性描述符的信息：“属性属性和属性描述符^(ES5) (高级)” (§30.10)

    ```js
    > Object.getOwnPropertyDescriptor({a: 1, b: 2}, 'a')
    { value: 1, writable: true, enumerable: true, configurable: true }
    > Object.getOwnPropertyDescriptor({a: 1, b: 2}, 'x')
    undefined

    ```

+   `Object.getOwnPropertyDescriptors(obj)` ES2017

    +   返回一个包含属性描述符的对象，每个`obj`的自身属性都有一个。

    +   更多关于属性描述符的信息：“属性属性和属性描述符^(ES5) (高级)” (§30.10)

    ```js
    > Object.getOwnPropertyDescriptors({a: 1, b: 2})
    {
      a: { value: 1, writable: true, enumerable: true, configurable: true },
      b: { value: 2, writable: true, enumerable: true, configurable: true },
    }

    ```

#### 30.12.3 `Object.*`: 属性键、值、条目

+   `Object.keys(obj)` ES5

    返回一个包含所有自身可枚举属性键（字符串键）的数组。

    ```js
    const enumSymbolKey = Symbol('enumSymbolKey');
    const nonEnumSymbolKey = Symbol('nonEnumSymbolKey');

    const obj = Object.defineProperties(
      {},
      {
        enumStringKey: {
          value: 1, enumerable: true,
        },
        [enumSymbolKey]: {
          value: 2, enumerable: true,
        },
        nonEnumStringKey: {
          value: 3, enumerable: false,
        },
        [nonEnumSymbolKey]: {
          value: 4, enumerable: false,
        },
      }
    );
    assert.deepEqual(
      Object.keys(obj),
      ['enumStringKey']
    );

    ```

+   `Object.getOwnPropertyNames(obj)` ES5

    返回一个包含所有自身属性键（可枚举和不可枚举的字符串键）的数组。

    ```js
    const enumSymbolKey = Symbol('enumSymbolKey');
    const nonEnumSymbolKey = Symbol('nonEnumSymbolKey');

    const obj = Object.defineProperties(
      {},
      {
        enumStringKey: {
          value: 1, enumerable: true,
        },
        [enumSymbolKey]: {
          value: 2, enumerable: true,
        },
        nonEnumStringKey: {
          value: 3, enumerable: false,
        },
        [nonEnumSymbolKey]: {
          value: 4, enumerable: false,
        },
      }
    );
    assert.deepEqual(
      Object.getOwnPropertyNames(obj),
      ['enumStringKey', 'nonEnumStringKey']
    );

    ```

+   `Object.getOwnPropertySymbols(obj)` ES6

    返回一个包含所有自身属性键（可枚举和不可枚举的符号键）的数组。

    ```js
    const enumSymbolKey = Symbol('enumSymbolKey');
    const nonEnumSymbolKey = Symbol('nonEnumSymbolKey');

    const obj = Object.defineProperties(
      {},
      {
        enumStringKey: {
          value: 1, enumerable: true,
        },
        [enumSymbolKey]: {
          value: 2, enumerable: true,
        },
        nonEnumStringKey: {
          value: 3, enumerable: false,
        },
        [nonEnumSymbolKey]: {
          value: 4, enumerable: false,
        },
      }
    );
    assert.deepEqual(
      Object.getOwnPropertySymbols(obj),
      [enumSymbolKey, nonEnumSymbolKey]
    );

    ```

+   `Object.values(obj)` ES2017

    返回一个包含所有可枚举的自身字符串键属性的值的数组。

    ```js
    > Object.values({a: 1, b: 2})
    [ 1, 2 ]

    ```

+   `Object.entries(obj)` ES2017

    +   返回一个包含每个`obj`属性的一个键值对（编码为一个包含两个元素的数组）的数组。

    +   仅包含具有字符串键的自身可枚举属性。

    +   逆操作：`Object.fromEntries()`

    ```js
    const obj = {
      a: 1,
      b: 2,
      [Symbol('myKey')]: 3,
    };
    assert.deepEqual(
      Object.entries(obj),
      [
        ['a', 1],
        ['b', 2],
        // Property with symbol key is ignored
      ]
    );

    ```

+   `Object.fromEntries(keyValueIterable)` ES2019

    +   创建一个对象，其自身属性由`keyValueIterable`指定。

    +   逆操作：`Object.entries()`

    ```js
    > Object.fromEntries([['a', 1], ['b', 2]])
    { a: 1, b: 2 }

    ```

+   `Object.hasOwn(obj, key)` ES2022

    +   如果`obj`有一个具有键`key`的自身属性，则返回`true`。如果没有，则返回`false`。

    ```js
    > Object.hasOwn({a: 1, b: 2}, 'a')
    true
    > Object.hasOwn({a: 1, b: 2}, 'x')
    false

    ```

#### 30.12.4 `Object.*`: 保护对象

更多信息：“保护对象不被更改^(ES5) (高级)” (§30.11)

+   `Object.preventExtensions(obj)` ES5

    +   使 `obj` 不可扩展并返回它。

    +   影响：

        +   `obj` 不可扩展：我们无法添加属性或更改其原型。

    +   只改变 `obj` 的顶层（浅改变）。嵌套对象不受影响。

    +   相关：`Object.isExtensible()`

+   `Object.isExtensible(obj)` ES5

    +   如果 `obj` 可扩展则返回 `true`，否则返回 `false`。

    +   相关：`Object.preventExtensions()`

+   `Object.seal(obj)` ES5

    +   密封 `obj` 并返回它。

    +   影响：

        +   `obj` 不可扩展：我们无法添加属性或更改其原型。

        +   如果 `obj` 被密封：此外，它的所有属性都是不可配置的。

    +   只改变 `obj` 的顶层（浅改变）。嵌套对象不受影响。

    +   相关：`Object.isSealed()`

+   `Object.isSealed(obj)` ES5

    +   如果 `obj` 被密封则返回 `true`，否则返回 `false`。

    +   相关：`Object.seal()`

+   `Object.freeze(obj)` ES5

    +   冻结 `obj` 并返回它。

    +   影响：

        +   `obj` 不可扩展：我们无法添加属性或更改其原型。

        +   `obj` 被密封：此外，它的所有属性都是不可配置的。

        +   `obj` 被冻结：此外，它的所有属性都是不可写的。

    +   只改变 `obj` 的顶层（浅改变）。嵌套对象不受影响。

    +   相关：`Object.isFrozen()`

    ```js
    const frozen = Object.freeze({ x: 2, y: 5 });
    assert.equal(
      Object.isFrozen(frozen), true
    );
    assert.throws(
      () => frozen.x = 7,
      {
        name: 'TypeError',
        message: /^Cannot assign to read only property 'x'/,
      }
    );

    ```

+   `Object.isFrozen(obj)` ES5

    +   如果 `obj` 被冻结则返回 `true`。

    +   相关：`Object.freeze()`

#### 30.12.5 `Object.*`：杂项

+   `Object.assign(target, ...sources)` ES6

    将每个 `sources` 的所有可枚举的自身字符串键属性分配给 `target` 并返回 `target`。

    ```js
    > const obj = {a: 1, b: 1};
    > Object.assign(obj, {b: 2, c: 2}, {d: 3})
    { a: 1, b: 2, c: 2, d: 3 }
    > obj
    { a: 1, b: 2, c: 2, d: 3 }

    ```

+   `Object.groupBy(items, computeGroupKey)` ES2024

    ```js
    Object.groupBy<K extends PropertyKey, T>(
      items: Iterable<T>,
      computeGroupKey: (item: T, index: number) => K,
    ): {[key: K]: Array<T>}

    ```

    +   回调 `computeGroupKey` 为每个 `items` 返回一个 *组键*。

    +   `Object.groupBy()` 的结果是这样一个对象：

        +   每个属性的键是一个组键，并且

        +   其值是一个包含所有具有该组键的项的数组。

    ```js
    assert.deepEqual(
      Object.groupBy(
        ['orange', 'apricot', 'banana', 'apple', 'blueberry'],
        (str) => str[0] // compute group key
      ),
      {
        __proto__: null,
        'o': ['orange'],
        'a': ['apricot', 'apple'],
        'b': ['banana', 'blueberry'],
      }
    );

    ```

+   `Object.is(value1, value2)` ES6

    主要等同于 `value1 === value2` ——但有两个例外：

    ```js
    > NaN === NaN
    false
    > Object.is(NaN, NaN)
    true

    > -0 === 0
    true
    > Object.is(-0, 0)
    false

    ```

    +   将所有 `NaN` 值视为相等可能很有用——例如，在搜索数组中的值时。

    +   值 `-0` 很少见，通常最好假装它与 `0` 相同。

#### 30.12.6 `Object.prototype.*`

`Object.prototype` 有以下属性：

+   `Object.prototype.__proto__`（获取器和设置器）

+   `Object.prototype.hasOwnProperty()`

+   `Object.prototype.isPrototypeOf()`

+   `Object.prototype.propertyIsEnumerable()`

+   `Object.prototype.toLocaleString()`

+   `Object.prototype.toString()`

+   `Object.prototype.valueOf()`

这些方法在“快速参考：`Object.prototype.*`”（§31.10）中有详细解释。

### 30.13 快速参考：`Reflect`

`Reflect` 提供了用于 [JavaScript 代理](https://exploringjs.com/deep-js/ch_proxies.html) 的功能，这些功能偶尔在其他地方也很有用：

+   `Reflect.apply(target, thisArgument, argumentsList)` ES6

    +   使用`argumentsList`提供的参数调用`target`，并将`this`设置为`thisArgument`。

    +   等同于`target.apply(thisArgument, argumentsList)`。

+   `Reflect.construct(target, argumentsList, newTarget=target)` ES6

    +   作为函数的`new`运算符。

    +   `target`是要调用的构造函数。

    +   可选参数`newTarget`指向启动当前构造函数调用链的构造函数。

+   `Reflect.defineProperty(target, propertyKey, propDesc)` ES6

    +   类似于`Object.defineProperty()`。

    +   返回一个布尔值，指示操作是否成功。

+   `Reflect.deleteProperty(target, propertyKey)` ES6

    作为函数的`delete`运算符。尽管它的工作方式略有不同：

    +   如果成功删除了属性或属性原本不存在，则返回`true`。

    +   如果属性无法删除且仍然存在，则返回`false`。

    在宽松模式下，`delete`运算符返回与该方法相同的结果。但在严格模式下，它抛出`TypeError`而不是返回`false`。

    保护属性不被删除的唯一方法是将它们设置为不可配置。

+   `Reflect.get(target, propertyKey, receiver=target)` ES6

    获取属性的功能。如果`get`在原型链中的某个地方遇到 getter，则需要可选参数`receiver`。然后它提供`this`的值。

+   `Reflect.getOwnPropertyDescriptor(target, propertyKey)` ES6

    与`Object.getOwnPropertyDescriptor()`相同。

+   `Reflect.getPrototypeOf(target)` ES6

    与`Object.getPrototypeOf()`相同。

+   `Reflect.has(target, propertyKey)` ES6

    作为函数的`in`运算符。

+   `Reflect.isExtensible(target)` ES6

    与`Object.isExtensible()`相同。

+   `Reflect.ownKeys(target)` ES6

    以数组形式返回所有自有属性键（字符串和符号）。

+   `Reflect.preventExtensions(target)` ES6

    +   类似于`Object.preventExtensions()`。

    +   返回一个布尔值，指示操作是否成功。

+   `Reflect.set(target, propertyKey, value, receiver=target)` ES6

    +   设置属性。

    +   返回一个布尔值，指示操作是否成功。

+   `Reflect.setPrototypeOf(target, proto)` ES6

    +   与`Object.setPrototypeOf()`相同。

    +   返回一个布尔值，指示操作是否成功。

#### 30.13.1 `Reflect.*` 与 `Object.*`

一般建议：

+   在可能的情况下，使用`Object.*`。

+   在使用[ECMAScript 代理](https://exploringjs.com/deep-js/ch_proxies.html)时使用`Reflect.*`。其方法很好地适应了 ECMAScript 的元对象协议（MOP），该方法也返回布尔错误标志而不是抛出异常。

`Reflect`除了代理之外还有什么用例？

+   `Reflect.ownKeys()`列出所有自有属性键——这是其他地方没有提供的功能。

+   与`Object`具有相同的功能，但返回值不同：`Reflect`复制了`Object`的以下方法，但其方法返回布尔值，指示操作是否成功（而`Object`方法返回被修改的对象）。

    +   `Object.defineProperty(obj, propKey, propDesc)`

    +   `Object.preventExtensions(obj)`

    +   `Object.setPrototypeOf(obj, proto)`

+   作为函数的运算符：以下`Reflect`方法实现了其他情况下仅通过运算符可用的功能：

    +   `Reflect.construct(target, argumentsList, newTarget=target)`

    +   `Reflect.deleteProperty(target, propertyKey)`

    +   `Reflect.get(target, propertyKey, receiver=target)`

    +   `Reflect.has(target, propertyKey)`

    +   `Reflect.set(target, propertyKey, value, receiver=target)`

+   `apply()`函数的简短版本：如果我们想完全安全地在一个函数上调用`apply()`方法，我们不能通过动态分派来这样做，因为该函数可能有一个键为`'apply'`的自有属性：

    ```js
    func.apply(thisArg, argArray) // not safe
    Function.prototype.apply.call(func, thisArg, argArray) // safe

    ```

    使用`Reflect.apply()`更简洁：

    ```js
    Reflect.apply(func, thisArg, argArray)

    ```

+   删除属性时无例外：在严格模式下，如果我们尝试删除一个不可配置的自有属性，`delete`运算符会抛出异常。`Reflect.deleteProperty()`在这种情况下返回`false`。
