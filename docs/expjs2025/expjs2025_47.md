# 40 ES6 解构

> 原文：[`exploringjs.com/js/book/ch_destructuring.html`](https://exploringjs.com/js/book/ch_destructuring.html)

1.  40.1 解构的第一印象

1.  40.2 构造与提取

1.  40.3 在哪里可以进行解构？

1.  40.4 对象解构

    1.  40.4.1 属性值简写

    1.  40.4.2 剩余属性

    1.  40.4.3 语法陷阱：通过对象解构进行赋值

1.  40.5 数组解构

    1.  40.5.1 数组解构与任何可迭代对象一起工作

    1.  40.5.2 剩余元素

1.  40.6 解构的示例

    1.  40.6.1 数组解构：交换变量值

    1.  40.6.2 数组解构：返回数组的操作

    1.  40.6.3 对象解构：多个返回值

1.  40.7 如果模式部分没有匹配到任何内容会发生什么？

    1.  40.7.1 对象解构和缺失的属性

    1.  40.7.2 数组解构和缺失的元素

1.  40.8 哪些值不能解构？

    1.  40.8.1 我们无法对 `undefined` 和 `null` 进行对象解构

    1.  40.8.2 我们无法对非可迭代值进行数组解构

1.  40.9 (高级)

1.  40.10 默认值

    1.  40.10.1 数组解构中的默认值

    1.  40.10.2 对象解构中的默认值

1.  40.11 参数定义与解构类似

1.  40.12 嵌套解构

### 40.1 解构的第一印象

使用常规赋值，我们一次提取一个数据片段——例如：

```js
const arr = ['a', 'b', 'c'];
const x = arr[0]; // extract
const y = arr[1]; // extract

```

使用解构，我们可以通过接收数据的位置上的模式同时提取多个数据片段。上一段代码中 `=` 的左侧是一个这样的位置。在以下代码中，行 A 中的方括号是一个解构模式：

```js
const arr = ['a', 'b', 'c'];
const [x, y] = arr; // (A)
assert.equal(x, 'a');
assert.equal(y, 'b');

```

这段代码与上一段代码执行相同的操作。

注意模式“小于”数据：我们只提取所需的内容。

### 40.2 构造与提取

为了理解解构是什么，考虑 JavaScript 有两种相反的操作：

+   我们可以通过设置属性和对象字面量来*构造*复合数据。

+   我们可以从复合数据中提取数据，例如，通过获取属性。

数据构造看起来如下：

```js
// Constructing: one property at a time
const jane1 = {};
jane1.first = 'Jane';
jane1.last = 'Doe';

// Constructing: multiple properties
const jane2 = {
  first: 'Jane',
  last: 'Doe',
};

assert.deepEqual(jane1, jane2);

```

数据提取看起来如下：

```js
const jane = {
  first: 'Jane',
  last: 'Doe',
};

// Extracting: one property at a time
const f1 = jane.first;
const l1 = jane.last;
assert.equal(f1, 'Jane');
assert.equal(l1, 'Doe');

// Extracting: multiple properties (NEW!)
const {first: f2, last: l2} = jane; // (A)
assert.equal(f2, 'Jane');
assert.equal(l2, 'Doe');

```

行 A 的操作是新的：我们声明了两个变量`f2`和`l2`，并通过*解构*（多值提取）来初始化它们。

行 A 的以下部分是一个*解构模式*：

```js
{first: f2, last: l2}

```

解构模式在语法上与用于多值构造的字面量相似。但它们出现在数据接收的地方（例如，在赋值的左侧），而不是数据创建的地方（例如，在赋值的右侧）。

### 40.3 在哪里可以进行解构？

解构模式可以在“数据接收位置”使用，例如：

+   变量声明：

    ```js
    const [a] = ['x'];
    assert.equal(a, 'x');

    let [b] = ['y'];
    assert.equal(b, 'y');

    ```

+   赋值：

    ```js
    let b;
    [b] = ['z'];
    assert.equal(b, 'z');

    ```

+   参数定义：

    ```js
    const f = ([x]) => x;
    assert.equal(f(['a']), 'a');

    ```

注意，变量声明包括`const`和`let`声明在`for-of`循环中：

```js
const arr = ['a', 'b'];
for (const [index, element] of arr.entries()) {
    console.log(index, element);
}

```

输出：

```js
0 a
1 b

```

在接下来的两个部分中，我们将更深入地探讨两种解构类型：对象解构和数组解构。

### 40.4 对象解构

*对象解构* 允许我们通过类似于对象字面量的模式批量提取属性值：

```js
const address = {
  street: 'Evergreen Terrace',
  number: '742',
  city: 'Springfield',
  state: 'NT',
  zip: '49007',
};

const { street: s, city: c } = address;
assert.equal(s, 'Evergreen Terrace');
assert.equal(c, 'Springfield');

```

我们可以将模式视为放置在数据上的一张透明纸：模式键`'street'`在数据中有匹配项。因此，数据值`'Evergreen Terrace'`被分配给模式变量`s`。

我们还可以对原始值进行对象解构：

```js
const {length: len} = 'abc';
assert.equal(len, 3);

```

我们还可以对数组进行对象解构：

```js
const {0:x, 2:y} = ['a', 'b', 'c'];
assert.equal(x, 'a');
assert.equal(y, 'c');

```

为什么这样工作？数组索引也是属性。

#### 40.4.1 属性值缩写

对象字面量支持属性值缩写，对象模式也是如此：

```js
const { street, city } = address;
assert.equal(street, 'Evergreen Terrace');
assert.equal(city, 'Springfield');

```

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：对象解构**

`exercises/destructuring/object_destructuring_exrc.mjs`

#### 40.4.2 剩余属性

在对象字面量中，我们可以有扩展属性。在对象模式中，我们可以有剩余属性（必须放在最后）：

```js
const obj = { a: 1, b: 2, c: 3 };
const { a: propValue, ...remaining } = obj; // (A)

assert.equal(propValue, 1);
assert.deepEqual(remaining, {b:2, c:3});

```

一个剩余属性变量，如`remaining`（行 A），被分配了一个包含所有数据属性的对象，其键在模式中未提及。

`remaining`也可以被视为从`obj`中非破坏性地移除属性`a`的结果。

#### 40.4.3 通过对象解构进行赋值：语法陷阱

如果我们在赋值时进行对象解构，我们将面临由语法歧义引起的陷阱——我们不能以大括号开始一个语句，因为这样 JavaScript 会认为我们正在开始一个块：

```js
let prop;
assert.throws(
  () => eval("{prop} = { prop: 'hello' };"),
  {
    name: 'SyntaxError',
    message: "Unexpected token '='",
  });

```

![图标“详情”](img/38ba63de820aae6f94a019538ae0f222.png) **为什么使用`eval()`？**

`eval()` 延迟解析（因此`SyntaxError`），直到`assert.throws()`的回调执行。如果我们不使用它，当这段代码被解析时，我们就会得到错误，而`assert.throws()`甚至不会被执行。

解决方案是将整个赋值放在括号中：

```js
let prop;
({prop} = { prop: 'hello' });
assert.equal(prop, 'hello');

```

### 40.5 数组解构

*数组解构*允许我们通过类似于数组字面量的模式批量提取数组元素的值：

```js
const [x, y] = ['a', 'b'];
assert.equal(x, 'a');
assert.equal(y, 'b');

```

我们可以通过在数组模式中放置空位来跳过元素：

```js
const [, x, y] = ['a', 'b', 'c']; // (A)
assert.equal(x, 'b');
assert.equal(y, 'c');

```

行 A 中的数组模式以一个空位开始，这就是为什么索引 0 的数组元素被忽略。

#### 40.5.1 数组解构与任何可迭代对象一起工作

数组解构可以应用于任何可迭代的值，而不仅仅是数组：

```js
{ // Sets are iterable
  const [a, b] = new Set().add('fee').add('fi').add('fo');
  assert.equal(a, 'fee');
  assert.equal(b, 'fi');
}

{ // Maps are iterable
  const [a, b] = new Map().set('one', 1).set('two', 2);
  assert.deepEqual(
    a, ['one',1]
  );
  assert.deepEqual(
    b, ['two',2]
  );
}

{ // Strings are iterable
  const [a, b] = 'hello';
  assert.equal(a, 'h');
  assert.equal(b, 'e');
}

```

#### 40.5.2 剩余元素

在数组字面量中，我们可以有扩展元素。在数组模式中，我们可以有剩余元素（必须放在最后）：

```js
const [x, y, ...remaining] = ['a', 'b', 'c', 'd']; // (A)

assert.equal(x, 'a');
assert.equal(y, 'b');
assert.deepEqual(remaining, ['c', 'd']);

```

剩余元素变量，如 `remaining`（行 A），被分配一个数组，其中包含尚未提到的解构值的所有元素。

### 40.6 解构示例

#### 40.6.1 数组解构：交换变量值

我们可以使用数组解构来交换两个变量的值，而无需使用临时变量：

```js
let x = 'a';
let y = 'b';

[x,y] = [y,x]; // swap

assert.equal(x, 'b');
assert.equal(y, 'a');

```

#### 40.6.2 数组解构：返回数组的操作

当操作返回数组时，数组解构很有用，例如正则表达式的 `.exec()` 方法：

```js
// Skip the element at index 0 (the whole match):
const [, year, month, day] =
  /^([0-9]{4})-([0-9]{2})-([0-9]{2})$/
  .exec('2999-12-31');

assert.equal(year, '2999');
assert.equal(month, '12');
assert.equal(day, '31');

```

#### 40.6.3 对象解构：多个返回值

如果一个函数返回多个值——无论是作为数组还是作为对象包装，解构都非常有用。

考虑一个 `findElement()` 函数，该函数在数组中查找元素：

```js
findElement(array, (value, index) => «boolean expression»)

```

其第二个参数是一个函数，该函数接收元素的值和索引，并返回一个布尔值，指示这是否是调用者正在寻找的元素。

我们现在面临一个困境：`findElement()` 应该返回它找到的元素的值还是索引？一个解决方案是创建两个单独的函数，但这会导致代码重复，因为这两个函数非常相似。

以下实现通过返回一个包含找到的元素的索引和值的对象来避免重复：

```js
function findElement(arr, predicate) {
  for (let index=0; index < arr.length; index++) {
    const value = arr[index];
    if (predicate(value)) {
      // We found something:
      return { value, index };
    }
  }
  // We didn’t find anything:
  return { value: undefined, index: -1 };
}

```

解构帮助我们处理 `findElement()` 的结果：

```js
const arr = [7, 8, 6];

const {value, index} = findElement(arr, x => x % 2 === 0);
assert.equal(value, 8);
assert.equal(index, 1);

```

由于我们正在处理属性键，所以 `value` 和 `index` 的提及顺序并不重要：

```js
const {index, value} = findElement(arr, x => x % 2 === 0);

```

关键是，如果我们只对两个结果中的一个感兴趣，解构也能很好地为我们服务：

```js
const arr = [7, 8, 6];

const {value} = findElement(arr, x => x % 2 === 0);
assert.equal(value, 8);

const {index} = findElement(arr, x => x % 2 === 0);
assert.equal(index, 1);

```

所有这些便利性结合起来，使得处理多个返回值的方式非常灵活。

### 40.7 如果模式部分不匹配会发生什么？

如果模式的一部分没有匹配，会发生什么？这与我们使用非批量操作时发生的情况相同：我们得到 `undefined`。

#### 40.7.1 对象解构和缺失属性

如果对象模式右侧没有匹配的属性，我们得到 `undefined`：

```js
const {prop: p} = {};
assert.equal(p, undefined);

```

#### 40.7.2 数组解构和缺失元素

如果数组模式右侧没有匹配的元素，我们得到 `undefined`：

```js
const [x] = [];
assert.equal(x, undefined);

```

### 40.8 哪些值不能解构？

#### 40.8.1 我们不能解构 `undefined` 和 `null`

对象解构只有在要解构的值是 `undefined` 或 `null` 时才会失败。也就是说，当通过点操作符访问属性会失败时，它也会失败。

```js
> const {prop} = undefined
TypeError: Cannot destructure property 'prop' of 'undefined'
as it is undefined.

> const {prop} = null
TypeError: Cannot destructure property 'prop' of 'null'
as it is null.

```

因此，使用空对象模式解构值意味着“如果值是 `undefined` 或 `null`，则抛出异常”：

```js
function throwIfUndefinedOrNull(value) {
  const {} = value;
}
assert.throws(
  () => throwIfUndefinedOrNull(undefined),
  TypeError
);
throwIfUndefinedOrNull(123); // OK

```

#### 40.8.2 我们不能解构非可迭代值

数组解构要求解构的值是可迭代的。因此，我们不能解构 `undefined` 和 `null`。但我们也不能解构非可迭代的基本类型和对象：

```js
> const [x] = 123
TypeError: 123 is not iterable
> const [y] = {}
TypeError: {} is not iterable

```

因此，使用空数组模式解构值意味着“如果值不可迭代，则抛出异常”：

```js
function throwIfNotIterable(value) {
  const [] = value;
}
assert.throws(
  () => throwIfNotIterable(null),
  TypeError
);
assert.throws(
  () => throwIfNotIterable(true),
  TypeError
);
throwIfNotIterable('abc'); // OK: iterable primitive
throwIfNotIterable([]); // OK: iterable object

```

### 40.9 (高级)

所有剩余的部分都是高级的。

### 40.10 默认值

通常，如果模式没有匹配，相应的变量将被设置为 `undefined`：

```js
const {prop: p} = {};
assert.equal(p, undefined);

```

如果我们想使用不同的值，我们需要指定一个 *默认值*（通过 `=`）：

```js
const {prop: p = 123} = {}; // (A)
assert.equal(p, 123);

```

在行 A 中，我们指定 `p` 的默认值为 `123`。这个默认值被使用，因为我们正在解构的数据没有名为 `prop` 的属性。

#### 40.10.1 数组解构中的默认值

这里，我们有两个默认值被分配给变量 `x` 和 `y`，因为相应的元素不存在于解构的数组中。

```js
const [x=1, y=2] = [];

assert.equal(x, 1);
assert.equal(y, 2);

```

数组模式中第一个元素的默认值是 `1`；第二个元素的默认值是 `2`。

#### 40.10.2 对象解构中的默认值

我们也可以为对象解构指定默认值：

```js
const {first: f='', last: l=''} = {};
assert.equal(f, '');
assert.equal(l, '');

```

在解构的对象中，既不存在属性键 `first` 也不存在属性键 `last`。因此，使用了默认值。

使用属性值简写，这段代码变得更简单：

```js
const {first='', last=''} = {};
assert.equal(first, '');
assert.equal(last, '');

```

### 40.11 参数定义与解构类似

考虑到我们在本章中学到的内容，参数定义与数组模式有很多共同之处（剩余元素、默认值等）。事实上，以下两个函数声明是等价的：

```js
function f1(«pattern1», «pattern2») {
  // ···
}

function f2(...args) {
  const [«pattern1», «pattern2»] = args;
  // ···
}

```

### 40.12 嵌套解构

到目前为止，我们只在使用解构模式内部作为 *赋值目标*（数据汇）时使用了变量。但我们可以也将模式用作赋值目标，这使得我们可以将模式嵌套到任意深度：

```js
const arr = [
  { first: 'Jane', last: 'Bond' },
  { first: 'Lars', last: 'Croft' },
];
const [, {first}] = arr; // (A)
assert.equal(first, 'Lars');

```

在行 A 的 Array 模式内部，存在一个索引为 1 的嵌套对象模式。

嵌套模式可能会变得难以理解，因此最好适度使用。
