# 35 类型化数组：处理二进制数据 ES6 (高级)

> 原文：[`exploringjs.com/js/book/ch_typed-arrays.html`](https://exploringjs.com/js/book/ch_typed-arrays.html)

1.  35.1 类型化数组 API：二进制数据的容器

    1.  35.1.1 类型化数组的用例

    1.  35.1.2 核心类：`ArrayBuffer`、类型化数组、`DataView`

    1.  35.1.3 `SharedArrayBuffer` (ES2017)

1.  35.2 使用类型化数组

    1.  35.2.1 创建类型化数组

    1.  35.2.2 包装的 ArrayBuffer

    1.  35.2.3 获取和设置元素

    1.  35.2.4 连接类型化数组

    1.  35.2.5 类型化数组与普通数组

1.  35.3 使用 DataView

1.  35.4 元素类型

    1.  35.4.1 处理溢出和下溢

    1.  35.4.2 字节序

1.  35.5 转换为和从类型化数组转换

    1.  35.5.1 静态方法 `«ElementType»Array.from()`

    1.  35.5.2 类型化数组是可迭代的

    1.  35.5.3 将类型化数组转换为普通数组以及反之

    1.  35.5.4 将 `Uint8Array` (UTF-8) 转换为字符串以及反之

1.  35.6 调整 ArrayBuffer 的大小 (ES2024)

    1.  35.6.1 ArrayBuffer 的新特性

    1.  35.6.2 类型化数组如何响应 ArrayBuffer 大小的变化

    1.  35.6.3 ECMAScript 规范提供的指南

1.  35.7 传输和分离 ArrayBuffer (ES2024)

    1.  35.7.1 准备：数据传输和分离

    1.  35.7.2 与传输和分离相关的方法

    1.  35.7.3 通过 `structuredClone()` 传输 ArrayBuffer

    1.  35.7.4 在同一代理内传输 ArrayBuffer

    1.  35.7.5 分离 ArrayBuffer 会如何影响其包装器？

    1.  35.7.6 `ArrayBuffer.prototype.transferToFixedLength()`

1.  35.8 快速参考：索引与偏移量

1.  35.9 快速参考：ArrayBuffer

    1.  35.9.1 `new ArrayBuffer()`

    1.  35.9.2 `ArrayBuffer.*`

    1.  35.9.3 `ArrayBuffer.prototype.*`: 获取和切片

    1.  35.9.4 `ArrayBuffer.prototype.*`: 调整大小

1.  35.10 快速参考：Typed Arrays

    1.  35.10.1 `TypedArray.*`

    1.  35.10.2 `TypedArray.prototype.*`

    1.  35.10.3 `new «ElementType»Array()`

    1.  35.10.4 `«ElementType»Array.*`

    1.  35.10.5 `«ElementType»Array.prototype.*`

1.  35.11 快速参考：DataViews

    1.  35.11.1 `new DataView()`

    1.  35.11.2 `DataView.prototype.*`

### 35.1 The Typed Array API: containers for binary data

网络上的大量数据是文本：JSON 文件、HTML 文件、CSS 文件、JavaScript 代码等。JavaScript 通过其内置的字符串很好地处理这类数据。

然而，在 2011 年之前，它并没有很好地处理二进制数据。[Typed Array 规范 1.0](https://web.archive.org/web/20160529225618/https://www.khronos.org/registry/typedarray/specs/1.0/)于 2011 年 2 月 8 日推出，为处理二进制数据提供了工具。随着 ECMAScript 6 的推出，Typed Arrays 被添加到核心语言中，并获得了之前仅适用于普通数组的方法（`.map()`、`.filter()`等）。

#### 35.1.1 Use cases for Typed Arrays

Typed Arrays 的主要用途包括：

+   处理二进制数据：管理图像数据、操作二进制文件、处理二进制网络协议等。

+   与原生 API 交互：原生 API 通常以二进制格式接收和返回数据，在 ES6 之前的 JavaScript 中，我们无法很好地存储或操作这些数据。这意味着每次与这样的 API 通信时，数据都必须在每次调用时从 JavaScript 转换为二进制格式，然后再转换回来。Typed Arrays 消除了这个瓶颈。例如包括：

    +   [WebGL](https://www.khronos.org/webgl/)，"基于 OpenGL ES 的低级 3D 图形 API，通过 HTML5 Canvas 元素暴露给 ECMAScript"。Typed Arrays 最初是为 WebGL 创建的。文章[“Typed Arrays: Binary Data in the Browser”](https://web.dev/articles/webgl-typed-arrays#toc-history)（由 Ilmari Heikkinen 为 HTML5 Rocks 撰写）的[“Typed Arrays 的历程”](https://web.dev/articles/webgl-typed-arrays#toc-history)部分提供了更多信息。

    +   [WebGPU](https://www.w3.org/TR/webgpu/)，"一个用于在图形处理单元上执行操作（如渲染和计算）的 API"。例如，WebGPU 使用 ArrayBuffer 作为后备存储的包装器。

    +   [WebAssembly](https://webassembly.org)（简称“Wasm”），"一种基于栈的虚拟机的二进制指令格式。Wasm 被设计为编程语言的便携式编译目标，使得客户端和服务器应用程序能够在网络上部署。"例如，WebAssembly 代码的内存存储在 ArrayBuffer 或 SharedArrayBuffer 中（[详情](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Memory)）。

#### 35.1.2   核心类：`ArrayBuffer`、类型数组、`DataView`

类型数组 API 将二进制数据存储在`ArrayBuffer`的实例中：

```js
const buf = new ArrayBuffer(4); // length in bytes
  // buf is initialized with zeros

```

数组缓冲区本身是一个黑盒：如果我们想访问其数据，我们必须将其包装在另一个对象中——一个*视图对象*。有两种类型的视图对象可用：

+   *类型数组*与普通数组的工作方式相似，并允许我们将数据作为具有相同类型的索引元素序列访问。例如包括：

    +   `Uint8Array`：元素是无符号的 8 位整数。*无符号*意味着它们的范围从零开始。

    +   `Int16Array`：元素是带符号的 16 位整数。*带符号*意味着它们有符号，可以是负数、零或正数。

    +   `Float16Array`：元素是 16 位浮点数。

+   *数据视图*允许我们将数据解释为各种类型（`Uint8`、`Int16`、`Float16`等），我们可以在任何字节偏移量处读取和写入这些类型。

图 35.1 显示了 API 的类图。

![](img/a115834d4de67018f7d77365cf61bfce.png)

图 35.1：类型数组 API 的类。

#### 35.1.3   `SharedArrayBuffer` (ES2017)

共享数组缓冲区是一个数组缓冲区，其内存可以被多个*代理*（代理可以是主线程或 Web Worker）同时访问。

+   在数组缓冲区可以在代理之间*传输*（移动，而不是复制）的情况下，共享数组缓冲区是不可传输的，必须进行克隆。然而，这仅克隆了它们的表层部分。数据存储本身是共享的。

+   共享数组缓冲区可以*调整大小*，但它们只能增长而不能缩小，因为缩小共享内存太复杂了。

+   `Atomics`是一个全局命名空间，用于补充共享数组缓冲区的 API。ECMAScript 规范[描述它](https://tc39.es/ecma262/#sec-atomics-object)为“在共享内存数组单元上操作不可分割（原子）的函数以及允许代理等待和调度原始事件的函数。当有纪律地使用时，Atomics 函数允许通过共享内存通信的多代理程序在并行 CPU 上以可理解的方式执行。”

有关`SharedArrayBuffer`（[SharedArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer)）和`Atomics`（[Atomics](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics)）的更多信息，请参阅 MDN Web 文档。

### 35.2   使用类型数组

类型数组的使用方式与普通数组非常相似。

#### 35.2.1   创建类型数组

以下代码展示了创建相同类型数组的三种不同方法：

```js
// Argument: Typed Array or Array-like object
const ta1 = new Uint8Array([0, 1, 2]);

const ta2 = Uint8Array.of(0, 1, 2);
assert.deepEqual(ta2, ta1);

const ta3 = Uint8Array.from([0, 1, 2]);
assert.deepEqual(ta3, ta1);

const ta4 = new Uint8Array(3); // length of Typed Array
ta4[0] = 0;
ta4[1] = 1;
ta4[2] = 2;
assert.deepEqual(ta4, ta1);

```

#### 35.2.2   包装的`ArrayBuffer`

```js
const typedArray = new Int16Array(2); // 2 elements
assert.equal(typedArray.length, 2);

assert.deepEqual(
  typedArray.buffer, new ArrayBuffer(4)); // 4 bytes

```

#### 35.2.3   获取和设置元素

```js
const typedArray = new Int16Array(2);

assert.equal(typedArray[1], 0); // initialized with 0
typedArray[1] = 72;
assert.equal(typedArray[1], 72);

```

#### 35.2.4   连接类型数组

类型化数组没有像普通数组那样的 `.concat()` 方法。解决方案是使用它们的重载方法 `.set()`：

```js
.set(typedArray: TypedArray, offset=0): void
.set(arrayLike: ArrayLike<number>, offset=0): void

```

它将现有的 `typedArray` 或 `arrayLike` 复制到接收器中的 `offset` 索引处。`TypedArray` 是所有具体类型化数组类的内部抽象超类（实际上没有全局名称）。

以下函数使用该方法将零个或多个类型化数组（或类似数组的对象）复制到 `resultConstructor` 的一个实例中：

```js
function concatenate(resultConstructor, ...arrays) {
  let totalLength = 0;
  for (const arr of arrays) {
    totalLength += arr.length;
  }
  const result = new resultConstructor(totalLength);
  let offset = 0;
  for (const arr of arrays) {
    result.set(arr, offset);
    offset += arr.length;
  }
  return result;
}
assert.deepEqual(
  concatenate(Uint8Array, Uint8Array.of(1, 2), [3, 4]),
  Uint8Array.of(1, 2, 3, 4));

```

#### 35.2.5 类型化数组与普通数组

类型化数组与普通数组非常相似：它们都有一个 `.length`，可以通过中括号运算符 `[]` 访问元素，并且具有大多数标准数组方法。它们与普通数组在以下方面有所不同：

+   类型化数组有缓冲区。类型化数组 `ta` 的元素不存储在 `ta` 中，而是存储在关联的 ArrayBuffer 中，可以通过 `ta.buffer` 访问：

    ```js
    const ta = new Uint16Array(2); // 2 elements
    assert.deepEqual(
      ta.buffer, new ArrayBuffer(4)); // 4 bytes

    ```

+   类型化数组以零初始化：

    +   `new Array(4)` 创建一个没有任何元素的普通数组。它只有四个*空洞*（小于 `.length` 的索引没有关联的元素）。

    +   `new Uint8Array(4)` 创建一个类型化数组，其四个元素都是 0。

    ```js
    assert.deepEqual(new Uint8Array(4), Uint8Array.of(0, 0, 0, 0));

    ```

+   类型化数组的所有元素都具有相同的类型：

    +   设置元素会将值转换为该类型。

        ```js
        const ta = new Uint8Array(1);

        ta[0] = 257;
        assert.equal(ta[0], 1); // 257 % 256 (overflow)

        ta[0] = '2';
        assert.equal(ta[0], 2);

        ```

    +   获取元素返回数字或大整数。

        ```js
        const ta = new Uint8Array(1);
        assert.equal(ta[0], 0);
        assert.equal(typeof ta[0], 'number');

        ```

+   类型化数组的 `.length` 从其 ArrayBuffer 中派生，永远不会改变（除非我们切换到不同的 ArrayBuffer）。

+   普通数组可以有空洞；类型化数组不能。

![Icon “exercise”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：字符串与 UTF-16 之间的转换**

`exercises/typed-arrays/utf-16-conversion_test.mjs`

### 35.3 使用 DataViews

这就是如何使用 DataViews：

```js
const dataView = new DataView(new ArrayBuffer(4));
assert.equal(dataView.getInt16(0), 0);
assert.equal(dataView.getUint8(0), 0);
dataView.setUint8(0, 5);

```

### 35.4 元素类型

| 元素 | 类型化数组 | 字节 | 描述 | 获取/设置 |  |
| --- | --- | --- | --- | --- | --- |
| `Int8` | `Int8Array` | 1 | 8-bit signed integer | `number` | ES6 |
| `Uint8` | `Uint8Array` | 1 | 8-bit unsigned int | `number` | ES6 |
| (`Uint8C`) | `Uint8ClampedArray` | 1 | 8-bit unsigned int | `number` | ES6 |
| `Int16` | `Int16Array` | 2 | 16-bit signed int | `number` | ES6 |
| `Uint16` | `Uint16Array` | 2 | 16-bit unsigned int | `number` | ES6 |
| `Int32` | `Int32Array` | 4 | 32-bit signed int | `number` | ES6 |
| `Uint32` | `Uint32Array` | 4 | 32-bit unsigned int | `number` | ES6 |
| `BigInt64` | `BigInt64Array` | 8 | 64-bit signed int | `bigint` | ES2020 |
| `BigUint64` | `BigUint64Array` | 8 | 64-bit unsigned int | `bigint` | ES2020 |
| `Float16` | `Float16Array` | 2 | 16-bit floating point | `number` | ES2025 |
| `Float32` | `Float32Array` | 4 | 32-bit floating point | `number` | ES6 |
| `Float64` | `Float64Array` | 8 | 64-bit floating point | `number` | ES6 |

表 35.1：类型化数组 API 支持的元素类型。

表 35.1 列出了可用的元素类型。这些类型（例如，`Int32`）出现在两个位置：

+   在类型数组中，它们指定了元素的类型。例如，`Int32Array`的所有元素都具有`Int32`类型。元素类型是类型数组唯一不同的方面。

+   在数据视图中，它们是我们使用`.getInt32()`和`.setInt32()`等方法访问其 ArrayBuffers 时的透镜。

元素类型`Uint8C`是特殊的：它不被`DataView`支持，仅存在以启用`Uint8ClampedArray`。此类型数组由`canvas`元素使用（其中它取代了`CanvasPixelArray`），应避免使用。`Uint8C`和`Uint8`之间的唯一区别是它们处理溢出的方式（如下所述）。

类型数组和数组缓冲区使用数字和大整数来导入和导出值：

+   `BigInt64`和`BigUint64`类型通过大整数处理。例如，设置器接受大整数，获取器返回大整数。

+   所有其他元素类型都通过数字处理。

#### 35.4.1 处理溢出和下溢

##### 35.4.1.1 处理整数的溢出

通常，当值超出元素类型范围时，使用模运算将其转换为范围内的值。对于有符号和无符号整数，这意味着：

+   最高值加一转换为最低值（对于无符号整数来说是 0）。

+   最低值减一转换为最高值。

以下函数有助于说明转换是如何工作的：

```js
function setAndGet(typedArray, value) {
  typedArray[0] = value;
  return typedArray[0];
}

```

无符号 8 位整数的模转换：

```js
const uint8 = new Uint8Array(1);

// Highest value of range
assert.equal(setAndGet(uint8, 255), 255);
// Positive overflow
assert.equal(setAndGet(uint8, 256), 0);

// Lowest value of range
assert.equal(setAndGet(uint8, 0), 0);
// Negative overflow
assert.equal(setAndGet(uint8, -1), 255);

```

有符号 8 位整数的模转换：

```js
const int8 = new Int8Array(1);

// Highest value of range
assert.equal(setAndGet(int8, 127), 127);
// Positive overflow
assert.equal(setAndGet(int8, 128), -128);

// Lowest value of range
assert.equal(setAndGet(int8, -128), -128);
// Negative overflow
assert.equal(setAndGet(int8, -129), 127);

```

限制转换不同：

+   所有负溢出值都转换为最低值。

+   所有正溢出值都转换为最高值。

```js
const uint8c = new Uint8ClampedArray(1);

// Highest value of range
assert.equal(setAndGet(uint8c, 255), 255);
// Positive overflow
assert.equal(setAndGet(uint8c, 256), 255);

// Lowest value of range
assert.equal(setAndGet(uint8c, 0), 0);
// Negative overflow
assert.equal(setAndGet(uint8c, -1), 0);

```

##### 35.4.1.2 处理浮点数的溢出和下溢

```js
const float16 = new Float16Array(1);
function setAndGet(typedArray, value) {
  typedArray[0] = value;
  return typedArray[0];
}

```

如果发生正溢出（正数离零太远），结果是正无穷大：

```js
assert.equal(
  setAndGet(float16, 2**15),
  32768
);
assert.equal(
  setAndGet(float16, 2**16),
  Infinity
);
assert.equal(
  2**16,
  65536 // float64
);

```

如果发生负溢出（负数离零太远），结果是负无穷大：

```js
assert.equal(
  setAndGet(float16, -(2**15)),
  -32768
);
assert.equal(
  setAndGet(float16, -(2**16)),
  -Infinity
);
assert.equal(
  -(2**16),
  -65536 // float64
);

```

算术下溢意味着一个数字在二进制小数点后有太多数字（它太接近整数）。如果发生这种情况，无法表示的数字将被省略：

```js
assert.equal(
  setAndGet(float16, 2**-24),
  5.960464477539063e-8
);
assert.equal(
  setAndGet(float16, 2**-25),
  0,
);
assert.equal(
  2**-25,
  2.9802322387695312e-8 // float64
);

```

有用的相关函数：`Math.f16round(x)` 将`x`四舍五入到 16 位（在 64 位浮点数内）。

#### 35.4.2 字节序

当一个类型（如`Uint16`）作为多个字节的序列存储时，*字节序*很重要：

+   大端序：最高有效字节最先。例如，`Uint16`值 0x4321 存储为两个字节——首先是 0x43，然后是 0x21。

+   小端序：最低有效字节最先。例如，`Uint16`值 0x4321 存储为两个字节——首先是 0x21，然后是 0x43。

字节序通常在每个 CPU 架构中是固定的，并且与原生 API 保持一致。类型数组用于与这些 API 通信，这就是为什么它们的字节序遵循平台的字节序，并且不能更改。

另一方面，协议和二进制文件的字节序可能不同，但每个格式在平台间是固定的。因此，我们必须能够以任意的字节序访问数据。DataViews 用于满足这一需求，并允许我们在获取或设置值时指定字节序。

[引用维基百科关于字节序](https://en.wikipedia.org/wiki/Endianness):

+   大端表示法是数据网络中最常见的约定；在互联网协议套件的协议中，如 IPv4、IPv6、TCP 和 UDP，字段以大端顺序传输。因此，大端字节序也被称为网络字节序。

+   小端存储在微处理器中很受欢迎，部分原因是英特尔公司对微处理器设计产生了重大历史影响。

其他排序也是可能的。这些通常被称为*中间端序*或*混合端序*。

### 35.5 将数据转换为和从类型数组转换

在本节中，`「ElementType」Array`代表`Int8Array`、`Uint8Array`等。`ElementType`是`Int8`、`Uint8`等。

#### 35.5.1 静态方法「ElementType」Array.from()

此方法具有以下类型签名：

```js
.from<S>(
  source: Iterable<S>|ArrayLike<S>,
  mapfn?: S => ElementType, thisArg?: any)
  : «ElementType»Array

```

`.from()`将`source`转换为`this`（一个类型数组）的实例。

例如，普通数组是可迭代的，并且可以使用此方法进行转换：

```js
assert.deepEqual(
  Uint16Array.from([0, 1, 2]),
  Uint16Array.of(0, 1, 2));

```

类型数组也是可迭代的：

```js
assert.deepEqual(
  Uint16Array.from(Uint8Array.of(0, 1, 2)),
  Uint16Array.of(0, 1, 2));

```

`source`也可以是一个类似数组的对象：

```js
assert.deepEqual(
  Uint16Array.from({0:0, 1:1, 2:2, length: 3}),
  Uint16Array.of(0, 1, 2));

```

可选的`mapfn`允许我们在`source`的元素成为结果元素之前对其进行转换。为什么一次性执行两个步骤*映射*和*转换*？与通过`.map()`单独映射相比，有两个优点：

1.  不需要中间的数组或类型数组。

1.  在将不同精度的类型数组之间进行转换时，出错的可能性更小。

继续阅读以了解第二个优势的解释。

##### 35.5.1.1 陷阱：在转换类型数组时映射

`.from()`静态方法可以选择性地在类型数组之间进行映射和转换。如果我们使用该方法，出错的可能性会更小。

为了了解为什么是这样，让我们首先将类型数组转换为具有更高精度的类型数组。如果我们使用`.from()`进行映射，结果将自动正确。否则，我们必须先转换然后映射。

```js
const typedArray = Int8Array.of(127, 126, 125);
assert.deepEqual(
  Int16Array.from(typedArray, x => x * 2),
  Int16Array.of(254, 252, 250));

assert.deepEqual(
  Int16Array.from(typedArray).map(x => x * 2),
  Int16Array.of(254, 252, 250)); // OK
assert.deepEqual(
  Int16Array.from(typedArray.map(x => x * 2)),
  Int16Array.of(-2, -4, -6)); // wrong

```

如果我们从类型数组转换为具有较低精度的类型数组，通过`.from()`进行映射会产生正确的结果。否则，我们必须先映射然后转换。

```js
assert.deepEqual(
  Int8Array.from(Int16Array.of(254, 252, 250), x => x / 2),
  Int8Array.of(127, 126, 125));

assert.deepEqual(
  Int8Array.from(Int16Array.of(254, 252, 250).map(x => x / 2)),
  Int8Array.of(127, 126, 125)); // OK
assert.deepEqual(
  Int8Array.from(Int16Array.of(254, 252, 250)).map(x => x / 2),
  Int8Array.of(-1, -2, -3)); // wrong

```

问题在于，如果我们通过`.map()`进行映射，则输入类型和输出类型是相同的。相比之下，`.from()`从任意输入类型映射到我们通过其接收器指定的输出类型。

#### 35.5.2 Typed Arrays 是可迭代的

Typed Arrays 是可迭代的。这意味着我们可以使用`for-of`循环和其他基于迭代的机制：

```js
const ui8 = Uint8Array.of(0, 1, 2);
for (const byte of ui8) {
  console.log(byte);
}

```

输出：

```js
0
1
2

```

ArrayBuffer 和 DataViews 是不可迭代的。

#### 35.5.3 将 Typed Arrays 转换为普通数组以及从普通数组转换回来

要将普通数组转换为 Typed Array，我们将其传递给：

+   Typed Array 构造函数接受 Typed Arrays、可迭代值和类似数组的对象。

+   `«ElementType»Array.from()`接受可迭代值和类似数组的值。

例如：

```js
const ta1 = new Uint8Array([0, 1, 2]);
const ta2 = Uint8Array.from([0, 1, 2]);
assert.deepEqual(ta1, ta2);

```

要将 Typed Array 转换为普通数组，我们可以使用`Array.from()`或展开（因为 Typed Arrays 是可迭代的）：

```js
assert.deepEqual(
  [...Uint8Array.of(0, 1, 2)], [0, 1, 2]
);
assert.deepEqual(
  Array.from(Uint8Array.of(0, 1, 2)), [0, 1, 2]
);

```

#### 35.5.4 将`Uint8Array`（UTF-8）转换为字符串以及从字符串转换回来

类`TextEncoder`和`TextDecoder`不是 ECMAScript 本身的一部分，但所有主要的 JavaScript 平台（浏览器、Node.js 等）都支持它们。因此，我们可以使用它们在`Uint8Array`和字符串之间进行转换。

将字符串转换为 UTF-8 编码的字节：

```js
const textEncoder = new TextEncoder();
function stringToUtf8(str) {
  return textEncoder.encode(str);
}

assert.deepEqual(
  stringToUtf8('abc'),
  Uint8Array.of(97, 98, 99)
);

```

将 UTF-8 编码的字节转换为字符串：

```js
const textDecoder = new TextDecoder();
function utf8ToString(bytes) {
  return textDecoder.decode(bytes);
}

assert.deepEqual(
  utf8ToString(Uint8Array.of(97, 98, 99)),
  'abc'
);

```

### 35.6 调整 ArrayBuffers（ES2024）

在 ArrayBuffers 变得可调整大小之前，它们具有固定的大小。如果我们想要一个增长或缩小，我们必须分配一个新的，并将旧的复制过来。这会花费时间，并且可以在 32 位系统上破坏地址空间。

#### 35.6.1 ArrayBuffer 的新特性

这些是调整大小引入的变化：

+   现有的构造函数多了一个参数：

    ```js
    new ArrayBuffer(byteLength: number, options?: {maxByteLength?: number})

    ```

+   有一个新方法和两个新属性：

    +   `ArrayBuffer.prototype.resize(newByteLength: number)`

        +   调整 ArrayBuffer 的大小。

    +   `get ArrayBuffer.prototype.resizable`

        +   返回一个布尔值，表示此 ArrayBuffer 是否可调整大小。

    +   `get ArrayBuffer.prototype.maxByteLength`

        +   如果在构造函数中提供了`options.maxByteLength`，则返回`options.maxByteLength`。否则，返回`this.byteLength`。

+   现有的`.slice()`方法始终返回不可调整大小的 ArrayBuffer。

构造函数的`options`对象决定了 ArrayBuffer 是否可调整大小：

```js
const resizableArrayBuffer = new ArrayBuffer(16, {maxByteLength: 32});
assert.equal(
  resizableArrayBuffer.resizable, true
);

const fixedArrayBuffer = new ArrayBuffer(16);
assert.equal(
  fixedArrayBuffer.resizable, false
);

```

#### 35.6.2 如何处理 Typed Arrays 对 ArrayBuffer 大小的变化

Typed Array 的构造函数看起来是这样的：

```js
new «TypedArray»(
  buffer: ArrayBuffer | SharedArrayBuffer,
  byteOffset?: number,
  length?: number
)

```

如果`length`是`undefined`，则 Typed Array 实例的`.length`和`.byteLength`会自动跟踪可调整大小的`buffer`的长度：

```js
const buf = new ArrayBuffer(2, {maxByteLength: 4});
// `tarr1` starts at offset 0 (`length` is undefined)
const tarr1 = new Uint8Array(buf);
// `tarr2` starts at offset 2 (`length` is undefined)
const tarr2 = new Uint8Array(buf, 2);

assert.equal(
  tarr1.length, 2
);
assert.equal(
  tarr2.length, 0
);

buf.resize(4);

assert.equal(
  tarr1.length, 4
);
assert.equal(
  tarr2.length, 2
);

```

如果 ArrayBuffer 被调整大小，则具有固定长度的包装器可能会*超出范围*：包装器的范围不再由 ArrayBuffer 覆盖。JavaScript 将其视为如果 ArrayBuffer 被*断开连接*：

+   `.length`、`.byteLength`和`.byteOffset`为零。

+   获取元素返回`undefined`。

+   设置元素会被静默忽略。

+   所有与元素相关的方法都会抛出错误。

```js
const buf = new ArrayBuffer(4, {maxByteLength: 4});
const tarr = new Uint8Array(buf, 2, 2);
assert.equal(
  tarr.length, 2
);
buf.resize(3);
// `tarr` is now partially out of bounds
assert.equal(
  tarr.length, 0
);
assert.equal(
  tarr.byteLength, 0
);
assert.equal(
  tarr.byteOffset, 0
);
assert.equal(
  tarr[0], undefined
);
assert.throws(
  () => tarr.at(0),
  {
    name: 'TypeError',
    message: 'Cannot perform %TypedArray%.prototype.at '
      + 'on a detached ArrayBuffer',
  }
);

```

#### 35.6.3 ECMAScript 规范提供的指南

ECMAScript 规范为使用可调整大小的 ArrayBuffer 提供了[以下指南](https://tc39.es/ecma262/#sec-resizable-arraybuffer-guidelines)：

+   我们建议尽可能在部署环境中测试程序。不同硬件设备之间的可用物理内存差异很大。同样，虚拟内存子系统在硬件设备和操作系统之间也存在很大差异。一个在 64 位桌面网络浏览器上运行且没有内存不足错误的程序，可能在 32 位移动网络浏览器上耗尽内存。

+   当为可调整大小的 ArrayBuffer 选择 `maxByteLength` 选项的值时，我们建议选择应用程序可能的最小大小。我们建议 `maxByteLength` 不要超过 1,073,741,824 (2³⁰ 字节或 1 GiB)。

+   请注意，成功构造特定最大大小的可调整大小 ArrayBuffer 并不保证未来的调整大小操作将成功。

### 35.7 转移和断开 ArrayBuffer^(ES2024)

#### 35.7.1 准备：转移数据和断开连接

网络 API（不是 ECMAScript 标准）长期以来一直支持[*结构化克隆*](https://html.spec.whatwg.org/multipage/structured-data.html#safe-passing-of-structured-data)，以安全地在领域之间移动值（`globalThis`、iframe、web workers 等）。某些对象也可以被[*转移*]：在克隆之后，原始对象变为*断开连接*（不可访问），所有权从原始对象转移到克隆对象。转移通常比复制更快，尤其是涉及大量内存时。这些是最常见的[*可转移对象*](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Transferable_objects)类别：

+   `ArrayBuffer`

+   流：

    +   `ReadableStream`

    +   `TransformStream`

    +   `WritableStream`

+   与 DOM 相关的数据：

    +   `ImageBitmap`

    +   `OffscreenCanvas`

+   杂项通信：

    +   `MessagePort`

    +   `RTCDataChannel`

#### 35.7.2 与转移和断开连接相关的方法

+   两个方法让我们可以显式地将一个 ArrayBuffer 转移到新对象（我们很快就会看到为什么这很有用）：

    +   `ArrayBuffer.prototype.transfer(newLength?: number)`

    +   `ArrayBuffer.prototype.transferToFixedLength(newLength?: number)`

+   一个获取器告诉我们一个 ArrayBuffer 是否已断开连接：

    +   `get ArrayBuffer.prototype.detached`

#### 35.7.3 通过 `structuredClone()` 转移 ArrayBuffer

广泛支持的`structuredClone()`也允许我们转移（因此断开）ArrayBuffer：

```js
const original = new ArrayBuffer(16);
const clone = structuredClone(original, {transfer: [original]});

assert.equal(
  original.byteLength, 0
);

assert.equal(
  clone.byteLength, 16
);

```

```js
assert.equal(
  original.detached, true
);
assert.equal(
  clone.detached, false
);

```

ArrayBuffer 的 `.transfer()` 方法仅仅提供了一个更简洁的方式来断开 ArrayBuffer：

```js
const original = new ArrayBuffer(16);
const transferred = original.transfer();

assert.equal(
  original.detached, true
);
assert.equal(
  transferred.detached, false
);

```

#### 35.7.4 在同一代理内传输 ArrayBuffer

转移通常用于两个 *代理*（代理可以是主线程或 Web Worker）之间。然而，在同一代理内进行转移也是有意义的：如果函数将（可能共享的）ArrayBuffer 作为参数传递，则可以将其转移，这样外部代码就无法干扰其操作。示例（取自 [ECMAScript 提案](https://github.com/tc39/proposal-arraybuffer-transfer?tab=readme-ov-file#ownership) 并稍作编辑）：

```js
async function validateAndWriteSafeAndFast(arrayBuffer) {
  const owned = arrayBuffer.transfer();

  // We have `owned` and no one can access its data via
  // `arrayBuffer` now because the latter is detached:
  assert.equal(
    arrayBuffer.detached, true
  );

  // `await` pauses this function – which gives external
  // code the opportunity to access `arrayBuffer`.
  await validate(owned);
  await fs.writeFile("data.bin", owned);
}

```

#### 35.7.5 解除 ArrayBuffer 的连接会如何影响其包装器？

##### 35.7.5.1 解除连接的 ArrayBuffer 的类型化数组

准备：

```js
> const arrayBuffer = new ArrayBuffer(16);
> const typedArray = new Uint8Array(arrayBuffer);
> arrayBuffer.transfer();

```

长度和偏移量都是零：

```js
> typedArray.length
0
> typedArray.byteLength
0
> typedArray.byteOffset
0

```

获取元素返回 `undefined`；设置元素会静默失败：

```js
> typedArray[0]
undefined
> typedArray[0] = 128
128

```

所有与元素相关的都会抛出异常：

```js
> typedArray.at(0)
TypeError: Cannot perform %TypedArray%.prototype.at
on a detached ArrayBuffer

```

##### 35.7.5.2 解除连接的 ArrayBuffer 的 DataView

DataView 的所有数据相关方法都会抛出：

```js
> const arrayBuffer = new ArrayBuffer(16);
> const dataView = new DataView(arrayBuffer);
> arrayBuffer.transfer();
> dataView.byteLength
TypeError: Cannot perform get DataView.prototype.byteLength
on a detached ArrayBuffer
> dataView.getUint8(0)
TypeError: Cannot perform DataView.prototype.getUint8
on a detached ArrayBuffer

```

##### 35.7.5.3 我们无法使用解除连接的 ArrayBuffer 创建新的包装器

```js
> const arrayBuffer = new ArrayBuffer(16);
> arrayBuffer.transfer();
> new Uint8Array(arrayBuffer)
TypeError: Cannot perform Construct on a detached ArrayBuffer
> new DataView(arrayBuffer)
TypeError: Cannot perform DataView constructor on a detached ArrayBuffer

```

#### 35.7.6 `ArrayBuffer.prototype.transferToFixedLength()`

此方法完善了 API：它将可调整大小的 ArrayBuffer 转换为固定长度的 ArrayBuffer。这可能会释放为增长而保留的内存。

### 35.8 快速参考：索引与偏移量

在准备 ArrayBuffer、类型化数组和 DataView 的快速参考之前，我们需要了解索引和偏移量之间的区别：

+   方括号运算符 `[ ]` 的索引：我们只能使用非负索引（从 0 开始）。

    在正常数组中，写入负索引会创建属性：

    ```js
    const arr = [6, 7];
    arr[-1] = 5;
    assert.deepEqual(
      Object.keys(arr), ['0', '1', '-1']);

    ```

    在类型化数组中，写入负索引会被忽略：

    ```js
    const tarr = Uint8Array.of(6, 7);
    tarr[-1] = 5;
    assert.deepEqual(
      Object.keys(tarr), ['0', '1']);

    ```

+   ArrayBuffer、类型化数组和 DataView 方法的索引：每个索引都可以是负数。如果是，则将其添加到实体的长度以产生实际索引。因此，`-1` 指的是最后一个元素，`-2` 指的是倒数第二个，等等。正常数组的方法也是这样工作的。

    ```js
    const ui8 = Uint8Array.of(0, 1, 2);
    assert.deepEqual(ui8.slice(-1), Uint8Array.of(2));

    ```

+   传递给类型化数组和 DataView 方法的偏移量：必须是非负数——例如：

    ```js
    const dataView = new DataView(new ArrayBuffer(4));
    assert.throws(
      () => dataView.getUint8(-1),
      {
        name: 'RangeError',
        message: 'Offset is outside the bounds of the DataView',
      });

    ```

是否是索引或偏移量只能通过查看文档来确定；没有简单的规则。

### 35.9 快速参考：ArrayBuffer

ArrayBuffer 存储二进制数据，这些数据应通过类型化数组和 DataView 访问。

#### 35.9.1 `new ArrayBuffer()`

+   `new ArrayBuffer(byteLength, options?)` ES6

    ```js
    new ArrayBuffer(
      byteLength: number,
      options?: { // ES2024
        maxByteLength?: number
      }
    )

    ```

    通过 `new` 调用此构造函数会创建一个容量为 `length` 字节的实例。每个字节最初都是 0。

    如果提供了 `options.maxByteLength`，则 ArrayBuffer 可以调整大小。否则，它具有固定长度。

#### 35.9.2 `ArrayBuffer.*`

+   `ArrayBuffer.isView(arg)` ES6

    如果`arg`是`ArrayBuffer`的视图（即，如果它是类型化数组或`DataView`），则返回`true`。

    ```js
    > ArrayBuffer.isView(new Uint8Array())
    true
    > ArrayBuffer.isView(new DataView(new ArrayBuffer()))
    true

    ```

#### 35.9.3 `ArrayBuffer.prototype.*`：获取和切片

+   `get ArrayBuffer.prototype.byteLength` ES6

    返回此`ArrayBuffer`的字节容量。

+   `ArrayBuffer.prototype.slice(startIndex=0, endIndex=this.byteLength)` ES6

    创建一个新的`ArrayBuffer`，它包含此`ArrayBuffer`中索引大于或等于`startIndex`且小于`endIndex`的字节。`start`和`endIndex`可以是负数（参见“快速参考：索引与偏移量”（§35.8））。

#### 35.9.4 `ArrayBuffer.prototype.*`：调整大小

+   `ArrayBuffer.prototype.resize(newByteLength)` ES2024

    改变此`ArrayBuffer`的大小。更多信息，请参见“调整`ArrayBuffer`大小”（§35.6）。

+   `get ArrayBuffer.prototype.resizable` ES2024

    如果此`ArrayBuffer`可调整大小，则返回`true`；如果不可以，则返回`false`。

+   `get ArrayBuffer.prototype.maxByteLength` ES2024

    如果在构造函数中提供了`options.maxByteLength`，则返回`options.maxByteLength`。否则，返回`this.byteLength`。

### 35.10 快速参考：类型化数组

类型化数组对象的属性分两步介绍：

1.  `TypedArray`：首先，我们来看所有类型化数组类的抽象超类（在本书开头的类图中已展示）。这个超类称为`TypedArray`，但在 JavaScript 中没有全局名称：

    ```js
    > Object.getPrototypeOf(Uint8Array).name
    'TypedArray'

    ```

1.  `«ElementType»Array`：具体的类型化数组类称为`Uint8Array`、`Int16Array`、`Float16Array`等。这些是我们通过`new`、`.of`和`.from()`使用的类。

#### 35.10.1 `TypedArray.*`

静态`TypedArray`方法由其子类（`Uint8Array`等）继承。因此，我们可以通过子类使用这些方法，这些子类是具体的，可以直接实例化。

+   `TypedArray.from(iterableOrArrayLike, mapFunc?)` ES6

    ```js
    // BigInt64Array: bigint instead of number
    TypedArray.from<T>(
      iterableOrArrayLike: Iterable<number> | ArrayLike<number>
    ): TypedArray<T>
    TypedArray.from<S, T>(
      iterableOrArrayLike: Iterable<S> | ArrayLike<S>,
      mapFunc: (v: S, k: number) => T, thisArg?: any
    ): TypedArray<T>

    ```

    将可迭代对象（包括数组和类型化数组）或类似数组的对象转换为类型化数组类的实例。

    ```js
    assert.deepEqual(
      Uint16Array.from([0, 1, 2]),
      Uint16Array.of(0, 1, 2));

    ```

    可选的`mapFunc`允许我们在`source`元素成为结果元素之前对其进行转换。

    ```js
    assert.deepEqual(
      Int16Array.from(Int8Array.of(127, 126, 125), x => x * 2),
      Int16Array.of(254, 252, 250));

    ```

+   `TypedArray.of(...items)` ES6

    ```js
    // BigInt64Array: bigint instead of number
    TypedArray.of<T>(
      ...items: Array<number>
    ): TypedArray<T>

    ```

    创建一个类型化数组类的新实例，其元素是`items`（强制转换为元素类型）。

    ```js
    assert.deepEqual(
      Int16Array.of(-1234, 5, 67),
      new Int16Array([-1234, 5, 67]) );

    ```

#### 35.10.2 `TypedArray.prototype.*`

类型化数组方法接受的索引可以是负数（它们以这种方式像传统的数组方法一样工作）。偏移量必须是正数。有关详细信息，请参见“快速参考：索引与偏移量”（§35.8）。

##### 35.10.2.1 特定于类型化数组的属性

以下属性特定于类型化数组；普通数组没有这些属性：

+   `get TypedArray.prototype.buffer` ES6

    返回支持此 Typed Array 的 ArrayBuffer。

+   `获取 TypedArray.prototype.length` ES6

    返回此 Typed Array 缓冲区的元素长度。

    ```js
    > new Uint32Array(new ArrayBuffer(4)).length
    1

    ```

+   `获取 TypedArray.prototype.byteLength` ES6

    返回此 Typed Array 缓冲区的字节大小。

    ```js
    > new Uint32Array(new ArrayBuffer(4)).byteLength
    4

    ```

+   `获取 TypedArray.prototype.byteOffset` ES6

    返回此 Typed Array 在其 ArrayBuffer 中的起始偏移量。

+   `TypedArray.prototype.set(typedArrayOrArrayLike, offset=0)` (ES6)

    将第一个参数的所有元素复制到这个 Typed Array 中。参数的索引 0 处的元素写入此 Typed Array 的`offset`索引（等等）。有关类似数组的更多信息，请参阅“类似数组的对象”（§34.5）。

+   `TypedArray.prototype.subarray(startIndex=0, endIndex=this.length)` ES6

    返回一个新的 Typed Array，它具有与这个 Typed Array 相同的缓冲区，但范围（通常）更小。如果`startIndex`为非负数，则结果 Typed Array 的第一个元素是`this[startIndex]`，第二个是`this[startIndex+1]`（等等）。如果`startIndex`为负数，则相应地转换。

##### 35.10.2.2 数组方法

以下方法基本上与普通数组的 方法相同（ECMAScript 版本指定了方法何时添加到数组中 - 在 ES6 之前，Typed Arrays 不存在于 ECMAScript 中）：

+   `TypedArray.prototype.at(index)` (ES2022, R)

+   `TypedArray.prototype.copyWithin(target, start, end=this.length)` (ES6, W)

+   `TypedArray.prototype.entries()` (ES6, R)

+   `TypedArray.prototype.every(predicate, thisArg?)` (ES5, R)

+   `TypedArray.prototype.fill(start=0, end=this.length)` (ES6, W)

+   `TypedArray.prototype.filter(predicate, thisArg?)` (ES5, R)

+   `TypedArray.prototype.find(predicate, thisArg?)` (ES6, R)

+   `TypedArray.prototype.findIndex(predicate, thisArg?)` (ES6, R)

+   `TypedArray.prototype.findLast(predicate, thisArg?)` (ES2023, R)

+   `TypedArray.prototype.findLastIndex(predicate, thisArg?)` (ES2023, R)

+   `TypedArray.prototype.forEach(callback)` (ES5, R)

+   `TypedArray.prototype.includes(searchElement, fromIndex)` (ES2016, R)

+   `TypedArray.prototype.indexOf(searchElement, fromIndex)` (ES5, R)

+   `TypedArray.prototype.join(separator = ',')` (ES1, R)

+   `TypedArray.prototype.keys()` (ES6, R)

+   `TypedArray.prototype.lastIndexOf(searchElement, fromIndex)` (ES5, R)

+   `TypedArray.prototype.map(callback, thisArg?)` (ES5, R)

+   `TypedArray.prototype.reduce(callback, initialValue?)` (ES5, R)

+   `TypedArray.prototype.reduceRight(callback, initialValue?)` (ES5, R)

+   `TypedArray.prototype.reverse()` (ES1, W)

+   `TypedArray.prototype.slice(start?, end?)` (ES3, R)

+   `TypedArray.prototype.some(predicate, thisArg?)` (ES5, R)

+   `TypedArray.prototype.sort(compareFunc?)` (ES1, W)

+   `TypedArray.prototype.toLocaleString()` (ES3, R)

+   `TypedArray.prototype.toReversed()` (ES2023, R)

+   `TypedArray.prototype.toSorted(compareFunc?)` (ES2023, R)

+   `TypedArray.prototype.toSpliced(start?, deleteCount?, ...items)` (ES2023, R)

+   `TypedArray.prototype.toString()` (ES1, R)

+   `TypedArray.prototype.values()` ^ (ES6, R)

+   `TypedArray.prototype.with(index, value)` ^ (ES2023, R)

关于这些方法如何工作的详细信息，请参阅“快速参考：`Array`” (§34.18)。

#### 35.10.3 `new «ElementType»Array()`

每个类型化数组构造函数都有一个名称，遵循 `«ElementType»Array` 的模式，其中 `«ElementType»` 是 表 35.1 中列出的元素类型之一。这意味着有 12 个类型化数组构造函数：

+   `Int8Array`, `Uint8Array`, `Uint8ClampedArray`

+   `Int16Array`, `Uint16Array`

+   `Int32Array`, `Uint32Array`

+   `BigInt64Array`, `BigUint64Array`

+   `Float16Array`, `Float32Array`, `Float64Array`

每个构造函数都有几个 *重载* 版本 – 它的行为取决于它接收到的参数数量和它们的类型：

+   `new «ElementType»Array(length=0)`

    创建一个新的 `«ElementType»Array`，具有给定的 `length` 和适当的缓冲区。缓冲区的大小（以字节为单位）：

    ```js
    length * «ElementType»Array.BYTES_PER_ELEMENT

    ```

+   `new «ElementType»Array(source: TypedArray)`

    创建一个新的 `«ElementType»Array` 实例，其元素与 `source` 的元素具有相同的值，但被强制转换为 `ElementType`。

+   `new «ElementType»Array(source: Iterable<number>)`

    +   `BigInt64Array`, `BigUint64Array`: 使用 `bigint` 而不是 `number`

    +   创建一个新的 `«ElementType»Array` 实例，其元素与 `source` 的项具有相同的值，但被强制转换为 `ElementType`。有关迭代器的更多信息，请参阅“同步迭代 (ES6)” (§32)。

+   `new «ElementType»Array(source: ArrayLike<number>)`

    +   `BigInt64Array`, `BigUint64Array`: 使用 `bigint` 而不是 `number`

    +   创建一个新的 `«ElementType»Array` 实例，其元素与 `source` 的元素具有相同的值，但被强制转换为 `ElementType`。有关类似数组的更多信息，请参阅“类似数组的对象” (§34.5)。

+   `new «ElementType»Array(buffer: ArrayBuffer, byteOffset=0, length=0)`

    创建一个新的 `«ElementType»Array`，其缓冲区为 `buffer`。它从给定的 `byteOffset` 开始访问缓冲区，并将具有给定的 `length`。注意，`length` 计算的是类型化数组（每个元素 1-8 字节）的元素数量，而不是字节数。

#### 35.10.4 `«ElementType»Array.*`

+   `«ElementType»Array.BYTES_PER_ELEMENT: number`

    计算存储单个元素所需的字节数：

    ```js
    > Uint8Array.BYTES_PER_ELEMENT
    1
    > Int16Array.BYTES_PER_ELEMENT
    2
    > Float64Array.BYTES_PER_ELEMENT
    8

    ```

#### 35.10.5 `«ElementType»Array.prototype.*`

+   `«ElementType»Array.prototype.BYTES_PER_ELEMENT: number`

    与 `«ElementType»Array.BYTES_PER_ELEMENT` 相同。

### 35.11 快速参考：DataViews

#### 35.11.1 `new DataView()`

+   `new DataView(arrayBuffer, byteOffset?, byteLength?)` ES6

    创建一个新的 `DataView`，其数据存储在 `buffer` 的 ArrayBuffer 中。默认情况下，新的 `DataView` 可以访问 `buffer` 的全部内容。最后两个参数允许我们更改这一点。

#### 35.11.2 `DataView.prototype.*`

在本节的剩余部分，`«ElementType»` 指的是以下两种类型之一：

+   `Int8`, `Uint8`

+   `Int16`, `Uint16`

+   `Int32`, `Uint32`

+   `BigInt64`, `BigUint64`

+   `Float16`, `Float32`, `Float64`

这些是 `DataView.prototype` 的属性：

+   `get DataView.prototype.buffer` ES6

    返回此 DataView 的 ArrayBuffer。

+   `get DataView.prototype.byteLength` ES6

    返回此 DataView 可以访问的字节数。

+   `get DataView.prototype.byteOffset` ES6

    返回此 DataView 从其缓冲区开始访问字节的偏移量。

+   `DataView.prototype.get«ElementType»(byteOffset, littleEndian=false)` ES6

    返回：

    +   `BigInt64`, `BigUint64`: `bigint`

    +   所有其他元素类型：`number`

    从此 DataView 的缓冲区中读取一个值。

+   `DataView.prototype.set«ElementType»(byteOffset, value, littleEndian=false)` ES6

    `value` 的类型：

    +   `BigInt64`, `BigUint64`: `bigint`

    +   所有其他元素类型：`number`

    将 `value` 写入此 DataView 的缓冲区。
