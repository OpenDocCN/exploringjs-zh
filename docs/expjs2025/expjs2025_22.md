# 18 数字

> 原文：[`exploringjs.com/js/book/ch_numbers.html`](https://exploringjs.com/js/book/ch_numbers.html)

1.  18.1 数字用于浮点数和整数

1.  18.2 数字字面量

    1.  18.2.1 整数字面量

    1.  18.2.2 浮点数字面量

    1.  18.2.3 语法陷阱：十进制整数字面量的属性

    1.  18.2.4 下划线（`_`）作为数字字面量的分隔符（ES2021）

1.  18.3 算术运算符

    1.  18.3.1 二进制算术运算符

    1.  18.3.2 一元加号（`+`）和一元减号（`-`）

    1.  18.3.3 增量（`++`）和减少（`--`）

1.  18.4 转换为数字

1.  18.5 数字错误值 `NaN` 和 `Infinity`

    1.  18.5.1 错误值：`NaN`

    1.  18.5.2 错误值：`Infinity`

1.  18.6 数字的精度：小心处理小数

1.  18.7 （高级）

1.  18.8 背景：浮点数精度

    1.  18.8.1 浮点数的简化表示

1.  18.9 JavaScript 中的整数数字

    1.  18.9.1 整数与带分数的浮点数有何不同？

    1.  18.9.2 转换为整数

    1.  18.9.3 JavaScript 中整数数字的范围

    1.  18.9.4 安全整数

1.  18.10 位运算符（高级）

    1.  18.10.1 内部位运算符使用 32 位整数

    1.  18.10.2 位非运算

    1.  18.10.3 二进制位运算符

    1.  18.10.4 位运算符

    1.  18.10.5 `b32()`: 以二进制表示法显示无符号 32 位整数

1.  18.11 快速参考：数字

    1.  18.11.1 数字的全局函数

    1.  18.11.2 `Number.*`: 数据属性

    1.  18.11.3 `Number.*`: 方法

    1.  18.11.4 `Number.prototype.*`

    1.  18.11.5 `Number.*`: 整数的属性和方法

    1.  18.11.6 来源

JavaScript 有两种数值类型：

+   *数字*是*双精度浮点数* - 根据*IEEE 浮点算术标准*（IEEE 754）实现的 64 位浮点数。

    +   它们也用于范围在±53 位内的较小整数。更多信息，请参阅“JavaScript 中的整数数字”（§18.9）。

+   *大整数*用任意精度表示整数。

本章涵盖了数字。大整数将在本书的后面部分介绍大整数。

### 18.1 数字用于浮点数和整数

在 JavaScript 中，类型`number`用于浮点数和整数：

```js
123.45 // floating point number literal
98 // integer literal

```

然而，所有数字都是浮点数。整数数字只是没有小数部分的浮点数：

```js
> 98 === 98.0
true

```

### 18.2 数字字面量

让我们检查数字字面量。

#### 18.2.1 整数字面量

几个*整数字面量*让我们可以用不同的基数表示整数：

```js
// Binary (base 2)
assert.equal(0b11, 3); // ES6

// Octal (base 8)
assert.equal(0o10, 8); // ES6

// Decimal (base 10)
assert.equal(35, 35);

// Hexadecimal (base 16)
assert.equal(0xE7, 231);

```

#### 18.2.2 浮点字面量

浮点数只能用 10 进制表示。

分数：

```js
> 35.0
35

```

指数：`eN`表示×10^N

```js
> 3e2
300
> 3e-2
0.03
> 0.3e2
30

```

#### 18.2.3 语法陷阱：十进制整数字面量的属性

访问十进制整数字面量的属性存在一个陷阱：如果十进制整数字面量后面紧跟着一个点，那么这个点被解释为小数点：

```js
7.toString(); // SyntaxError

```

有四种方法可以绕过这个陷阱：

```js
(7).toString(2)
7.0.toString(2)
7..toString(2)
7 .toString(2)  // space before dot

```

注意，非十进制整数字面量没有这个陷阱：

```js
> 0b11.toString()
'3'
> 0o11.toString()
'9'
> 0x11.toString()
'17'

```

#### 18.2.4 数字字面量中的下划线（`_`）作为分隔符（ES2021）

将数字分组以使长数字更易于阅读有着悠久的历史。例如：

+   1825 年，伦敦有 133.5 万人。

+   地球与太阳之间的距离是 1 亿 4 千 960 万公里。

自从 ES2021 以来，我们可以在数字字面量中使用下划线作为分隔符：

```js
const inhabitantsOfLondon = 1_335_000;
const distanceEarthSunInKm = 149_600_000;

```

在其他基数中，分组也很重要：

```js
const fileSystemPermission = 0b111_111_000;
const bytes = 0b1111_10101011_11110000_00001101;
const words = 0xFAB_F00D;

```

我们也可以在分数和指数中使用分隔符：

```js
const massOfElectronInKg = 9.109_383_56e-31;
const trillionInShortScale = 1e1_2;

```

##### 18.2.4.1 分隔符可以放在哪里？

分隔符的位置受到两种方式的限制：

+   我们只能在两个数字之间放置下划线。因此，以下所有数字字面量都是非法的：

    ```js
    3_.141
    3._141

    1_e12
    1e_12

    _1464301  // valid variable name!
    1464301_

    0_b111111000
    0b_111111000

    ```

+   我们不能在行内使用多个下划线：

    ```js
    123__456 // two underscores – not allowed

    ```

这些限制背后的动机是为了保持解析简单并避免奇怪的边缘情况。

##### 18.2.4.2 带有分隔符的数字解析

以下用于解析数字的函数不支持分隔符：

+   `Number()`

+   `Number.parseInt()`

+   `Number.parseFloat()`

例如：

```js
> Number('123_456')
NaN
> Number.parseInt('123_456')
123

```

理由是数字分隔符是为了代码。其他类型的输入应该以不同的方式处理。

### 18.3 算术运算符

#### 18.3.1 二进制算术运算符

表 18.1 列出了 JavaScript 的二进制算术运算符。

| 运算符 | 名称 |  | 示例 |
| --- | --- | --- | --- |
| `n + m` | 加法 | ES1 | `3 + 4` → `7` |
| `n - m` | 减法 | ES1 | `9 - 1` → `8` |
| `n * m` | 乘法 | ES1 | `3 * 2.25` → `6.75` |
| `n / m` | 除法 | ES1 | `5.625 / 5` → `1.125` |
| `n % m` | 余数 | ES1 | `8 % 5` → `3` |
|  |  |  | `-8 % 5` → `-3` |
| `n ** m` | 幂运算 | ES2016 | `4 ** 2` → `16` |

表 18.1：二进制算术操作符。

##### 18.3.1.1 `%` 是余数操作符

`%` 是余数操作符，而不是取模操作符。其结果具有第一个操作数的符号：

```js
> 5 % 3
2
> -5 % 3
-2

```

关于余数和取模之间的区别的更多信息，请参阅 2ality 上的博客文章“余数操作符 vs. 取模操作符（带 JavaScript 代码）”[“Remainder operator vs. modulo operator (with JavaScript code)”](https://2ality.com/2019/08/remainder-vs-modulo.html)。

#### 18.3.2 一元加号(`+`)和一元负号(`-`)

表 18.2 总结了两个操作符一元加号(`+`)和一元负号(`-`)。

| 操作符 | 名称 |  | 示例 |
| --- | --- | --- | --- |
| `+n` | 一元加号 | ES1 | `+(-7)` → `-7` |
| `-n` | 一元负号 | ES1 | `-(-7)` → `7` |

表 18.2：一元加号(`+`)和一元负号(`-`)操作符。

两个操作符都将它们的操作数强制转换为数字：

```js
> +'5'
5
> +'-12'
-12
> -'9'
-9

```

因此，一元加号允许我们将任意值转换为数字。

#### 18.3.3 增量(`++`)和减量(`--`)

增量操作符 `++` 存在前缀版本和后缀版本。在这两种版本中，它都会破坏性地将其操作数增加一。因此，其操作数必须是可以改变的存储位置。

减量操作符 `--` 作用相同，但会从其操作数中减去一个。以下两个示例解释了前缀和后缀版本之间的区别。

表 18.3 总结了增量操作符和减量操作符。

| 操作符 | 名称 |  | 示例 |
| --- | --- | --- | --- |
| `v++` | 增量 | ES1 | `let v=0; [v++, v]` → `[0, 1]` |
| `++v` | 增量 | ES1 | `let v=0; [++v, v]` → `[1, 1]` |
| `v--` | 减量 | ES1 | `let v=1; [v--, v]` → `[1, 0]` |
| `--v` | 减量 | ES1 | `let v=1; [--v, v]` → `[0, 0]` |

表 18.3：增量操作符和减量操作符。

接下来，我们将查看这些操作符的使用示例。

前缀 `++` 和前缀 `--` 改变它们的操作数然后返回它们。

```js
let foo = 3;
assert.equal(++foo, 4);
assert.equal(foo, 4);

let bar = 3;
assert.equal(--bar, 2);
assert.equal(bar, 2);

```

后缀 `++` 和后缀 `--` 返回它们的操作数然后改变它们。

```js
let foo = 3;
assert.equal(foo++, 3);
assert.equal(foo, 4);

let bar = 3;
assert.equal(bar--, 3);
assert.equal(bar, 2);

```

##### 18.3.3.1 操作数：不仅仅是变量

我们还可以将这些操作符应用于属性值：

```js
const obj = { a: 1 };
++obj.a;
assert.equal(obj.a, 2);

```

并且应用于数组元素：

```js
const arr = [ 4 ];
arr[0]++;
assert.deepEqual(arr, [5]);

```

![练习图标](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：数字操作符**

`exercises/numbers/is_odd_test.mjs`

### 18.4 转换为数字

这三种方法可以将值转换为数字：

+   `Number(value)`: 有一个描述性的名称，因此推荐使用。表 18.4 总结了其工作方式。

+   `+value`: 等同于 `Number(value)`。

+   `parseFloat(value)`: 具有异常行为 quirks 并且应该避免使用。

| `x` | `Number(x)` |
| --- | --- |
| `undefined` | `NaN` |
| `null` | `0` |
| 布尔值 | `false` → `0`, `true` → `1` |
| 数字 | `x`（无变化） |
| 大整数 | `-1n` → `-1`, `1n` → `1`等。 |
| 字符串 | `''` → `0` |
|  | 其他 → 解析的数字，忽略前导/尾随空格 |
| 符号 | 抛出`TypeError` |
| 对象 | 可配置的（例如，通过`.valueOf()`） |

表 18.4：将值转换为数字。

示例：

```js
assert.equal(Number(123.45), 123.45);

assert.equal(Number(''), 0);
assert.equal(Number('\n 123.45 \t'), 123.45);
assert.equal(Number('xyz'), NaN);

assert.equal(Number(-123n), -123);

```

对象转换为数字的方式可以配置——例如，通过重写`.valueOf()`：

```js
> Number({ valueOf() { return 123 } })
123 
```

![练习图标](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：转换为数字**

`exercises/numbers/parse_number_test.mjs`

### 18.5 数值错误值`NaN`和`Infinity`

JavaScript 有两个数值错误值：

+   `NaN`：

    +   如果解析数字失败或无法执行操作，将返回。

    +   通过`Number.isNaN()`检测。`NaN`不严格等于自身。

+   `Infinity`：

    +   如果一个数字太大或除以零，将返回。

    +   通过`Number.isFinite()`或通过`===`比较检测。

#### 18.5.1 错误值：`NaN`

`NaN`是“不是一个数字”（not a number）的缩写。讽刺的是，JavaScript 将其视为一个数字：

```js
> typeof NaN
'number'

```

何时返回`NaN`？

如果一个数字无法解析，将返回`NaN`：

```js
> Number('$$$')
NaN
> Number(undefined)
NaN

```

如果操作无法执行，将返回`NaN`：

```js
> Math.log(-1)
NaN
> Math.sqrt(-1)
NaN

```

如果操作数或参数是`NaN`，将返回`NaN`（以传播错误）：

```js
> NaN - 3
NaN
> 7 ** NaN
NaN

```

##### 18.5.1.1 检查`NaN`

`NaN`是唯一一个不严格等于自身的 JavaScript 值：

```js
const n = NaN;
assert.equal(n === n, false);

```

这些是检查值`x`是否为`NaN`的几种方法：

```js
const x = NaN;

assert.equal(Number.isNaN(x), true); // preferred
assert.equal(Object.is(x, NaN), true);
assert.equal(x !== x, true);

```

在最后一行，我们使用比较怪癖来检测`NaN`。

##### 18.5.1.2 在数组中查找`NaN`

一些数组方法无法找到`NaN`：

```js
> [NaN].indexOf(NaN)
-1

```

其他方法可以：

```js
> [NaN].includes(NaN)
true
> [NaN].findIndex(x => Number.isNaN(x))
0
> [NaN].find(x => Number.isNaN(x))
NaN

```

很遗憾，没有简单的经验法则。我们必须检查每个方法如何处理`NaN`。

#### 18.5.2 错误值：`Infinity`

何时返回错误值`Infinity`？

如果一个数字太大，将返回`Infinity`：

```js
> Math.pow(2, 1023)
8.98846567431158e+307
> Math.pow(2, 1024)
Infinity
> -Math.pow(2, 1024)
-Infinity

```

如果发生除以零，将返回`Infinity`：

```js
> 5 / 0
Infinity
> -5 / 0
-Infinity

```

##### 18.5.2.1 `Infinity`作为默认值

`Infinity`大于所有其他数字（除了`NaN`），因此它是一个很好的默认值：

```js
function findMinimum(numbers) {
  let min = Infinity;
  for (const n of numbers) {
    if (n < min) min = n;
  }
  return min;
}

assert.equal(findMinimum([5, -1, 2]), -1);
assert.equal(findMinimum([]), Infinity);

```

这解释了以下结果：

```js
> Math.min()
Infinity

```

##### 18.5.2.2 检查`Infinity`

这些是检查值`x`是否为`Infinity`的两种常见方式：

```js
const x = Infinity;

assert.equal(x === Infinity, true);
assert.equal(Number.isFinite(x), false);

```

![练习图标](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：比较数字**

`exercises/numbers/find_max_test.mjs`

### 18.6 数字的精度：小心处理小数

内部，JavaScript 浮点数使用 2 为基数（根据 IEEE 754 标准表示）。这意味着十进制小数（10 为基数）不能总是精确表示：

```js
> 0.1 + 0.2
0.30000000000000004
> 1.3 * 3
3.9000000000000004
> 1.4 * 100000000000000
139999999999999.98

```

因此，在 JavaScript 中进行算术运算时，我们需要考虑舍入误差。

继续阅读以了解这一现象的解释。

### 18.7 (高级)

本章的所有剩余部分都是高级内容。

### 18.8 背景信息：浮点精度

在 JavaScript 中，数字的计算并不总是产生正确的结果——例如：

```js
> 0.1 + 0.2
0.30000000000000004

```

要理解为什么，我们需要探索 JavaScript 内部如何表示浮点数。它使用三个整数来这样做，总共占用 64 位存储空间（双精度）：

| 成分 | 大小 | 整数范围 |
| --- | --- | --- |
| 符号 | 1 位 | [0, 1] |
| 分数 | 52 位 | [0, 2⁵²−1] |
| 指数 | 11 位 | [−1023, 1024] |

这些整数表示的浮点数是这样计算的：

> (–1)^(符号) × 0b1.尾数 × 2^(指数)

这种表示方法不能编码零，因为它的第二个组件（涉及分数）总是以 1 开头。因此，零通过特殊的指数−1023 和分数 0 进行编码。

#### 18.8.1 浮点数的简化表示

为了使进一步的讨论更容易，我们简化了前面的表示：

+   我们使用 10（十进制）而不是 2（二进制），因为大多数人更熟悉十进制。

+   *分数*是一个自然数，被解释为分数（小数点后的数字）。我们切换到*mantissa*，一个被解释为自身的整数。因此，指数的使用方式不同，但其基本作用没有改变。

+   由于尾数是一个整数（具有自己的符号），我们不再需要单独的符号。

新的表示方法如下：

> 尾数 × 10^(指数)

让我们尝试用几个浮点数来测试这种表示方法。

+   要编码整数 123，我们使用尾数 123 并将其乘以 1（10⁰）：

    ```js
    > 123 * (10 ** 0)
    123

    ```

+   要编码整数−45，我们使用尾数−45，再次使用指数零：

    ```js
    > -45 * (10 ** 0)
    -45

    ```

+   对于数字 1.5，我们想象在尾数后面有一个点。我们使用负指数−1 将那个点向左移动一位：

    ```js
    > 15 * (10 ** -1)
    1.5

    ```

+   对于数字 0.25，我们将小数点向左移动两位：

    ```js
    > 25 * (10 ** -2)
    0.25

    ```

换句话说：一旦我们有了小数位，指数就变为负数。我们也可以将这样的数字写成分数的形式：

+   分子（在水平分数线上方）：尾数

+   分母（在水平分数线下方）：一个指数为正且≥1 的 10。

例如：

```js
> 15 * (10 ** -1) === 15 / (10 ** 1)
true
> 25 * (10 ** -2) === 25 / (10 ** 2)
true

```

这些分数有助于理解为什么有些数字我们的编码无法表示：

+   `1/10` 可以表示。它已经具有所需的格式：分母中的 10 的幂次。

+   `1/2` 可以表示为 `5/10`。我们将分母中的 2 转换成 10 的幂次，通过将分子和分母都乘以 5 来实现。

+   `1/4` 可以表示为 `25/100`。我们将分母中的 4 转换成 10 的幂次，通过将分子和分母都乘以 25 来实现。

+   `1/3` 不能表示。没有方法可以将分母转换为 10 的幂。（10 的质因数是 2 和 5。因此，任何只有这些质因数的分母可以通过将分子和分母乘以足够的 2 和 5 来转换为 10 的幂。如果一个分母有不同的质因数，那么我们就无能为力了。）

为了结束我们的探索，我们切换回二进制：

+   `0.5 = 1/2` 可以用二进制表示，因为分母已经是 2 的幂。

+   `0.25 = 1/4` 可以用二进制表示，因为分母已经是 2 的幂。

+   `0.1 = 1/10` 不能表示，因为分母不能转换为 2 的幂。

+   `0.2 = 2/10` 不能表示，因为分母不能转换为 2 的幂。

现在我们可以看到为什么 `0.1 + 0.2` 不会产生正确的结果：内部，两个操作数都无法精确表示。

使用小数精确计算的唯一方法是通过内部切换到十进制。对于许多编程语言，默认是二进制，十进制是选项。例如：

+   Java 有 `BigDecimal` 类[`BigDecimal`](https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html)。

+   Python 有 `decimal` 模块[`decimal`](https://docs.python.org/3/library/decimal.html)。

有计划添加类似于 JavaScript 的东西：[ECMAScript 提案“十进制”](https://github.com/tc39/proposal-decimal)。直到那时，我们可以使用像 [big.js](https://github.com/MikeMcl/big.js/) 这样的库。

### 18.9 整数在 JavaScript 中的表示

整数是正常（浮点）数，没有小数部分：

```js
> 1 === 1.0
true
> Number.isInteger(1.0)
true

```

在本节中，我们将探讨一些用于处理这些伪整数的工具。JavaScript 也支持 *大整数*，它们是真正的整数。

#### 18.9.1 整数与带分数的浮点数有何不同？

正如我们所见，JavaScript（非大整数）整数只是没有小数部分的浮点数。但它们在以下方面有所不同：

+   在某些位置，只允许整数 – 例如，`Array` 构造函数只接受整数作为长度：

    ```js
    > new Array(1.1)
    RangeError: Invalid array length
    > new Array(1.0)
    [,]

    ```

+   在某些位置，带分数的数字会被强制转换为不带分数的数字 – 例如，位或（`|`）操作将操作数强制转换为 32 位整数：

    ```js
    > 3.9 | 0
    3

    ```

+   JavaScript 有几个常量和操作用于处理整数：

    ```js
    > Math.log2(Number.MAX_SAFE_INTEGER)
    53
    > Number.isInteger(123.0)
    true
    > Number.parseInt('123')
    123

    ```

+   非十进制整数字面量不能有分数（后缀 `.1` 被解释为读取属性 – 其名称非法以数字开头）：

    ```js
    0b1.1 // SyntaxError
    0o7.1 // SyntaxError
    0xF.1 // SyntaxError

    ```

+   一些 JavaScript 引擎内部以不同的方式表示较小的整数 – 作为真正的整数。例如，V8 对以下“小整数”范围这样做（[来源](https://medium.com/fhinkel/v8-internals-how-small-is-a-small-integer-e0badc18b6da)）：

    +   32 位系统：30 位加上符号位

    +   64 位系统：31 位加上符号位

#### 18.9.2 转换为整数

将数字转换为整数的推荐方法是使用 `Math` 对象的舍入方法之一：

+   `Math.floor(n)`: 返回小于等于 `n` 的最大整数 `i`

    ```js
    > Math.floor(2.1)
    2
    > Math.floor(2.9)
    2

    ```

+   `Math.ceil(n)`: 返回大于等于 `n` 的最小整数 `i`

    ```js
    > Math.ceil(2.1)
    3
    > Math.ceil(2.9)
    3

    ```

+   `Math.round(n)`: 返回与 `n` “最接近”的整数，其中 `.5` 被向上舍入——例如：

    ```js
    > Math.round(2.4)
    2
    > Math.round(2.5)
    3

    ```

+   `Math.trunc(n)`: 移除 `n` 中的任何小数部分（小数点后），因此将其转换为整数。

    ```js
    > Math.trunc(2.1)
    2
    > Math.trunc(2.9)
    2

    ```

更多关于四舍五入的信息，请参阅“四舍五入”（§19.3）。

#### 18.9.3 JavaScript 中整数数字的范围

这些是 JavaScript 中整数数字的重要范围：

+   **安全整数**：可以安全地由 JavaScript 表示（关于这意味着什么将在下一小节中详细介绍）

    +   精度：53 位加符号

    +   范围：(-2⁵³, 2⁵³)

+   **数组索引**

    +   精度：32 位，无符号

    +   范围：0, 2³²-1)（不包括最大长度）

    +   类型化数组有更大的范围，53 位（安全且无符号）

+   **位运算符**（位或等）

    +   精度：32 位

    +   无符号右移运算符（`>>>`）的范围：无符号，[0, 2³²)

    +   所有其他位运算符的范围：有符号，[-2³¹, 2³¹)

#### [18.9.4 安全整数

这是 JavaScript 中整数数字的安全范围（53 位加符号）：

> [–(2⁵³)+1, 2⁵³-1]

一个整数如果是精确地由一个 JavaScript 数字表示，则它是*安全的*。鉴于 JavaScript 数字是以分数形式乘以 2 的指数编码的，因此也可以表示更高的整数，但它们之间会有间隔。

例如（18014398509481984 是 2⁵⁴）：

```js
> 18014398509481983
18014398509481984
> 18014398509481984
18014398509481984
> 18014398509481985
18014398509481984
> 18014398509481986
18014398509481984
> 18014398509481987
18014398509481988

```

因此，以下数学整数是不安全的：

+   数学整数 18014398509481984 是由以下 JavaScript 数字表示的：

    +   18014398509481983

    +   18014398509481984

    +   18014398509481985

    +   18014398509481986

+   数学整数 18014398509481985 不能由任何 JavaScript 数字表示。

以下 `Number` 对象的属性有助于确定一个整数是否安全：

```js
assert.equal(Number.MAX_SAFE_INTEGER, (2 ** 53) - 1);
assert.equal(Number.MIN_SAFE_INTEGER, -Number.MAX_SAFE_INTEGER);

assert.equal(Number.isSafeInteger(5), true);
assert.equal(Number.isSafeInteger('5'), false);
assert.equal(Number.isSafeInteger(5.1), false);
assert.equal(Number.isSafeInteger(Number.MAX_SAFE_INTEGER), true);
assert.equal(Number.isSafeInteger(Number.MAX_SAFE_INTEGER+1), false);

```

![练习图标](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：检测安全整数**

`exercises/numbers/is_safe_integer_test.mjs`

##### 18.9.4.1 安全计算

让我们看看涉及不安全整数的计算。

以下结果是不正确的且不安全的，尽管它的两个操作数都是安全的：

```js
> 9007199254740990 + 3
9007199254740992

```

以下结果是安全的，但是不正确的。第一个操作数是不安全的；第二个操作数是安全的：

```js
> 9007199254740995 - 10
9007199254740986

```

因此，表达式 `a op b` 的结果是正确的，当且仅当：

```js
isSafeInteger(a) && isSafeInteger(b) && isSafeInteger(a op b)

```

即，操作数和结果都必须是安全的。

### 18.10 位运算符（高级）

#### 18.10.1 内部位运算符使用 32 位整数

内部，JavaScript 的位运算符使用 32 位整数进行操作。它们按照以下步骤产生结果：

+   输入（JavaScript 数字）：1-2 个操作数首先被转换为 JavaScript 数字（64 位浮点数），然后转换为 32 位整数。

+   计算（32 位整数）：实际操作处理 32 位整数并产生一个 32 位整数。

+   输出（JavaScript 数字）：在返回结果之前，它被转换回 JavaScript 数字。

##### 18.10.1.1 操作数和结果的类型

对于每个按位运算符，本书都提到了其操作数的类型及其结果。每个类型始终是以下两种之一：

| 类型 | 描述 | 大小 | 范围 |
| --- | --- | --- | --- |
| Int32 | 有符号 32 位整数 | 32 位，包括符号 | −2³¹, 2³¹) |
| Uint32 | 无符号 32 位整数 | 32 位 | [0, 2³²) |

考虑到前面提到的步骤，我建议假设按位运算符在内部以无符号 32 位整数（计算步骤）工作，而 Int32 和 Uint32 只影响 JavaScript 数字转换为整数以及从整数转换回 JavaScript 数字的方式（输入和输出步骤）。

##### [18.10.1.2 显示 JavaScript 数字为无符号 32 位整数

在探索按位运算符时，有时将 JavaScript 数字以二进制形式显示为无符号 32 位整数会有所帮助。这正是 `b32()` 所做的（其实现将在后面展示）：

```js
assert.equal(
  b32(-1),
  '11111111111111111111111111111111');
assert.equal(
  b32(1),
  '00000000000000000000000000000001');
assert.equal(
  b32(2 ** 31),
  '10000000000000000000000000000000');

```

#### 18.10.2 按位非

| 操作 | 名称 | 类型签名 |  |
| --- | --- | --- | --- |
| `~num` | 按位非，*补码* | Int32 → Int32 | ES1 |

表 18.5：按位非运算符。

按位非运算符（表 18.5）反转其操作数的每个二进制位：

```js
> b32(~0b100)
'11111111111111111111111111111011'

```

这种所谓的 *补码* 对于某些算术操作类似于负数。例如，将一个整数与其补码相加总是 `-1`：

```js
> 4 + ~4
-1
> -11 + ~-11
-1

```

#### 18.10.3 二进制按位运算符

| 操作 | 名称 | 类型签名 |  |
| --- | --- | --- | --- |
| `num1 & num2` | 按位与 | Int32 × Int32 → Int32 | ES1 |
| `num1 ¦ num2` | 按位或 | Int32 × Int32 → Int32 | ES1 |
| `num1 ^ num2` | 按位异或 | Int32 × Int32 → Int32 | ES1 |

表 18.6：二进制按位运算符。

二进制按位运算符（表 18.6）将它们的操作数的位组合起来以产生结果：

```js
> (0b1010 & 0b0011).toString(2).padStart(4, '0')
'0010'
> (0b1010 | 0b0011).toString(2).padStart(4, '0')
'1011'
> (0b1010 ^ 0b0011).toString(2).padStart(4, '0')
'1001'

```

#### 18.10.4 按位移位运算符

| 操作 | 名称 | 类型签名 |  |
| --- | --- | --- | --- |
| `num << count` | 左移 | Int32 × Uint32 → Int32 | ES1 |
| `num >> count` | 有符号右移 | Int32 × Uint32 → Int32 | ES1 |
| `num >>> count` | 无符号右移 | Uint32 × Uint32 → Uint32 | ES1 |

表 18.7：按位移位运算符。

移位运算符（表 18.7）将二进制位向左或向右移动：

```js
> (0b10 << 1).toString(2)
'100'

```

`>>` 保留最高位，`>>>` 不保留：

```js
> b32(0b10000000000000000000000000000010 >> 1)
'11000000000000000000000000000001'
> b32(0b10000000000000000000000000000010 >>> 1)
'01000000000000000000000000000001'

```

#### 18.10.5 `b32()`：以二进制形式显示无符号 32 位整数

我们已经多次使用了 `b32()`。以下代码是它的实现：

```js
/**
 * Return a string representing n as a 32-bit unsigned integer,
 * in binary notation.
 */
function b32(n) {
  // >>> ensures highest bit isn’t interpreted as a sign
  return (n >>> 0).toString(2).padStart(32, '0');
}
assert.equal(
  b32(6),
  '00000000000000000000000000000110');

```

`n >>> 0` 表示我们将 `n` 向右移动 0 位。因此，原则上，`>>>` 运算符什么都不做，但它仍然将 `n` 强制转换为无符号 32 位整数：

```js
> 12 >>> 0
12
> -12 >>> 0
4294967284
> (2**32 + 1) >>> 0
1

```

### 18.11 快速参考：数字

#### 18.11.1 数字的全局函数

JavaScript 有以下四个用于数字的全局函数：

+   `isFinite()`

+   `isNaN()`

+   `parseFloat()`

+   `parseInt()`

然而，最好使用 `Number` 的相应方法（如 `Number.isFinite()` 等），这些方法有更少的陷阱。它们是在 ES6 中引入的，下面将讨论。

#### 18.11.2 `Number.*`: 数据属性

+   `Number.EPSILON` ES6

    1 和下一个可表示的浮点数之间的差异。一般来说，[机器精度](https://en.wikipedia.org/wiki/Machine_epsilon)为浮点数算术中的舍入误差提供了一个上限。

    +   大约：2.2204460492503130808472633361816 × 10^(-16)

+   `Number.MAX_VALUE` ES1

    最大的正有限 JavaScript 数字。

    +   大约：1.7976931348623157 × 10³⁰⁸

+   `Number.MIN_VALUE` ES1

    最小的正 JavaScript 数字。大约 5 × 10^(−324)。

+   `Number.NaN` ES1

    与全局变量 `NaN` 相同。

+   `Number.NEGATIVE_INFINITY` ES1

    与 `-Number.POSITIVE_INFINITY` 相同。

+   `Number.POSITIVE_INFINITY` ES1

    与全局变量 `Infinity` 相同。

#### 18.11.3 `Number.*`: 方法

+   `Number.isFinite(num)` ES6

    如果 `num` 是一个实际的数字（既不是 `Infinity` 也不是 `-Infinity` 也不是 `NaN`），则返回 `true`。

    ```js
    > Number.isFinite(Infinity)
    false
    > Number.isFinite(-Infinity)
    false
    > Number.isFinite(NaN)
    false
    > Number.isFinite(123)
    true

    ```

+   `Number.isNaN(num)` ES6

    如果 `num` 的值是 `NaN`，则返回 `true`：

    ```js
    > Number.isNaN(NaN)
    true
    > Number.isNaN(123)
    false
    > Number.isNaN('abc')
    false

    ```

+   `Number.parseFloat(str)` ES6

    将其参数强制转换为字符串，并将其解析为浮点数。它忽略前导空白和非法尾随字符：

    ```js
    > Number.parseFloat('\t 123.4#')
    123.4

    ```

    这可能会隐藏问题。因此，对于将字符串转换为数字，`Number()` 通常是一个更好的选择，因为它只忽略前导和尾随空白：

    ```js
    > Number('\t 123.4#')
    NaN

    ```

#### 18.11.4 `Number.prototype.*`

(`Number.prototype` 是存储数字方法的区域。)

+   `Number.prototype.toExponential(fractionDigits?)` ES3

    +   返回一个表示数字的字符串，通过指数表示法。

    +   通过 `fractionDigits`，我们可以指定乘以指数的数字应该显示多少位数字。

        +   默认情况下，显示所需的所有数字。

    示例：数字太小，无法通过 `.toString()` 获取正指数。

    ```js
    > 1234..toString()
    '1234'

    > 1234..toExponential() // 3 fraction digits
    '1.234e+3'
    > 1234..toExponential(5)
    '1.23400e+3'
    > 1234..toExponential(1)
    '1.2e+3'

    ```

    示例：分数不够小，无法通过 `.toString()` 获取负指数。

    ```js
    > 0.003.toString()
    '0.003'
    > 0.003.toExponential()
    '3e-3'

    ```

+   `Number.prototype.toFixed(fractionDigits=0)` ES3

    返回一个不带指数的数字字符串表示形式，四舍五入到 `fractionDigits` 位数字。

    ```js
    > 0.00000012.toString() // with exponent
    '1.2e-7'

    > 0.00000012.toFixed(10) // no exponent
    '0.0000001200'
    > 0.00000012.toFixed()
    '0'

    ```

    如果数字是 10²¹ 或更大，即使是 `.toFixed()` 也使用指数：

    ```js
    > (10 ** 21).toFixed()
    '1e+21'

    ```

+   `Number.prototype.toPrecision(precision?)` ES3

    +   与 `.toString()` 类似，但 `precision` 指定了总共应该显示多少位数字。

    +   如果缺少`precision`，则使用`.toString()`。

    ```js
    > 1234..toPrecision(3)  // requires exponential notation
    '1.23e+3'

    > 1234..toPrecision(4)
    '1234'

    > 1234..toPrecision(5)
    '1234.0'

    > 1.234.toPrecision(3)
    '1.23'

    ```

+   `Number.prototype.toString(radix=10)` ES1

    返回数字的字符串表示形式。

    默认情况下，我们得到一个基数为 10 的数字：

    ```js
    > 123.456.toString()
    '123.456'

    ```

    如果我们想使数字有不同的基数，我们可以通过`radix`指定它：

    ```js
    > 4..toString(2) // binary (base 2)
    '100'
    > 4.5.toString(2)
    '100.1'

    > 255..toString(16) // hexadecimal (base 16)
    'ff'
    > 255.66796875.toString(16)
    'ff.ab'

    > 1234567890..toString(36)
    'kf12oi'

    ```

    `Number.parseInt()`提供逆操作：它将包含整数字符（没有分数！）的字符串（给定基数）转换为数字。

    ```js
    > Number.parseInt('kf12oi', 36)
    1234567890

    ```

#### 18.11.5 `Number.*`：整数的数据属性和方法

+   `Number.MIN_SAFE_INTEGER` ES6

    JavaScript 可以无歧义表示的最小整数（-2⁵³+1）。

+   `Number.MAX_SAFE_INTEGER` ES6

    JavaScript 可以无歧义表示的最大整数（2⁵³−1）。

+   `Number.isInteger(num)` ES6

    如果`num`是一个数字并且没有小数部分，则返回`true`。

    ```js
    > Number.isInteger(-17)
    true
    > Number.isInteger(33)
    true
    > Number.isInteger(33.1)
    false
    > Number.isInteger('33')
    false
    > Number.isInteger(NaN)
    false
    > Number.isInteger(Infinity)
    false

    ```

+   `Number.isSafeInteger(num)` ES6

    如果`num`是一个数字并且无歧义地表示一个整数，则返回`true`。

+   `Number.parseInt(str, radix=10)` ES6

    将其参数强制转换为字符串并将其解析为整数，忽略前导空白和非法尾随字符：

    ```js
    > Number.parseInt('  123#')
    123

    ```

    参数`radix`指定要解析的数字的基数：

    ```js
    > Number.parseInt('101', 2)
    5
    > Number.parseInt('FF', 16)
    255

    ```

    不要使用这种方法将数字转换为整数：将数字强制转换为字符串是不高效的。并且在第一个非数字字符之前停止并不是移除数字分数的好算法。以下是一个出错示例：

    ```js
    > Number.parseInt(1e21, 10) // wrong
    1

    ```

    使用`Math`的其中一个舍入函数将数字转换为整数更好：

    ```js
    > Math.trunc(1e21) // correct
    1e+21

    ```

#### 18.11.6 源

+   维基百科

+   [TypeScript 内置类型定义](https://github.com/microsoft/TypeScript/tree/main/src/lib/)

+   [MDN Web 文档中的 JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)

+   [ECMAScript 语言规范](https://tc39.es/ecma262/)
