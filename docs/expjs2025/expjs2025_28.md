# 24 符号 ES6

> 原文：[`exploringjs.com/js/book/ch_symbols.html`](https://exploringjs.com/js/book/ch_symbols.html)

1.  24.1 符号是具有唯一标识的原始值

    1.  24.1.1 符号是原始值

    1.  24.1.2 符号具有唯一标识且不按值比较

1.  24.2 符号的描述

1.  24.3 符号的用途

    1.  24.3.1 符号作为常数的值

    1.  24.3.2 符号作为唯一属性键

1.  24.4 公开已知的符号

1.  24.5 转换符号

### 24.1 符号是具有唯一标识的原始值

符号是通过`Symbol()`工厂函数创建的原始值：

```js
const mySymbol = Symbol('mySymbol');

```

参数是可选的，提供描述，这对于调试非常有用。

#### 24.1.1 符号是原始值

符号是原始值：

+   它们必须通过`typeof`进行分类：

    ```js
    const sym = Symbol();
    assert.equal(typeof sym, 'symbol');

    ```

+   它们可以作为对象的属性键：

    ```js
    const obj = {
      [sym]: 123,
    };

    ```

#### 24.1.2 符号具有唯一标识且不按值比较

尽管符号是原始值，但它们也像对象一样，由`Symbol()`创建的值具有唯一标识，并且不是通过值来比较的：

```js
> Symbol() === Symbol()
false

```

在符号出现之前，如果需要一个具有唯一标识（仅等于自身）的值，对象是最好的选择：

```js
const string1 = 'abc';
const string2 = 'abc';
assert.equal(
  string1 === string2, true // not unique
);

const object1 = {};
const object2 = {};
assert.equal(
  object1 === object2, false // unique
);

const symbol1 = Symbol();
const symbol2 = Symbol();
assert.equal(
  symbol1 === symbol2, false // unique
);

```

### 24.2 符号的描述

我们传递给符号工厂函数的参数为创建的符号提供描述：

```js
const mySymbol = Symbol('mySymbol');

```

描述可以通过两种方式访问。

首先，它是`.toString()`返回的字符串的一部分：

```js
assert.equal(mySymbol.toString(), 'Symbol(mySymbol)');

```

其次，自 ES2019 以来，我们可以通过属性`.description`检索描述：

```js
assert.equal(mySymbol.description, 'mySymbol');

```

### 24.3 符号的用途

符号的主要用途包括：

+   常数的值

+   唯一属性键

#### 24.3.1 符号作为常数的值

假设你想创建代表红色、橙色、黄色、绿色、蓝色和紫色的常量。一个简单的方法是使用字符串：

```js
const COLOR_BLUE = 'Blue';

```

优点是，记录该常量会产生有用的输出。缺点是，有误将无关的值误认为是颜色的风险，因为内容相同的两个字符串被认为是相等的：

```js
const MOOD_BLUE = 'Blue';
assert.equal(COLOR_BLUE, MOOD_BLUE);

```

我们可以通过符号解决这个问题：

```js
const COLOR_BLUE = Symbol('Blue');
const MOOD_BLUE = Symbol('Blue');

assert.notEqual(COLOR_BLUE, MOOD_BLUE);

```

让我们使用符号值常数来实现一个函数：

```js
const COLOR_RED    = Symbol('Red');
const COLOR_ORANGE = Symbol('Orange');
const COLOR_YELLOW = Symbol('Yellow');
const COLOR_GREEN  = Symbol('Green');
const COLOR_BLUE   = Symbol('Blue');
const COLOR_VIOLET = Symbol('Violet');

function getComplement(color) {
  switch (color) {
    case COLOR_RED:
      return COLOR_GREEN;
    case COLOR_ORANGE:
      return COLOR_BLUE;
    case COLOR_YELLOW:
      return COLOR_VIOLET;
    case COLOR_GREEN:
      return COLOR_RED;
    case COLOR_BLUE:
      return COLOR_ORANGE;
    case COLOR_VIOLET:
      return COLOR_YELLOW;
    default:
      throw new Exception('Unknown color: '+color);
  }
}
assert.equal(getComplement(COLOR_YELLOW), COLOR_VIOLET);

```

#### 24.3.2 符号作为唯一属性键

对象中属性（字段）的键在两个级别上使用：

+   程序在*基本级别*上运行。该级别的键反映了*问题域*——程序解决问题的领域——例如：

    +   如果一个程序管理员工，属性键可能涉及职位名称、薪资类别、部门 ID 等。

    +   如果程序是一个棋盘游戏应用，属性键可能涉及棋子、棋盘、玩家颜色等。

+   ECMAScript 和许多库在元级别上运行。它们管理数据并提供不属于问题域的服务。例如：

    +   当 ECMAScript 创建对象的字符串表示时，会使用标准方法 `.toString()`（行 A）：

        ```js
        const point = {
          x: 7,
          y: 4,
          toString() {
         return `(${this.x}, ${this.y})`;
         },
        };
        assert.equal(
         String(point), '(7, 4)'); // (A)

        ```

        `.x` 和 `.y` 是基础级别的属性——它们用于解决使用点进行计算的问题。`.toString()` 是元级别的属性——它与问题域无关。

    +   标准 ECMAScript 方法 `.toJSON()` 可以用来自定义对象转换为其他形式的方式。

        ```js
        const point = {
          x: 7,
          y: 4,
          toJSON() {
         return [this.x, this.y];
         },
        };
        assert.equal(
         JSON.stringify(point), '[7,4]');

        ```

        `.x` 和 `.y` 是基础级别的属性，`.toJSON()` 是元级别的属性。

程序的基础级别和元级别必须是独立的：基础级别的属性键不应与元级别的属性键冲突。

如果我们使用名称（字符串）作为属性键，我们将面临两个挑战：

+   当一种语言最初被创建时，它可以使用它想要的任何元级别名称。基础级别代码被迫避免这些名称。然而，当大量基础级别代码已经存在时，元级别名称不能再自由选择。

+   我们可以引入命名规则来区分基础级别和元级别。例如，Python 使用两个下划线括起来元级别名称：`__init__`、`__iter__`、`__hash__` 等。然而，语言和库的元级别名称仍然存在于同一个命名空间中，可能会发生冲突。

这两个例子说明了后者对 JavaScript 产生的问题：

+   2018 年 5 月，Array 方法 `.flatten()` 必须更名为 `.flat()`，因为之前的名称已被库使用（[来源](https://github.com/tc39/proposal-flatMap/commit/093eacc7fe0906e70f7626bf6c7d6e9dfc53cce9))。

+   2020 年 11 月，Array 方法 `.item()` 必须更名为 `.at()`，因为之前的名称已被库使用（[来源](https://github.com/tc39/proposal-relative-indexing-method#web-incompatibility-history))。

作为属性键使用的符号在这里很有帮助：每个符号都是唯一的，符号键永远不会与任何其他字符串或符号键冲突。

##### 24.3.2.1 示例：具有元级别方法的库

例如，假设我们正在编写一个库，该库根据对象是否实现特殊方法以不同的方式处理对象。定义此类方法的属性键并为其对象实现它的样子如下：

```js
const specialMethod = Symbol('specialMethod');
const obj = {
  _id: 'kf12oi',
  [specialMethod]() { // (A)
    return this._id;
  }
};
assert.equal(obj[specialMethod](), 'kf12oi');

```

行 A 中的方括号使我们能够指定该方法必须具有键 `specialMethod`。更多细节请参阅“对象字面量中的计算键”（§30.9.2）。

### 24.4 公共符号

在 ECMAScript 中扮演特殊角色的符号被称为*公开已知符号*。例如包括：

+   `Symbol.iterator`: 使一个对象可迭代。它是返回迭代器的方法的键。有关此主题的更多信息，请参阅“同步迭代（ES6）”（§32）。

+   `Symbol.hasInstance`: 自定义 `instanceof` 的工作方式。如果一个对象实现了具有该键的方法，则可以在该运算符的右侧使用它。例如：

    ```js
    const PrimitiveNull = {
      Symbol.hasInstance {
        return x === null;
      }
    };
    assert.equal(null instanceof PrimitiveNull, true);

    ```

+   `Symbol.toStringTag`: 影响默认的 `.toString()` 方法。

    ```js
    > String({})
    '[object Object]'
    > String({ [Symbol.toStringTag]: 'is no money' })
    '[object is no money]'

    ```

    注意：通常最好重写 `.toString()`。

![图标“练习”](img/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：公开已知符号**

+   `Symbol.toStringTag`: `exercises/symbols/to_string_tag_test.mjs`

+   `Symbol.hasInstance`: `exercises/symbols/has_instance_test.mjs`

### 24.5 符号转换

如果我们将符号 `sym` 转换为其他原始类型会发生什么？表 24.1 中有答案。

| 转换为 | 显式转换 | 强制转换（隐式转换） |
| --- | --- | --- |
| 布尔值 | `Boolean(sym)` → 正确 | `!sym` → 正确 |
| 数字 | `Number(sym)` → `TypeError` | `sym*2` → `TypeError` |
| 字符串 | `String(sym)` → 正确 | `''+sym` → `TypeError` |
|  | `sym.toString()` → 正确 | `` `${sym}` `` → `TypeError` |

表 24.1：将符号转换为其他原始类型的结果。

符号的一个关键陷阱是转换它们时抛出异常的频率。背后的想法是什么？首先，转换为数字永远没有意义，应该警告。其次，将符号转换为字符串确实对诊断输出很有用。但同时也应该警告意外地将符号转换为字符串（这是一种不同类型的属性键）：

```js
const obj = {};
const sym = Symbol();
assert.throws(
  () => { obj['__'+sym+'__'] = true },
  { message: 'Cannot convert a Symbol value to a string' });

```

缺点是异常使得使用符号变得更加复杂。您必须显式转换符号，当通过加号运算符组装字符串时：

```js
> const mySymbol = Symbol('mySymbol');
> 'Symbol I used: ' + mySymbol
TypeError: Cannot convert a Symbol value to a string
> 'Symbol I used: ' + String(mySymbol)
'Symbol I used: Symbol(mySymbol)'

```
