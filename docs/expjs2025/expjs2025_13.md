# 11 断言 API

> 原文：[`exploringjs.com/js/book/ch_assertion-api.html`](https://exploringjs.com/js/book/ch_assertion-api.html)

1.  11.1 软件开发中的断言

1.  11.2 本书中使用断言的方式

    1.  11.2.1 通过断言在代码示例中记录结果

    1.  11.2.2 通过断言实现测试驱动练习

1.  11.3 正常比较与深度比较

1.  11.4 快速参考：模块 `assert`

    1.  11.4.1 正常相等：`assert.equal()`

    1.  11.4.2 深度相等：`assert.deepEqual()`

    1.  11.4.3 期望异常：`assert.throws()`

    1.  11.4.4 总是失败：`assert.fail()`

### 11.1 软件开发中的断言

在软件开发中，*断言*用于声明关于值或代码片段的事实，这些事实必须是真实的。如果不是，则会抛出异常。Node.js 通过其内置模块 `assert` 支持断言 – 例如：

```js
import assert from 'node:assert/strict';
assert.equal(3 + 5, 8);

```

此断言声明期望的结果是 3 加 5 等于 8。导入语句使用了[推荐的 `strict` 版本](https://nodejs.org/api/assert.html#assert_strict_mode)的 `assert`。

### 11.2 本书中使用断言的方式

在本书中，断言以两种方式使用：在代码示例中记录结果以及实现测试驱动练习。

#### 11.2.1 通过断言在代码示例中记录结果

在代码示例中，断言表达期望的结果。例如，以下函数：

```js
function id(x) {
  return x;
}

```

`id()` 返回其参数。我们可以通过断言来展示其作用：

```js
assert.equal(id('abc'), 'abc');

```

在示例中，我通常省略导入 `assert` 的语句。

使用断言背后的动机是：

+   我们可以精确地指定期望的内容。

+   代码示例可以自动测试，这确保了它们确实有效。

#### 11.2.2 通过断言实现测试驱动练习

本书的学习练习是通过测试框架 Mocha 驱动的。测试中的检查是通过 `assert` 的方法进行的。

以下是一个此类测试的示例：

```js
// For the exercise, we must implement the function hello().
// The test checks if we have done it properly.
test('First exercise', () => {
  assert.equal(hello('world'), 'Hello world!');
  assert.equal(hello('Jane'), 'Hello Jane!');
  assert.equal(hello('John'), 'Hello John!');
  assert.equal(hello(''), 'Hello !');
});

```

更多信息，请参阅“开始练习”（§12）。

### 11.3 正常比较与深度比较

严格的 `equal()` 使用 `===` 来比较值。因此，一个对象仅等于自身 – 即使另一个对象具有相同的内容（因为 `===` 不比较对象的内容，只比较它们的标识）：

```js
assert.notEqual({foo: 1}, {foo: 1});

```

`deepEqual()` 是比较对象的更好选择：

```js
assert.deepEqual({foo: 1}, {foo: 1});

```

此方法也适用于数组：

```js
assert.notEqual(['a', 'b', 'c'], ['a', 'b', 'c']);
assert.deepEqual(['a', 'b', 'c'], ['a', 'b', 'c']);

```

### 11.4 快速参考：模块 `assert`

对于完整的文档，请参阅 [Node.js 文档](https://nodejs.org/api/assert.html)。

#### 11.4.1 正常相等：`assert.equal()`

+   `assert.equal(actual, expected, message?)`

    `actual === expected` 必须为 `true`。如果不为真，将抛出 `AssertionError`。

    ```js
    assert.equal(3+3, 6);

    ```

+   `assert.notEqual(actual, expected, message?)`

    `actual !== expected` 必须为 `true`。如果不为真，将抛出 `AssertionError`。

    ```js
    assert.notEqual(3+3, 22);

    ```

可选的最后一个参数 `message` 可以用来解释所断言的内容。如果断言失败，该消息用于设置抛出的 `AssertionError`。

```js
let e;
try {
  const x = 3;
  assert.equal(x, 8, 'x must be 8')
} catch (err) {
  assert.equal(
    String(err),
    'AssertionError [ERR_ASSERTION]: x must be 8\n\n3 !== 8\n');
}

```

#### 11.4.2 深度相等：`assert.deepEqual()`

+   `assert.deepEqual(actual, expected, message?)`

    `actual` 必须与 `expected` 深度相等。如果不相等，将抛出 `AssertionError`。

    ```js
    assert.deepEqual([1,2,3], [1,2,3]);
    assert.deepEqual([], []);

    // To .equal(), an object is only equal to itself:
    assert.notEqual([], []);

    ```

+   `assert.notDeepEqual(actual, expected, message?)`

    `actual` 必须与 `expected` 不深度相等。如果相等，将抛出 `AssertionError`。

    ```js
    assert.notDeepEqual([1,2,3], [1,2]);

    ```

#### 11.4.3 期望异常：`assert.throws()`

如果我们想要（或期望）收到一个异常，我们需要 `assert.throws()`：这个函数调用它的第一个参数，即函数 `callback`，并且只有当它抛出异常时才成功。可以使用额外的参数来指定那个异常必须看起来像什么。

+   `assert.throws(callback, message?): void`

    ```js
    assert.throws(
      () => {
        null.prop;
      }
    );

    ```

+   `assert.throws(callback, errorClass, message?): void`

    ```js
    assert.throws(
      () => {
        null.prop;
      },
      TypeError
    );

    ```

+   `assert.throws(callback, errorRegExp, message?): void`

    ```js
    assert.throws(
      () => {
        null.prop;
      },
      /^TypeError: Cannot read properties of null \(reading 'prop'\)$/
    );

    ```

+   `assert.throws(callback, errorObject, message?): void`

    ```js
    assert.throws(
      () => {
        null.prop;
      },
      {
        name: 'TypeError',
        message: "Cannot read properties of null (reading 'prop')",
      }
    );

    ```

#### 11.4.4 始终失败：`assert.fail()`

+   `assert.fail(messageOrError?)`

    默认情况下，当它被调用时，它会抛出 `AssertionError`。这在单元测试中偶尔很有用。"messageOrError" 可以是：

    +   一个字符串。这允许覆盖默认的错误信息。

    +   `Error` 的一个实例（或其子类）。这使我们能够抛出不同的值。

    ```js
    try {
      functionThatShouldThrow();
      assert.fail();
    } catch (_) {
      // Success
    }

    ```
