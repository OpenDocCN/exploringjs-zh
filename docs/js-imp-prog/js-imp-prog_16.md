# 十三、运算符

> 原文：[`exploringjs.com/impatient-js/ch_operators.html`](https://exploringjs.com/impatient-js/ch_operators.html)
> 
> 译者：[飞龙](https://github.com/wizardforcel)
> 
> 协议：[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)


* * *

+   13.1 理解运算符

    +   13.1.1 运算符将其操作数强制转换为适当的类型

    +   13.1.2 大多数运算符只能用于原始值

+   13.2 加法运算符 (`+`)

+   13.3 赋值运算符

    +   13.3.1 普通赋值运算符

    +   13.3.2 复合赋值运算符

+   13.4 相等：`==` vs. `===`

    +   13.4.1 宽松相等 (`==` 和 `!=`)

    +   13.4.2 严格相等 (`===` 和 `!==`)

    +   13.4.3 建议：始终使用严格相等

    +   13.4.4 比 `===` 更严格：`Object.is()`

+   13.5 排序运算符

+   13.6 其他各种运算符

    +   13.6.1 逗号运算符

    +   13.6.2 `void` 运算符

* * *

### 13.1 理解运算符

JavaScript 的运算符可能看起来有些古怪。有了以下两条规则，它们就更容易理解：

+   运算符将其操作数强制转换为适当的类型

+   大多数运算符只能用于原始值

#### 13.1.1 运算符将其操作数强制转换为适当的类型

如果运算符得到不正确类型的操作数，则很少抛出异常。相反，它会*强制*（自动转换）操作数，以便可以使用它们。让我们看两个例子。

首先，乘法运算符只能用于数字。因此，在计算结果之前，它将字符串转换为数字。

```js
> '7' * '3'
21
```

其次，用于访问对象属性的方括号运算符（`[ ]`）只能处理字符串和符号。所有其他值都被强制转换为字符串：

```js
const obj = {};
obj['true'] = 123;

// Coerce true to the string 'true'
assert.equal(obj[true], 123);
```

#### 13.1.2 大多数运算符只能用于原始值

如前所述，大多数运算符只能用于原始值。如果操作数是对象，则通常会被强制转换为原始值，例如：

```js
> [1,2,3] + [4,5,6]
'1,2,34,5,6'
```

为什么？加法运算符首先将其操作数强制转换为原始值：

```js
> String([1,2,3])
'1,2,3'
> String([4,5,6])
'4,5,6'
```

接下来，连接两个字符串：

```js
> '1,2,3' + '4,5,6'
'1,2,34,5,6'
```

### 13.2 加法运算符 (`+`)

在 JavaScript 中，加法运算符的工作方式如下：

+   首先，它将两个操作数转换为原始值。然后切换到两种模式之一：

    +   字符串模式：如果两个原始值中有一个是字符串，则将另一个转换为字符串，连接两个字符串，并返回结果。

    +   数字模式：否则，将两个操作数转换为数字，相加，并返回结果。

字符串模式允许我们使用 `+` 来组装字符串：

```js
> 'There are ' + 3 + ' items'
'There are 3 items'
```

数字模式意味着如果没有一个操作数是字符串（或者是一个变成字符串的对象），那么一切都会被强制转换为数字：

```js
> 4 + true
5
```

`Number(true)` 是 `1`。

### 13.3 赋值运算符

#### 13.3.1 普通赋值运算符

普通赋值运算符用于更改存储位置：

```js
x = value; // assign to a previously declared variable
obj.propKey = value; // assign to a property
arr[index] = value; // assign to an Array element
```

变量声明中的初始化器也可以看作是一种赋值：

```js
const x = value;
let y = value;
```

#### 13.3.2 复合赋值运算符

JavaScript 支持以下赋值运算符：

+   算术赋值运算符：`+= -= *= /= %=` [ES1]

    +   `+=` 也可以用于字符串连接

    +   后引入：`**=` [ES2016]

+   按位赋值运算符：`&= ^= |=` [ES1]

+   按位移位赋值运算符：`<<= >>= >>>=` [ES1]

+   逻辑赋值运算符：`||= &&= ??=` [ES2021]

##### 13.3.2.1 逻辑赋值运算符 [ES2021]

逻辑赋值运算符与其他复合赋值运算符的工作方式不同：

| 赋值运算符 | 等同于 | 仅在 `a` 为时赋值 |
| --- | --- | --- |
| `a &#124;&#124;= b` | `a &#124;&#124; (a = b)` | 假值 |
| `a &&= b` | `a && (a = b)` | 真值 |
| `a ??= b` | `a ?? (a = b)` | 空值 |

为什么 `a ||= b` 等同于以下表达式？

> `a || (a = b)`

为什么不使用这个表达式？

> `a = a || b`

前一个表达式的好处在于 短路：只有在 `a` 评估为 `false` 时才会评估赋值。因此，只有在必要时才执行赋值。相反，后一个表达式总是执行赋值。

有关 `??=` 的更多信息，请参阅 [§14.4.5 “空值合并赋值运算符 (`??=`) [ES2021]”](ch_undefined-null.html#nullish-coalescing-assignment-operator)。

##### 13.3.2.2 剩余的复合赋值运算符

对于除 `|| && ??` 之外的操作符 `op`，以下两种赋值方式是等效的：

```js
myvar op= value
myvar = myvar op value
```

例如，如果 `op` 是 `+`，那么我们得到的运算符 `+=` 的工作方式如下。

```js
let str = '';
str += '<b>';
str += 'Hello!';
str += '</b>';

assert.equal(str, '<b>Hello!</b>');
```

### 13.4 相等：`==` vs. `===`

JavaScript 有两种类型的相等运算符：宽松相等 (`==`) 和严格相等 (`===`)。建议始终使用后者。

![](img/b666ba365e94edaf0ef510fd7e12c7de.png)  **`==` 和 `===` 的其他名称**

+   `==` 也被称为 *双等号*。它在语言规范中的官方名称是 [*抽象相等比较*](https://tc39.github.io/ecma262/#sec-abstract-equality-comparison)。

+   `===` 也被称为 *三等号*。

#### 13.4.1 宽松相等 (`==` 和 `!=`)

宽松相等是 JavaScript 的怪癖之一。它经常强制操作数。其中一些强制是有意义的：

```js
> '123' == 123
true
> false == 0
true
```

其他的不太一样：

```js
> '' == 0
true
```

如果（且仅当！）另一个操作数是原始值，对象才会被强制为原始值：

```js
> [1, 2, 3] == '1,2,3'
true
> ['1', '2', '3'] == '1,2,3'
true
```

如果两个操作数都是对象，则只有当它们是同一个对象时才相等：

```js
> [1, 2, 3] == ['1', '2', '3']
false
> [1, 2, 3] == [1, 2, 3]
false

> const arr = [1, 2, 3];
> arr == arr
true
```

最后，`==` 认为 `undefined` 和 `null` 是相等的：

```js
> undefined == null
true
```

#### 13.4.2 严格相等 (`===` 和 `!==`)

严格相等从不强制。只有当它们具有相同的类型时，两个值才相等。让我们重新审视我们与 `==` 运算符的先前交互，并看看 `===` 运算符的作用：

```js
> false === 0
false
> '123' === 123
false
```

只有当对象等于另一个值时，该对象才等于另一个值：

```js
> [1, 2, 3] === '1,2,3'
false
> ['1', '2', '3'] === '1,2,3'
false

> [1, 2, 3] === ['1', '2', '3']
false
> [1, 2, 3] === [1, 2, 3]
false

> const arr = [1, 2, 3];
> arr === arr
true
```

`===` 运算符不认为 `undefined` 和 `null` 是相等的：

```js
> undefined === null
false
```

#### 13.4.3 建议：始终使用严格相等

我建议始终使用 `===`。它使您的代码更易于理解，并避免了对 `==` 的怪癖进行思考。

让我们看看 `==` 的两个用例以及我建议做的替代方案。

##### 13.4.3.1 `==` 的用例：与数字或字符串比较

`==` 让你检查一个值 `x` 是否是一个数字或该数字的字符串 - 只需一次比较：

```js
if (x == 123) {
 // x is either 123 or '123'
}
```

我更喜欢以下两种替代方案之一：

```js
if (x === 123 || x === '123') ···
if (Number(x) === 123) ···
```

当您首次遇到 `x` 时，您也可以将其转换为数字。

##### 13.4.3.2 `==` 的用例：与 `undefined` 或 `null` 比较

`==` 的另一个用例是检查值 `x` 是否为 `undefined` 或 `null`：

```js
if (x == null) {
 // x is either null or undefined
}
```

这段代码的问题在于您无法确定某人是否打算以这种方式编写它，还是是否打错了字，打算使用 `=== null`。

我更喜欢以下两种替代方案之一：

```js
if (x === undefined || x === null) ···
if (!x) ···
```

第二种替代方案的缺点是它接受除 `undefined` 和 `null` 之外的值，但这是 JavaScript 中一个成熟的模式（将在 §15.3 “基于真值的存在性检查” 中详细解释）。

以下三个条件也大致等效：

```js
if (x != null) ···
if (x !== undefined && x !== null) ···
if (x) ···
```

#### 13.4.4 比 `===` 更严格：`Object.is()`

`Object.is()` 方法比较两个值：

```js
> Object.is(123, 123)
true
> Object.is(123, '123')
false
```

它甚至比 `===` 更严格。例如，它认为 `NaN`，涉及数字的计算的错误值，等于它自己：

```js
> Object.is(NaN, NaN)
true
> NaN === NaN
false
```

这偶尔是有用的。例如，您可以使用它来实现 `.indexOf()` 的改进版本：

```js
const myIndexOf = (arr, elem) => {
 return arr.findIndex(x => Object.is(x, elem));
};
```

`myIndexOf()` 在数组中查找 `NaN`，而 `.indexOf()` 不会：

```js
> myIndexOf([0,NaN,2], NaN)
1
> [0,NaN,2].indexOf(NaN)
-1
```

结果 `-1` 表示 `.indexOf()` 在数组中找不到其参数。

### 13.5 排序运算符

表 3：JavaScript 的排序运算符。

| 运算符 | 名称 |
| --- | --- |
| `<` | 小于 |
| `<=` | 小于或等于 |
| `>` | 大于 |
| `>=` | 大于或等于 |

JavaScript 的排序运算符（表 3）适用于数字和字符串：

```js
> 5 >= 2
true
> 'bar' < 'foo'
true
```

`<=` 和 `>=` 基于严格相等。

![](img/0ac255e56dc93a43365d8502301c8688.png)  **排序运算符在人类语言中效果不佳**

排序运算符在比较人类语言的文本时效果不佳，例如，当涉及大写或重音时。详细信息请参见§20.6 “比较字符串”。

### 13.6 其他各种运算符

本书的其他地方涵盖了以下运算符：

+   布尔值、数字、字符串、对象的运算符

+   空值合并运算符 (`??`) 用于默认值

接下来的两个小节讨论了两个很少使用的运算符。

#### 13.6.1 逗号运算符

逗号运算符有两个操作数，评估它们两个并返回第二个：

```js
> 'a', 'b'
'b'
```

有关此运算符的更多信息，请参见[*Speaking JavaScript*](http://speakingjs.com/es5/ch09.html#comma_operator)。

#### 13.6.2 `void` 运算符

`void` 运算符评估其操作数并返回 `undefined`：

```js
> void (3 + 2)
undefined
```

有关此运算符的更多信息，请参见[*Speaking JavaScript*](http://speakingjs.com/es5/ch09.html#void_operator)。

![](img/4ca05ad97a693bee61e4fd6459232e60.png)  **测验**

请参见测验应用。

[评论](https://github.com/rauschma/impatient-js/issues/8)
