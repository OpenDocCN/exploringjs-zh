["```ts\ntype _ = Type extends Constraint ? <then> : <else>;\n\n```", "```ts\nT[]\nPromise<T>\n(arg: T) => R\n\n```", "```ts\ntype ElemType<Arr> = Arr extends Array<infer Elem> ? Elem : never;\ntype _ = Assert<Equal<\n ElemType<Array<string>>, string\n>>;\n\n```", "```ts\nconst Color = {\n red: 0,\n green: 1,\n blue: 2,\n} as const;\n\ntype KeyOf<T> = T extends Record<infer K, any> ? K : never;\ntype _1 = Assert<Equal<\n KeyOf<typeof Color>,\n \"red\" | \"green\" | \"blue\"\n>>;\n\n```", "```ts\ntype PropValues<T> = T extends Record<any, infer V> ? V : never;\ntype _2 = Assert<Equal<\n PropValues<typeof Color>,\n 0 | 1 | 2\n>>;\n\n```", "```ts\ntype EnumFromTuple<T extends ReadonlyArray<string>> =\n T extends [\n infer First extends string, // (A)\n ...infer Rest extends ReadonlyArray<string> // (B)\n ]\n ? Record<First, First> & EnumFromTuple<Rest>\n : {}\n ;\ntype _ = [\n Assert<Equal< // (C)\n EnumFromTuple<['a', 'b']>,\n Record<'a', 'a'> & Record<'b', 'b'>\n >>,\n Assert<Equal< // (D)\n EnumFromTuple<['a', 'b']>,\n { a: 'a', b: 'b' }\n >>,\n];\n\n```", "```ts\n/**\n * Obtain the parameters of a function type in a tuple\n */\ntype Parameters<T extends (...args: any) => any> =\n T extends (...args: infer P) => any ? P : never;\n\n/**\n * Obtain the return type of a function type\n */\ntype ReturnType<T extends (...args: any) => any> =\n T extends (...args: any) => infer R ? R : any;\n\n```", "```ts\nfunction add(x: number, y: number): number {\n return x + y;\n}\ntype _1 = Assert<Equal<\n typeof add,\n (x: number, y: number) => number\n>>;\ntype _2 = Assert<Equal<\n Parameters<typeof add>,\n [x: number, y: number]\n>>;\ntype _3 = Assert<Equal<\n ReturnType<typeof add>,\n number\n>>;\n\n```", "```ts\ntype Class<T> = abstract new (...args: Array<any>) => T;\n\n```", "```ts\n/**\n * Obtain the parameters of a constructor function type in a tuple\n */\ntype ConstructorParameters<T extends abstract new (...args: any) => any> =\n T extends abstract new (...args: infer P) => any ? P : never;\n\n/**\n * Obtain the return type of a constructor function type\n */\ntype InstanceType<T extends abstract new (...args: any) => any> =\n T extends abstract new (...args: any) => infer R ? R : any;\n\n```", "```ts\nclass Point {\n x: number;\n y: number;\n constructor(x: number, y: number) {\n this.x = x;\n this.y = y;\n }\n}\n\n```", "```ts\nconst pointAsValue: Class<Point> = Point;\ntype _ = [\n Assert<Equal<\n ConstructorParameters<typeof Point>,\n [x: number, y: number]\n >>,\n Assert<Equal<\n InstanceType<typeof Point>,\n Point\n >>,\n];\n\n```", "```ts\ntype Syncify<Intf> = {\n [K in keyof Intf]:\n Intf[K] extends (...args: infer A) => Promise<infer R> // (A)\n ? (...args: A) => R // (B)\n : Intf[K] // (C)\n};\n\n```", "```ts\ninterface AsyncService {\n factorize(num: number): Promise<Array<number>>;\n createDigest(text: string): Promise<string>;\n}\ntype SyncService = Syncify<AsyncService>;\ntype _ = Assert<Equal<\n SyncService,\n {\n factorize: (num: number) => Array<number>,\n createDigest: (text: string) => string,\n }\n>>;\n\n```", "```ts\ntype WrapTriple<T> = Promise<T> extends infer W\n ? [W, W, W]\n : never\n;\ntype _ = Assert<Equal<\n WrapTriple<number>,\n [Promise<number>, Promise<number>, Promise<number>]\n>>;\n\n```"]