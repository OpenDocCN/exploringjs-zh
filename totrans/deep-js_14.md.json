["```js\nObject.preventExtensions<T>(obj: T): T\n```", "```js\nconst obj = { first: 'Jane' };\nObject.preventExtensions(obj);\nassert.throws(\n () => obj.last = 'Doe',\n /^TypeError: Cannot add property last, object is not extensible$/);\n```", "```js\nassert.deepEquals(\n Object.keys(obj), ['first']);\ndelete obj.first;\nassert.deepEquals(\n Object.keys(obj), []);\n```", "```js\nObject.isExtensible(obj: any): boolean\n```", "```js\n> const obj = {};\n> Object.isExtensible(obj)\ntrue\n> Object.preventExtensions(obj)\n{}\n> Object.isExtensible(obj)\nfalse\n```", "```js\nObject.seal<T>(obj: T): T\n```", "```js\nconst obj = {\n first: 'Jane',\n last: 'Doe',\n};\n\n// Before sealing\nassert.equal(Object.isExtensible(obj), true);\nassert.deepEqual(\n Object.getOwnPropertyDescriptors(obj),\n {\n first: {\n value: 'Jane',\n writable: true,\n enumerable: true,\n configurable: true\n },\n last: {\n value: 'Doe',\n writable: true,\n enumerable: true,\n configurable: true\n }\n });\n\nObject.seal(obj);\n\n// After sealing\nassert.equal(Object.isExtensible(obj), false);\nassert.deepEqual(\n Object.getOwnPropertyDescriptors(obj),\n {\n first: {\n value: 'Jane',\n writable: true,\n enumerable: true,\n configurable: false\n },\n last: {\n value: 'Doe',\n writable: true,\n enumerable: true,\n configurable: false\n }\n });\n```", "```js\nobj.first = 'John';\nassert.deepEqual(\n obj, {first: 'John', last: 'Doe'});\n```", "```js\nassert.throws(\n () => Object.defineProperty(obj, 'first', { enumerable: false }),\n /^TypeError: Cannot redefine property: first$/);\n```", "```js\nObject.isSealed(obj: any): boolean\n```", "```js\n> const obj = {};\n> Object.isSealed(obj)\nfalse\n> Object.seal(obj)\n{}\n> Object.isSealed(obj)\ntrue\n```", "```js\nObject.freeze<T>(obj: T): T;\n```", "```js\nconst point = { x: 17, y: -5 };\nObject.freeze(point);\n\nassert.throws(\n () => point.x = 2,\n /^TypeError: Cannot assign to read only property 'x'/);\n\nassert.throws(\n () => Object.defineProperty(point, 'x', {enumerable: false}),\n /^TypeError: Cannot redefine property: x$/);\n\nassert.throws(\n () => point.z = 4,\n /^TypeError: Cannot add property z, object is not extensible$/);\n```", "```js\nObject.isFrozen(obj: any): boolean\n```", "```js\n> const point = { x: 17, y: -5 };\n> Object.isFrozen(point)\nfalse\n> Object.freeze(point)\n{ x: 17, y: -5 }\n> Object.isFrozen(point)\ntrue\n```", "```js\nconst teacher = {\n name: 'Edna Krabappel',\n students: ['Bart'],\n};\nObject.freeze(teacher);\n\n// We can\u2019t change own properties:\nassert.throws(\n () => teacher.name = 'Elizabeth Hoover',\n /^TypeError: Cannot assign to read only property 'name'/);\n\n// Alas, we can still change values of own properties:\nteacher.students.push('Lisa');\nassert.deepEqual(\n teacher, {\n name: 'Edna Krabappel',\n students: ['Bart', 'Lisa'],\n });\n```", "```js\nfunction deepFreeze(value) {\n if (Array.isArray(value)) {\n for (const element of value) {\n deepFreeze(element);\n }\n Object.freeze(value);\n } else if (typeof value === 'object' && value !== null) {\n for (const v of Object.values(value)) {\n deepFreeze(v);\n }\n Object.freeze(value);\n } else {\n // Nothing to do: primitive values are already immutable\n } \n return value;\n}\n```", "```js\nconst teacher = {\n name: 'Edna Krabappel',\n students: ['Bart'],\n};\ndeepFreeze(teacher);\n\nassert.throws(\n () => teacher.students.push('Lisa'),\n /^TypeError: Cannot add property 1, object is not extensible$/);\n```"]