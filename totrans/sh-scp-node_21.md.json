["```js\nimport * as assert from 'node:assert/strict';\nimport {parseArgs} from 'node:util';\n```", "```js\n#!/usr/bin/env node\nconsole.log(process.argv);\n```", "```js\n% ./args.mjs one two\n[ '/usr/bin/node', '/home/john/args.mjs', 'one', 'two' ]\n```", "```js\n[\n 'C:\\\\Program Files\\\\nodejs\\\\node.exe',\n 'C:\\\\Users\\\\jane\\\\args.mjs',\n 'one',\n 'two'\n]\n```", "```js\n#!/usr/bin/env node\nconsole.log(process.argv.slice(2));\n```", "```js\n% ./args.mjs --str abc --bool home.html main.js\n[ '--str', 'abc', '--bool', 'home.html', 'main.js' ]\n```", "```js\nargsMjs('home.html', 'main.js', {str: 'abc', bool: false});\n```", "```js\nconst options = {\n 'verbose': {\n type: 'boolean',\n short: 'v',\n },\n 'color': {\n type: 'string',\n short: 'c',\n },\n 'times': {\n type: 'string',\n short: 't',\n },\n};\n```", "```js\ntype Options = {\n type: 'boolean' | 'string', // required\n short?: string, // optional\n multiple?: boolean, // optional, default `false`\n};\n```", "```js\nassert.deepEqual(\n parseArgs({options, args: [\n '--verbose', '--color', 'green', '--times', '5'\n ]}),\n {\n values: {__proto__:null,\n verbose: true,\n color: 'green',\n times: '5'\n },\n positionals: []\n }\n);\n```", "```js\ntype ParseArgsProps = {\n options?: {[key: string], Options}, // optional, default: {}\n args?: Array<string>, // optional\n // default: process.argv.slice(2)\n strict?: boolean, // optional, default `true`\n allowPositionals?: boolean, // optional, default `false`\n};\n```", "```js\ntype ParseArgsResult = {\n values: {[key: string]: ValuesValue}, // an object\n positionals: Array<string>, // always an Array\n};\ntype ValuesValue = boolean | string | Array<boolean|string>;\n```", "```js\nassert.deepEqual(\n parseArgs({options, args: ['-v', '-c', 'green']}),\n {\n values: {__proto__:null,\n verbose: true,\n color: 'green',\n },\n positionals: []\n }\n);\n```", "```js\nassert.deepEqual(\n parseArgs({\n options,\n allowPositionals: true,\n args: [\n 'home.html', '--verbose', 'main.js', '--color', 'red', 'post.md'\n ]\n }),\n {\n values: {__proto__:null,\n verbose: true,\n color: 'red',\n },\n positionals: [\n 'home.html', 'main.js', 'post.md'\n ]\n }\n);\n```", "```js\nconst options = {\n 'bool': {\n type: 'boolean',\n },\n 'str': {\n type: 'string',\n },\n};\n\nassert.deepEqual(\n parseArgs({\n options, args: [\n '--bool', '--bool', '--str', 'yes', '--str', 'no'\n ]\n }),\n {\n values: {__proto__:null,\n bool: true,\n str: 'no'\n },\n positionals: []\n }\n);\n```", "```js\nconst options = {\n 'bool': {\n type: 'boolean',\n multiple: true,\n },\n 'str': {\n type: 'string',\n multiple: true,\n },\n};\n\nassert.deepEqual(\n parseArgs({\n options, args: [\n '--bool', '--bool', '--str', 'yes', '--str', 'no'\n ]\n }),\n {\n values: {__proto__:null,\n bool: [ true, true ],\n str: [ 'yes', 'no' ]\n },\n positionals: []\n }\n);\n```", "```js\nconst options = {\n 'verbose': {\n type: 'boolean',\n short: 'v',\n },\n 'silent': {\n type: 'boolean',\n short: 's',\n },\n 'color': {\n type: 'string',\n short: 'c',\n },\n};\n```", "```js\nassert.deepEqual(\n parseArgs({options, args: ['-vs']}),\n {\n values: {__proto__:null,\n verbose: true,\n silent: true,\n },\n positionals: []\n }\n);\n```", "```js\nassert.deepEqual(\n parseArgs({options, args: ['--color=green']}),\n {\n values: {__proto__:null,\n color: 'green'\n },\n positionals: []\n }\n);\n```", "```js\n#!/usr/bin/env node\nconsole.log(process.argv.slice(2));\n```", "```js\n    % ./args.mjs \"say \\\"hi\\\"\" \"\\t\\n\" \"$USER\"\n    [ 'say \"hi\"', '\\\\t\\\\n', 'rauschma' ]\n    ```", "```js\n    % ./args.mjs 'back slash\\' '\\t\\n' '$USER' \n    [ 'back slash\\\\', '\\\\t\\\\n', '$USER' ]\n    ```", "```js\n% ./args.mjs --str \"two words\" --str 'two words'\n[ '--str', 'two words', '--str', 'two words' ]\n\n% ./args.mjs --str=\"two words\" --str='two words'\n[ '--str=two words', '--str=two words' ]\n\n% ./args.mjs -s \"two words\" -s 'two words'\n[ '-s', 'two words', '-s', 'two words' ]\n```", "```js\n>node args.mjs \"say \\\"hi\\\"\" \"\\t\\n\" \"%USERNAME%\"\n[ 'say \"hi\"', '\\\\t\\\\n', 'jane' ]\n\n>node args.mjs 'back slash\\' '\\t\\n' '%USERNAME%'\n[ \"'back\", \"slash\\\\'\", \"'\\\\t\\\\n'\", \"'jane'\" ]\n```", "```js\n>node args.mjs --str 'two words' --str \"two words\"\n[ '--str', \"'two\", \"words'\", '--str', 'two words' ]\n\n>node args.mjs --str='two words' --str=\"two words\"\n[ \"--str='two\", \"words'\", '--str=two words' ]\n\n>>node args.mjs -s \"two words\" -s 'two words'\n[ '-s', 'two words', '-s', \"'two\", \"words'\" ]\n```", "```js\n> node args.mjs \"say `\"hi`\"\" \"\\t\\n\" \"%USERNAME%\"\n[ 'say hi', '\\\\t\\\\n', '%USERNAME%' ]\n> node args.mjs 'backtick`' '\\t\\n' '%USERNAME%'\n[ 'backtick`', '\\\\t\\\\n', '%USERNAME%' ]\n```", "```js\nconst options = {\n 'times': {\n type: 'string',\n short: 't',\n },\n 'color': {\n type: 'string',\n short: 'c',\n },\n};\n\n// Quoted external option values\nassert.deepEqual(\n parseArgs({\n options,\n args: ['-t', '5 times', '--color', 'light green']\n }),\n {\n values: {__proto__:null,\n times: '5 times',\n color: 'light green',\n },\n positionals: []\n }\n);\n\n// Quoted inline option values\nassert.deepEqual(\n parseArgs({\n options,\n args: ['--color=light green']\n }),\n {\n values: {__proto__:null,\n color: 'light green',\n },\n positionals: []\n }\n);\n\n// Quoted positional values\nassert.deepEqual(\n parseArgs({\n options, allowPositionals: true,\n args: ['two words', 'more words']\n }),\n {\n values: {__proto__:null,\n },\n positionals: [ 'two words', 'more words' ]\n }\n);\n```", "```js\nconst options = {\n 'verbose': {\n type: 'boolean',\n },\n 'count': {\n type: 'string',\n },\n};\n\nassert.deepEqual(\n parseArgs({options, allowPositionals: true,\n args: [\n 'how', '--verbose', 'are', '--', '--count', '5', 'you'\n ]\n }),\n {\n values: {__proto__:null,\n verbose: true\n },\n positionals: [ 'how', 'are', '--count', '5', 'you' ]\n }\n);\n```", "```js\nconst options = {\n 'str': {\n type: 'string',\n },\n};\n\n// Unknown option name\nassert.throws(\n () => parseArgs({\n options,\n args: ['--unknown']\n }),\n {\n name: 'TypeError',\n message: \"Unknown option '--unknown'\",\n }\n);\n\n// Wrong option type (missing value)\nassert.throws(\n () => parseArgs({\n options,\n args: ['--str']\n }),\n {\n name: 'TypeError',\n message: \"Option '--str <value>' argument missing\",\n }\n);\n\n// Unallowed positional\nassert.throws(\n () => parseArgs({\n options,\n allowPositionals: false, // (the default)\n args: ['posarg']\n }),\n {\n name: 'TypeError',\n message: \"Unexpected argument 'posarg'. \" +\n \"This command does not take positional arguments\",\n }\n);\n```", "```js\ntype Token = OptionToken | PositionalToken | OptionTerminatorToken;\n\ninterface CommonTokenProperties {\n /** Where in `args` does the token start? */\n index: number;\n}\n\ninterface OptionToken extends CommonTokenProperties {\n kind: 'option';\n\n /** Long name of option */\n name: string;\n\n /** The option name as mentioned in `args` */\n rawName: string;\n\n /** The option\u2019s value. `undefined` for boolean options. */\n value: string | undefined;\n\n /** Is the option value specified inline (e.g. --level=5)? */\n inlineValue: boolean | undefined;\n}\n\ninterface PositionalToken extends CommonTokenProperties {\n kind: 'positional';\n\n /** The value of the positional, args[token.index] */\n value: string;\n}\n\ninterface OptionTerminatorToken extends CommonTokenProperties {\n kind: 'option-terminator';\n}\n```", "```js\nconst options = {\n 'bool': {\n type: 'boolean',\n short: 'b',\n },\n 'flag': {\n type: 'boolean',\n short: 'f',\n },\n 'str': {\n type: 'string',\n short: 's',\n },\n};\n```", "```js\nassert.deepEqual(\n parseArgs({\n options, tokens: true,\n args: [\n '--bool', '-b', '-bf',\n ]\n }),\n {\n values: {__proto__:null,\n bool: true,\n flag: true,\n },\n positionals: [],\n tokens: [\n {\n kind: 'option',\n name: 'bool',\n rawName: '--bool',\n index: 0,\n value: undefined,\n inlineValue: undefined\n },\n {\n kind: 'option',\n name: 'bool',\n rawName: '-b',\n index: 1,\n value: undefined,\n inlineValue: undefined\n },\n {\n kind: 'option',\n name: 'bool',\n rawName: '-b',\n index: 2,\n value: undefined,\n inlineValue: undefined\n },\n {\n kind: 'option',\n name: 'flag',\n rawName: '-f',\n index: 2,\n value: undefined,\n inlineValue: undefined\n },\n ]\n }\n);\n```", "```js\nassert.deepEqual(\n parseArgs({\n options, tokens: true,\n args: [\n '--str', 'yes', '--str=yes', '-s', 'yes',\n ]\n }),\n {\n values: {__proto__:null,\n str: 'yes',\n },\n positionals: [],\n tokens: [\n {\n kind: 'option',\n name: 'str',\n rawName: '--str',\n index: 0,\n value: 'yes',\n inlineValue: false\n },\n {\n kind: 'option',\n name: 'str',\n rawName: '--str',\n index: 2,\n value: 'yes',\n inlineValue: true\n },\n {\n kind: 'option',\n name: 'str',\n rawName: '-s',\n index: 3,\n value: 'yes',\n inlineValue: false\n }\n ]\n }\n);\n```", "```js\nassert.deepEqual(\n parseArgs({\n options, allowPositionals: true, tokens: true,\n args: [\n 'command', '--', '--str', 'yes', '--str=yes'\n ]\n }),\n {\n values: {__proto__:null,\n },\n positionals: [ 'command', '--str', 'yes', '--str=yes' ],\n tokens: [\n { kind: 'positional', index: 0, value: 'command' },\n { kind: 'option-terminator', index: 1 },\n { kind: 'positional', index: 2, value: '--str' },\n { kind: 'positional', index: 3, value: 'yes' },\n { kind: 'positional', index: 4, value: '--str=yes' }\n ]\n }\n);\n```", "```js\nfunction parseSubcommand(config) {\n // The subcommand is a positional, allow them\n const {tokens} = parseArgs({\n ...config, tokens: true, allowPositionals: true\n });\n let firstPosToken = tokens.find(({kind}) => kind==='positional');\n if (!firstPosToken) {\n throw new Error('Command name is missing: ' + config.args);\n }\n\n //----- Command options\n\n const cmdArgs = config.args.slice(0, firstPosToken.index);\n // Override `config.args`\n const commandResult = parseArgs({\n ...config, args: cmdArgs, tokens: false, allowPositionals: false\n });\n\n //----- Subcommand\n\n const subcommandName = firstPosToken.value;\n\n const subcmdArgs = config.args.slice(firstPosToken.index+1);\n // Override `config.args`\n const subcommandResult = parseArgs({\n ...config, args: subcmdArgs, tokens: false\n });\n\n return {\n commandResult,\n subcommandName,\n subcommandResult,\n };\n}\n```", "```js\nconst options = {\n 'log': {\n type: 'string',\n },\n color: {\n type: 'boolean',\n }\n};\nconst args = ['--log', 'all', 'print', '--color', 'file.txt'];\nconst result = parseSubcommand({options, allowPositionals: true, args});\n\nconst pn = obj => Object.setPrototypeOf(obj, null);\nassert.deepEqual(\n result,\n {\n commandResult: {\n values: pn({'log': 'all'}),\n positionals: []\n },\n subcommandName: 'print',\n subcommandResult: {\n values: pn({color: true}),\n positionals: ['file.txt']\n }\n }\n);\n```"]