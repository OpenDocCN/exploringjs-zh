- en: 14 Adding special values to types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/tackling-ts/ch_special-values.html](https://exploringjs.com/tackling-ts/ch_special-values.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 14.1 [Adding special values in band](ch_special-values.html#adding-special-values-in-band)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.1.1 [Adding `null` or `undefined` to a type](ch_special-values.html#adding-null-or-undefined-to-a-type)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.1.2 [Adding a symbol to a type](ch_special-values.html#adding-symbol-to-type)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.2 [Adding special values out of band](ch_special-values.html#adding-special-values-out-of-band)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.2.1 [Discriminated unions](ch_special-values.html#discriminated-unions)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.2.2 [Other kinds of union types](ch_special-values.html#other-kinds-of-union-types)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'One way of understanding types is as sets of values. Sometimes there are two
    levels of values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Base level: normal values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Meta level: special values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we examine how we can add special values to base-level types.
  prefs: []
  type: TYPE_NORMAL
- en: 14.1 Adding special values in band
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One way of adding special values is to create a new type which is a superset
    of the base type where some values are special. These special values are called
    [*sentinels*](https://en.wikipedia.org/wiki/Sentinel_value). They exist [*in band*](https://en.wikipedia.org/wiki/In-band_signaling)
    (think inside the same channel), as siblings of normal values.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the following interface for readable streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: At the moment, `.getNextLine()` only handles text lines, but not ends of files
    (EOFs). How could we add support for EOF?
  prefs: []
  type: TYPE_NORMAL
- en: 'Possibilities include:'
  prefs: []
  type: TYPE_NORMAL
- en: An additional method `.isEof()` that needs to be called before calling `.getNextLine()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.getNextLine()` throws an exception when it reaches an EOF.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sentinel value for EOF.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next two subsections describe two ways in which we can introduce sentinel
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 14.1.1 Adding `null` or `undefined` to a type
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When using strict TypeScript, no simple object type (defined via interfaces,
    object patterns, classes, etc.) includes `null`. That makes it a good sentinel
    value that we can add to the base type `string` via a union type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, whenever we are using the value returned by `.getNextLine()`, TypeScript
    forces us to consider both possibilities: strings and `null` – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In line A, we can’t use the string method `.startsWith()` because `line` might
    be `null`. We can fix this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, when execution reaches line A, we can be sure that `line` is not `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 14.1.2 Adding a symbol to a type
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can also use values other than `null` as sentinels. Symbols and objects are
    best suited for this task because each one of them has a unique identity and no
    other value can be mistaken for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how to use a symbol to represent EOF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Why do we need `typeof` and can’t use `EOF` directly? That’s because `EOF`
    is a value, not a type. The type operator `typeof` converts `EOF` to a type. For
    more information on the different language levels of values and types, see [§7.7
    “The two language levels: dynamic vs. static”](ch_typescript-essentials.html#language-levels).'
  prefs: []
  type: TYPE_NORMAL
- en: 14.2 Adding special values out of band
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What do we do if potentially *any* value can be returned by a method? How do
    we ensure that base values and meta values don’t get mixed up? This is an example
    where that might happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Whatever value we pick for `EOF`, there is a risk of someone creating an `InputStream<typeof
    EOF>` and adding that value to the stream.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to keep normal values and special values separate, so that they
    can’t be mixed up. Special values existing separately is called [*out of band*](https://en.wikipedia.org/wiki/Out-of-band_data)
    (think different channel).
  prefs: []
  type: TYPE_NORMAL
- en: 14.2.1 Discriminated unions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A [*discriminated union*](ch_enum-alternatives.html#discriminated-union) is
    a union type over several object types that all have at least one property in
    common, the so-called *discriminant*. The discriminant must have a different value
    for each object type – we can think of it as the ID of the object type.
  prefs: []
  type: TYPE_NORMAL
- en: '14.2.1.1 Example: `InputStreamValue`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the following example, `InputStreamValue<T>` is a discriminated union and
    its discriminant is `.type`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Initially, the type of `value` is `InputStreamValue<T>` (line A). Then we exclude
    the value `'eof'` for the discriminant `.type` and its type is narrowed to `NormalValue<T>`
    (line B). That’s why we can access property `.data` in line C.
  prefs: []
  type: TYPE_NORMAL
- en: '14.2.1.2 Example: `IteratorResult`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When deciding how to implement [iterators](https://exploringjs.com/impatient-js/ch_sync-iteration.html),
    TC39 didn’t want to use a fixed sentinel value. Otherwise, that value could appear
    in iterables and break code. One solution would have been to pick a sentinel value
    when starting an iteration. TC39 instead opted for a discriminated union with
    the common property `.done`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 14.2.2 Other kinds of union types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Other kinds of union types can be as convenient as discriminated unions, as
    long as we have the means to distinguish the member types of the union.
  prefs: []
  type: TYPE_NORMAL
- en: 'One possibility is to distinguish the member types via unique properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Another possibility is to distinguish the member types via `typeof` and/or
    instance checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[Comments](https://github.com/rauschma/tackling-ts/issues/14)'
  prefs: []
  type: TYPE_NORMAL
