- en: 16 The non-values undefined and null
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_undefined-null.html](https://exploringjs.com/js/book/ch_undefined-null.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[16.1 `undefined` vs. `null`](#undefined-vs-null)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[16.2 Occurrences of `undefined` and `null`](#occurrences-of-undefined-and-null)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[16.2.1 Occurrences of `undefined`](#occurrences-of-undefined)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[16.2.2 Occurrences of `null`](#occurrences-of-null)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[16.3 Checking for `undefined` or `null`](#checking-for-undefined-or-null)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[16.4 The nullish coalescing operator (`??`) for default values ^(ES2020)](#nullish-coalescing-operator)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[16.4.0.1 `??` is short-circuiting](#is-shortcircuiting)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[16.4.1 Example: counting matches](#example-counting-matches)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[16.4.2 Example: specifying a default value for a property](#example-specifying-a-default-value-for-a-property)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[16.4.3 Legacy approach: using logical Or (`||`) for default values](#legacy-approach-using-logical-or--for-default-values)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[16.4.4 The nullish coalescing assignment operator (`??=`) ^(ES2021)](#nullish-coalescing-assignment-operator)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[16.5 `undefined` and `null` don’t have properties](#undefined-null-no-properties)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[16.6 The history of `undefined` and `null`](#history-of-undefined-null)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Many programming languages have one “non-value” called `null`. It indicates
    that a variable does not currently point to an object – for example, when it hasn’t
    been initialized yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, JavaScript has two of them: `undefined` and `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[16.1 `undefined` vs. `null`](#undefined-vs-null)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both values are very similar and often used interchangeably. How they differ
    is therefore subtle. The language itself makes the following distinction:'
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined` means “not initialized” (e.g., a variable) or “not existing” (e.g.,
    a property of an object).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null` means “the intentional absence of any object value” (a quote from [the
    language specification](https://tc39.es/ecma262/#sec-null-value)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Programmers sometimes make the following distinction:'
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined` is the non-value used by the language (when something is uninitialized,
    etc.).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null` means “explicitly switched off”. That is, it helps implement a type
    that comprises both meaningful values and a meta-value that stands for “no meaningful
    value”. Such a type is called [*option type* or *maybe type*](https://en.wikipedia.org/wiki/Option_type)
    in functional programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[16.2 Occurrences of `undefined` and `null`](#occurrences-of-undefined-and-null)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following subsections describe where `undefined` and `null` appear in the
    language. We’ll encounter several mechanisms that are explained in more detail
    later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: '[16.2.1 Occurrences of `undefined`](#occurrences-of-undefined)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Uninitialized variable `myVar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameter `x` is not provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Property `.unknownProp` is missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don’t explicitly specify the result of a function via a `return` statement,
    JavaScript returns `undefined` for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[16.2.2 Occurrences of `null`](#occurrences-of-null)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The prototype of an object is either an object or, at the end of a chain of
    prototypes, `null`. `Object.prototype` does not have a prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we match a regular expression (such as `/a/`) against a string (such as
    `''x''`), we either get an object with matching data (if matching was successful)
    or `null` (if matching failed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The [JSON data format](ch_json.html#ch_json) does not support `undefined`,
    only `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[16.3 Checking for `undefined` or `null`](#checking-for-undefined-or-null)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Checking for either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Does `x` have a value?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Is `x` either `undefined` or `null`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Truthy* means “is `true` if coerced to boolean”. *Falsy* means “is `false`
    if coerced to boolean”. Both concepts are explained properly in [“Falsy and truthy
    values” (§17.2)](ch_booleans.html#falsiness-truthiness).'
  prefs: []
  type: TYPE_NORMAL
- en: '[16.4 The nullish coalescing operator (`??`) for default values ^(ES2020)](#nullish-coalescing-operator)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *nullish coalescing operator* (`??`) lets us use a default if a value is
    `undefined` or `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If `value` is `undefined` nor `null`, `defaultValue` is evaluated and the result
    is returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, `value` is returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[16.4.0.1 `??` is short-circuiting](#-is-shortcircuiting)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`??` is [short-circuiting](ch_booleans.html#short-circuiting) – the right-hand
    side is only evaluated if it is actually used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[16.4.1 Example: counting matches](#example-counting-matches)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following code shows a real-world example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If there are one or more matches for `regex` inside `str`, then `.match()` returns
    an Array. If there are no matches, it unfortunately returns `null` (and not the
    empty Array). We fix that via the `??` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also could have used [optional chaining](ch_objects.html#optional-chaining):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[16.4.2 Example: specifying a default value for a property](#example-specifying-a-default-value-for-a-property)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[16.4.3 Legacy approach: using logical Or (`||`) for default values](#legacy-approach-using-logical-or--for-default-values)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before ECMAScript 2020 and the nullish coalescing operator, logical Or was used
    for default values. That has a downside.
  prefs: []
  type: TYPE_NORMAL
- en: '`||` works as expected for `undefined` and `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'But it also returns the default for all other falsy values – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare that to how `??` works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[16.4.4 The nullish coalescing assignment operator (`??=`) ^(ES2021)](#nullish-coalescing-assignment-operator)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The nullish coalescing assignment operator (`??=`) assigns a default if a value
    is `undefined` or `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If `value` is either `undefined` or `null`, `defaultValue` is evaluated and
    assigned to `value`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, nothing happens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[16.4.4.1 `??=` is short-circuiting](#-is-shortcircuiting-1)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following two expressions are roughly equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'That means that `??=` is [short-circuiting](ch_booleans.html#short-circuiting)
    – the following two things only happen if `a` is `undefined` or `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`b` is evaluated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result is assigned to `a`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[16.4.4.2 Example: using `??=` to add missing properties](#example-using--to-add-missing-properties)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[16.5 `undefined` and `null` don’t have properties](#undefined-null-no-properties)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`undefined` and `null` are the only two JavaScript values where we get an exception
    if we try to read a property. To explore this phenomenon, let’s use the following
    function, which reads (“gets”) property `.prop` and returns the result.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we apply `getProp()` to various values, we can see that it only fails for
    `undefined` and `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[16.6 The history of `undefined` and `null`](#history-of-undefined-null)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Java (which inspired many aspects of JavaScript), initialization values
    depend on the static type of a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: Variables with object types are initialized with `null`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each primitive type has its own initialization value. For example, `int` variables
    are initialized with `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript borrowed `null` and uses it where objects are expected. It means
    “not an object”.
  prefs: []
  type: TYPE_NORMAL
- en: However, storage locations in JavaScript (variables, properties, etc.) can hold
    either primitive values or objects. They need an initialization value that means
    “neither an object nor a primitive value”. That’s why `undefined` was introduced.
  prefs: []
  type: TYPE_NORMAL
