["```ts\ninterface Array<T> {\n concat(...items: Array<T[] | T>): T[];\n reduce<U>(\n callback: (state: U, element: T, index: number, array: T[]) => U,\n firstState?: U\n ): U;\n // \u00b7\u00b7\u00b7\n}\n```", "```ts\nfunction toString(num: number): string {\n return String(num);\n}\n```", "```ts\n// %inferred-type: (num: number) => string\nfunction toString(num: number) {\n return String(num);\n}\n```", "```ts\n// @ts-expect-error: Parameter 'num' implicitly has an 'any' type. (7006)\nfunction toString(num) {\n return String(num);\n}\n```", "```ts\nconst undef: undefined = undefined;\n```", "```ts\ntype Age = number;\nconst age: Age = 82;\n```", "```ts\nlet arr1: number[] = [];\nlet arr2: Array<number> = [];\n```", "```ts\nlet point: [number, number] = [7, 5];\n```", "```ts\n// %inferred-type: number[]\nlet point = [7, 5];\n```", "```ts\n// %inferred-type: [string, number][]\nconst entries = Object.entries({ a: 1, b: 2 });\n\nassert.deepEqual(\n entries,\n [[ 'a', 1 ], [ 'b', 2 ]]);\n```", "```ts\n(num: number) => string\n```", "```ts\nconst toString: (num: number) => string = // (A)\n (num: number) => String(num); // (B)\n```", "```ts\nconst toString: (num: number) => string =\n (num) => String(num);\n```", "```ts\n// %inferred-type: (num: number) => string\nconst toString = (num: number) => String(num);\n```", "```ts\nfunction stringify123(callback: (num: number) => string) {\n return callback(123);\n}\n```", "```ts\n// @ts-expect-error: Argument of type 'NumberConstructor' is not\n// assignable to parameter of type '(num: number) => string'.\n//   Type 'number' is not assignable to type 'string'.(2345)\nstringify123(Number);\n```", "```ts\nassert.equal(\n stringify123(String), '123');\n```", "```ts\nfunction stringify123(callback: (num: number) => string): string {\n return callback(123);\n}\n```", "```ts\nfunction f1(): void {\n return undefined;\n}\n```", "```ts\nfunction f2(): void {}\n```", "```ts\nfunction f3(): void {\n // @ts-expect-error: Type '\"abc\"' is not assignable to type 'void'. (2322)\n return 'abc';\n}\n```", "```ts\nfunction stringify123(callback?: (num: number) => string) {\n if (callback === undefined) {\n callback = String;\n }\n return callback(123); // (A)\n}\n```", "```ts\nfunction createPoint(x=0, y=0): [number, number] {\n return [x, y];\n}\n\nassert.deepEqual(\n createPoint(),\n [0, 0]);\nassert.deepEqual(\n createPoint(1, 2),\n [1, 2]);\n```", "```ts\nfunction createPoint(x:number = 0, y:number = 0): [number, number] {\n return [x, y];\n}\n```", "```ts\nfunction joinNumbers(...nums: number[]): string {\n return nums.join('-');\n}\nassert.equal(\n joinNumbers(1, 2, 3),\n '1-2-3');\n```", "```ts\nfunction getScore(stringOrNumber: string|number): number {\n if (typeof stringOrNumber === 'string'\n && /^\\*{1,5}$/.test(stringOrNumber)) {\n return stringOrNumber.length;\n } else if (typeof stringOrNumber === 'number'\n && stringOrNumber >= 1 && stringOrNumber <= 5) {\n return stringOrNumber\n } else {\n throw new Error('Illegal value: ' + JSON.stringify(stringOrNumber));\n }\n}\n\nassert.equal(getScore('*****'), 5);\nassert.equal(getScore(3), 3);\n```", "```ts\nlet maybeNumber: null|number = null;\nmaybeNumber = 123;\n```", "```ts\n// @ts-expect-error: Type 'null' is not assignable to type 'number'. (2322)\nlet maybeNumber: number = null;\nmaybeNumber = 123;\n```", "```ts\nlet myNumber: number; // OK\nmyNumber = 123;\n```", "```ts\nfunction stringify123(callback?: (num: number) => string) {\n if (callback === undefined) {\n callback = String;\n }\n return callback(123); // (A)\n}\n```", "```ts\nfunction stringify123(\n callback: null | ((num: number) => string)) {\n const num = 123;\n if (callback === null) { // (A)\n callback = String;\n }\n return callback(num); // (B)\n}\n\nassert.equal(\n stringify123(null),\n '123');\n\n// @ts-expect-error: Expected 1 arguments, but got 0\\. (2554)\nassert.throws(() => stringify123());\n```", "```ts\nfunction f1(x?: number) { return x }\n\nassert.equal(f1(123), 123); // OK\nassert.equal(f1(undefined), undefined); // OK\nassert.equal(f1(), undefined); // can omit\n```", "```ts\nfunction f2(x = 456) { return x }\n\nassert.equal(f2(123), 123); // OK\nassert.equal(f2(undefined), 456); // OK\nassert.equal(f2(), 456); // can omit\n```", "```ts\nfunction f3(x: undefined | number) { return x }\n\nassert.equal(f3(123), 123); // OK\nassert.equal(f3(undefined), undefined); // OK\n\n// @ts-expect-error: Expected 1 arguments, but got 0\\. (2554)\nf3(); // can\u2019t omit\n```", "```ts\ninterface Point {\n x: number;\n y: number;\n}\n```", "```ts\ninterface Point {\n x: number,\n y: number,\n}\n```", "```ts\ninterface Point {\n x: number;\n y: number;\n}\nfunction pointToString(pt: Point) {\n return `(${pt.x}, ${pt.y})`;\n}\n\nassert.equal(\n pointToString({x: 5, y: 7}), // compatible structure\n '(5, 7)');\n```", "```ts\ntype Point = {\n x: number;\n y: number;\n};\n```", "```ts\nfunction pointToString(pt: {x: number, y: number}) {\n return `(${pt.x}, ${pt.y})`;\n}\n```", "```ts\ninterface Person {\n name: string;\n company?: string;\n}\n```", "```ts\nconst john: Person = {\n name: 'John',\n};\nconst jane: Person = {\n name: 'Jane',\n company: 'Massive Dynamic',\n};\n```", "```ts\ninterface Point {\n x: number;\n y: number;\n distance(other: Point): number;\n}\n```", "```ts\ninterface HasMethodDef {\n simpleMethod(flag: boolean): void;\n}\ninterface HasFuncProp {\n simpleMethod: (flag: boolean) => void;\n}\n\nconst objWithMethod: HasMethodDef = {\n simpleMethod(flag: boolean): void {},\n};\nconst objWithMethod2: HasFuncProp = objWithMethod;\n\nconst objWithOrdinaryFunction: HasMethodDef = {\n simpleMethod: function (flag: boolean): void {},\n};\nconst objWithOrdinaryFunction2: HasFuncProp = objWithOrdinaryFunction;\n\nconst objWithArrowFunction: HasMethodDef = {\n simpleMethod: (flag: boolean): void => {},\n};\nconst objWithArrowFunction2: HasFuncProp = objWithArrowFunction;\n```", "```ts\n    const valueFactory = (x: number) => x; // definition\n    const myValue = valueFactory(123); // use\n    ```", "```ts\n    type TypeFactory<X> = X; // definition\n    type MyType = TypeFactory<string>; // use\n    ```", "```ts\n// Factory for types\ninterface ValueContainer<Value> {\n value: Value;\n}\n\n// Creating one type\ntype StringContainer = ValueContainer<string>;\n```", "```ts\nclass SimpleStack<Elem> {\n #data: Array<Elem> = [];\n push(x: Elem): void {\n this.#data.push(x);\n }\n pop(): Elem {\n const result = this.#data.pop();\n if (result === undefined) {\n throw new Error();\n }\n return result;\n }\n get length() {\n return this.#data.length;\n }\n}\n```", "```ts\nconst stringStack = new SimpleStack<string>();\nstringStack.push('first');\nstringStack.push('second');\nassert.equal(stringStack.length, 2);\nassert.equal(stringStack.pop(), 'second');\n```", "```ts\nconst myMap: Map<boolean,string> = new Map([\n [false, 'no'],\n [true, 'yes'],\n]);\n```", "```ts\n// %inferred-type: Map<boolean, string>\nconst myMap = new Map([\n [false, 'no'],\n [true, 'yes'],\n]);\n```", "```ts\nfunction identity<Arg>(arg: Arg): Arg {\n return arg;\n}\n```", "```ts\n// %inferred-type: number\nconst num1 = identity<number>(123);\n```", "```ts\n// %inferred-type: 123\nconst num2 = identity(123);\n```", "```ts\nconst identity = <Arg>(arg: Arg): Arg => arg;\n```", "```ts\nconst obj = {\n identity<Arg>(arg: Arg): Arg {\n return arg;\n },\n};\n```", "```ts\nfunction fillArray<T>(len: number, elem: T): T[] {\n return new Array<T>(len).fill(elem);\n}\n```", "```ts\n// %inferred-type: string[]\nconst arr1 = fillArray<string>(3, '*');\nassert.deepEqual(\n arr1, ['*', '*', '*']);\n\n// %inferred-type: string[]\nconst arr2 = fillArray(3, '*'); // (A)\n```", "```ts\ninterface Array<T> {\n concat(...items: Array<T[] | T>): T[];\n reduce<U>(\n callback: (state: U, element: T, index: number, array: T[]) => U,\n firstState?: U\n ): U;\n // \u00b7\u00b7\u00b7\n}\n```"]