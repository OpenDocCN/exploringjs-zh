<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>41 A roadmap for asynchronous programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>41 A roadmap for asynchronous programming</h1>
<blockquote>原文：<a href="https://exploringjs.com/js/book/ch_async-roadmap.html">https://exploringjs.com/js/book/ch_async-roadmap.html</a></blockquote>

        
    
    
    
<p><span id="index-entry-asynchronous-programming"/></p>
<nav class="local-toc">
  <ol>
    <li>
      <a href="#the-next-chapters">41.1 The next chapters</a>
    </li>
    <li>
      <a href="#synchronous-functions">41.2 Synchronous functions</a>
    </li>
    <li>
      <a href="#javascript-executes-tasks-sequentially-in-a-single-process">41.3 JavaScript executes tasks sequentially in a single process</a>
    </li>
    <li>
      <a href="#roadmap-callbacks-for-async">41.4 Callback-based asynchronous functions</a>
    </li>
    <li>
      <a href="#promisebased-asynchronous-functions">41.5 Promise-based asynchronous functions</a>
    </li>
    <li>
      <a href="#roadmap-async-functions">41.6 Async functions</a>
    </li>
  </ol>
</nav>
<p>This chapter is a brief roadmap for asynchronous programming.</p>
<h3 id="the-next-chapters"><a class="heading-id-link" href="#the-next-chapters">41.1 The next chapters</a></h3>
<p>The next chapters explain asynchronous programming in JavaScript:</p>
<ul>
  <li>
    <a href="ch_async-js.html#ch_async-js">“Foundations of asynchronous programming in JavaScript” (§42)</a>:
    <ul>
      <li>
        We’ll see how synchronous function calls work.
      </li>
      <li>
        We’ll also explore JavaScript’s way of executing code in a single process, via its <em>event loop</em>.
      </li>
      <li>
        <a href="ch_async-js.html#callback-pattern">Asynchronicity via callbacks</a> is also described in that chapter.
      </li>
    </ul>
  </li>
  <li>
    <a href="ch_promises.html#ch_promises">“Promises for asynchronous programming<span> <sup>ES6</sup></span>” (§43)</a>
  </li>
  <li>
    <a href="ch_async-functions.html#ch_async-functions">“Async functions<span> <sup>ES2017</sup></span>” (§44)</a>
  </li>
  <li>
    <a href="ch_async-iteration.html#ch_async-iteration">“Asynchronous iteration<span> <sup>ES2018</sup></span>” (§45)</a> concludes this series of chapters on asynchronous programming. Asynchronous iteration is similar to <a href="ch_sync-iteration.html#ch_sync-iteration">synchronous iteration</a>, but iterated values are delivered asynchronously.
  </li>
</ul>
<p>The remainder of this chapter gives you some first ideas of what all of that means.</p>
<div class="boxout">
  <p><img src="../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png" class="boxout-icon" height="24" alt="Icon “reading”" data-original-src="https://exploringjs.com/js/book/icon/reading.svg"/> <strong>Don’t worry about the details!</strong></p>
  <div class="boxout-vspace"/>
  <p>Don’t worry if you don’t understand everything yet. This is just a quick peek at what’s coming up. Everything is explained in much more detail in the next chapters.</p>
</div>
<h3 id="synchronous-functions"><a class="heading-id-link" href="#synchronous-functions">41.2 Synchronous functions</a></h3>
<p>Normal functions are <em>synchronous</em>: the caller waits until the callee is finished with its computation. <code>divideSync()</code> in line A is a synchronous function call:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-keyword">try</span> {</span>
<span class="hljs-params">    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">divideSync</span>(<span class="hljs-number">12</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// (A)</span></span>
<span class="hljs-params">    assert.<span class="hljs-title function_">equal</span>(result, <span class="hljs-number">4</span>);</span>
<span class="hljs-params">  } <span class="hljs-keyword">catch</span> (err) {</span>
<span class="hljs-params">    assert.<span class="hljs-title function_">fail</span>(err);</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
</pre>
<h3 id="javascript-executes-tasks-sequentially-in-a-single-process"><a class="heading-id-link" href="#javascript-executes-tasks-sequentially-in-a-single-process">41.3 JavaScript executes tasks sequentially in a single process</a></h3>
<p>By default, JavaScript <em>tasks</em> are functions that are executed sequentially in a single process. That looks like this:</p>
<pre class="language-js">
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">const</span> task = taskQueue.<span class="hljs-title function_">dequeue</span>();
  <span class="hljs-title function_">task</span>(); <span class="hljs-comment">// run task</span>
}
</pre>
<p>This loop is also called the <em>event loop</em> because events, such as clicking a mouse, add tasks to the queue.</p>
<p>Due to this style of cooperative multitasking, we don’t want a task to block other tasks from being executed while, for example, it waits for results coming from a server. <span refcheck="#roadmap-callbacks-for-async">The next subsection</span> explores how to handle this case.</p>
<h3 id="roadmap-callbacks-for-async"><a class="heading-id-link" href="#roadmap-callbacks-for-async">41.4 Callback-based asynchronous functions</a></h3>
<p>What if <code>divide()</code> needs a server to compute its result? Then the result should be delivered in a different manner: The caller shouldn’t have to wait (synchronously) until the result is ready; it should be notified (asynchronously) when it is. One way of delivering the result asynchronously is by giving <code>divide()</code> a callback function that it uses to notify the caller.</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-title function_">divideCallback</span>(<span class="hljs-number">12</span>, <span class="hljs-number">3</span>,</span>
<span class="hljs-params">    <span class="hljs-function">(<span class="hljs-params">err, result</span>) =&gt;</span> {</span>
<span class="hljs-params">      <span class="hljs-keyword">if</span> (err) {</span>
<span class="hljs-params">        assert.<span class="hljs-title function_">fail</span>(err);</span>
<span class="hljs-params">      } <span class="hljs-keyword">else</span> {</span>
<span class="hljs-params">        assert.<span class="hljs-title function_">equal</span>(result, <span class="hljs-number">4</span>);</span>
<span class="hljs-params">      }</span>
<span class="hljs-params">    });</span>
<span class="hljs-params">}</span>
</pre>
<p>When there is an asynchronous function call:</p>
<pre class="language-js">
<span class="hljs-title function_">divideCallback</span>(x, y, callback)
</pre>
<p>Then the following steps happen:</p>
<ul>
  <li>
    <code>divideCallback()</code> sends a request to a server.
  </li>
  <li>
    Then the current task <code>main()</code> is finished and other tasks can be executed.
  </li>
  <li>
    When a response from the server arrives, it is either:
    <ul>
      <li>
        <p>An error <code>err</code>: Then the following task is added to the queue.</p>
<pre class="language-js">
taskQueue.<span class="hljs-title function_">enqueue</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">callback</span>(err));
</pre>
      </li>
      <li>
        <p>A <code>result</code> value: Then the following task is added to the queue.</p>
<pre class="language-js">
taskQueue.<span class="hljs-title function_">enqueue</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, result));
</pre>
      </li>
    </ul>
  </li>
</ul>
<h3 id="promisebased-asynchronous-functions"><a class="heading-id-link" href="#promisebased-asynchronous-functions">41.5 Promise-based asynchronous functions</a></h3>
<p>Promises are two things:</p>
<ul>
  <li>
    A standard pattern that makes working with callbacks easier.
  </li>
  <li>
    The mechanism on which <em>async functions</em> (the topic of <span refcheck="#roadmap-async-functions">the next subsection</span>) are built.
  </li>
</ul>
<p>Invoking a Promise-based function looks as follows.</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-title function_">dividePromise</span>(<span class="hljs-number">12</span>, <span class="hljs-number">3</span>)</span>
<span class="hljs-params">    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> assert.<span class="hljs-title function_">equal</span>(result, <span class="hljs-number">4</span>))</span>
<span class="hljs-params">    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> assert.<span class="hljs-title function_">fail</span>(err));</span>
<span class="hljs-params">}</span>
</pre>
<h3 id="roadmap-async-functions"><a class="heading-id-link" href="#roadmap-async-functions">41.6 Async functions</a></h3>
<p>One way of looking at async functions is as better syntax for Promise-based code:</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-keyword">try</span> {</span>
<span class="hljs-params">    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">dividePromise</span>(<span class="hljs-number">12</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// (A)</span></span>
<span class="hljs-params">    assert.<span class="hljs-title function_">equal</span>(result, <span class="hljs-number">4</span>);</span>
<span class="hljs-params">  } <span class="hljs-keyword">catch</span> (err) {</span>
<span class="hljs-params">    assert.<span class="hljs-title function_">fail</span>(err);</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
</pre>
<p>The <code>dividePromise()</code> we are calling in line A is the same Promise-based function as in the previous section. But we now have synchronous-looking syntax for handling the call. <code>await</code> can only be used inside a special kind of function, an <em>async function</em> (note the keyword <code>async</code> in front of the keyword <code>function</code>). <code>await</code> pauses the current async function and returns from it. Once the awaited result is ready, the execution of the function continues where it left off.</p>

    
      
</body>
</html>