["```ts\nclass OtherClass {}\n\nclass MyClass1 extends OtherClass {\n\n publicInstanceField = 1;\n\n constructor() {\n super();\n }\n\n publicPrototypeMethod() {\n return 2;\n }\n}\n\nconst inst1 = new MyClass1();\nassert.equal(inst1.publicInstanceField, 1);\nassert.equal(inst1.publicPrototypeMethod(), 2);\n```", "```ts\nclass MyClass2 {\n\n static staticPublicField = 1;\n\n static staticPublicMethod() {\n return 2;\n }\n}\n\nassert.equal(MyClass2.staticPublicField, 1);\nassert.equal(MyClass2.staticPublicMethod(), 2);\n```", "```ts\nclass MyClass3 {\n #privateField = 1;\n\n #privateMethod() {\n return 2;\n }\n\n static accessPrivateMembers() {\n // Private members can only be accessed from inside class definitions\n const inst3 = new MyClass3();\n assert.equal(inst3.#privateField, 1);\n assert.equal(inst3.#privateMethod(), 2);\n }\n}\nMyClass3.accessPrivateMembers();\n```", "```ts\nclass MyClass5 {\n #name = 'Rumpelstiltskin';\n\n /** Prototype getter */\n get name() {\n return this.#name;\n }\n\n /** Prototype setter */\n set name(value) {\n this.#name = value;\n }\n}\nconst inst5 = new MyClass5();\nassert.equal(inst5.name, 'Rumpelstiltskin'); // getter\ninst5.name = 'Queen'; // setter\nassert.equal(inst5.name, 'Queen'); // getter\n```", "```ts\nclass MyClass6 {\n * publicPrototypeGeneratorMethod() {\n yield 'hello';\n yield 'world';\n }\n}\n\nconst inst6 = new MyClass6();\nassert.deepEqual(\n [...inst6.publicPrototypeGeneratorMethod()],\n ['hello', 'world']);\n```", "```ts\nclass MyClass7 {\n async publicPrototypeAsyncMethod() {\n const result = await Promise.resolve('abc');\n return result + result;\n }\n}\n\nconst inst7 = new MyClass7();\ninst7.publicPrototypeAsyncMethod()\n .then(result => assert.equal(result, 'abcabc'));\n```", "```ts\nconst publicInstanceFieldKey = Symbol('publicInstanceFieldKey');\nconst publicPrototypeMethodKey = Symbol('publicPrototypeMethodKey');\n\nclass MyClass8 {\n\n [publicInstanceFieldKey] = 1;\n\n [publicPrototypeMethodKey]() {\n return 2;\n }\n}\n\nconst inst8 = new MyClass8();\nassert.equal(inst8[publicInstanceFieldKey], 1);\nassert.equal(inst8[publicPrototypeMethodKey](), 2);\n```", "```ts\nclass ClassA {\n static staticMthdA() {}\n constructor(instPropA) {\n this.instPropA = instPropA;\n }\n prototypeMthdA() {}\n}\nclass ClassB extends ClassA {\n static staticMthdB() {}\n constructor(instPropA, instPropB) {\n super(instPropA);\n this.instPropB = instPropB;\n }\n prototypeMthdB() {}\n}\nconst instB = new ClassB(0, 1);\n```", "```ts\nclass PersonPrivateProperty {\n private name: string; // (A)\n constructor(name: string) {\n this.name = name;\n }\n sayHello() {\n return `Hello ${this.name}!`;\n }\n}\n```", "```ts\nconst john = new PersonPrivateProperty('John');\n\nassert.equal(\n john.sayHello(), 'Hello John!');\n\n// @ts-expect-error: Property 'name' is private and only accessible\n// within class 'PersonPrivateProperty'. (2341)\njohn.name; // (A)\n```", "```ts\nassert.deepEqual(\n Object.keys(john),\n ['name']);\n```", "```ts\nclass PersonPrivateProperty {\n constructor(name) {\n this.name = name;\n }\n sayHello() {\n return `Hello ${this.name}!`;\n }\n}\n```", "```ts\nclass PersonPrivateField {\n #name: string;\n constructor(name: string) {\n this.#name = name;\n }\n sayHello() {\n return `Hello ${this.#name}!`;\n }\n}\n```", "```ts\nconst john = new PersonPrivateField('John');\n\nassert.equal(\n john.sayHello(), 'Hello John!');\n```", "```ts\nassert.throws(\n () => eval('john.#name'), // (A)\n {\n name: 'SyntaxError',\n message: \"Private field '#name' must be declared in \"\n + \"an enclosing class\",\n });\n\nassert.deepEqual(\n Object.keys(john),\n []);\n```", "```ts\nvar __classPrivateFieldSet = function (receiver, privateMap, value) {\n if (!privateMap.has(receiver)) {\n throw new TypeError(\n 'attempted to set private field on non-instance');\n }\n privateMap.set(receiver, value);\n return value;\n};\n\n// Omitted: __classPrivateFieldGet\n\nvar _name = new WeakMap();\nclass Person {\n constructor(name) {\n // Add an entry for this instance to _name\n _name.set(this, void 0);\n\n // Now we can use the helper function:\n __classPrivateFieldSet(this, _name, name);\n }\n // \u00b7\u00b7\u00b7\n}\n```", "```ts\nclass PrivatePerson {\n private name: string;\n constructor(name: string) {\n this.name = name;\n }\n sayHello() {\n return `Hello ${this.name}!`;\n }\n}\nclass PrivateEmployee extends PrivatePerson {\n private company: string;\n constructor(name: string, company: string) {\n super(name);\n this.company = company;\n }\n sayHello() {\n // @ts-expect-error: Property 'name' is private and only\n // accessible within class 'PrivatePerson'. (2341)\n return `Hello ${this.name} from ${this.company}!`; // (A)\n } \n}\n```", "```ts\nclass ProtectedPerson {\n protected name: string; // (A)\n constructor(name: string) {\n this.name = name;\n }\n sayHello() {\n return `Hello ${this.name}!`;\n }\n}\nclass ProtectedEmployee extends ProtectedPerson {\n protected company: string; // (B)\n constructor(name: string, company: string) {\n super(name);\n this.company = company;\n }\n sayHello() {\n return `Hello ${this.name} from ${this.company}!`; // OK\n } \n}\n```", "```ts\nclass DataContainer {\n #data: string;\n static async create() {\n const data = await Promise.resolve('downloaded'); // (A)\n return new this(data);\n }\n private constructor(data: string) {\n this.#data = data;\n }\n getData() {\n return 'DATA: '+this.#data;\n }\n}\nDataContainer.create()\n .then(dc => assert.equal(\n dc.getData(), 'DATA: downloaded'));\n```", "```ts\n    class Point {\n     x: number;\n     y: number;\n     constructor(x: number, y: number) {\n     this.x = x;\n     this.y = y;\n     }\n    }\n    ```", "```ts\n    class Point {\n     x = 0;\n     y = 0;\n\n     // No constructor needed\n    }\n    ```", "```ts\nclass Point {\n x!: number; // (A)\n y!: number; // (B)\n constructor() {\n this.initProperties();\n }\n initProperties() {\n this.x = 0;\n this.y = 0;\n }\n}\n```", "```ts\nclass CompilerError implements CompilerErrorProps { // (A)\n line!: number;\n description!: string;\n constructor(props: CompilerErrorProps) {\n Object.assign(this, props); // (B)\n }\n}\n\n// Helper interface for the parameter properties\ninterface CompilerErrorProps {\n line: number,\n description: string,\n}\n\n// Using the class:\nconst err = new CompilerError({\n line: 123,\n description: 'Unexpected token',\n});\n```", "```ts\nclass Point1 {\n constructor(public x: number, public y: number) {\n }\n}\n\nclass Point2 {\n x: number;\n y: number;\n constructor(x: number, y: number) {\n this.x = x;\n this.y = y;\n }\n}\n```", "```ts\nclass StringBuilder {\n string = '';\n add(str: string) {\n this.string += str;\n }\n}\nabstract class Printable {\n toString() {\n const out = new StringBuilder();\n this.print(out);\n return out.string;\n }\n abstract print(out: StringBuilder): void;\n}\n```", "```ts\nclass Entries extends Printable {\n entries: Entry[];\n constructor(entries: Entry[]) {\n super();\n this.entries = entries;\n }\n print(out: StringBuilder): void {\n for (const entry of this.entries) {\n entry.print(out);\n }\n }\n}\nclass Entry extends Printable {\n key: string;\n value: string;\n constructor(key: string, value: string) {\n super();\n this.key = key;\n this.value = value;\n }\n print(out: StringBuilder): void {\n out.add(this.key);\n out.add(': ');\n out.add(this.value);\n out.add('\\n');\n }\n}\n```", "```ts\nconst entries = new Entries([\n new Entry('accept-ranges', 'bytes'),\n new Entry('content-length', '6518'),\n]);\nassert.equal(\n entries.toString(),\n 'accept-ranges: bytes\\ncontent-length: 6518\\n');\n```"]