["```js\n123.45 // floating point number literal\n98 // integer literal\n\n```", "```js\n> 98 === 98.0\ntrue\n\n```", "```js\n// Binary (base 2)\nassert.equal(0b11, 3); // ES6\n `// Octal (base 8)`\n`assert.equal(0o10, 8); // ES6`\n ```", "```js \n```", "```js```", "````js````", "```js```", "```js```", "````js````", "```js```", "``` > 35.0 35  ```", "``` > 3e2 300 > 3e-2 0.03 > 0.3e2 30  ```", "``` 7.toString(); // SyntaxError  ```", "``` (7).toString(2) 7.0.toString(2) 7..toString(2) 7 .toString(2)  // space before dot  ```", "``` > 0b11.toString() '3' > 0o11.toString() '9' > 0x11.toString() '17'  ```", "``` const inhabitantsOfLondon = 1_335_000; const distanceEarthSunInKm = 149_600_000;  ```", "``` const fileSystemPermission = 0b111_111_000; const bytes = 0b1111_10101011_11110000_00001101; const words = 0xFAB_F00D;  ```", "``` const massOfElectronInKg = 9.109_383_56e-31; const trillionInShortScale = 1e1_2;  ```", "```     3_.141     3._141      `1_e12`     `1e_12`      ```", "```      ```", "````` ```js` *   We can’t use more than one underscore in a row:                    ```     123__456 // two underscores – not allowed          ```js ```` ```js``    `````", "```````js`````` ```js```````", "```````js` The motivation behind these restrictions is to keep parsing simple and to avoid strange edge cases.    ##### [18.2.4.2 Parsing numbers with separators](#parsing-numbers-with-separators)    The following functions for parsing numbers do not support separators:    *   `Number()` *   `Number.parseInt()` *   `Number.parseFloat()`    For example:    ``` > Number('123_456') NaN > Number.parseInt('123_456') 123  ```js    The rationale is that numeric separators are for code. Other kinds of input should be processed differently.    ### [18.3 Arithmetic operators](#arithmetic-operators)    #### [18.3.1 Binary arithmetic operators](#binary-arithmetic-operators)    [Table 18.1](#tbl:binary-arithmetic-operators) lists JavaScript’s binary arithmetic operators.     | Operator | Name |  | Example | | --- | --- | --- | --- | | `n + m` | Addition | ES1 | `3 + 4` → `7` | | `n - m` | Subtraction | ES1 | `9 - 1` → `8` | | `n * m` | Multiplication | ES1 | `3 * 2.25` → `6.75` | | `n / m` | Division | ES1 | `5.625 / 5` → `1.125` | | `n % m` | Remainder | ES1 | `8 % 5` → `3` | |  |  |  | `-8 % 5` → `-3` | | `n ** m` | Exponentiation | ES2016 | `4 ** 2` → `16` |      Table 18.1: Binary arithmetic operators.      ##### [18.3.1.1 `%` is a remainder operator](#-is-a-remainder-operator)    `%` is a remainder operator, not a modulo operator. Its result has the sign of the first operand:    ``` > 5 % 3 2 > -5 % 3 -2  ```js    For more information on the difference between remainder and modulo, see the blog post [“Remainder operator vs. modulo operator (with JavaScript code)”](https://2ality.com/2019/08/remainder-vs-modulo.html) on 2ality.    #### [18.3.2 Unary plus (`+`) and negation (`-`)](#unary-plus--and-negation-)    [Table 18.2](#tbl:unary-plus-negation) summarizes the two operators *unary plus* (`+`) and *negation* (`-`).     | Operator | Name |  | Example | | --- | --- | --- | --- | | `+n` | Unary plus | ES1 | `+(-7)` → `-7` | | `-n` | Unary negation | ES1 | `-(-7)` → `7` |      Table 18.2: The operators unary plus (`+`) and negation (`-`).      Both operators coerce their operands to numbers:    ``` > +'5' 5 > +'-12' -12 > -'9' -9  ```js    Thus, unary plus lets us convert arbitrary values to numbers.    #### [18.3.3 Incrementing (`++`) and decrementing (`--`)](#incrementing--and-decrementing-)    The incrementation operator `++` exists in a prefix version and a suffix version. In both versions, it destructively adds one to its operand. Therefore, its operand must be a storage location that can be changed.    The decrementation operator `--` works the same, but subtracts one from its operand. The next two examples explain the difference between the prefix and the suffix version.    [Table 18.3](#tbl:incrementing-decrementing) summarizes the incrementation and decrementation operators.     | Operator | Name |  | Example | | --- | --- | --- | --- | | `v++` | Increment | ES1 | `let v=0; [v++, v]` → `[0, 1]` | | `++v` | Increment | ES1 | `let v=0; [++v, v]` → `[1, 1]` | | `v--` | Decrement | ES1 | `let v=1; [v--, v]` → `[1, 0]` | | `--v` | Decrement | ES1 | `let v=1; [--v, v]` → `[0, 0]` |      Table 18.3: Incrementation operators and decrementation operators.      Next, we’ll look at examples of these operators in use.    Prefix `++` and prefix `--` change their operands and then return them.    ``` let foo = 3; assert.equal(++foo, 4); assert.equal(foo, 4);  `let bar = 3;` `assert.equal(--bar, 2);` `assert.equal(bar, 2);`  ```js   ``````js```````", "```` Suffix `++` and suffix `--` return their operands and then change them.    ```js let foo = 3; assert.equal(foo++, 3); assert.equal(foo, 4);  `let bar = 3;` `assert.equal(bar--, 3);` `assert.equal(bar, 2);`  ```   ```js````", "```js```", "``` ##### [18.3.3.1 Operands: not just variables](#operands-not-just-variables)    We can also apply these operators to property values:    ```", "```    And to Array elements:    ```", "```    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Number operators**    `exercises/numbers/is_odd_test.mjs`    ### [18.4 Converting to number](#converting-to-number)    These are three ways of converting values to numbers:    *   `Number(value)`: has a descriptive name and is therefore recommended. [Table 18.4](#tbl:converting-values-to-numbers) summarizes how it works. *   `+value`: is equivalent to `Number(value)`. *   `parseFloat(value)`: has [quirks](#qref-Number.parseFloat) and should be avoided.     | `x` | `Number(x)` | | --- | --- | | `undefined` | `NaN` | | `null` | `0` | | boolean | `false` → `0`, `true` → `1` | | number | `x` (no change) | | bigint | `-1n` → `-1`, `1n` → `1`, etc. | | string | `''` → `0` | |  | Other → parsed number, ignoring leading/trailing whitespace | | symbol | Throws `TypeError` | | object | Configurable (e.g. via `.valueOf()`) |      Table 18.4: Converting values to numbers.      Examples:    ```", "```   ```", "```````js````` ```js```````", "```` How objects are converted to numbers can be configured – for example, by overriding `.valueOf()`:    ```js > Number({ valueOf() { return 123 } }) 123  ```    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Converting to number**    `exercises/numbers/parse_number_test.mjs`    ### [18.5 The numeric error values `NaN` and `Infinity`](#numeric-error-values)    JavaScript has two numeric error values:    *   `NaN`:     *   Returned if parsing a number doesn’t work or an operation can’t be performed.     *   Detected via `Number.isNaN()`. `NaN` is not strictly equal to itself. *   `Infinity`:     *   Returned if a number is too large or if a number is divided by zero.     *   Detected via `Number.isFinite()` or by comparing via `===`.    #### [18.5.1 Error value: `NaN`](#NaN)    `NaN` is an abbreviation of “not a number”. Ironically, JavaScript considers it to be a number:    ```js > typeof NaN 'number'  ```    When is `NaN` returned?    `NaN` is returned if a number can’t be parsed:    ```js > Number('$$$') NaN > Number(undefined) NaN  ```    `NaN` is returned if an operation can’t be performed:    ```js > Math.log(-1) NaN > Math.sqrt(-1) NaN  ```    `NaN` is returned if an operand or argument is `NaN` (to propagate errors):    ```js > NaN - 3 NaN > 7 ** NaN NaN  ```    ##### [18.5.1.1 Checking for `NaN`](#checking-for-nan)    `NaN` is the only JavaScript value that is not strictly equal to itself:    ```js const n = NaN; assert.equal(n === n, false);  ```    These are several ways of checking if a value `x` is `NaN`:    ```js const x = NaN;  `assert.equal(Number.isNaN(x), true); // preferred` `assert.equal(Object.is(x, NaN), true);` `assert.equal(x !== x, true);`  ```   ```js````", "```js```", "``` > [NaN].indexOf(NaN) -1  ```", "``` > [NaN].includes(NaN) true > [NaN].findIndex(x => Number.isNaN(x)) 0 > [NaN].find(x => Number.isNaN(x)) NaN  ```", "``` > Math.pow(2, 1023) 8.98846567431158e+307 > Math.pow(2, 1024) Infinity > -Math.pow(2, 1024) -Infinity  ```", "``` > 5 / 0 Infinity > -5 / 0 -Infinity  ```", "``` function findMinimum(numbers) {  let min = Infinity;  for (const n of numbers) {  if (n < min) min = n;  }  return min; }  `assert.equal(findMinimum([5, -1, 2]), -1);` `assert.equal(findMinimum([]), Infinity);`  ```", "``````js``````", "```js > Math.min() Infinity  ```", "```js const x = Infinity;  `assert.equal(x === Infinity, true);` `assert.equal(Number.isFinite(x), false);`  ```", "```js```", "````js` ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Comparing numbers**    `exercises/numbers/find_max_test.mjs`    ### [18.6 The precision of numbers: careful with decimal fractions](#the-precision-of-numbers-careful-with-decimal-fractions)    Internally, JavaScript floating point numbers are represented with base 2 (according to the IEEE 754 standard). That means that decimal fractions (base 10) can’t always be represented precisely:    ``` > 0.1 + 0.2 0.30000000000000004 > 1.3 * 3 3.9000000000000004 > 1.4 * 100000000000000 139999999999999.98  ```js    We therefore need to take rounding errors into consideration when performing arithmetic in JavaScript.    Read on for an explanation of this phenomenon.    ### [18.7 (Advanced)](#advanced-2)    All remaining sections of this chapter are advanced.    ### [18.8 Background: floating point precision](#floating-point-precision)    In JavaScript, computations with numbers don’t always produce correct results – for example:    ``` > 0.1 + 0.2 0.30000000000000004  ```js    To understand why, we need to explore how JavaScript represents floating point numbers internally. It uses three integers to do so, which take up a total of 64 bits of storage (double precision):     | Component | Size | Integer range | | --- | --- | --- | | Sign | 1 bit | [0, 1] | | Fraction | 52 bits | [0, 2^(52)−1] | | Exponent | 11 bits | [−1023, 1024] |    The floating point number represented by these integers is computed as follows:    > (–1)^(sign) × 0b1.fraction × 2^(exponent)    This representation can’t encode a zero because its second component (involving the fraction) always has a leading 1\\. Therefore, a zero is encoded via the special exponent −1023 and a fraction 0.    #### [18.8.1 A simplified representation of floating point numbers](#a-simplified-representation-of-floating-point-numbers)    To make further discussions easier, we simplify the previous representation:    *   Instead of base 2 (binary), we use base 10 (decimal) because that’s what most people are more familiar with. *   The *fraction* is a natural number that is interpreted as a fraction (digits after a point). We switch to a *mantissa*, an integer that is interpreted as itself. As a consequence, the exponent is used differently, but its fundamental role doesn’t change. *   As the mantissa is an integer (with its own sign), we don’t need a separate sign, anymore.    The new representation works like this:    > mantissa × 10^(exponent)    Let’s try out this representation for a few floating point numbers.    *   To encode the integer 123, we use the mantissa 123 and multiply it with 1 (10⁰):                    ```     > 123 * (10 ** 0)     123          ```js           *   To encode the integer −45, we use the mantissa −45 and, again, the exponent zero:                    ```     > -45 * (10 ** 0)     -45          ```js           *   For the number 1.5, we imagine there being a point after the mantissa. We use the negative exponent −1 to move that point one digit to the left:                    ```     > 15 * (10 ** -1)     1.5          ```js           *   For the number 0.25, we move the point two digits to the left:                    ```     > 25 * (10 ** -2)     0.25          ```js              In other words: As soon as we have decimal digits, the exponent becomes negative. We can also write such a number as a fraction:    *   Numerator (above the horizontal fraction bar): the mantissa *   Denominator (below the horizontal fraction bar): a 10 with a positive exponent ≥ 1.    For example:    ``` > 15 * (10 ** -1) === 15 / (10 ** 1) true > 25 * (10 ** -2) === 25 / (10 ** 2) true  ```js    These fractions help with understanding why there are numbers that our encoding cannot represent:    *   `1/10` can be represented. It already has the required format: a power of 10 in the denominator.           *   `1/2` can be represented as `5/10`. We turned the 2 in the denominator into a power of 10 by multiplying the numerator and denominator by 5.           *   `1/4` can be represented as `25/100`. We turned the 4 in the denominator into a power of 10 by multiplying the numerator and denominator by 25.           *   `1/3` cannot be represented. There is no way to turn the denominator into a power of 10\\. (The prime factors of 10 are 2 and 5\\. Therefore, any denominator that only has these prime factors can be converted to a power of 10, by multiplying both the numerator and denominator by enough twos and fives. If a denominator has a different prime factor, then there’s nothing we can do.)              To conclude our excursion, we switch back to base 2:    *   `0.5 = 1/2` can be represented with base 2 because the denominator is already a power of 2. *   `0.25 = 1/4` can be represented with base 2 because the denominator is already a power of 2. *   `0.1 = 1/10` cannot be represented because the denominator cannot be converted to a power of 2. *   `0.2 = 2/10` cannot be represented because the denominator cannot be converted to a power of 2.    Now we can see why `0.1 + 0.2` doesn’t produce a correct result: internally, neither of the two operands can be represented precisely.    The only way to compute precisely with decimal fractions is by internally switching to base 10\\. For many programming languages, base 2 is the default and base 10 an option. For example:    *   Java has the class [`BigDecimal`](https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html). *   Python has the module [`decimal`](https://docs.python.org/3/library/decimal.html).    There are plans to add something similar to JavaScript: [the ECMAScript proposal “Decimal”](https://github.com/tc39/proposal-decimal). Until that happens, we can use libraries such as [big.js](https://github.com/MikeMcl/big.js/).    ### [18.9 Integer numbers in JavaScript](#integer-numbers)    Integer numbers are normal (floating point) numbers without decimal fractions:    ``` > 1 === 1.0 true > Number.isInteger(1.0) true  ```js    In this section, we’ll look at a few tools for working with these pseudo-integers. JavaScript also supports [*bigints*](ch_bigints.html#ch_bigints), which are real integers.    #### [18.9.1 How are integers different from floating point numbers with fractions?](#how-are-integers-different-from-floating-point-numbers-with-fractions)    As we have seen, JavaScript (non-bigint) integers are simply floating point numbers without decimal fractions. But they are different in the following ways:    *   In some locations, only integers are allowed – e.g., the `Array` constructor only accepts integers as lengths:                    ```     > new Array(1.1)     RangeError: Invalid array length     > new Array(1.0)     [,]          ```js           *   In some locations, numbers with fractions are coerced to numbers without fractions – e.g., the bitwise Or (`|`) operation coerces its operands to 32-bit integers:                    ```     > 3.9 | 0     3          ```js           *   JavaScript has several constants and operations for working with integers:                    ```     > Math.log2(Number.MAX_SAFE_INTEGER)     53     > Number.isInteger(123.0)     true     > Number.parseInt('123')     123          ```js           *   Non-decimal integer literals can’t have fractions (the suffix `.1` is interpreted as reading a property – whose name illegally starts with a digit):                    ```     0b1.1 // SyntaxError     0o7.1 // SyntaxError     0xF.1 // SyntaxError          ```js           *   Some JavaScript engines internally represent smaller integers differently – as real integers. For example, V8 does this for the following “small integer” ranges ([source](https://medium.com/fhinkel/v8-internals-how-small-is-a-small-integer-e0badc18b6da)):               *   32-bit systems: 30 bits plus sign     *   64-bit systems: 31 bits plus sign    #### [18.9.2 Converting to integer](#converting-to-integer)    The recommended way of converting numbers to integers is to use one of the rounding methods of the `Math` object:    *   `Math.floor(n)`: returns the largest integer `i` ≤ `n`                    ```     > Math.floor(2.1)     2     > Math.floor(2.9)     2          ```js           *   `Math.ceil(n)`: returns the smallest integer `i` ≥ `n`                    ```     > Math.ceil(2.1)     3     > Math.ceil(2.9)     3          ```js           *   `Math.round(n)`: returns the integer that is “closest” to `n` with `__.5` being rounded up – for example:                    ```     > Math.round(2.4)     2     > Math.round(2.5)     3          ```js           *   `Math.trunc(n)`: removes any decimal fraction (after the point) that `n` has, therefore turning it into an integer.                    ```     > Math.trunc(2.1)     2     > Math.trunc(2.9)     2          ```js              For more information on rounding, see [“Rounding” (§19.3)](ch_math.html#math-rounding).    #### [18.9.3 Ranges of integer numbers in JavaScript](#ranges-of-integer-numbers-in-javascript)    These are important ranges of integer numbers in JavaScript:    *   **Safe integers:** can be represented “safely” by JavaScript (more on what that means in the next subsection)     *   Precision: 53 bits plus sign     *   Range: (−2^(53), 2^(53)) *   **Array indices**     *   Precision: 32 bits, unsigned     *   Range: [0, 2^(32)−1) (excluding the maximum length)     *   Typed Arrays have a larger range of 53 bits (safe and unsigned) *   **Bitwise operators** (bitwise Or, etc.)     *   Precision: 32 bits     *   Range of unsigned right shift (`>>>`): unsigned, [0, 2^(32))     *   Range of all other bitwise operators: signed, [−2^(31), 2^(31))    #### [18.9.4 Safe integers](#safe-integers)    This is the range of integer numbers that are *safe* in JavaScript (53 bits plus a sign):    > [–(2^(53))+1, 2^(53)–1]    An integer is *safe* if it is represented by exactly one JavaScript number. Given that JavaScript numbers are encoded as a fraction multiplied by 2 to the power of an exponent, higher integers can also be represented, but then there are gaps between them.    For example (18014398509481984 is 2^(54)):    ``` > 18014398509481983 18014398509481984 > 18014398509481984 18014398509481984 > 18014398509481985 18014398509481984 > 18014398509481986 18014398509481984 > 18014398509481987 18014398509481988  ```js    The following mathematical integers are therefore not safe:    *   The mathematical integer 18014398509481984 is represented by these JavaScript numbers:     *   18014398509481983     *   18014398509481984     *   18014398509481985     *   18014398509481986 *   The mathematical integer 18014398509481985 is not represented by any JavaScript number.    The following properties of `Number` help determine if an integer is safe:    ``` assert.equal(Number.MAX_SAFE_INTEGER, (2 ** 53) - 1); assert.equal(Number.MIN_SAFE_INTEGER, -Number.MAX_SAFE_INTEGER);  `assert.equal(Number.isSafeInteger(5), true);` `assert.equal(Number.isSafeInteger('5'), false);` `assert.equal(Number.isSafeInteger(5.1), false);` `assert.equal(Number.isSafeInteger(Number.MAX_SAFE_INTEGER), true);` `assert.equal(Number.isSafeInteger(Number.MAX_SAFE_INTEGER+1), false);`  ```js   ````", "```` ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Detecting safe integers**    `exercises/numbers/is_safe_integer_test.mjs`    ##### [18.9.4.1 Safe computations](#safe-computations)    Let’s look at computations involving unsafe integers.    The following result is incorrect and unsafe, even though both of its operands are safe:    ```js > 9007199254740990 + 3 9007199254740992  ```    The following result is safe, but incorrect. The first operand is unsafe; the second operand is safe:    ```js > 9007199254740995 - 10 9007199254740986  ```    Therefore, the result of an expression `a op b` is correct if and only if:    ```js isSafeInteger(a) && isSafeInteger(b) && isSafeInteger(a op b)  ```    That is, both operands and the result must be safe.    ### [18.10 Bitwise operators (advanced)](#bitwise-operators-advanced)    #### [18.10.1 Internally, bitwise operators work with 32-bit integers](#bitwise-operators-32-bit-operands)    Internally, JavaScript’s bitwise operators work with 32-bit integers. They produce their results in the following steps:    *   Input (JavaScript numbers): The 1–2 operands are first converted to JavaScript numbers (64-bit floating point numbers) and then to 32-bit integers. *   Computation (32-bit integers): The actual operation processes 32-bit integers and produces a 32-bit integer. *   Output (JavaScript number): Before returning the result, it is converted back to a JavaScript number.    ##### [18.10.1.1 The types of operands and results](#the-types-of-operands-and-results)    For each bitwise operator, this book mentions the types of its operands and its result. Each type is always one of the following two:     | Type | Description | Size | Range | | --- | --- | --- | --- | | Int32 | signed 32-bit integer | 32 bits incl. sign | [−2^(31), 2^(31)) | | Uint32 | unsigned 32-bit integer | 32 bits | [0, 2^(32)) |    Considering the previously mentioned steps, I recommend to pretend that bitwise operators internally work with unsigned 32-bit integers (step “computation”) and that Int32 and Uint32 only affect how JavaScript numbers are converted to and from integers (steps “input” and “output”).    ##### [18.10.1.2 Displaying JavaScript numbers as unsigned 32-bit integers](#displaying-javascript-numbers-as-unsigned-32bit-integers)    While exploring the bitwise operators, it occasionally helps to display JavaScript numbers as unsigned 32-bit integers in binary notation. That’s what `b32()` does (whose implementation is shown later):    ```js assert.equal(  b32(-1),  '11111111111111111111111111111111'); assert.equal(  b32(1),  '00000000000000000000000000000001'); assert.equal(  b32(2 ** 31),  '10000000000000000000000000000000');  ```    #### [18.10.2 Bitwise Not](#bitwise-not)     | Operation | Name | Type signature |  | | --- | --- | --- | --- | | `~num` | Bitwise Not, *ones’ complement* | Int32 → Int32 | ES1 |      Table 18.5: The bitwise Not operator.      The bitwise Not operator ([table 18.5](#tbl:bitwise-not)) inverts each binary digit of its operand:    ```js > b32(~0b100) '11111111111111111111111111111011'  ```    This so-called *ones’ complement* is similar to a negative for some arithmetic operations. For example, adding an integer to its ones’ complement is always `-1`:    ```js > 4 + ~4 -1 > -11 + ~-11 -1  ```    #### [18.10.3 Binary bitwise operators](#binary-bitwise-operators)     | Operation | Name | Type signature |  | | --- | --- | --- | --- | | `num1 & num2` | Bitwise And | Int32 × Int32 → Int32 | ES1 | | `num1 ¦ num2` | Bitwise Or | Int32 × Int32 → Int32 | ES1 | | `num1 ^ num2` | Bitwise Xor | Int32 × Int32 → Int32 | ES1 |      Table 18.6: Binary bitwise operators.      The binary bitwise operators ([table 18.6](#tbl:binary-bitwise-operators)) combine the bits of their operands to produce their results:    ```js > (0b1010 & 0b0011).toString(2).padStart(4, '0') '0010' > (0b1010 | 0b0011).toString(2).padStart(4, '0') '1011' > (0b1010 ^ 0b0011).toString(2).padStart(4, '0') '1001'  ```    #### [18.10.4 Bitwise shift operators](#bitwise-shift-operators)     | Operation | Name | Type signature |  | | --- | --- | --- | --- | | `num << count` | Left shift | Int32 × Uint32 → Int32 | ES1 | | `num >> count` | Signed right shift | Int32 × Uint32 → Int32 | ES1 | | `num >>> count` | Unsigned right shift | Uint32 × Uint32 → Uint32 | ES1 |      Table 18.7: Bitwise shift operators.      The shift operators ([table 18.7](#tbl:bitwise-shift-operators-short)) move binary digits to the left or to the right:    ```js > (0b10 << 1).toString(2) '100'  ```    `>>` preserves highest bit, `>>>` doesn’t:    ```js > b32(0b10000000000000000000000000000010 >> 1) '11000000000000000000000000000001' > b32(0b10000000000000000000000000000010 >>> 1) '01000000000000000000000000000001'  ```    #### [18.10.5 `b32()`: displaying unsigned 32-bit integers in binary notation](#b32)    We have now used `b32()` a few times. The following code is an implementation of it:    ```js /**  * Return a string representing n as a 32-bit unsigned integer,  * in binary notation.  */ function b32(n) {  // >>> ensures highest bit isn’t interpreted as a sign  return (n >>> 0).toString(2).padStart(32, '0'); } assert.equal(  b32(6),  '00000000000000000000000000000110');  ```    `n >>> 0` means that we are shifting `n` zero bits to the right. Therefore, in principle, the `>>>` operator does nothing, but it still coerces `n` to an unsigned 32-bit integer:    ```js > 12 >>> 0 12 > -12 >>> 0 4294967284 > (2**32 + 1) >>> 0 1  ```    ### [18.11 Quick reference: numbers](#quick-reference-numbers)    #### [18.11.1 Global functions for numbers](#global-functions-for-numbers)    JavaScript has the following four global functions for numbers:    *   `isFinite()` *   `isNaN()` *   `parseFloat()` *   `parseInt()`    However, it is better to use the corresponding methods of `Number` (`Number.isFinite()`, etc.), which have fewer pitfalls. They were introduced with ES6 and are discussed below.    #### [18.11.2 `Number.*`: data properties](#number-data-properties)    *   `Number.EPSILON` ES6                    The difference between 1 and the next representable floating point number. In general, [a machine epsilon](https://en.wikipedia.org/wiki/Machine_epsilon) provides an upper bound for rounding errors in floating point arithmetic.               *   Approximately: 2.2204460492503130808472633361816 × 10^(-16) *   `Number.MAX_VALUE` ES1                    The largest positive finite JavaScript number.               *   Approximately: 1.7976931348623157 × 10^(308) *   `Number.MIN_VALUE` ES1                    The smallest positive JavaScript number. Approximately 5 × 10^(−324).           *   `Number.NaN` ES1                    The same as the global variable `NaN`.           *   `Number.NEGATIVE_INFINITY` ES1                    The same as `-Number.POSITIVE_INFINITY`.           *   `Number.POSITIVE_INFINITY` ES1                    The same as the global variable `Infinity`.              #### [18.11.3 `Number.*`: methods](#number-methods)    *   `Number.isFinite(num)` ES6                    Returns `true` if `num` is an actual number (neither `Infinity` nor `-Infinity` nor `NaN`).                    ```js     > Number.isFinite(Infinity)     false     > Number.isFinite(-Infinity)     false     > Number.isFinite(NaN)     false     > Number.isFinite(123)     true          ```           *   `Number.isNaN(num)` ES6                    Returns `true` if `num` is the value `NaN`:                    ```js     > Number.isNaN(NaN)     true     > Number.isNaN(123)     false     > Number.isNaN('abc')     false          ```           *   `Number.parseFloat(str)` ES6                    Coerces its parameter to string and parses it as a floating point number. It ignores leading whitespace and illegal trailing characters:                    ```js     > Number.parseFloat('\\t 123.4#')     123.4          ```                    That can hide problems. Thus, for converting strings to numbers, `Number()` is usually a better choice because it only ignores leading and trailing whitespace:                    ```js     > Number('\\t 123.4#')     NaN          ```              #### [18.11.4 `Number.prototype.*`](#numberprototype)    (`Number.prototype` is where the methods of numbers are stored.)    *   `Number.prototype.toExponential(fractionDigits?)` ES3               *   Returns a string that represents the number via exponential notation.     *   With `fractionDigits`, we can specify, how many digits should be shown of the number that is multiplied with the exponent.         *   The default is to show as many digits as necessary.          Example: number too small to get a positive exponent via `.toString()`.                    ```js     > 1234..toString()     '1234'      `> 1234..toExponential() // 3 fraction digits`     `'1.234e+3'`     `> 1234..toExponential(5)`     `'1.23400e+3'`     `> 1234..toExponential(1)`     `'1.2e+3'`      ```           ```js` Example: fraction not small enough to get a negative exponent via `.toString()`.    ``` > 0.003.toString() '0.003' > 0.003.toExponential() '3e-3'  ```js ````", "```js```", "``` *   `Number.prototype.toFixed(fractionDigits=0)` ES3                    Returns an exponent-free string representation of the number, rounded to `fractionDigits` digits.                    ```", "```           ```", "``` > (10 ** 21).toFixed() '1e+21'  ```", "```` ```js````", "```js     > 1234..toPrecision(3)  // requires exponential notation     '1.23e+3'      `> 1234..toPrecision(4)`     `'1234'`      ```", "```js      ```", "```js```", "```js```", "```     > 123.456.toString()     '123.456'          ```", "```     > 4..toString(2) // binary (base 2)     '100'     > 4.5.toString(2)     '100.1'      `> 255..toString(16) // hexadecimal (base 16)`     `'ff'`     `> 255.66796875.toString(16)`     `'ff.ab'`      `` `> 1234567890..toString(36)` `'kf12oi'` ``      ```", "````` ```js` `Number.parseInt()` provides the inverse operation: it converts a string that contains an integer (no fraction!) numeral with a given base, to a number.    ``` > Number.parseInt('kf12oi', 36) 1234567890  ```js ```` ```js`` `````", "``````js` ``````", "``````js```    ````` ```js`#### [18.11.5 `Number.*`: data properties and methods for integers](#number-data-properties-and-methods-for-integers)    *   `Number.MIN_SAFE_INTEGER` ES6                    The smallest integer that JavaScript can represent unambiguously (−2^(53)+1).           *   `Number.MAX_SAFE_INTEGER` ES6                    The largest integer that JavaScript can represent unambiguously (2^(53)−1).           *   `Number.isInteger(num)` ES6                    Returns `true` if `num` is a number and does not have a decimal fraction.                    ```     > Number.isInteger(-17)     true     > Number.isInteger(33)     true     > Number.isInteger(33.1)     false     > Number.isInteger('33')     false     > Number.isInteger(NaN)     false     > Number.isInteger(Infinity)     false          ```js           *   `Number.isSafeInteger(num)` ES6                    Returns `true` if `num` is a number and unambiguously represents an integer.           *   `Number.parseInt(str, radix=10)` ES6                    Coerces its parameter to string and parses it as an integer, ignoring leading whitespace and illegal trailing characters:                    ```     > Number.parseInt('  123#')     123          ```js                    The parameter `radix` specifies the base of the number to be parsed:                    ```     > Number.parseInt('101', 2)     5     > Number.parseInt('FF', 16)     255          ```js                    Do not use this method to convert numbers to integers: coercing to string is inefficient. And stopping before the first non-digit is not a good algorithm for removing the fraction of a number. Here is an example where it goes wrong:                    ```     > Number.parseInt(1e21, 10) // wrong     1          ```js                    It is better to use one of the rounding functions of `Math` to convert a number to an integer:                    ```     > Math.trunc(1e21) // correct     1e+21          ```js              #### [18.11.6 Sources](#sources)    *   Wikipedia *   [TypeScript’s built-in typings](https://github.com/microsoft/TypeScript/tree/main/src/lib/) *   [MDN web docs for JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript) *   [ECMAScript language specification](https://tc39.es/ecma262/)```` ```js`` ``````", "```` ```js````", "```js` ```", "```js```", "``` ```", "```````js``` ``````js```````", "``````js``````", "``````js``````", "``` ```", "```js```", "````js````", "```js```", "````js````", "```js` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "``````js``````", "```````"]