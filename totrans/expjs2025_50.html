<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>42 Foundations of asynchronous programming in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>42 Foundations of asynchronous programming in JavaScript</h1>
<blockquote>原文：<a href="https://exploringjs.com/js/book/ch_async-js.html">https://exploringjs.com/js/book/ch_async-js.html</a></blockquote>

        
    
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#event-loop">42.1 The event loop</a>
    </li>
    <li>
      <a href="#how-to-avoid-blocking-the-javascript-process">42.2 How to avoid blocking the JavaScript process</a>
      <ol>
        <li>
          <a href="#blocking-browsers">42.2.1 The user interface of the browser can be blocked</a>
        </li>
        <li>
          <a href="#avoiding-blocking-browser">42.2.2 How can we avoid blocking the browser?</a>
        </li>
        <li>
          <a href="#setTimeout">42.2.3 Scheduling new tasks via <code>setTimeout()</code></a>
        </li>
        <li>
          <a href="#run-to-completion-semantics">42.2.4 Run-to-completion semantics</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#patterns-for-async-results">42.3 Patterns for delivering results asynchronously</a>
      <ol>
        <li>
          <a href="#event-pattern">42.3.1 Delivering asynchronous results via events</a>
        </li>
        <li>
          <a href="#callback-pattern">42.3.2 Delivering asynchronous results via callbacks</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#async-code-downsides">42.4 Asynchronous code: the downsides</a>
    </li>
    <li>
      <a href="#resources">42.5 Resources</a>
    </li>
  </ol>
</nav>
<p>This chapter explains the foundations of asynchronous programming in JavaScript.</p>
<h3 id="event-loop"><a class="heading-id-link" href="#event-loop">42.1 The event loop</a></h3>
<p><span id="index-entry-event-loop"/><span id="index-entry-task-queue"/></p>
<p>Normally JavaScript runs in a single process – in both web browsers and Node.js. Inside that single process, <em>tasks</em> are run, one at a time. A <em>task</em> is a piece of code – think function with zero parameters. Tasks are managed via a queue:</p>
<ul>
  <li>
    <p>The <em>event loop</em> runs continuously inside the JavaScript process. During each loop iteration, it takes one task out of the queue (if the queue is empty, it waits until it isn’t) and executes it. After the task is finished, control goes back to the event loop, which then retrieves the next task from the queue and executes it. And so on.</p>
  </li>
  <li>
    <p><em>Task sources</em> add tasks to the queue. Some of those sources run concurrently to the JavaScript process. For example, one task source takes care of user interface events: if a user clicks somewhere and a click listener was registered, then an invocation of that listener is added to the task queue.</p>
  </li>
</ul>
<p>The following JavaScript code is an approximation of the event loop:</p>
<pre class="language-js">
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">const</span> task = taskQueue.<span class="hljs-title function_">dequeue</span>();
  <span class="hljs-title function_">task</span>(); <span class="hljs-comment">// run task</span>
}
</pre>
<p>The event loop is depicted in <a href="#fig:event_loop">figure 42.1</a>.</p>
<figure id="fig:event_loop" class="float">
  <p><img src="../Images/74ee57a8c7fc965c57f47cc602fdd8cf.png" width="349" alt="" style="height:249.37502px" data-original-src="https://exploringjs.com/js/book/img/async-js/event_loop.svg"/></p>
  <figcaption>
    <p><span class="float-label">Figure 42.1:</span> <em>Task sources</em> add code to run to the <em>task queue</em>, which is emptied by the <em>event loop</em>.</p>
  </figcaption>
</figure>
<h3 id="how-to-avoid-blocking-the-javascript-process"><a class="heading-id-link" href="#how-to-avoid-blocking-the-javascript-process">42.2 How to avoid blocking the JavaScript process</a></h3>
<h4 id="blocking-browsers"><a class="heading-id-link" href="#blocking-browsers">42.2.1 The user interface of the browser can be blocked</a></h4>
<p>Many of the user interface mechanisms of browsers also run in the JavaScript process (as tasks). Therefore, long-running JavaScript code can block the user interface. Let’s look at a web page that demonstrates that. There are two ways in which we can try out that page:</p>
<ul>
  <li>
    We can <a href="http://rauschma.github.io/async-examples/blocking.html">run it online</a>.
  </li>
  <li>
    We can open the following file inside the repository with the exercises: <code>demos/async-js/blocking.html</code>
  </li>
</ul>
<p>The following HTML is the page’s user interface:</p>
<pre class="language-html">
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"block"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">""</span>&gt;</span>Block<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"statusMessage"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</pre>
<p>The idea is that we click “Block” and a long-running loop is executed via JavaScript. During that loop, we can’t click the button because the browser/JavaScript process is blocked.</p>
<p>A simplified version of the JavaScript code looks like this:</p>
<pre class="language-js">
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'block'</span>)
  .<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, doBlock); <span class="hljs-comment">// (A)</span>
<code/>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">doBlock</span>(<span class="hljs-params">event</span>) {
  <span class="hljs-comment">// ···</span>
  <span class="hljs-title function_">displayStatus</span>(<span class="hljs-string">'Blocking...'</span>);
  <span class="hljs-comment">// ···</span>
  <span class="hljs-title function_">sleep</span>(<span class="hljs-number">5000</span>); <span class="hljs-comment">// (B)</span>
  <span class="hljs-title function_">displayStatus</span>(<span class="hljs-string">'Done'</span>);
}
<code/>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-params">milliseconds</span>) {
  <span class="hljs-keyword">const</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
  <span class="hljs-keyword">while</span> ((<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - start) &lt; milliseconds);
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">displayStatus</span>(<span class="hljs-params">status</span>) {
  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'statusMessage'</span>)
    .<span class="hljs-property">textContent</span> = status;
}
</pre>
<p>These are the key parts of the code:</p>
<ul>
  <li>
    Line A: We tell the browser to call <code>doBlock()</code> whenever the HTML element is clicked whose ID is <code>block</code>.
  </li>
  <li>
    <code>doBlock()</code> displays status information and then calls <code>sleep()</code> to block the JavaScript process for 5000 milliseconds (line B).
  </li>
  <li>
    <code>sleep()</code> blocks the JavaScript process by looping until enough time has passed.
  </li>
  <li>
    <code>displayStatus()</code> displays status messages inside the <code>&lt;div&gt;</code> whose ID is <code>statusMessage</code>.
  </li>
</ul>
<h4 id="avoiding-blocking-browser"><a class="heading-id-link" href="#avoiding-blocking-browser">42.2.2 How can we avoid blocking the browser?</a></h4>
<p><span id="index-entry-Web-Worker"/></p>
<p>How can we prevent a long-running operation from blocking the browser?</p>
<ul>
  <li>
    <p>The operation can deliver its result <em>asynchronously</em>: Some operations, such as downloading files, run outside the JavaScript process and concurrently with it. If we invoke such an operation, we provide it with a callback. Once the operation is done, it calls the callback with the result (by adding a task to the queue). This style of delivering a result is called <em>asynchronous</em> because the invoker isn’t blocked while it waits for the result: It can do other things and is notified when the result is ready. Normal function invocations deliver their results synchronously. Our own code can also deliver results asynchronously. We’ll learn more about asynchronous code soon.</p>
  </li>
  <li>
    <p>The operation can be performed in a separate process: This can be done via so-called <span id="web-workers"><em>Web Workers</em></span>. A Web Worker is a heavyweight process that runs concurrently to the main process. It has its own runtime environment (global variables, etc.). It is completely isolated; communication happens via message passing. See <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API">MDN web docs</a> for more information.</p>
  </li>
  <li>
    <p>The operation can take breaks and give pending tasks in the queue a chance to run – which unblocks the browser. <span refcheck="#setTimeout">The next subsection</span> explains how that is done.</p>
  </li>
</ul>
<h4 id="setTimeout"><a class="heading-id-link" href="#setTimeout">42.2.3 Scheduling new tasks via <code>setTimeout()</code></a></h4>
<p>The following global function executes its parameter <code>callback</code> after a delay of <code>ms</code> milliseconds (the type signature is simplified – <code>setTimeout()</code> has more features):</p>
<pre class="language-ts">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">setTimeout</span>(<span class="hljs-params">callback: () =&gt; <span class="hljs-built_in">void</span>, ms: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">any</span>
</pre>
<p>The function returns a <em>handle</em> (an ID) that can be used to <em>clear</em> the timeout (cancel the execution of the callback before it happens) via the following global function:</p>
<pre class="language-ts">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">clearTimeout</span>(<span class="hljs-params">handle?: <span class="hljs-built_in">any</span></span>): <span class="hljs-built_in">void</span>
</pre>
<p><code>setTimeout()</code> is available on both browsers and Node.js. We can view <code>setTimeout()</code> as scheduling a task for later execution:</p>
<pre class="language-js">
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'First task starts'</span>);
<span class="hljs-built_in">setTimeout</span>(
  <span class="hljs-function">() =&gt;</span> { <span class="hljs-comment">// (A)</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Second task starts'</span>);
  },
  <span class="hljs-number">0</span> <span class="hljs-comment">// (B)</span>
);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'First task ends'</span>);
</pre>
<p>Within the first task, we are scheduling a new task (the callback starting in line A) to be run after a delay of zero milliseconds (line B).</p>
<p>Output:</p>
<pre>
First task starts
First task ends
Second task starts
</pre>
<p>There is another way of looking at what happened: <strong>The first task took a break and later continued with the second task.</strong></p>
<ul>
  <li>
    The first task runs. While it does, events such as click events may fire and cause tasks to be added to the queue. Those tasks can only run after the current task is finished.
  </li>
  <li>
    The first task ends. Now other tasks can run. We used a delay of zero milliseconds, so all tasks that were added to the queue before the second task, will run next.
  </li>
  <li>
    The second task runs, continuing the work of the first task.
  </li>
</ul>
<p>In other words: The task took a break and gave other tasks a chance to run.</p>
<h4 id="run-to-completion-semantics"><a class="heading-id-link" href="#run-to-completion-semantics">42.2.4 Run-to-completion semantics</a></h4>
<p><span id="index-entry-run-to-completion-semantics"/></p>
<p>JavaScript makes a guarantee for tasks:</p>
<blockquote>
  <p>Each task is always finished (“run to completion”) before the next task is executed.</p>
</blockquote>
<p>As a consequence, tasks don’t have to worry about their data being changed while they are working on it (<em>concurrent modification</em>). That simplifies programming in JavaScript.</p>
<p>We can observe run to completion in the previous example:</p>
<pre class="language-js">
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'First task starts'</span>);
<span class="hljs-built_in">setTimeout</span>(
  <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Second task starts'</span>);
  },
  <span class="hljs-number">0</span>
);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'First task ends'</span>);
</pre>
<p>The first task ends before the next task starts.</p>
<h3 id="patterns-for-async-results"><a class="heading-id-link" href="#patterns-for-async-results">42.3 Patterns for delivering results asynchronously</a></h3>
<p>In order to avoid blocking the main process while waiting for a long-running operation to finish, results are often delivered asynchronously in JavaScript. These are three popular patterns for doing so:</p>
<ul>
  <li>
    Events
  </li>
  <li>
    Callbacks
  </li>
  <li>
    Promises
  </li>
</ul>
<p>The first two patterns are explained in <span refcheck="#event-pattern #callback-pattern">the next two subsections</span>. Promises are explained in <a href="ch_promises.html#ch_promises">the next chapter</a>.</p>
<h4 id="event-pattern"><a class="heading-id-link" href="#event-pattern">42.3.1 Delivering asynchronous results via events</a></h4>
<p><span id="index-entry-event--asynchronous-pattern-"/></p>
<p>Events as a pattern work as follows:</p>
<ul>
  <li>
    They are used to deliver values asynchronously.
  </li>
  <li>
    They do so zero or more times.
  </li>
  <li>
    There are three roles in this pattern:
    <ul>
      <li>
        The <em>event</em> (an object) carries the data to be delivered.
      </li>
      <li>
        The <em>event listener</em> is a function that receives events via a parameter.
      </li>
      <li>
        The <em>event source</em> sends events and lets us register event listeners.
      </li>
    </ul>
  </li>
</ul>
<p>Multiple variations of this pattern exist in the world of JavaScript. We’ll look at three examples next.</p>
<h5 id="events-indexeddb"><a class="heading-id-link" href="#events-indexeddb">42.3.1.1 Events: IndexedDB</a></h5>
<p>IndexedDB is a database that is built into web browsers. This is an example of using it:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> openRequest = indexedDB.<span class="hljs-title function_">open</span>(<span class="hljs-string">'MyDatabase'</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// (A)</span>
<code/>
openRequest.<span class="hljs-property">onsuccess</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> db = event.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>;
  <span class="hljs-comment">// ···</span>
};
<code/>
openRequest.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);
};
</pre>
<p><code>indexedDB</code> has an unusual way of invoking operations:</p>
<ul>
  <li>
    <p>Each operation has an associated method for creating <em>request objects</em>. For example, in line A, the operation is “open”, the method is <code>.open()</code>, and the request object is <code>openRequest</code>.</p>
  </li>
  <li>
    <p>The parameters for the operation are provided via the request object, not via parameters of the method. For example, the event listeners (functions) are stored in the properties <code>.onsuccess</code> and <code>.onerror</code>.</p>
  </li>
  <li>
    <p>The invocation of the operation is added to the task queue via the method (in line A). That is, we configure the operation <em>after</em> its invocation has already been added to the queue. Only run-to-completion semantics saves us from race conditions here and ensures that the operation runs after the current code fragment is finished.</p>
  </li>
</ul>
<h5 id="XMLHttpRequest"><a class="heading-id-link" href="#XMLHttpRequest">42.3.1.2 Events: <code>XMLHttpRequest</code></a></h5>
<p>The <code>XMLHttpRequest</code> API lets us make downloads from within a web browser. This is how we download the file <code>http://example.com/textfile.txt</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>(); <span class="hljs-comment">// (A)</span>
xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'http://example.com/textfile.txt'</span>); <span class="hljs-comment">// (B)</span>
xhr.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> { <span class="hljs-comment">// (C)</span>
  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>) {
    <span class="hljs-title function_">processData</span>(xhr.<span class="hljs-property">responseText</span>);
  } <span class="hljs-keyword">else</span> {
    assert.<span class="hljs-title function_">fail</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(xhr.<span class="hljs-property">statusText</span>));
  }
};
xhr.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> { <span class="hljs-comment">// (D)</span>
  assert.<span class="hljs-title function_">fail</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Network error'</span>));
};
xhr.<span class="hljs-title function_">send</span>(); <span class="hljs-comment">// (E)</span>
<code/>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">processData</span>(<span class="hljs-params">str</span>) {
  assert.<span class="hljs-title function_">equal</span>(str, <span class="hljs-string">'Content of textfile.txt\n'</span>);
}
</pre>
<p>With this API, we first create a request object (line A), then configure it, then activate it (line E). The configuration consists of:</p>
<ul>
  <li>
    Specifying which HTTP request method to use (line B): <code>GET</code>, <code>POST</code>, <code>PUT</code>, etc.
  </li>
  <li>
    Registering a listener (line C) that is notified if something could be downloaded. Inside the listener, we still need to determine if the download contains what we requested or informs us of an error. Note that some of the result data is delivered via the request object <code>xhr</code>. (I’m not a fan of this kind of mixing of input and output data.)
  </li>
  <li>
    Registering a listener (line D) that is notified if there was a network error.
  </li>
</ul>
<h5 id="events-dom"><a class="heading-id-link" href="#events-dom">42.3.1.3 Events: DOM</a></h5>
<p>We have already seen DOM events in action in <a href="#blocking-browsers">“The user interface of the browser can be blocked” (§42.2.1)</a>. The following code also handles <code>click</code> events:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'my-link'</span>); <span class="hljs-comment">// (A)</span>
element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, clickListener); <span class="hljs-comment">// (B)</span>
<code/>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">clickListener</span>(<span class="hljs-params">event</span>) {
  event.<span class="hljs-title function_">preventDefault</span>(); <span class="hljs-comment">// (C)</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">shiftKey</span>); <span class="hljs-comment">// (D)</span>
}
</pre>
<p>We first ask the browser to retrieve the HTML element whose ID is <code>'my-link'</code> (line A). Then we add a listener for all <code>click</code> events (line B). In the listener, we first tell the browser not to perform its default action (line C) – going to the target of the link. Then we log to the console if the shift key is currently pressed (line D).</p>
<h4 id="callback-pattern"><a class="heading-id-link" href="#callback-pattern">42.3.2 Delivering asynchronous results via callbacks</a></h4>
<p><span id="index-entry-callback--asynchronous-pattern-"/></p>
<p>Callbacks are another pattern for handling asynchronous results. They are only used for one-off results and have the advantage of being less verbose than events.</p>
<p>As an example, consider a function <code>readFile()</code> that reads a text file and returns its contents asynchronously. This is how we call <code>readFile()</code> if it uses Node.js-style callbacks:</p>
<pre class="language-js">
<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'some-file.txt'</span>, {<span class="hljs-attr">encoding</span>: <span class="hljs-string">'utf-8'</span>},
  <span class="hljs-function">(<span class="hljs-params">error, data</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (error) {
      assert.<span class="hljs-title function_">fail</span>(error);
      <span class="hljs-keyword">return</span>;
    }
    assert.<span class="hljs-title function_">equal</span>(data, <span class="hljs-string">'The content of some-file.txt'</span>);
  });
</pre>
<p>There is a single callback that handles both success and failure. If the first parameter is not <code>null</code> then an error happened. Otherwise, the result can be found in the second parameter.</p>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercises: Callback-based code</strong></p>
  <div class="boxout-vspace"/>
  <p>The following exercises use tests for asynchronous code, which are different from tests for synchronous code. See <a href="ch_exercises.html#async-tests-mocha">“Asynchronous tests in Mocha” (§12.2.2)</a> for more information.</p>
  <ul>
    <li>
      From synchronous to callback-based code: <code>exercises/async-js/read_file_cb_exrc.mjs</code>
    </li>
    <li>
      Implementing a callback-based version of <code>.map()</code>: <code>exercises/async-js/map_cb_test.mjs</code>
    </li>
  </ul>
</div>
<h3 id="async-code-downsides"><a class="heading-id-link" href="#async-code-downsides">42.4 Asynchronous code: the downsides</a></h3>
<p>In many situations, on either browsers or Node.js, we have no choice: We must use asynchronous code. In this chapter, we have seen several patterns that such code can use. All of them have two disadvantages:</p>
<ul>
  <li>
    Asynchronous code is more verbose than synchronous code.
  </li>
  <li>
    If we call asynchronous code, our code must become asynchronous too. That’s because we can’t wait synchronously for an asynchronous result. Asynchronous code has an infectious quality.
  </li>
</ul>
<p>The first disadvantage becomes less severe with Promises (covered in <a href="ch_promises.html#ch_promises">the next chapter</a>) and mostly disappears with async functions (covered in <a href="ch_async-functions.html#ch_async-functions">the chapter after next</a>).</p>
<p>Alas, the infectiousness of async code does not go away. But it is mitigated by the fact that switching between sync and async is easy with async functions.</p>
<h3 id="resources"><a class="heading-id-link" href="#resources">42.5 Resources</a></h3>
<ul>
  <li>
    <a href="https://vimeo.com/96425312">“Help, I'm stuck in an event-loop”</a> by Philip Roberts (video).
  </li>
  <li>
    <a href="https://www.w3.org/TR/html5/webappapis.html#event-loops">“Event loops”</a>, section in HTML5 spec.
  </li>
</ul>

    
      
</body>
</html>