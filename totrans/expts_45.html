<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>37 Computing with tuple types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>37 Computing with tuple types</h1>
<blockquote>原文：<a href="https://exploringjs.com/ts/book/ch_computing-with-tuple-types.html">https://exploringjs.com/ts/book/ch_computing-with-tuple-types.html</a></blockquote>

    
        <div id="adbox">
      <div id="adbox-explain">(Ad, please don’t block.)</div>
              
          </div>
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#the-syntax-of-tuple-types">37.1 The syntax of tuple types</a>
      <ol>
        <li>
          <a href="#basic-syntax">37.1.1 Basic syntax</a>
        </li>
        <li>
          <a href="#variadic-tuple-elements">37.1.2 Variadic tuple elements</a>
        </li>
        <li>
          <a href="#labeled-tuple-elements">37.1.3 Labeled tuple elements</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#types-for-tuples">37.2 Types for tuples</a>
      <ol>
        <li>
          <a href="#tuples-and-nouncheckedindexedaccess">37.2.1 Tuples and <code>--noUncheckedIndexedAccess</code></a>
        </li>
        <li>
          <a href="#forcing-array-literals-to-be-inferred-as-tuples">37.2.2 Forcing Array literals to be inferred as tuples</a>
        </li>
        <li>
          <a href="#using-readonly-to-accept-const-tuples">37.2.3 Using <code>readonly</code> to accept const tuples</a>
        </li>
        <li>
          <a href="#enforcing-a-fixed-array-length">37.2.4 Enforcing a fixed Array length</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#keyof-tuple-type">37.3 The keys of tuple types</a>
      <ol>
        <li>
          <a href="#TupleIndexKeys">37.3.1 Extracting the index keys (strings) of a tuple</a>
        </li>
        <li>
          <a href="#TupleIndices">37.3.2 Extracting the indices (numbers) of a tuple</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#mapped-types-over-tuples">37.4 Mapping tuples via mapped types</a>
      <ol>
        <li>
          <a href="#how-a-mapped-type-handles-the-keys-of-a-tuple-type">37.4.1 How a mapped type handles the keys of a tuple type</a>
        </li>
        <li>
          <a href="#mapping-preserves-the-labels-of-tuple-elements">37.4.2 Mapping preserves the labels of tuple elements</a>
        </li>
        <li>
          <a href="#tuples-and-mapped-types-with-key-remapping-as">37.4.3 Tuples and mapped types with key remapping (<code>as</code>)</a>
        </li>
        <li>
          <a href="#typing-Promise.all">37.4.4 Example: typing <code>Promise.all()</code></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#extracting-union-types-from-tuples">37.5 Extracting union types from tuples</a>
      <ol>
        <li>
          <a href="#from-tuple-to-union">37.5.1 Applying the indexed access operator <code>T[K]</code> to a tuple</a>
        </li>
        <li>
          <a href="#from-tuple-of-tuples-to-union">37.5.2 Extracting a union from a tuple of tuples</a>
        </li>
        <li>
          <a href="#from-tuple-of-objects-to-union">37.5.3 Extracting a union from a tuple of objects</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#computing-with-tuple-types-1">37.6 Computing with tuple types</a>
      <ol>
        <li>
          <a href="#extracting-parts-of-tuples">37.6.1 Extracting parts of tuples</a>
        </li>
        <li>
          <a href="#tuple-lookup-table">37.6.2 Using a tuple of pairs as a lookup table</a>
        </li>
        <li>
          <a href="#concatenating-tuples">37.6.3 Concatenating tuples</a>
        </li>
        <li>
          <a href="#recursion-over-tuples">37.6.4 Recursion over tuples</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#real-world-examples">37.7 Real-world examples</a>
      <ol>
        <li>
          <a href="#applyPartial">37.7.1 Partial application that preserves parameter names</a>
        </li>
        <li>
          <a href="#typing-zip">37.7.2 Typing a function <code>zip()</code></a>
        </li>
        <li>
          <a href="#typing-a-function-zipobj">37.7.3 Typing a function <code>zipObj()</code></a>
        </li>
        <li>
          <a href="#util-promisify-converting-a-callback-based-function-to-a-promise-based-one">37.7.4 <code>util.promisify()</code>: converting a callback-based function to a Promise-based one</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#limitations-of-computing-with-tuples">37.8 Limitations of computing with tuples</a>
    </li>
    <li>
      <a href="#sources-of-this-chapter-6">37.9 Sources of this chapter</a>
    </li>
  </ol>
</nav>
<p>JavaScript’s Arrays are so flexible that TypeScript provides two different kinds of types for handling them:</p>
<ul>
  <li>
    Array types for arbitrary-length sequences of values that all have the same type – e.g.: <code>Array&lt;string&gt;</code>
  </li>
  <li>
    Tuple types for fixed-length sequences of values where each one may have a different type – e.g.: <code>[number, string, boolean]</code>
  </li>
</ul>
<p>In this chapter, we look at the latter – especially how to compute with tuples at the type level.</p>
<h3 id="the-syntax-of-tuple-types"><a class="heading-id-link" href="#the-syntax-of-tuple-types">37.1 The syntax of tuple types</a></h3>
<h4 id="basic-syntax"><a class="heading-id-link" href="#basic-syntax">37.1.1 Basic syntax</a></h4>
<p>Tuple types have this syntax:</p>
<pre class="language-ts">
<code>[ <span class="hljs-title class_">Required</span>, <span class="hljs-title class_">Optional</span>?, ...<span class="hljs-title class_">RestElement</span>[] ]</code>
</pre>
<ul>
  <li>
    First, zero or more required elements.
  </li>
  <li>
    Then, zero or more optional elements.
  </li>
  <li>
    At the end, optionally, a single rest element.
  </li>
</ul>
<p>Examples:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> T = [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>?, ...<span class="hljs-built_in">number</span>[]];</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">v1</span>: T = [<span class="hljs-string">'a'</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">v2</span>: T = [<span class="hljs-string">'a'</span>, <span class="hljs-literal">true</span>];</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">v3</span>: T = [<span class="hljs-string">'a'</span>];</code>
<code><span class="hljs-comment">// @ts-expect-error: Type '[]' is not assignable to type 'T'.</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">v4</span>: T = [];</code>
</pre>
<p><strong>There is one additional rule:</strong> required elements can appear after a rest element – but only if there is no optional element before them:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = [<span class="hljs-built_in">number</span>, ...<span class="hljs-built_in">boolean</span>[], <span class="hljs-built_in">string</span>]; <span class="hljs-comment">// OK</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = [...<span class="hljs-built_in">boolean</span>[], <span class="hljs-built_in">string</span>]; <span class="hljs-comment">// OK</span></code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: A required element cannot follow</span></code>
<code><span class="hljs-comment">// an optional element.</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T3</span> = [<span class="hljs-built_in">number</span>?, ...<span class="hljs-built_in">boolean</span>[], <span class="hljs-built_in">string</span>];</code>
</pre>
<h5 id="optional-elements-can-only-be-omitted-at-the-end"><a class="heading-id-link" href="#optional-elements-can-only-be-omitted-at-the-end">37.1.1.1 Optional elements can only be omitted at the end</a></h5>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> T = [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>?, ...<span class="hljs-built_in">number</span>[]];</code>
<code/>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">v1</span>: T = [<span class="hljs-string">'a'</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// OK</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">v2</span>: T = [<span class="hljs-string">'a'</span>]; <span class="hljs-comment">// OK</span></code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Type 'number' is not assignable to</span></code>
<code><span class="hljs-comment">// type 'boolean'.</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">v3</span>: T = [<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</code>
</pre>
<p>If the compiler option <a href="ch_tsconfig-json.html#exactOptionalPropertyTypes"><code>exactOptionalPropertyTypes</code></a> is active, we can’t even do the following:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// @ts-expect-error: Type '[string, undefined, number, number, number]' is</span></code>
<code><span class="hljs-comment">// not assignable to type 'T'. Type at position 1 in source is not</span></code>
<code><span class="hljs-comment">// compatible with type at position 1 in target. Type 'undefined' is not</span></code>
<code><span class="hljs-comment">// assignable to type 'boolean'.</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">v4</span>: T = [<span class="hljs-string">'a'</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</code>
</pre>
<p>Note that this is similar to how JavaScript handles parameters and destructuring – e.g.:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x, y=<span class="hljs-number">3</span>, ...z</span>) {</code>
<code>  <span class="hljs-keyword">return</span> {x,y,z};</code>
<code>}</code>
</pre>
<p>If we want to enable omitting elements in the middle, we can use a union:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// The `boolean` element can be omitted:</span></code>
<code><span class="hljs-keyword">type</span> T =</code>
<code>  | [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>, ...<span class="hljs-built_in">number</span>[]]</code>
<code>  | [<span class="hljs-built_in">string</span>, ...<span class="hljs-built_in">number</span>[]]</code>
<code>;</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">v1</span>: T = [<span class="hljs-string">'a'</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// OK</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">v2</span>: T = [<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// OK</span></code>
</pre>
<p>If there is a second parameter, it is assigned to <code>y</code> and does not become an element of <code>z</code>.</p>
<h4 id="variadic-tuple-elements"><a class="heading-id-link" href="#variadic-tuple-elements">37.1.2 Variadic tuple elements</a></h4>
<p><em>Variadic</em> means “has variable (not fixed) arity”. The arity of a tuple is its length.</p>
<p><em>Variadic elements</em> (or <em>spread elements</em>) enable spreading into tuples at the type level:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Tuple1</span> = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Tuple2</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  [<span class="hljs-literal">true</span>, ...<span class="hljs-title class_">Tuple1</span>, ...<span class="hljs-title class_">Tuple2</span>, <span class="hljs-literal">false</span>], <span class="hljs-comment">// type expression</span></code>
<code>  [ <span class="hljs-literal">true</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">false</span> ] <span class="hljs-comment">// result</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>Compare that to spreading in JavaScript:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> tuple1 = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];</code>
<code><span class="hljs-keyword">const</span> tuple2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  [<span class="hljs-literal">true</span>, ...tuple1, ...tuple2, <span class="hljs-literal">false</span>], <span class="hljs-comment">// expression</span></code>
<code>  [ <span class="hljs-literal">true</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">false</span> ] <span class="hljs-comment">// result</span></code>
<code>);</code>
</pre>
<p>The type that is spread is usually a type variable and must be assignable to <code>readonly any[]</code> – i.e., it must be an Array or a tuple. It can have any length – hence the term “variadic”. The pull request <a href="https://github.com/microsoft/TypeScript/pull/39094">“Variadic tuple types”</a> describes spreading like this:</p>
<blockquote>
  <p>Intuitively, a variadic element  <code>...T</code> is a placeholder that is replaced with one or more elements through generic type instantiation.</p>
</blockquote>
<h5 id="normalization-of-instantiated-generic-tuple-types"><a class="heading-id-link" href="#normalization-of-instantiated-generic-tuple-types">37.1.2.1 Normalization of instantiated generic tuple types</a></h5>
<p>The result of spreading is adjusted so that it always fits the shape described at the beginning of this section. To explore how that works, we’ll use the utility types <code>Spread1</code> and <code>Spread2</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Spread1</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[]&gt; = [...T];</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Spread2</span>&lt;<span class="hljs-variable constant_">T1</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[], <span class="hljs-variable constant_">T2</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[]&gt; =</code>
<code>  [...<span class="hljs-variable constant_">T1</span>, ...<span class="hljs-variable constant_">T2</span>]</code>
<code>;</code>
<code/>
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-comment">// A tuple with only a spread Array becomes an Array:</span></code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">Spread1</span>&lt;<span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;,</code>
<code>    <span class="hljs-built_in">string</span>[]</code>
<code>  &gt;&gt;,</code>
<code>  </code>
<code>  <span class="hljs-comment">// If an Array is spread at the end, it becomes a rest element:</span></code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">Spread2</span>&lt;[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>], <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt;&gt;,</code>
<code>    [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, ...<span class="hljs-built_in">number</span>[]]</code>
<code>  &gt;&gt;,</code>
<code>  </code>
<code>  <span class="hljs-comment">// If two Arrays are spread, they are merged so that there</span></code>
<code>  <span class="hljs-comment">// is at most one rest element:</span></code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">Spread2</span>&lt;<span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;, <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt;&gt;,</code>
<code>    [...(<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[]]</code>
<code>  &gt;&gt;,</code>
<code>  </code>
<code>  <span class="hljs-comment">// Optional elements after an Array are merged into it:</span></code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">Spread2</span>&lt;<span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;, [<span class="hljs-built_in">number</span>?, <span class="hljs-built_in">boolean</span>?]&gt;,</code>
<code>    (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">boolean</span> | <span class="hljs-literal">undefined</span>)[]</code>
<code>  &gt;&gt;,</code>
<code>  </code>
<code>  <span class="hljs-comment">// Optional elements `T` before required ones become `undefined|T`:</span></code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">Spread2</span>&lt;[<span class="hljs-built_in">string</span>?], [<span class="hljs-built_in">number</span>]&gt;,</code>
<code>    [<span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>, <span class="hljs-built_in">number</span>]</code>
<code>  &gt;&gt;,</code>
<code>  </code>
<code>  <span class="hljs-comment">// Required elements between Arrays are also merged:</span></code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">Spread2</span>&lt;[<span class="hljs-built_in">boolean</span>, ...<span class="hljs-built_in">number</span>[]], [<span class="hljs-built_in">string</span>, ...<span class="hljs-built_in">bigint</span>[]]&gt;,</code>
<code>    [<span class="hljs-built_in">boolean</span>, ...(<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">bigint</span>)[]]</code>
<code>  &gt;&gt;,</code>
<code>];</code>
</pre>
<p>Note that we can only spread a type <code>T</code> if it is constrained via <code>extends</code> to an Array type:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Spread1</span>a&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[]&gt; = [...T]; <span class="hljs-comment">// OK</span></code>
<code><span class="hljs-comment">// @ts-expect-error: A rest element type must be an array type.</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Spread1</span>b&lt;T&gt; = [...T];</code>
</pre>
<h4 id="labeled-tuple-elements"><a class="heading-id-link" href="#labeled-tuple-elements">37.1.3 Labeled tuple elements</a></h4>
<p>We can also specify labels for tuple elements:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Interval</span> = [<span class="hljs-attr">start</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">end</span>: <span class="hljs-built_in">number</span>];</code>
</pre>
<p>If one element is labeled, all elements must be labeled. For optional elements, the syntax changes with labels – the question mark (<code>?</code>) is added to the label, not the type (TypeScript will tell you during editing if you do it wrong):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Tuple1</span> = [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>?, ...<span class="hljs-built_in">number</span>[]];</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Tuple2</span> = [<span class="hljs-attr">requ</span>: <span class="hljs-built_in">string</span>, opt?: <span class="hljs-built_in">boolean</span>, ...<span class="hljs-attr">rest</span>: <span class="hljs-built_in">number</span>[]];</code>
</pre>
<p>What do labels do? Not much: They help with autocompletion and are preserved by some type operations but have no other effect in the type system:</p>
<ul>
  <li>
    We can’t derive anything from them (e.g. to derive an options object from normal parameters).
  </li>
  <li>
    They don’t affect type compatibility etc.
  </li>
</ul>
<p>Therefore: If names matter, you should use an object type.</p>
<h5 id="extracted-function-parameters-are-labeled"><a class="heading-id-link" href="#extracted-function-parameters-are-labeled">37.1.3.1 Extracted function parameters are labeled</a></h5>
<p>If we extract function parameters, we get labeled tuple elements:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _1 = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-function">(<span class="hljs-params">sym: <span class="hljs-built_in">symbol</span>, bool: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;,</code>
<code>  [<span class="hljs-attr">sym</span>: <span class="hljs-built_in">symbol</span>, <span class="hljs-attr">bool</span>: <span class="hljs-built_in">boolean</span>]</code>
<code>&gt;&gt;;</code>
</pre>
<p>Note that there is no way to check what the actual tuple element labels are – these checks succeed too:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// Different labels</span></code>
<code><span class="hljs-keyword">type</span> _2 = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-function">(<span class="hljs-params">sym: <span class="hljs-built_in">symbol</span>, bool: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;,</code>
<code>  [<span class="hljs-attr">HELLO</span>: <span class="hljs-built_in">symbol</span>, <span class="hljs-attr">EVERYONE</span>: <span class="hljs-built_in">boolean</span>]</code>
<code>&gt;&gt;;</code>
<code/>
<code><span class="hljs-comment">// No labels</span></code>
<code><span class="hljs-keyword">type</span> _3 = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-function">(<span class="hljs-params">sym: <span class="hljs-built_in">symbol</span>, bool: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;,</code>
<code>  [<span class="hljs-built_in">symbol</span>, <span class="hljs-built_in">boolean</span>]</code>
<code>&gt;&gt;;</code>
</pre>
<h5 id="overloading"><a class="heading-id-link" href="#overloading">37.1.3.2 Use case: overloading</a></h5>
<p>TypeScript uses labels as function parameters if a rest parameter has a tuple type:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params">...args: [str: <span class="hljs-built_in">string</span>, num: <span class="hljs-built_in">number</span>]</span>) {}</code>
<code>  <span class="hljs-comment">// function f1(str: string, num: number): void</span></code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params">...args: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>]</span>) {}</code>
<code>  <span class="hljs-comment">// function f2(args_0: string, args_1: number): void</span></code>
</pre>
<p>Thanks to labels, tuples become better as an alternative to overloading because autocompletion can show parameter names:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// Overloading with tuples</span></code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(</code>
<code><span class="hljs-params">  ...args:</span></code>
<code><span class="hljs-params">    | [str: <span class="hljs-built_in">string</span>, num: <span class="hljs-built_in">number</span>]</span></code>
<code><span class="hljs-params">    | [num: <span class="hljs-built_in">number</span>]</span></code>
<code><span class="hljs-params">    | [bool: <span class="hljs-built_in">boolean</span>]</span></code>
<code>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-comment">// ···</span></code>
<code>}</code>
</pre>
<pre class="language-ts">
<code><span class="hljs-comment">// Traditional overloading</span></code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span>, num: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">void</span>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">num: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">void</span>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">bool: <span class="hljs-built_in">boolean</span></span>): <span class="hljs-built_in">void</span>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">arg0: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">boolean</span>, num?: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-comment">// ···</span></code>
<code>}</code>
</pre>
<p>The caveat is that the tuples can’t influence the return type.</p>
<h5 id="use-case-preserving-argument-names-when-transforming-functions"><a class="heading-id-link" href="#use-case-preserving-argument-names-when-transforming-functions">37.1.3.3 Use case: preserving argument names when transforming functions</a></h5>
<p>How that works is demonstrated when we handle partial application <a href="#applyPartial">later in this chapter</a>.</p>
<h3 id="types-for-tuples"><a class="heading-id-link" href="#types-for-tuples">37.2 Types for tuples</a></h3>
<h4 id="tuples-and-nouncheckedindexedaccess"><a class="heading-id-link" href="#tuples-and-nouncheckedindexedaccess">37.2.1 Tuples and <code>--noUncheckedIndexedAccess</code></a></h4>
<p>If we switch on the <code>tsconfig.json</code> option <a href="ch_tsconfig-json.html#noUncheckedIndexedAccess"><code>noUncheckedIndexedAccess</code></a> then TypeScript is more honest about what it knows about an indexable type.</p>
<p>With an Array, TypeScript never knows at compile time at which indices there are elements – which is why <code>undefined</code> is always a possible result with indexed reading:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];</code>
<code><span class="hljs-keyword">const</span> arrayElement = arr[<span class="hljs-number">1</span>];</code>
<code>assertType&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>&gt;(arrayElement);</code>
</pre>
<p>With a tuple, TypeScript knows the whole shape and can provide better types for indexed reading:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">tuple</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>] = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];</code>
<code><span class="hljs-keyword">const</span> tupleElement = tuple[<span class="hljs-number">1</span>];</code>
<code>assertType&lt;<span class="hljs-built_in">string</span>&gt;(tupleElement);</code>
</pre>
<h4 id="forcing-array-literals-to-be-inferred-as-tuples"><a class="heading-id-link" href="#forcing-array-literals-to-be-inferred-as-tuples">37.2.2 Forcing Array literals to be inferred as tuples</a></h4>
<p>By default, a JavaScript Array literal has an Array type:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// Array</span></code>
<code><span class="hljs-keyword">const</span> value1 = [<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>];</code>
<code>assertType&lt;</code>
<code>  (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[]</code>
<code>&gt;(value1);</code>
</pre>
<p>The most common way of changing that is via an <code>as const</code> annotation:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// Tuple</span></code>
<code><span class="hljs-keyword">const</span> value2 = [<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code>
<code>assertType&lt;</code>
<code>  <span class="hljs-keyword">readonly</span> [<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>]</code>
<code>&gt;(value2);</code>
</pre>
<p>But we can also use <code>satisfies</code>:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// Non-empty tuple</span></code>
<code><span class="hljs-keyword">const</span> value3 = [<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>] satisfies [<span class="hljs-built_in">unknown</span>, ...<span class="hljs-built_in">unknown</span>[]];</code>
<code>assertType&lt;</code>
<code>  [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>]</code>
<code>&gt;(value3);</code>
<code/>
<code><span class="hljs-comment">// Tuple (possibly empty)</span></code>
<code><span class="hljs-keyword">const</span> value4 = [<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>] satisfies [<span class="hljs-built_in">unknown</span>?, ...<span class="hljs-built_in">unknown</span>[]];</code>
<code>assertType&lt;</code>
<code>  [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>]</code>
<code>&gt;(value4);</code>
</pre>
<p>Note that <code>as const</code> also narrows the element types to <code>'a'</code> and <code>1</code>. With <code>satisfies</code>, they are <code>string</code> and <code>number</code> – unless we use <code>as const</code> for the elements:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// Tuple</span></code>
<code><span class="hljs-keyword">const</span> value5 = [</code>
<code>  <span class="hljs-string">'a'</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>, <span class="hljs-number">1</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span></code>
<code>] satisfies [<span class="hljs-built_in">unknown</span>?, ...<span class="hljs-built_in">unknown</span>[]];</code>
<code>assertType&lt;</code>
<code>  [<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>]</code>
<code>&gt;(value5);</code>
</pre>
<p>If we omit the tuple element before the rest element (at the end), we are back to an Array type:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// Array</span></code>
<code><span class="hljs-keyword">const</span> value6 = [<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>] satisfies [...<span class="hljs-built_in">unknown</span>[]];</code>
<code>assertType&lt;</code>
<code>  (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[]</code>
<code>&gt;(value6);</code>
</pre>
<p>There is one other type we can use for tuples:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// Tuple</span></code>
<code><span class="hljs-keyword">const</span> value7 = [<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>] satisfies <span class="hljs-built_in">unknown</span>[] | [];</code>
<code>assertType&lt;</code>
<code>  [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>]</code>
<code>&gt;(value7);</code>
</pre>
<h4 id="using-readonly-to-accept-const-tuples"><a class="heading-id-link" href="#using-readonly-to-accept-const-tuples">37.2.3 Using <code>readonly</code> to accept const tuples</a></h4>
<p>If a type <code>T</code> is constrained to a normal array type then it doesn’t match the type of an <code>as const</code> literal:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Tuple</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">unknown</span>&gt;&gt; = T;</code>
<code><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code>
<code><span class="hljs-comment">// @ts-expect-error: Type 'readonly ["a", "b"]' does not satisfy</span></code>
<code><span class="hljs-comment">// the constraint 'unknown[]'.</span></code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Tuple</span>&lt;<span class="hljs-keyword">typeof</span> arr&gt;;</code>
</pre>
<p>We can change that by switching to a <code>ReadonlyArray</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Tuple</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">unknown</span>&gt;&gt; = T;</code>
<code><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span> = <span class="hljs-title class_">Tuple</span>&lt;<span class="hljs-keyword">typeof</span> arr&gt;;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Result</span>, <span class="hljs-keyword">readonly</span> [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]</code>
<code>&gt;&gt;;</code>
</pre>
<p>The following two notations are equivalent:</p>
<pre class="language-ts">
<code><span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">unknown</span>&gt;</code>
<code><span class="hljs-keyword">readonly</span> <span class="hljs-built_in">unknown</span>[]</code>
</pre>
<p>In this chapter, I don’t always make array types readonly because it adds visual clutter.</p>
<h4 id="enforcing-a-fixed-array-length"><a class="heading-id-link" href="#enforcing-a-fixed-array-length">37.2.4 Enforcing a fixed Array length</a></h4>
<p>We can use the following trick to enforce a fixed length for Array literals:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> join3&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>[] &amp; {<span class="hljs-attr">length</span>: <span class="hljs-number">3</span>}&gt;(...<span class="hljs-attr">strs</span>: T) {</code>
<code>  <span class="hljs-keyword">return</span> strs.<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>);</code>
<code>}</code>
<code><span class="hljs-title function_">join3</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>); <span class="hljs-comment">// OK</span></code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Argument of type '["a", "b"]' is not assignable</span></code>
<code><span class="hljs-comment">// to parameter of type 'string[] &amp; { length: 3; }'.</span></code>
<code><span class="hljs-title function_">join3</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>);</code>
</pre>
<p>The caveat is that this technique does not work if the <code>strs</code> come from a variable whose type is an Array:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];</code>
<code><span class="hljs-comment">// @ts-expect-error: Argument of type 'string[]' is not assignable</span></code>
<code><span class="hljs-comment">// to parameter of type 'string[] &amp; { length: 3; }'.</span></code>
<code><span class="hljs-title function_">join3</span>(...arr);</code>
</pre>
<p>In contrast, a tuple works:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> tuple = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code>
<code><span class="hljs-title function_">join3</span>(...tuple);</code>
</pre>
<h3 id="keyof-tuple-type"><a class="heading-id-link" href="#keyof-tuple-type">37.3 The keys of tuple types</a></h3>
<p>The keys of an Array type look like this (note the <code>Includes</code> in the first line):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Includes</span>&lt;</code>
<code>  keyof <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;,</code>
<code>  <span class="hljs-built_in">number</span> | <span class="hljs-string">'length'</span> | <span class="hljs-string">'push'</span> | <span class="hljs-string">'join'</span> <span class="hljs-comment">// ...</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>We can see keys for Array indices (<code>number</code>), <code>.length</code> and Array methods.</p>
<p>The keys of a tuple type are similar, but, in addition to the broad type <code>number</code> for indices, they also have one stringified number for each index:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Includes</span>&lt;</code>
<code>  keyof [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>],</code>
<code>  <span class="hljs-built_in">number</span> | <span class="hljs-string">'0'</span> | <span class="hljs-string">'1'</span> | <span class="hljs-string">'length'</span> | <span class="hljs-string">'push'</span> | <span class="hljs-string">'join'</span>  <span class="hljs-comment">// ...</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>Why are string literal types used and not number literal types? The latter disappear in a union with <code>number</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Includes</span>&lt;</code>
<code>  <span class="hljs-built_in">number</span> | <span class="hljs-number">0</span> | <span class="hljs-number">1</span>,</code>
<code>  <span class="hljs-built_in">number</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>Note that the ECMAScript specification also uses string keys for Array elements (<a href="https://exploringjs.com/js/book/ch_arrays.html#arrays-are-actually-dictionaries">more information</a>):</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>])</span></code>
<code>[ '0', '1' ]</code>
</pre>
<h4 id="TupleIndexKeys"><a class="heading-id-link" href="#TupleIndexKeys">37.3.1 Extracting the index keys (strings) of a tuple</a></h4>
<p>This utility type returns all string keys of a tuple <code>T</code> that are indices:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">TupleIndexKeys</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">unknown</span>&gt;&gt; =</code>
<code>  (keyof T) &amp; <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">number</span>}</span>`</span></code>
<code>;</code>
</pre>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">TupleIndexKeys</span>&lt;[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]&gt;,</code>
<code>  <span class="hljs-string">'0'</span> | <span class="hljs-string">'1'</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>We use <code>&amp;</code> to create the intersection type between the keys of <code>T</code> and the template literal type <code>`${number}`</code> – which is the type of all strings that are stringified numbers (see <a href="ch_template-literal-types.html#interpolating-primitive-types-into-template-literals">“Interpolating primitive types into template literals” (§38.2.5)</a>).</p>
<h4 id="TupleIndices"><a class="heading-id-link" href="#TupleIndices">37.3.2 Extracting the indices (numbers) of a tuple</a></h4>
<p>Getting a tuple’s numeric indices (numbers, not stringified numbers) is more work:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">TupleIndices</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">unknown</span>&gt;&gt; =</code>
<code>  <span class="hljs-title class_">StrToNum</span>&lt;keyof T&gt;</code>
<code>;</code>
</pre>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">TupleIndices</span>&lt;[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]&gt;,</code>
<code>  <span class="hljs-number">0</span> | <span class="hljs-number">1</span></code>
<code>&gt;&gt;;</code>
</pre>
<p><code>TupleIndices</code> uses the following helper type, which extracts string literal types with numbers and converts them to numbers.</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">StrToNum</span>&lt;T&gt; =</code>
<code>  T <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer N <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>}</span>`</span> ? N : <span class="hljs-built_in">never</span> <span class="hljs-comment">// (A)</span></code>
<code>;</code>
</pre>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">StrToNum</span>&lt;<span class="hljs-built_in">number</span> | <span class="hljs-string">'0'</span> | <span class="hljs-string">'1'</span> | <span class="hljs-string">'length'</span> | <span class="hljs-string">'push'</span> | <span class="hljs-string">'join'</span>&gt;,</code>
<code>  <span class="hljs-number">0</span> | <span class="hljs-number">1</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>In line A, <code>StrToNum</code> uses a template literal type plus <code>infer</code> to parse a number inside a string literal type. If there is no number, it returns <code>never</code>. Since the conditional type in line A is distributive, we can use it to filter a union type (as shown at the end).</p>
<h3 id="mapped-types-over-tuples"><a class="heading-id-link" href="#mapped-types-over-tuples">37.4 Mapping tuples via mapped types</a></h3>
<p>A mapped type has the following syntax:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">MapOverType</span>&lt;<span class="hljs-title class_">Type</span>&gt; = {</code>
<code>  [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Type</span>]: <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Type</span>[<span class="hljs-title class_">Key</span>]&gt;</code>
<code>};</code>
</pre>
<h4 id="how-a-mapped-type-handles-the-keys-of-a-tuple-type"><a class="heading-id-link" href="#how-a-mapped-type-handles-the-keys-of-a-tuple-type">37.4.1 How a mapped type handles the keys of a tuple type</a></h4>
<p>Recall that <code>keyof</code>, applied to a tuple, produces <a href="#keyof-tuple-type">a variety of values</a>: method names, stringified indices, etc.</p>
<p>In its basic form, a mapped type helps us with tuples in two ways:</p>
<ul>
  <li>
    First, it filters the keys and only loops over string index keys (<code>'0'</code>, <code>'1'</code>, etc.).
  </li>
  <li>
    Second, it returns a tuple (not an object literal type).
  </li>
</ul>
<p>The following example demonstrates both phenomena. <code>KeyToKey&lt;T&gt;</code> returns a tuple whose elements are the string index keys of the tuple <code>T</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">KeyToKey</span>&lt;T&gt; = {</code>
<code>  [K <span class="hljs-keyword">in</span> keyof T]: K</code>
<code>};</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">KeyToKey</span>&lt;[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]&gt;,</code>
<code>  <span class="hljs-comment">// Result is a tuple</span></code>
<code>  [<span class="hljs-string">'0'</span>, <span class="hljs-string">'1'</span>]</code>
<code>&gt;&gt;;</code>
</pre>
<h4 id="mapping-preserves-the-labels-of-tuple-elements"><a class="heading-id-link" href="#mapping-preserves-the-labels-of-tuple-elements">37.4.2 Mapping preserves the labels of tuple elements</a></h4>
<p>Mapping preserves the labels of tuple elements:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">WrapValues</span>&lt;T&gt; = {</code>
<code>  [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof T]: <span class="hljs-title class_">Promise</span>&lt;T[<span class="hljs-title class_">Key</span>]&gt;</code>
<code>};</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">WrapValues</span>&lt;[<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>]&gt;,</code>
<code>  [<span class="hljs-attr">a</span>: <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">number</span>&gt;, <span class="hljs-attr">b</span>: <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">number</span>&gt;]</code>
<code>&gt;&gt;;</code>
</pre>
<h4 id="tuples-and-mapped-types-with-key-remapping-as"><a class="heading-id-link" href="#tuples-and-mapped-types-with-key-remapping-as">37.4.3 Tuples and mapped types with key remapping (<code>as</code>)</a></h4>
<p>If we use key remapping (<code>as</code>) in a mapped type over a tuple then the result won’t be a tuple anymore and all keys of a tuple will be considered (vs. only its indices):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">KeyAsKeyToKey</span>&lt;T&gt; = {</code>
<code>  [K <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> K]: K</code>
<code>};</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-comment">// Use Pick&lt;&gt; because result of KeyAsKeyToKey&lt;&gt; is large</span></code>
<code>  <span class="hljs-title class_">Pick</span>&lt;</code>
<code>    <span class="hljs-title class_">KeyAsKeyToKey</span>&lt;[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]&gt;,</code>
<code>    <span class="hljs-string">'0'</span> | <span class="hljs-string">'1'</span> | <span class="hljs-string">'length'</span> | <span class="hljs-string">'push'</span> | <span class="hljs-string">'join'</span></code>
<code>  &gt;,</code>
<code>  <span class="hljs-comment">// Result is an object, not a tuple</span></code>
<code>  {</code>
<code>    <span class="hljs-attr">length</span>: <span class="hljs-string">'length'</span>;</code>
<code>    <span class="hljs-attr">push</span>: <span class="hljs-string">'push'</span>;</code>
<code>    <span class="hljs-attr">join</span>: <span class="hljs-string">'join'</span>;</code>
<code>    <span class="hljs-number">0</span>: <span class="hljs-string">'0'</span>;</code>
<code>    <span class="hljs-number">1</span>: <span class="hljs-string">'1'</span>;</code>
<code>  }</code>
<code>&gt;&gt;;</code>
</pre>
<p>If we want to stick with tuple indices, we have to filter the result of <code>keyof</code>. To do that, we can use the utility types <code>TupleIndexKeys</code> that we have defined previously:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">StringTupleToObject</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; = {</code>
<code>  [K <span class="hljs-keyword">in</span> <span class="hljs-title class_">TupleIndexKeys</span>&lt;T&gt; <span class="hljs-keyword">as</span> T[K]]: K</code>
<code>};</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">StringTupleToObject</span>&lt;[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]&gt;,</code>
<code>  {</code>
<code>    <span class="hljs-attr">a</span>: <span class="hljs-string">'0'</span>,</code>
<code>    <span class="hljs-attr">b</span>: <span class="hljs-string">'1'</span>,</code>
<code>  }</code>
<code>&gt;&gt;;</code>
</pre>
<p>Note that <code>TupleIndices</code> returns string literal types – which explains the property values. If we prefer number literal types, we can use the previously defined utility type <code>TupleIndices</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">StringTupleToObject</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; = {</code>
<code>  [K <span class="hljs-keyword">in</span> <span class="hljs-title class_">TupleIndices</span>&lt;T&gt; <span class="hljs-keyword">as</span> T[K]]: K</code>
<code>};</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">StringTupleToObject</span>&lt;[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]&gt;,</code>
<code>  {</code>
<code>    <span class="hljs-attr">a</span>: <span class="hljs-number">0</span>,</code>
<code>    <span class="hljs-attr">b</span>: <span class="hljs-number">1</span>,</code>
<code>  }</code>
<code>&gt;&gt;;</code>
</pre>
<h4 id="typing-Promise.all"><a class="heading-id-link" href="#typing-Promise.all">37.4.4 Example: typing <code>Promise.all()</code></a></h4>
<p>This is what the type for <code>Promise.all()</code> looks like (I edited <a href="https://github.com/microsoft/TypeScript/blob/main/src/lib/es2015.promise.d.ts">the actual code</a> slightly):</p>
<p>We will use the following helper type which unwraps the Promises in a tuple:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">AwaitedTuple</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">unknown</span>&gt;&gt; = {</code>
<code>  -<span class="hljs-keyword">readonly</span> [K <span class="hljs-keyword">in</span> keyof T]: <span class="hljs-title class_">Awaited</span>&lt;T[K]&gt; <span class="hljs-comment">// (A)</span></code>
<code>}</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">AwaitedTuple</span>&lt;<span class="hljs-keyword">readonly</span> [<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">number</span>&gt;, <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;]&gt;,</code>
<code>  [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>]</code>
<code>&gt;&gt;;</code>
</pre>
<p>Notes:</p>
<ul>
  <li>
    The <code>-readonly</code> in line A removes that modifier from each tuple element and therefore from the whole tuple.
  </li>
  <li>
    The built-in utility type <code>Awaited</code> (used in line A) works like <code>await</code> and (roughly) unwraps Promises.
  </li>
</ul>
<p>With that helper type, our version of <code>Promise.all()</code> is easy to type:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> promiseAll&lt;</code>
<code>  T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">unknown</span>&gt; | [] <span class="hljs-comment">// (A)</span></code>
<code>&gt;(<span class="hljs-attr">values</span>: T): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">AwaitedTuple</span>&lt;T&gt;&gt; {</code>
<code>  <span class="hljs-comment">// ···</span></code>
<code>}</code>
<code><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">promiseAll</span>(</code>
<code>  [<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">123</span>), <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'abc'</span>)]</code>
<code>);</code>
<code>assertType&lt;<span class="hljs-title class_">Promise</span>&lt;[<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>]&gt;&gt;(result);</code>
</pre>
<p>The constraint after <code>extends</code> in line A achieves two things:</p>
<ul>
  <li>
    <code>readonly</code> means that read-only <code>values</code> are also accepted, not just mutable <code>values</code>.
  </li>
  <li>
    <code>unknown[] | []</code> means that Array literals are interpreted as tuples.
  </li>
</ul>
<h3 id="extracting-union-types-from-tuples"><a class="heading-id-link" href="#extracting-union-types-from-tuples">37.5 Extracting union types from tuples</a></h3>
<h4 id="from-tuple-to-union"><a class="heading-id-link" href="#from-tuple-to-union">37.5.1 Applying the indexed access operator <code>T[K]</code> to a tuple</a></h4>
<p>If we apply <a href="ch_computing-with-types-overview.html#indexed-access-types">the indexed access operator <code>T[K]</code></a> to a tuple, we get the tuple elements as a union:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">UnionOf</span>&lt;<span class="hljs-title class_">Tup</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">unknown</span>&gt;&gt; = <span class="hljs-title class_">Tup</span>[<span class="hljs-built_in">number</span>];</code>
<code/>
<code><span class="hljs-keyword">const</span> flowers = [<span class="hljs-string">'rose'</span>, <span class="hljs-string">'sunflower'</span>, <span class="hljs-string">'lavender'</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">UnionOf</span>&lt;<span class="hljs-keyword">typeof</span> flowers&gt;,</code>
<code>  <span class="hljs-string">'rose'</span> | <span class="hljs-string">'sunflower'</span> | <span class="hljs-string">'lavender'</span></code>
<code>&gt;&gt;;</code>
</pre>
<h4 id="from-tuple-of-tuples-to-union"><a class="heading-id-link" href="#from-tuple-of-tuples-to-union">37.5.2 Extracting a union from a tuple of tuples</a></h4>
<p>Sometimes, it makes sense to encode data as a collection of tuples – e.g. when we want to look up a tuple by any of its elements and performance is not as important. In contrast, Maps only support lookup by key well.</p>
<p>For Maps, it’s easy to compute the keys and the values – which we can use to constrain values when looking up data. Can we do the same for a tuple of tuples? We can, if we use the indexed access operator <code>T[K]</code> twice:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> englishSpanishGerman = [</code>
<code>  [<span class="hljs-string">'yes'</span>, <span class="hljs-string">'sí'</span>, <span class="hljs-string">'ja'</span>],</code>
<code>  [<span class="hljs-string">'no'</span>, <span class="hljs-string">'no'</span>, <span class="hljs-string">'nein'</span>],</code>
<code>  [<span class="hljs-string">'maybe'</span>, <span class="hljs-string">'tal vez'</span>, <span class="hljs-string">'vielleicht'</span>],</code>
<code>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code>
<code/>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">English</span> = (<span class="hljs-keyword">typeof</span> englishSpanishGerman)[<span class="hljs-built_in">number</span>][<span class="hljs-number">0</span>];</code>
<code><span class="hljs-keyword">type</span> _1 = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">English</span>, <span class="hljs-string">'yes'</span> | <span class="hljs-string">'no'</span> | <span class="hljs-string">'maybe'</span></code>
<code>&gt;&gt;;</code>
<code/>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Spanish</span> = (<span class="hljs-keyword">typeof</span> englishSpanishGerman)[<span class="hljs-built_in">number</span>][<span class="hljs-number">1</span>];</code>
<code><span class="hljs-keyword">type</span> _2 = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Spanish</span>, <span class="hljs-string">'sí'</span> | <span class="hljs-string">'no'</span> | <span class="hljs-string">'tal vez'</span></code>
<code>&gt;&gt;;</code>
</pre>
<h4 id="from-tuple-of-objects-to-union"><a class="heading-id-link" href="#from-tuple-of-objects-to-union">37.5.3 Extracting a union from a tuple of objects</a></h4>
<p>The same approach works for a tuple of objects:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> listCounterStyles = [</code>
<code>  { <span class="hljs-attr">name</span>: <span class="hljs-string">'upperRoman'</span>, <span class="hljs-attr">regExp</span>: <span class="hljs-regexp">/^[IVXLCDM]+$/</span> },</code>
<code>  { <span class="hljs-attr">name</span>: <span class="hljs-string">'lowerRoman'</span>, <span class="hljs-attr">regExp</span>: <span class="hljs-regexp">/^[ivxlcdm]+$/</span> },</code>
<code>  { <span class="hljs-attr">name</span>: <span class="hljs-string">'upperLatin'</span>, <span class="hljs-attr">regExp</span>: <span class="hljs-regexp">/^[A-Z]$/</span> },</code>
<code>  { <span class="hljs-attr">name</span>: <span class="hljs-string">'lowerLatin'</span>, <span class="hljs-attr">regExp</span>: <span class="hljs-regexp">/^[a-z]$/</span> },</code>
<code>  { <span class="hljs-attr">name</span>: <span class="hljs-string">'decimal'</span>,    <span class="hljs-attr">regExp</span>: <span class="hljs-regexp">/^[0-9]+$/</span> },</code>
<code>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span> satisfies <span class="hljs-title class_">Array</span>&lt;{<span class="hljs-attr">regExp</span>: <span class="hljs-title class_">RegExp</span>, <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>}&gt;;</code>
<code/>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">CounterNames</span> = (<span class="hljs-keyword">typeof</span> listCounterStyles)[<span class="hljs-built_in">number</span>][<span class="hljs-string">'name'</span>];</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">CounterNames</span>,</code>
<code>  | <span class="hljs-string">'upperRoman'</span> | <span class="hljs-string">'lowerRoman'</span></code>
<code>  | <span class="hljs-string">'upperLatin'</span> | <span class="hljs-string">'lowerLatin'</span></code>
<code>  | <span class="hljs-string">'decimal'</span></code>
<code>&gt;&gt;;</code>
</pre>
<h3 id="computing-with-tuple-types-1"><a class="heading-id-link" href="#computing-with-tuple-types-1">37.6 Computing with tuple types</a></h3>
<ul>
  <li>
    In this section, we’ll explore computing with tuple types via small examples.
  </li>
  <li>
    In the next section, we’ll look at real-world use cases for this kind of computation.
  </li>
</ul>
<h4 id="extracting-parts-of-tuples"><a class="heading-id-link" href="#extracting-parts-of-tuples">37.6.1 Extracting parts of tuples</a></h4>
<p>To extract parts of tuples, we use <code>infer</code>.</p>
<h5 id="extracting-the-first-element-of-a-tuple"><a class="heading-id-link" href="#extracting-the-first-element-of-a-tuple">37.6.1.1 Extracting the first element of a tuple</a></h5>
<p>We infer the first element and ignore all other elements by using <code>unknown</code> as a wildcard type that matches anything.</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">First</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">unknown</span>&gt;&gt; =</code>
<code>T <span class="hljs-keyword">extends</span> [infer F, ...<span class="hljs-built_in">unknown</span>[]]</code>
<code>  ? F</code>
<code>  : <span class="hljs-built_in">never</span></code>
<code>;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">First</span>&lt;[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]&gt;,</code>
<code>  <span class="hljs-string">'a'</span></code>
<code>&gt;&gt;;</code>
</pre>
<h5 id="extracting-the-last-element-of-a-tuple"><a class="heading-id-link" href="#extracting-the-last-element-of-a-tuple">37.6.1.2 Extracting the last element of a tuple</a></h5>
<p>The approach we used to extract the first element (in the previous example) also works for extracting the last element:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Last</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">unknown</span>&gt;&gt; =</code>
<code>T <span class="hljs-keyword">extends</span> [...<span class="hljs-built_in">unknown</span>[], infer L]</code>
<code>  ? L</code>
<code>  : <span class="hljs-built_in">never</span></code>
<code>;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Last</span>&lt;[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]&gt;,</code>
<code>  <span class="hljs-string">'c'</span></code>
<code>&gt;&gt;;</code>
</pre>
<h5 id="extracting-the-rest-of-a-tuple-elements-after-the-first-one"><a class="heading-id-link" href="#extracting-the-rest-of-a-tuple-elements-after-the-first-one">37.6.1.3 Extracting the <em>rest</em> of a tuple (elements after the first one)</a></h5>
<p>To extract the <em>rest</em> of a tuple (the elements after the first one), we make use the wildcard type <code>unknown</code> for the first element and infer what is spread after it:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Rest</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">unknown</span>&gt;&gt; =</code>
<code>T <span class="hljs-keyword">extends</span> [<span class="hljs-built_in">unknown</span>, ...infer R]</code>
<code>  ? R</code>
<code>  : <span class="hljs-built_in">never</span></code>
<code>;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Rest</span>&lt;[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]&gt;,</code>
<code>  [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]</code>
<code>&gt;&gt;;</code>
</pre>
<h4 id="tuple-lookup-table"><a class="heading-id-link" href="#tuple-lookup-table">37.6.2 Using a tuple of pairs as a lookup table</a></h4>
<p>For many purposes, object literal types are very convenient as lookup tables: At the type level, lookup only works if keys are strings, numbers or symbols. Additionally, TypeScript doesn’t distinguish between strings and numbers. That mirrors how JavaScript works and prevents us from distinguishing between the number <code>1</code> and the string <code>'1'</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">LookupTable</span> = {</code>
<code>  [<span class="hljs-number">1</span>]: <span class="hljs-string">'a'</span>,</code>
<code>};</code>
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">LookupTable</span>[<span class="hljs-number">1</span>], <span class="hljs-string">'a'</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">LookupTable</span>[<span class="hljs-string">'1'</span>], <span class="hljs-string">'a'</span></code>
<code>  &gt;&gt;,</code>
<code>];</code>
</pre>
<p>As an alternative, we can use a tuple of pairs (tuples with two elements) as a lookup table:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">LookupTable</span> = [</code>
<code>  [<span class="hljs-literal">undefined</span>, <span class="hljs-string">'undefined'</span>],</code>
<code>  [<span class="hljs-literal">null</span>, <span class="hljs-string">'null'</span>],</code>
<code>  [<span class="hljs-built_in">boolean</span>, <span class="hljs-string">'boolean'</span>],</code>
<code>  [<span class="hljs-built_in">number</span>, <span class="hljs-string">'number'</span>],</code>
<code>  [<span class="hljs-built_in">bigint</span>, <span class="hljs-string">'bigint'</span>],</code>
<code>  [<span class="hljs-built_in">string</span>, <span class="hljs-string">'string'</span>],</code>
<code>];</code>
<code><span class="hljs-keyword">type</span> R = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Lookup</span>&lt;<span class="hljs-title class_">LookupTable</span>, <span class="hljs-built_in">string</span>&gt;, <span class="hljs-string">'string'</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>These are the types that implement the lookup functionality:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">LookupOne</span>&lt;<span class="hljs-title class_">Pair</span> <span class="hljs-keyword">extends</span> <span class="hljs-keyword">readonly</span> [<span class="hljs-built_in">unknown</span>, <span class="hljs-built_in">unknown</span>], <span class="hljs-title class_">Key</span>&gt; =</code>
<code>  <span class="hljs-title class_">Pair</span> <span class="hljs-keyword">extends</span> [<span class="hljs-title class_">Key</span>, infer <span class="hljs-title class_">Value</span>] ? <span class="hljs-title class_">Value</span> : <span class="hljs-built_in">never</span>;</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Lookup</span>&lt;<span class="hljs-title class_">Table</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-keyword">readonly</span> [<span class="hljs-built_in">unknown</span>, <span class="hljs-built_in">unknown</span>]&gt;, <span class="hljs-title class_">Key</span>&gt; =</code>
<code>  <span class="hljs-title class_">LookupOne</span>&lt;<span class="hljs-title class_">Table</span>[<span class="hljs-built_in">number</span>], <span class="hljs-title class_">Key</span>&gt;;</code>
</pre>
<p>How does that work? Step 1: Go from a tuple of pairs to a union of pairs via <a href="ch_computing-with-types-overview.html#indexed-access-types">an indexed access type (<code>T[K]</code>)</a>.</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _1 = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">LookupTable</span>[<span class="hljs-built_in">number</span>],</code>
<code>  | [<span class="hljs-literal">undefined</span>, <span class="hljs-string">'undefined'</span>]</code>
<code>  | [<span class="hljs-literal">null</span>, <span class="hljs-string">'null'</span>]</code>
<code>  | [<span class="hljs-built_in">boolean</span>, <span class="hljs-string">'boolean'</span>]</code>
<code>  | [<span class="hljs-built_in">number</span>, <span class="hljs-string">'number'</span>]</code>
<code>  | [<span class="hljs-built_in">bigint</span>, <span class="hljs-string">'bigint'</span>]</code>
<code>  | [<span class="hljs-built_in">string</span>, <span class="hljs-string">'string'</span>]</code>
<code>&gt;&gt;;</code>
</pre>
<p>Step 2: Apply <code>LookupOne</code> to each of the pairs. That happens automatically if we apply that generic type to the union because its conditional type is <a href="ch_conditional-types.html#distributivity-of-conditional-types">distributive</a>: </p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _2 = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">LookupOne</span>&lt;[<span class="hljs-literal">undefined</span>, <span class="hljs-string">'undefined'</span>], <span class="hljs-built_in">string</span>&gt;,</code>
<code>    <span class="hljs-built_in">never</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">LookupOne</span>&lt;[<span class="hljs-built_in">string</span>, <span class="hljs-string">'string'</span>], <span class="hljs-built_in">string</span>&gt;,</code>
<code>    <span class="hljs-string">'string'</span></code>
<code>  &gt;&gt;,</code>
<code>];</code>
</pre>
<p>Step 3: Since <a href="ch_never.html#never-is-the-empty-set"><code>never</code> is the empty set</a>, we get the final result <code>'string'</code> after the intermediate result of the distributed application of <code>LookupOne</code> is evaluated:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _3 = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-built_in">never</span> | <span class="hljs-built_in">never</span> | <span class="hljs-built_in">never</span> | <span class="hljs-built_in">never</span> | <span class="hljs-built_in">never</span> | <span class="hljs-string">'string'</span>,</code>
<code>  <span class="hljs-string">'string'</span> <span class="hljs-comment">// final result</span></code>
<code>&gt;&gt;;</code>
</pre>
<h4 id="concatenating-tuples"><a class="heading-id-link" href="#concatenating-tuples">37.6.3 Concatenating tuples</a></h4>
<p>To concatenate two tuples <code>T1</code> and <code>T2</code>, we spread them both:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Concat</span>&lt;<span class="hljs-variable constant_">T1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">unknown</span>&gt;, <span class="hljs-variable constant_">T2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">unknown</span>&gt;&gt; =</code>
<code>  [...<span class="hljs-variable constant_">T1</span>, ...<span class="hljs-variable constant_">T2</span>]</code>
<code>;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Concat</span>&lt;[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>], [<span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>]&gt;,</code>
<code>  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>]</code>
<code>&gt;&gt;;</code>
</pre>
<h4 id="recursion-over-tuples"><a class="heading-id-link" href="#recursion-over-tuples">37.6.4 Recursion over tuples</a></h4>
<p>To explore recursion over tuples, let’s implement wrapping tuple elements with recursion (where we previously used a mapped type):</p>
<p>Recursing over tuples in TypeScript </p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">WrapValues</span>&lt;<span class="hljs-title class_">Tup</span>&gt; =</code>
<code>  <span class="hljs-title class_">Tup</span> <span class="hljs-keyword">extends</span> [infer <span class="hljs-title class_">First</span>, ...infer <span class="hljs-title class_">Rest</span>] <span class="hljs-comment">// (A)</span></code>
<code>    ? [<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">First</span>&gt;, ...<span class="hljs-title class_">WrapValues</span>&lt;<span class="hljs-title class_">Rest</span>&gt;] <span class="hljs-comment">// (B)</span></code>
<code>    : [] <span class="hljs-comment">// (C)</span></code>
<code>;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">WrapValues</span>&lt;[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]&gt;,</code>
<code>  [<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-string">'a'</span>&gt;, <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-string">'b'</span>&gt;, <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-string">'c'</span>&gt;]</code>
<code>&gt;&gt;;</code>
</pre>
<p>We use a technique that is inspired by how functional programming languages recurse over lists:</p>
<ul>
  <li>
    <p>Line A: We check whether we can split <code>Tup</code> into the first element <code>First</code> and the remaining elements <code>Rest</code>.</p>
  </li>
  <li>
    <p>Line B: If yes then <code>Tup</code> has at least one element. We return a tuple whose first element is the wrapped <code>First</code> and whose remaining elements are computed by a self-recursive call.</p>
  </li>
  <li>
    <p>Line C: If no then <code>Tup</code> is empty. We return an empty tuple.</p>
  </li>
</ul>
<p>In functional programming, <code>First</code> is often called <code>Head</code> and <code>Rest</code> is often called <code>Tail</code>.</p>
<h5 id="flattening-a-tuple-of-tuples"><a class="heading-id-link" href="#flattening-a-tuple-of-tuples">37.6.4.1 Flattening a tuple of tuples</a></h5>
<p>Let’s use recursion to flatten a tuple of tuples:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Flatten</span>&lt;<span class="hljs-title class_">Tups</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">unknown</span>&gt;&gt;&gt; =</code>
<code>  <span class="hljs-title class_">Tups</span> <span class="hljs-keyword">extends</span> [</code>
<code>    infer <span class="hljs-title class_">Tup</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">unknown</span>&gt;, <span class="hljs-comment">// (A)</span></code>
<code>    ...infer <span class="hljs-title class_">Rest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">unknown</span>&gt;&gt; <span class="hljs-comment">// (B)</span></code>
<code>  ]</code>
<code>    ? [...<span class="hljs-title class_">Tup</span>, ...<span class="hljs-title class_">Flatten</span>&lt;<span class="hljs-title class_">Rest</span>&gt;]</code>
<code>    : []</code>
<code>;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Flatten</span>&lt;[[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>], [<span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>], [<span class="hljs-string">'e'</span>]]&gt;,</code>
<code>  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>]</code>
<code>&gt;&gt;;</code>
</pre>
<p>In this case, the inferred types <code>Tup</code> and <code>Rest</code> are more complex – which is why TypeScript complains if we don’t use <code>extends</code> (line A, line B) to constrain them.</p>
<h5 id="filtering-tuples"><a class="heading-id-link" href="#filtering-tuples">37.6.4.2 Filtering a tuple</a></h5>
<p>The following code uses recursion to filter out empty strings in a tuple:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">RemoveEmptyStrings</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; =</code>
<code>  T <span class="hljs-keyword">extends</span> [</code>
<code>    infer <span class="hljs-title class_">First</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>,</code>
<code>    ...infer <span class="hljs-title class_">Rest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;</code>
<code>  ]</code>
<code>    ? <span class="hljs-title class_">First</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">''</span></code>
<code>      ? <span class="hljs-title class_">RemoveEmptyStrings</span>&lt;<span class="hljs-title class_">Rest</span>&gt;</code>
<code>      : [<span class="hljs-title class_">First</span>, ...<span class="hljs-title class_">RemoveEmptyStrings</span>&lt;<span class="hljs-title class_">Rest</span>&gt;]</code>
<code>    : []</code>
<code>;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">RemoveEmptyStrings</span>&lt;[<span class="hljs-string">''</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">''</span>]&gt;,</code>
<code>  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]</code>
<code>&gt;&gt;;</code>
</pre>
<p>Note that we have to use recursion for filtering. There are two reasons why using a mapped type and key remapping via <code>as</code> won’t work:</p>
<ul>
  <li>
    Due to <code>as</code>, such a type constructs an object type, not a tuple type.
  </li>
  <li>
    Mapping preserves the indices, so removing properties leaves gaps.
  </li>
</ul>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">RemoveEmptyStrings</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; = {</code>
<code>  [K <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> (T[K] <span class="hljs-keyword">extends</span> <span class="hljs-string">''</span> ? <span class="hljs-built_in">never</span> : K)]: T[K]</code>
<code>};</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Filtered</span> = <span class="hljs-title class_">RemoveEmptyStrings</span>&lt;[<span class="hljs-string">''</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">''</span>]&gt;</code>
<code>  <span class="hljs-comment">// type Filtered = {</span></code>
<code>  <span class="hljs-comment">//   [x: number]: "" | "a" | "b";</span></code>
<code>  <span class="hljs-comment">//   1: "a";</span></code>
<code>  <span class="hljs-comment">//   3: "b";</span></code>
<code>  <span class="hljs-comment">//   length: 5;</span></code>
<code>  <span class="hljs-comment">//   toString: () =&gt; string;</span></code>
<code>  <span class="hljs-comment">//   ...</span></code>
<code>  <span class="hljs-comment">// }</span></code>
</pre>
<h5 id="utility-type-Repeat"><a class="heading-id-link" href="#utility-type-Repeat">37.6.4.3 Creating a tuple with a given length</a></h5>
<p>If we want to create a tuple that has a given length <code>Len</code>, we are faced with a challenge: How do we know when to stop? We can’t decrement <code>Len</code>, we can only check if it is equal to a given value (line A):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Repeat</span>&lt;</code>
<code>  <span class="hljs-title class_">Len</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>, <span class="hljs-title class_">Value</span>,</code>
<code>  <span class="hljs-title class_">Acc</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">unknown</span>&gt; = []</code>
<code>&gt; = </code>
<code>  <span class="hljs-title class_">Acc</span>[<span class="hljs-string">'length'</span>] <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Len</span> <span class="hljs-comment">// (A)</span></code>
<code>    ? <span class="hljs-title class_">Acc</span> <span class="hljs-comment">// (B)</span></code>
<code>    : <span class="hljs-title class_">Repeat</span>&lt;<span class="hljs-title class_">Len</span>, <span class="hljs-title class_">Value</span>, [...<span class="hljs-title class_">Acc</span>, <span class="hljs-title class_">Value</span>]&gt; <span class="hljs-comment">// (C)</span></code>
<code>;</code>
<code/>
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">Repeat</span>&lt;<span class="hljs-number">3</span>, <span class="hljs-string">'*'</span>&gt;,</code>
<code>    [<span class="hljs-string">'*'</span>, <span class="hljs-string">'*'</span>, <span class="hljs-string">'*'</span>]</code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">Repeat</span>&lt;<span class="hljs-number">3</span>, <span class="hljs-built_in">string</span>&gt;,</code>
<code>    [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>]</code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">Repeat</span>&lt;<span class="hljs-number">3</span>, <span class="hljs-built_in">unknown</span>&gt;,</code>
<code>    [<span class="hljs-built_in">unknown</span>, <span class="hljs-built_in">unknown</span>, <span class="hljs-built_in">unknown</span>]</code>
<code>  &gt;&gt;,</code>
<code>];</code>
</pre>
<p>How does this code work? We use another functional programming technique and introduce an internal <em>accumulator</em> parameter <code>Acc</code>:</p>
<ul>
  <li>
    While recursion is still ongoing, we assemble the eventual result in <code>Acc</code> (line C).
  </li>
  <li>
    One the length of <code>Acc</code> is equal to <code>Len</code> (line A), we are done and can return <code>Acc</code> (line B).
  </li>
</ul>
<h5 id="computing-a-range-of-numbers"><a class="heading-id-link" href="#computing-a-range-of-numbers">37.6.4.4 Computing a range of numbers</a></h5>
<p>We can use the same technique to compute a range of numbers. Only this time, we append the current length of the accumulator to the accumulator:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">NumRange</span>&lt;<span class="hljs-title class_">Upper</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>, <span class="hljs-title class_">Acc</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>[] = []&gt; =</code>
<code>  <span class="hljs-title class_">Upper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Acc</span>[<span class="hljs-string">'length'</span>]</code>
<code>    ? <span class="hljs-title class_">Acc</span></code>
<code>    : <span class="hljs-title class_">NumRange</span>&lt;<span class="hljs-title class_">Upper</span>, [...<span class="hljs-title class_">Acc</span>, <span class="hljs-title class_">Acc</span>[<span class="hljs-string">'length'</span>]]&gt;</code>
<code>;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">NumRange</span>&lt;<span class="hljs-number">3</span>&gt;,</code>
<code>  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]</code>
<code>&gt;&gt;;</code>
</pre>
<h5 id="dropping-initial-elements"><a class="heading-id-link" href="#dropping-initial-elements">37.6.4.5 Dropping initial elements</a></h5>
<p>This is one way of implementing a utility type that removes the first <code>Num</code> elements of a <code>Tuple</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Drop</span>&lt;</code>
<code>  <span class="hljs-title class_">Tuple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">unknown</span>&gt;,</code>
<code>  <span class="hljs-title class_">Num</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>,</code>
<code>  <span class="hljs-title class_">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">boolean</span>&gt; = []</code>
<code>&gt; =</code>
<code>  <span class="hljs-title class_">Counter</span>[<span class="hljs-string">'length'</span>] <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Num</span></code>
<code>    ? <span class="hljs-title class_">Tuple</span></code>
<code>    : <span class="hljs-title class_">Tuple</span> <span class="hljs-keyword">extends</span> [<span class="hljs-built_in">unknown</span>, ...infer <span class="hljs-title class_">Rest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">unknown</span>&gt;]</code>
<code>      ? <span class="hljs-title class_">Drop</span>&lt;<span class="hljs-title class_">Rest</span>, <span class="hljs-title class_">Num</span>, [<span class="hljs-literal">true</span>, ...<span class="hljs-title class_">Counter</span>]&gt;</code>
<code>      : <span class="hljs-title class_">Tuple</span></code>
<code>;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Drop</span>&lt;[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>], <span class="hljs-number">2</span>&gt;,</code>
<code>  [<span class="hljs-string">'c'</span>]</code>
<code>&gt;&gt;;</code>
</pre>
<p>This time, we use the accumulator variable <code>Counter</code> to count up – until Counter['length'] is equal to <code>Num</code>.</p>
<p>We can also use inference (<a href="https://mastodon.social/@hcschuetz/113906317654567023">idea</a> by Heribert Schütz):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Drop</span>&lt;</code>
<code>  <span class="hljs-title class_">Tuple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">unknown</span>&gt;,</code>
<code>  <span class="hljs-title class_">Num</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span></code>
<code>&gt; =</code>
<code>  <span class="hljs-title class_">Tuple</span> <span class="hljs-keyword">extends</span> [...<span class="hljs-title class_">Repeat</span>&lt;<span class="hljs-title class_">Num</span>, <span class="hljs-built_in">unknown</span>&gt;, ...infer <span class="hljs-title class_">Rest</span>]</code>
<code>    ? <span class="hljs-title class_">Rest</span></code>
<code>    : <span class="hljs-built_in">never</span></code>
<code>;</code>
</pre>
<p>We use <a href="#utility-type-Repeat">the utility type <code>Repeat</code></a> to compute a tuple where each element is the wildcard type <code>unknown</code> that matches any type. Then we match <code>Tuple</code> against a tuple pattern that begins with those elements. The remaining elements are the result we are looking for and we extract it via <code>infer</code>.</p>
<h3 id="real-world-examples"><a class="heading-id-link" href="#real-world-examples">37.7 Real-world examples</a></h3>
<h4 id="applyPartial"><a class="heading-id-link" href="#applyPartial">37.7.1 Partial application that preserves parameter names</a></h4>
<p>Let’s implement the function <code>applyPartial(func, args)</code> for partially applying a function <code>func</code>. It works similarly to the function method <code>.bind()</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> applyPartial&lt;</code>
<code>  <span class="hljs-title class_">Func</span> <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span>,</code>
<code>  <span class="hljs-title class_">InitialArgs</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[],</code>
<code>&gt;(<span class="hljs-attr">func</span>: <span class="hljs-title class_">Func</span>, ...<span class="hljs-attr">initialArgs</span>: <span class="hljs-title class_">InitialArgs</span>) {</code>
<code>  <span class="hljs-keyword">return</span> (...<span class="hljs-attr">remainingArgs</span>: <span class="hljs-title class_">RemainingArgs</span>&lt;<span class="hljs-title class_">Func</span>, <span class="hljs-title class_">InitialArgs</span>&gt;)</code>
<code>  : <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-title class_">Func</span>&gt; =&gt; {</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">func</span>(...initialArgs, ...remainingArgs);</code>
<code>  };</code>
<code>}</code>
<code/>
<code><span class="hljs-comment">//----- Test -----</span></code>
<code/>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {</code>
<code>  <span class="hljs-keyword">return</span> x + y;</code>
<code>}</code>
<code><span class="hljs-keyword">const</span> add3 = <span class="hljs-title function_">applyPartial</span>(add, <span class="hljs-number">3</span>);</code>
<code><span class="hljs-keyword">type</span> _1 = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-keyword">typeof</span> add3,</code>
<code>  <span class="hljs-comment">// The parameter name is preserved!</span></code>
<code>  <span class="hljs-function">(<span class="hljs-params">y: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>We return a partially applied <code>func</code>. To compute the type for the parameter <code>remainingArgs</code>, we remove the <code>InitialArgs</code> from the arguments of <code>Func</code> – via the following utility type:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">RemainingArgs</span>&lt;</code>
<code>  <span class="hljs-title class_">Func</span> <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span>,</code>
<code>  <span class="hljs-title class_">InitialArgs</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[],</code>
<code>&gt; =</code>
<code>  <span class="hljs-title class_">Func</span> <span class="hljs-keyword">extends</span> (</code>
<code>    ...<span class="hljs-attr">args</span>: [...<span class="hljs-title class_">InitialArgs</span>,</code>
<code>    ...infer <span class="hljs-title class_">TrailingArgs</span>]</code>
<code>  ) =&gt; <span class="hljs-built_in">unknown</span></code>
<code>    ? <span class="hljs-title class_">TrailingArgs</span></code>
<code>    : <span class="hljs-built_in">never</span></code>
<code>;</code>
<code/>
<code><span class="hljs-comment">//----- Test -----</span></code>
<code/>
<code><span class="hljs-keyword">type</span> _2 = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">RemainingArgs</span>&lt;<span class="hljs-keyword">typeof</span> add, [<span class="hljs-built_in">number</span>]&gt;,</code>
<code>  [<span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>]</code>
<code>&gt;&gt;;</code>
</pre>
<h4 id="typing-zip"><a class="heading-id-link" href="#typing-zip">37.7.2 Typing a function <code>zip()</code></a></h4>
<p>Consider a <code>zip()</code> function that converts a tuple of iterables to an iterable of tuples (<a href="https://github.com/rauschma/iterable/blob/main/ts/src/sync.ts">source code of an implementation</a>):</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">zip</span>([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]])</span></code>
<code>[ [1, 'a'], [2, 'b'], [3, 'c'] ]</code>
</pre>
<p>The following utility type <code>Zip</code> computes a return type for it:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Zip</span>&lt;<span class="hljs-title class_">Tuple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Iterable</span>&lt;<span class="hljs-built_in">unknown</span>&gt;&gt;&gt; =</code>
<code>  <span class="hljs-title class_">Iterable</span>&lt;</code>
<code>    { [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Tuple</span>]: <span class="hljs-title class_">UnwrapIterable</span>&lt;<span class="hljs-title class_">Tuple</span>[<span class="hljs-title class_">Key</span>]&gt; }</code>
<code>  &gt;</code>
<code>;</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">UnwrapIterable</span>&lt;<span class="hljs-title class_">Iter</span>&gt; =</code>
<code>  <span class="hljs-title class_">Iter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Iterable</span>&lt;infer T&gt;</code>
<code>    ? T</code>
<code>    : <span class="hljs-built_in">never</span></code>
<code>;</code>
<code/>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Zip</span>&lt;[<span class="hljs-title class_">Iterable</span>&lt;<span class="hljs-built_in">string</span>&gt;, <span class="hljs-title class_">Iterable</span>&lt;<span class="hljs-built_in">number</span>&gt;]&gt;,</code>
<code>  <span class="hljs-title class_">Iterable</span>&lt;[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>]&gt;</code>
<code>&gt;&gt;;</code>
</pre>
<h4 id="typing-a-function-zipobj"><a class="heading-id-link" href="#typing-a-function-zipobj">37.7.3 Typing a function <code>zipObj()</code></a></h4>
<p>Function <code>zipObj()</code> is similar to <code>zip()</code>: It converts an object of iterables to an iterable of objects (<a href="https://github.com/rauschma/iterable/blob/main/ts/src/sync.ts">source code of an implementation</a>):</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">zipObj</span>({<span class="hljs-attr">num</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-attr">str</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]})</span></code>
<code>[ {num: 1, str: 'a'}, {num: 2, str: 'b'}, {num: 3, str: 'c'} ]</code>
</pre>
<p>The following utility type <code>ZipObj</code> computes a return type for it:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ZipObj</span>&lt;<span class="hljs-title class_">Obj</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Iterable</span>&lt;<span class="hljs-built_in">unknown</span>&gt;&gt;&gt; =</code>
<code>  <span class="hljs-title class_">Iterable</span>&lt;</code>
<code>    { [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Obj</span>]: <span class="hljs-title class_">UnwrapIterable</span>&lt;<span class="hljs-title class_">Obj</span>[<span class="hljs-title class_">Key</span>]&gt; }</code>
<code>  &gt;</code>
<code>;</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">UnwrapIterable</span>&lt;<span class="hljs-title class_">Iter</span>&gt; =</code>
<code>  <span class="hljs-title class_">Iter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Iterable</span>&lt;infer T&gt;</code>
<code>    ? T</code>
<code>    : <span class="hljs-built_in">never</span></code>
<code>;</code>
<code/>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">ZipObj</span>&lt;{<span class="hljs-attr">a</span>: <span class="hljs-title class_">Iterable</span>&lt;<span class="hljs-built_in">string</span>&gt;, <span class="hljs-attr">b</span>: <span class="hljs-title class_">Iterable</span>&lt;<span class="hljs-built_in">number</span>&gt;}&gt;,</code>
<code>  <span class="hljs-title class_">Iterable</span>&lt;{<span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>}&gt;</code>
<code>&gt;&gt;;</code>
</pre>
<h4 id="util-promisify-converting-a-callback-based-function-to-a-promise-based-one"><a class="heading-id-link" href="#util-promisify-converting-a-callback-based-function-to-a-promise-based-one">37.7.4 <code>util.promisify()</code>: converting a callback-based function to a Promise-based one</a></h4>
<p>The Node.js function <a href="https://nodejs.org/api/util.html#utilpromisifyoriginal"><code>util.promisify(cb)</code></a> converts a function that returns its result via a callback to a function that returns it via a Promise. <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/node/util.d.ts">Its official type</a> is long:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// 0 arguments</span></code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> promisify&lt;<span class="hljs-title class_">TResult</span>&gt;(</code>
<code>    <span class="hljs-attr">fn</span>: <span class="hljs-function">(<span class="hljs-params">callback: (err: <span class="hljs-built_in">any</span>, result: TResult) =&gt; <span class="hljs-built_in">void</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>,</code>
<code>): <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">TResult</span>&gt;;</code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">promisify</span>(</code>
<code><span class="hljs-params">  fn: (callback: (err?: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">void</span>) =&gt; <span class="hljs-built_in">void</span></span></code>
<code>): <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;</code>
<code/>
<code><span class="hljs-comment">// 1 argument</span></code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> promisify&lt;<span class="hljs-variable constant_">T1</span>, <span class="hljs-title class_">TResult</span>&gt;(</code>
<code>    <span class="hljs-attr">fn</span>: <span class="hljs-function">(<span class="hljs-params">arg1: T1, callback: (err: <span class="hljs-built_in">any</span>, result: TResult) =&gt; <span class="hljs-built_in">void</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>,</code>
<code>): <span class="hljs-function">(<span class="hljs-params">arg1: T1</span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">TResult</span>&gt;;</code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> promisify&lt;<span class="hljs-variable constant_">T1</span>&gt;(</code>
<code>  <span class="hljs-attr">fn</span>: <span class="hljs-function">(<span class="hljs-params">arg1: T1, callback: (err?: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">void</span></span>) =&gt;</span> <span class="hljs-built_in">void</span></code>
<code>): <span class="hljs-function">(<span class="hljs-params">arg1: T1</span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;</code>
<code/>
<code><span class="hljs-comment">// 2 arguments</span></code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> promisify&lt;<span class="hljs-variable constant_">T1</span>, <span class="hljs-variable constant_">T2</span>, <span class="hljs-title class_">TResult</span>&gt;(</code>
<code>    <span class="hljs-attr">fn</span>: <span class="hljs-function">(<span class="hljs-params">arg1: T1, arg2: T2, callback: (err: <span class="hljs-built_in">any</span>, result: TResult) =&gt; <span class="hljs-built_in">void</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>,</code>
<code>): <span class="hljs-function">(<span class="hljs-params">arg1: T1, arg2: T2</span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">TResult</span>&gt;;</code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> promisify&lt;<span class="hljs-variable constant_">T1</span>, <span class="hljs-variable constant_">T2</span>&gt;(</code>
<code>    <span class="hljs-attr">fn</span>: <span class="hljs-function">(<span class="hljs-params">arg1: T1, arg2: T2, callback: (err?: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">void</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>,</code>
<code>): <span class="hljs-function">(<span class="hljs-params">arg1: T1, arg2: T2</span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;</code>
<code/>
<code><span class="hljs-comment">// Etc.: up to 5 arguments</span></code>
</pre>
<p>Let’s try to simplify it:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> promisify&lt;<span class="hljs-title class_">Args</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>[], <span class="hljs-variable constant_">CB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NodeCallback</span>&gt;(</code>
<code>  <span class="hljs-attr">fn</span>: <span class="hljs-function">(<span class="hljs-params">...args: [...Args, CB]</span>) =&gt;</span> <span class="hljs-built_in">void</span>,</code>
<code>): <span class="hljs-function">(<span class="hljs-params">...args: Args</span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ExtractResultType</span>&lt;<span class="hljs-variable constant_">CB</span>&gt;&gt; {</code>
<code>  <span class="hljs-comment">// ···</span></code>
<code>}</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">NodeCallback</span> =</code>
<code>  | (<span class="hljs-function">(<span class="hljs-params">err: <span class="hljs-built_in">any</span>, result: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>)</code>
<code>  | (<span class="hljs-function">(<span class="hljs-params">err: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>)</code>
<code>;</code>
<code/>
<code><span class="hljs-comment">//----- Test -----</span></code>
<code/>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">nodeFunc</span>(</code>
<code><span class="hljs-params">  arr: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;,</span></code>
<code><span class="hljs-params">  cb: (err: <span class="hljs-built_in">Error</span>, str: <span class="hljs-built_in">string</span>) =&gt; <span class="hljs-built_in">void</span></span></code>
<code>) {}</code>
<code><span class="hljs-keyword">const</span> asyncFunc = <span class="hljs-title function_">promisify</span>(nodeFunc);</code>
<code>assertType&lt;</code>
<code>  <span class="hljs-function">(<span class="hljs-params">arr: <span class="hljs-built_in">string</span>[]</span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;</code>
<code>&gt;(asyncFunc);</code>
</pre>
<p>The previous code uses the following utility type:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ExtractResultType</span>&lt;F <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NodeCallback</span>&gt; =</code>
<code>  F <span class="hljs-keyword">extends</span> (<span class="hljs-attr">err</span>: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">void</span></code>
<code>  ? <span class="hljs-built_in">void</span></code>
<code>  : F <span class="hljs-keyword">extends</span> (<span class="hljs-attr">err</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">result</span>: infer <span class="hljs-title class_">TResult</span>) =&gt; <span class="hljs-built_in">void</span></code>
<code>  ? <span class="hljs-title class_">TResult</span></code>
<code>  : <span class="hljs-built_in">never</span></code>
<code>;</code>
<code/>
<code><span class="hljs-comment">//----- Test -----</span></code>
<code/>
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">ExtractResultType</span>&lt;<span class="hljs-function">(<span class="hljs-params">err: <span class="hljs-built_in">Error</span>, result: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;,</code>
<code>    <span class="hljs-built_in">string</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">ExtractResultType</span>&lt;<span class="hljs-function">(<span class="hljs-params">err: <span class="hljs-built_in">Error</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;,</code>
<code>    <span class="hljs-built_in">void</span></code>
<code>  &gt;&gt;,</code>
<code>];</code>
</pre>
<h3 id="limitations-of-computing-with-tuples"><a class="heading-id-link" href="#limitations-of-computing-with-tuples">37.8 Limitations of computing with tuples</a></h3>
<p>There are constraints we can’t express via TypeScript’s type system. The following code is one example:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Same</span>&lt;T&gt; = {<span class="hljs-attr">a</span>: T, <span class="hljs-attr">b</span>: T};</code>
<code/>
<code><span class="hljs-keyword">function</span> one&lt;T&gt;(<span class="hljs-attr">obj</span>: <span class="hljs-title class_">Same</span>&lt;T&gt;) {}</code>
<code><span class="hljs-comment">// @ts-expect-error: Type 'string' is not assignable to type 'boolean'.</span></code>
<code><span class="hljs-title function_">one</span>({<span class="hljs-attr">a</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">'abc'</span>}); <span class="hljs-comment">// 👍 error</span></code>
<code/>
<code><span class="hljs-keyword">function</span> many&lt;A, B, C, D, E&gt;(</code>
<code>  <span class="hljs-attr">objs</span>: [<span class="hljs-title class_">Same</span>&lt;A&gt;, <span class="hljs-title class_">Same</span>&lt;B&gt;]</code>
<code>      | [<span class="hljs-title class_">Same</span>&lt;A&gt;, <span class="hljs-title class_">Same</span>&lt;B&gt;, <span class="hljs-title class_">Same</span>&lt;C&gt;]</code>
<code>      | [<span class="hljs-title class_">Same</span>&lt;A&gt;, <span class="hljs-title class_">Same</span>&lt;B&gt;, <span class="hljs-title class_">Same</span>&lt;C&gt;, <span class="hljs-title class_">Same</span>&lt;D&gt;]</code>
<code>      | [<span class="hljs-title class_">Same</span>&lt;A&gt;, <span class="hljs-title class_">Same</span>&lt;B&gt;, <span class="hljs-title class_">Same</span>&lt;C&gt;, <span class="hljs-title class_">Same</span>&lt;D&gt;, <span class="hljs-title class_">Same</span>&lt;E&gt;,</code>
<code>        ...<span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Same</span>&lt;<span class="hljs-built_in">unknown</span>&gt;&gt;]</code>
<code>) {}</code>
<code/>
<code><span class="hljs-title function_">many</span>([</code>
<code>  {<span class="hljs-attr">a</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">b</span>: <span class="hljs-literal">true</span>},</code>
<code>  {<span class="hljs-attr">a</span>: <span class="hljs-string">'abc'</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">'abc'</span>},</code>
<code>  <span class="hljs-comment">// @ts-expect-error: Type 'boolean' is not assignable to type 'number'.</span></code>
<code>  {<span class="hljs-attr">a</span>: <span class="hljs-number">7</span>, <span class="hljs-attr">b</span>: <span class="hljs-literal">false</span>} <span class="hljs-comment">// 👍 error</span></code>
<code>]);</code>
</pre>
<p>We’d like to express:</p>
<ul>
  <li>
    Function <code>many()</code> receives an Array of objects.
  </li>
  <li>
    The types of the two properties should be the same.
  </li>
</ul>
<p>We can’t loop and introduce one variable per loop iteration. Therefore, we list the most common cases manually.</p>
<h3 id="sources-of-this-chapter-6"><a class="heading-id-link" href="#sources-of-this-chapter-6">37.9 Sources of this chapter</a></h3>
<ul>
  <li>
    Pull request <a href="https://github.com/microsoft/TypeScript/pull/39094">“Variadic tuple types”</a> by Anders Hejlsberg
  </li>
  <li>
    Section <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-0/#variadic-tuple-types">“Variadic Tuple Types”</a> in the TypeScript 4.0 blog post
  </li>
  <li>
    Section <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-0/#labeled-tuple-elements">“Labeled Tuple Elements”</a> in the TypeScript 4.0 blog post
  </li>
</ul>

    
      
</body>
</html>