["```js\nlet i;\ni = 0;\ni = i + 1;\nassert.equal(i, 1);\n\n```", "```js\nlet i = 0;\n\n```", "```js\nconst i = 0; // must initialize\n\nassert.throws(\n  () => { i = i + 1 },\n  {\n    name: 'TypeError',\n    message: 'Assignment to constant variable.',\n  }\n);\n\n```", "```js\nconst obj = { prop: 0 };\n\n// Allowed: changing properties of `obj`\nobj.prop = obj.prop + 1;\nassert.equal(obj.prop, 1);\n\n// Not allowed: assigning to `obj`\nassert.throws(\n  () => { obj = {} },\n  {\n    name: 'TypeError',\n    message: 'Assignment to constant variable.',\n  }\n);\n\n```", "```js\nconst arr = ['hello', 'world'];\nfor (const elem of arr) {\n  console.log(elem);\n}\n\n```", "```js\nhello\nworld\n\n```", "```js\nconst arr = ['hello', 'world'];\nfor (let i=0; i<arr.length; i++) {\n  const elem = arr[i];\n  console.log(elem);\n}\n\n```", "```js\n{ // // Scope A. Accessible: x\n  const x = 0;\n  assert.equal(x, 0);\n  { // Scope B. Accessible: x, y\n    const y = 1;\n    assert.equal(x, 0);\n    assert.equal(y, 1);\n    { // Scope C. Accessible: x, y, z\n      const z = 2;\n      assert.equal(x, 0);\n      assert.equal(y, 1);\n      assert.equal(z, 2);\n    }\n  }\n}\n// Outside. Not accessible: x, y, z\nassert.throws(\n  () => console.log(x),\n  {\n    name: 'ReferenceError',\n    message: 'x is not defined',\n  }\n);\n\n```", "```js\nassert.throws(\n  () => {\n    eval('let x = 1; let x = 2;');\n  },\n  {\n    name: 'SyntaxError',\n    message: \"Identifier 'x' has already been declared\",\n  }\n);\n\n```", "```js\nconst x = 1;\nassert.equal(x, 1);\n{\n  const x = 2;\n  assert.equal(x, 2);\n}\nassert.equal(x, 1);\n\n```", "```js\nfunction f() {\n const x = 3;\n // ···\n}\n\n```", "```js\nfunction g(x) {}\nfunction h(y) {\n  if (Math.random()) g(y); // (A)\n}\n\n```", "```js\n<script>\n const declarativeVariable = 'd';\n var objectVariable = 'o';\n</script>\n<script>\n // All scripts share the same top-level scope:\n console.log(declarativeVariable); // 'd'\n console.log(objectVariable); // 'o'\n\n // Not all declarations create properties of the global object:\n console.log(globalThis.declarativeVariable); // undefined\n console.log(globalThis.objectVariable); // 'o'\n</script>\n\n```", "```js\nwindow.encodeURIComponent(str); // no\nencodeURIComponent(str); // yes\n\n```", "```js\n{\n  console.log(x); // What happens here?\n  const x = 123;\n}\n\n```", "```js\nif (true) { // entering scope of `tmp`, TDZ starts\n  // `tmp` is uninitialized:\n  assert.throws(() => (tmp = 'abc'), ReferenceError);\n  assert.throws(() => console.log(tmp), ReferenceError);\n\n  let tmp; // TDZ ends\n  assert.equal(tmp, undefined);\n}\n\n```", "```js\nif (true) { // entering scope of `myVar`, TDZ starts\n  const func = () => {\n console.log(myVar); // executed later\n };\n\n // We are within the TDZ:\n // Accessing `myVar` causes `ReferenceError`\n\n let myVar = 3; // TDZ ends\n func(); // OK, called outside TDZ\n}\n\n```", "```js\nassert.equal(funcDecl(), 123); // OK\nfunction funcDecl() { return 123; }\n\n```", "```js\nfunction funcDecl() { return 123; }\nassert.equal(funcDecl(), 123);\n\n```", "```js\nassert.throws(\n  () => arrowFunc(), // before declaration\n  ReferenceError\n);\n\nconst arrowFunc = () => { return 123 };\n\nassert.equal(arrowFunc(), 123); // after declaration \n\n```", "```js\nconst f = () => g();\nconst g = () => 123;\n\n// We call f() after g() was declared:\nassert.equal(f(), 123); // OK \n```", "```js\nfuncDecl();\n\nconst MY_STR = 'abc';\nfunction funcDecl() {\n assert.throws(\n () => MY_STR,\n ReferenceError\n );\n}\n\n```", "```js\nassert.throws(\n  () => new MyClass(),\n  ReferenceError\n);\n\nclass MyClass {}\n\nassert.equal(new MyClass() instanceof MyClass, true);\n\n```", "```js\nclass MyClass extends Object {}\n\n```", "```js\nconst identity = x => x;\nclass MyClass extends identity(Object) {}\n\n```", "```js\nvar x = 123;\n\n```", "```js\nfunction f() {\n // Partial early activation:\n assert.equal(x, undefined);\n if (true) {\n var x = 123;\n // The assignment is executed in place:\n assert.equal(x, 123);\n }\n // Scope is function, not block:\n assert.equal(x, 123);\n}\n\n```", "```js\nfunction func(x) {\n  const y = 123;\n  console.log(z);\n}\n\n```", "```js\nfunction funcFactory(value) {\n  return () => {\n    return value;\n  };\n}\n\nconst func = funcFactory('abc');\nassert.equal(func(), 'abc'); // (A)\n\n```", "```js\nfunction createInc(startValue) {\n  return (step) => { // (A)\n    startValue += step;\n    return startValue;\n  };\n}\nconst inc = createInc(5);\nassert.equal(inc(2), 7);\n\n```", "```js\nfunction createInc(startValue) {\n  let index = -1;\n  return (step) => {\n    startValue += step;\n    index++;\n    return [index, startValue];\n  };\n}\nconst inc = createInc(5);\nassert.deepEqual(inc(2), [0, 7]);\nassert.deepEqual(inc(2), [1, 9]);\nassert.deepEqual(inc(2), [2, 11]);\n\n```"]