["```js\nlet i;\ni = 0;\ni = i + 1;\nassert.equal(i, 1);\n\n```", "```js\nlet i = 0;\n\n```", "```js\nconst i = 0; // must initialize\n `assert.throws(`\n `() => { i = i + 1 },`\n `{`\n `name: 'TypeError',`\n `message: 'Assignment to constant variable.',`\n `}`\n`);` \n```", "```js```", "````js````", "```js const obj = { prop: 0 };  `` // Allowed: changing properties of `obj` `` `obj.prop = obj.prop + 1;` `assert.equal(obj.prop, 1);`  ```", "```js  ```", "```js```", "````js````", "```js```", "````js````", "```js const arr = ['hello', 'world']; for (const elem of arr) {  console.log(elem); }  ```", "```js hello world  ```", "```js const arr = ['hello', 'world']; for (let i=0; i<arr.length; i++) {  const elem = arr[i];  console.log(elem); }  ```", "```js { // // Scope A. Accessible: x  const x = 0;  assert.equal(x, 0);  { // Scope B. Accessible: x, y  const y = 1;  assert.equal(x, 0);  assert.equal(y, 1);  { // Scope C. Accessible: x, y, z  const z = 2;  assert.equal(x, 0);  assert.equal(y, 1);  assert.equal(z, 2);  }  } } // Outside. Not accessible: x, y, z assert.throws(  () => console.log(x),  {  name: 'ReferenceError',  message: 'x is not defined',  } );  ```", "```js assert.throws(  () => {  eval('let x = 1; let x = 2;');  },  {  name: 'SyntaxError',  message: \"Identifier 'x' has already been declared\",  } );  ```", "```js const x = 1; assert.equal(x, 1); {  const x = 2;  assert.equal(x, 2); } assert.equal(x, 1);  ```", "```js function f() {  const x = 3;  // ··· }  ```", "```js function g(x) {} function h(y) {  if (Math.random()) g(y); // (A) }  ```", "```js <script>  const declarativeVariable = 'd';  var objectVariable = 'o'; </script> <script>  // All scripts share the same top-level scope:  console.log(declarativeVariable); // 'd'  console.log(objectVariable); // 'o'   // Not all declarations create properties of the global object:  console.log(globalThis.declarativeVariable); // undefined  console.log(globalThis.objectVariable); // 'o' </script>  ```", "```js window.encodeURIComponent(str); // no encodeURIComponent(str); // yes  ```", "```js {  console.log(x); // What happens here?  const x = 123; }  ```", "```js if (true) { // entering scope of `tmp`, TDZ starts  // `tmp` is uninitialized:  assert.throws(() => (tmp = 'abc'), ReferenceError);  assert.throws(() => console.log(tmp), ReferenceError);  `let tmp; // TDZ ends`  `assert.equal(tmp, undefined);` `}`  ```", "```js```", "````js``` The next example shows that the temporal dead zone is truly *temporal* (related to time):    ``` if (true) { // entering scope of `myVar`, TDZ starts  const func = () => {  console.log(myVar); // executed later  };  `// We are within the TDZ:`  `` // Accessing `myVar` causes `ReferenceError` ``  `` `let myVar = 3; // TDZ ends`  `func(); // OK, called outside TDZ` `}` ``  ```js   ````", "`````` ```js``````", "``` assert.equal(funcDecl(), 123); // OK function funcDecl() { return 123; }  ```", "``` function funcDecl() { return 123; } assert.equal(funcDecl(), 123);  ```", "``` assert.throws(  () => arrowFunc(), // before declaration  ReferenceError );  `const arrowFunc = () => { return 123 };`  `` `assert.equal(arrowFunc(), 123); // after declaration` ``  ```", "``````js```` ```js``````", "```js const f = () => g(); const g = () => 123;  `// We call f() after g() was declared:` `assert.equal(f(), 123); // OK`  ```", "```js```", "```js funcDecl();  `const MY_STR = 'abc';` `function funcDecl() {`  `assert.throws(`  `() => MY_STR,`  `ReferenceError`  `);` `}`  ```", "```js```", "```js assert.throws(  () => new MyClass(),  ReferenceError );  `class MyClass {}`  `` `assert.equal(new MyClass() instanceof MyClass, true);` ``  ```", "```js```", "````` Why is that? Consider the following class declaration:    ```js class MyClass extends Object {}  ```    The operand of `extends` is an expression. Therefore, we can do things like this:    ```js const identity = x => x; class MyClass extends identity(Object) {}  ```    Evaluating such an expression must be done at the location where it is mentioned. Anything else would be confusing. That explains why class declarations are not activated early.    #### [13.8.4 `var`: hoisting (partial early activation)](#hoisting)    `var` is an older way of declaring variables that predates `const` and `let` (which are preferred now). Consider the following `var` declaration.    ```js var x = 123;  ```    This declaration has two parts:    *   Declaration `var x`: The scope of a `var`-declared variable is the innermost surrounding function and not the innermost surrounding block, as for most other declarations. Such a variable is already active at the beginning of its scope and initialized with `undefined`. *   Assignment `x = 123`: The assignment is always executed in place.    The following code demonstrates the effects of `var`:    ```js function f() {  // Partial early activation:  assert.equal(x, undefined);  if (true) {  var x = 123;  // The assignment is executed in place:  assert.equal(x, 123);  }  // Scope is function, not block:  assert.equal(x, 123); }  ```    ### [13.9 Closures](#closures)    Before we can explore closures, we need to learn about bound variables and free variables.    #### [13.9.1 Bound variables vs. free variables](#bound-variables-vs-free-variables)    Per scope, there is a set of variables that are mentioned. Among these variables we distinguish:    *   *Bound variables* are declared within the scope. They are parameters and local variables. *   *Free variables* are declared externally. They are also called *non-local variables*.    Consider the following code:    ```js function func(x) {  const y = 123;  console.log(z); }  ```    In the body of `func()`, `x` and `y` are bound variables. `z` is a free variable.    #### [13.9.2 What is a closure?](#what-is-a-closure)    What is a closure then? A *closure* is a function plus a connection to the variables that exist at its “birth place”.    What is the point of keeping this connection? It provides the values for the free variables of the function – for example:    ```js function funcFactory(value) {  return () => {  return value;  }; }  `const func = funcFactory('abc');` `assert.equal(func(), 'abc'); // (A)`  ```   ```js` `funcFactory` returns a closure that is assigned to `func`. Because `func` has the connection to the variables at its birth place, it can still access the free variable `value` when it is called in line A (even though it “escaped” its scope).    ![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **All functions in JavaScript are closures**    Static scoping is supported via closures in JavaScript. Therefore, every function is a closure.    #### [13.9.3 Example: A factory for incrementors](#example-a-factory-for-incrementors)    The following function returns *incrementors* (a name that I just made up). An incrementor is a function that internally stores a number. When it is called, it updates that number by adding the argument to it and returns the new value.    ``` function createInc(startValue) {  return (step) => { // (A)  startValue += step;  return startValue;  }; } const inc = createInc(5); assert.equal(inc(2), 7);  ```js    We can see that the function created in line A keeps its internal number in the free variable `startValue`. This time, we don’t just read from the birth scope, we use it to store data that we change and that persists across function calls.    We can create more storage slots in the birth scope, via local variables:    ``` function createInc(startValue) {  let index = -1;  return (step) => {  startValue += step;  index++;  return [index, startValue];  }; } const inc = createInc(5); assert.deepEqual(inc(2), [0, 7]); assert.deepEqual(inc(2), [1, 9]); assert.deepEqual(inc(2), [2, 11]);  ```js    #### [13.9.4 Use cases for closures](#use-cases-for-closures)    What are closures good for?    *   For starters, they are simply an implementation of static scoping. As such, they provide context data for callbacks.           *   They can also be used by functions to store state that persists across function calls. `createInc()` is an example of that.           *   And they can provide private data for objects (produced via literals or classes). The details of how that works are explained in [*Exploring ES6*](https://exploringjs.com/es6/ch_classes.html#_private-data-via-constructor-environments). ```` ```js`` `````", "``````js` ``````", "``````js``` ``````", "```` ```js````", "```js` ```", "```js```", "``` ```", "```````js``` ``````js```````", "``````js``````", "``````js``````"]