- en: 37 WeakMaps (WeakMap) ES6 (advanced)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_weakmaps.html](https://exploringjs.com/js/book/ch_weakmaps.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[37.1 How are WeakMaps different from Maps?](#maps-vs-weakmaps)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.2 WeakMaps are black boxes](#weakmaps-as-black-boxes)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.3 The keys of a WeakMap are *weakly held*](#weakmap-keys-are-weakly-held)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.3.1 What values can be keys in WeakMaps?](#weakmap-keys-criteria)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.3.2 Why are symbols as WeakMap keys interesting? ^(ES2023)](#why-are-symbols-as-weakmap-keys-interesting-es2023)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.4 Use case for WeakMaps: attaching values to objects](#attaching-values-to-objects-via-weakmaps)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.4.1 Example: caching computed results](#example-caching-computed-results)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.4.2 Example: keeping data of objects private](#private-data-in-weakmaps)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.5 Quick reference: `WeakMap`](#quickref-weakmaps)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.1 How are WeakMaps different from Maps?](#maps-vs-weakmaps)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'WeakMaps are similar to Maps, with the following differences:'
  prefs: []
  type: TYPE_NORMAL
- en: They are black boxes, where a value can only be accessed if we have both the
    WeakMap and the key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The keys of a WeakMap are *weakly held*: If a value is a key in a WeakMap,
    it can still be garbage-collected. That enables two important use cases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can attach data to value that we don’t own – e.g., to cache computed results.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We can keep part of a value private, by not making the WeakMap public that contains
    that part.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The next two sections examine in more detail what that means.
  prefs: []
  type: TYPE_NORMAL
- en: '[37.2 WeakMaps are black boxes](#weakmaps-as-black-boxes)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is impossible to inspect what’s inside a WeakMap:'
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can’t iterate or loop over keys, values or entries. And we can’t
    compute the size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, we can’t clear a WeakMap either – we have to create a fresh instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These restrictions enable a security property. Quoting [Mark Miller](https://github.com/tc39/notes/blob/main/meetings/2014-11/nov-19.md#412-should-weakmapweakset-have-a-clear-method-markm):'
  prefs: []
  type: TYPE_NORMAL
- en: The mapping from weakmap/key pair value can only be observed or affected by
    someone who has both the weakmap and the key. With `clear()`, someone with only
    the WeakMap would’ve been able to affect the WeakMap-and-key-to-value mapping.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[37.3 The keys of a WeakMap are *weakly held*](#weakmap-keys-are-weakly-held)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The keys of a WeakMap are said to be *weakly held*: Normally if one object
    refers to another one, then the latter object can’t be garbage-collected as long
    as the former exists. With a WeakMap, that is different: If an object is a key
    and not referred to elsewhere, it can be garbage-collected while the WeakMap still
    exists. That also leads to the corresponding entry being removed (but there is
    no way to observe that).'
  prefs: []
  type: TYPE_NORMAL
- en: '[37.3.1 What values can be keys in WeakMaps?](#weakmap-keys-criteria)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Which values can be keys in WeakMaps is documented in the ECMAScript specification,
    via the specification function [`CanBeHeldWeakly()`](https://tc39.es/ecma262/#sec-canbeheldweakly):'
  prefs: []
  type: TYPE_NORMAL
- en: Objects ^(ES6)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbols ^(ES2023) – as long as they are not registered (created via `Symbol.for()`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All kinds of keys have one thing in common – they have [*identity semantics*](ch_values.html#primitive-values-vs-objects):'
  prefs: []
  type: TYPE_NORMAL
- en: When compared via `===`, two keys are considered equal if they have the same
    identity – they are *not* compared by comparing their contents (their values).
    That means there are never two or more different keys (“different” meaning “at
    different locations in memory”) that are all considered equal. Each key is unique.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They are garbage-collected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both conditions are important so that WeakMaps can dispose entries when keys
    disappear and no memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Non-registered symbols can be used as WeakMap keys: They are primitive but
    they are compared by identity and they are garbage-collected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following two kinds of values cannot be used as WeakMap keys:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings are garbage-collected but they are compared by value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Registered symbols](https://exploringjs.com/es6/ch_symbols.html#sec_symbols-crossing-realms)
    are different from normal symbols – they do not have identity semantics ([source](https://tc39.es/ecma262/#sec-canbeheldweakly)).
    This is how registered symbols are used:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[37.3.2 Why are symbols as WeakMap keys interesting? ^(ES2023)](#why-are-symbols-as-weakmap-keys-interesting-es2023)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Symbols as WeakMap keys solve important issues for upcoming JavaScript features:'
  prefs: []
  type: TYPE_NORMAL
- en: We can put references to objects inside [records and tuples](https://2ality.com/2020/05/records-tuples-first-look.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can pass references to objects in and out of [ShadowRealms](https://2ality.com/2022/04/shadow-realms.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[37.4 Use case for WeakMaps: attaching values to objects](#attaching-values-to-objects-via-weakmaps)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use WeakMaps to externally attach values to objects – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In line A, we set an external ID for `obj`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line B, we get the external ID of `obj`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line C, `obj` can be garbage-collected even though it is a key in the data
    structure `externalId`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a way, we created a property for `obj`, but stored it externally. If `externalId`
    were a property, the previous code would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[37.4.1 Example: caching computed results](#example-caching-computed-results)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With WeakMaps, we can associate previously computed results with objects without
    having to worry about memory management. The following function `countOwnKeys()`
    is an example: it caches previous results in the WeakMap `cache`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use this function with an object `obj`, we can see that the result is
    only computed for the first invocation, while a cached value is used for the second
    invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[37.4.2 Example: keeping data of objects private](#private-data-in-weakmaps)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the following code, the WeakMaps `_counter` and `_action` are used to store
    the values of virtual properties of instances of `Countdown`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how `Countdown` is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    WeakMaps for private data**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/weakmaps/weakmaps_private_data_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[37.5 Quick reference: `WeakMap`](#quickref-weakmaps)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The constructor and the four methods of `WeakMap` work the same as [their `Map`
    equivalents](ch_maps.html#quickref-maps):'
  prefs: []
  type: TYPE_NORMAL
- en: '`new WeakMap<K, V>(entries?: Iterable<[K, V]>)` ^(ES6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WeakMap.prototype.delete(key: K) : boolean` ^(ES6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WeakMap.prototype.get(key: K) : V` ^(ES6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WeakMap.prototype.has(key: K) : boolean` ^(ES6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WeakMap.prototype.set(key: K, value: V) : this` ^(ES6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
