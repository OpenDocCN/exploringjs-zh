- en: 37 WeakMaps (WeakMap) ES6 (advanced)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 37 WeakMap (WeakMap) ES6 (高级)
- en: 原文：[https://exploringjs.com/js/book/ch_weakmaps.html](https://exploringjs.com/js/book/ch_weakmaps.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/js/book/ch_weakmaps.html](https://exploringjs.com/js/book/ch_weakmaps.html)
- en: '[37.1 How are WeakMaps different from Maps?](#maps-vs-weakmaps)'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[37.1 WeakMap 与 Map 有何不同？](#maps-vs-weakmaps)'
- en: '[37.2 WeakMaps are black boxes](#weakmaps-as-black-boxes)'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[37.2 WeakMap 是黑盒](#weakmaps-as-black-boxes)'
- en: '[37.3 The keys of a WeakMap are *weakly held*](#weakmap-keys-are-weakly-held)'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[37.3 WeakMap 的键是**弱持有**的](#weakmap-keys-are-weakly-held)'
- en: '[37.3.1 What values can be keys in WeakMaps?](#weakmap-keys-criteria)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[37.3.1 WeakMap 中可以作为键的值有哪些？](#weakmap-keys-criteria)'
- en: '[37.3.2 Why are symbols as WeakMap keys interesting? ^(ES2023)](#why-are-symbols-as-weakmap-keys-interesting-es2023)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[37.3.2 为什么符号作为 WeakMap 键有趣？^(ES2023)](#why-are-symbols-as-weakmap-keys-interesting-es2023)'
- en: '[37.4 Use case for WeakMaps: attaching values to objects](#attaching-values-to-objects-via-weakmaps)'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[37.4 WeakMap 的用例：将值附加到对象上](#attaching-values-to-objects-via-weakmaps)'
- en: '[37.4.1 Example: caching computed results](#example-caching-computed-results)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[37.4.1 示例：缓存计算结果](#example-caching-computed-results)'
- en: '[37.4.2 Example: keeping data of objects private](#private-data-in-weakmaps)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[37.4.2 示例：在 WeakMap 中保持对象私有数据](#private-data-in-weakmaps)'
- en: '[37.5 Quick reference: `WeakMap`](#quickref-weakmaps)'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[37.5 快速参考：`WeakMap`](#quickref-weakmaps)'
- en: '[37.1 How are WeakMaps different from Maps?](#maps-vs-weakmaps)'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[37.1 WeakMap 与 Map 有何不同？](#maps-vs-weakmaps)'
- en: 'WeakMaps are similar to Maps, with the following differences:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: WeakMap 与 Map 类似，但有以下区别：
- en: They are black boxes, where a value can only be accessed if we have both the
    WeakMap and the key.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是黑盒，只有当我们同时拥有 WeakMap 和键时，才能访问值。
- en: 'The keys of a WeakMap are *weakly held*: If a value is a key in a WeakMap,
    it can still be garbage-collected. That enables two important use cases:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WeakMap 的键是**弱持有**的：如果一个值是 WeakMap 的键，它仍然可以被垃圾回收。这使两个重要的用例成为可能：
- en: We can attach data to value that we don’t own – e.g., to cache computed results.
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将数据附加到我们拥有的值上——例如，缓存计算结果。
- en: We can keep part of a value private, by not making the WeakMap public that contains
    that part.
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过不公开包含该部分的 WeakMap 来保持部分值的私有性。
- en: The next two sections examine in more detail what that means.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 下两个部分将更详细地探讨这意味着什么。
- en: '[37.2 WeakMaps are black boxes](#weakmaps-as-black-boxes)'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[37.2 WeakMap 是黑盒](#weakmaps-as-black-boxes)'
- en: 'It is impossible to inspect what’s inside a WeakMap:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 无法检查 WeakMap 内部的内容：
- en: For example, we can’t iterate or loop over keys, values or entries. And we can’t
    compute the size.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，我们无法对键、值或条目进行迭代或循环。我们也不能计算大小。
- en: Additionally, we can’t clear a WeakMap either – we have to create a fresh instance.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们也不能清除 WeakMap，我们必须创建一个新的实例。
- en: 'These restrictions enable a security property. Quoting [Mark Miller](https://github.com/tc39/notes/blob/main/meetings/2014-11/nov-19.md#412-should-weakmapweakset-have-a-clear-method-markm):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制使得具有安全性属性。引用 [Mark Miller](https://github.com/tc39/notes/blob/main/meetings/2014-11/nov-19.md#412-should-weakmapweakset-have-a-clear-method-markm)：
- en: The mapping from weakmap/key pair value can only be observed or affected by
    someone who has both the weakmap and the key. With `clear()`, someone with only
    the WeakMap would’ve been able to affect the WeakMap-and-key-to-value mapping.
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 只有同时拥有 weakmap 和键的人才能观察或影响 weakmap/key 对值映射。使用 `clear()`，只有 WeakMap 的人原本能够影响
    WeakMap 和键到值的映射。
- en: '[37.3 The keys of a WeakMap are *weakly held*](#weakmap-keys-are-weakly-held)'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[37.3 WeakMap 的键是**弱持有**的](#weakmap-keys-are-weakly-held)'
- en: 'The keys of a WeakMap are said to be *weakly held*: Normally if one object
    refers to another one, then the latter object can’t be garbage-collected as long
    as the former exists. With a WeakMap, that is different: If an object is a key
    and not referred to elsewhere, it can be garbage-collected while the WeakMap still
    exists. That also leads to the corresponding entry being removed (but there is
    no way to observe that).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: WeakMap 的键被称为**弱持有**：通常情况下，如果一个对象引用了另一个对象，那么后一个对象只要前一个对象存在，就不能被垃圾回收。使用 WeakMap，情况就不同了：如果一个对象是键并且没有其他引用，它可以在
    WeakMap 存在的情况下被垃圾回收。这也导致相应的条目被移除（但无法观察到这一点）。
- en: '[37.3.1 What values can be keys in WeakMaps?](#weakmap-keys-criteria)'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[37.3.1 WeakMap 中可以作为键的值有哪些？](#weakmap-keys-criteria)'
- en: 'Which values can be keys in WeakMaps is documented in the ECMAScript specification,
    via the specification function [`CanBeHeldWeakly()`](https://tc39.es/ecma262/#sec-canbeheldweakly):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: WeakMap 中可以作为键的值在 ECMAScript 规范中有记录，通过规范函数 `CanBeHeldWeakly()` 实现（[https://tc39.es/ecma262/#sec-canbeheldweakly](https://tc39.es/ecma262/#sec-canbeheldweakly)）：
- en: Objects ^(ES6)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象 (ES6)
- en: Symbols ^(ES2023) – as long as they are not registered (created via `Symbol.for()`)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号^(ES2023)——只要它们没有被注册（通过`Symbol.for()`创建）
- en: 'All kinds of keys have one thing in common – they have [*identity semantics*](ch_values.html#primitive-values-vs-objects):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的键有一个共同点——它们有[*身份语义*](ch_values.html#primitive-values-vs-objects)：
- en: When compared via `===`, two keys are considered equal if they have the same
    identity – they are *not* compared by comparing their contents (their values).
    That means there are never two or more different keys (“different” meaning “at
    different locations in memory”) that are all considered equal. Each key is unique.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当通过`===`比较时，如果两个键具有相同的身份，则认为它们相等——它们不是通过比较它们的内容（它们的值）来比较的。这意味着永远不会有两个或更多不同的键（“不同”意味着“在内存中的不同位置”）都被认为是相等的。每个键都是唯一的。
- en: They are garbage-collected.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们被垃圾回收了。
- en: Both conditions are important so that WeakMaps can dispose entries when keys
    disappear and no memory leaks.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个条件都很重要，这样WeakMaps才能在键消失时销毁条目，避免内存泄漏。
- en: 'Let’s look at examples:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看例子：
- en: 'Non-registered symbols can be used as WeakMap keys: They are primitive but
    they are compared by identity and they are garbage-collected.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非注册符号可以用作WeakMap键：它们是原始类型，但它们通过身份比较，并且会被垃圾回收。
- en: 'The following two kinds of values cannot be used as WeakMap keys:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下两种类型的值不能用作WeakMap键：
- en: Strings are garbage-collected but they are compared by value.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串会被垃圾回收，但它们是通过值进行比较的。
- en: '[Registered symbols](https://exploringjs.com/es6/ch_symbols.html#sec_symbols-crossing-realms)
    are different from normal symbols – they do not have identity semantics ([source](https://tc39.es/ecma262/#sec-canbeheldweakly)).
    This is how registered symbols are used:'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[已注册的符号](https://exploringjs.com/es6/ch_symbols.html#sec_symbols-crossing-realms)与普通符号不同——它们没有身份语义([来源](https://tc39.es/ecma262/#sec-canbeheldweakly))。这是已注册符号的使用方式：'
- en: '[PRE0]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[37.3.2 Why are symbols as WeakMap keys interesting? ^(ES2023)](#why-are-symbols-as-weakmap-keys-interesting-es2023)'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[37.3.2 为什么将符号作为WeakMap键有趣？^(ES2023)](#why-are-symbols-as-weakmap-keys-interesting-es2023)'
- en: 'Symbols as WeakMap keys solve important issues for upcoming JavaScript features:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 符号作为WeakMap键解决了即将到来的JavaScript功能的重要问题：
- en: We can put references to objects inside [records and tuples](https://2ality.com/2020/05/records-tuples-first-look.html).
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在[记录和元组](https://2ality.com/2020/05/records-tuples-first-look.html)中放置对象的引用。
- en: We can pass references to objects in and out of [ShadowRealms](https://2ality.com/2022/04/shadow-realms.html).
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在[ShadowRealms](https://2ality.com/2022/04/shadow-realms.html)中传递对象的引用。
- en: '[37.4 Use case for WeakMaps: attaching values to objects](#attaching-values-to-objects-via-weakmaps)'
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[37.4 WeakMaps的使用场景：附加值到对象](#attaching-values-to-objects-via-weakmaps)'
- en: 'We can use WeakMaps to externally attach values to objects – for example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用WeakMaps来外部附加值到对象上——例如：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In line A, we set an external ID for `obj`.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行A中，我们为`obj`设置了一个外部ID。
- en: In line B, we get the external ID of `obj`.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行B中，我们获取`obj`的外部ID。
- en: In line C, `obj` can be garbage-collected even though it is a key in the data
    structure `externalId`.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行C中，即使`obj`是数据结构`externalId`中的键，它也可以被垃圾回收。
- en: 'In a way, we created a property for `obj`, but stored it externally. If `externalId`
    were a property, the previous code would look as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，我们为`obj`创建了一个属性，但将其外部存储。如果`externalId`是一个属性，则之前的代码将如下所示：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[37.4.1 Example: caching computed results](#example-caching-computed-results)'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[37.4.1 示例：缓存计算结果](#example-caching-computed-results)'
- en: 'With WeakMaps, we can associate previously computed results with objects without
    having to worry about memory management. The following function `countOwnKeys()`
    is an example: it caches previous results in the WeakMap `cache`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用WeakMaps，我们可以将之前计算的结果与对象关联起来，而无需担心内存管理。以下函数`countOwnKeys()`是一个例子：它在WeakMap
    `cache`中缓存了之前的结果。
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we use this function with an object `obj`, we can see that the result is
    only computed for the first invocation, while a cached value is used for the second
    invocation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用这个函数与对象`obj`一起使用，我们可以看到结果只对第一次调用进行了计算，而第二次调用则使用了缓存的值：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[37.4.2 Example: keeping data of objects private](#private-data-in-weakmaps)'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[37.4.2 示例：在WeakMaps中保持对象数据私有](#private-data-in-weakmaps)'
- en: 'In the following code, the WeakMaps `_counter` and `_action` are used to store
    the values of virtual properties of instances of `Countdown`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，WeakMaps `_counter`和`_action`被用来存储`Countdown`实例的虚拟属性值。
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is how `Countdown` is used:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`Countdown`的使用方式：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    WeakMaps for private data**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“练习”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：WeakMaps用于私有数据**'
- en: '`exercises/weakmaps/weakmaps_private_data_test.mjs`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/weakmaps/weakmaps_private_data_test.mjs`'
- en: '[37.5 Quick reference: `WeakMap`](#quickref-weakmaps)'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[37.5 快速参考：`WeakMap`](#quickref-weakmaps)'
- en: 'The constructor and the four methods of `WeakMap` work the same as [their `Map`
    equivalents](ch_maps.html#quickref-maps):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数和 `WeakMap` 的四个方法与它们的 `Map` 等价物工作方式相同：
- en: '`new WeakMap<K, V>(entries?: Iterable<[K, V]>)` ^(ES6)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new WeakMap<K, V>(entries?: Iterable<[K, V]>)` (ES6)'
- en: '`WeakMap.prototype.delete(key: K) : boolean` ^(ES6)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeakMap.prototype.delete(key: K) : boolean` (ES6)'
- en: '`WeakMap.prototype.get(key: K) : V` ^(ES6)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeakMap.prototype.get(key: K) : V` (ES6)'
- en: '`WeakMap.prototype.has(key: K) : boolean` ^(ES6)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeakMap.prototype.has(key: K) : boolean` (ES6)'
- en: '`WeakMap.prototype.set(key: K, value: V) : this` ^(ES6)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeakMap.prototype.set(key: K, value: V) : this` (ES6)'
