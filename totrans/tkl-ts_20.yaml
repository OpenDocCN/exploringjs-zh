- en: 16 Class definitions in TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/tackling-ts/ch_class-definitions.html](https://exploringjs.com/tackling-ts/ch_class-definitions.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '16.1 [Cheat sheet: classes in plain JavaScript](ch_class-definitions.html#cheat-sheet-classes-in-plain-javascript)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.1.1 [Basic members of classes](ch_class-definitions.html#basic-members-of-classes)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.1.2 [Modifier: `static`](ch_class-definitions.html#modifier-static)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.1.3 [Modifier-like name prefix: `#` (private)](ch_class-definitions.html#modifier-like-name-prefix-private)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.1.4 [Modifiers for accessors: `get` (getter) and `set` (setter)](ch_class-definitions.html#modifiers-for-accessors-get-getter-and-set-setter)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.1.5 [Modifier for methods: `*` (generator)](ch_class-definitions.html#modifier-for-methods-generator)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.1.6 [Modifier for methods: `async`](ch_class-definitions.html#modifier-for-methods-async)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.1.7 [Computed class member names](ch_class-definitions.html#computed-class-member-names)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.1.8 [Combinations of modifiers](ch_class-definitions.html#combinations-of-modifiers)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.1.9 [Under the hood](ch_class-definitions.html#under-the-hood)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.1.10 [More information on class definitions in plain JavaScript](ch_class-definitions.html#more-information-on-class-definitions-in-plain-javascript)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.2 [Non-public data slots in TypeScript](ch_class-definitions.html#non-public-data-slots-in-typescript)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.2.1 [Private properties](ch_class-definitions.html#private-properties)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.2.2 [Private fields](ch_class-definitions.html#private-fields)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.2.3 [Private properties vs. private fields](ch_class-definitions.html#private-properties-vs.-private-fields)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.2.4 [Protected properties](ch_class-definitions.html#protected-properties)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.3 [Private constructors](ch_class-definitions.html#private-constructors)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.4 [Initializing instance properties](ch_class-definitions.html#initializing-instance-properties)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.4.1 [Strict property initialization](ch_class-definitions.html#strict-property-initialization)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.4.2 [Making constructor parameters `public`, `private`, or `protected`](ch_class-definitions.html#making-constructor-parameters-public-private-or-protected)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.5 [Abstract classes](ch_class-definitions.html#abstract-classes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we examine how class definitions work in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we take a quick look at the features of class definitions in plain JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we explore what additions TypeScript brings to the table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.1 Cheat sheet: classes in plain JavaScript'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section is a cheat sheet for class definitions in plain JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 16.1.1 Basic members of classes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/65d35c0a2478236e12cc4321e1b02db6.png)  **The next sections are
    about modifiers**'
  prefs: []
  type: TYPE_NORMAL
- en: At the end, there is a table that shows how modifiers can be combined.
  prefs: []
  type: TYPE_NORMAL
- en: '16.1.2 Modifier: `static`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '16.1.3 Modifier-like name prefix: `#` (private)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Warning for JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Support for private methods is currently quite limited.](https://github.com/tc39/proposal-private-methods#implementations)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Private fields have broader, but also limited, support.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Class_fields#Private_class_fields)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript has been supporting private fields since version 3.8 but does not
    currently support private methods.
  prefs: []
  type: TYPE_NORMAL
- en: '16.1.4 Modifiers for accessors: `get` (getter) and `set` (setter)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Roughly, accessors are methods that are invoked by accessing properties. There
    are two kinds of accessors: getters and setters.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '16.1.5 Modifier for methods: `*` (generator)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '16.1.6 Modifier for methods: `async`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 16.1.7 Computed class member names
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Comments:'
  prefs: []
  type: TYPE_NORMAL
- en: The main use case for this feature is symbols such as `Symbol.iterator`. But
    any expression can be used inside the square brackets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can compute the names of fields, methods, and accessors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot compute the names of private members (which are always fixed).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.1.8 Combinations of modifiers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Fields (no level means that a construct exists at the instance level):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Level | Visibility |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| (instance) |  |'
  prefs: []
  type: TYPE_TB
- en: '| (instance) | `#` |'
  prefs: []
  type: TYPE_TB
- en: '| `static` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `static` | `#` |'
  prefs: []
  type: TYPE_TB
- en: 'Methods (no level means that a construct exists at the prototype level):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Level | Accessor | Async | Generator | Visibility |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| (prototype) |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| (prototype) | `get` |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| (prototype) | `set` |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| (prototype) |  | `async` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| (prototype) |  |  | `*` |  |'
  prefs: []
  type: TYPE_TB
- en: '| (prototype) |  | `async` | `*` |  |'
  prefs: []
  type: TYPE_TB
- en: '| (prototype-associated) |  |  |  | `#` |'
  prefs: []
  type: TYPE_TB
- en: '| (prototype-associated) | `get` |  |  | `#` |'
  prefs: []
  type: TYPE_TB
- en: '| (prototype-associated) | `set` |  |  | `#` |'
  prefs: []
  type: TYPE_TB
- en: '| (prototype-associated) |  | `async` |  | `#` |'
  prefs: []
  type: TYPE_TB
- en: '| (prototype-associated) |  |  | `*` | `#` |'
  prefs: []
  type: TYPE_TB
- en: '| (prototype-associated) |  | `async` | `*` | `#` |'
  prefs: []
  type: TYPE_TB
- en: '| `static` |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `static` | `get` |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `static` | `set` |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `static` |  | `async` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `static` |  |  | `*` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `static` |  | `async` | `*` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `static` |  |  |  | `#` |'
  prefs: []
  type: TYPE_TB
- en: '| `static` | `get` |  |  | `#` |'
  prefs: []
  type: TYPE_TB
- en: '| `static` | `set` |  |  | `#` |'
  prefs: []
  type: TYPE_TB
- en: '| `static` |  | `async` |  | `#` |'
  prefs: []
  type: TYPE_TB
- en: '| `static` |  |  | `*` | `#` |'
  prefs: []
  type: TYPE_TB
- en: '| `static` |  | `async` | `*` | `#` |'
  prefs: []
  type: TYPE_TB
- en: 'Limitations of methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessors can’t be async or generators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.1.9 Under the hood
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It’s important to keep in mind that with classes, there are two chains of prototype
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: The instance chain which starts with an instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The static chain which starts with the class of that instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following plain JavaScript example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Fig. [1](#fig:class-prototype-chains) shows what the prototype chains look like
    that are created by `ClassA` and `ClassB`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1: The classes ClassA and ClassB create two prototype chains: One
    for classes (left-hand side) and one for instances (right-hand side).](../Images/0665e9f0d4e7a5093d20ad851c81a01c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: The classes `ClassA` and `ClassB` create two prototype chains: One
    for classes (left-hand side) and one for instances (right-hand side).'
  prefs: []
  type: TYPE_NORMAL
- en: 16.1.10 More information on class definitions in plain JavaScript
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Public fields, private fields, private methods/getters/setters](https://2ality.com/2019/07/public-class-fields.html)
    (blog post)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[All remaining JavaScript class features](https://exploringjs.com/impatient-js/ch_proto-chains-classes.html)
    (chapter in “JavaScript for impatient programming”)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.2 Non-public data slots in TypeScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, all data slots in TypeScript are public properties. There are two
    ways of keeping data private:'
  prefs: []
  type: TYPE_NORMAL
- en: Private properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll look at both next.
  prefs: []
  type: TYPE_NORMAL
- en: Note that TypeScript does not currently support private methods.
  prefs: []
  type: TYPE_NORMAL
- en: 16.2.1 Private properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Private properties are a TypeScript-only (static) feature. Any property can
    be made private by prefixing it with the keyword `private` (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We now get compile-time errors if we access that property in the wrong scope
    (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `private` doesn’t change anything at runtime. There, property `.name`
    is indistinguishable from a public property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also see that private properties aren’t protected at runtime when we
    look at the JavaScript code that the class is compiled to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 16.2.2 Private fields
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Private fields are a new JavaScript feature that TypeScript has supported since
    version 3.8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This version of `Person` is mostly used the same way as the private property
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this time, the data is completely encapsulated. Using the private
    field syntax outside classes is even a JavaScript syntax error. That’s why we
    have to use `eval()` in line A so that we can execute this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The compilation result is much more complicated now (slightly simplified):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This code uses a common technique for keeping instance data private:'
  prefs: []
  type: TYPE_NORMAL
- en: Each WeakMap implements one private field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It associates each instance with one piece of private data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information on this topic: see [“JavaScript for impatient programmers”](https://exploringjs.com/impatient-js/ch_weakmaps.html#private-data-in-weakmaps).'
  prefs: []
  type: TYPE_NORMAL
- en: 16.2.3 Private properties vs. private fields
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Downsides of private properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can’t reuse the names of private properties in subclasses (because the properties
    aren’t private at runtime).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: No encapsulation at runtime.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Upside of private properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Clients can circumvent the encapsulation and access private properties. This
    can be useful if someone needs to work around a bug. In other words: Data being
    completely encapsulated has pros and cons.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.2.4 Protected properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Private fields and private properties can’t be accessed in subclasses (line
    A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can fix the previous example by switching from `private` to `protected`
    in line A (we also switch in line B, for consistency’s sake):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 16.3 Private constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Constructors can be private, too. That is useful when we have static factory
    methods and want clients to always use those methods, never the constructor directly.
    Static methods can access private class members, which is why the factory methods
    can still use the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, there is one static factory method `DataContainer.create()`.
    It sets up instances via asynchronously loaded data. Keeping the asynchronous
    code in the factory method enables the actual class to be completely synchronous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In real-world code, we would use `fetch()` or a similar Promise-based API to
    load data asynchronously in line A.
  prefs: []
  type: TYPE_NORMAL
- en: The private constructor prevents `DataContainer` from being subclassed. If we
    want to allow subclasses, we have to make it `protected`.
  prefs: []
  type: TYPE_NORMAL
- en: 16.4 Initializing instance properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 16.4.1 Strict property initialization
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If the compiler setting `--strictPropertyInitialization` is switched on (which
    is the case if we use `--strict`), then TypeScript checks if all declared instance
    properties are correctly initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Either via assignments in the constructor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or via initializers for the property declarations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, sometimes we initialize properties in a manner that TypeScript doesn’t
    recognize. Then we can use exclamation marks (*definite assignment assertions*)
    to switch off TypeScript’s warnings (line A and line B):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '16.4.1.1 Example: setting up instance properties via objects'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the following example, we also need definite assignment assertions. Here,
    we set up instance properties via the constructor parameter `props`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Notes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In line B, we initialize all properties: We use `Object.assign()` to copy the
    properties of parameter `props` into `this`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line A, the `implements` ensures that the class declares all properties that
    are part of interface `CompilerErrorProps`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.4.2 Making constructor parameters `public`, `private`, or `protected`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we use the keyword `public` for a constructor parameter, then TypeScript
    does two things for us:'
  prefs: []
  type: TYPE_NORMAL
- en: It declares a public instance property with the same name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It assigns the parameter to that instance property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore, the following two classes are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If we use `private` or `protected` instead of `public`, then the corresponding
    instance properties are private or protected (not public).
  prefs: []
  type: TYPE_NORMAL
- en: 16.5 Abstract classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Two constructs can be abstract in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: An abstract class can’t be instantiated. Only its subclasses can – if they are
    not abstract, themselves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An abstract method has no implementation, only a type signature. Each concrete
    subclass must have a concrete method with the same name and a compatible type
    signature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a class has any abstract methods, it must be abstract, too.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The following code demonstrates abstract classes and methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'On one hand, there is the abstract superclass `Printable` and its helper class
    `StringBuilder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, there are the concrete subclasses `Entries` and `Entry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, this is us using `Entries` and `Entry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Notes about abstract classes:'
  prefs: []
  type: TYPE_NORMAL
- en: An abstract class can be seen as an interface where some members already have
    implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While a class can implement multiple interfaces, it can only extend at most
    one abstract class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Abstractness” only exists at compile time. At runtime, abstract classes are
    normal classes and abstract methods don’t exist (due to them only providing compile-time
    information).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract classes can be seen as templates where each abstract method is a blank
    that has to be filled in (implemented) by subclasses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/tackling-ts/issues/16)'
  prefs: []
  type: TYPE_NORMAL
