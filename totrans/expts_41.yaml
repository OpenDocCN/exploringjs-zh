- en: '33 Overview: computing with types'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/ts/book/ch_computing-with-types-overview.html](https://exploringjs.com/ts/book/ch_computing-with-types-overview.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Ad, please don’t block.)
  prefs: []
  type: TYPE_NORMAL
- en: '[33.1 Computation in TypeScript: program level vs. type level](#computation-in-typescript-program-level-vs-type-level)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.2 “Values” we can compute with at the type level](#values-we-can-compute-with-at-the-type-level)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.2.1 Primitive types](#primitive-types)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.2.2 Literal types](#literal-types)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.2.3 Non-generic object types](#non-generic-object-types)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.2.4 Compound types](#compound-types-1)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.2.5 Unions of literal types as sets of values](#unions-of-literal-types-as-sets-of-values)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.3 Generic types are type-level functions](#generic-types)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.3.1 Terminology: generic type, parameterized type, concrete type](#terminology-generic-type-parameterized-type-concrete-type)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.3.2 Optional type parameters](#optional-type-parameters)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.3.3 Constraining type parameters](#constraining-type-parameters)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.4 The `typeof` type operator: referring to the program level from the type
    level](#the-typeof-type-operator-referring-to-the-program-level-from-the-type-level)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.4.1 Program-level `typeof` vs. type-level `typeof`](#program-level-typeof-vs-type-level-typeof)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.4.2 Syntax of `typeof`](#syntax-of-typeof)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.5 The `keyof` type operator](#keyof-operator)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.5.1 Number keys: JavaScript vs. TypeScript](#number-keys-javascript-vs-typescript)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.5.2 `keyof` and index signatures](#keyof-and-index-signatures)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.5.3 `keyof` of an Array](#keyof-array)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.5.4 `keyof` of a tuple](#keyof-tuple)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.5.5 `keyof` of intersection types and union types](#keyof-of-intersection-types-and-union-types)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.6 Indexed access types `T[K]`](#indexed-access-types)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.6.1 `T[K]`: `K` must be a subset of the keys of `T`](#indexed-access-type-index)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.6.2 Indexed access of a tuple](#indexed-access-of-a-tuple)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.6.3 Example: implementing `ValueOf`](#ValueOf)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.6.4 Example: getting a property value](#example-getting-a-property-value)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.6.5 Example: lookup table and indexed access](#example-lookup-table-and-indexed-access)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.6.6 Indexed access and lookup table in `lib.dom.d.ts`](#indexed-access-and-lookup-table-in-lib-dom-d-ts)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.7 Conditional types (`C ? T : F`)](#conditional-types-c-t-f)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.7.1 Extracting parts of compound types via `infer`](#extracting-parts-of-compound-types-via-infer)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.8 Defining local type variables](#local-type-variables)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.8.1 Example](#example)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.9 Mapped types `{[K in U]: X}`](#mapped-types-k-in-u-x)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.10 Template literal types: processing strings](#template-literal-types-processing-strings)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.11 Computing with union types](#computing-with-union-types)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.11.1 Intersection and union](#intersection-and-union)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.11.2 Distributivity over union types](#distributivity)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.11.3 Template literal types are distributive](#distributivity-of-template-literal-types)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.11.4 Indexed access types `T[K]` are distributive](#distributivity-of-indexed-access-types)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.11.5 Conditional types are distributive](#conditional-types-are-distributive)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.12 Computing with object types](#computing-with-object-types)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.13 Computing with tuple types](#computing-with-tuple-types)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.14 Computed return types of functions often don’t match returned values](#computed-return-types-dont-match)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[33.15 Conclusion](#computing-with-types-conclusion)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this chapter, we explore how we can compute with types at compile time in
    TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “question”](../Images/471cce0defd950c2994152f322a88405.png) **Is computing
    with types useful in practice?**'
  prefs: []
  type: TYPE_NORMAL
- en: We first have to learn the foundations and some of the examples may seem a bit
    abstract. But those foundations help with solving practical problems – some of
    which are listed in [the conclusion](#computing-with-types-conclusion).
  prefs: []
  type: TYPE_NORMAL
- en: If you are *using* libraries, you can often get by without computing with types.
    If, however, you are *writing* libraries, it tends to come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: '[33.1 Computation in TypeScript: program level vs. type level](#computation-in-typescript-program-level-vs-type-level)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'TypeScript code has two levels of computation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Program level: At runtime, we can compute via values and functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type level: At compile time, we can compute via concrete types and generic
    types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  | Program level | Type level |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Programming language | JavaScript | TypeScript excluding JS |'
  prefs: []
  type: TYPE_TB
- en: '| Operands | values | concrete types |'
  prefs: []
  type: TYPE_TB
- en: '| Operations | functions | generic types |'
  prefs: []
  type: TYPE_TB
- en: '| Invoking an operation | calling a function | instantiating a generic type
    |'
  prefs: []
  type: TYPE_TB
- en: '| Computation happens | at runtime | at compile time |'
  prefs: []
  type: TYPE_TB
- en: 'This is an example of computing at the type level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`Uppercase` is a generic type. Its argument, in angular brackets, is the string
    literal type `''hello''`. The result of instantiating the generic type is the
    string literal type `''HELLO''`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The analogous computation at the program level looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the next subsection, we examine the “values” we can use at the type level.
    Then we’ll define our own type-level “functions”.
  prefs: []
  type: TYPE_NORMAL
- en: '[33.2 “Values” we can compute with at the type level](#values-we-can-compute-with-at-the-type-level)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the type level we can compute with the following “values”.
  prefs: []
  type: TYPE_NORMAL
- en: '[33.2.1 Primitive types](#primitive-types)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These are the primitive types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bigint`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symbol`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Even though two of them look like JavaScript values, we are operating at the
    type level:'
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined` is a type whose only value is `undefined`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null` is a type whose only value is `null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[33.2.2 Literal types](#literal-types)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These are examples of literal types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We are still operating at the type level:'
  prefs: []
  type: TYPE_NORMAL
- en: '`true` is a type whose only value is `true`. It is a subset of `boolean`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`12.34` is a type whose only value is `12.34`. It is a subset of `number`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[33.2.3 Non-generic object types](#non-generic-object-types)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These are examples of non-generic object types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RegExp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Uint8Array`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[33.2.4 Compound types](#compound-types-1)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can also compose types to produce new types – e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[33.2.5 Unions of literal types as sets of values](#unions-of-literal-types-as-sets-of-values)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When computing with types, unions of literal types are often used to represent
    sets of values – e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[The `keyof` operator](#keyof-operator) returns the keys of an object type.
    And it uses a union of string literal types to do so.'
  prefs: []
  type: TYPE_NORMAL
- en: '[33.3 Generic types are type-level functions](#generic-types)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following example is type-level code (that runs at compile time):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In line A, we define the *generic type* `Pair` that has one *type parameter*
    called `T`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line B, we define type `Result` to be the instantiation of `Pair` with the
    string literal type `'abc'`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the body of `Pair` contains type variables (`T`, twice). When we instantiate
    it, those variables are replaced with concrete types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example is similar program-level code (that runs at runtime):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[33.3.1 Terminology: generic type, parameterized type, concrete type](#terminology-generic-type-parameterized-type-concrete-type)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I like [Angelika Langer’s definitions](http://www.angelikalanger.com/GenericsFAQ/FAQSections/ParameterizedTypes.html#FAQ001):'
  prefs: []
  type: TYPE_NORMAL
- en: A *generic type* is a type with formal type parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *parameterized type* is an instantiation of a generic type with actual type
    arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`Pair` is a generic type. `Pair<3>` is a parameterized type – an instantiation
    of `Pair`. We say that `Pair<3>` *constructs* (“returns”) the type `[3, 3]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *concrete type* is a specific (potentially compound) type that can be used
    in a type annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[33.3.2 Optional type parameters](#optional-type-parameters)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can make a type parameter optional by specifying a default value via an
    equals sign (`=`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[33.3.3 Constraining type parameters](#constraining-type-parameters)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a type parameter definition is just the variable, it accepts any type but
    we can also constrain which types it accepts – via the keyword `extends`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`T extends C` means that:'
  prefs: []
  type: TYPE_NORMAL
- en: '`T` must be assignable to `C`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T` must be a subset of `C`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extends` in a parameter definition of a generic type is similar to the colon
    (`:`) in a parameter definition of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We an also combine `extends` with a parameter default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[33.4 The `typeof` type operator: referring to the program level from the type
    level](#the-typeof-type-operator-referring-to-the-program-level-from-the-type-level)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '(Non-type) variables and type expressions exist at two different levels:'
  prefs: []
  type: TYPE_NORMAL
- en: Variables exist at the program level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type expressions exist at the type level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore, we can’t directly mention a variable inside a type expression. However,
    the type-level `typeof` operator enables us to refer to the type of a variable
    inside a type expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[33.4.1 Program-level `typeof` vs. type-level `typeof`](#program-level-typeof-vs-type-level-typeof)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'JavaScript also has a `typeof` operator – one that operates at the program
    level. For a given value, it returns the name of its type as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of type-level `typeof` are usually much more complex than the results
    of program-level `typeof`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[33.4.2 Syntax of `typeof`](#syntax-of-typeof)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The operand must be an an identifier which can optionally be followed by member
    accesses (dot operator or square brackets operator). Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Any other operand produces a syntax error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[33.5 The `keyof` type operator](#keyof-operator)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The type operator `keyof` lists the property keys of an object type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The property keys of an empty object type are the empty set `never`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[33.5.1 Number keys: JavaScript vs. TypeScript](#number-keys-javascript-vs-typescript)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[33.5.1.1 Number keys in JavaScript](#number-keys-in-javascript)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'JavaScript treats all number keys (whether quoted or not) as strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, Array elements are properties whose keys are stringified numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: For information on what Array elements are in JavaScript, see [“Exploring JavaScript”](https://exploringjs.com/js/book/ch_arrays.html#arrays-are-actually-dictionaries).
  prefs: []
  type: TYPE_NORMAL
- en: '[33.5.1.2 Number keys in TypeScript](#number-keys-in-typescript)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In object literal types, unquoted number keys are number literal types and
    quoted number keys are string literal types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript also makes that distinction if types are derived from JavaScript
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The indices of an Array type are numbers (note the `Includes` in the first
    line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[33.5.2 `keyof` and index signatures](#keyof-and-index-signatures)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The key of a number index signature is `number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The key of a string index signature is `string | number` because in JavaScript,
    number keys are a subset of string keys (as explained the previous subsection):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[33.5.3 `keyof` of an Array](#keyof-array)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The keys of an Array type include a variety of types (note the `Includes` in
    the first line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The keys consist of:'
  prefs: []
  type: TYPE_NORMAL
- en: The type `number` for Array indices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the special instance property `.length`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The names of all `Array` methods: `''push'' | ''join'' | ···`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[33.5.4 `keyof` of a tuple](#keyof-tuple)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since tuples are mostly Arrays, their keys look similar (note the `Includes`
    in the first line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As with Arrays, there are `number`, `'length'` and the names of methods. Additionally,
    there is a stringified index for each element.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on this topic, including how to extract tuple indices,
    see [“The keys of tuple types” (§37.3)](ch_computing-with-tuple-types.html#keyof-tuple-type).
  prefs: []
  type: TYPE_NORMAL
- en: '[33.5.5 `keyof` of intersection types and union types](#keyof-of-intersection-types-and-union-types)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is how `keyof` handles intersection types and union types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes sense if we remember that:'
  prefs: []
  type: TYPE_NORMAL
- en: An object of type `A & B` has the properties of *both* type `A` and type `B`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object of type `A | B` has either the properties of type `A` or the properties
    of type `B`. That is, only properties that both types have in common are always
    there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[33.6 Indexed access types `T[K]`](#indexed-access-types)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The indexed access operator `T[K]` returns the types of all properties of `T`
    whose keys are assignable to type `K`. `T[K]` is also called a *lookup type*.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are examples of the operator being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[33.6.1 `T[K]`: `K` must be a subset of the keys of `T`](#indexed-access-type-index)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The type in brackets must be assignable to the type of all property keys (as
    computed by `keyof`). That’s why `Obj[string]` and `Obj[number]` are not allowed
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can use `string` and `number` as index types if the indexed type
    has an index signature (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`keyof Obj` (line B) includes the type `number` because number keys are a subset
    of string keys in JavaScript (and therefore in TypeScript).'
  prefs: []
  type: TYPE_NORMAL
- en: '[33.6.2 Indexed access of a tuple](#indexed-access-of-a-tuple)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Tuple types also support indexed access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We can use `number` as an index because the `keyof` of a tuple includes the
    type `number` ([more information](#keyof-tuple)).
  prefs: []
  type: TYPE_NORMAL
- en: '[33.6.3 Example: implementing `ValueOf`](#ValueOf)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'TypeScript has a `keyof` operator but no `valueof` operator. However, we can
    implement that operator ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[33.6.4 Example: getting a property value](#example-getting-a-property-value)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following function retrieves the value of the property of `obj` whose key
    is `key`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s interesting that, in addition to correctly computing the type of `result`,
    TypeScript also warns us if we get the key wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[33.6.5 Example: lookup table and indexed access](#example-lookup-table-and-indexed-access)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Thanks to the indexed access operator, we can easily map from one kind of type
    to another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Alas, object literal types only work as lookup tables if the key type is a subset
    of `string`, `number` or `symbol`. For other types, we need to [work with tuples](ch_computing-with-tuple-types.html#tuple-lookup-table).
  prefs: []
  type: TYPE_NORMAL
- en: '[33.6.6 Indexed access and lookup table in `lib.dom.d.ts`](#indexed-access-and-lookup-table-in-lib-dom-d-ts)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The built-in type definitions for the DOM ([`lib.dom.d.ts`](https://github.com/microsoft/TypeScript/blob/main/src/lib/dom.generated.d.ts))
    use indexed access and a lookup table `GlobalEventHandlersEventMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[33.7 Conditional types (`C ? T : F`)](#conditional-types-c-t-f)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *conditional type* has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If `Sub` is assignable to `Super`, the result of the conditional type is `TrueBranch`.
    Otherwise, it is `FalseBranch`. This is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'For more information see [“Conditional types (`C ? T : F`)” (§34)](ch_conditional-types.html#ch_conditional-types).'
  prefs: []
  type: TYPE_NORMAL
- en: '[33.7.1 Extracting parts of compound types via `infer`](#extracting-parts-of-compound-types-via-infer)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `infer` keyword can only be used in the condition of a conditional type
    and extracts parts of compound types into type variables – e.g., the following
    generic type extracts what’s inside the angle brackets of `Array<>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`infer` has a lot in common with [destructuring](https://exploringjs.com/js/book/ch_destructuring.html#ch_destructuring)
    in JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: For more information, see [“Extracting parts of compound types via `infer`”
    (§35)](ch_infer-keyword.html#ch_infer-keyword).
  prefs: []
  type: TYPE_NORMAL
- en: '[33.8 Defining local type variables](#local-type-variables)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Normal programming languages let us define local variables to help with managing
    various bits of data. Alas, the type level of TypeScript does not have this feature.
    If it had, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can emulate it via `infer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also define multiple variables at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[33.8.1 Example](#example)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is an example where this technique is useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the “body” of a generic type, we can also use a different technique – a
    helper parameter with a default value (`W` in the following code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[33.9 Mapped types `{[K in U]: X}`](#mapped-types-k-in-u-x)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Roughly, a mapped type creates a new version of an input type `T` (usually
    an object type or a tuple type) by looping over its keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`«PropValue»` is a type expression that often uses `K` in some way. This is
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[33.10 Template literal types: processing strings](#template-literal-types-processing-strings)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Template literal types have the same syntax as JavaScript template literals.
    Two important use cases for them are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, concatenating string literal types (the template literal is in line
    A, delimited by backticks):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, extracting parts of string literal types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In line A, we extract part of `AsyncMethodName` into the type variable `MN`,
    via the `infer` operator. That operator works similarly destructuring in JavaScript.
    It must be used inside a conditional type (`Cond ? True : False`).'
  prefs: []
  type: TYPE_NORMAL
- en: Both concatenating and extracting string literal types are useful in many situations,
    e.g. they enable us to transform the names of object properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[33.11 Computing with union types](#computing-with-union-types)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we explore how to compute with union types.
  prefs: []
  type: TYPE_NORMAL
- en: '[33.11.1 Intersection and union](#intersection-and-union)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can intersect union types via `&`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'And, as expected, we can also compute unions via `|`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[33.11.2 Distributivity over union types](#distributivity)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One interesting phenomenon with union types is that some operations are *distributive*
    over them:'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the operation to a non-union type produces a single output type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the operation to a union type produces a union of output types – one
    for each element of the input union.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[33.11.3 Template literal types are distributive](#distributivity-of-template-literal-types)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next example demonstrates that applying the template literal type in line
    A to a union produces a union of string literal types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[33.11.4 Indexed access types `T[K]` are distributive](#distributivity-of-indexed-access-types)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The next example applies an indexed access type to a union of object literal
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[33.11.5 Conditional types are distributive](#conditional-types-are-distributive)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because they are distributive, conditional types are the most important tool
    for working with union types. In this section, we explore a few examples. For
    more information, see [“Conditional types are distributive over union types” (§34.2)](ch_conditional-types.html#distributivity-of-conditional-types).
  prefs: []
  type: TYPE_NORMAL
- en: '[33.11.5.1 Mapping a union type](#mapping-a-union-type)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[33.11.5.2 Filtering a union type](#filtering-a-union-type)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[33.12 Computing with object types](#computing-with-object-types)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'How to compute with object types is explained elsewhere:'
  prefs: []
  type: TYPE_NORMAL
- en: We can transform and create object types via [mapped types](ch_mapped-types.html#ch_mapped-types).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Template literal types](ch_template-literal-types.html#ch_template-literal-types)
    help us with changing property names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[33.13 Computing with tuple types](#computing-with-tuple-types)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'See [“Computing with tuple types” (§37)](ch_computing-with-tuple-types.html#ch_computing-with-tuple-types):'
  prefs: []
  type: TYPE_NORMAL
- en: We can map tuples via mapped types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For other operations, such as filtering, we often need recursion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[33.14 Computed return types of functions often don’t match returned values](#computed-return-types-dont-match)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One downside of computed return types of functions is that TypeScript often
    thinks that the type of the returned value doesn’t match the computed type. This
    is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Sadly, the value returned in line B is not assignable to the return type specified
    in line A. There are several ways of fixing this error – all of them involve a
    type assertion (`as`). This is one solution – using `as any` in line B:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Options for getting the return type right:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicitly defining a return type (as we have done in line A) plus a type assertion
    in line B:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`as any` (our current solution)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`as unknown as PrependDollarSign<Obj>` (an alternative to what we have done).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Does not work: `as unknown`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inferring the return type (omitting it in line A) plus a type assertion in
    line B:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`as unknown as PrependDollarSign<Obj>`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I prefer the solution that is used above because inferred return types prevent
    some ways of generating `.d.ts` files: [“`isolatedDeclarations`: generating `.d.ts`
    files more efficiently” (§8.8.5)](ch_tsconfig-json.html#isolatedDeclarations)'
  prefs: []
  type: TYPE_NORMAL
- en: '[33.15 Conclusion](#computing-with-types-conclusion)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Computing with types is fascinating:'
  prefs: []
  type: TYPE_NORMAL
- en: We are writing programs at the type level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It enables us to provide types for relatively complicated functionality, such
    as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Promise.all()`](ch_computing-with-tuple-types.html#typing-Promise.all)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`zip()`](ch_computing-with-tuple-types.html#typing-zip)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Property paths](ch_template-literal-types.html#example-property-paths)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Converting hyphen case to camel case at the type level](ch_template-literal-types.html#example-from-hyphen-case-to-camel-case)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We effectively implement a solution twice (see previous section): Once at the
    program level and once at the type level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Computed types do make code more complex. My general recommendation is: Keep
    your types as simple as possible and do type-level computations only if it’s absolutely
    necessary. In some cases, it may be possible to use simpler types by restructuring
    code and/or data.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, there are projects where *writing* the types took cleverness,
    but *using* them is fun. One small example is [a prototype of a simple SQL API](https://github.com/rauschma/simple-sql)
    that I wrote.
  prefs: []
  type: TYPE_NORMAL
