<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>6 How TypeScript is used: workflows, tools, etc.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>6 How TypeScript is used: workflows, tools, etc.</h1>
<blockquote>原文：<a href="https://exploringjs.com/ts/book/ch_typescript-workflows.html">https://exploringjs.com/ts/book/ch_typescript-workflows.html</a></blockquote>

    
        <div id="adbox">
      <div id="adbox-explain">(Ad, please don’t block.)</div>
              
          </div>
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#typescript-is-javascript-plus-type-syntax">6.1 TypeScript is JavaScript plus type syntax</a>
    </li>
    <li>
      <a href="#ways-of-running-typescript-code">6.2 Ways of running TypeScript code</a>
      <ol>
        <li>
          <a href="#running-typescript-directly-1">6.2.1 Running TypeScript directly</a>
        </li>
        <li>
          <a href="#bundling">6.2.2 Bundling TypeScript</a>
        </li>
        <li>
          <a href="#transpiling-typescript-to-javascript">6.2.3 Transpiling TypeScript to JavaScript</a>
        </li>
        <li>
          <a href="#the-filename-extensions-of-locally-imported-typescript-modules">6.2.4 The filename extensions of locally imported TypeScript modules</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#publishing-a-library-package-to-the-npm-registry">6.3 Publishing a library package to the npm registry</a>
      <ol>
        <li>
          <a href="#essential-js-and-d-ts">6.3.1 Essential: <code>.js</code> and <code>.d.ts</code></a>
        </li>
        <li>
          <a href="#optional-source-maps">6.3.2 Optional: source maps</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#definitelytyped-a-repository-with-types-for-type-less-npm-packages">6.4 DefinitelyTyped: a repository with types for type-less npm packages</a>
    </li>
    <li>
      <a href="#compiling-typescript-with-tools-other-than-tsc">6.5 Compiling TypeScript with tools other than <code>tsc</code></a>
      <ol>
        <li>
          <a href="#type-stripping-1">6.5.1 Type stripping</a>
        </li>
        <li>
          <a href="#isolated-declarations">6.5.2 Isolated declarations</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#jsr-the-javascript-registry">6.6 JSR – the JavaScript registry</a>
      <ol>
        <li>
          <a href="#who-owns-jsr">6.6.1 Who owns JSR?</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#editing-typescript">6.7 Editing TypeScript</a>
    </li>
    <li>
      <a href="#check-js">6.8 Type-checking JavaScript files</a>
    </li>
  </ol>
</nav>
<p>Read this chapter if you are a JavaScript programmer and want to get a rough idea of what using TypeScript is like (think first step before learning more details). You’ll get answers to the following questions:</p>
<ul>
  <li>
    How is TypeScript code different from JavaScript code?
  </li>
  <li>
    How is TypeScript code run?
  </li>
  <li>
    How does TypeScript help during editing in an IDE?
  </li>
  <li>
    Etc.
  </li>
</ul>
<p>This chapter focuses on how TypeScript works. If you want to know more about why it is useful, see <a href="ch_why-typescript.html#ch_why-typescript">“Sales pitch for TypeScript” (§2)</a>.</p>
<h3 id="typescript-is-javascript-plus-type-syntax"><a class="heading-id-link" href="#typescript-is-javascript-plus-type-syntax">6.1 TypeScript is JavaScript plus type syntax</a></h3>
<p>Let’s start with a rough first description of what TypeScript is. That description is not completely accurate (there are exceptions and details that I’m omitting), but it should give you a solid first idea:</p>
<blockquote>
  <p>TypeScript is JavaScript plus type syntax.</p>
</blockquote>
<p>What are the purposes of these two parts?</p>
<ul>
  <li>
    <p>The JavaScript syntax is what is run and what exists at runtime: In order to run TypeScript code, the type syntax must be removed – via compilation that results in pure JavaScript. That code is executed by a JavaScript engine.</p>
  </li>
  <li>
    <p>The type syntax is only used during editing and compiling; it has no effect at runtime:</p>
    <ul>
      <li>
        On one hand, it supports <em>type checking</em> which reports errors if there are inconsistencies within the types or between the types and the JavaScript values. Type checking runs during editing and during compiling.
      </li>
      <li>
        On the other hand, the types improve editing via auto-completion, type hints, refactorings, etc.
      </li>
    </ul>
  </li>
</ul>
<p>Consider the following TypeScript code:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {</code>
<code>  <span class="hljs-keyword">return</span> x + y;</code>
<code>}</code>
</pre>
<p>If we want to run this code, we have to remove the type syntax and get JavaScript that is executed by a JavaScript engine:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) {</code>
<code>  <span class="hljs-keyword">return</span> x + y;</code>
<code>}</code>
</pre>
<h3 id="ways-of-running-typescript-code"><a class="heading-id-link" href="#ways-of-running-typescript-code">6.2 Ways of running TypeScript code</a></h3>
<p>Consider the following TypeScript project:</p>
<pre>
<code>ts-app/</code>
<code>  tsconfig.json</code>
<code>  src/</code>
<code>    main.ts</code>
<code>    util.ts</code>
<code>    util_test.ts</code>
<code>  test/</code>
<code>    integration_test.ts</code>
</pre>
<ul>
  <li>
    <code>tsconfig.json</code> is a configuration file that tells TypeScript how to type-check and compile our code.
  </li>
  <li>
    The remaining files are TypeScript source code.
  </li>
</ul>
<p>Let’s explore the different ways in which we can run this code.</p>
<h4 id="running-typescript-directly-1"><a class="heading-id-link" href="#running-typescript-directly-1">6.2.1 Running TypeScript directly</a></h4>
<p>Most server-side runtimes now can run TypeScript code directly – e.g., Node.js, Deno and Bun. In other words, the following works in Node.js 23.6.0+:</p>
<pre>
<code>cd ts-app/</code>
<code>node src/main.ts</code>
</pre>
<h4 id="bundling"><a class="heading-id-link" href="#bundling">6.2.2 Bundling TypeScript</a></h4>
<p>When developing a web app, <em>bundling</em> is a common practice – even for pure JavaScript projects: All the JavaScript code (app code and library code) is combined into a single JavaScript file (sometimes more, but never more than a few) – which is typically loaded from an HTML file. That has several benefits:</p>
<ul>
  <li>
    Prior to HTTP/2, only one file could be served per connection. But that benefit of bundling is not relevant anymore.
    <ul>
      <li>
        Each file the client has to request and process, still incurs a little overhead (even though no new connection is opened).
      </li>
    </ul>
  </li>
  <li>
    Web servers don’t have to serve many (often small) files – which helps with efficiency.
  </li>
  <li>
    A single large file can be compressed better than many small files.
  </li>
</ul>
<p>Most bundlers support TypeScript – either directly or via plugins. That means, we run our TypeScript code via the JavaScript file <code>bundle.js</code> that was produced by a bundler:</p>
<pre>
<code>ts-app/</code>
<code>  tsconfig.json</code>
<code>  src/</code>
<code>    main.ts</code>
<code>    util.ts</code>
<code>    util_test.ts</code>
<code>  test/</code>
<code>    integration_test.ts</code>
<code>  dist/</code>
<code>    bundle.js</code>
</pre>
<h4 id="transpiling-typescript-to-javascript"><a class="heading-id-link" href="#transpiling-typescript-to-javascript">6.2.3 Transpiling TypeScript to JavaScript</a></h4>
<p>Another option is to compile out TypeScript app to JavaScript via the TypeScript compiler <code>tsc</code> and run the resulting code. Before server-side JavaScript runtimes had built-in support for TypeScript, that was the only way we could run TypeScript there.</p>
<p>Compiling source code to source code is also called <em>transpiling</em>. <code>tsconfig.json</code> specifies where the transpilation output is written. Let’s assume we write it to the directory <code>dist/</code>:</p>
<pre>
<code>ts-app/</code>
<code>  tsconfig.json</code>
<code>  src/</code>
<code>    main.ts</code>
<code>    util.ts</code>
<code>    util_test.ts</code>
<code>  test/</code>
<code>    integration_test.ts</code>
<code>  dist/</code>
<code>    src/</code>
<code>      main.js</code>
<code>      util.js</code>
<code>      util_test.js</code>
<code>    test/</code>
<code>      integration_test.js</code>
</pre>
<h4 id="the-filename-extensions-of-locally-imported-typescript-modules"><a class="heading-id-link" href="#the-filename-extensions-of-locally-imported-typescript-modules">6.2.4 The filename extensions of locally imported TypeScript modules</a></h4>
<p>When it comes to filename extensions of locally imported TypeScript modules, we must distinguish between code that is transpiled and code that is run directly.</p>
<p>By default, TypeScript does not change the specifiers of imported modules. Therefore, code that is transpiled must look like this (we import <code>util.js</code>, from JavaScript code):</p>
<pre class="language-ts">
<code><span class="hljs-comment">// main.ts</span></code>
<code><span class="hljs-keyword">import</span> {helperFunc} <span class="hljs-keyword">from</span> <span class="hljs-string">'./util.js'</span>;</code>
</pre>
<p>However, such code does not work if we run it directly. There, we must write (we import <code>util.ts</code> from TypeScript code):</p>
<pre class="language-ts">
<code><span class="hljs-comment">// main.ts</span></code>
<code><span class="hljs-keyword">import</span> {helperFunc} <span class="hljs-keyword">from</span> <span class="hljs-string">'./util.ts'</span>;</code>
</pre>
<p>We can also tell TypeScript to change the filename extensions of local imports from <code>.ts</code> to <code>.js</code> (<a href="ch_tsconfig-json.html#running-typescript-directly">more information</a>). Then the previous code can also be transpiled.</p>
<h3 id="publishing-a-library-package-to-the-npm-registry"><a class="heading-id-link" href="#publishing-a-library-package-to-the-npm-registry">6.3 Publishing a library package to the npm registry</a></h3>
<p>The npm registry is still the most popular means of publishing packages. Even though Node.js runs TypeScript code, packages must be deployed as JavaScript code. That enables JavaScript code to use library packages written in TypeScript. However, we additionally want to support TypeScript features. Therefore, a single library file <code>lib.ts</code> is often deployed as five files (four of which are compiled by TypeScript from <code>lib.ts</code>):</p>
<ul>
  <li>
    Essential:
    <ul>
      <li>
        <code>lib.js</code>: the JavaScript part of <code>lib.ts</code>
      </li>
      <li>
        <code>lib.d.ts</code>: the type part of <code>lib.ts</code> (a <em>declaration file</em>)
      </li>
    </ul>
  </li>
  <li>
    Optional: source maps. They map source code locations of compilation output to <code>lib.ts</code>.
    <ul>
      <li>
        <code>lib.js.map</code>: source map for <code>lib.js</code>
      </li>
      <li>
        <code>lib.d.ts.map</code>: source map for <code>lib.d.ts</code>
      </li>
      <li>
        <code>lib.ts</code>: the target of the previous two source maps
      </li>
    </ul>
  </li>
</ul>
<p>(More on what all of that means in a second.)</p>
<p>As an example, consider the following library package:</p>
<pre>
<code>ts-lib/</code>
<code>  package.json</code>
<code>  tsconfig.json</code>
<code>  src/</code>
<code>    lib.ts</code>
<code>  dist/</code>
<code>    lib.js</code>
<code>    lib.js.map</code>
<code>    lib.d.ts</code>
<code>    lib.d.ts.map</code>
</pre>
<ul>
  <li>
    <code>package.json</code> is npm’s description of our library package. Some of its data, such as the so-called <em>package exports</em>, are also used by TypeScript – e.g. to look up type information when someone imports from our package.
  </li>
  <li>
    Every file in <code>dist/</code> was generated by TypeScript. While it is uploaded to the npm registry, it is usually not added to version control systems because it can easily be regenerated.
  </li>
  <li>
    Only <code>tsconfig.json</code> is not uploaded to the npm registry.
  </li>
</ul>
<h4 id="essential-js-and-d-ts"><a class="heading-id-link" href="#essential-js-and-d-ts">6.3.1 Essential: <code>.js</code> and <code>.d.ts</code></a></h4>
<p>It’s interesting to see the combined JavaScript plus types in <code>.lib.ts</code> be split into <code>lib.js</code> with only JavaScript and <code>lib.d.ts</code> with only types. Why do that? It enables library packages to be used by either JavaScript code or TypeScript code:</p>
<ul>
  <li>
    JavaScript code can ignore <code>.d.ts</code> files.
  </li>
  <li>
    TypeScript uses them for type checking, auto-completion, refactorings, etc.
  </li>
</ul>
<p>Actually, behind the scenes, many editors (e.g. Visual Studio Code) use a kind of lightweight TypeScript mode when editing JavaScript code so that we also get simple type checking and code completion there.</p>
<p>This is the TypeScript input <code>lib.ts</code></p>
<pre class="language-ts">
<code><span class="hljs-comment">/** Add two numbers. */</span></code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {</code>
<code>  <span class="hljs-keyword">return</span> x + y; <span class="hljs-comment">// numeric addition</span></code>
<code>}</code>
</pre>
<p>It is split into <code>lib.js</code> on one hand:</p>
<pre class="language-js">
<code><span class="hljs-comment">/** Add two numbers. */</span></code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) {</code>
<code>    <span class="hljs-keyword">return</span> x + y; <span class="hljs-comment">// numeric addition</span></code>
<code>}</code>
<code><span class="hljs-comment">//# sourceMappingURL=lib.js.map</span></code>
</pre>
<p>And <code>lib.d.ts</code> on the other hand:</p>
<pre class="language-ts">
<code><span class="hljs-comment">/** Add two numbers. */</span></code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>;</code>
<code><span class="hljs-comment">//# sourceMappingURL=lib.d.ts.map</span></code>
</pre>
<p>Notes:</p>
<ul>
  <li>
    Both files point to their source maps.
  </li>
  <li>
    By default, both files contain comments (but we can tell TypeScript not to include them):
    <ul>
      <li>
        <code>lib.js</code> has all comments so that the code is easier to read.
      </li>
      <li>
        <code>lib.d.ts</code> only has JSDoc comments (<code>/** */</code>) because they are used by many IDEs to display inline documentation.
      </li>
    </ul>
  </li>
</ul>
<h4 id="optional-source-maps"><a class="heading-id-link" href="#optional-source-maps">6.3.2 Optional: source maps</a></h4>
<p>If we compile a file <code>I</code> to a file <code>O</code> then a source map for <code>O</code> maps source code locations in <code>O</code> to source code locations in <code>I</code>. That means we can work with <code>O</code> but display information from <code>I</code> – e.g.:</p>
<ul>
  <li>
    <code>lib.js.map</code>: maps <code>lib.js</code> locations to <code>lib.ts</code> locations and gives us debugging and stack traces for the latter when we run the former.
  </li>
  <li>
    <code>lib.d.ts.map</code>: maps <code>lib.d.ts</code> lines to <code>lib.ts</code> lines. It enables “go to definition” for imports from <code>lib.ts</code> to take us to that file.
  </li>
</ul>
<p>All source-map-related functionality except stack traces require access to the original TypeScript source code. That’s why it makes sense to include <code>lib.ts</code> if there are source maps.</p>
<p>This is what <code>lib.js.map</code> looks like:</p>
<pre class="language-json">
<code><span class="hljs-punctuation">{</span></code>
<code>  <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"file"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"lib.js"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"sourceRoot"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"sources"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span></code>
<code>    <span class="hljs-string">"../../src/lib.ts"</span></code>
<code>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"names"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"mappings"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"AAAA,uBAAuB;AACvB,MAAM,UAAU,···"</span></code>
<code><span class="hljs-punctuation">}</span></code>
</pre>
<p>This is what <code>lib.d.ts.map</code> looks like:</p>
<pre class="language-json">
<code><span class="hljs-punctuation">{</span></code>
<code>  <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"file"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"lib.d.ts"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"sourceRoot"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"sources"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span></code>
<code>    <span class="hljs-string">"../../src/lib.ts"</span></code>
<code>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"names"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"mappings"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"AAAA,uBAAuB;AACvB,wBAAgB,GAAG,···"</span></code>
<code><span class="hljs-punctuation">}</span></code>
</pre>
<p>In both cases, the actual content of <code>"mappings"</code> was abbreviated. And in the actual output of <code>tsc</code>, the JSON is always squeezed into a single line.</p>
<h3 id="definitelytyped-a-repository-with-types-for-type-less-npm-packages"><a class="heading-id-link" href="#definitelytyped-a-repository-with-types-for-type-less-npm-packages">6.4 DefinitelyTyped: a repository with types for type-less npm packages</a></h3>
<p>These days, many npm packages come with TypeScript types. However, not all of them do. In that case, <a href="https://definitelytyped.org">DefinitelyTyped</a> may help: If it supports a type-less package <code>pkg</code> then we can additionally install a package <code>@types/pkg</code> with types for <code>pkg</code>.</p>
<p>One important DefinitelyTyped package for Node.js is <code>@types/node</code> with types for all of its APIs. If you develop TypeScript on Node.js, you will usually have this package as a development dependency.</p>
<h3 id="compiling-typescript-with-tools-other-than-tsc"><a class="heading-id-link" href="#compiling-typescript-with-tools-other-than-tsc">6.5 Compiling TypeScript with tools other than <code>tsc</code></a></h3>
<p>Let’s recap all the tasks performed by <code>tsc</code> (we’ll ignore source maps in this section):</p>
<ol>
  <li>
    It compiles TypeScript files to JavaScript files.
  </li>
  <li>
    It compiles TypeScript files to type declaration files.
  </li>
  <li>
    It type-checks TypeScript files.
  </li>
</ol>
<p>##3 is so complex that only <code>tsc</code> can do it. However, for both #1 and #2, there are slightly simpler subsets of TypeScript where compilation does not involve much more than syntactic processing. That means that we can use external, faster tools for #1 and #2.</p>
<p>There are even <code>tsconfig.json</code> settings to warn us if we don’t stay within those subsets of TypeScript (<a href="ch_tsconfig-json.html#compiling-without-tsc">more information</a>). Doing that is not much of a sacrifice in practice.</p>
<h4 id="type-stripping-1"><a class="heading-id-link" href="#type-stripping-1">6.5.1 Type stripping</a></h4>
<p><em>Type stripping</em> is a simple and fast way of compiling TypeScript to JavaScript. It’s what Node.js uses when it runs TypeScript. Type stripping is fast because it only supports a subset of TypeScript where two things are possible:</p>
<ol>
  <li>
    <p>Type syntax can be detected and removed by only parsing the syntax – without performing additional semantic analyses.</p>
  </li>
  <li>
    <p>No non-type language features are transpiled. In other words: Removing the type syntax is enough to produce JavaScript.</p>
  </li>
</ol>
<p>#2 means that there are several TypeScript features that we can’t use – e.g., enums and JSX (HTML-like syntax inside TypeScript, as used, e.g., by React).</p>
<p>One considerable benefit of type stripping is that it does not need any configuration (via <code>tsconfig.json</code> or other means) because it’s so simple. That makes platforms that use it more stable w.r.t. changes made to TypeScript.</p>
<h5 id="ts-blank-space"><a class="heading-id-link" href="#ts-blank-space">6.5.1.1 Type stripping technique: replacing types with spaces</a></h5>
<p>One clever technique for type stripping was pioneered by the <a href="https://bloomberg.github.io/ts-blank-space/"><code>ts-blank-space</code></a> tool (by Ashley Claymore for Bloomberg): Instead of simply removing the type syntax, it replaces it with spaces. That means that source code positions in the output don’t change. Therefore, any positions that show up (e.g.) in stack traces still work for the input and there is less of a need for source maps: You still need them for debugging and going to definitions but JavaScript generated by type stripping is relatively close to the original TypeScript and you are often OK even then.</p>
<p>For example - input (TypeScript):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {</code>
<code>  <span class="hljs-keyword">return</span> x + y;</code>
<code>}</code>
</pre>
<p>Output (JavaScript):</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x        , y        </span>)         {</code>
<code>  <span class="hljs-keyword">return</span> x + y;</code>
<code>}</code>
</pre>
<p>If you want to explore further, you can check out <a href="https://bloomberg.github.io/ts-blank-space/play/">the ts-blank-space playground</a>.</p>
<h4 id="isolated-declarations"><a class="heading-id-link" href="#isolated-declarations">6.5.2 Isolated declarations</a></h4>
<p>“Isolated declaration” is a style of writing TypeScript that makes it easier for external tools to generate declaration files. It mainly means we have to add type annotations in locations where the TypeScript compiler <code>tsc</code> does not need them – thanks to its ability to automatically derive types (so-called <em>type inference</em>). However, external tools are simpler and faster if they don’t need that ability. Additionally, they don’t have to visit and analyze external files if the type information is provided locally.</p>
<p>The following example shows how the isolated declaration style changes code:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// OK: return type stated explicitly</span></code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params">): <span class="hljs-built_in">string</span> {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">return</span> <span class="hljs-number">123.</span>.<span class="hljs-title function_">toString</span>();</span></code>
<code><span class="hljs-params">}</span></code>
<code><span class="hljs-params"><span class="hljs-comment">// Error: return type requires inference</span></span></code>
<code><span class="hljs-params"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"/>) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">return</span> <span class="hljs-number">123.</span>.<span class="hljs-title function_">toString</span>();</span></code>
<code><span class="hljs-params">}</span></code>
<code><span class="hljs-params"><span class="hljs-comment">// OK: return type trivial to determine</span></span></code>
<code><span class="hljs-params"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f3</span>(<span class="hljs-params"/>) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p>Note that isolated declarations only affect constructs that are exported. Module-internal code does not show up in declaration files.</p>
<h3 id="jsr-the-javascript-registry"><a class="heading-id-link" href="#jsr-the-javascript-registry">6.6 JSR – the JavaScript registry</a></h3>
<p><a href="https://jsr.io">The JavaScript registry JSR</a> is an alternative to npm and the npm registry for publishing packages. It works as follows:</p>
<ul>
  <li>
    For TypeScript packages, you only upload <code>.ts</code> files.
  </li>
  <li>
    How to install a TypeScript package depends on the platform:
    <ul>
      <li>
        On JavaScript platforms where TypeScript-only library packages are supported, JSR only installs TypeScript.
      </li>
      <li>
        On all other platforms, JSR automatically generates <code>.js</code> files and <code>.d.ts</code> files and installs those, along with the <code>.ts</code> files. To make automatic generation possible, the TypeScript code must follow a set of rules called <a href="https://jsr.io/docs/about-slow-types">“no slow types”</a> – which is similar to <a href="#isolated-declarations">isolated declarations</a>.
      </li>
    </ul>
  </li>
</ul>
<p>In contrast, with the npm registry, your TypeScript library package is only usable on Node.js if you upload <code>.js</code> files and <code>.d.ts</code> files.</p>
<p>JSR also provides several features that npm doesn’t such as automatic generation of documentation. See <a href="https://jsr.io/docs/why">“Why JSR?”</a> in the official documentation for more information.</p>
<h4 id="who-owns-jsr"><a class="heading-id-link" href="#who-owns-jsr">6.6.1 Who owns JSR?</a></h4>
<p>Quoting the official documentation page <a href="https://jsr.io/docs/governance/overview">“Governance”</a>:</p>
<blockquote>
  <p>JSR is not owned by any one person or organization. It is a community-driven project that is open to all, built for the entire JavaScript ecosystem.</p>
  <p>JSR is currently operated by the Deno company. We are currently working on establishing a governance board to oversee the project, which will then work on moving the project to a foundation.</p>
</blockquote>
<h3 id="editing-typescript"><a class="heading-id-link" href="#editing-typescript">6.7 Editing TypeScript</a></h3>
<p>Two popular IDEs for JavaScript are:</p>
<ul>
  <li>
    <a href="https://code.visualstudio.com/"><em>Visual Studio Code</em></a> (free)
  </li>
  <li>
    <a href="https://www.jetbrains.com/webstorm/"><em>WebStorm</em></a> (free for non-commercial use)
  </li>
</ul>
<p>The observations in this section are about Visual Studio Code, but may apply to other IDEs, too.</p>
<p>With Visual Studio Code, we get two different ways of type checking:</p>
<ul>
  <li>
    <p>Any file that is currently open is automatically type-checked within Visual Studio Code. It order to provide that functionality, it comes with its own installation of TypeScript.</p>
  </li>
  <li>
    <p>If we want to type-check all of a code base, we must invoke the TypeScript compiler <code>tsc</code>. We can do that via Visual Studio Code’s <em>tasks</em> – a built-in way of invoking external tools (for type checking, compiling, bundling, etc.). The official documentation has <a href="https://code.visualstudio.com/Docs/editor/tasks">more information on tasks</a>.</p>
  </li>
</ul>
<h3 id="check-js"><a class="heading-id-link" href="#check-js">6.8 Type-checking JavaScript files</a></h3>
<p>Optionally, TypeScript can also type-check JavaScript files. Obviously that will only give us limited results. However, to help TypeScript, we can add type information via JSDoc comments – e.g.:</p>
<pre class="language-js">
<code><span class="hljs-comment">/**</span></code>
<code><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">x</span> - The first operand</span></code>
<code><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">y</span> - The second operand</span></code>
<code><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number</span>} The sum of both operands</span></code>
<code><span class="hljs-comment"> */</span></code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) {</code>
<code>  <span class="hljs-keyword">return</span> x + y;</code>
<code>}</code>
</pre>
<p>If we do that, we are still writing TypeScript, just with a different syntax.</p>
<p>Benefits of this approach:</p>
<ul>
  <li>
    No need for a build step to run the code – even on platforms (such as browsers) that don’t support TypeScript.
    <ul>
      <li>
        We can also generate <code>.d.ts</code> files from <code>.js</code> files with JSDoc comments. That is an extra build step, though. How to do that is explained in <a href="https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html">the TypeScript Handbook</a>.
      </li>
    </ul>
  </li>
  <li>
    It enables us to make a JavaScript code base more type-safe – in small incremental steps.
  </li>
</ul>
<p>Downside of this approach:</p>
<ul>
  <li>
    The syntax becomes less pleasant to use.
  </li>
</ul>
<p>To explain the downside – consider how we define an interface in TypeScript:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> {</code>
<code>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;</code>
<code>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;</code>
<code>  <span class="hljs-comment">/** optional property */</span></code>
<code>  z?: <span class="hljs-built_in">number</span>;</code>
<code>}</code>
</pre>
<p>Doing that via a JSDoc comment looks like this:</p>
<pre class="language-js">
<code><span class="hljs-comment">/**</span></code>
<code><span class="hljs-comment"> * <span class="hljs-doctag">@typedef</span> <span class="hljs-variable">Point</span></span></code>
<code><span class="hljs-comment"> * <span class="hljs-doctag">@prop</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">x</span></span></code>
<code><span class="hljs-comment"> * <span class="hljs-doctag">@prop</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">y</span></span></code>
<code><span class="hljs-comment"> * <span class="hljs-doctag">@prop</span> {<span class="hljs-type">number</span>} [z] optional property</span></code>
<code><span class="hljs-comment"> */</span></code>
</pre>
<p>More information in the TypeScript Handbook:</p>
<ul>
  <li>
    <a href="https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html">“Type Checking JavaScript Files”</a>
  </li>
  <li>
    <a href="https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html">“Creating <code>.d.ts</code> Files from <code>.js</code> files”</a>
  </li>
  <li>
    <a href="https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html">“JSDoc Reference”</a>
  </li>
</ul>

    
      
</body>
</html>