<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>19 Unions of object types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>19 Unions of object types</h1>
<blockquote>原文：<a href="https://exploringjs.com/ts/book/ch_unions-object-types.html">https://exploringjs.com/ts/book/ch_unions-object-types.html</a></blockquote>

    
        <div id="adbox">
      <div id="adbox-explain">(Ad, please don’t block.)</div>
              
          </div>
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#discriminated-unions">19.1 From unions of object types to discriminated unions</a>
      <ol>
        <li>
          <a href="#example-a-union-of-objects">19.1.1 Example: a union of objects</a>
        </li>
        <li>
          <a href="#fileentry-as-a-discriminated-union">19.1.2 <code>FileEntry</code> as a discriminated union</a>
        </li>
        <li>
          <a href="#discriminated-unions-are-related-to-algebraic-data-types">19.1.3 Discriminated unions are related to algebraic data types</a>
        </li>
        <li>
          <a href="#readfile-for-the-new-fileenty">19.1.4 <code>readFile()</code> for the new <code>FileEnty</code></a>
        </li>
        <li>
          <a href="#pros-and-cons-of-discriminated-unions">19.1.5 Pros and cons of discriminated unions</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#deriving-types-from-discriminated-unions">19.2 Deriving types from discriminated unions</a>
      <ol>
        <li>
          <a href="#extracting-discriminant-values">19.2.1 Extracting the values of the discriminant (the type tags)</a>
        </li>
        <li>
          <a href="#maps-for-the-elements-of-discriminated-unions">19.2.2 Maps for the elements of discriminated unions</a>
        </li>
        <li>
          <a href="#extracting-subtype-of-discriminated-union">19.2.3 Extracting a subtype of a discriminated union</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#class-hierarchies-vs-discriminated-unions">19.3 Class hierarchies vs. discriminated unions</a>
      <ol>
        <li>
          <a href="#a-class-hierarchy-for-syntax-trees">19.3.1 A class hierarchy for syntax trees</a>
        </li>
        <li>
          <a href="#a-discriminated-union-for-syntax-trees">19.3.2 A discriminated union for syntax trees</a>
        </li>
        <li>
          <a href="#comparing-classes-and-discriminated-unions">19.3.3 Comparing classes and discriminated unions</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#defining-discriminated-unions-via-classes">19.4 Defining discriminated unions via classes</a>
    </li>
  </ol>
</nav>
<p>In this chapter, we explore what unions of object types can be used for in TypeScript.</p>
<p>In this chapter, <em>object type</em> means:</p>
<ul>
  <li>
    Object literal type
  </li>
  <li>
    Interface type
  </li>
  <li>
    Mapped type (such as <code>Record</code>)
  </li>
</ul>
<h3 id="discriminated-unions"><a class="heading-id-link" href="#discriminated-unions">19.1 From unions of object types to discriminated unions</a></h3>
<p>Unions of object types are often a good choice if a single type has multiple representations – e.g. a type <code>Shape</code> that can be either a <code>Triangle</code>, a <code>Rectangle</code> or a <code>Circle</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Shape</span> = <span class="hljs-title class_">Triangle</span> | <span class="hljs-title class_">Rectangle</span> | <span class="hljs-title class_">Circle</span>;</code>
<code/>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Triangle</span> = {</code>
<code>  <span class="hljs-attr">corner1</span>: <span class="hljs-title class_">Point</span>,</code>
<code>  <span class="hljs-attr">corner2</span>: <span class="hljs-title class_">Point</span>,</code>
<code>  <span class="hljs-attr">corner3</span>: <span class="hljs-title class_">Point</span>,</code>
<code>};</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Rectangle</span> = {</code>
<code>  <span class="hljs-attr">corner1</span>: <span class="hljs-title class_">Point</span>,</code>
<code>  <span class="hljs-attr">corner2</span>: <span class="hljs-title class_">Point</span>,</code>
<code>};</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Circle</span> = {</code>
<code>  <span class="hljs-attr">center</span>: <span class="hljs-title class_">Point</span>,</code>
<code>  <span class="hljs-attr">radius</span>: <span class="hljs-built_in">number</span>,</code>
<code>};</code>
<code/>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = {</code>
<code>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>,</code>
<code>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>,</code>
<code>};</code>
</pre>
<h4 id="example-a-union-of-objects"><a class="heading-id-link" href="#example-a-union-of-objects">19.1.1 Example: a union of objects</a></h4>
<p>The following types define a simple virtual file system:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">VirtualFileSystem</span> = <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">FileEntry</span>&gt;;</code>
<code/>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">FileEntry</span> = <span class="hljs-title class_">FileEntryData</span> | <span class="hljs-title class_">FileEntryGenerator</span> | <span class="hljs-title class_">FileEntryFile</span>;</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">FileEntryData</span> = {</code>
<code>  <span class="hljs-attr">data</span>: <span class="hljs-built_in">string</span>,</code>
<code>};</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">FileEntryGenerator</span> = {</code>
<code>  <span class="hljs-attr">generator</span>: <span class="hljs-function">(<span class="hljs-params">path: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">string</span>,</code>
<code>};</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">FileEntryFile</span> = {</code>
<code>  <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span>,</code>
<code>};</code>
</pre>
<p>A function <code>readFile()</code> for <code>VirtualFileSystem</code> would work as follows (line A and line B):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">vfs</span>: <span class="hljs-title class_">VirtualFileSystem</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([</code>
<code>  [ <span class="hljs-string">'/tmp/file.txt'</span>,</code>
<code>    { <span class="hljs-attr">data</span>: <span class="hljs-string">'Hello!'</span> }</code>
<code>  ],</code>
<code>  [ <span class="hljs-string">'/tmp/echo.txt'</span>,</code>
<code>    { <span class="hljs-attr">generator</span>: <span class="hljs-function">(<span class="hljs-params">path: <span class="hljs-built_in">string</span></span>) =&gt;</span> path }</code>
<code>  ],</code>
<code>]);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">readFile</span>(vfs, <span class="hljs-string">'/tmp/file.txt'</span>), <span class="hljs-comment">// (A)</span></code>
<code>  <span class="hljs-string">'Hello!'</span></code>
<code>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">readFile</span>(vfs, <span class="hljs-string">'/tmp/echo.txt'</span>), <span class="hljs-comment">// (B)</span></code>
<code>  <span class="hljs-string">'/tmp/echo.txt'</span></code>
<code>);</code>
</pre>
<p>This is an implementation of <code>readFile()</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'node:fs'</span>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">readFile</span>(<span class="hljs-params">vfs: VirtualFileSystem, path: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span> {</code>
<code>  <span class="hljs-keyword">const</span> fileEntry = vfs.<span class="hljs-title function_">get</span>(path);</code>
<code>  <span class="hljs-keyword">if</span> (fileEntry === <span class="hljs-literal">undefined</span>) {</code>
<code>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Unknown path: '</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(path));</code>
<code>  }</code>
<code>  <span class="hljs-keyword">if</span> (<span class="hljs-string">'data'</span> <span class="hljs-keyword">in</span> fileEntry) { <span class="hljs-comment">// (A)</span></code>
<code>    <span class="hljs-keyword">return</span> fileEntry.<span class="hljs-property">data</span>;</code>
<code>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">'generator'</span> <span class="hljs-keyword">in</span> fileEntry) { <span class="hljs-comment">// (B)</span></code>
<code>    <span class="hljs-keyword">return</span> fileEntry.<span class="hljs-title function_">generator</span>(path);</code>
<code>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">'path'</span> <span class="hljs-keyword">in</span> fileEntry) { <span class="hljs-comment">// (C)</span></code>
<code>    <span class="hljs-keyword">return</span> fs.<span class="hljs-title function_">readFileSync</span>(fileEntry.<span class="hljs-property">path</span>, <span class="hljs-string">'utf-8'</span>);</code>
<code>  } <span class="hljs-keyword">else</span> {</code>
<code>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnexpectedValueError</span>(fileEntry); <span class="hljs-comment">// (D)</span></code>
<code>  }</code>
<code>}</code>
</pre>
<p>Initially, the type of <code>fileEntry</code> is <code>FileEntry</code> and therefore:</p>
<pre class="language-ts">
<code><span class="hljs-title class_">FileEntryData</span> | <span class="hljs-title class_">FileEntryGenerator</span> | <span class="hljs-title class_">FileEntryFile</span></code>
</pre>
<p>We have to narrow its type to one of the elements of this union type before we can access properties. And TypeScript lets us do that via the <code>in</code> operator (line A, line B, line C).</p>
<p>Additionally, we check statically if we covered all possible cases, by checking if <code>fileEntry</code> is assignable to the type <code>never</code> (line D). That is done via the following class:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnexpectedValueError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Error</span> {</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">_value: <span class="hljs-built_in">never</span></span>) {</code>
<code>    <span class="hljs-variable language_">super</span>();</code>
<code>  }</code>
<code>}</code>
</pre>
<p>For more information on this technique and a longer and better implementation of <code>UnexpectedValueError</code>, see <a href="ch_never.html#exhaustiveness-checks">“Use case for <code>never</code>: exhaustiveness checks at compile time” (§15.4)</a>.</p>
<h4 id="fileentry-as-a-discriminated-union"><a class="heading-id-link" href="#fileentry-as-a-discriminated-union">19.1.2 <code>FileEntry</code> as a discriminated union</a></h4>
<p>A <em>discriminated union</em> is a union of object types that all have one property in common – whose value indicates the type of a union element. Let’s convert <code>FileEntry</code> to a discriminated union:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">FileEntry</span> =</code>
<code>  | {</code>
<code>    <span class="hljs-attr">kind</span>: <span class="hljs-string">'FileEntryData'</span>,</code>
<code>    <span class="hljs-attr">data</span>: <span class="hljs-built_in">string</span>,</code>
<code>  }</code>
<code>  | {</code>
<code>    <span class="hljs-attr">kind</span>: <span class="hljs-string">'FileEntryGenerator'</span>,</code>
<code>    <span class="hljs-attr">generator</span>: <span class="hljs-function">(<span class="hljs-params">path: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">string</span>,</code>
<code>  }</code>
<code>  | {</code>
<code>    <span class="hljs-attr">kind</span>: <span class="hljs-string">'FileEntryFile'</span>,</code>
<code>    <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span>,</code>
<code>  }</code>
<code>  ;</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">VirtualFileSystem</span> = <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">FileEntry</span>&gt;;</code>
</pre>
<p>The property of a discriminated union that has the type information is called a <em>discriminant</em> or a <em>type tag</em>. The discriminant of <code>FileEntry</code> is <code>.kind</code>. Other common names are <code>.tag</code>, <code>.key</code> and <code>.type</code>.</p>
<p>On one hand, <code>FileEntry</code> is more verbose now. On the other hand, discriminants give us several benefits – as we’ll see soon.</p>
<h4 id="discriminated-unions-are-related-to-algebraic-data-types"><a class="heading-id-link" href="#discriminated-unions-are-related-to-algebraic-data-types">19.1.3 Discriminated unions are related to algebraic data types</a></h4>
<p>As an aside, <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions">discriminated unions</a> are related to <a href="https://wiki.haskell.org/Algebraic_data_type">algebraic data types</a> in functional programming languages. This is what <code>FileEntry</code> looks like as an algebraic data type in Haskell (if the TypeScript union elements had more properties, we’d probably use records in Haskell).</p>
<pre class="language-hs">
<code><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">FileEntry</span> = <span class="hljs-type">FileEntryData</span> <span class="hljs-type">String</span></span></code>
<code>  | <span class="hljs-type">FileEntryGenerator</span> (<span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span>)</code>
<code>  | <span class="hljs-type">FileEntryFile</span> <span class="hljs-type">String</span></code>
</pre>
<h4 id="readfile-for-the-new-fileenty"><a class="heading-id-link" href="#readfile-for-the-new-fileenty">19.1.4 <code>readFile()</code> for the new <code>FileEnty</code></a></h4>
<p>Let’s adapt <code>readFile()</code> to the new shape of <code>FileEnty</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">readFile</span>(<span class="hljs-params">vfs: VirtualFileSystem, path: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span> {</code>
<code>  <span class="hljs-keyword">const</span> fileEntry = vfs.<span class="hljs-title function_">get</span>(path);</code>
<code>  <span class="hljs-keyword">if</span> (fileEntry === <span class="hljs-literal">undefined</span>) {</code>
<code>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Unknown path: '</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(path));</code>
<code>  }</code>
<code>  <span class="hljs-keyword">switch</span> (fileEntry.<span class="hljs-property">kind</span>) {</code>
<code>    <span class="hljs-keyword">case</span> <span class="hljs-string">'FileEntryData'</span>:</code>
<code>      <span class="hljs-keyword">return</span> fileEntry.<span class="hljs-property">data</span>;</code>
<code>    <span class="hljs-keyword">case</span> <span class="hljs-string">'FileEntryGenerator'</span>:</code>
<code>      <span class="hljs-keyword">return</span> fileEntry.<span class="hljs-title function_">generator</span>(path);</code>
<code>    <span class="hljs-keyword">case</span> <span class="hljs-string">'FileEntryFile'</span>:</code>
<code>      <span class="hljs-keyword">return</span> fs.<span class="hljs-title function_">readFileSync</span>(fileEntry.<span class="hljs-property">path</span>, <span class="hljs-string">'utf-8'</span>);</code>
<code>    <span class="hljs-attr">default</span>:</code>
<code>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnexpectedValueError</span>(fileEntry);</code>
<code>  }</code>
<code>}</code>
</pre>
<p>This brings us to a first advantage of discriminated unions: We can use <code>switch</code> statements. And it’s immediately clear that <code>.kind</code> distinguishes the type union elements – we don’t have to look for property names that are unique to elements.</p>
<p>Note that narrowing works as it did before: Once we have checked <code>.kind</code>, we can access all relevant properties.</p>
<h4 id="pros-and-cons-of-discriminated-unions"><a class="heading-id-link" href="#pros-and-cons-of-discriminated-unions">19.1.5 Pros and cons of discriminated unions</a></h4>
<ul>
  <li>
    Con: Discriminating a union of object types makes it more verbose.
  </li>
  <li>
    Pro: We can handle cases via a <code>switch</code> statement.
  </li>
  <li>
    Pro: It’s immediately clear which property distinguishes the elements of the union.
  </li>
</ul>
<h5 id="pro-inline-union-type-elements-come-with-descriptions"><a class="heading-id-link" href="#pro-inline-union-type-elements-come-with-descriptions">19.1.5.1 Pro: Inline union type elements come with descriptions</a></h5>
<p>Another benefit is that, if the union elements are inlined (and not defined externally via types with names) then we can still see what each element does:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Shape</span> =</code>
<code>| {</code>
<code>  <span class="hljs-attr">tag</span>: <span class="hljs-string">'Triangle'</span>,</code>
<code>  <span class="hljs-attr">corner1</span>: <span class="hljs-title class_">Point</span>,</code>
<code>  <span class="hljs-attr">corner2</span>: <span class="hljs-title class_">Point</span>,</code>
<code>  <span class="hljs-attr">corner3</span>: <span class="hljs-title class_">Point</span>,</code>
<code>}</code>
<code>| {</code>
<code>  <span class="hljs-attr">tag</span>: <span class="hljs-string">'Rectangle'</span>,</code>
<code>  <span class="hljs-attr">corner1</span>: <span class="hljs-title class_">Point</span>,</code>
<code>  <span class="hljs-attr">corner2</span>: <span class="hljs-title class_">Point</span>,</code>
<code>}</code>
<code>| {</code>
<code>  <span class="hljs-attr">tag</span>: <span class="hljs-string">'Circle'</span>,</code>
<code>  <span class="hljs-attr">center</span>: <span class="hljs-title class_">Point</span>,</code>
<code>  <span class="hljs-attr">radius</span>: <span class="hljs-built_in">number</span>,</code>
<code>}</code>
<code>;</code>
</pre>
<h5 id="pro-union-elements-are-not-required-to-have-unique-properties"><a class="heading-id-link" href="#pro-union-elements-are-not-required-to-have-unique-properties">19.1.5.2 Pro: Union elements are not required to have unique properties</a></h5>
<p>Discriminated unions work even if all normal properties of union elements are the same:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Temperature</span> =</code>
<code>  | {</code>
<code>    <span class="hljs-attr">type</span>: <span class="hljs-string">'TemperatureCelsius'</span>,</code>
<code>    <span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>,</code>
<code>  }</code>
<code>  | {</code>
<code>    <span class="hljs-attr">type</span>: <span class="hljs-string">'TemperatureFahrenheit'</span>,</code>
<code>    <span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>,</code>
<code>  }</code>
<code>;</code>
</pre>
<h5 id="general-benefit-of-unions-of-object-types-descriptiveness"><a class="heading-id-link" href="#general-benefit-of-unions-of-object-types-descriptiveness">19.1.5.3 General benefit of unions of object types: descriptiveness</a></h5>
<p>The following type definition is terse; but can you tell how it works?</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">OutputPathDef</span> =</code>
<code>  | <span class="hljs-literal">null</span> <span class="hljs-comment">// same as input path</span></code>
<code>  | <span class="hljs-string">''</span> <span class="hljs-comment">// stem of output path</span></code>
<code>  | <span class="hljs-built_in">string</span> <span class="hljs-comment">// output path with different extension</span></code>
</pre>
<p>If we use a discriminated union, the code becomes much more self-descriptive:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">OutputPathDef</span> =</code>
<code>  | { <span class="hljs-attr">key</span>: <span class="hljs-string">'sameAsInputPath'</span> }</code>
<code>  | { <span class="hljs-attr">key</span>: <span class="hljs-string">'inputPathStem'</span> }</code>
<code>  | { <span class="hljs-attr">key</span>: <span class="hljs-string">'inputPathStemPlusExt'</span>, <span class="hljs-attr">ext</span>: <span class="hljs-built_in">string</span> }</code>
<code>  ;</code>
</pre>
<p>This is a function that uses <code>OutputPathDef</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'node:path'</span>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">deriveOutputPath</span>(<span class="hljs-params">def: OutputPathDef, inputPath: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span> {</code>
<code>  <span class="hljs-keyword">if</span> (def.<span class="hljs-property">key</span> === <span class="hljs-string">'sameAsInputPath'</span>) {</code>
<code>    <span class="hljs-keyword">return</span> inputPath;</code>
<code>  }</code>
<code>  <span class="hljs-keyword">const</span> parsed = path.<span class="hljs-title function_">parse</span>(inputPath);</code>
<code>  <span class="hljs-keyword">const</span> stem = path.<span class="hljs-title function_">join</span>(parsed.<span class="hljs-property">dir</span>, parsed.<span class="hljs-property">name</span>);</code>
<code>  <span class="hljs-keyword">switch</span> (def.<span class="hljs-property">key</span>) {</code>
<code>    <span class="hljs-keyword">case</span> <span class="hljs-string">'inputPathStem'</span>:</code>
<code>      <span class="hljs-keyword">return</span> stem;</code>
<code>    <span class="hljs-keyword">case</span> <span class="hljs-string">'inputPathStemPlusExt'</span>:</code>
<code>      <span class="hljs-keyword">return</span> stem + def.<span class="hljs-property">ext</span>;</code>
<code>  }</code>
<code>}</code>
<code><span class="hljs-keyword">const</span> zip = { <span class="hljs-attr">key</span>: <span class="hljs-string">'inputPathStemPlusExt'</span>, <span class="hljs-attr">ext</span>: <span class="hljs-string">'.zip'</span> } <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">deriveOutputPath</span>(zip, <span class="hljs-string">'/tmp/my-dir'</span>),</code>
<code>  <span class="hljs-string">'/tmp/my-dir.zip'</span></code>
<code>);</code>
</pre>
<h3 id="deriving-types-from-discriminated-unions"><a class="heading-id-link" href="#deriving-types-from-discriminated-unions">19.2 Deriving types from discriminated unions</a></h3>
<p>In this section, we explore how we can derive types from discriminated unions. As an example, we work with the following discriminated union:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Content</span> =</code>
<code>  | {</code>
<code>    <span class="hljs-attr">kind</span>: <span class="hljs-string">'text'</span>,</code>
<code>    <span class="hljs-attr">charCount</span>: <span class="hljs-built_in">number</span>,</code>
<code>  }</code>
<code>  | {</code>
<code>    <span class="hljs-attr">kind</span>: <span class="hljs-string">'image'</span>,</code>
<code>    <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>,</code>
<code>    <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>,</code>
<code>  }</code>
<code>  | {</code>
<code>    <span class="hljs-attr">kind</span>: <span class="hljs-string">'video'</span>,</code>
<code>    <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>,</code>
<code>    <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>,</code>
<code>    <span class="hljs-attr">runningTimeInSeconds</span>: <span class="hljs-built_in">number</span>,</code>
<code>  }</code>
<code>;</code>
</pre>
<h4 id="extracting-discriminant-values"><a class="heading-id-link" href="#extracting-discriminant-values">19.2.1 Extracting the values of the discriminant (the type tags)</a></h4>
<p>To extract the values of the discriminant, we can use <a href="ch_computing-with-types-overview.html#indexed-access-types">an indexed access type</a> (<code>T[K]</code>):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">GetKind</span>&lt;T <span class="hljs-keyword">extends</span> {<span class="hljs-attr">kind</span>: <span class="hljs-built_in">string</span>}&gt; =</code>
<code>  T[<span class="hljs-string">'kind'</span>];</code>
<code/>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ContentKind</span> = <span class="hljs-title class_">GetKind</span>&lt;<span class="hljs-title class_">Content</span>&gt;;</code>
<code/>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">ContentKind</span>,</code>
<code>  <span class="hljs-string">'text'</span> | <span class="hljs-string">'image'</span> | <span class="hljs-string">'video'</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>Because indexed access types are <a href="ch_computing-with-types-overview.html#distributivity-of-indexed-access-types">distributive</a> over unions, <code>T['kind']</code> is applied to each element of <code>Content</code> and the result is a union of string literal types.</p>
<h4 id="maps-for-the-elements-of-discriminated-unions"><a class="heading-id-link" href="#maps-for-the-elements-of-discriminated-unions">19.2.2 Maps for the elements of discriminated unions</a></h4>
<p>If we use the type <code>ContentKind</code> from the previous subsection, we can define an exhaustive map for the elements of <code>Content</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">DESCRIPTIONS_FULL</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-title class_">ContentKind</span>, <span class="hljs-built_in">string</span>&gt; = {</code>
<code>  <span class="hljs-attr">text</span>: <span class="hljs-string">'plain text'</span>,</code>
<code>  <span class="hljs-attr">image</span>: <span class="hljs-string">'an image'</span>,</code>
<code>  <span class="hljs-attr">video</span>: <span class="hljs-string">'a video'</span>,</code>
<code>} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code>
</pre>
<p>If the map should not be exhaustive, we can use the utility type <code>Partial</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">DESCRIPTIONS_PARTIAL</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">Record</span>&lt;<span class="hljs-title class_">ContentKind</span>, <span class="hljs-built_in">string</span>&gt;&gt; = {</code>
<code>  <span class="hljs-attr">text</span>: <span class="hljs-string">'plain text'</span>,</code>
<code>} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code>
</pre>
<h4 id="extracting-subtype-of-discriminated-union"><a class="heading-id-link" href="#extracting-subtype-of-discriminated-union">19.2.3 Extracting a subtype of a discriminated union</a></h4>
<p>Sometimes, we don’t need all of a discriminated union. We can write out own utility type for extracting a subtype of <code>Content</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ExtractSubtype</span>&lt;</code>
<code>  <span class="hljs-title class_">Union</span> <span class="hljs-keyword">extends</span> {<span class="hljs-attr">kind</span>: <span class="hljs-built_in">string</span>},</code>
<code>  <span class="hljs-title class_">SubKinds</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GetKind</span>&lt;<span class="hljs-title class_">Union</span>&gt; <span class="hljs-comment">// (A)</span></code>
<code>&gt; =</code>
<code>  <span class="hljs-title class_">Union</span> <span class="hljs-keyword">extends</span> {<span class="hljs-attr">kind</span>: <span class="hljs-title class_">SubKinds</span>} ? <span class="hljs-title class_">Union</span> : <span class="hljs-built_in">never</span> <span class="hljs-comment">// (B)</span></code>
<code>;</code>
</pre>
<p>We use <a href="ch_conditional-types.html#ch_conditional-types">a conditional type</a> to loop over the union type <code>U</code>:</p>
<ul>
  <li>
    Line B: If property <code>.kind</code> of a union element has a type that is assignable to <code>SubKinds</code> then we keep the element. If not then we omit it (by returning <code>never</code>).
  </li>
  <li>
    The <code>extends</code> in line A ensures that we don’t make a typo when we extract: Our discriminant values <code>SubKinds</code> must be a subset of <code>GetKind&lt;Union&gt;</code> (see earlier subsection).
  </li>
</ul>
<p>Let’s use <code>ExtractSubtype</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">ExtractSubtype</span>&lt;<span class="hljs-title class_">Content</span>, <span class="hljs-string">'text'</span> | <span class="hljs-string">'image'</span>&gt;,</code>
<code>  | {</code>
<code>    <span class="hljs-attr">kind</span>: <span class="hljs-string">'text'</span>,</code>
<code>    <span class="hljs-attr">charCount</span>: <span class="hljs-built_in">number</span>,</code>
<code>  }</code>
<code>  | {</code>
<code>    <span class="hljs-attr">kind</span>: <span class="hljs-string">'image'</span>,</code>
<code>    <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>,</code>
<code>    <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>,</code>
<code>  }</code>
<code>&gt;&gt;;</code>
</pre>
<p>As an alternative to our own <code>ExtractSubtype</code>, we can also use the built-in utility type <code>Extract</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Extract</span>&lt;<span class="hljs-title class_">Content</span>, {<span class="hljs-attr">kind</span>: <span class="hljs-string">'text'</span> | <span class="hljs-string">'image'</span>}&gt;,</code>
<code>  | {</code>
<code>    <span class="hljs-attr">kind</span>: <span class="hljs-string">'text'</span>,</code>
<code>    <span class="hljs-attr">charCount</span>: <span class="hljs-built_in">number</span>,</code>
<code>  }</code>
<code>  | {</code>
<code>    <span class="hljs-attr">kind</span>: <span class="hljs-string">'image'</span>,</code>
<code>    <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>,</code>
<code>    <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>,</code>
<code>  }</code>
<code>&gt;&gt;;</code>
</pre>
<p><code>Extract</code> returns all elements of the union <code>Content</code> that are assignable to the following type:</p>
<pre class="language-ts">
<code>{<span class="hljs-attr">kind</span>: <span class="hljs-string">'text'</span> | <span class="hljs-string">'image'</span>}</code>
</pre>
<h3 id="class-hierarchies-vs-discriminated-unions"><a class="heading-id-link" href="#class-hierarchies-vs-discriminated-unions">19.3 Class hierarchies vs. discriminated unions</a></h3>
<p>To compare class hierarchies with discriminated unions, we use both to define syntax trees for representing expressions such as:</p>
<pre>
<code>1 + 2 + 3</code>
</pre>
<p>A syntax tree is either:</p>
<ul>
  <li>
    A number value
  </li>
  <li>
    The addition of two syntax trees
  </li>
</ul>
<h4 id="a-class-hierarchy-for-syntax-trees"><a class="heading-id-link" href="#a-class-hierarchy-for-syntax-trees">19.3.1 A class hierarchy for syntax trees</a></h4>
<p>The following code uses an abstract class and two subclasses to represent syntax trees:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SyntaxTree</span> {</code>
<code>  <span class="hljs-keyword">abstract</span> evaluate(): <span class="hljs-built_in">number</span>;</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberValue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">SyntaxTree</span> {</code>
<code>  <span class="hljs-attr">numberValue</span>: <span class="hljs-built_in">number</span>;</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">numberValue: <span class="hljs-built_in">number</span></span>) {</code>
<code>    <span class="hljs-variable language_">super</span>();</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">numberValue</span> = numberValue;</code>
<code>  }</code>
<code>  evaluate(): <span class="hljs-built_in">number</span> {</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">numberValue</span>;</code>
<code>  }</code>
<code>}</code>
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Addition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">SyntaxTree</span> {</code>
<code>  <span class="hljs-attr">operand1</span>: <span class="hljs-title class_">SyntaxTree</span>;</code>
<code>  <span class="hljs-attr">operand2</span>: <span class="hljs-title class_">SyntaxTree</span>;</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">operand1: SyntaxTree, operand2: SyntaxTree</span>) {</code>
<code>    <span class="hljs-variable language_">super</span>();</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">operand1</span> = operand1;</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">operand2</span> = operand2;</code>
<code>  }</code>
<code>  evaluate(): <span class="hljs-built_in">number</span> {</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">operand1</span>.evaluate() + <span class="hljs-variable language_">this</span>.<span class="hljs-property">operand2</span>.evaluate();</code>
<code>  }</code>
<code>}</code>
</pre>
<p>The operation <code>evaluate</code> handles the two cases “number value” and “addition” in the corresponding classes – via polymorphism. Here it is in action:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> syntaxTree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Addition</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberValue</span>(<span class="hljs-number">1</span>),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Addition</span>(</code>
<code>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberValue</span>(<span class="hljs-number">2</span>),</code>
<code>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberValue</span>(<span class="hljs-number">3</span>),</code>
<code>  ),</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  syntaxTree.evaluate(), <span class="hljs-number">6</span></code>
<code>);</code>
</pre>
<h4 id="a-discriminated-union-for-syntax-trees"><a class="heading-id-link" href="#a-discriminated-union-for-syntax-trees">19.3.2 A discriminated union for syntax trees</a></h4>
<p>The following code uses a discriminated union with two elements to represent syntax trees:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">SyntaxTree</span> =</code>
<code>  | {</code>
<code>    <span class="hljs-attr">kind</span>: <span class="hljs-string">'NumberValue'</span>;</code>
<code>    <span class="hljs-attr">numberValue</span>: <span class="hljs-built_in">number</span>;</code>
<code>  }</code>
<code>  | {</code>
<code>    <span class="hljs-attr">kind</span>: <span class="hljs-string">'Addition'</span>;</code>
<code>    <span class="hljs-attr">operand1</span>: <span class="hljs-title class_">SyntaxTree</span>;</code>
<code>    <span class="hljs-attr">operand2</span>: <span class="hljs-title class_">SyntaxTree</span>;  </code>
<code>  }</code>
<code>;</code>
<code/>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">evaluate</span>(<span class="hljs-params">syntaxTree: SyntaxTree</span>): <span class="hljs-built_in">number</span> {</code>
<code>  <span class="hljs-keyword">switch</span>(syntaxTree.<span class="hljs-property">kind</span>) {</code>
<code>    <span class="hljs-keyword">case</span> <span class="hljs-string">'NumberValue'</span>:</code>
<code>      <span class="hljs-keyword">return</span> syntaxTree.<span class="hljs-property">numberValue</span>;</code>
<code>    <span class="hljs-keyword">case</span> <span class="hljs-string">'Addition'</span>:</code>
<code>      <span class="hljs-keyword">return</span> (</code>
<code>        evaluate(syntaxTree.<span class="hljs-property">operand1</span>) +</code>
<code>        evaluate(syntaxTree.<span class="hljs-property">operand2</span>)</code>
<code>      );</code>
<code>    <span class="hljs-attr">default</span>:</code>
<code>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnexpectedValueError</span>(syntaxTree);</code>
<code>  }</code>
<code>}</code>
</pre>
<p>The operation <code>evaluate</code> handles the two cases “number value” and “addition” in a single location, via <code>switch</code>. Here it is in action:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">syntaxTree</span>: <span class="hljs-title class_">SyntaxTree</span> = {</code>
<code>  <span class="hljs-attr">kind</span>: <span class="hljs-string">'Addition'</span>,</code>
<code>  <span class="hljs-attr">operand1</span>: {</code>
<code>    <span class="hljs-attr">kind</span>: <span class="hljs-string">'NumberValue'</span>,</code>
<code>    <span class="hljs-attr">numberValue</span>: <span class="hljs-number">1</span>,</code>
<code>  },</code>
<code>  <span class="hljs-attr">operand2</span>: {</code>
<code>    <span class="hljs-attr">kind</span>: <span class="hljs-string">'Addition'</span>,</code>
<code>    <span class="hljs-attr">operand1</span>: {</code>
<code>      <span class="hljs-attr">kind</span>: <span class="hljs-string">'NumberValue'</span>,</code>
<code>      <span class="hljs-attr">numberValue</span>: <span class="hljs-number">2</span>,</code>
<code>    },</code>
<code>    <span class="hljs-attr">operand2</span>: {</code>
<code>      <span class="hljs-attr">kind</span>: <span class="hljs-string">'NumberValue'</span>,</code>
<code>      <span class="hljs-attr">numberValue</span>: <span class="hljs-number">3</span>,</code>
<code>    },</code>
<code>  }</code>
<code>};</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  evaluate(syntaxTree), <span class="hljs-number">6</span></code>
<code>);</code>
</pre>
<p>We don’t need the type annotation in line A, but it helps ensure that the data has the correct structure. If we don’t do it here, we’ll find out about problems later.</p>
<h4 id="comparing-classes-and-discriminated-unions"><a class="heading-id-link" href="#comparing-classes-and-discriminated-unions">19.3.3 Comparing classes and discriminated unions</a></h4>
<p>With classes, we check the types of instances via <code>instanceof</code>. With discriminated unions, we use discriminants to do so. In a way, they are runtime type information.</p>
<p>Each approach does one kind of extensibility well:</p>
<ul>
  <li>
    <p>With classes, we have to modify each class if we want to add a new operation. However, adding a new type does not require any changes to existing code.</p>
  </li>
  <li>
    <p>With discriminated unions, we have to modify each function if we want to add a new type. In contrast, adding new operations is simple.</p>
  </li>
</ul>
<h3 id="defining-discriminated-unions-via-classes"><a class="heading-id-link" href="#defining-discriminated-unions-via-classes">19.4 Defining discriminated unions via classes</a></h3>
<p>It’s also possible to define a discriminated union via classes – e.g.:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Black</span> | <span class="hljs-title class_">White</span>;</code>
<code/>
<code><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractColor</span> {}</code>
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Black</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">AbstractColor</span> {</code>
<code>  <span class="hljs-keyword">readonly</span> kind = <span class="hljs-string">'Black'</span>;</code>
<code>}</code>
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">White</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">AbstractColor</span> {</code>
<code>  <span class="hljs-keyword">readonly</span> kind = <span class="hljs-string">'White'</span>;</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">colorToRgb</span>(<span class="hljs-params">color: Color</span>): <span class="hljs-built_in">string</span> {</code>
<code>  <span class="hljs-keyword">switch</span> (color.<span class="hljs-property">kind</span>) {</code>
<code>    <span class="hljs-keyword">case</span> <span class="hljs-string">'Black'</span>:</code>
<code>      <span class="hljs-keyword">return</span> <span class="hljs-string">'#000000'</span>;</code>
<code>    <span class="hljs-keyword">case</span> <span class="hljs-string">'White'</span>:</code>
<code>      <span class="hljs-keyword">return</span> <span class="hljs-string">'#FFFFFF'</span>;</code>
<code>  }</code>
<code>}</code>
</pre>
<p>Why would we want to do that? We can define and inherit methods for the elements of the union.</p>
<p>The abstract class <code>AbstractColor</code> is only needed if we want to share methods between the union classes.</p>

    
      
</body>
</html>