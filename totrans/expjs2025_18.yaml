- en: 15 Operators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15 运算符
- en: 原文：[https://exploringjs.com/js/book/ch_operators.html](https://exploringjs.com/js/book/ch_operators.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/js/book/ch_operators.html](https://exploringjs.com/js/book/ch_operators.html)
- en: '[15.1 Making sense of operators](#making-sense-of-operators)'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[15.1 理解运算符](#making-sense-of-operators)'
- en: '[15.1.1 Operators coerce their operands to appropriate types](#operators-coerce-their-operands-to-appropriate-types)'
  id: totrans-3
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[15.1.1 运算符将它们的操作数转换为适当的类型](#operators-coerce-their-operands-to-appropriate-types)'
- en: '[15.1.2 Most operators only work with primitive values](#most-operators-only-work-with-primitive-values)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[15.1.2 大多数运算符仅与原始值一起工作](#most-operators-only-work-with-primitive-values)'
- en: '[15.2 Converting values to primitives (advanced)](#ToPrimitive)'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[15.2 将值转换为原始值（高级）](#ToPrimitive)'
- en: '[15.3 The plus operator (`+`)](#plus-operator)'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[15.3 加号运算符（`+`）](#plus-operator)'
- en: '[15.4 Assignment operators](#assignment-operators)'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[15.4 赋值运算符](#assignment-operators)'
- en: '[15.4.1 The plain assignment operator](#the-plain-assignment-operator)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[15.4.1 普通赋值运算符](#the-plain-assignment-operator)'
- en: '[15.4.2 Compound assignment operators](#compound-assignment-operators)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[15.4.2 复合赋值运算符](#compound-assignment-operators)'
- en: '[15.5 Equality: `==` vs. `===` vs. `Object.is()`](#equality--vs--vs-objectis)'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[15.5 相等：`==` 与 `===` 与 `Object.is()`](#equality--vs--vs-objectis)'
- en: '[15.5.1 Strict equality (`===` and `!==`)](#strict-equality)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[15.5.1 严格相等（`===` 和 `!==`）](#strict-equality)'
- en: '[15.5.2 Loose equality (`==` and `!=`)](#loose-equality)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[15.5.2 宽松相等（`==` 和 `!=`）](#loose-equality)'
- en: '[15.5.3 Recommendation: always use strict equality](#recommendation-always-strict-equality)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[15.5.3 建议：始终使用严格相等](#recommendation-always-strict-equality)'
- en: '[15.5.4 Even stricter than `===`: `Object.is()` (advanced)](#Object.is)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[15.5.4 比 `===` 更严格：`Object.is()`（高级）](#Object.is)'
- en: '[15.6 Ordering operators](#ordering-operators)'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[15.6 排序运算符](#ordering-operators)'
- en: '[15.7 Various other operators](#various-other-operators)'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[15.7 其他各种运算符](#various-other-operators)'
- en: '[15.7.1 Comma operator](#comma-operator)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[15.7.1 逗号运算符](#comma-operator)'
- en: '[15.7.2 `void` operator](#void-operator)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[15.7.2 `void` 运算符](#void-operator)'
- en: '[15.1 Making sense of operators](#making-sense-of-operators)'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[15.1 理解运算符](#making-sense-of-operators)'
- en: 'JavaScript’s operators sometimes produce unintuitive results. With the following
    two rules, they are easier to understand:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的运算符有时会产生不直观的结果。以下两个规则使它们更容易理解：
- en: Operators coerce their operands to appropriate types.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符会将它们的操作数强制转换为适当的类型。
- en: Most operators only work with primitive values.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数运算符仅与原始值一起工作。
- en: '[15.1.1 Operators coerce their operands to appropriate types](#operators-coerce-their-operands-to-appropriate-types)'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[15.1.1 运算符将它们的操作数转换为适当的类型](#operators-coerce-their-operands-to-appropriate-types)'
- en: If an operator gets operands that don’t have the proper types, it rarely throws
    an exception. Instead, it *coerces* (automatically converts) the operands so that
    it can work with them. Let’s look at two examples.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运算符接收到不正确的类型的操作数，它很少抛出异常。相反，它会*强制转换*（自动转换）操作数，以便可以与它们一起工作。让我们看看两个例子。
- en: First, the multiplication operator can only work with numbers. Therefore, it
    converts strings to numbers before computing its result.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，乘法运算符只能与数字一起工作。因此，在计算结果之前，它会将字符串转换为数字。
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Second, the square brackets operator (`[ ]`) for accessing the properties of
    an object can only handle strings and symbols. All other values are coerced to
    string:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，用于访问对象属性的方括号运算符（`[ ]`）只能处理字符串和符号。所有其他值都会被强制转换为字符串：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[15.1.2 Most operators only work with primitive values](#most-operators-only-work-with-primitive-values)'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[15.1.2 大多数运算符仅与原始值一起工作](#most-operators-only-work-with-primitive-values)'
- en: 'As mentioned before, most operators only work with primitive values. If an
    operand is an object, it is usually coerced to a primitive value – for example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，大多数运算符仅与原始值一起工作。如果一个操作数是对象，它通常会被强制转换为原始值——例如：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Why? The plus operator first coerces its operands to primitive values:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？加号运算符首先将它的操作数强制转换为原始值：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, it concatenates the two strings:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它连接这两个字符串：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[15.2 Converting values to primitives (advanced)](#ToPrimitive)'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[15.2 将值转换为原始值（高级）](#ToPrimitive)'
- en: 'The following JavaScript code explains how arbitrary values are converted to
    primitive values:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下JavaScript代码解释了任意值是如何转换为原始值的：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Only the following objects define a method with the key `Symbol.toPrimitive`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 只有以下对象定义了具有键 `Symbol.toPrimitive` 的方法：
- en: '`Symbol.prototype[Symbol.toPrimitive]`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.prototype[Symbol.toPrimitive]`'
- en: '`Date.prototype[Symbol.toPrimitive]`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype[Symbol.toPrimitive]`'
- en: 'Therefore, let’s focus on `OrdinaryToPrimitive()`: If we prefer strings, `.toString()`
    is called first. If we prefer numbers, `.valueOf()` is called first. We can see
    that in the following code.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们关注 `OrdinaryToPrimitive()`：如果我们更喜欢字符串，则首先调用 `.toString()`。如果我们更喜欢数字，则首先调用
    `.valueOf()`。我们可以在以下代码中看到这一点。
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[15.3 The plus operator (`+`)](#plus-operator)'
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[15.3 加号运算符 (`+`)](#plus-operator)'
- en: 'The plus operator works as follows in JavaScript:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 加号运算符在 JavaScript 中的工作方式如下：
- en: 'First, it converts both operands to primitive values (by default, conversion
    to primitive prefers numbers). Then it switches to one of two modes:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它将两个操作数都转换为原始值（默认情况下，转换为原始值优先于数字）。然后它切换到两种模式之一：
- en: 'String mode: If one of the two primitive values is a string, then it converts
    the other one to a string, concatenates both strings, and returns the result.'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串模式：如果两个原始值中有一个是字符串，则将另一个转换为字符串，将两个字符串连接起来，并返回结果。
- en: 'Number mode: Otherwise, It converts both operands to numbers, adds them, and
    returns the result.'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字模式：否则，它将两个操作数都转换为数字，将它们相加，并返回结果。
- en: 'String mode lets us use `+` to assemble strings:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串模式允许我们使用 `+` 来拼接字符串：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Number mode means that if neither operand is a string (or an object that becomes
    a string) then everything is coerced to numbers:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 数字模式意味着如果两个操作数都不是字符串（或变成字符串的对象）则将所有内容强制转换为数字：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`Number(true)` is `1`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number(true)` 是 `1`。'
- en: '[15.4 Assignment operators](#assignment-operators)'
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[15.4 赋值运算符](#assignment-operators)'
- en: '[15.4.1 The plain assignment operator](#the-plain-assignment-operator)'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[15.4.1 简单赋值运算符](#the-plain-assignment-operator)'
- en: 'The plain assignment operator is used to change storage locations:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 简单赋值运算符用于更改存储位置：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Initializers in variable declarations can also be viewed as a form of assignment:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 变量声明中的初始化器也可以视为一种赋值形式：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[15.4.2 Compound assignment operators](#compound-assignment-operators)'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[15.4.2 复合赋值运算符](#compound-assignment-operators)'
- en: 'JavaScript supports the following assignment operators:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 支持以下赋值运算符：
- en: 'Arithmetic assignment operators: `+= -= *= /= %=` ^(ES1)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术赋值运算符：`+= -= *= /= %=` (ES1)
- en: '`+=` can also be used for string concatenation'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+=` 也可以用于字符串连接'
- en: 'Introduced later: `**=` ^(ES2016)'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后续引入：`**=` (ES2016)
- en: 'Bitwise assignment operators: `&= ^= |=` ^(ES1)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位运算赋值运算符：`&= ^= |=` (ES1)
- en: 'Bitwise shift assignment operators: `<<= >>= >>>=` ^(ES1)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位运算移位赋值运算符：`<<= >>= >>>=` (ES1)
- en: 'Logical assignment operators: `||= &&= ??=` ^(ES2021)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑赋值运算符：`||= &&= ??=` (ES2021)
- en: '[15.4.2.1 Logical assignment operators ^(ES2021)](#logical-assignment-operators)'
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[15.4.2.1 逻辑赋值运算符 (ES2021)](#logical-assignment-operators)'
- en: 'Logical assignment operators work differently from other compound assignment
    operators:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑赋值运算符与其他复合赋值运算符的工作方式不同：
- en: '| Assignment operator | Equivalent to | Only assigns if `a` is |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 赋值运算符 | 等价于 | 只有当 `a` 是 |'
- en: '| --- | --- | --- |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `a &#124;&#124;= b` | `a &#124;&#124; (a = b)` | Falsy |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `a ??= b` | `a ?? (a = b)` | Falsy |'
- en: '| `a &&= b` | `a && (a = b)` | Truthy |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `a &&= b` | `a && (a = b)` | Truthy |'
- en: '| `a ??= b` | `a ?? (a = b)` | Nullish |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `a ??= b` | `a ?? (a = b)` | Nullish |'
- en: Why is `a ||= b` equivalent to the following expression?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 `a ||= b` 等价于以下表达式？
- en: '`a || (a = b)`'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a || (a = b)`'
- en: Why not to this expression?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不使用这个表达式？
- en: '`a = a || b`'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a = a || b`'
- en: 'The former expression has the benefit of [short-circuiting](ch_booleans.html#short-circuiting):
    The assignment is only evaluated if `a` evaluates to `false`. Therefore, the assignment
    is only performed if it’s necessary. In contrast, the latter expression always
    performs an assignment.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个表达式的好处是 [短路](ch_booleans.html#short-circuiting)：只有当 `a` 评估为 `false` 时才进行赋值。因此，只有当必要时才执行赋值。相比之下，后一个表达式总是执行赋值。
- en: For more on `??=`, see [“The nullish coalescing assignment operator (`??=`)
    ^(ES2021)” (§16.4.4)](ch_undefined-null.html#nullish-coalescing-assignment-operator).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 `??=` 的信息，请参阅 [“nullish 合并赋值运算符 (`??=`) (§16.4.4)” (ch_undefined-null.html#nullish-coalescing-assignment-operator)]。
- en: '[15.4.2.2 The remaining compound assignment operators](#the-remaining-compound-assignment-operators)'
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[15.4.2.2 剩余的复合赋值运算符](#the-remaining-compound-assignment-operators)'
- en: 'For operators `op` other than `|| && ??`, the following two ways of assigning
    are equivalent:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `op` 除了 `|| && ??` 的运算符，以下两种赋值方式是等价的：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If, for example, `op` is `+`, then we get the operator `+=` that works as follows.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果 `op` 是 `+`，则我们得到以下工作方式的运算符 `+=`。
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[15.5 Equality: `==` vs. `===` vs. `Object.is()`](#equality--vs--vs-objectis)'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[15.5 相等：`==` vs. `===` vs. `Object.is()`](#equality--vs--vs-objectis)'
- en: 'JavaScript has two kinds of equality operators:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 有两种类型的相等运算符：
- en: (`==`) loose equality (“double equals”)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (`==`) 松散相等（“双等号”）
- en: (`===`) strict equality (“triple equals”)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （`===`）严格相等（“三等号”）
- en: '![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Recommendation:
    always use strict equality (`===`)**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“提示”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **建议：始终使用严格相等（`===`**）'
- en: Loose equality has many quirks and is difficult to understand. My recommendation
    is to always use strict equality. I’ll explain how loose equality works but it’s
    not something worth remembering.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 松散相等有很多怪癖，难以理解。我的建议是始终使用严格相等。我将解释松散相等是如何工作的，但这不是值得记住的事情。
- en: '[15.5.1 Strict equality (`===` and `!==`)](#strict-equality)'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[15.5.1 严格相等（`===` 和 `!==`）](#strict-equality)'
- en: Two values are only strictly equal if they have the same type. Strict equality
    never coerces.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当两个值具有相同的类型时，它们才严格相等。严格相等从不进行转换。
- en: 'Primitive values (including strings and excluding symbols) are compared by
    value:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 原始值（包括字符串，但不包括符号）通过值进行比较：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'All other values must have the same identity:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他值都必须具有相同的标识符：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Symbols are compared similarly to objects:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 符号的比较方式类似于对象：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `number` error value `NaN` is famously not strictly equal to itself (because,
    internally, it’s not a single value):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`number` 错误值 `NaN` 著名地不严格等于自身（因为，在内部，它不是一个单一值）：'
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[15.5.2 Loose equality (`==` and `!=`)](#loose-equality)'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[15.5.2 松散相等（`==` 和 `!=`）](#loose-equality)'
- en: Loose equality is one of JavaScript’s quirks. Let’s explore its behavior.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 松散相等是 JavaScript 的怪癖之一。让我们探索其行为。
- en: '[15.5.2.1 If both operands have the same type](#if-both-operands-have-the-same-type)'
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[15.5.2.1 如果两个操作数具有相同的类型](#if-both-operands-have-the-same-type)'
- en: 'If both operands have the same primitive type, loose equality behaves like
    strict equality:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个操作数具有相同的原始类型，松散相等的行为类似于严格相等：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If both operands are objects, the same rule applies: Loose equality behaves
    like strict equality and they are only equal if they have the same identity.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个操作数都是对象，则适用相同的规则：松散相等的行为类似于严格相等，并且它们只有在具有相同的标识符时才相等。
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Comparing symbols works similarly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 符号的比较方式类似。
- en: '[15.5.2.2 Coercion](#coercion-1)'
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[15.5.2.2 转换](#coercion-1)'
- en: 'If the operands have different types, loose equality often coerces. Some of
    those type coercions make sense:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作数具有不同的类型，松散相等通常会进行转换。其中一些类型转换是有意义的：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Others less so:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 其他情况较少：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'An object is coerced to a primitive value (only) if the other operand is primitive:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果另一个操作数是原始值，则对象会被转换为原始值（仅限）：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[15.5.2.3 `==` vs. `Boolean()`](#-vs-boolean)'
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[15.5.2.3 `==` 与 `Boolean()`](#-vs-boolean)'
- en: 'Comparison with booleans is different from converting to boolean via `Boolean()`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与布尔值的比较与通过 `Boolean()` 转换为布尔值不同：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[15.5.2.4 `undefined == null`](#undefined--null)'
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[15.5.2.4 `undefined == null`](#undefined--null)'
- en: '`==` considers `undefined` and `null` to be equal:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`==` 将 `undefined` 和 `null` 视为相等：'
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[15.5.2.5 How exactly does loose equality work? (advanced)](#how-exactly-does-loose-equality-work-advanced)'
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[15.5.2.5 松散相等是如何工作的？（高级）](#how-exactly-does-loose-equality-work-advanced)'
- en: 'In the ECMAScript specification, loose equality is defined via [the following
    operation](https://tc39.es/ecma262/#sec-islooselyequal):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ECMAScript 规范中，松散相等是通过以下操作定义的：[以下操作](https://tc39.es/ecma262/#sec-islooselyequal)。
- en: '`IsLooselyEqual(x: any, y: any): boolean`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsLooselyEqual(x: any, y: any): boolean`'
- en: If both operands have the same type, return the result of [`IsStrictlyEqual(x,
    y)`](https://tc39.es/ecma262/#sec-isstrictlyequal) (not explained here).
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个操作数具有相同的类型，则返回 `IsStrictlyEqual(x, y)` 的结果（此处未解释）。
- en: If one operand is `null` and the other one is `undefined`, return `true`.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个操作数是 `null` 而另一个是 `undefined`，则返回 `true`。
- en: If one operand is a number and the other one a string, convert the string to
    a number and return the result of applying `IsLooselyEqual()`.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个操作数是数字而另一个是字符串，则将字符串转换为数字，并返回应用 `IsLooselyEqual()` 的结果。
- en: If one operand is a bigint and the other one a string, convert the string to
    a bigint and return the result of applying `IsLooselyEqual()`.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个操作数是 `bigint` 而另一个是字符串，则将字符串转换为 `bigint` 并返回应用 `IsLooselyEqual()` 的结果。
- en: If one operand is a boolean, convert it to a number and return the result of
    applying `IsLooselyEqual()`.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个操作数是布尔值，则将其转换为数字，并返回应用 `IsLooselyEqual()` 的结果。
- en: If one operand is an object and the other is a string, a number, a bigint or
    a symbol, then convert the object to a primitive via [`ToPrimitive()`](#ToPrimitive)
    and return the result of applying `IsLooselyEqual()`.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个操作数是对象而另一个是字符串、数字、`bigint` 或符号，则通过 `ToPrimitive()` 将对象转换为原始值，并返回应用 `IsLooselyEqual()`
    的结果。
- en: 'If one operand is a bigint and the other operand is a number:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个操作数是 `bigint` 而另一个操作数是数字：
- en: If either operand is not finite, return `false`.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任一操作数不是有限的，则返回 `false`。
- en: If both operands represent the same mathematical value, return `true`; otherwise
    return `false`.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个操作数表示相同的数学值，则返回 `true`；否则返回 `false`。
- en: Return `false`.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回 `false`。
- en: As you can see, this algorithm is not exactly intuitive. Hence the following
    recommendation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个算法并不完全直观。因此有以下建议。
- en: '[15.5.3 Recommendation: always use strict equality](#recommendation-always-strict-equality)'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[15.5.3 建议：始终使用严格相等](#recommendation-always-strict-equality)'
- en: I recommend to always use `===`. It makes our code easier to understand and
    spares us from having to think about the quirks of `==`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议始终使用 `===`。这使得我们的代码更容易理解，并使我们免于思考 `==` 的怪癖。
- en: Let’s look at two use cases for `==` and what I recommend to do instead.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `==` 的两个用例以及我建议的替代方案。
- en: '[15.5.3.1 Use case for `==`: comparing with a number or a string](#use-case-for--comparing-with-a-number-or-a-string)'
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[15.5.3.1 `==` 的用例：与数字或字符串比较](#use-case-for--comparing-with-a-number-or-a-string)'
- en: '`==` lets us check if a value `x` is a number or that number as a string –
    with a single comparison:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`==` 允许我们检查值 `x` 是否为数字或该数字的字符串表示——只需一次比较：'
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'I prefer either of the following two alternatives:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢以下两种替代方案之一：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can also convert `x` to a number when we first encounter it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在我们第一次遇到 `x` 时将其转换为数字。
- en: '[15.5.3.2 Use case for `==`: comparing with `undefined` or `null`](#use-case-for--comparing-with-undefined-or-null)'
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[15.5.3.2 `==` 的用例：与 `undefined` 或 `null` 比较](#use-case-for--comparing-with-undefined-or-null)'
- en: 'Another use case for `==` is to check if a value `x` is either `undefined`
    or `null`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`==` 的另一个用例是检查值 `x` 是否为 `undefined` 或 `null`：'
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The problem with this code is that we can’t be sure if someone meant to write
    it that way or if they made a typo and meant `=== null`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的问题是我们无法确定某人是否有意这样编写，还是他们打字错误，本意是 `=== null`。
- en: 'I prefer this alternative:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢这个替代方案：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[15.5.4 Even stricter than `===`: `Object.is()` (advanced)](#Object.is)'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[15.5.4 比严格等于 `===` 更严格：`Object.is()`（高级）](#Object.is)'
- en: 'Method `Object.is()` compares two values:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `Object.is()` 比较两个值：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`Object.is()` is even stricter than `===` – e.g.:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.is()` 比严格等于 `===` 更严格——例如：'
- en: 'It considers `NaN`, [the error value for computations involving numbers](ch_numbers.html#NaN),
    to be equal to itself:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将 [涉及数字的计算的错误值](ch_numbers.html#NaN) `NaN` 视为等于自身：
- en: '[PRE29]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It distinguishes a positive zero and a negative zero (the two are usually considered
    to be the same value, so this functionality is not that useful):'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它区分正零和负零（这两个值通常被认为是相同的，因此此功能并不那么有用）：
- en: '[PRE30]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[15.5.4.1 Detecting `NaN` via `Object.is()`](#detecting-nan-via-objectis)'
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[15.5.4.1 通过 `Object.is()` 检测 `NaN`](#detecting-nan-via-objectis)'
- en: '`Object.is()` considering `NaN` to be equal to itself is occasionally useful.
    For example, we can use it to implement an improved version of the Array method
    `.indexOf()`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.is()` 将 `NaN` 视为等于自身，偶尔很有用。例如，我们可以用它来实现数组方法 `.indexOf()` 的改进版本：'
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`myIndexOf()` finds `NaN` in an Array, while `.indexOf()` doesn’t:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`myIndexOf()` 在数组中查找 `NaN`，而 `.indexOf()` 则不：'
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The result `-1` means that `.indexOf()` couldn’t find its argument in the Array.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 结果 `-1` 表示 `.indexOf()` 在数组中找不到其参数。
- en: '[15.6 Ordering operators](#ordering-operators)'
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[15.6 排序运算符](#ordering-operators)'
- en: '| Operator | name |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 名称 |'
- en: '| --- | --- |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `<` | less than |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `<` | 小于 |'
- en: '| `<=` | Less than or equal |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | 小于等于 |'
- en: '| `>` | Greater than |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 大于 |'
- en: '| `>=` | Greater than or equal |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | 大于等于 |'
- en: 'Table 15.1: JavaScript’s ordering operators.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15.1：JavaScript 的排序运算符。
- en: 'JavaScript’s ordering operators ([table 15.1](#tbl:ordering_operators)) work
    for both numbers and strings:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的排序运算符（[表 15.1](#tbl:ordering_operators)）适用于数字和字符串：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`<=` and `>=` are based on strict equality.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`<=` 和 `>=` 基于严格相等。'
- en: '![Icon “warning”](../Images/5aa4bf88dc66ecb2bac6be4022a1fed4.png) **The ordering
    operators don’t work well for human languages**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“警告”](../Images/5aa4bf88dc66ecb2bac6be4022a1fed4.png) **排序运算符在处理人类语言时效果不佳**'
- en: The ordering operators don’t work well for comparing text in a human language,
    e.g., when capitalization or accents are involved. The details are explained in
    [“Comparing strings” (§22.6)](ch_strings.html#comparing-strings).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 排序运算符在比较人类语言文本时效果不佳，例如，当涉及大小写或重音符号时。详情请见[“比较字符串”（§22.6）](ch_strings.html#comparing-strings)。
- en: '[15.7 Various other operators](#various-other-operators)'
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[15.7 其他各种运算符](#various-other-operators)'
- en: 'The following operators are covered elsewhere in this book:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下运算符在其他章节中有所介绍：
- en: Operators for [booleans](ch_booleans.html#ch_booleans), [numbers](ch_numbers.html#ch_numbers),
    [strings](ch_strings.html#ch_strings), [objects](ch_objects.html#ch_objects)
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于[布尔值](ch_booleans.html#ch_booleans)、[数字](ch_numbers.html#ch_numbers)、[字符串](ch_strings.html#ch_strings)、[对象](ch_objects.html#ch_objects)的运算符
- en: '[The nullish coalescing operator (`??`) for default values](ch_undefined-null.html#nullish-coalescing-operator)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[用于默认值的空值合并运算符（`??`）](ch_undefined-null.html#nullish-coalescing-operator)'
- en: The next two subsections discuss two operators that are rarely used.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 下两个小节讨论了两个很少使用的运算符。
- en: '[15.7.1 Comma operator](#comma-operator)'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[15.7.1 逗号运算符](#comma-operator)'
- en: 'The comma operator has two operands, evaluates both of them and returns the
    second one:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号运算符有两个操作数，评估它们并返回第二个：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Output:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For more information on this operator, see [*Speaking JavaScript*](http://exploringjs.com/es5/ch09.html#comma_operator).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此运算符的更多信息，请参阅[*Speaking JavaScript*](http://exploringjs.com/es5/ch09.html#comma_operator)。
- en: '[15.7.2 `void` operator](#void-operator)'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[15.7.2 `void`运算符](#void-operator)'
- en: 'The `void` operator evaluates its operand and returns `undefined`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`void`运算符评估其操作数并返回`undefined`：'
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Output:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For more information on this operator, see [*Speaking JavaScript*](http://exploringjs.com/es5/ch09.html#void_operator).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此运算符的更多信息，请参阅[*Speaking JavaScript*](http://exploringjs.com/es5/ch09.html#void_operator)。
