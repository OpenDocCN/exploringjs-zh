["```js\nconst myObject = { // object literal\n myProperty: 1,\n myMethod() {\n return 2;\n }, // comma!\n get myAccessor() {\n return this.myProperty;\n }, // comma!\n set myAccessor(value) {\n this.myProperty = value;\n }, // last comma is optional\n};\n\nassert.equal(\n myObject.myProperty, 1\n);\nassert.equal(\n myObject.myMethod(), 2\n);\nassert.equal(\n myObject.myAccessor, 1\n);\nmyObject.myAccessor = 3;\nassert.equal(\n myObject.myProperty, 3\n);\n```", "```js\nconst original = {\n a: 1,\n b: {\n c: 3,\n },\n};\n\n// Spreading (...) copies one object \u201cinto\u201d another one:\nconst modifiedCopy = {\n ...original, // spreading\n d: 4,\n};\n\nassert.deepEqual(\n modifiedCopy,\n {\n a: 1,\n b: {\n c: 3,\n },\n d: 4,\n }\n);\n\n// Caveat: spreading copies shallowly (property values are shared)\nmodifiedCopy.a = 5; // does not affect `original`\nmodifiedCopy.b.c = 6; // affects `original`\nassert.deepEqual(\n original,\n {\n a: 1, // unchanged\n b: {\n c: 6, // changed\n },\n },\n);\n```", "```js\nconst exactCopy = {...obj};\n```", "```js\n// `obj1` has no prototype (its prototype is `null`)\nconst obj1 = Object.create(null); // (A)\nassert.equal(\n Object.getPrototypeOf(obj1), null // (B)\n);\n\n// `obj2` has the prototype `proto`\nconst proto = {\n protoProp: 'protoProp',\n};\nconst obj2 = {\n __proto__: proto, // (C)\n objProp: 'objProp',\n}\nassert.equal(\n Object.getPrototypeOf(obj2), proto\n);\n```", "```js\n// `obj2` inherits .protoProp from `proto`\nassert.equal(\n obj2.protoProp, 'protoProp'\n);\nassert.deepEqual(\n Reflect.ownKeys(obj2),\n ['objProp'] // own properties of `obj2`\n);\n```", "```js\n    const fixedLayoutObject = {\n     product: 'carrot',\n     quantity: 4,\n    };\n    ```", "```js\n    const dictionaryObject = {\n     ['one']: 1,\n     ['two']: 2,\n    };\n    ```", "```js\nconst jane = {\n first: 'Jane',\n last: 'Doe', // optional trailing comma\n};\n```", "```js\nconst obj = {\n if: true,\n const: true,\n};\n```", "```js\n> Object.keys({a:1, b:2})\n[ 'a', 'b' ]\n```", "```js\nfunction createPoint(x, y) {\n return {x, y}; // Same as: {x: x, y: y}\n}\nassert.deepEqual(\n createPoint(9, 2),\n { x: 9, y: 2 }\n);\n```", "```js\nconst jane = {\n first: 'Jane',\n last: 'Doe',\n};\n\n// Get property .first\nassert.equal(jane.first, 'Jane'); // (A)\n```", "```js\nassert.equal(jane.unknownProperty, undefined);\n```", "```js\nconst obj = {\n prop: 1,\n};\nassert.equal(obj.prop, 1);\nobj.prop = 2; // (A)\nassert.equal(obj.prop, 2);\n```", "```js\nconst obj = {}; // empty object\nassert.deepEqual(\n Object.keys(obj), []);\n\nobj.unknownProperty = 'abc';\nassert.deepEqual(\n Object.keys(obj), ['unknownProperty']);\n```", "```js\nconst jane = {\n first: 'Jane', // value property\n says(text) {   // method\n return `${this.first} says \u201c${text}\u201d`; // (A)\n }, // comma as separator (optional at end)\n};\nassert.equal(jane.says('hello'), 'Jane says \u201chello\u201d');\n```", "```js\nconst jane = {\n first: 'Jane',\n last: 'Doe',\n get full() {\n return `${this.first}  ${this.last}`;\n },\n};\n\nassert.equal(jane.full, 'Jane Doe');\njane.first = 'John';\nassert.equal(jane.full, 'John Doe');\n```", "```js\nconst jane = {\n first: 'Jane',\n last: 'Doe',\n set full(fullName) {\n const parts = fullName.split(' ');\n this.first = parts[0];\n this.last = parts[1];\n },\n};\n\njane.full = 'Richard Roe';\nassert.equal(jane.first, 'Richard');\nassert.equal(jane.last, 'Roe');\n```", "```js\n> const obj = {one: 1, two: 2};\n> {...obj, three: 3}\n{ one: 1, two: 2, three: 3 }\n```", "```js\nconst obj1 = {one: 1, two: 2};\nconst obj2 = {three: 3};\nassert.deepEqual(\n {...obj1, ...obj2, four: 4},\n {one: 1, two: 2, three: 3,  four: 4}\n);\n```", "```js\n> const obj = {one: 1, two: 2, three: 3};\n> {...obj, one: true}\n{ one: true, two: 2, three: 3 }\n> {one: true, ...obj}\n{ one: 1, two: 2, three: 3 }\n```", "```js\n> {...undefined}\n{}\n> {...null}\n{}\n> {...123}\n{}\n> {...'abc'}\n{ '0': 'a', '1': 'b', '2': 'c' }\n> {...['a', 'b']}\n{ '0': 'a', '1': 'b' }\n```", "```js\nconst symbolKey = Symbol('symbolKey');\nconst obj = {\n stringKey: 1,\n [symbolKey]: 2,\n};\nassert.deepEqual(\n {...obj, anotherStringKey: 3},\n {\n stringKey: 1,\n [symbolKey]: 2,\n anotherStringKey: 3,\n }\n);\n```", "```js\nconst copy = {...original};\n```", "```js\nconst original = { a: 1, b: {prop: true} };\nconst copy = {...original};\n```", "```js\ncopy.a = 2;\nassert.deepEqual(\n original, { a: 1, b: {prop: true} }); // no change\n```", "```js\ncopy.b.prop = false;\nassert.deepEqual(\n original, { a: 1, b: {prop: false} });\n```", "```js\nconst DEFAULTS = {alpha: 'a', beta: 'b'};\nconst providedData = {alpha: 1};\n\nconst allData = {...DEFAULTS, ...providedData};\nassert.deepEqual(allData, {alpha: 1, beta: 'b'});\n```", "```js\nconst providedData = {alpha: 1};\n\nconst allData = {alpha: 'a', beta: 'b', ...providedData};\nassert.deepEqual(allData, {alpha: 1, beta: 'b'});\n```", "```js\nconst obj = {alpha: 'a', beta: 'b'};\nobj.alpha = 1; // (A)\nassert.deepEqual(obj, {alpha: 1, beta: 'b'});\n```", "```js\nconst obj = {alpha: 'a', beta: 'b'};\nconst updatedObj = {...obj, alpha: 1};\nassert.deepEqual(updatedObj, {alpha: 1, beta: 'b'});\n```", "```js\nObject.assign(target, source_1, source_2, \u00b7\u00b7\u00b7)\n```", "```js\nconst target = { a: 1 };\n\nconst result = Object.assign(\n target,\n {b: 2},\n {c: 3, b: true});\n\nassert.deepEqual(\n result, { a: 1, b: true, c: 3 });\n// target was modified and returned:\nassert.equal(result, target);\n```", "```js\nconst jane = {\n first: 'Jane',\n says(text) {\n return `${this.first} says \u201c${text}\u201d`;\n },\n};\n```", "```js\nassert.equal(typeof jane.says, 'function');\n```", "```js\nconst jane = {\n first: 'Jane',\n says: function (text) {\n return `${this.first} says \u201c${text}\u201d`;\n },\n};\n```", "```js\nconst obj = {\n someMethod(x, y) {\n assert.equal(this, obj); // (A)\n assert.equal(x, 'a');\n assert.equal(y, 'b');\n }\n};\nobj.someMethod('a', 'b'); // (B)\n```", "```js\nobj.someMethod('a', 'b')\n```", "```js\nobj.someMethod.call(obj, 'a', 'b');\n```", "```js\nconst func = obj.someMethod;\nfunc.call(obj, 'a', 'b');\n```", "```js\nconst jane = {\n first: 'Jane',\n says(text) {\n return `${this.first} says \u201c${text}\u201d`; // (A)\n },\n};\n\nconst func = jane.says.bind(jane, 'hello');\nassert.equal(func(), 'Jane says \u201chello\u201d');\n```", "```js\nconst jane = {\n first: 'Jane',\n says(text) {\n return `${this.first} says \u201c${text}\u201d`;\n },\n};\nconst func = jane.says; // extract the method\nassert.throws(\n () => func('hello'), // (A)\n {\n name: 'TypeError',\n message: \"Cannot read properties of undefined (reading 'first')\",\n });\n```", "```js\nassert.throws(\n () => jane.says.call(undefined, 'hello'), // `this` is undefined!\n {\n name: 'TypeError',\n message: \"Cannot read properties of undefined (reading 'first')\",\n }\n);\n```", "```js\nconst func2 = jane.says.bind(jane);\nassert.equal(func2('hello'), 'Jane says \u201chello\u201d');\n```", "```js\nconst func3 = text => jane.says(text);\nassert.equal(func3('hello'), 'Jane says \u201chello\u201d');\n```", "```js\nclass ClickHandler {\n constructor(id, elem) {\n this.id = id;\n elem.addEventListener('click', this.handleClick); // (A)\n }\n handleClick(event) {\n alert('Clicked ' + this.id);\n }\n}\n```", "```js\nconst listener = this.handleClick.bind(this);\nelem.addEventListener('click', listener);\n\n// Later, possibly:\nelem.removeEventListener('click', listener);\n```", "```js\nconst prefixer = {\n prefix: '==> ',\n prefixStringArray(stringArray) {\n return stringArray.map(\n function (x) {\n return this.prefix + x; // (A)\n });\n },\n};\nassert.throws(\n () => prefixer.prefixStringArray(['a', 'b']),\n {\n name: 'TypeError',\n message: \"Cannot read properties of undefined (reading 'prefix')\",\n }\n);\n```", "```js\nconst prefixer = {\n prefix: '==> ',\n prefixStringArray(stringArray) {\n return stringArray.map(\n (x) => {\n return this.prefix + x;\n });\n },\n};\nassert.deepEqual(\n prefixer.prefixStringArray(['a', 'b']),\n ['==> a', '==> b']);\n```", "```js\nprefixStringArray(stringArray) {\n const that = this; // (A)\n return stringArray.map(\n function (x) {\n return that.prefix + x;\n });\n},\n```", "```js\nprefixStringArray(stringArray) {\n return stringArray.map(\n function (x) {\n return this.prefix + x;\n }.bind(this)); // (A)\n},\n```", "```js\nprefixStringArray(stringArray) {\n return stringArray.map(\n function (x) {\n return this.prefix + x;\n },\n this); // (A)\n},\n```", "```js\nobj?.prop     // optional fixed property getting\nobj?.[\u00abexpr\u00bb] // optional dynamic property getting\nfunc?.(\u00abarg0\u00bb, \u00abarg1\u00bb) // optional function or method call\n```", "```js\n> null?.prop\nundefined\n> {prop: 1}?.prop\n1\n\n> null?.(123)\nundefined\n> String?.(123)\n'123'\n```", "```js\nconst persons = [\n {\n surname: 'Zoe',\n address: {\n street: {\n name: 'Sesame Street',\n number: '123',\n },\n },\n },\n {\n surname: 'Mariner',\n },\n {\n surname: 'Carmen',\n address: {\n },\n },\n];\n```", "```js\nconst streetNames = persons.map(\n p => p.address?.street?.name);\nassert.deepEqual(\n streetNames, ['Sesame Street', undefined, undefined]\n);\n```", "```js\nconst streetNames = persons.map(\n p => p.address?.street?.name ?? '(no name)');\nassert.deepEqual(\n streetNames, ['Sesame Street', '(no name)', '(no name)']\n);\n```", "```js\no?.prop\n(o !== undefined && o !== null) ? o.prop : undefined\n```", "```js\nassert.equal(undefined?.prop, undefined);\nassert.equal(null?.prop,      undefined);\nassert.equal({prop:1}?.prop,  1);\n```", "```js\no?.[\u00abexpr\u00bb]\n(o !== undefined && o !== null) ? o[\u00abexpr\u00bb] : undefined\n```", "```js\nconst key = 'prop';\nassert.equal(undefined?.[key], undefined);\nassert.equal(null?.[key], undefined);\nassert.equal({prop:1}?.[key], 1);\n```", "```js\nf?.(arg0, arg1)\n(f !== undefined && f !== null) ? f(arg0, arg1) : undefined\n```", "```js\nassert.equal(undefined?.(123), undefined);\nassert.equal(null?.(123), undefined);\nassert.equal(String?.(123), '123');\n```", "```js\nassert.throws(\n () => true?.(123),\n TypeError);\n```", "```js\nfunction invokeM(value) {\n return value?.a.b.m(); // (A)\n}\n\nconst obj = {\n a: {\n b: {\n m() { return 'result' }\n }\n }\n};\nassert.equal(\n invokeM(obj), 'result'\n);\nassert.equal(\n invokeM(undefined), undefined // (B)\n);\n```", "```js\nobj?.[\u00abexpr\u00bb]          // better: obj?[\u00abexpr\u00bb]\nfunc?.(\u00abarg0\u00bb, \u00abarg1\u00bb) // better: func?(\u00abarg0\u00bb, \u00abarg1\u00bb)\n```", "```js\nobj?['a', 'b', 'c'].map(x => x+x)\nobj ? ['a', 'b', 'c'].map(x => x+x) : []\n```", "```js\nconst obj = {\n mustBeAnIdentifier: 123,\n};\n\n// Get property\nassert.equal(obj.mustBeAnIdentifier, 123);\n\n// Set property\nobj.mustBeAnIdentifier = 'abc';\nassert.equal(obj.mustBeAnIdentifier, 'abc');\n```", "```js\nconst obj = {\n 'Can be any string!': 123,\n};\n```", "```js\n// Get property\nassert.equal(obj['Can be any string!'], 123);\n\n// Set property\nobj['Can be any string!'] = 'abc';\nassert.equal(obj['Can be any string!'], 'abc');\n```", "```js\nconst obj = {\n 'A nice method'() {\n return 'Yes!';\n },\n};\n\nassert.equal(obj['A nice method'](), 'Yes!');\n```", "```js\nconst obj = {\n ['Hello world!']: true,\n ['p'+'r'+'o'+'p']: 123,\n [Symbol.toStringTag]: 'Goodbye', // (A)\n};\n\nassert.equal(obj['Hello world!'], true);\nassert.equal(obj.prop, 123);\nassert.equal(obj[Symbol.toStringTag], 'Goodbye');\n```", "```js\nassert.equal(obj['p'+'r'+'o'+'p'], 123);\nassert.equal(obj['==> prop'.slice(4)], 123);\n```", "```js\nconst methodKey = Symbol();\nconst obj = {\n [methodKey]() {\n return 'Yes!';\n },\n};\n\nassert.equal(obj[methodKey](), 'Yes!');\n```", "```js\nconst obj = {\n alpha: 'abc',\n beta: false,\n};\n\nassert.equal('alpha' in obj, true);\nassert.equal('beta' in obj, true);\nassert.equal('unknownKey' in obj, false);\n```", "```js\nassert.equal(\n obj.alpha ? 'exists' : 'does not exist',\n 'exists');\nassert.equal(\n obj.unknownKey ? 'exists' : 'does not exist',\n 'does not exist');\n```", "```js\nassert.equal(\n obj.beta ? 'exists' : 'does not exist',\n 'does not exist'); // should be: 'exists'\n```", "```js\nconst obj = {\n myProp: 123,\n};\n\nassert.deepEqual(Object.keys(obj), ['myProp']);\ndelete obj.myProp;\nassert.deepEqual(Object.keys(obj), []);\n```", "```js\nconst enumerableSymbolKey = Symbol('enumerableSymbolKey');\nconst nonEnumSymbolKey = Symbol('nonEnumSymbolKey');\n\n// We create enumerable properties via an object literal\nconst obj = {\n enumerableStringKey: 1,\n [enumerableSymbolKey]: 2,\n}\n\n// For non-enumerable properties, we need a more powerful tool\nObject.defineProperties(obj, {\n nonEnumStringKey: {\n value: 3,\n enumerable: false,\n },\n [nonEnumSymbolKey]: {\n value: 4,\n enumerable: false,\n },\n});\n\n// Non-enumerable properties are ignored by spreading:\nassert.deepEqual(\n {...obj},\n {\n enumerableStringKey: 1,\n [enumerableSymbolKey]: 2,\n }\n);\n```", "```js\nconst enumerableSymbolKey = Symbol('enumerableSymbolKey');\nconst nonEnumSymbolKey = Symbol('nonEnumSymbolKey');\n\nconst obj = {\n enumerableStringKey: 1,\n [enumerableSymbolKey]: 2,\n}\nObject.defineProperties(obj, {\n nonEnumStringKey: {\n value: 3,\n enumerable: false,\n },\n [nonEnumSymbolKey]: {\n value: 4,\n enumerable: false,\n },\n});\n\nassert.deepEqual(\n Object.keys(obj),\n ['enumerableStringKey']\n);\nassert.deepEqual(\n Object.getOwnPropertyNames(obj),\n ['enumerableStringKey', 'nonEnumStringKey']\n);\nassert.deepEqual(\n Object.getOwnPropertySymbols(obj),\n [enumerableSymbolKey, nonEnumSymbolKey]\n);\nassert.deepEqual(\n Reflect.ownKeys(obj),\n [\n 'enumerableStringKey', 'nonEnumStringKey',\n enumerableSymbolKey, nonEnumSymbolKey,\n ]\n);\n```", "```js\nconst firstName = Symbol('firstName');\nconst obj = {\n [firstName]: 'Jane',\n lastName: 'Doe',\n};\nassert.deepEqual(\n Object.values(obj),\n ['Doe']);\n```", "```js\nconst firstName = Symbol('firstName');\nconst obj = {\n [firstName]: 'Jane',\n lastName: 'Doe',\n};\nassert.deepEqual(\n Object.entries(obj),\n [\n ['lastName', 'Doe'],\n ]);\n```", "```js\nfunction entries(obj) {\n return Object.keys(obj)\n .map(key => [key, obj[key]]);\n}\n```", "```js\n> Object.keys({b:0,a:0, 10:0,2:0})\n[ '2', '10', 'b', 'a' ]\n```", "```js\nconst symbolKey = Symbol('symbolKey');\nassert.deepEqual(\n Object.fromEntries(\n [\n ['stringKey', 1],\n [symbolKey, 2],\n ]\n ),\n {\n stringKey: 1,\n [symbolKey]: 2,\n }\n);\n```", "```js\npick(object, ...keys)\n```", "```js\nconst address = {\n street: 'Evergreen Terrace',\n number: '742',\n city: 'Springfield',\n state: 'NT',\n zip: '49007',\n};\nassert.deepEqual(\n pick(address, 'street', 'number'),\n {\n street: 'Evergreen Terrace',\n number: '742',\n }\n);\n```", "```js\nfunction pick(object, ...keys) {\n const filteredEntries = Object.entries(object)\n .filter(([key, _value]) => keys.includes(key));\n return Object.fromEntries(filteredEntries);\n}\n```", "```js\ninvert(object)\n```", "```js\nassert.deepEqual(\n invert({a: 1, b: 2, c: 3}),\n {1: 'a', 2: 'b', 3: 'c'}\n);\n```", "```js\nfunction invert(object) {\n const reversedEntries = Object.entries(object)\n .map(([key, value]) => [value, key]);\n return Object.fromEntries(reversedEntries);\n}\n```", "```js\nfunction fromEntries(iterable) {\n const result = {};\n for (const [key, value] of iterable) {\n let coercedKey;\n if (typeof key === 'string' || typeof key === 'symbol') {\n coercedKey = key;\n } else {\n coercedKey = String(key);\n }\n result[coercedKey] = value;\n }\n return result;\n}\n```", "```js\nconst dict = {};\nassert.equal('toString' in dict, true);\n```", "```js\nconst dict = {};\n\ndict['__proto__'] = 123;\n// No property was added to dict:\nassert.deepEqual(Object.keys(dict), []);\n```", "```js\nconst dict = Object.create(null); // prototype is `null`\n\nassert.equal('toString' in dict, false); // (A)\n\ndict['__proto__'] = 123;\nassert.deepEqual(Object.keys(dict), ['__proto__']);\n```", "```js\nconst obj = { myProp: 123 };\nassert.deepEqual(\n Object.getOwnPropertyDescriptor(obj, 'myProp'),\n {\n value: 123,\n writable: true,\n enumerable: true,\n configurable: true,\n });\n```", "```js\nassert.deepEqual(Object.keys(obj), ['myProp']);\n\n// Hide property `myProp` from Object.keys()\n// by making it non-enumerable\nObject.defineProperty(obj, 'myProp', {\n enumerable: false,\n});\n\nassert.deepEqual(Object.keys(obj), []);\n```", "```js\nconst frozen = Object.freeze({ x: 2, y: 5 });\nassert.throws(\n () => { frozen.x = 7 },\n {\n name: 'TypeError',\n message: /^Cannot assign to read only property 'x'/,\n });\n```", "```js\nconst proto = {\n protoProp: 'a',\n};\nconst obj = {\n __proto__: proto,\n objProp: 'b',\n};\n\n// obj inherits .protoProp:\nassert.equal(obj.protoProp, 'a');\nassert.equal('protoProp' in obj, true);\n```", "```js\n> const obj = { one: 1 };\n> typeof obj.one // own\n'number'\n> typeof obj.toString // inherited\n'function'\n```", "```js\n> Object.keys(obj)\n[ 'one' ]\n```", "```js\nconst proto = {\n protoProp: 'a',\n};\nconst obj = {\n __proto__: proto,\n objProp: 'b',\n};\n```", "```js\n// In the beginning, obj has one own property\nassert.deepEqual(Object.keys(obj), ['objProp']);\n\nobj.protoProp = 'x'; // (A)\n\n// We created a new own property:\nassert.deepEqual(Object.keys(obj), ['objProp', 'protoProp']);\n\n// The inherited property itself is unchanged:\nassert.equal(proto.protoProp, 'a');\n\n// The own property overrides the inherited property:\nassert.equal(obj.protoProp, 'x');\n```", "```js\n    Object.getPrototypeOf(obj: Object) : Object\n    ```", "```js\n    Object.create(proto: Object) : Object\n    ```", "```js\nconst proto1 = {};\nconst proto2a = {};\nconst proto2b = {};\n\nconst obj1 = {\n __proto__: proto1,\n a: 1,\n b: 2,\n};\nassert.equal(Object.getPrototypeOf(obj1), proto1);\n\nconst obj2 = Object.create(\n proto2a,\n {\n a: {\n value: 1,\n writable: true,\n enumerable: true,\n configurable: true,\n },\n b: {\n value: 2,\n writable: true,\n enumerable: true,\n configurable: true,\n }, \n }\n);\nassert.equal(Object.getPrototypeOf(obj2), proto2a);\n\nObject.setPrototypeOf(obj2, proto2b);\nassert.equal(Object.getPrototypeOf(obj2), proto2b);\n```", "```js\nconst a = {};\nconst b = {__proto__: a};\nconst c = {__proto__: b};\n\nassert.equal(a.isPrototypeOf(b), true);\nassert.equal(a.isPrototypeOf(c), true);\n\nassert.equal(c.isPrototypeOf(a), false);\nassert.equal(a.isPrototypeOf(a), false);\n```", "```js\nconst proto = {\n protoProp: 'protoProp',\n};\nconst obj = {\n __proto__: proto,\n objProp: 'objProp',\n}\nassert.equal('protoProp' in obj, true); // (A)\nassert.equal(Object.hasOwn(obj, 'protoProp'), false); // (B)\nassert.equal(Object.hasOwn(proto, 'protoProp'), true); // (C)\n```", "```js\nconst jane = {\n firstName: 'Jane',\n describe() {\n return 'Person named '+this.firstName;\n },\n};\nconst tarzan = {\n firstName: 'Tarzan',\n describe() {\n return 'Person named '+this.firstName;\n },\n};\n\nassert.equal(jane.describe(), 'Person named Jane');\nassert.equal(tarzan.describe(), 'Person named Tarzan');\n```", "```js\nconst PersonProto = {\n describe() {\n return 'Person named ' + this.firstName;\n },\n};\nconst jane = {\n __proto__: PersonProto,\n firstName: 'Jane',\n};\nconst tarzan = {\n __proto__: PersonProto,\n firstName: 'Tarzan',\n};\n```", "```js\nassert.equal(jane.describe(), 'Person named Jane');\nassert.equal(tarzan.describe(), 'Person named Tarzan');\n```"]