- en: 46‚ÄÉRegular expressions (RegExp)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://exploringjs.com/js/book/ch_regexps.html](https://exploringjs.com/js/book/ch_regexps.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[46.1‚ÄÉCreating regular expressions](#creating-regular-expressions)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.1.1‚ÄÉLiteral vs. constructor](#regex-literal-vs-constructor)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.1.2‚ÄÉTip: Use `String.raw` literals with `new RegExp()`](#tip-use-stringraw-literals-with-new-regexp)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.1.3‚ÄÉCloning and non-destructively modifying regular expressions](#cloning-regexps)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.2‚ÄÉSyntax characters and escaping](#escaping-for-regexp)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.2.1‚ÄÉSyntax characters](#syntax-characters)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.2.2‚ÄÉIllegal top-level escaping](#illegal-toplevel-escaping)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.2.3‚ÄÉEscaping inside character classes (`[¬∑¬∑¬∑]`)](#escaping-inside-character-classes)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.3‚ÄÉRegular expressions: the concept of a character](#regular-expression-character)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.4‚ÄÉSyntax: matching single characters](#syntax-matching-single-characters)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.5‚ÄÉSyntax: character class escapes](#syntax-character-class-escapes)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.5.1‚ÄÉBasic character class escapes (sets of code units): `\d \D \s \S \w
    \W`](#basic-character-class-escapes)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.5.2‚ÄÉUnicode property escapes: `\p{}` and `\P{}`](#unicode-property-escapes)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.5.3‚ÄÉUnicode character property escapes ^(ES2018)](#unicode-character-property-escapes)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.5.4‚ÄÉUnicode string property escapes ^(ES2024)](#unicode-string-property-escapes)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.6‚ÄÉSyntax: character classes](#syntax-character-classes)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.6.1‚ÄÉCode point sequences in character classes ^(ES2024)](#character-class-code-point-sequences)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.6.2‚ÄÉSet operations for character classes ^(ES2024)](#regexp-character-class-set-operations)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.7‚ÄÉSyntax: capture groups](#regexp-capture-groups)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.8‚ÄÉSyntax: quantifiers](#regexp-quantifiers)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.9‚ÄÉSyntax: assertions](#regexp-assertions)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.9.1‚ÄÉLookahead assertions](#regexp-lookahead-assertions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.9.2‚ÄÉLookbehind assertions ^(ES2018)](#regexp-lookbehind-assertions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.10‚ÄÉSyntax: disjunction (`|`)](#syntax-disjunction-)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.11‚ÄÉRegular expression flags](#regexp-flags)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.11.1‚ÄÉHow to order regular expression flags?](#order-of-regexp-flags)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.11.2‚ÄÉWithout the Unicode flags `/u` and `/v`: characters are UTF-16 code
    units](#without-the-unicode-flags-u-and-v-characters-are-utf16-code-units)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.11.3‚ÄÉFlag `/u`: characters are code points ^(ES6)](#regexp-flag-unicode)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.11.4‚ÄÉFlag `/v`: limited support for multi-code-point grapheme clusters
    ^(ES2024)](#regexp-flag-unicode-sets)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.12‚ÄÉPattern modifiers (inline flags) ^(ES2025)](#regexp-pattern-modifiers)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.12.1‚ÄÉThe syntax of pattern modifiers](#the-syntax-of-pattern-modifiers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.12.2‚ÄÉWhich flags are supported?](#which-flags-are-supported)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.12.3‚ÄÉUse case: changing flags for part of a regular expression](#use-case-changing-flags-for-part-of-a-regular-expression)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.12.4‚ÄÉUse case: inlining flags](#use-case-inlining-flags)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.12.5‚ÄÉUse case: regular expression fragments that change flags](#use-case-regular-expression-fragments-that-change-flags)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.13‚ÄÉProperties of regular expression objects](#properties-of-regular-expression-objects)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.13.1‚ÄÉFlags as properties](#flags-as-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.13.2‚ÄÉOther properties](#other-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.14‚ÄÉMatch objects](#match-objects)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.14.1‚ÄÉMatch indices in match objects ^(ES2022)](#regexp-match-indices)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.15‚ÄÉMethods for working with regular expressions](#methods-for-working-with-regular-expressions)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.15.1‚ÄÉBy default, regular expressions match anywhere in a string](#by-default-regular-expressions-match-anywhere-in-a-string)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.15.2‚ÄÉ`string.match(regExp)` without `/g`: getting a match object for the
    first match](#String.prototype.match)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.15.3‚ÄÉ`string.match(regExp)` with `/g`: getting all group 0 captures ^(ES3)](#stringmatchregexp-with-g-getting-all-group-0-captures-es3)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.15.4‚ÄÉ`string.matchAll(regExp)`: getting an iterable over all match objects
    ^(ES2020)](#String.prototype.matchAll)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.15.5‚ÄÉ`regExp.exec(str)`: capturing groups ^(ES3)](#RegExp.prototype.exec)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.15.6‚ÄÉ`string.match()` vs. `string.matchAll()` vs. `regExp.exec()`](#match-vs-matchall-vs-exec)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.15.7‚ÄÉReplacing with `string.replace()` and `string.replaceAll()`](#replace-replaceAll)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.15.8‚ÄÉ`regExp.test(str)`: is there a match? ^(ES3)](#RegExp.prototype.test)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.15.9‚ÄÉ`string.search(regExp)`: at what index is the match? ^(ES3)](#String.prototype.search)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.15.10‚ÄÉ`string.split(separator, limit?)`: splitting strings ^(ES3)](#String.prototype.split)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.16‚ÄÉThe flags `/g` and `/y`, and the property `.lastIndex` (advanced)](#regexp-flags-gy)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.16.1‚ÄÉThe flags `/g` and `/y`](#the-flags-g-and-y)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.16.2‚ÄÉHow exactly are methods affected by `/g` and `/y`?](#how-exactly-are-methods-affected-by-g-and-y)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.16.3‚ÄÉFour pitfalls of `/g` and `/y` and how to deal with them](#four-pitfalls-of-g-and-y-and-how-to-deal-with-them)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.16.4‚ÄÉUse case for `.lastIndex`: starting matching at a given index](#use-case-for-lastindex-starting-matching-at-a-given-index)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.16.5‚ÄÉThe downsides and an upside of `.lastIndex`](#regexp-lastindex-upsides-downsides)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.17‚ÄÉ`RegExp.escape()`: escaping text so that it can be used inside a regular
    expression ^(ES2025)](#RegExp.escape)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.17.1‚ÄÉUse case for `RegExp.escape()`: replacing all occurrences of a text](#use-case-for-regexpescape-replacing-all-occurrences-of-a-text)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.17.2‚ÄÉUse case for `RegExp.escape()`: part of a regular expression must
    match a given text](#use-case-for-regexpescape-part-of-a-regular-expression-must-match-a-given-text)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.18‚ÄÉMatching everything or nothing](#matching-everything-or-nothing)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.19‚ÄÉTips for making regular expressions easier to use](#tips-for-making-regular-expressions-easier-to-use)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.19.1‚ÄÉTip: Use flag `/v`](#tip-use-flag-v)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.19.2‚ÄÉTip: order flags alphabetically](#tip-order-flags-alphabetically)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.19.3‚ÄÉTip: Use named capture groups](#tip-use-named-capture-groups)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.19.4‚ÄÉTip: insignificant whitespace and line comments via `#`](#tip-insignificant-whitespace-and-line-comments-via-)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.19.5‚ÄÉTip: Write tests for your regular expression](#tip-write-tests-for-your-regular-expression)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.19.6‚ÄÉTip: Mention examples in your documentation](#tip-mention-examples-in-your-documentation)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.19.7‚ÄÉBonus tip: Use interpolation to reuse patterns](#bonus-tip-use-interpolation-to-reuse-patterns)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.19.8‚ÄÉBonus tip: insignificant whitespace without a library](#bonus-tip-insignificant-whitespace-without-a-library)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.19.9‚ÄÉConclusion: This is how regular expressions are meant to be written](#conclusion-this-is-how-regular-expressions-are-meant-to-be-written)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.20‚ÄÉQuick reference: regular expression functionality](#quickref-RegExp)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.20.1‚ÄÉSummary: `.global` (`/g`) and `.sticky` (`/y`)](#summary-flags-global-sticky)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.20.2‚ÄÉ`String.prototype.*`: matching and searching](#stringprototype-matching-and-searching)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.20.3‚ÄÉ`String.prototype.*`: splitting and replacing](#stringprototype-splitting-and-replacing)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[46.20.4‚ÄÉ`RegExp.prototype.*`](#regexpprototype)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Icon ‚Äúreading‚Äù](../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png)‚ÄÇ**Availability
    of features**'
  prefs: []
  type: TYPE_NORMAL
- en: Unless stated otherwise, each regular expression feature has been available
    since ES3.
  prefs: []
  type: TYPE_NORMAL
- en: '[46.1‚ÄÉCreating regular expressions](#creating-regular-expressions)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[46.1.1‚ÄÉLiteral vs. constructor](#regex-literal-vs-constructor)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The two main ways of creating regular expressions are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Literal: compiled statically (at load time).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Constructor: compiled dynamically (at runtime).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Both regular expressions have the same two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The *body* `abc` ‚Äì the actual regular expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *flags* `i` and `v`. Flags configure how the pattern is interpreted. For
    example, `i` enables case-insensitive matching. A list of available flags is given
    [later in this chapter](#regexp-flags).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Icon ‚Äútip‚Äù](../Images/8440b17bb8219cda9f9405ac83c36db0.png)‚ÄÇ**Recommended:
    flag `/v` ^(ES2024)**'
  prefs: []
  type: TYPE_NORMAL
- en: Flag `/v` enables important features and is recommended for all regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '[46.1.2‚ÄÉTip: Use `String.raw` literals with `new RegExp()`](#tip-use-stringraw-literals-with-new-regexp)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we use a normal string literal as an argument for `new RegExp()`, every
    regular expression backslash has to be escaped. If we use [`String.raw`](ch_template-literals.html#raw-string-literals)
    as a template tag then that‚Äôs not necessary. The following three regular expressions
    are all equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use `String.raw` often, we can abbreviate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4][PRE5][PRE6][PRE7] #### [46.1.3‚ÄÉCloning and non-destructively modifying
    regular expressions](#cloning-regexps)    There are two variants of the constructor
    `RegExp()`:    *   `new RegExp(pattern : string, flags = '''')` ^(ES3)                    A
    new regular expression is created as specified via `pattern`. If `flags` is missing,
    the empty string `''''` is used.           *   `new RegExp(regExp : RegExp, flags
    = regExp.flags)` ^(ES6)                    `regExp` is cloned. If `flags` is provided,
    then it determines the flags of the clone.              The second variant is
    useful for cloning regular expressions, optionally while modifying them. Flags
    are immutable and this is the only way of changing them ‚Äì for example:    [PRE8]    `new
    Set()` iterates over its argument which means that a string is split into code
    points. Those code points become Set elements, which eliminates duplicates. Before
    we can join them into a string, we have to convert them to an Array and do so
    via `Array.from()`.    ### [46.2‚ÄÉSyntax characters and escaping](#escaping-for-regexp)    ####
    [46.2.1‚ÄÉSyntax characters](#syntax-characters)    At the top level of a regular
    expression, the following [*Syntax Characters*](https://tc39.es/ecma262/#prod-SyntaxCharacter)
    are special. They are escaped by prefixing a backslash (`\`).    [PRE9]    This
    is an example:    [PRE10]    In regular expression literals, we must escape slashes:    [PRE11]    In
    the argument of `new RegExp()`, we don‚Äôt have to escape slashes:    [PRE12]    ####
    [46.2.2‚ÄÉIllegal top-level escaping](#illegal-toplevel-escaping)    With a Unicode
    flag (`/u` or `/v`), escaping a non-syntax character at the top level is a syntax
    error. That enables syntax such as `\p{¬∑¬∑¬∑}`.    [PRE13]    Without flag `/u`
    and `/v`, an escaped non-syntax character at the top level matches itself:    [PRE14]    ####
    [46.2.3‚ÄÉEscaping inside character classes (`[¬∑¬∑¬∑]`)](#escaping-inside-character-classes)    The
    rules for escaping inside character classes are different if we use the recommended
    flag `/v`. We look at those first before we look at the rules for regular expressions
    that have no Unicode flag (neither `/u` nor `/v`).    ##### [46.2.3.1‚ÄÉEscaping
    inside character classes: flag `/v`](#escaping-inside-character-classes-flag-v)    The
    following characters can be escaped via backslash:    *   [*Syntax Characters*](https://tc39.es/ecma262/#prod-SyntaxCharacter):                    [PRE15]           *   Slash:                    [PRE16]           *   [*Class
    Set Reserved Punctuators*](https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator):                    [PRE17]              Interestingly,
    we don‚Äôt always have to escape these characters. Only the following sequences
    of characters don‚Äôt match themselves and have to be escaped:    *   A single `^`
    only has to be escaped if it comes first.           *   [*Class Set Syntax Characters*](https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter)
    must always be escaped:                    [PRE18]           *   [*Class Set Reserved
    Double Punctuators*](https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator)
    must always be escaped (at least one of them):                    [PRE19]              #####
    [46.2.3.2‚ÄÉEscaping inside character classes: no Unicode flag (neither `/u` nor
    `/v`)](#escaping-inside-character-classes-no-unicode-flag-neither-u-nor-v)    *   We
    always must escape: `\ ]`           *   Some characters only have to be escaped
    in some locations:               *   `^` only has to be escaped if it comes first.     *   `-`
    only has to be escaped if it doesn‚Äôt come first or last.    ### [46.3‚ÄÉRegular
    expressions: the concept of a character](#regular-expression-character)    In
    the context of regular expressions, ‚Äúcharacter‚Äù means ‚Äúatomic unit of text‚Äù:    *   Without
    the Unicode flags (`/u` and `/v`), a character is a JavaScript character (a UTF-16
    code unit). *   With a Unicode flag, a character is a code point.    For example,
    a dot (`.`) matches a single character:    [PRE20]    ### [46.4‚ÄÉSyntax: matching
    single characters](#syntax-matching-single-characters)    These constructs match
    single characters:    *   *Pattern characters* are all characters *except* syntax
    characters (`^`, `$`, etc.). Pattern characters match themselves. Examples: `A
    b % -`           *   `.` matches any character. We can use [flag `/s` (`dotAll`)](#regexp-dot-all-flag)
    to control if the dot matches line terminators or not.           *   *Character
    escapes* (each escape matches a single fixed character):               *   Control
    escapes (for a few control characters):         *   `\f`: form feed (FF)         *   `\n`:
    line feed (LF)         *   `\r`: carriage return (CR)         *   `\t`: character
    tabulation         *   `\v`: line tabulation     *   Control characters: `\cA`
    (Ctrl-A), ‚Ä¶, `\cZ` (Ctrl-Z)     *   Hex escape (first 256 Unicode code points):
    `\x20` (space)     *   Unicode code unit escapes: `\u00E4` (√§)     *   Unicode
    code point escapes (require Unicode flag `/u` or `/v`): `\u{1F642}` (üôÇ)     *   Identity
    escapes match the escaped characters (these are the rules with a Unicode flag
    `/u` or `/v`; without them, most characters can be identity-escaped):         *   We
    can escape the following [syntax characters](https://tc39.es/ecma262/#prod-SyntaxCharacter)
    by prefixing them with backslashes:                                                    [PRE21]                                   *   We
    can also escape a slash like this: `\/`                              ### [46.5‚ÄÉSyntax:
    character class escapes](#syntax-character-class-escapes)    Character class escapes
    match sets of code units, sets of code points or sets of code point sequences.    ####
    [46.5.1‚ÄÉBasic character class escapes (sets of code units): `\d \D \s \S \w \W`](#basic-character-class-escapes)    The
    following character class escapes and their complements are always supported:     |  |
    Escape | Equivalent | Complement | | --- | --- | --- | --- | | Digits | `\d` |
    `[0-9]` | `\D` | | ‚ÄúWord‚Äù characters | `\w` | `[a-zA-Z0-9_]` | `\W` | | Whitespace
    | `\s` |  | `\S` |    Note:    *   Whitespace: `\s` matches all whitespace code
    points: space, tab, line terminators, etc. They all fit into single UTF-16 code
    units. *   ‚ÄúWord‚Äù characters are related to identifiers in programming languages.    Examples:    [PRE22]    ####
    [46.5.2‚ÄÉUnicode property escapes: `\p{}` and `\P{}`](#unicode-property-escapes)    Unicode
    property escapes look like this:    *   Positive escape: `\p{UP}` matches Unicode
    characters or Unicode strings that have the Unicode property `UP`. *   Negative
    escape: `\P{UP}` matches Unicode characters that do not have the Unicode property
    `UP`.    There are two kinds of Unicode properties:    *   *Unicode character
    properties* are properties of code points. They specify sets of code points.               *   Example:
    `White_Space`     *   Supported by flag `/u` and flag `/v`     *   Introduced
    in ES2018 *   *Unicode string properties* are properties of sequences of code
    points. They specify sets of code point strings. String property escapes can only
    be positive.               *   Example: `RGI_Emoji`     *   Only supported by
    flag `/v`     *   Introduced in ES2024    A quick example before we look at everything
    in more detail. This is how we can escape the Unicode character property `White_Space`:    [PRE23]   [PRE24][PRE25][PRE26][PRE27]``js[PRE28]js[PRE29]`js[PRE30]js`
    Single code points can also be used on either side of the `--` operator:    [PRE31]js    #####
    [46.6.2.3‚ÄÉIntersection of character sets via `&&`](#intersection-of-character-sets-via-)    We
    can use the `&&` operator to set-theoretically intersect the character sets defined
    by character classes or character class escapes:    [PRE32]js   [PRE33]`js[PRE34]js[PRE35]js[PRE36]js[PRE37]js[PRE38]js[PRE39]`js[PRE40]js[PRE41][PRE42][PRE43]js
    a aa  [PRE44]js     > ''aaa''.replace(/a/, ''x'')     ''xaa''          [PRE45]js     >
    ''aaa''.replace(''a'', ''x'')     ''xaa''          [PRE46]js     > ''aaa''.replace(/a/g,
    ''x'')     ''xxx''          [PRE47]js     > ''aaa''.replaceAll(/a/g, ''x'')     ''xxx''          [PRE48]js     >
    ''aaa''.replaceAll(''a'', ''x'')     ''xxx''          [PRE49]js     > ''aaa''.replaceAll(/a/,
    ''x'')     TypeError: String.prototype.replaceAll called with     a non-global
    RegExp argument          [PRE50]js > ''a1 a2''.replaceAll(/a/g, "($`|$&|$'')")
    ''(|a|1 a2)1 (a1 |a|2)2''  [PRE51]js > const regExp = /^([A-Za-z]+): (.*)$/gv;
    > ''first: Jane''.replaceAll(regExp, ''KEY: $1, VALUE: $2'') ''KEY: first, VALUE:
    Jane''  [PRE52]js > const regExp = /^(?<key>[A-Za-z]+): (?<value>.*)$/gv; > ''first:
    Jane''.replaceAll(regExp, ''KEY: $<key>, VALUE: $<value>'') ''KEY: first, VALUE:
    Jane''  [PRE53]js assert.equal(  ''3 cats and 4 dogs''.replaceAll(/[0-9]+/g, (all)
    => 2 * Number(all)),  ''6 cats and 8 dogs'' );  [PRE54]js const result = ''first=jane,
    last=doe''.replace(  /(?<key>[a-z]+)=(?<value>[a-z]+)/g,  (...args) => { // (A)  const
    groups = args.at(-1); // (B)  const {key, value} = groups;  return key.toUpperCase()
    + ''='' + value.toUpperCase();  }); assert.equal(result, ''FIRST=JANE, LAST=DOE'');  [PRE55]js
    > /bc/.test(''ABCD'') false > /bc/i.test(''ABCD'') true > /\.mjs$/.test(''main.mjs'')
    true  [PRE56]js > const r = /a/g; > r.test(''aab'') true > r.test(''aab'') true
    > r.test(''aab'') false  [PRE57]js > ''_abc_''.search(/abc/) 1 > ''main.mjs''.search(/\.mjs$/)
    4  [PRE58]js > ''a : b : c''.split('':'') [ ''a '', '' b '', '' c'' ]  [PRE59]js
    > ''a x:yyy b''.split(/x+:y+/) [ ''a '', '' b'' ] > ''a x:yyy b''.split(/(x+):(y+)/)
    [ ''a '', ''x'', ''yyy'', '' b'' ]  [PRE60]js > ''a: b: c''.split(/(?<=:) */)
    [ ''a:'', ''b:'', ''c'' ] > ''a :b :c''.split(/ *(?=:)/) [ ''a'', '':b'', '':c''
    ]  [PRE61]js > const re = /#/; re.lastIndex = 1; > [''##-#''.match(re), re.lastIndex]
    [{ 0: ''#'', index: 0, input: ''##-#'' }, 1] > [''##-#''.match(re), re.lastIndex]
    [{ 0: ''#'', index: 0, input: ''##-#'' }, 1]  [PRE62]js > const re = /#/y; re.lastIndex
    = 1; > [''##-#''.match(re), re.lastIndex] [{ 0: ''#'', index: 1, input: ''##-#''
    }, 2] > [''##-#''.match(re), re.lastIndex] [null, 0]  [PRE63]js > const re = /#/g;
    re.lastIndex = 1; > ''##-#''.match(re) [''#'', ''#'', ''#''] > re.lastIndex 0  [PRE64]js
    > const re = /#/gy; re.lastIndex = 1; > ''##-#''.match(re) [''#'', ''#''] > re.lastIndex
    0  [PRE65]js > const re = /#/y; re.lastIndex = 1; > ''##-#''.matchAll(re) TypeError:
    String.prototype.matchAll called with a non-global RegExp argument  [PRE66]js
    > const re = /#/g; re.lastIndex = 1; > Array.from(''##-#''.matchAll(re)) [  {
    0: ''#'', index: 1, input: ''##-#'' },  { 0: ''#'', index: 3, input: ''##-#''
    }, ] > re.lastIndex 1  [PRE67]js > const re = /#/gy; re.lastIndex = 1; > Array.from(''##-#''.matchAll(re))
    [  { 0: ''#'', index: 1, input: ''##-#'' }, ] > re.lastIndex 1  [PRE68]js > const
    re = /#/; re.lastIndex = 1; > [re.exec(''##-#''), re.lastIndex] [{ 0: ''#'', index:
    0, input: ''##-#'' }, 1] > [re.exec(''##-#''), re.lastIndex] [{ 0: ''#'', index:
    0, input: ''##-#'' }, 1]  [PRE69]js > const re = /#/g; re.lastIndex = 1; > [re.exec(''##-#''),
    re.lastIndex] [{ 0: ''#'', index: 1, input: ''##-#'' }, 2] > [re.exec(''##-#''),
    re.lastIndex] [{ 0: ''#'', index: 3, input: ''##-#'' }, 4] > [re.exec(''##-#''),
    re.lastIndex] [null, 0]  [PRE70]js > const re = /#/y; re.lastIndex = 1; > [re.exec(''##-#''),
    re.lastIndex] [{ 0: ''#'', index: 1, input: ''##-#'' }, 2] > [re.exec(''##-#''),
    re.lastIndex] [null, 0]  [PRE71]js > const re = /#/; re.lastIndex = 1; > ''##-#''.replace(re,
    ''x'') ''x#-#'' > re.lastIndex 1  [PRE72]js > const re = /#/g; re.lastIndex =
    1; > ''##-#''.replace(re, ''x'') ''xx-x'' > re.lastIndex 0  [PRE73]js > const
    re = /#/y; re.lastIndex = 1; > ''##-#''.replace(re, ''x'') ''#x-#'' > re.lastIndex
    2  [PRE74]js > const re = /#/gy; re.lastIndex = 1; > ''##-#''.replace(re, ''x'')
    ''xx-#'' > re.lastIndex 0  [PRE75]js > const re = /#/y; re.lastIndex = 1; > ''##-#''.replaceAll(re,
    ''x'') TypeError: String.prototype.replaceAll called with a non-global RegExp
    argument  [PRE76]js > const re = /#/; re.lastIndex = 1; > [re.test(''##-#''),
    re.lastIndex] [true, 1] > [re.test(''##-#''), re.lastIndex] [true, 1]  [PRE77]js
    > const re = /#/g; re.lastIndex = 1; > [re.test(''##-#''), re.lastIndex] [true,
    2] > [re.test(''##-#''), re.lastIndex] [true, 4] > [re.test(''##-#''), re.lastIndex]
    [false, 0]  [PRE78]js > const re = /#/y; re.lastIndex = 1; > [re.test(''##-#''),
    re.lastIndex] [true, 2] > [re.test(''##-#''), re.lastIndex] [false, 0]  [PRE79]js
    let matchObj; // Infinite loop while (matchObj = /a+/g.exec(''bbbaabaaa'')) {  console.log(matchObj[0]);
    }  [PRE80]js function collectMatches(regExp, str) {  const matches = [];  let
    matchObj;  // Infinite loop  while (matchObj = regExp.exec(str)) {  matches.push(matchObj[0]);  }  return
    matches; } collectMatches(/a+/, ''bbbaabaaa''); // Missing: flag /g  [PRE81]js
    > const regExp = /^X/g; > [regExp.test(''Xa''), regExp.lastIndex] [ true, 1 ]
    > [regExp.test(''Xa''), regExp.lastIndex] [ false, 0 ] > [regExp.test(''Xa''),
    regExp.lastIndex] [ true, 1 ]  [PRE82]js > const regExp = /^X/y; > regExp.test(''Xa'')
    true > regExp.test(''Xa'') false > regExp.test(''Xa'') true  [PRE83]js function
    countMatches(regExp, str) {  let count = 0;  while (regExp.test(str)) {  count++;  }  return
    count; }  `const myRegExp = /a/g;` `myRegExp.lastIndex = 4;` `assert.equal(`  `countMatches(myRegExp,
    ''babaa''), 1 // should be 3` `);`  [PRE84]js[PRE85]js[PRE86][PRE87] Here, `countMatches()`
    works even though we didn‚Äôt check or fix `.lastIndex`.    #### [46.16.4‚ÄÉUse case
    for `.lastIndex`: starting matching at a given index](#use-case-for-lastindex-starting-matching-at-a-given-index)    Apart
    from storing the current position when matching multiple times, `.lastIndex` can
    also be used to:    *   Match once at exactly a given position (via flag `/y`)
    *   Match once at a given position or later (via flag `/g`)    We‚Äôll look at examples
    next.    ##### [46.16.4.1‚ÄÉExample: Checking if a regular expression matches at
    a given index](#example-checking-if-a-regular-expression-matches-at-a-given-index)    Given
    that `.test()` is affected by `/y` and `.lastIndex`, we can use it to check if
    a regular expression `regExp` matches a string `str` at exactly a given `index`:    [PRE88]js    `regExp`
    is anchored to `.lastIndex` due to `/y`.    Note that we must not use the assertion
    `^` which would anchor `regExp` to the beginning of the input string.    #####
    [46.16.4.2‚ÄÉExample: Finding the location of a match, starting at a given index](#example-finding-the-location-of-a-match-starting-at-a-given-index)    `.search()`
    lets us find the location where a regular expression matches:    [PRE89]js    Alas,
    we can‚Äôt change where `.search()` starts looking for matches. As a workaround,
    we can use `.exec()` for searching:    [PRE90]js   [PRE91] ##### [46.16.4.3‚ÄÉExample:
    Replacing an occurrence at a given index](#example-replacing-an-occurrence-at-a-given-index)    When
    used without `/g` and with `/y`, `.replace()` makes one replacement ‚Äì if there
    is a match at `.lastIndex`:    [PRE92]    #### [46.16.5‚ÄÉThe downsides and an upside
    of `.lastIndex`](#regexp-lastindex-upsides-downsides)    The regular expression
    property `.lastIndex` has two significant downsides:    *   It makes regular expressions
    stateful:     *   We now have to be mindful of the states of regular expressions
    and how we share them.     *   For many use cases, we can‚Äôt make them immutable
    via freezing, either. *   Support for `.lastIndex` is inconsistent among regular
    expression operations.    On the upside, `.lastIndex` also gives us additional
    useful functionality: We can dictate where matching should begin (for some operations).
    Ideally, such functionality would be provided via an assertion such as `\G` (vs.
    a flag `/y`) and an index as an argument for various regular-expression-related
    methods (vs. a regular expression property `.lastIndex`). But it‚Äôs better than
    not having it at all.    ### [46.17‚ÄÉ`RegExp.escape()`: escaping text so that it
    can be used inside a regular expression ^(ES2025)](#RegExp.escape)    For a string
    `text`, `RegExp.escape(text)` creates a regular expression pattern that matches
    `text`.    Characters that have special meaning in regular expressions can‚Äôt be
    used verbatim and have to be escaped:    [PRE93]    Note that we see each regular
    expression backslash twice: One of them is the actual backslash, the other one
    escapes it inside the string literal:    [PRE94]    Characters that have no special
    meaning don‚Äôt have to be escaped:    [PRE95]    #### [46.17.1‚ÄÉUse case for `RegExp.escape()`:
    replacing all occurrences of a text](#use-case-for-regexpescape-replacing-all-occurrences-of-a-text)    The
    classic use case for escaping was searching and replacing text:    [PRE96]    However,
    since ES2021, we have [`.replaceAll()`](#String.prototype.replaceAll):    [PRE97]    ####
    [46.17.2‚ÄÉUse case for `RegExp.escape()`: part of a regular expression must match
    a given text](#use-case-for-regexpescape-part-of-a-regular-expression-must-match-a-given-text)    The
    following code removes all occurrences of `text` inside `str` that are not quoted:    [PRE98]    The
    same approach can also be used to find or count unquoted text.    ![Icon ‚Äúexercise‚Äù](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png)‚ÄÇ**Exercise:
    Searching for text that contains a wildcard**    ‚úÖ `exercises/regexps/includes-with-elision_test.mjs`    ###
    [46.18‚ÄÉMatching everything or nothing](#matching-everything-or-nothing)    Sometimes,
    we may need a regular expression that matches everything or nothing ‚Äì for example,
    as a default value.    *   Match everything: `/(?:)/`                    The empty
    group `()` matches everything. We make it non-capturing (via `?:`), to avoid unnecessary
    work.                    [PRE99]           *   Match nothing: `/.^/`                    `^`
    only matches at the beginning of a string. The dot moves matching beyond the first
    character and now `^` doesn‚Äôt match anymore.                    [PRE100]              Regular
    expression literals can‚Äôt be empty because `//` starts a single-line comment.
    Therefore, the first of the previous two regular expressions is used in this case:    [PRE101]    ###
    [46.19‚ÄÉTips for making regular expressions easier to use](#tips-for-making-regular-expressions-easier-to-use)    In
    this section, we explore ways in which we can make regular expressions easier
    to use. We‚Äôll use the following regular expression as an example:    [PRE102]    Right
    now, it is still fairly cryptic. It will be much easier to understand once we
    get to ‚Äúinsignificant whitespace‚Äù.    #### [46.19.1‚ÄÉTip: Use flag `/v`](#tip-use-flag-v)    If
    we add flag `/v` to our regular expression, we get fewer quirks and more features:    [PRE103]    `/v`
    doesn‚Äôt change anything in this particular case, but it helps us if we add grapheme
    clusters with more than one code point or if we want features such as set operations
    in character classes.    #### [46.19.2‚ÄÉTip: order flags alphabetically](#tip-order-flags-alphabetically)    If
    there is more than one flag, we should [order the flags alphabetically](#order-of-regexp-flags)
    ‚Äì¬†e.g.:    [PRE104]    That makes ordering consistent and is also how JavaScript
    displays regular expressions:    [PRE105]    #### [46.19.3‚ÄÉTip: Use named capture
    groups](#tip-use-named-capture-groups)    Our regular expression contains two
    positional capture groups. If we name them, they describe their purposes and we
    need less external documentation:    [PRE106]    #### [46.19.4‚ÄÉTip: insignificant
    whitespace and line comments via `#`](#tip-insignificant-whitespace-and-line-comments-via-)    So
    far, the regular expression is still fairly hard to read. We can change that by
    adding spaces and line breaks. Since regular expression literals don‚Äôt allow us
    to do that, we use the library [Regex+](https://github.com/slevithan/regex) which
    provides us with the template tag `regex`:    [PRE107]   [PRE108][PRE109]``js[PRE110]
    `` const TAG = regex` ``  `(?<openingTag>`  `\[`  `\x20*`  `${NAME}`  `${ARGS}`  `\x20*`  `\]`  `)`  `|`  `(?<singletonTag>`  `\[`  `\x20*`  `${NAME}`  `${ARGS}`  `\x20*`  `/
    \]`  `)` `` `; ``  [PRE111] [PRE112]   [PRE113][PRE114]js[PRE115]  [PRE116]` *   `String.prototype.replace(searchValue,
    replaceValue)`     ES3 | `/y` honors and updates `.lastIndex` | `/g /gy` ignore
    and reset `.lastIndex`                    For more information on this method,
    see [its section](#String.prototype.replace) earlier in this chapter.               *   (1
    of 2) `searchValue` is string or RegExp without `/g`.                                    [PRE117]                                    Works
    similarly to `.replaceAll()`, but only replaces the first occurrence:                                    [PRE118]                       *   (1
    of 2) `searchValue` is RegExp with `/g`.                                    [PRE119]                                    Works
    exactly like `.replaceAll()`:                                    [PRE120]                  *   `String.prototype.replaceAll(searchValue,
    replaceValue)`     ES2021 | `/g /gy` ignore and reset `.lastIndex`               *   (1
    of 2) `replaceValue` is a string.                                    [PRE121]                                    Replaces
    all matches of `searchValue` with `replaceValue`. If `searchValue` is a regular
    expression without flag `/g`, a `TypeError` is thrown.                                    [PRE122]                                    Special
    characters in `replaceValue` are:                           *   `$$`: becomes
    `$`         *   `$n`: becomes the capture of numbered group `n` (alas, `$0` stands
    for the string `''$0''`, it does not refer to the complete match)         *   `$&`:
    becomes the complete match         *   `` $` ``: becomes everything before the
    match         *   `$''`: becomes everything after the match         *   `$<name>`
    becomes the capture of named group `name`     *   (2 of 2) `replaceValue` is a
    function.                                    [PRE123]                                    If
    the second parameter is a function, occurrences are replaced with the strings
    it returns. Its parameters `args` are:                           *   `matched:
    string`. The complete match         *   `g1: string|undefined`. The capture of
    numbered group 1         *   `g2: string|undefined`. The capture of numbered group
    2         *   (Etc.)         *   `offset: number`. Where was the match found in
    the input string?         *   `input: string`. The whole input string                  [PRE124]                                    [Named
    capture groups](#named-capture-groups) (ES2018) are supported, too. If there are
    any, an argument is added at the end with an object whose properties contain the
    captures:                                    [PRE125] [PRE126]``    [PRE127] [PRE128]`js
    [PRE129]js`` [PRE130]js[PRE131][PRE132][PRE133][PRE134]js[PRE135]js` [PRE136]`js``
    [PRE137]`js[PRE138][PRE139][PRE140] [PRE141][PRE142][PRE143][PRE144][PRE145]``
    [PRE146][PRE147][PRE148] [PRE149]`js[PRE150]js[PRE151]js[PRE152]js[PRE153]js[PRE154]js`
    [PRE155]`js[PRE156]js[PRE157]js[PRE158][PRE159][PRE160][PRE161]`````'
  prefs: []
  type: TYPE_NORMAL
