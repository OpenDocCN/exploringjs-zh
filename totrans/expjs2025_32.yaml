- en: 27 Callable values
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_callables.html](https://exploringjs.com/js/book/ch_callables.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[27.1 Kinds of functions](#kinds-of-functions)'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.2 Ordinary functions](#ordinary-functions)'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.2.1 Named function expressions (advanced)](#named-function-expressions)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.2.2 Terminology: function definitions and function expressions](#terminology-function-definitions-and-function-expressions)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.2.3 Parts of a function declaration](#parts-of-a-function-declaration)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.2.4 Roles played by ordinary functions](#roles-of-ordinary-functions)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.2.5 Terminology: entity vs. syntax vs. role (advanced)](#terminology-entity-vs-syntax-vs-role-advanced)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.3 Specialized functions ^(ES6)](#specialized-functions)'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.3.1 Specialized functions are still functions](#specialized-functions-are-still-functions)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.3.2 Arrow functions](#arrow-functions)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.3.3 The special variable `this` in methods, ordinary functions and arrow
    functions](#this-in-callables)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.3.4 Recommendation: prefer specialized functions over ordinary functions](#prefer-specialized-functions)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.4 Summary: kinds of callable values](#summary-kinds-of-callable-values)'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.5 Returning values from functions and methods](#returning-values-from-functions-and-methods)'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.6 Parameter handling](#parameter-handling)'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.6.1 Terminology: parameters vs. arguments](#terminology-parameters-vs-arguments)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.6.2 Terminology: callback](#callback-function)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.6.3 Too many or not enough arguments](#too-many-or-not-enough-arguments)'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.6.4 Parameter default values ^(ES6)](#parameter-default-values)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.6.5 Rest parameters ^(ES6)](#rest-parameters)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.6.6 Named parameters](#named-parameters)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.6.7 Simulating named parameters ^(ES6)](#simulating-named-parameters)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.6.8 Spreading (`...`) into function calls ^(ES6)](#spread-arguments)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.7 Methods of functions: `.call()`, `.apply()`, `.bind()`](#methods-of-functions)'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.7.1 The function method `.call()`](#Function.prototype.call)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.7.2 The function method `.apply()`](#Function.prototype.apply)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.7.3 The function method `.bind()`](#Function.prototype.bind)'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this chapter, we look at JavaScript values that can be invoked: functions,
    methods, and classes.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[27.1 Kinds of functions](#kinds-of-functions)'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript has two categories of functions:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'An *ordinary function* can play several roles:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real function
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Method
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor function
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A *specialized function* can only play one of those roles – for example:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An *arrow function* can only be a real function.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A *method* can only be a method.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A *class* can only be a constructor function.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Specialized functions were added to the language in ECMAScript 6.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Read on to find out what all of those things mean.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[27.2 Ordinary functions](#ordinary-functions)'
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code shows two ways of doing (roughly) the same thing: creating
    an ordinary function.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inside a scope, function declarations are activated early (see [“Declarations:
    scope and activation” (§13.8)](ch_variables-assignment.html#declarations-scope-activation))
    and can be called before they are declared. That is occasionally useful.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个作用域内，函数声明会提前激活（参见“声明：作用域和激活”§13.8），可以在声明之前调用。这偶尔是有用的。
- en: Variable declarations, such as the one for `ordinary2`, are not activated early.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 变量声明，如 `ordinary2` 的声明，不会提前激活。
- en: '[27.2.1 Named function expressions (advanced)](#named-function-expressions)'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.2.1 命名函数表达式（高级）](#named-function-expressions)'
- en: 'So far, we have only seen anonymous function expressions – which don’t have
    names:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了匿名函数表达式——它们没有名字：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'But there are also *named function expressions*:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但也存在**命名函数表达式**：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`myName` is only accessible inside the body of the function. The function can
    use it to refer to itself (for self-recursion, etc.) – independently of which
    variable it is assigned to:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`myName` 只在函数体内可访问。函数可以使用它来引用自身（用于自递归等），而不论它被分配给哪个变量：'
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Even if they are not assigned to variables, named function expressions have
    names (line A):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它们没有被分配给变量，命名函数表达式也有名字（行 A）：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that functions created via function declarations or variable declarations
    always have names:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过函数声明或变量声明创建的函数总是有名字的：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: One benefit of functions having names is that those names show up in [error
    stack traces](ch_exception-handling.html#error-stack).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 函数有名字的一个好处是，这些名字会出现在[错误堆栈跟踪](ch_exception-handling.html#error-stack)中。
- en: '[27.2.2 Terminology: function definitions and function expressions](#terminology-function-definitions-and-function-expressions)'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.2.2 术语：函数定义和函数表达式](#terminology-function-definitions-and-function-expressions)'
- en: 'A *function definition* is syntax that creates functions:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数定义**是创建函数的语法：'
- en: A function declaration (a statement)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数声明（一个语句）
- en: A function expression
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数表达式
- en: 'Function declarations always produce ordinary functions. Function expressions
    produce either ordinary functions or specialized functions:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明总是产生普通函数。函数表达式可以产生普通函数或特殊函数：
- en: 'Ordinary function expressions (which we have already encountered):'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通函数表达式（我们之前已经遇到过）：
- en: Anonymous function expressions
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名函数表达式
- en: Named function expressions
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名函数表达式
- en: 'Specialized function expressions (which we’ll look at later):'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊函数表达式（我们稍后会看到）：
- en: Arrow functions (which are always expressions)
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数（它们总是表达式）
- en: While function declarations are still popular in JavaScript, function expressions
    are almost always arrow functions in modern code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然函数声明在 JavaScript 中仍然很受欢迎，但现代代码中函数表达式几乎总是箭头函数。
- en: '[27.2.3 Parts of a function declaration](#parts-of-a-function-declaration)'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.2.3 函数声明的各个部分](#parts-of-a-function-declaration)'
- en: Let’s examine the parts of a function declaration via the following example.
    Most of the terms also apply to function expressions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来检查函数声明的各个部分。大多数术语也适用于函数表达式。
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`add` is the *name* of the function declaration.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add` 是函数声明的**名字**。'
- en: '`add(x, y)` is the *head* of the function declaration.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add(x, y)` 是函数声明的**头部**。'
- en: '`x` and `y` are the *parameters*.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x` 和 `y` 是**参数**。'
- en: The curly braces (`{` and `}`) and everything between them are the *body* of
    the function declaration.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大括号（`{` 和 `}`）及其之间的一切都是函数声明的**主体**。
- en: The `return` statement explicitly returns a value from the function.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return` 语句明确地从函数中返回一个值。'
- en: '[27.2.3.1 Trailing commas in parameter lists ^(ES2017)](#trailing-commas-parameters)'
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[27.2.3.1 参数列表中的尾随逗号（ES2017）](#trailing-commas-parameters)'
- en: 'JavaScript has always allowed and ignored trailing commas in Array literals.
    Since ES5, they are also allowed in object literals. Since ES2017, we can add
    trailing commas to parameter lists (declarations and invocations):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 一直允许并忽略数组字面量中的尾随逗号。自 ES5 以来，它们也被允许在对象字面量中使用。自 ES2017 以来，我们可以在参数列表（声明和调用）中添加尾随逗号。
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[27.2.4 Roles played by ordinary functions](#roles-of-ordinary-functions)'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.2.4 普通函数所扮演的角色](#roles-of-ordinary-functions)'
- en: 'Consider the following function declaration from the previous section:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下来自上一节的函数声明：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This function declaration creates an ordinary function whose name is `add`.
    As an ordinary function, `add()` can play three roles:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数声明创建了一个名为 `add` 的普通函数。作为一个普通函数，`add()` 可以扮演三个角色：
- en: 'Real function: invoked via a function call.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际函数：通过函数调用执行。
- en: '[PRE9]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Method: stored in a property, invoked via a method call.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法：存储在属性中，通过方法调用执行。
- en: '[PRE10]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In line A, `obj` is called the *receiver* of the method call.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在行A中，`obj` 被称为方法调用的 *接收者*。
- en: 'Constructor function: invoked via `new`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数：通过 `new` 调用。
- en: '[PRE11]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As an aside, the names of constructor functions (incl. classes) normally start
    with capital letters.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为旁白，构造函数（包括类）的名称通常以大写字母开头。
- en: '[27.2.5 Terminology: entity vs. syntax vs. role (advanced)](#terminology-entity-vs-syntax-vs-role-advanced)'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.2.5 术语：实体 vs. 语法 vs. 角色（高级）](#terminology-entity-vs-syntax-vs-role-advanced)'
- en: 'The distinction between the concepts *syntax*, *entity*, and *role* is subtle
    and often doesn’t matter. But it’s still useful to be aware of it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*语法*、*实体* 和 *角色* 之间的区别很微妙，通常并不重要。但了解这一点仍然很有用：'
- en: An *entity* is a JavaScript feature as it “lives” in RAM. An ordinary function
    is an entity.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实体* 是一种JavaScript特性，因为它“存在于”RAM中。普通函数是一个实体。'
- en: 'Entities include: ordinary functions, arrow functions, methods, and classes.'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体包括：普通函数、箭头函数、方法和类。
- en: '*Syntax* is the code that we use to create entities. Function declarations
    and anonymous function expressions are syntax. They both create entities that
    are called ordinary functions.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*语法* 是我们用来创建实体的代码。函数声明和匿名函数表达式是语法。它们都创建被称为普通函数的实体。'
- en: 'Syntax includes: function declarations and anonymous function expressions.
    The syntax that produces arrow functions is also called *arrow functions*. The
    same is true for methods and classes.'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法包括：函数声明和匿名函数表达式。产生箭头函数的语法也称为 *箭头函数*。对于方法和类也是如此。
- en: A *role* describes how we use entities. The entity *ordinary function* can play
    the role *real function*, or the role *method*, or the role *class*. The entity
    *arrow function* can also play the role *real function*.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*角色* 描述了如何使用实体。实体 *普通函数* 可以扮演 *真实函数* 的角色，或者 *方法* 的角色，或者 *类* 的角色。实体 *箭头函数* 也可以扮演
    *真实函数* 的角色。'
- en: 'The roles of functions are: real function, method, and constructor function.'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的角色包括：真实函数、方法和构造函数。
- en: Many other programming languages only have a single entity that plays the role
    *real function*. Then they can use the name *function* for both role and entity.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他编程语言只有一个实体扮演 *真实函数* 的角色。然后它们可以使用 *函数* 这个名字来指代这个角色和实体。
- en: '[27.3 Specialized functions ^(ES6)](#specialized-functions)'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[27.3 特殊函数 (ES6)](#specialized-functions)'
- en: 'Specialized functions are single-purpose versions of ordinary functions. Each
    one of them specializes in a single role:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊函数是普通函数的单用途版本。每个都专注于单一角色：
- en: 'The purpose of an *arrow function* is to be a real function:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*箭头函数* 的目的是成为一个真实函数：'
- en: '[PRE12]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The purpose of a *method* is to be a method:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*方法* 的目的是成为一个方法：'
- en: '[PRE13]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The purpose of a *class* is to be a constructor function:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类* 的目的是成为一个构造函数：'
- en: '[PRE14]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Apart from nicer syntax, each kind of specialized function also supports new
    features, making them better at their jobs than ordinary functions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更简洁的语法外，每种特殊函数也支持新特性，使它们在各自的工作中比普通函数表现得更好。
- en: Arrow functions are explained soon.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数将在后面解释。
- en: Methods are explained [in the chapter on objects](ch_objects.html#methods-and-this).
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法在 [对象章节](ch_objects.html#methods-and-this) 中进行解释。
- en: Classes are explained [in the chapter on classes](ch_classes.html#classes).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类在 [类章节](ch_classes.html#classes) 中进行解释。
- en: '[Table 27.1](#tbl:capabilities-of-functions) lists the capabilities of ordinary
    and specialized functions.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[表27.1](#tbl:capabilities-of-functions) 列出了普通函数和特殊函数的能力。'
- en: '|  | Function call | Method call | Constructor call |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|  | 函数调用 | 方法调用 | 构造函数调用 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Ordinary function | (`this === undefined`) | ✔ | ✔ |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 普通函数 | (`this === undefined`) | ✔ | ✔ |'
- en: '| Arrow function | ✔ | (lexical `this`) | ✘ |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 箭头函数 | ✔ | (词法 `this`) | ✘ |'
- en: '| Method | (`this === undefined`) | ✔ | ✘ |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | (`this === undefined`) | ✔ | ✘ |'
- en: '| Class | ✘ | ✘ | ✔ |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 类 | ✘ | ✘ | ✔ |'
- en: 'Table 27.1: Capabilities of four kinds of functions. If a cell value is in
    parentheses, that implies some kind of limitation. The special variable `this`
    is explained in [“The special variable `this` in methods, ordinary functions and
    arrow functions” (§27.3.3)](#this-in-callables).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 表27.1：四种函数的能力。如果单元格值在括号中，则表示某种限制。特殊变量 `this` 在 [“方法、普通函数和箭头函数中的特殊变量 `this`”（§27.3.3）](#this-in-callables)
    中进行解释。
- en: '[27.3.1 Specialized functions are still functions](#specialized-functions-are-still-functions)'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.3.1 特殊函数仍然是函数](#specialized-functions-are-still-functions)'
- en: 'It’s important to note that arrow functions, methods, and classes are still
    categorized as functions:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，箭头函数、方法和类仍然被归类为函数：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[27.3.2 Arrow functions](#arrow-functions)'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.3.2 箭头函数](#arrow-functions)'
- en: 'Arrow functions were added to JavaScript for two reasons:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数被添加到 JavaScript 中有两个原因：
- en: To provide a more concise way for creating functions.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了提供一个更简洁的创建函数的方法。
- en: 'They work better as real functions inside methods: Methods can refer to the
    object that received a method call via the special variable `this`. Arrow functions
    can access the `this` of a surrounding method, ordinary functions can’t (because
    they have their own `this`).'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们在方法内部作为真正的函数表现更好：方法可以通过特殊变量 `this` 来引用接收方法调用的对象。箭头函数可以访问周围方法的 `this`，普通函数则不能（因为它们有自己的
    `this`）。
- en: We’ll first examine the syntax of arrow functions and then how `this` works
    in various functions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先检查箭头函数的语法，然后讨论 `this` 在各种函数中的工作方式。
- en: '[27.3.2.1 The syntax of arrow functions](#the-syntax-of-arrow-functions)'
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[27.3.2.1 箭头函数的语法](#the-syntax-of-arrow-functions)'
- en: 'Let’s review the syntax of an anonymous function expression:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下匿名函数表达式的语法：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The (roughly) equivalent arrow function looks as follows. Arrow functions are
    expressions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数的（大致）等效形式如下。箭头函数是表达式。
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, the body of the arrow function is a block. But it can also be an expression.
    The following arrow function works exactly like the previous one.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，箭头函数的主体是一个代码块。但它也可以是一个表达式。下面的箭头函数与上一个完全相同。
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If an arrow function has only a single parameter and that parameter is an identifier
    (not [a destructuring pattern](ch_destructuring.html#ch_destructuring)) then we
    can omit the parentheses around the parameter:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个箭头函数只有一个参数，并且这个参数是一个标识符（不是 [解构模式](ch_destructuring.html#ch_destructuring)），那么我们可以省略参数周围的括号：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'That is convenient when passing arrow functions as parameters to other functions
    or methods:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当将箭头函数作为参数传递给其他函数或方法时，这很方便：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This previous example demonstrates one benefit of arrow functions – conciseness.
    If we perform the same task with a function expression, our code is more verbose:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个先前的例子展示了箭头函数的一个优点 – 简洁性。如果我们用函数表达式执行相同的任务，我们的代码会更冗长：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[27.3.2.2 Syntax pitfall: returning an object literal from an arrow function](#returning-object-literal-from-arrow-function)'
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[27.3.2.2 箭头函数返回对象字面量的语法陷阱](#returning-object-literal-from-arrow-function)'
- en: 'If we want the expression body of an arrow function to be an object literal,
    we must put the literal in parentheses:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让箭头函数的表达式主体是一个对象字面量，我们必须在字面量周围加上括号：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we don’t, JavaScript thinks, the arrow function has a block body (that doesn’t
    return anything):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不这样做，JavaScript 会认为箭头函数有一个代码块主体（不返回任何内容）：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`{a: 1}` is interpreted as a block with [the label `a:`](ch_control-flow.html#labels)
    and the expression statement `1`. Without an explicit `return` statement, the
    block body returns `undefined`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`{a: 1}` 被解释为一个带有 [标签 `a:`](ch_control-flow.html#labels) 的代码块和表达式语句 `1`。如果没有显式的
    `return` 语句，代码块主体返回 `undefined`。'
- en: 'This pitfall is caused by [syntactic ambiguity](ch_syntax.html#ambiguous-syntax):
    object literals and code blocks have the same syntax. We use the parentheses to
    tell JavaScript that the body is an expression (an object literal) and not a statement
    (a block).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个陷阱是由 [语法歧义](ch_syntax.html#ambiguous-syntax) 引起的：对象字面量和代码块有相同的语法。我们使用括号来告诉
    JavaScript，主体是一个表达式（对象字面量），而不是一个语句（代码块）。
- en: '[27.3.3 The special variable `this` in methods, ordinary functions and arrow
    functions](#this-in-callables)'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.3.3 方法、普通函数和箭头函数中的特殊变量 `this`](#this-in-callables)'
- en: '![Icon “reading”](../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png) **The special
    variable `this` is an object-oriented feature**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![“阅读”图标](../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png) **特殊变量 `this` 是面向对象的一个特性**'
- en: We are taking a quick look at the special variable `this` here, in order to
    understand why arrow functions are better real functions than ordinary functions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里快速查看特殊变量 `this`，以便了解为什么箭头函数比普通函数更像是真正的函数。
- en: But this feature only matters in object-oriented programming and is covered
    in more depth in [“Methods and the special variable `this`” (§30.6)](ch_objects.html#methods-and-this).
    Therefore, don’t worry if you don’t fully understand it yet.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个特性只在面向对象编程中才有意义，在“方法和特殊变量 `this`”（§30.6）中有更深入的介绍。因此，如果你现在还没有完全理解它，请不要担心。
- en: 'Inside methods, the special variable `this` lets us access the *receiver* –
    the object which received the method call:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法内部，特殊变量 `this` 允许我们访问 *接收者* – 被方法调用的对象：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Ordinary functions can be methods and therefore also have the implicit parameter
    `this`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 普通函数可以是方法，因此也具有隐式参数`this`：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`this` is even an implicit parameter when we use an ordinary function as a
    real function. Then its value is `undefined` (if [strict mode](ch_syntax.html#strict-mode)
    is active, which it almost always is):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 即使当我们使用普通函数作为实函数时，`this`也是一个隐式参数。然后其值是`undefined`（如果[严格模式](ch_syntax.html#strict-mode)处于活动状态，这几乎总是如此）：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'That means that an ordinary function, used as a real function, can’t access
    the `this` of a surrounding method (line A). In contrast, arrow functions don’t
    have `this` as an implicit parameter. They treat it like any other variable and
    can therefore access the `this` of a surrounding method (line B):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一个作为实函数使用的普通函数无法访问周围方法的`this`（行A）。相比之下，箭头函数没有`this`作为隐式参数。它们将其视为任何其他变量，因此可以访问周围方法的`this`（行B）：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this code, we can observe two ways of handling `this`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们可以观察到两种处理`this`的方式：
- en: 'Dynamic `this`: In line A, we try to access the `this` of `.someMethod()` from
    an ordinary function. There, it is *shadowed* by the function’s own `this`, which
    is `undefined` (as filled in by the function call). Given that ordinary functions
    receive their `this` via (dynamic) function or method calls, their `this` is called
    *dynamic*.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态`this`：在行A中，我们尝试从一个普通函数中访问`.someMethod()`的`this`。在那里，它被函数自己的`this`所掩盖，该`this`是`undefined`（由函数调用填充）。鉴于普通函数通过（动态）函数或方法调用接收它们的`this`，它们的`this`被称为*动态*。
- en: 'Lexical `this`: In line B, we again try to access the `this` of `.someMethod()`.
    This time, we succeed because the arrow function does not have its own `this`.
    `this` is resolved *lexically*, just like any other variable. That’s why the `this`
    of arrow functions is called *lexical*.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 词法`this`：在行B中，我们再次尝试访问`.someMethod()`的`this`。这次我们成功了，因为箭头函数没有自己的`this`。`this`是按词法解析的，就像任何其他变量一样。这就是为什么箭头函数的`this`被称为*词法*。
- en: '[27.3.4 Recommendation: prefer specialized functions over ordinary functions](#prefer-specialized-functions)'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.3.4 推荐方案：优先使用专用函数而非普通函数](#prefer-specialized-functions)'
- en: Normally, we should prefer specialized functions over ordinary functions, especially
    classes and methods.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们应该优先使用专用函数而非普通函数，尤其是类和方法。
- en: 'When it comes to real functions, the choice between an arrow function and an
    ordinary function is less clear-cut, though:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到真实函数时，箭头函数和普通函数之间的选择并不那么明确：
- en: 'For anonymous inline function expressions, arrow functions are clear winners,
    due to their compact syntax and them not having `this` as an implicit parameter:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于匿名内联函数表达式，箭头函数由于其紧凑的语法和没有`this`作为隐式参数，是明显的赢家：
- en: '[PRE28]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For stand-alone named function declarations, arrow functions still benefit
    from lexical `this`. But function declarations (which produce ordinary functions)
    have nice syntax and early activation is also occasionally useful (see [“Declarations:
    scope and activation” (§13.8)](ch_variables-assignment.html#declarations-scope-activation)).
    If `this` doesn’t appear in the body of an ordinary function, there is no downside
    to using it as a real function. The static checking tool ESLint can warn us during
    development when we do this wrong via [a built-in rule](https://eslint.org/docs/rules/no-invalid-this).'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于独立的命名函数声明，箭头函数仍然得益于词法`this`。但函数声明（产生普通函数）具有很好的语法，早期激活偶尔也很有用（参见[“声明：作用域和激活”（§13.8）](ch_variables-assignment.html#declarations-scope-activation))。如果`this`在普通函数体中未出现，使用它作为实函数没有缺点。静态检查工具ESLint可以在开发过程中通过[内置规则](https://eslint.org/docs/rules/no-invalid-this)警告我们这种错误的使用。
- en: '[PRE29]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[27.4 Summary: kinds of callable values](#summary-kinds-of-callable-values)'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[27.4 摘要：可调用值的种类](#summary-kinds-of-callable-values)'
- en: '![Icon “reading”](../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png) **This section
    refers to upcoming content**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“阅读”](../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png) **本节涉及即将到来的内容**'
- en: This section mainly serves as a reference for the current and upcoming chapters.
    Don’t worry if you don’t understand everything.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 本节主要作为当前和即将到来的章节的参考。如果你没有完全理解，请不要担心。
- en: 'So far, all (real) functions and methods, that we have seen, were:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所看到的所有（真实）函数和方法都是：
- en: Single-result
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一结果
- en: Synchronous
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步
- en: 'Later chapters will cover other modes of programming:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 后续章节将涵盖其他编程模式：
- en: '*Iteration* treats objects as containers of data (so-called *iterables*) and
    provides a standardized way for retrieving what is inside them. If a function
    or a method returns an iterable, it returns multiple values.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*迭代*将对象视为数据容器（所谓*可迭代*）并提供了一种标准化的方式来检索其中的内容。如果一个函数或方法返回一个可迭代对象，它将返回多个值。'
- en: '*Asynchronous programming* deals with handling a long-running computation.
    We are notified when the computation is finished and can do something else in
    between. The standard pattern for asynchronously delivering single results is
    called *Promise*.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异步编程*处理长时间运行的计算。当计算完成时，我们会收到通知，并在其间做其他事情。异步传递单个结果的标准模式称为*Promise*。'
- en: These modes can be combined – for example, there are synchronous iterables and
    asynchronous iterables.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式可以组合——例如，存在同步可迭代和异步可迭代。
- en: 'Several new kinds of functions and methods help with some of the mode combinations:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 几种新的函数和方法有助于处理一些模式组合：
- en: '*Async functions* help implement functions that return Promises. There are
    also *async methods*.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异步函数*帮助实现返回Promise的函数。也有*异步方法*。'
- en: '*Synchronous generator functions* help implement functions that return synchronous
    iterables. There are also *synchronous generator methods*.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*同步生成器函数*帮助实现返回同步可迭代的函数。也有*同步生成器方法*。'
- en: '*Asynchronous generator functions* help implement functions that return asynchronous
    iterables. There are also *asynchronous generator methods*.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异步生成器函数*帮助实现返回异步可迭代的函数。也有*异步生成器方法*。'
- en: 'That leaves us with 4 kinds (2 × 2) of functions and methods:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这就留下了4种（2×2）函数和方法：
- en: Synchronous vs. asynchronous
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步与异步
- en: Generator vs. single-result
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器与单结果
- en: '[Table 27.2](#tbl:syntax-functions-methods) gives an overview of the syntax
    for creating these 4 kinds of functions and methods.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[表27.2](#tbl:syntax-functions-methods)概述了创建这些4种函数和方法的语法。'
- en: '|  |  | **Result** | **#** |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '|  |  | **结果** | **#** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **Sync function** | **Sync method** |  |  |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| **同步函数** | **同步方法** |  |  |'
- en: '| `function f() {}` | `{ m() {} }` | value | 1 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `function f() {}` | `{ m() {} }` | 值 | 1 |'
- en: '| `f = function () {}` |  |  |  |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `f = function () {}` |  |  |  |'
- en: '| `f = () => {}` |  |  |  |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `f = () => {}` |  |  |  |'
- en: '| **Sync generator function** | **Sync gen. method** |  |  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| **同步生成器函数** | **同步生成器方法** |  |  |'
- en: '| `function* f() {}` | `{ * m() {} }` | iterable | 0+ |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `function* f() {}` | `{ * m() {} }` | 可迭代 | 0+ |'
- en: '| `f = function* () {}` |  |  |  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `f = function* () {}` |  |  |  |'
- en: '| **Async function** | **Async method** |  |  |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| **异步函数** | **异步方法** |  |  |'
- en: '| `async function f() {}` | `{ async m() {} }` | Promise | 1 |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `async function f() {}` | `{ async m() {} }` | Promise | 1 |'
- en: '| `f = async function () {}` |  |  |  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `f = async function () {}` |  |  |  |'
- en: '| `f = async () => {}` |  |  |  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `f = async () => {}` |  |  |  |'
- en: '| **Async generator function** | **Async gen. method** |  |  |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| **异步生成器函数** | **异步生成器方法** |  |  |'
- en: '| `async function* f() {}` | `{ async * m() {} }` | async iterable | 0+ |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `async function* f() {}` | `{ async * m() {} }` | 异步可迭代 | 0+ |'
- en: '| `f = async function* () {}` |  |  |  |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `f = async function* () {}` |  |  |  |'
- en: 'Table 27.2: Syntax for creating functions and methods. The last column specifies
    how many values are produced by an entity.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 表27.2：创建函数和方法的语法。最后一列指定实体产生的值的数量。
- en: '[27.5 Returning values from functions and methods](#returning-values-from-functions-and-methods)'
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[27.5 函数和方法的返回值](#returning-values-from-functions-and-methods)'
- en: (Everything mentioned in this section applies to both functions and methods.)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: （本节中提到的所有内容都适用于函数和方法。）
- en: 'The `return` statement explicitly returns a value from a function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`语句明确地从函数中返回一个值：'
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Another example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子：
- en: '[PRE31]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If, at the end of a function, we haven’t returned anything explicitly, JavaScript
    returns `undefined` for us:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在函数的末尾我们没有明确返回任何内容，JavaScript会为我们返回`undefined`：
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[27.6 Parameter handling](#parameter-handling)'
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[27.6 参数处理](#parameter-handling)'
- en: Once again, I am only mentioning functions in this section, but everything also
    applies to methods.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，本节中我只提到函数，但所有内容也适用于方法。
- en: '[27.6.1 Terminology: parameters vs. arguments](#terminology-parameters-vs-arguments)'
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.6.1 术语：参数与参数](#terminology-parameters-vs-arguments)'
- en: 'The term *parameter* and the term *argument* basically mean the same thing.
    If we want to, we can make the following distinction:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*参数*和术语*参数*基本上意味着同一件事。如果我们愿意，我们可以做出以下区分：
- en: '*Parameters* are part of a function definition. They are also called *formal
    parameters* and *formal arguments*.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*参数*是函数定义的一部分。它们也被称为*形式参数*和*形式参数*。'
- en: '*Arguments* are part of a function call. They are also called *actual parameters*
    and *actual arguments*.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*参数*是函数调用的一部分。它们也被称为*实际参数*和*实际参数*。'
- en: '[27.6.2 Terminology: callback](#callback-function)'
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.6.2 术语：回调](#callback-function)'
- en: A *callback* or *callback function* is a function that is an argument of a function
    or method call.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*回调*或*回调函数*是函数或方法调用的参数。'
- en: 'The following is an example of a callback:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个回调示例：
- en: '[PRE33]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Output:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[27.6.3 Too many or not enough arguments](#too-many-or-not-enough-arguments)'
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.6.3 过多或不足的参数](#too-many-or-not-enough-arguments)'
- en: 'JavaScript does not complain if a function call provides a different number
    of arguments than expected by the function definition:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数调用提供的参数数量与函数定义期望的不同，JavaScript不会报错：
- en: Extra arguments are ignored.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的参数会被忽略。
- en: Missing parameters are set to `undefined`.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少的参数会被设置为`undefined`。
- en: 'For example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[27.6.4 Parameter default values ^(ES6)](#parameter-default-values)'
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.6.4 参数默认值（ES6）](#parameter-default-values)'
- en: 'Parameter default values specify the value to use if a parameter has not been
    provided – for example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 参数默认值指定了如果未提供参数应使用的值——例如：
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`undefined` also triggers the default value:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`undefined`也会触发默认值：'
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[27.6.5 Rest parameters ^(ES6)](#rest-parameters)'
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.6.5 剩余参数（ES6）](#rest-parameters)'
- en: 'A rest parameter is declared by prefixing an identifier with three dots (`...`).
    During a function or method call, it receives an Array with all remaining arguments.
    If there are no extra arguments at the end, it is an empty Array – for example:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余参数通过在标识符前加三个点（`...`）来声明。在函数或方法调用期间，它接收一个包含所有剩余参数的数组。如果没有额外的参数在末尾，它是一个空数组——例如：
- en: '[PRE38]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'There are two restrictions related to how we can use rest parameters:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们如何使用剩余参数相关的有两个限制：
- en: We cannot use more than one rest parameter per function definition.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能在函数定义中使用多个剩余参数。
- en: '[PRE39]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'A rest parameter must always come last. As a consequence, we can’t access the
    last parameter like this:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩余参数必须始终放在最后。因此，我们不能像这样访问最后一个参数：
- en: '[PRE40]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[27.6.5.1 Enforcing a certain number of arguments via a rest parameter](#enforcing-a-certain-number-of-arguments-via-a-rest-parameter)'
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[27.6.5.1 通过剩余参数强制指定一定数量的参数](#enforcing-a-certain-number-of-arguments-via-a-rest-parameter)'
- en: 'We can use a rest parameter to enforce a certain number of arguments. Take,
    for example, the following function:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用剩余参数来强制指定一定数量的参数。例如，以下是一个函数：
- en: '[PRE41]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is how we force callers to always provide two arguments:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们强制调用者始终提供两个参数的方式：
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In line A, we access the elements of `args` via [*destructuring*](ch_destructuring.html#ch_destructuring).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在行A中，我们通过[*解构赋值*](ch_destructuring.html#ch_destructuring)访问`args`的元素。
- en: '[27.6.6 Named parameters](#named-parameters)'
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.6.6 命名参数](#named-parameters)'
- en: 'When someone calls a function, the arguments provided by the caller are assigned
    to the parameters received by the callee. Two common ways of performing the mapping
    are:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人调用一个函数时，调用者提供的参数会被分配给接收者接收的参数。执行映射的两种常见方式是：
- en: 'Positional parameters: An argument is assigned to a parameter if they have
    the same position. A function call with only positional arguments looks as follows.'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 位置参数：如果一个参数与一个参数具有相同的位置，则将其分配给该参数。只有位置参数的函数调用看起来如下。
- en: '[PRE43]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Named parameters: An argument is assigned to a parameter if they have the same
    name. JavaScript doesn’t have named parameters, but we can simulate them. For
    example, this is a function call with only (simulated) named arguments:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名参数：如果一个参数与一个参数具有相同的名称，则将其分配给该参数。JavaScript没有命名参数，但我们可以模拟它们。例如，这是一个只有（模拟的）命名参数的函数调用：
- en: '[PRE44]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Named parameters have several benefits:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数有几个优点：
- en: 'They lead to more self-explanatory code because each argument has a descriptive
    label. Just compare the two versions of `selectEntries()`: with the second one,
    it is much easier to see what happens.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们导致代码更具自解释性，因为每个参数都有一个描述性的标签。只需比较`selectEntries()`的两个版本：在第二个版本中，更容易看到发生了什么。
- en: The order of the arguments doesn’t matter (as long as the names are correct).
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数的顺序无关紧要（只要名称正确）。
- en: 'Handling more than one optional parameter is more convenient: callers can easily
    provide any subset of all optional parameters and don’t have to be aware of the
    ones they omit (with positional parameters, we have to fill in preceding optional
    parameters, with `undefined`).'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理多个可选参数更方便：调用者可以轻松提供所有可选参数的任何子集，而无需了解他们省略了哪些（使用位置参数时，我们必须填写前面的可选参数，使用`undefined`）。
- en: '[27.6.7 Simulating named parameters ^(ES6)](#simulating-named-parameters)'
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.6.7 模拟命名参数 (ES6)](#simulating-named-parameters)'
- en: 'JavaScript doesn’t have real named parameters. The official way of simulating
    them is via object literals:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 没有真正的命名参数。官方模拟它们的方式是通过对象字面量：
- en: '[PRE45]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This function uses [*destructuring*](ch_destructuring.html#ch_destructuring)
    to access the properties of its single parameter. The pattern it uses is an abbreviation
    for the following pattern:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用[*解构赋值*](ch_destructuring.html#ch_destructuring)来访问其单个参数的属性。它使用的模式是以下模式的缩写：
- en: '[PRE46]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This destructuring pattern works for empty object literals:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解构模式适用于空对象字面量：
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'But it does not work if we call the function without any parameters:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们不带任何参数调用函数，则不起作用：
- en: '[PRE48]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can fix this by providing a default value for the whole pattern. This default
    value works the same as default values for simpler parameter definitions: if the
    parameter is missing, the default is used.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过为整个模式提供默认值来修复这个问题。这个默认值与更简单的参数定义中的默认值作用相同：如果参数缺失，则使用默认值。
- en: '[PRE49]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[27.6.8 Spreading (`...`) into function calls ^(ES6)](#spread-arguments)'
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.6.8 将展开 (`...`) 用于函数调用 (ES6)](#spread-arguments)'
- en: 'If we put three dots (`...`) in front of the argument of a function call, then
    we *spread* it. That means that the argument must be [an *iterable* object](ch_sync-iteration.html#ch_sync-iteration)
    and the iterated values all become arguments. In other words, a single argument
    is expanded into multiple arguments – for example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在函数调用参数前放置三个点 (`...`)，则我们 *展开* 它。这意味着该参数必须是[一个 *可迭代* 对象](ch_sync-iteration.html#ch_sync-iteration)并且迭代的值都成为参数。换句话说，单个参数被扩展成多个参数——例如：
- en: '[PRE50]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Output:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE51]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Spreading and rest parameters use the same syntax (`...`), but they serve opposite
    purposes:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 展开和剩余参数使用相同的语法 (`...`)，但它们服务于相反的目的：
- en: Rest parameters are used when defining functions or methods. They collect arguments
    into Arrays.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩余参数用于定义函数或方法时。它们将参数收集到数组中。
- en: Spread arguments are used when calling functions or methods. They turn iterable
    objects into arguments.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开参数用于调用函数或方法时。它们将可迭代对象转换为参数。
- en: '[27.6.8.1 Example: spreading into `Math.max()`](#example-spreading-into-mathmax)'
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[27.6.8.1 示例：将展开用于 `Math.max()`](#example-spreading-into-mathmax)'
- en: '`Math.max()` returns the largest one of its zero or more arguments. Alas, it
    can’t be used for Arrays, but spreading gives us a way out:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.max()` 返回其零个或多个参数中的最大值。然而，它不能用于数组，但展开操作为我们提供了一条出路：'
- en: '[PRE52]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[27.6.8.2 Example: spreading into `Array.prototype.push()`](#example-spreading-into-arrayprototypepush)'
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[27.6.8.2 示例：将展开用于 `Array.prototype.push()`](#example-spreading-into-arrayprototypepush)'
- en: 'Similarly, the Array method `.push()` destructively adds its zero or more parameters
    to the end of its Array. JavaScript has no method for destructively appending
    an Array to another one. Once again, we are saved by spreading:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，数组方法 `.push()` 会破坏性地将其零个或多个参数添加到数组的末尾。JavaScript 没有方法可以破坏性地将一个数组追加到另一个数组中。又一次，我们通过展开操作得以幸免：
- en: '[PRE53]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercises:
    Parameter handling**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“练习”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：参数处理**'
- en: 'Positional parameters: `exercises/callables/positional_parameters_test.mjs`'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置参数：`exercises/callables/positional_parameters_test.mjs`
- en: 'Named parameters: `exercises/callables/named_parameters_test.mjs`'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名参数：`exercises/callables/named_parameters_test.mjs`
- en: '[27.7 Methods of functions: `.call()`, `.apply()`, `.bind()`](#methods-of-functions)'
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[27.7 函数方法：`.call()`、`.apply()`、`.bind()`](#methods-of-functions)'
- en: 'Functions are objects and have methods. In this section, we look at three of
    those methods: `.call()`, `.apply()`, and `.bind()`.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是对象，并且具有方法。在本节中，我们将探讨其中三种方法：`.call()`、`.apply()` 和 `.bind()`。
- en: '[27.7.1 The function method `.call()`](#Function.prototype.call)'
  id: totrans-292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.7.1 函数方法 `.call()`](#Function.prototype.call)'
- en: 'Each function `someFunc` has the following method:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数 `someFunc` 都有以下方法：
- en: '[PRE54]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This method invocation is loosely equivalent to the following function call:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法调用大致等同于以下函数调用：
- en: '[PRE55]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'However, with `.call()`, we can also specify a value for [the implicit parameter
    `this`](#this-in-callables). In other words: `.call()` makes the implicit parameter
    `this` explicit.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 `.call()`，我们也可以为[隐式参数 `this`](#this-in-callables)指定一个值。换句话说：`.call()`
    使得隐式参数 `this` 明确化。
- en: 'The following code demonstrates the use of `.call()`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了 `.call()` 的使用：
- en: '[PRE56]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As we have seen before, if we function-call an ordinary function, its `this`
    is `undefined`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，如果我们对一个普通函数进行函数调用，其 `this` 是 `undefined`：
- en: '[PRE57]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Therefore, the previous function call is equivalent to:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的函数调用等同于：
- en: '[PRE58]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In arrow functions, the value for `this` provided via `.call()` (or other means)
    is ignored.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在箭头函数中，通过 `.call()`（或其他方式）提供的 `this` 值将被忽略。
- en: '[27.7.2 The function method `.apply()`](#Function.prototype.apply)'
  id: totrans-305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.7.2 函数方法 `.apply()`](#Function.prototype.apply)'
- en: 'Each function `someFunc` has the following method:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数 `someFunc` 都有以下方法：
- en: '[PRE59]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This method invocation is loosely equivalent to the following function call
    (which uses [spreading](#spread-arguments)):'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法调用大致等同于以下函数调用（使用了 [展开操作](#spread-arguments)）：
- en: '[PRE60]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: However, with `.apply()`, we can also specify a value for [the implicit parameter
    `this`](#this-in-callables).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 `.apply()`，我们还可以指定 [隐式参数 `this`](#this-in-callables) 的值。
- en: 'The following code demonstrates the use of `.apply()`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了 `.apply()` 的使用：
- en: '[PRE61]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[27.7.3 The function method `.bind()`](#Function.prototype.bind)'
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.7.3 函数方法 `.bind()`](#Function.prototype.bind)'
- en: '`.bind()` is another method of function objects. This method is invoked as
    follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`.bind()` 是函数对象的另一种方法。该方法如下调用：'
- en: '[PRE62]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`.bind()` returns a new function `boundFunc()`. Calling that function invokes
    `someFunc()` with `this` set to `thisValue` and these parameters: `arg1`, `arg2`,
    followed by the parameters of `boundFunc()`.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`.bind()` 返回一个新的函数 `boundFunc()`。调用该函数时，将使用 `thisValue` 设置 `this` 并使用这些参数：`arg1`、`arg2`，然后是
    `boundFunc()` 的参数。'
- en: 'That is, the following two function calls are equivalent:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 即，以下两个函数调用是等价的：
- en: '[PRE63]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[27.7.3.1 An alternative to `.bind()`](#an-alternative-to-bind)'
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[27.7.3.1 `.bind()` 的替代方法](#an-alternative-to-bind)'
- en: 'Another way of pre-filling `this` and parameters is via an arrow function:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种预先填充 `this` 和参数的方法是通过箭头函数：
- en: '[PRE64]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[27.7.3.2 An implementation of `.bind()`](#an-implementation-of-bind)'
  id: totrans-322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[27.7.3.2 `.bind()` 的实现](#an-implementation-of-bind)'
- en: 'Considering the previous section, `.bind()` can be implemented as a real function
    as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到上一节，`.bind()` 可以实现为一个真正的函数，如下所示：
- en: '[PRE65]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[27.7.3.3 Example: binding a real function](#example-binding-a-real-function)'
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[27.7.3.3 示例：绑定真正的函数](#example-binding-a-real-function)'
- en: Using `.bind()` for real functions is somewhat unintuitive because we have to
    provide a value for `this`. Given that it is `undefined` during function calls,
    it is usually set to `undefined` or `null`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 对于真正的函数使用 `.bind()` 有点不直观，因为我们必须提供一个 `this` 的值。鉴于在函数调用期间它是 `undefined`，通常将其设置为
    `undefined` 或 `null`。
- en: In the following example, we create `add8()`, a function that has one parameter,
    by binding the first parameter of `add()` to `8`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们创建 `add8()`，一个只有一个参数的函数，通过将 `add()` 的第一个参数绑定到 `8`。
- en: '[PRE66]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
