- en: 27 Callable values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_callables.html](https://exploringjs.com/js/book/ch_callables.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[27.1 Kinds of functions](#kinds-of-functions)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.2 Ordinary functions](#ordinary-functions)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.2.1 Named function expressions (advanced)](#named-function-expressions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.2.2 Terminology: function definitions and function expressions](#terminology-function-definitions-and-function-expressions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.2.3 Parts of a function declaration](#parts-of-a-function-declaration)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.2.4 Roles played by ordinary functions](#roles-of-ordinary-functions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.2.5 Terminology: entity vs. syntax vs. role (advanced)](#terminology-entity-vs-syntax-vs-role-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.3 Specialized functions ^(ES6)](#specialized-functions)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.3.1 Specialized functions are still functions](#specialized-functions-are-still-functions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.3.2 Arrow functions](#arrow-functions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.3.3 The special variable `this` in methods, ordinary functions and arrow
    functions](#this-in-callables)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.3.4 Recommendation: prefer specialized functions over ordinary functions](#prefer-specialized-functions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.4 Summary: kinds of callable values](#summary-kinds-of-callable-values)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.5 Returning values from functions and methods](#returning-values-from-functions-and-methods)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.6 Parameter handling](#parameter-handling)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.6.1 Terminology: parameters vs. arguments](#terminology-parameters-vs-arguments)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.6.2 Terminology: callback](#callback-function)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.6.3 Too many or not enough arguments](#too-many-or-not-enough-arguments)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.6.4 Parameter default values ^(ES6)](#parameter-default-values)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.6.5 Rest parameters ^(ES6)](#rest-parameters)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.6.6 Named parameters](#named-parameters)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.6.7 Simulating named parameters ^(ES6)](#simulating-named-parameters)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.6.8 Spreading (`...`) into function calls ^(ES6)](#spread-arguments)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.7 Methods of functions: `.call()`, `.apply()`, `.bind()`](#methods-of-functions)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.7.1 The function method `.call()`](#Function.prototype.call)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.7.2 The function method `.apply()`](#Function.prototype.apply)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.7.3 The function method `.bind()`](#Function.prototype.bind)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this chapter, we look at JavaScript values that can be invoked: functions,
    methods, and classes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[27.1 Kinds of functions](#kinds-of-functions)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript has two categories of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An *ordinary function* can play several roles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real function
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Method
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor function
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A *specialized function* can only play one of those roles – for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An *arrow function* can only be a real function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A *method* can only be a method.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A *class* can only be a constructor function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Specialized functions were added to the language in ECMAScript 6.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Read on to find out what all of those things mean.
  prefs: []
  type: TYPE_NORMAL
- en: '[27.2 Ordinary functions](#ordinary-functions)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code shows two ways of doing (roughly) the same thing: creating
    an ordinary function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1][PRE2]`` Inside a scope, function declarations are activated early (see
    [“Declarations: scope and activation” (§13.8)](ch_variables-assignment.html#declarations-scope-activation))
    and can be called before they are declared. That is occasionally useful.    Variable
    declarations, such as the one for `ordinary2`, are not activated early.    ####
    [27.2.1 Named function expressions (advanced)](#named-function-expressions)    So
    far, we have only seen anonymous function expressions – which don’t have names:    [PRE3]    But
    there are also *named function expressions*:    [PRE4]    `myName` is only accessible
    inside the body of the function. The function can use it to refer to itself (for
    self-recursion, etc.) – independently of which variable it is assigned to:    [PRE5]   [PRE6][PRE7]`
    Even if they are not assigned to variables, named function expressions have names
    (line A):    [PRE8]   [PRE9][PRE10] [PRE11][PRE12]``js[PRE13]`js` #### [27.2.4 Roles
    played by ordinary functions](#roles-of-ordinary-functions)    Consider the following
    function declaration from the previous section:    [PRE14]js    This function
    declaration creates an ordinary function whose name is `add`. As an ordinary function,
    `add()` can play three roles:    *   Real function: invoked via a function call.                    [PRE15]js           *   Method:
    stored in a property, invoked via a method call.                    [PRE16]js                    In
    line A, `obj` is called the *receiver* of the method call.           *   Constructor
    function: invoked via `new`.                    [PRE17]js                    As
    an aside, the names of constructor functions (incl. classes) normally start with
    capital letters.              #### [27.2.5 Terminology: entity vs. syntax vs.
    role (advanced)](#terminology-entity-vs-syntax-vs-role-advanced)    The distinction
    between the concepts *syntax*, *entity*, and *role* is subtle and often doesn’t
    matter. But it’s still useful to be aware of it:    *   An *entity* is a JavaScript
    feature as it “lives” in RAM. An ordinary function is an entity.               *   Entities
    include: ordinary functions, arrow functions, methods, and classes. *   *Syntax*
    is the code that we use to create entities. Function declarations and anonymous
    function expressions are syntax. They both create entities that are called ordinary
    functions.               *   Syntax includes: function declarations and anonymous
    function expressions. The syntax that produces arrow functions is also called
    *arrow functions*. The same is true for methods and classes. *   A *role* describes
    how we use entities. The entity *ordinary function* can play the role *real function*,
    or the role *method*, or the role *class*. The entity *arrow function* can also
    play the role *real function*.               *   The roles of functions are: real
    function, method, and constructor function.    Many other programming languages
    only have a single entity that plays the role *real function*. Then they can use
    the name *function* for both role and entity.    ### [27.3 Specialized functions
    ^(ES6)](#specialized-functions)    Specialized functions are single-purpose versions
    of ordinary functions. Each one of them specializes in a single role:    *   The
    purpose of an *arrow function* is to be a real function:                    [PRE18]js           *   The
    purpose of a *method* is to be a method:                    [PRE19]js           *   The
    purpose of a *class* is to be a constructor function:                    [PRE20]js              Apart
    from nicer syntax, each kind of specialized function also supports new features,
    making them better at their jobs than ordinary functions.    *   Arrow functions
    are explained soon. *   Methods are explained [in the chapter on objects](ch_objects.html#methods-and-this).
    *   Classes are explained [in the chapter on classes](ch_classes.html#classes).    [Table
    27.1](#tbl:capabilities-of-functions) lists the capabilities of ordinary and specialized
    functions.     |  | Function call | Method call | Constructor call | | --- | ---
    | --- | --- | | Ordinary function | (`this === undefined`) | ✔ | ✔ | | Arrow function
    | ✔ | (lexical `this`) | ✘ | | Method | (`this === undefined`) | ✔ | ✘ | | Class
    | ✘ | ✘ | ✔ |      Table 27.1: Capabilities of four kinds of functions. If a cell
    value is in parentheses, that implies some kind of limitation. The special variable
    `this` is explained in [“The special variable `this` in methods, ordinary functions
    and arrow functions” (§27.3.3)](#this-in-callables).      #### [27.3.1 Specialized
    functions are still functions](#specialized-functions-are-still-functions)    It’s
    important to note that arrow functions, methods, and classes are still categorized
    as functions:    [PRE21]js    #### [27.3.2 Arrow functions](#arrow-functions)    Arrow
    functions were added to JavaScript for two reasons:    1.  To provide a more concise
    way for creating functions. 2.  They work better as real functions inside methods:
    Methods can refer to the object that received a method call via the special variable
    `this`. Arrow functions can access the `this` of a surrounding method, ordinary
    functions can’t (because they have their own `this`).    We’ll first examine the
    syntax of arrow functions and then how `this` works in various functions.    #####
    [27.3.2.1 The syntax of arrow functions](#the-syntax-of-arrow-functions)    Let’s
    review the syntax of an anonymous function expression:    [PRE22]js    The (roughly)
    equivalent arrow function looks as follows. Arrow functions are expressions.    [PRE23]js    Here,
    the body of the arrow function is a block. But it can also be an expression. The
    following arrow function works exactly like the previous one.    [PRE24]js    If
    an arrow function has only a single parameter and that parameter is an identifier
    (not [a destructuring pattern](ch_destructuring.html#ch_destructuring)) then we
    can omit the parentheses around the parameter:    [PRE25]js    That is convenient
    when passing arrow functions as parameters to other functions or methods:    [PRE26]js    This
    previous example demonstrates one benefit of arrow functions – conciseness. If
    we perform the same task with a function expression, our code is more verbose:    [PRE27]js    #####
    [27.3.2.2 Syntax pitfall: returning an object literal from an arrow function](#returning-object-literal-from-arrow-function)    If
    we want the expression body of an arrow function to be an object literal, we must
    put the literal in parentheses:    [PRE28]js    If we don’t, JavaScript thinks,
    the arrow function has a block body (that doesn’t return anything):    [PRE29]js    `{a:
    1}` is interpreted as a block with [the label `a:`](ch_control-flow.html#labels)
    and the expression statement `1`. Without an explicit `return` statement, the
    block body returns `undefined`.    This pitfall is caused by [syntactic ambiguity](ch_syntax.html#ambiguous-syntax):
    object literals and code blocks have the same syntax. We use the parentheses to
    tell JavaScript that the body is an expression (an object literal) and not a statement
    (a block).    #### [27.3.3 The special variable `this` in methods, ordinary functions
    and arrow functions](#this-in-callables)    ![Icon “reading”](../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png) **The
    special variable `this` is an object-oriented feature**    We are taking a quick
    look at the special variable `this` here, in order to understand why arrow functions
    are better real functions than ordinary functions.    But this feature only matters
    in object-oriented programming and is covered in more depth in [“Methods and the
    special variable `this`” (§30.6)](ch_objects.html#methods-and-this). Therefore,
    don’t worry if you don’t fully understand it yet.    Inside methods, the special
    variable `this` lets us access the *receiver* – the object which received the
    method call:    [PRE30]js    Ordinary functions can be methods and therefore also
    have the implicit parameter `this`:    [PRE31]js    `this` is even an implicit
    parameter when we use an ordinary function as a real function. Then its value
    is `undefined` (if [strict mode](ch_syntax.html#strict-mode) is active, which
    it almost always is):    [PRE32]js    That means that an ordinary function, used
    as a real function, can’t access the `this` of a surrounding method (line A).
    In contrast, arrow functions don’t have `this` as an implicit parameter. They
    treat it like any other variable and can therefore access the `this` of a surrounding
    method (line B):    [PRE33]js   [PRE34] [PRE35]`` #### [27.6.4 Parameter default
    values ^(ES6)](#parameter-default-values)    Parameter default values specify
    the value to use if a parameter has not been provided – for example:    [PRE36]   [PRE37]`
    `undefined` also triggers the default value:    [PRE38]    #### [27.6.5 Rest parameters
    ^(ES6)](#rest-parameters)    A rest parameter is declared by prefixing an identifier
    with three dots (`...`). During a function or method call, it receives an Array
    with all remaining arguments. If there are no extra arguments at the end, it is
    an empty Array – for example:    [PRE39]    There are two restrictions related
    to how we can use rest parameters:    *   We cannot use more than one rest parameter
    per function definition.                    [PRE40]           *   A rest parameter
    must always come last. As a consequence, we can’t access the last parameter like
    this:                    [PRE41]              ##### [27.6.5.1 Enforcing a certain
    number of arguments via a rest parameter](#enforcing-a-certain-number-of-arguments-via-a-rest-parameter)    We
    can use a rest parameter to enforce a certain number of arguments. Take, for example,
    the following function:    [PRE42]    This is how we force callers to always provide
    two arguments:    [PRE43]    In line A, we access the elements of `args` via [*destructuring*](ch_destructuring.html#ch_destructuring).    ####
    [27.6.6 Named parameters](#named-parameters)    When someone calls a function,
    the arguments provided by the caller are assigned to the parameters received by
    the callee. Two common ways of performing the mapping are:    1.  Positional parameters:
    An argument is assigned to a parameter if they have the same position. A function
    call with only positional arguments looks as follows.                    [PRE44]           2.  Named
    parameters: An argument is assigned to a parameter if they have the same name.
    JavaScript doesn’t have named parameters, but we can simulate them. For example,
    this is a function call with only (simulated) named arguments:                    [PRE45]              Named
    parameters have several benefits:    *   They lead to more self-explanatory code
    because each argument has a descriptive label. Just compare the two versions of
    `selectEntries()`: with the second one, it is much easier to see what happens.           *   The
    order of the arguments doesn’t matter (as long as the names are correct).           *   Handling
    more than one optional parameter is more convenient: callers can easily provide
    any subset of all optional parameters and don’t have to be aware of the ones they
    omit (with positional parameters, we have to fill in preceding optional parameters,
    with `undefined`).              #### [27.6.7 Simulating named parameters ^(ES6)](#simulating-named-parameters)    JavaScript
    doesn’t have real named parameters. The official way of simulating them is via
    object literals:    [PRE46]    This function uses [*destructuring*](ch_destructuring.html#ch_destructuring)
    to access the properties of its single parameter. The pattern it uses is an abbreviation
    for the following pattern:    [PRE47]    This destructuring pattern works for
    empty object literals:    [PRE48]    But it does not work if we call the function
    without any parameters:    [PRE49]    We can fix this by providing a default value
    for the whole pattern. This default value works the same as default values for
    simpler parameter definitions: if the parameter is missing, the default is used.    [PRE50]    ####
    [27.6.8 Spreading (`...`) into function calls ^(ES6)](#spread-arguments)    If
    we put three dots (`...`) in front of the argument of a function call, then we
    *spread* it. That means that the argument must be [an *iterable* object](ch_sync-iteration.html#ch_sync-iteration)
    and the iterated values all become arguments. In other words, a single argument
    is expanded into multiple arguments – for example:    [PRE51]    Output:    [PRE52]    Spreading
    and rest parameters use the same syntax (`...`), but they serve opposite purposes:    *   Rest
    parameters are used when defining functions or methods. They collect arguments
    into Arrays. *   Spread arguments are used when calling functions or methods.
    They turn iterable objects into arguments.    ##### [27.6.8.1 Example: spreading
    into `Math.max()`](#example-spreading-into-mathmax)    `Math.max()` returns the
    largest one of its zero or more arguments. Alas, it can’t be used for Arrays,
    but spreading gives us a way out:    [PRE53]    ##### [27.6.8.2 Example: spreading
    into `Array.prototype.push()`](#example-spreading-into-arrayprototypepush)    Similarly,
    the Array method `.push()` destructively adds its zero or more parameters to the
    end of its Array. JavaScript has no method for destructively appending an Array
    to another one. Once again, we are saved by spreading:    [PRE54]   [PRE55] ![Icon
    “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercises: Parameter
    handling**    *   Positional parameters: `exercises/callables/positional_parameters_test.mjs`
    *   Named parameters: `exercises/callables/named_parameters_test.mjs`    ### [27.7 Methods
    of functions: `.call()`, `.apply()`, `.bind()`](#methods-of-functions)    Functions
    are objects and have methods. In this section, we look at three of those methods:
    `.call()`, `.apply()`, and `.bind()`.    #### [27.7.1 The function method `.call()`](#Function.prototype.call)    Each
    function `someFunc` has the following method:    [PRE56]js    This method invocation
    is loosely equivalent to the following function call:    [PRE57]js    However,
    with `.call()`, we can also specify a value for [the implicit parameter `this`](#this-in-callables).
    In other words: `.call()` makes the implicit parameter `this` explicit.    The
    following code demonstrates the use of `.call()`:    [PRE58]js   [PRE59]`js [PRE60]js``
    [PRE61]js[PRE62][PRE63][PRE64][PRE65]js[PRE66]js` [PRE67]`js`` [PRE68]````'
  prefs: []
  type: TYPE_NORMAL
