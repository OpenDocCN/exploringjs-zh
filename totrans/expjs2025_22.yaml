- en: 18 Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_numbers.html](https://exploringjs.com/js/book/ch_numbers.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[18.1 Numbers are used for both floating point numbers and integers](#numbers-are-used-for-both-floating-point-numbers-and-integers)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.2 Number literals](#number-literals)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.2.1 Integer literals](#integer-literals)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.2.2 Floating point literals](#floating-point-literals)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.2.3 Syntactic pitfall: properties of decimal integer literals](#properties-of-decimal-integer-literals)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.2.4 Underscores (`_`) as separators in number literals ^(ES2021)](#numeric-separator-number-literals)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.3 Arithmetic operators](#arithmetic-operators)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.3.1 Binary arithmetic operators](#binary-arithmetic-operators)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.3.2 Unary plus (`+`) and negation (`-`)](#unary-plus--and-negation-)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.3.3 Incrementing (`++`) and decrementing (`--`)](#incrementing--and-decrementing-)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.4 Converting to number](#converting-to-number)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.5 The numeric error values `NaN` and `Infinity`](#numeric-error-values)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.5.1 Error value: `NaN`](#NaN)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.5.2 Error value: `Infinity`](#error-value-infinity)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.6 The precision of numbers: careful with decimal fractions](#the-precision-of-numbers-careful-with-decimal-fractions)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.7 (Advanced)](#advanced-2)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.8 Background: floating point precision](#floating-point-precision)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.8.1 A simplified representation of floating point numbers](#a-simplified-representation-of-floating-point-numbers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.9 Integer numbers in JavaScript](#integer-numbers)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.9.1 How are integers different from floating point numbers with fractions?](#how-are-integers-different-from-floating-point-numbers-with-fractions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.9.2 Converting to integer](#converting-to-integer)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.9.3 Ranges of integer numbers in JavaScript](#ranges-of-integer-numbers-in-javascript)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.9.4 Safe integers](#safe-integers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.10 Bitwise operators (advanced)](#bitwise-operators-advanced)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.10.1 Internally, bitwise operators work with 32-bit integers](#bitwise-operators-32-bit-operands)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.10.2 Bitwise Not](#bitwise-not)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.10.3 Binary bitwise operators](#binary-bitwise-operators)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.10.4 Bitwise shift operators](#bitwise-shift-operators)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.10.5 `b32()`: displaying unsigned 32-bit integers in binary notation](#b32)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.11 Quick reference: numbers](#quick-reference-numbers)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.11.1 Global functions for numbers](#global-functions-for-numbers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.11.2 `Number.*`: data properties](#number-data-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.11.3 `Number.*`: methods](#number-methods)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.11.4 `Number.prototype.*`](#numberprototype)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.11.5 `Number.*`: data properties and methods for integers](#number-data-properties-and-methods-for-integers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.11.6 Sources](#sources)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'JavaScript has two kinds of numeric values:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Numbers* are *doubles* – 64-bit floating point numbers implemented according
    to the *IEEE Standard for Floating-Point Arithmetic* (IEEE 754).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are also used for smaller integers within a range of plus/minus 53 bits.
    For more information, see [“Integer numbers in JavaScript” (§18.9)](#integer-numbers).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bigints* represent integers with an arbitrary precision.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter covers numbers. Bigints are covered [later in this book](ch_bigints.html#ch_bigints).
  prefs: []
  type: TYPE_NORMAL
- en: '[18.1 Numbers are used for both floating point numbers and integers](#numbers-are-used-for-both-floating-point-numbers-and-integers)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The type `number` is used for both floating point numbers and integers in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'However, all numbers are floating point numbers. Integer numbers are simply
    floating point numbers without a decimal fraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[18.2 Number literals](#number-literals)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s examine literals for numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.2.1 Integer literals](#integer-literals)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Several *integer literals* let us express integers with various bases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[18.2.2 Floating point literals](#floating-point-literals)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Floating point numbers can only be expressed in base 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fractions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Exponent: `eN` means ×10^N'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[18.2.3 Syntactic pitfall: properties of decimal integer literals](#properties-of-decimal-integer-literals)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Accessing a property of an decimal integer literal entails a pitfall: If the
    decimal integer literal is immediately followed by a dot, then that dot is interpreted
    as a decimal dot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There are four ways to work around this pitfall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that non-decimal integer literals don’t have this pitfall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[18.2.4 Underscores (`_`) as separators in number literals ^(ES2021)](#numeric-separator-number-literals)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Grouping digits to make long numbers more readable has a long tradition. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: In 1825, London had 1,335,000 inhabitants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The distance between Earth and Sun is 149,600,000 km.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since ES2021, we can use underscores as separators in number literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With other bases, grouping is important, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the separator in fractions and exponents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[18.2.4.1 Where can we put separators?](#where-can-we-put-separators)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The locations of separators are restricted in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can only put underscores between two digits. Therefore, all of the following
    number literals are illegal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can’t use more than one underscore in a row:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The motivation behind these restrictions is to keep parsing simple and to avoid
    strange edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.2.4.2 Parsing numbers with separators](#parsing-numbers-with-separators)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following functions for parsing numbers do not support separators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Number()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.parseInt()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.parseFloat()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The rationale is that numeric separators are for code. Other kinds of input
    should be processed differently.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.3 Arithmetic operators](#arithmetic-operators)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[18.3.1 Binary arithmetic operators](#binary-arithmetic-operators)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Table 18.1](#tbl:binary-arithmetic-operators) lists JavaScript’s binary arithmetic
    operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Name |  | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `n + m` | Addition | ES1 | `3 + 4` → `7` |'
  prefs: []
  type: TYPE_TB
- en: '| `n - m` | Subtraction | ES1 | `9 - 1` → `8` |'
  prefs: []
  type: TYPE_TB
- en: '| `n * m` | Multiplication | ES1 | `3 * 2.25` → `6.75` |'
  prefs: []
  type: TYPE_TB
- en: '| `n / m` | Division | ES1 | `5.625 / 5` → `1.125` |'
  prefs: []
  type: TYPE_TB
- en: '| `n % m` | Remainder | ES1 | `8 % 5` → `3` |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  | `-8 % 5` → `-3` |'
  prefs: []
  type: TYPE_TB
- en: '| `n ** m` | Exponentiation | ES2016 | `4 ** 2` → `16` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 18.1: Binary arithmetic operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '[18.3.1.1 `%` is a remainder operator](#-is-a-remainder-operator)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`%` is a remainder operator, not a modulo operator. Its result has the sign
    of the first operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For more information on the difference between remainder and modulo, see the
    blog post [“Remainder operator vs. modulo operator (with JavaScript code)”](https://2ality.com/2019/08/remainder-vs-modulo.html)
    on 2ality.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.3.2 Unary plus (`+`) and negation (`-`)](#unary-plus--and-negation-)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Table 18.2](#tbl:unary-plus-negation) summarizes the two operators *unary
    plus* (`+`) and *negation* (`-`).'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Name |  | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `+n` | Unary plus | ES1 | `+(-7)` → `-7` |'
  prefs: []
  type: TYPE_TB
- en: '| `-n` | Unary negation | ES1 | `-(-7)` → `7` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 18.2: The operators unary plus (`+`) and negation (`-`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both operators coerce their operands to numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Thus, unary plus lets us convert arbitrary values to numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.3.3 Incrementing (`++`) and decrementing (`--`)](#incrementing--and-decrementing-)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The incrementation operator `++` exists in a prefix version and a suffix version.
    In both versions, it destructively adds one to its operand. Therefore, its operand
    must be a storage location that can be changed.
  prefs: []
  type: TYPE_NORMAL
- en: The decrementation operator `--` works the same, but subtracts one from its
    operand. The next two examples explain the difference between the prefix and the
    suffix version.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18.3](#tbl:incrementing-decrementing) summarizes the incrementation
    and decrementation operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Name |  | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `v++` | Increment | ES1 | `let v=0; [v++, v]` → `[0, 1]` |'
  prefs: []
  type: TYPE_TB
- en: '| `++v` | Increment | ES1 | `let v=0; [++v, v]` → `[1, 1]` |'
  prefs: []
  type: TYPE_TB
- en: '| `v--` | Decrement | ES1 | `let v=1; [v--, v]` → `[1, 0]` |'
  prefs: []
  type: TYPE_TB
- en: '| `--v` | Decrement | ES1 | `let v=1; [--v, v]` → `[0, 0]` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 18.3: Incrementation operators and decrementation operators.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at examples of these operators in use.
  prefs: []
  type: TYPE_NORMAL
- en: Prefix `++` and prefix `--` change their operands and then return them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Suffix `++` and suffix `--` return their operands and then change them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[18.3.3.1 Operands: not just variables](#operands-not-just-variables)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can also apply these operators to property values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And to Array elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Number operators**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/numbers/is_odd_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[18.4 Converting to number](#converting-to-number)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These are three ways of converting values to numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Number(value)`: has a descriptive name and is therefore recommended. [Table
    18.4](#tbl:converting-values-to-numbers) summarizes how it works.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+value`: is equivalent to `Number(value)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parseFloat(value)`: has [quirks](#qref-Number.parseFloat) and should be avoided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| `x` | `Number(x)` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `undefined` | `NaN` |'
  prefs: []
  type: TYPE_TB
- en: '| `null` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| boolean | `false` → `0`, `true` → `1` |'
  prefs: []
  type: TYPE_TB
- en: '| number | `x` (no change) |'
  prefs: []
  type: TYPE_TB
- en: '| bigint | `-1n` → `-1`, `1n` → `1`, etc. |'
  prefs: []
  type: TYPE_TB
- en: '| string | `''''` → `0` |'
  prefs: []
  type: TYPE_TB
- en: '|  | Other → parsed number, ignoring leading/trailing whitespace |'
  prefs: []
  type: TYPE_TB
- en: '| symbol | Throws `TypeError` |'
  prefs: []
  type: TYPE_TB
- en: '| object | Configurable (e.g. via `.valueOf()`) |'
  prefs: []
  type: TYPE_TB
- en: 'Table 18.4: Converting values to numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'How objects are converted to numbers can be configured – for example, by overriding
    `.valueOf()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Converting to number**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/numbers/parse_number_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[18.5 The numeric error values `NaN` and `Infinity`](#numeric-error-values)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript has two numeric error values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NaN`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returned if parsing a number doesn’t work or an operation can’t be performed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Detected via `Number.isNaN()`. `NaN` is not strictly equal to itself.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Infinity`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returned if a number is too large or if a number is divided by zero.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Detected via `Number.isFinite()` or by comparing via `===`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[18.5.1 Error value: `NaN`](#NaN)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`NaN` is an abbreviation of “not a number”. Ironically, JavaScript considers
    it to be a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When is `NaN` returned?
  prefs: []
  type: TYPE_NORMAL
- en: '`NaN` is returned if a number can’t be parsed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`NaN` is returned if an operation can’t be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`NaN` is returned if an operand or argument is `NaN` (to propagate errors):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[18.5.1.1 Checking for `NaN`](#checking-for-nan)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`NaN` is the only JavaScript value that is not strictly equal to itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'These are several ways of checking if a value `x` is `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the last line, we use the comparison quirk to detect `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.5.1.2 Finding `NaN` in Arrays](#finding-nan-in-arrays)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Some Array methods can’t find `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Others can:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Alas, there is no simple rule of thumb. We have to check for each method how
    it handles `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.5.2 Error value: `Infinity`](#error-value-infinity)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When is the error value `Infinity` returned?
  prefs: []
  type: TYPE_NORMAL
- en: '`Infinity` is returned if a number is too large:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`Infinity` is returned if there is a division by zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[18.5.2.1 `Infinity` as a default value](#infinity-as-a-default-value)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`Infinity` is larger than all other numbers (except `NaN`), making it a good
    default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This explains the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[18.5.2.2 Checking for `Infinity`](#checking-for-infinity)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'These are two common ways of checking if a value `x` is `Infinity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Comparing numbers**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/numbers/find_max_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[18.6 The precision of numbers: careful with decimal fractions](#the-precision-of-numbers-careful-with-decimal-fractions)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Internally, JavaScript floating point numbers are represented with base 2 (according
    to the IEEE 754 standard). That means that decimal fractions (base 10) can’t always
    be represented precisely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We therefore need to take rounding errors into consideration when performing
    arithmetic in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Read on for an explanation of this phenomenon.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.7 (Advanced)](#advanced-2)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All remaining sections of this chapter are advanced.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.8 Background: floating point precision](#floating-point-precision)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In JavaScript, computations with numbers don’t always produce correct results
    – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand why, we need to explore how JavaScript represents floating point
    numbers internally. It uses three integers to do so, which take up a total of
    64 bits of storage (double precision):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Component | Size | Integer range |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Sign | 1 bit | [0, 1] |'
  prefs: []
  type: TYPE_TB
- en: '| Fraction | 52 bits | [0, 2^(52)−1] |'
  prefs: []
  type: TYPE_TB
- en: '| Exponent | 11 bits | [−1023, 1024] |'
  prefs: []
  type: TYPE_TB
- en: 'The floating point number represented by these integers is computed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: (–1)^(sign) × 0b1.fraction × 2^(exponent)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This representation can’t encode a zero because its second component (involving
    the fraction) always has a leading 1\. Therefore, a zero is encoded via the special
    exponent −1023 and a fraction 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.8.1 A simplified representation of floating point numbers](#a-simplified-representation-of-floating-point-numbers)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make further discussions easier, we simplify the previous representation:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of base 2 (binary), we use base 10 (decimal) because that’s what most
    people are more familiar with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *fraction* is a natural number that is interpreted as a fraction (digits
    after a point). We switch to a *mantissa*, an integer that is interpreted as itself.
    As a consequence, the exponent is used differently, but its fundamental role doesn’t
    change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the mantissa is an integer (with its own sign), we don’t need a separate
    sign, anymore.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The new representation works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: mantissa × 10^(exponent)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s try out this representation for a few floating point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To encode the integer 123, we use the mantissa 123 and multiply it with 1 (10⁰):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To encode the integer −45, we use the mantissa −45 and, again, the exponent
    zero:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the number 1.5, we imagine there being a point after the mantissa. We use
    the negative exponent −1 to move that point one digit to the left:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the number 0.25, we move the point two digits to the left:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In other words: As soon as we have decimal digits, the exponent becomes negative.
    We can also write such a number as a fraction:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Numerator (above the horizontal fraction bar): the mantissa'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Denominator (below the horizontal fraction bar): a 10 with a positive exponent
    ≥ 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'These fractions help with understanding why there are numbers that our encoding
    cannot represent:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1/10` can be represented. It already has the required format: a power of 10
    in the denominator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1/2` can be represented as `5/10`. We turned the 2 in the denominator into
    a power of 10 by multiplying the numerator and denominator by 5.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1/4` can be represented as `25/100`. We turned the 4 in the denominator into
    a power of 10 by multiplying the numerator and denominator by 25.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1/3` cannot be represented. There is no way to turn the denominator into a
    power of 10\. (The prime factors of 10 are 2 and 5\. Therefore, any denominator
    that only has these prime factors can be converted to a power of 10, by multiplying
    both the numerator and denominator by enough twos and fives. If a denominator
    has a different prime factor, then there’s nothing we can do.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To conclude our excursion, we switch back to base 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0.5 = 1/2` can be represented with base 2 because the denominator is already
    a power of 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0.25 = 1/4` can be represented with base 2 because the denominator is already
    a power of 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0.1 = 1/10` cannot be represented because the denominator cannot be converted
    to a power of 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0.2 = 2/10` cannot be represented because the denominator cannot be converted
    to a power of 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we can see why `0.1 + 0.2` doesn’t produce a correct result: internally,
    neither of the two operands can be represented precisely.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only way to compute precisely with decimal fractions is by internally switching
    to base 10\. For many programming languages, base 2 is the default and base 10
    an option. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: Java has the class [`BigDecimal`](https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python has the module [`decimal`](https://docs.python.org/3/library/decimal.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are plans to add something similar to JavaScript: [the ECMAScript proposal
    “Decimal”](https://github.com/tc39/proposal-decimal). Until that happens, we can
    use libraries such as [big.js](https://github.com/MikeMcl/big.js/).'
  prefs: []
  type: TYPE_NORMAL
- en: '[18.9 Integer numbers in JavaScript](#integer-numbers)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Integer numbers are normal (floating point) numbers without decimal fractions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we’ll look at a few tools for working with these pseudo-integers.
    JavaScript also supports [*bigints*](ch_bigints.html#ch_bigints), which are real
    integers.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.9.1 How are integers different from floating point numbers with fractions?](#how-are-integers-different-from-floating-point-numbers-with-fractions)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we have seen, JavaScript (non-bigint) integers are simply floating point
    numbers without decimal fractions. But they are different in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In some locations, only integers are allowed – e.g., the `Array` constructor
    only accepts integers as lengths:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In some locations, numbers with fractions are coerced to numbers without fractions
    – e.g., the bitwise Or (`|`) operation coerces its operands to 32-bit integers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'JavaScript has several constants and operations for working with integers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Non-decimal integer literals can’t have fractions (the suffix `.1` is interpreted
    as reading a property – whose name illegally starts with a digit):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Some JavaScript engines internally represent smaller integers differently –
    as real integers. For example, V8 does this for the following “small integer”
    ranges ([source](https://medium.com/fhinkel/v8-internals-how-small-is-a-small-integer-e0badc18b6da)):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '32-bit systems: 30 bits plus sign'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '64-bit systems: 31 bits plus sign'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[18.9.2 Converting to integer](#converting-to-integer)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The recommended way of converting numbers to integers is to use one of the
    rounding methods of the `Math` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.floor(n)`: returns the largest integer `i` ≤ `n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Math.ceil(n)`: returns the smallest integer `i` ≥ `n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Math.round(n)`: returns the integer that is “closest” to `n` with `__.5` being
    rounded up – for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Math.trunc(n)`: removes any decimal fraction (after the point) that `n` has,
    therefore turning it into an integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For more information on rounding, see [“Rounding” (§19.3)](ch_math.html#math-rounding).
  prefs: []
  type: TYPE_NORMAL
- en: '[18.9.3 Ranges of integer numbers in JavaScript](#ranges-of-integer-numbers-in-javascript)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These are important ranges of integer numbers in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Safe integers:** can be represented “safely” by JavaScript (more on what
    that means in the next subsection)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Precision: 53 bits plus sign'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Range: (−2^(53), 2^(53))'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Array indices**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Precision: 32 bits, unsigned'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Range: [0, 2^(32)−1) (excluding the maximum length)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Typed Arrays have a larger range of 53 bits (safe and unsigned)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bitwise operators** (bitwise Or, etc.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Precision: 32 bits'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Range of unsigned right shift (`>>>`): unsigned, [0, 2^(32))'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Range of all other bitwise operators: signed, [−2^(31), 2^(31))'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[18.9.4 Safe integers](#safe-integers)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is the range of integer numbers that are *safe* in JavaScript (53 bits
    plus a sign):'
  prefs: []
  type: TYPE_NORMAL
- en: '[–(2^(53))+1, 2^(53)–1]'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An integer is *safe* if it is represented by exactly one JavaScript number.
    Given that JavaScript numbers are encoded as a fraction multiplied by 2 to the
    power of an exponent, higher integers can also be represented, but then there
    are gaps between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example (18014398509481984 is 2^(54)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The following mathematical integers are therefore not safe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The mathematical integer 18014398509481984 is represented by these JavaScript
    numbers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '18014398509481983'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '18014398509481984'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '18014398509481985'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '18014398509481986'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The mathematical integer 18014398509481985 is not represented by any JavaScript
    number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following properties of `Number` help determine if an integer is safe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Detecting safe integers**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/numbers/is_safe_integer_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[18.9.4.1 Safe computations](#safe-computations)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s look at computations involving unsafe integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following result is incorrect and unsafe, even though both of its operands
    are safe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The following result is safe, but incorrect. The first operand is unsafe; the
    second operand is safe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, the result of an expression `a op b` is correct if and only if:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: That is, both operands and the result must be safe.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.10 Bitwise operators (advanced)](#bitwise-operators-advanced)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[18.10.1 Internally, bitwise operators work with 32-bit integers](#bitwise-operators-32-bit-operands)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Internally, JavaScript’s bitwise operators work with 32-bit integers. They
    produce their results in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input (JavaScript numbers): The 1–2 operands are first converted to JavaScript
    numbers (64-bit floating point numbers) and then to 32-bit integers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Computation (32-bit integers): The actual operation processes 32-bit integers
    and produces a 32-bit integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Output (JavaScript number): Before returning the result, it is converted back
    to a JavaScript number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[18.10.1.1 The types of operands and results](#the-types-of-operands-and-results)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For each bitwise operator, this book mentions the types of its operands and
    its result. Each type is always one of the following two:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description | Size | Range |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Int32 | signed 32-bit integer | 32 bits incl. sign | [−2^(31), 2^(31)) |'
  prefs: []
  type: TYPE_TB
- en: '| Uint32 | unsigned 32-bit integer | 32 bits | [0, 2^(32)) |'
  prefs: []
  type: TYPE_TB
- en: Considering the previously mentioned steps, I recommend to pretend that bitwise
    operators internally work with unsigned 32-bit integers (step “computation”) and
    that Int32 and Uint32 only affect how JavaScript numbers are converted to and
    from integers (steps “input” and “output”).
  prefs: []
  type: TYPE_NORMAL
- en: '[18.10.1.2 Displaying JavaScript numbers as unsigned 32-bit integers](#displaying-javascript-numbers-as-unsigned-32bit-integers)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'While exploring the bitwise operators, it occasionally helps to display JavaScript
    numbers as unsigned 32-bit integers in binary notation. That’s what `b32()` does
    (whose implementation is shown later):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[18.10.2 Bitwise Not](#bitwise-not)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Operation | Name | Type signature |  |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `~num` | Bitwise Not, *ones’ complement* | Int32 → Int32 | ES1 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 18.5: The bitwise Not operator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The bitwise Not operator ([table 18.5](#tbl:bitwise-not)) inverts each binary
    digit of its operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This so-called *ones’ complement* is similar to a negative for some arithmetic
    operations. For example, adding an integer to its ones’ complement is always `-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[18.10.3 Binary bitwise operators](#binary-bitwise-operators)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Operation | Name | Type signature |  |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `num1 & num2` | Bitwise And | Int32 × Int32 → Int32 | ES1 |'
  prefs: []
  type: TYPE_TB
- en: '| `num1 ¦ num2` | Bitwise Or | Int32 × Int32 → Int32 | ES1 |'
  prefs: []
  type: TYPE_TB
- en: '| `num1 ^ num2` | Bitwise Xor | Int32 × Int32 → Int32 | ES1 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 18.6: Binary bitwise operators.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The binary bitwise operators ([table 18.6](#tbl:binary-bitwise-operators))
    combine the bits of their operands to produce their results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[18.10.4 Bitwise shift operators](#bitwise-shift-operators)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Operation | Name | Type signature |  |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `num << count` | Left shift | Int32 × Uint32 → Int32 | ES1 |'
  prefs: []
  type: TYPE_TB
- en: '| `num >> count` | Signed right shift | Int32 × Uint32 → Int32 | ES1 |'
  prefs: []
  type: TYPE_TB
- en: '| `num >>> count` | Unsigned right shift | Uint32 × Uint32 → Uint32 | ES1 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 18.7: Bitwise shift operators.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The shift operators ([table 18.7](#tbl:bitwise-shift-operators-short)) move
    binary digits to the left or to the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`>>` preserves highest bit, `>>>` doesn’t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[18.10.5 `b32()`: displaying unsigned 32-bit integers in binary notation](#b32)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have now used `b32()` a few times. The following code is an implementation
    of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`n >>> 0` means that we are shifting `n` zero bits to the right. Therefore,
    in principle, the `>>>` operator does nothing, but it still coerces `n` to an
    unsigned 32-bit integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[18.11 Quick reference: numbers](#quick-reference-numbers)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[18.11.1 Global functions for numbers](#global-functions-for-numbers)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'JavaScript has the following four global functions for numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isFinite()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isNaN()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parseFloat()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parseInt()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, it is better to use the corresponding methods of `Number` (`Number.isFinite()`,
    etc.), which have fewer pitfalls. They were introduced with ES6 and are discussed
    below.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.11.2 `Number.*`: data properties](#number-data-properties)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Number.EPSILON` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between 1 and the next representable floating point number. In
    general, [a machine epsilon](https://en.wikipedia.org/wiki/Machine_epsilon) provides
    an upper bound for rounding errors in floating point arithmetic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Approximately: 2.2204460492503130808472633361816 × 10^(-16)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.MAX_VALUE` ES1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The largest positive finite JavaScript number.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Approximately: 1.7976931348623157 × 10^(308)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.MIN_VALUE` ES1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The smallest positive JavaScript number. Approximately 5 × 10^(−324).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Number.NaN` ES1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same as the global variable `NaN`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Number.NEGATIVE_INFINITY` ES1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same as `-Number.POSITIVE_INFINITY`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Number.POSITIVE_INFINITY` ES1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same as the global variable `Infinity`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[18.11.3 `Number.*`: methods](#number-methods)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Number.isFinite(num)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if `num` is an actual number (neither `Infinity` nor `-Infinity`
    nor `NaN`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Number.isNaN(num)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns `true` if `num` is the value `NaN`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Number.parseFloat(str)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Coerces its parameter to string and parses it as a floating point number. It
    ignores leading whitespace and illegal trailing characters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That can hide problems. Thus, for converting strings to numbers, `Number()`
    is usually a better choice because it only ignores leading and trailing whitespace:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[18.11.4 `Number.prototype.*`](#numberprototype)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: (`Number.prototype` is where the methods of numbers are stored.)
  prefs: []
  type: TYPE_NORMAL
- en: '`Number.prototype.toExponential(fractionDigits?)` ES3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a string that represents the number via exponential notation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With `fractionDigits`, we can specify, how many digits should be shown of the
    number that is multiplied with the exponent.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The default is to show as many digits as necessary.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: number too small to get a positive exponent via `.toString()`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Example: fraction not small enough to get a negative exponent via `.toString()`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Number.prototype.toFixed(fractionDigits=0)` ES3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns an exponent-free string representation of the number, rounded to `fractionDigits`
    digits.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the number is 10^(21) or greater, even `.toFixed()` uses an exponent:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Number.prototype.toPrecision(precision?)` ES3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Works like `.toString()`, but `precision` specifies how many digits should be
    shown overall.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If `precision` is missing, `.toString()` is used.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Number.prototype.toString(radix=10)` ES1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a string representation of the number.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'By default, we get a base 10 numeral as a result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we want the numeral to have a different base, we can specify it via `radix`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Number.parseInt()` provides the inverse operation: it converts a string that
    contains an integer (no fraction!) numeral with a given base, to a number.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[18.11.5 `Number.*`: data properties and methods for integers](#number-data-properties-and-methods-for-integers)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Number.MIN_SAFE_INTEGER` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The smallest integer that JavaScript can represent unambiguously (−2^(53)+1).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Number.MAX_SAFE_INTEGER` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The largest integer that JavaScript can represent unambiguously (2^(53)−1).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Number.isInteger(num)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if `num` is a number and does not have a decimal fraction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Number.isSafeInteger(num)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if `num` is a number and unambiguously represents an integer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Number.parseInt(str, radix=10)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Coerces its parameter to string and parses it as an integer, ignoring leading
    whitespace and illegal trailing characters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter `radix` specifies the base of the number to be parsed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Do not use this method to convert numbers to integers: coercing to string is
    inefficient. And stopping before the first non-digit is not a good algorithm for
    removing the fraction of a number. Here is an example where it goes wrong:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is better to use one of the rounding functions of `Math` to convert a number
    to an integer:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[18.11.6 Sources](#sources)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Wikipedia
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[TypeScript’s built-in typings](https://github.com/microsoft/TypeScript/tree/main/src/lib/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MDN web docs for JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ECMAScript language specification](https://tc39.es/ecma262/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
