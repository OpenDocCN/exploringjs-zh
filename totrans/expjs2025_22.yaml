- en: 18 Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_numbers.html](https://exploringjs.com/js/book/ch_numbers.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[18.1 Numbers are used for both floating point numbers and integers](#numbers-are-used-for-both-floating-point-numbers-and-integers)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.2 Number literals](#number-literals)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.2.1 Integer literals](#integer-literals)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.2.2 Floating point literals](#floating-point-literals)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.2.3 Syntactic pitfall: properties of decimal integer literals](#properties-of-decimal-integer-literals)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.2.4 Underscores (`_`) as separators in number literals ^(ES2021)](#numeric-separator-number-literals)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.3 Arithmetic operators](#arithmetic-operators)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.3.1 Binary arithmetic operators](#binary-arithmetic-operators)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.3.2 Unary plus (`+`) and negation (`-`)](#unary-plus--and-negation-)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.3.3 Incrementing (`++`) and decrementing (`--`)](#incrementing--and-decrementing-)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.4 Converting to number](#converting-to-number)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.5 The numeric error values `NaN` and `Infinity`](#numeric-error-values)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.5.1 Error value: `NaN`](#NaN)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.5.2 Error value: `Infinity`](#error-value-infinity)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.6 The precision of numbers: careful with decimal fractions](#the-precision-of-numbers-careful-with-decimal-fractions)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.7 (Advanced)](#advanced-2)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.8 Background: floating point precision](#floating-point-precision)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.8.1 A simplified representation of floating point numbers](#a-simplified-representation-of-floating-point-numbers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.9 Integer numbers in JavaScript](#integer-numbers)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.9.1 How are integers different from floating point numbers with fractions?](#how-are-integers-different-from-floating-point-numbers-with-fractions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.9.2 Converting to integer](#converting-to-integer)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.9.3 Ranges of integer numbers in JavaScript](#ranges-of-integer-numbers-in-javascript)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.9.4 Safe integers](#safe-integers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.10 Bitwise operators (advanced)](#bitwise-operators-advanced)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.10.1 Internally, bitwise operators work with 32-bit integers](#bitwise-operators-32-bit-operands)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.10.2 Bitwise Not](#bitwise-not)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.10.3 Binary bitwise operators](#binary-bitwise-operators)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.10.4 Bitwise shift operators](#bitwise-shift-operators)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.10.5 `b32()`: displaying unsigned 32-bit integers in binary notation](#b32)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.11 Quick reference: numbers](#quick-reference-numbers)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.11.1 Global functions for numbers](#global-functions-for-numbers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.11.2 `Number.*`: data properties](#number-data-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.11.3 `Number.*`: methods](#number-methods)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.11.4 `Number.prototype.*`](#numberprototype)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.11.5 `Number.*`: data properties and methods for integers](#number-data-properties-and-methods-for-integers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.11.6 Sources](#sources)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'JavaScript has two kinds of numeric values:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Numbers* are *doubles* – 64-bit floating point numbers implemented according
    to the *IEEE Standard for Floating-Point Arithmetic* (IEEE 754).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are also used for smaller integers within a range of plus/minus 53 bits.
    For more information, see [“Integer numbers in JavaScript” (§18.9)](#integer-numbers).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bigints* represent integers with an arbitrary precision.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter covers numbers. Bigints are covered [later in this book](ch_bigints.html#ch_bigints).
  prefs: []
  type: TYPE_NORMAL
- en: '[18.1 Numbers are used for both floating point numbers and integers](#numbers-are-used-for-both-floating-point-numbers-and-integers)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The type `number` is used for both floating point numbers and integers in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'However, all numbers are floating point numbers. Integer numbers are simply
    floating point numbers without a decimal fraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[18.2 Number literals](#number-literals)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s examine literals for numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.2.1 Integer literals](#integer-literals)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Several *integer literals* let us express integers with various bases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2] `// Decimal (base 10)` `assert.equal(35, 35);`  `` `// Hexadecimal (base
    16)` `assert.equal(0xE7, 231);` `` [PRE3]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4][PRE5][PRE6]` [PRE7][PRE8][PRE9] #### [18.2.2 Floating point literals](#floating-point-literals)    Floating
    point numbers can only be expressed in base 10.    Fractions:    [PRE10]js    Exponent:
    `eN` means ×10^N    [PRE11]js    #### [18.2.3 Syntactic pitfall: properties of
    decimal integer literals](#properties-of-decimal-integer-literals)    Accessing
    a property of an decimal integer literal entails a pitfall: If the decimal integer
    literal is immediately followed by a dot, then that dot is interpreted as a decimal
    dot:    [PRE12]js    There are four ways to work around this pitfall:    [PRE13]js    Note
    that non-decimal integer literals don’t have this pitfall:    [PRE14]js    ####
    [18.2.4 Underscores (`_`) as separators in number literals ^(ES2021)](#numeric-separator-number-literals)    Grouping
    digits to make long numbers more readable has a long tradition. For example:    *   In
    1825, London had 1,335,000 inhabitants. *   The distance between Earth and Sun
    is 149,600,000 km.    Since ES2021, we can use underscores as separators in number
    literals:    [PRE15]js    With other bases, grouping is important, too:    [PRE16]js    We
    can also use the separator in fractions and exponents:    [PRE17]js    ##### [18.2.4.1 Where
    can we put separators?](#where-can-we-put-separators)    The locations of separators
    are restricted in two ways:    *   We can only put underscores between two digits.
    Therefore, all of the following number literals are illegal:                    [PRE18]js
    `_1464301  // valid variable name!` `1464301_`  `` `0_b111111000` `0b_111111000`
    `` [PRE19]js           [PRE20]`js[PRE21]js[PRE22]js[PRE23][PRE24][PRE25]js const
    obj = { a: 1 }; ++obj.a; assert.equal(obj.a, 2);  [PRE26]js const arr = [ 4 ];
    arr[0]++; assert.deepEqual(arr, [5]);  [PRE27]js assert.equal(Number(123.45),
    123.45);  `assert.equal(Number(''''), 0);` `assert.equal(Number(''\n 123.45 \t''),
    123.45);` `assert.equal(Number(''xyz''), NaN);`  `` `assert.equal(Number(-123n),
    -123);` ``  [PRE28]js[PRE29]js[PRE30][PRE31] In the last line, we use the comparison
    quirk to detect `NaN`.    ##### [18.5.1.2 Finding `NaN` in Arrays](#finding-nan-in-arrays)    Some
    Array methods can’t find `NaN`:    [PRE32]js    Others can:    [PRE33]js    Alas,
    there is no simple rule of thumb. We have to check for each method how it handles
    `NaN`.    #### [18.5.2 Error value: `Infinity`](#error-value-infinity)    When
    is the error value `Infinity` returned?    `Infinity` is returned if a number
    is too large:    [PRE34]js    `Infinity` is returned if there is a division by
    zero:    [PRE35]js    ##### [18.5.2.1 `Infinity` as a default value](#infinity-as-a-default-value)    `Infinity`
    is larger than all other numbers (except `NaN`), making it a good default value:    [PRE36]js   [PRE37]
    This explains the following result:    [PRE38]    ##### [18.5.2.2 Checking for
    `Infinity`](#checking-for-infinity)    These are two common ways of checking if
    a value `x` is `Infinity`:    [PRE39]   [PRE40][PRE41]``js[PRE42]  [PRE43][PRE44]js     >
    0.00000012.toString() // with exponent     ''1.2e-7''      `> 0.00000012.toFixed(10)
    // no exponent`     `''0.0000001200''`     `> 0.00000012.toFixed()`     `''0''`      [PRE45]js`
    If the number is 10^(21) or greater, even `.toFixed()` uses an exponent:    [PRE46]js
    [PRE47]` *   `Number.prototype.toPrecision(precision?)` ES3               *   Works
    like `.toString()`, but `precision` specifies how many digits should be shown
    overall.     *   If `precision` is missing, `.toString()` is used.          [PRE48]
    `> 1234..toPrecision(5)` `''1234.0''`  `` `> 1.234.toPrecision(3)` `''1.23''`
    `` [PRE49]          [PRE50]` [PRE51] *   `Number.prototype.toString(radix=10)`
    ES1                    Returns a string representation of the number.                    By
    default, we get a base 10 numeral as a result:                    [PRE52]js                    If
    we want the numeral to have a different base, we can specify it via `radix`:                    [PRE53]js           [PRE54]`js
    [PRE55]js`` [PRE56]js[PRE57][PRE58][PRE59][PRE60]js[PRE61]js` [PRE62]`js`` [PRE63]`js[PRE64][PRE65][PRE66]
    [PRE67][PRE68][PRE69][PRE70][PRE71]`` [PRE72][PRE73][PRE74] [PRE75]`js[PRE76]`'
  prefs: []
  type: TYPE_NORMAL
