["```ts\nconst pair = (x) => [x, x];\nconst result = pair('abc');\nassert.deepEqual(\n result, ['abc', 'abc']\n);\n\n```", "```ts\ntype Pair<T> = [T, T];\ntype Result = Pair<'abc'>;\ntype _ = Assert<Equal<\n Result, ['abc', 'abc']\n>>;\n\n```", "```ts\ntype TIsAny<T> = [T, 2] extends [1, T] ? true : false;\ntype _ = [\n Assert<Equal<\n TIsAny<any>, true\n >>,\n Assert<Equal<\n TIsAny<unknown>, false\n >>,\n Assert<Equal<\n TIsAny<never>, false\n >>,\n Assert<Equal<\n TIsAny<1>, false\n >>,\n Assert<Equal<\n TIsAny<2>, false\n >>,\n];\n\n```", "```ts\ntype TIsAny<T> = 0 extends (1 & T) ? true : false;\n\n```", "```ts\n    type _X = Assert<Equal<\n     1 & any,\n     any\n    >>;\n\n    ```", "```ts\ntype TMutuallyAssignable<X, Y> =\n X extends Y\n ? (Y extends X ? true : false)\n : false\n;\ntype _ = [\n Assert<Equal<\n TMutuallyAssignable<'hello', 'hello'>, // (A)\n true\n >>,\n Assert<Equal<\n TMutuallyAssignable<'yes', 'no'>, // (B)\n false\n >>,\n Assert<Equal<\n TMutuallyAssignable<string, 'yes'>, // (C)\n false\n >>,\n Assert<Equal<\n TMutuallyAssignable<'a', 'a'|'b'>, // (D)\n true | false\n >>,\n];\n\n```", "```ts\ntype TMutuallyAssignable<X, Y> =\n [X] extends [Y]\n ? ([Y] extends [X] ? true : false)\n : false\n;\n\n```", "```ts\nexport type TMutuallyAssignable<X, Y> =\n [X, Y] extends [Y, X] ? true : false\n ;\n\n```", "```ts\ntype _ = [\n Assert<Equal<\n TMutuallyAssignable<'hello', 'hello'>,\n true\n >>,\n Assert<Equal<\n TMutuallyAssignable<'yes', 'no'>,\n false\n >>,\n Assert<Equal<\n TMutuallyAssignable<string, 'yes'>,\n false\n >>,\n Assert<Equal<\n TMutuallyAssignable<'a', 'a'|'b'>, // (A)\n false\n >>,\n Assert<Equal<\n TMutuallyAssignable<any, 123>, // (B)\n true\n >>,\n];\n\n```", "```ts\ntype TEqual<X, Y> =\n [TIsAny<X>, TIsAny<Y>] extends [true, true] ? true\n : [TIsAny<X>, TIsAny<Y>] extends [false, false] ? MutuallyAssignable<X, Y>\n : false\n ;\n\n```", "```ts\ntype _ = [\n Assert<Equal<\n TEqual<'hello', 'hello'>,\n true\n >>,\n Assert<Equal<\n TEqual<'yes', 'no'>,\n false\n >>,\n Assert<Equal<\n TEqual<string, 'yes'>,\n false\n >>,\n Assert<Equal<\n TEqual<'a', 'a'|'b'>,\n false\n >>,\n Assert<Equal<\n TEqual<any, 123>, // (A)\n false\n >>,\n Assert<Equal<\n TEqual<any, any>, // (B)\n true\n >>,\n];\n\n```", "```ts\nfunction assert(condition) {\n if (condition === false) {\n throw new Error('Assertion failed');\n }\n}\nfunction equal(x, y) {\n return x === y;\n}\n\nassert(equal(3, 4)); // throws an exception\n\n```", "```ts\ntype AssertType1<B extends boolean> = B extends true ? void : fail;\n\n```", "```ts\ntype AssertType2<_B extends true> = void; // (A)\ntype _ = [\n AssertType2<true>, // OK\n // @ts-expect-error: Type 'false' does not satisfy\n // the constraint 'true'.\n AssertType2<false>,\n];\n\n```", "```ts\ntype AssertEqual<X, Y> = Equal<X, Y> extends true ? void : fail;\n\n```", "```ts\ntype TNot<B extends boolean> = [B] extends [true] ? false : true;\n\n```", "```ts\ntype _ = Assert<TNot<Equal<\n 'yes', 'no'\n>>>;\n\n```", "```ts\n/**\n * Is type `Target` assignable from type `Source`?\n */\ntype TAssignable<Target, Source> = [Source] extends [Target] ? true : false;\n\ntype _ = [\n Assert<TAssignable<number, 123>>,\n Assert<TAssignable<123, 123>>,\n\n Assert<Not<TAssignable<123, number>>>,\n Assert<Not<TAssignable<number, 'abc'>>>,\n];\n\n```", "```ts\nassert.throws(\n () => null.prop,\n {\n name: 'TypeError',\n message: \"Cannot read properties of null (reading 'prop')\",\n }\n);\n\n```", "```ts\n// @ts-expect-error: The value 'null' cannot be used here.\nnull.prop;\n\n```", "```ts\nfunction upperCase(str) {\n if (typeof str !== str) {\n throw new TypeError('Not a string: ' + str);\n }\n return str.toUpperCase();\n}\nassert.throws(\n () => upperCase(123),\n {\n name: 'TypeError',\n message: 'Not a string: 123',\n }\n);\n\n```", "```ts\nfunction upperCase(str: string) {\n return str.toUpperCase();\n}\n\n// @ts-expect-error: Argument of type 'number' is not assignable to\n// parameter of type 'string'.\nupperCase(123);\n\n```", "```ts\nconst pair = <T>(x: T): [T, T] => [x, x];\nconst value = pair('a' as const);\ntype _ = Assert<Equal<\n typeof value, ['a', 'a'] // (A)\n>>;\n\n```", "```ts\nassertType<['a', 'a']>(value);\n\n```", "```ts\nfunction assertType<T>(_value: T): void { }\n\n```", "```ts\nconst value_string: string = 'abc';\nconst value_abc: 'abc' = 'abc';\n\nassertType<string>(value_string);\nassertType<string>(value_abc);\n\n```", "```ts\ntype _ = [\n Assert<Equal<\n typeof value_string, string\n >>,\n Assert<Not<Equal<\n typeof value_abc, string\n >>>,\n];\n\n```", "```ts\nconst OutputFormat = {\n html: 'HTML',\n epub: 'EPUB',\n pdf: 'PDF',\n} as const;\ntype OutputFormatType = (typeof OutputFormat)[keyof typeof OutputFormat];\ntype OutputFormatKey = keyof (typeof OutputFormat);\n\n```", "```ts\nconst OUTPUT_FORMAT_KEYS = ['html', 'epub', 'pdf'] as const;\n\n```", "```ts\ntype _ = Assert<Equal<\n (typeof OUTPUT_FORMAT_KEYS)[number], // (A)\n OutputFormatKey\n>>;\n\n```"]