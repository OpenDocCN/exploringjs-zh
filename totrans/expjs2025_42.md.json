["```js\nconst buf = new ArrayBuffer(4); // length in bytes\n  // buf is initialized with zeros\n\n```", "```js\n// Argument: Typed Array or Array-like object\nconst ta1 = new Uint8Array([0, 1, 2]);\n\nconst ta2 = Uint8Array.of(0, 1, 2);\nassert.deepEqual(ta2, ta1);\n\nconst ta3 = Uint8Array.from([0, 1, 2]);\nassert.deepEqual(ta3, ta1);\n\nconst ta4 = new Uint8Array(3); // length of Typed Array\nta4[0] = 0;\nta4[1] = 1;\nta4[2] = 2;\nassert.deepEqual(ta4, ta1);\n\n```", "```js\nconst typedArray = new Int16Array(2); // 2 elements\nassert.equal(typedArray.length, 2);\n\nassert.deepEqual(\n  typedArray.buffer, new ArrayBuffer(4)); // 4 bytes\n\n```", "```js\nconst typedArray = new Int16Array(2);\n\nassert.equal(typedArray[1], 0); // initialized with 0\ntypedArray[1] = 72;\nassert.equal(typedArray[1], 72);\n\n```", "```js\n.set(typedArray: TypedArray, offset=0): void\n.set(arrayLike: ArrayLike<number>, offset=0): void\n\n```", "```js\nfunction concatenate(resultConstructor, ...arrays) {\n  let totalLength = 0;\n  for (const arr of arrays) {\n    totalLength += arr.length;\n  }\n  const result = new resultConstructor(totalLength);\n  let offset = 0;\n  for (const arr of arrays) {\n    result.set(arr, offset);\n    offset += arr.length;\n  }\n  return result;\n}\nassert.deepEqual(\n  concatenate(Uint8Array, Uint8Array.of(1, 2), [3, 4]),\n  Uint8Array.of(1, 2, 3, 4));\n\n```", "```js\n    const ta = new Uint16Array(2); // 2 elements\n    assert.deepEqual(\n      ta.buffer, new ArrayBuffer(4)); // 4 bytes\n\n    ```", "```js\n    assert.deepEqual(new Uint8Array(4), Uint8Array.of(0, 0, 0, 0));\n\n    ```", "```js\n        const ta = new Uint8Array(1);\n\n        ta[0] = 257;\n        assert.equal(ta[0], 1); // 257 % 256 (overflow)\n\n        ta[0] = '2';\n        assert.equal(ta[0], 2);\n\n        ```", "```js\n        const ta = new Uint8Array(1);\n        assert.equal(ta[0], 0);\n        assert.equal(typeof ta[0], 'number');\n\n        ```", "```js\nconst dataView = new DataView(new ArrayBuffer(4));\nassert.equal(dataView.getInt16(0), 0);\nassert.equal(dataView.getUint8(0), 0);\ndataView.setUint8(0, 5);\n\n```", "```js\nfunction setAndGet(typedArray, value) {\n  typedArray[0] = value;\n  return typedArray[0];\n}\n\n```", "```js\nconst uint8 = new Uint8Array(1);\n\n// Highest value of range\nassert.equal(setAndGet(uint8, 255), 255);\n// Positive overflow\nassert.equal(setAndGet(uint8, 256), 0);\n\n// Lowest value of range\nassert.equal(setAndGet(uint8, 0), 0);\n// Negative overflow\nassert.equal(setAndGet(uint8, -1), 255);\n\n```", "```js\nconst int8 = new Int8Array(1);\n\n// Highest value of range\nassert.equal(setAndGet(int8, 127), 127);\n// Positive overflow\nassert.equal(setAndGet(int8, 128), -128);\n\n// Lowest value of range\nassert.equal(setAndGet(int8, -128), -128);\n// Negative overflow\nassert.equal(setAndGet(int8, -129), 127);\n\n```", "```js\nconst uint8c = new Uint8ClampedArray(1);\n\n// Highest value of range\nassert.equal(setAndGet(uint8c, 255), 255);\n// Positive overflow\nassert.equal(setAndGet(uint8c, 256), 255);\n\n// Lowest value of range\nassert.equal(setAndGet(uint8c, 0), 0);\n// Negative overflow\nassert.equal(setAndGet(uint8c, -1), 0);\n\n```", "```js\nconst float16 = new Float16Array(1);\nfunction setAndGet(typedArray, value) {\n  typedArray[0] = value;\n  return typedArray[0];\n}\n\n```", "```js\nassert.equal(\n  setAndGet(float16, 2**15),\n  32768\n);\nassert.equal(\n  setAndGet(float16, 2**16),\n  Infinity\n);\nassert.equal(\n  2**16,\n  65536 // float64\n);\n\n```", "```js\nassert.equal(\n  setAndGet(float16, -(2**15)),\n  -32768\n);\nassert.equal(\n  setAndGet(float16, -(2**16)),\n  -Infinity\n);\nassert.equal(\n  -(2**16),\n  -65536 // float64\n);\n\n```", "```js\nassert.equal(\n  setAndGet(float16, 2**-24),\n  5.960464477539063e-8\n);\nassert.equal(\n  setAndGet(float16, 2**-25),\n  0,\n);\nassert.equal(\n  2**-25,\n  2.9802322387695312e-8 // float64\n);\n\n```", "```js\n.from<S>(\n  source: Iterable<S>|ArrayLike<S>,\n  mapfn?: S => ElementType, thisArg?: any)\n  : «ElementType»Array\n\n```", "```js\nassert.deepEqual(\n  Uint16Array.from([0, 1, 2]),\n  Uint16Array.of(0, 1, 2));\n\n```", "```js\nassert.deepEqual(\n  Uint16Array.from(Uint8Array.of(0, 1, 2)),\n  Uint16Array.of(0, 1, 2));\n\n```", "```js\nassert.deepEqual(\n  Uint16Array.from({0:0, 1:1, 2:2, length: 3}),\n  Uint16Array.of(0, 1, 2));\n\n```", "```js\nconst typedArray = Int8Array.of(127, 126, 125);\nassert.deepEqual(\n  Int16Array.from(typedArray, x => x * 2),\n  Int16Array.of(254, 252, 250));\n\nassert.deepEqual(\n  Int16Array.from(typedArray).map(x => x * 2),\n  Int16Array.of(254, 252, 250)); // OK\nassert.deepEqual(\n  Int16Array.from(typedArray.map(x => x * 2)),\n  Int16Array.of(-2, -4, -6)); // wrong\n\n```", "```js\nassert.deepEqual(\n  Int8Array.from(Int16Array.of(254, 252, 250), x => x / 2),\n  Int8Array.of(127, 126, 125));\n\nassert.deepEqual(\n  Int8Array.from(Int16Array.of(254, 252, 250).map(x => x / 2)),\n  Int8Array.of(127, 126, 125)); // OK\nassert.deepEqual(\n  Int8Array.from(Int16Array.of(254, 252, 250)).map(x => x / 2),\n  Int8Array.of(-1, -2, -3)); // wrong\n\n```", "```js\nconst ui8 = Uint8Array.of(0, 1, 2);\nfor (const byte of ui8) {\n  console.log(byte);\n}\n\n```", "```js\n0\n1\n2\n\n```", "```js\nconst ta1 = new Uint8Array([0, 1, 2]);\nconst ta2 = Uint8Array.from([0, 1, 2]);\nassert.deepEqual(ta1, ta2);\n\n```", "```js\nassert.deepEqual(\n  [...Uint8Array.of(0, 1, 2)], [0, 1, 2]\n);\nassert.deepEqual(\n  Array.from(Uint8Array.of(0, 1, 2)), [0, 1, 2]\n);\n\n```", "```js\nconst textEncoder = new TextEncoder();\nfunction stringToUtf8(str) {\n  return textEncoder.encode(str);\n}\n\nassert.deepEqual(\n  stringToUtf8('abc'),\n  Uint8Array.of(97, 98, 99)\n);\n\n```", "```js\nconst textDecoder = new TextDecoder();\nfunction utf8ToString(bytes) {\n  return textDecoder.decode(bytes);\n}\n\nassert.deepEqual(\n  utf8ToString(Uint8Array.of(97, 98, 99)),\n  'abc'\n);\n\n```", "```js\n    new ArrayBuffer(byteLength: number, options?: {maxByteLength?: number})\n\n    ```", "```js\nconst resizableArrayBuffer = new ArrayBuffer(16, {maxByteLength: 32});\nassert.equal(\n  resizableArrayBuffer.resizable, true\n);\n\nconst fixedArrayBuffer = new ArrayBuffer(16);\nassert.equal(\n  fixedArrayBuffer.resizable, false\n);\n\n```", "```js\nnew «TypedArray»(\n  buffer: ArrayBuffer | SharedArrayBuffer,\n  byteOffset?: number,\n  length?: number\n)\n\n```", "```js\nconst buf = new ArrayBuffer(2, {maxByteLength: 4});\n// `tarr1` starts at offset 0 (`length` is undefined)\nconst tarr1 = new Uint8Array(buf);\n// `tarr2` starts at offset 2 (`length` is undefined)\nconst tarr2 = new Uint8Array(buf, 2);\n\nassert.equal(\n  tarr1.length, 2\n);\nassert.equal(\n  tarr2.length, 0\n);\n\nbuf.resize(4);\n\nassert.equal(\n  tarr1.length, 4\n);\nassert.equal(\n  tarr2.length, 2\n);\n\n```", "```js\nconst buf = new ArrayBuffer(4, {maxByteLength: 4});\nconst tarr = new Uint8Array(buf, 2, 2);\nassert.equal(\n  tarr.length, 2\n);\nbuf.resize(3);\n// `tarr` is now partially out of bounds\nassert.equal(\n  tarr.length, 0\n);\nassert.equal(\n  tarr.byteLength, 0\n);\nassert.equal(\n  tarr.byteOffset, 0\n);\nassert.equal(\n  tarr[0], undefined\n);\nassert.throws(\n  () => tarr.at(0),\n  {\n    name: 'TypeError',\n    message: 'Cannot perform %TypedArray%.prototype.at '\n      + 'on a detached ArrayBuffer',\n  }\n);\n\n```", "```js\nconst original = new ArrayBuffer(16);\nconst clone = structuredClone(original, {transfer: [original]});\n\nassert.equal(\n  original.byteLength, 0\n);\n\nassert.equal(\n  clone.byteLength, 16\n);\n\n```", "```js\nassert.equal(\n  original.detached, true\n);\nassert.equal(\n  clone.detached, false\n);\n\n```", "```js\nconst original = new ArrayBuffer(16);\nconst transferred = original.transfer();\n\nassert.equal(\n  original.detached, true\n);\nassert.equal(\n  transferred.detached, false\n);\n\n```", "```js\nasync function validateAndWriteSafeAndFast(arrayBuffer) {\n  const owned = arrayBuffer.transfer();\n\n  // We have `owned` and no one can access its data via\n  // `arrayBuffer` now because the latter is detached:\n  assert.equal(\n    arrayBuffer.detached, true\n  );\n\n  // `await` pauses this function – which gives external\n  // code the opportunity to access `arrayBuffer`.\n  await validate(owned);\n  await fs.writeFile(\"data.bin\", owned);\n}\n\n```", "```js\n> const arrayBuffer = new ArrayBuffer(16);\n> const typedArray = new Uint8Array(arrayBuffer);\n> arrayBuffer.transfer();\n\n```", "```js\n> typedArray.length\n0\n> typedArray.byteLength\n0\n> typedArray.byteOffset\n0\n\n```", "```js\n> typedArray[0]\nundefined\n> typedArray[0] = 128\n128\n\n```", "```js\n> typedArray.at(0)\nTypeError: Cannot perform %TypedArray%.prototype.at\non a detached ArrayBuffer\n\n```", "```js\n> const arrayBuffer = new ArrayBuffer(16);\n> const dataView = new DataView(arrayBuffer);\n> arrayBuffer.transfer();\n> dataView.byteLength\nTypeError: Cannot perform get DataView.prototype.byteLength\non a detached ArrayBuffer\n> dataView.getUint8(0)\nTypeError: Cannot perform DataView.prototype.getUint8\non a detached ArrayBuffer\n\n```", "```js\n> const arrayBuffer = new ArrayBuffer(16);\n> arrayBuffer.transfer();\n> new Uint8Array(arrayBuffer)\nTypeError: Cannot perform Construct on a detached ArrayBuffer\n> new DataView(arrayBuffer)\nTypeError: Cannot perform DataView constructor on a detached ArrayBuffer\n\n```", "```js\n    const arr = [6, 7];\n    arr[-1] = 5;\n    assert.deepEqual(\n      Object.keys(arr), ['0', '1', '-1']);\n\n    ```", "```js\n    const tarr = Uint8Array.of(6, 7);\n    tarr[-1] = 5;\n    assert.deepEqual(\n      Object.keys(tarr), ['0', '1']);\n\n    ```", "```js\n    const ui8 = Uint8Array.of(0, 1, 2);\n    assert.deepEqual(ui8.slice(-1), Uint8Array.of(2));\n\n    ```", "```js\n    const dataView = new DataView(new ArrayBuffer(4));\n    assert.throws(\n      () => dataView.getUint8(-1),\n      {\n        name: 'RangeError',\n        message: 'Offset is outside the bounds of the DataView',\n      });\n\n    ```", "```js\n    new ArrayBuffer(\n      byteLength: number,\n      options?: { // ES2024\n        maxByteLength?: number\n      }\n    )\n\n    ```", "```js\n    > ArrayBuffer.isView(new Uint8Array())\n    true\n    > ArrayBuffer.isView(new DataView(new ArrayBuffer()))\n    true\n\n    ```", "```js\n    > Object.getPrototypeOf(Uint8Array).name\n    'TypedArray'\n\n    ```", "```js\n    // BigInt64Array: bigint instead of number\n    TypedArray.from<T>(\n      iterableOrArrayLike: Iterable<number> | ArrayLike<number>\n    ): TypedArray<T>\n    TypedArray.from<S, T>(\n      iterableOrArrayLike: Iterable<S> | ArrayLike<S>,\n      mapFunc: (v: S, k: number) => T, thisArg?: any\n    ): TypedArray<T>\n\n    ```", "```js\n    assert.deepEqual(\n      Uint16Array.from([0, 1, 2]),\n      Uint16Array.of(0, 1, 2));\n\n    ```", "```js\n    assert.deepEqual(\n      Int16Array.from(Int8Array.of(127, 126, 125), x => x * 2),\n      Int16Array.of(254, 252, 250));\n\n    ```", "```js\n    // BigInt64Array: bigint instead of number\n    TypedArray.of<T>(\n      ...items: Array<number>\n    ): TypedArray<T>\n\n    ```", "```js\n    assert.deepEqual(\n      Int16Array.of(-1234, 5, 67),\n      new Int16Array([-1234, 5, 67]) );\n\n    ```", "```js\n    > new Uint32Array(new ArrayBuffer(4)).length\n    1\n\n    ```", "```js\n    > new Uint32Array(new ArrayBuffer(4)).byteLength\n    4\n\n    ```", "```js\n    length * «ElementType»Array.BYTES_PER_ELEMENT\n\n    ```", "```js\n    > Uint8Array.BYTES_PER_ELEMENT\n    1\n    > Int16Array.BYTES_PER_ELEMENT\n    2\n    > Float64Array.BYTES_PER_ELEMENT\n    8\n\n    ```"]