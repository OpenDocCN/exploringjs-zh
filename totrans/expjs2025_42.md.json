["```js\nconst buf = new ArrayBuffer(4); // length in bytes\n // buf is initialized with zeros\n\n```", "```js\n// Argument: Typed Array or Array-like object\nconst ta1 = new Uint8Array([0, 1, 2]);\n `const ta2 = Uint8Array.of(0, 1, 2);`\n`assert.deepEqual(ta2, ta1);`\n ```", "```js \n```", "```js```", "````js````", "```js```", "````js``` ````", "```````js```````", "`````` #### [35.2.2 The wrapped ArrayBuffer](#the-wrapped-arraybuffer)    ```js const typedArray = new Int16Array(2); // 2 elements assert.equal(typedArray.length, 2);  `assert.deepEqual(`  `typedArray.buffer, new ArrayBuffer(4)); // 4 bytes`  ```   ```js``````", "```````js```````", "``` const typedArray = new Int16Array(2);  `assert.equal(typedArray[1], 0); // initialized with 0` `typedArray[1] = 72;` `assert.equal(typedArray[1], 72);`  ```", "``````js``````", "```````js```` #### [35.2.4 Concatenating Typed Arrays](#concatenating-typed-arrays)    Typed Arrays don’t have a method `.concat()`, like normal Arrays do. The workaround is to use their overloaded method `.set()`:    ```js .set(typedArray: TypedArray, offset=0): void .set(arrayLike: ArrayLike<number>, offset=0): void  ```    It copies the existing `typedArray` or `arrayLike` into the receiver, at index `offset`. `TypedArray` is an internal abstract superclass of all concrete Typed Array classes (that doesn’t actually have a global name).    The following function uses that method to copy zero or more Typed Arrays (or Array-like objects) into an instance of `resultConstructor`:    ```js function concatenate(resultConstructor, ...arrays) {  let totalLength = 0;  for (const arr of arrays) {  totalLength += arr.length;  }  const result = new resultConstructor(totalLength);  let offset = 0;  for (const arr of arrays) {  result.set(arr, offset);  offset += arr.length;  }  return result; } assert.deepEqual(  concatenate(Uint8Array, Uint8Array.of(1, 2), [3, 4]),  Uint8Array.of(1, 2, 3, 4));  ```    #### [35.2.5 Typed Arrays vs. normal Arrays](#typed-arrays-vs-arrays)    Typed Arrays are much like normal Arrays: they have a `.length`, elements can be accessed via the bracket operator `[]`, and they have most of the standard Array methods. They differ from normal Arrays in the following ways:    *   Typed Arrays have buffers. The elements of a Typed Array `ta` are not stored in `ta`, they are stored in an associated ArrayBuffer that can be accessed via `ta.buffer`:                    ```js     const ta = new Uint16Array(2); // 2 elements     assert.deepEqual(      ta.buffer, new ArrayBuffer(4)); // 4 bytes          ```           *   Typed Arrays are initialized with zeros:               *   `new Array(4)` creates a normal Array without any elements. It only has four *holes* (indices less than the `.length` that have no associated elements).     *   `new Uint8Array(4)` creates a Typed Array whose four elements are all 0.          ```js     assert.deepEqual(new Uint8Array(4), Uint8Array.of(0, 0, 0, 0));          ```           *   All of the elements of a Typed Array have the same type:               *   Setting elements converts values to that type.                                    ```js         const ta = new Uint8Array(1);          `ta[0] = 257;`         `assert.equal(ta[0], 1); // 257 % 256 (overflow)`          `` `ta[0] = '2';` `assert.equal(ta[0], 2);` ``          ```                       ```js`` ```` *   Getting elements returns numbers or bigints.                    ```js     const ta = new Uint8Array(1);     assert.equal(ta[0], 0);     assert.equal(typeof ta[0], 'number');          ``` ```js` `````  ```js ``*   The `.length` of a Typed Array is derived from its ArrayBuffer and never changes (unless we switch to a different ArrayBuffer).          *   Normal Arrays can have holes; Typed Arrays can’t.`` ```    ```js```````", "```````js`````` ```js```````", "```````js````` ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Converting between strings and UTF-16**    `exercises/typed-arrays/utf-16-conversion_test.mjs`    ### [35.3 Using DataViews](#using-dataviews)    This is how DataViews are used:    ```js const dataView = new DataView(new ArrayBuffer(4)); assert.equal(dataView.getInt16(0), 0); assert.equal(dataView.getUint8(0), 0); dataView.setUint8(0, 5);  ```    ### [35.4 Element types](#typed-array-element-types)     | Element | Typed Array | Bytes | Description | Get/Set |  | | --- | --- | --- | --- | --- | --- | | `Int8` | `Int8Array` | 1 | 8-bit signed integer | `number` | ES6 | | `Uint8` | `Uint8Array` | 1 | 8-bit unsigned int | `number` | ES6 | | (`Uint8C`) | `Uint8ClampedArray` | 1 | 8-bit unsigned int | `number` | ES6 | | `Int16` | `Int16Array` | 2 | 16-bit signed int | `number` | ES6 | | `Uint16` | `Uint16Array` | 2 | 16-bit unsigned int | `number` | ES6 | | `Int32` | `Int32Array` | 4 | 32-bit signed int | `number` | ES6 | | `Uint32` | `Uint32Array` | 4 | 32-bit unsigned int | `number` | ES6 | | `BigInt64` | `BigInt64Array` | 8 | 64-bit signed int | `bigint` | ES2020 | | `BigUint64` | `BigUint64Array` | 8 | 64-bit unsigned int | `bigint` | ES2020 | | `Float16` | `Float16Array` | 2 | 16-bit floating point | `number` | ES2025 | | `Float32` | `Float32Array` | 4 | 32-bit floating point | `number` | ES6 | | `Float64` | `Float64Array` | 8 | 64-bit floating point | `number` | ES6 |      Table 35.1: Element types supported by the Typed Array API.      [Table 35.1](#tbl:typed-array-element-types) lists the available element types. These types (e.g., `Int32`) show up in two locations:    *   In Typed Arrays, they specify the types of the elements. For example, all elements of a `Int32Array` have the type `Int32`. The element type is the only aspect of Typed Arrays that differs.           *   In DataViews, they are the lenses through which they access their ArrayBuffers when we use methods such as `.getInt32()` and `.setInt32()`.              The element type `Uint8C` is special: it is not supported by `DataView` and only exists to enable `Uint8ClampedArray`. This Typed Array is used by the `canvas` element (where it replaces `CanvasPixelArray`) and should otherwise be avoided. The only difference between `Uint8C` and `Uint8` is how overflow is handled (as explained next).    Typed Arrays and Array Buffers use numbers and bigints to import and export values:    *   The types `BigInt64` and `BigUint64` are handled via bigints. For example, setters accept bigints and getters return bigints.           *   All other element types are handled via numbers.              #### [35.4.1 Handling overflow and underflow](#handling-overflow-underflow)    ##### [35.4.1.1 Handling overflow for integers](#handling-overflow-for-integers)    Normally, when a value is out of the range of the element type, modulo arithmetic is used to convert it to a value within range. For signed and unsigned integers that means that:    *   The highest value plus one is converted to the lowest value (0 for unsigned integers). *   The lowest value minus one is converted to the highest value.    The following function helps illustrate how conversion works:    ```js function setAndGet(typedArray, value) {  typedArray[0] = value;  return typedArray[0]; }  ```    Modulo conversion for unsigned 8-bit integers:    ```js const uint8 = new Uint8Array(1);  `// Highest value of range` `assert.equal(setAndGet(uint8, 255), 255);` `// Positive overflow` `assert.equal(setAndGet(uint8, 256), 0);`  `` `// Lowest value of range` `assert.equal(setAndGet(uint8, 0), 0);` `// Negative overflow` `assert.equal(setAndGet(uint8, -1), 255);` ``  ```   ```js```````", "```````js```` ```js```````", "```````js``` Modulo conversion for signed 8-bit integers:    ``` const int8 = new Int8Array(1);  `// Highest value of range` `assert.equal(setAndGet(int8, 127), 127);` `// Positive overflow` `assert.equal(setAndGet(int8, 128), -128);`  `` `// Lowest value of range` `assert.equal(setAndGet(int8, -128), -128);` `// Negative overflow` `assert.equal(setAndGet(int8, -129), 127);` ``  ```js   ``````js```````", "`````` ```js``````", "```````js` Clamped conversion is different:    *   All negatively overflowing values are converted to the lowest value. *   All positively overflowing values are converted to the highest value.    ``` const uint8c = new Uint8ClampedArray(1);  `// Highest value of range` `assert.equal(setAndGet(uint8c, 255), 255);` `// Positive overflow` `assert.equal(setAndGet(uint8c, 256), 255);`  `` `// Lowest value of range` `assert.equal(setAndGet(uint8c, 0), 0);` `// Negative overflow` `assert.equal(setAndGet(uint8c, -1), 0);` ``  ```js   ``````js```````", "```` ```js````", "```js```", "``` ##### [35.4.1.2 Handling overflow and underflow for floats](#handling-overflow-and-underflow-for-floats)    ```", "```    If there is positive overflow (positive numbers being too far away from zero), the result is positive infinity:    ```", "```    If there is negative overflow (negative numbers being too far away from zero), the result is negative infinity:    ```", "```    Arithmetic underflow means that a number has too many digits after a binary point (it is too close to an integer). If that happens, digits that can’t be represented are omitted:    ```", "```    Useful related function: [`Math.f16round(x)`](ch_math.html#qref-Math.f16round) rounds `x` to 16 bits (within a 64-bit float).    #### [35.4.2 Endianness](#typed-arrays-endianness)    Whenever a type (such as `Uint16`) is stored as a sequence of multiple bytes, *endianness* matters:    *   Big endian: the most significant byte comes first. For example, the `Uint16` value 0x4321 is stored as two bytes – first 0x43, then 0x21. *   Little endian: the least significant byte comes first. For example, the `Uint16` value 0x4321 is stored as two bytes – first 0x21, then 0x43.    Endianness tends to be fixed per CPU architecture and consistent across native APIs. Typed Arrays are used to communicate with those APIs, which is why their endianness follows the endianness of the platform and can’t be changed.    On the other hand, the endianness of protocols and binary files varies, but is fixed per format, across platforms. Therefore, we must be able to access data with either endianness. DataViews serve this use case and let us specify endianness when we get or set a value.    [Quoting Wikipedia on Endianness](https://en.wikipedia.org/wiki/Endianness):    *   Big-endian representation is the most common convention in data networking; fields in the protocols of the Internet protocol suite, such as IPv4, IPv6, TCP, and UDP, are transmitted in big-endian order. For this reason, big-endian byte order is also referred to as network byte order. *   Little-endian storage is popular for microprocessors in part due to significant historical influence on microprocessor designs by Intel Corporation.    Other orderings are also possible. Those are generically called *middle-endian* or *mixed-endian*.    ### [35.5 Converting to and from Typed Arrays](#converting-to-and-from-typed-arrays)    In this section, `«ElementType»Array` stands for `Int8Array`, `Uint8Array`, etc. `ElementType` is `Int8`, `Uint8`, etc.    #### [35.5.1 The static method `«ElementType»Array.from()`](#the-static-method-elementtypearrayfrom)    This method has the type signature:    ```", "```    `.from()` converts `source` into an instance of `this` (a Typed Array).    For example, normal Arrays are iterable and can be converted with this method:    ```", "```    Typed Arrays are also iterable:    ```", "```    `source` can also be [an *Array-like object*](ch_arrays.html#array-like-objects):    ```", "```    The optional `mapfn` lets us transform the elements of `source` before they become elements of the result. Why perform the two steps *mapping* and *conversion* in one go? Compared to mapping separately via `.map()`, there are two advantages:    1.  No intermediate Array or Typed Array is needed. 2.  When converting between Typed Arrays with different precisions, less can go wrong.    Read on for an explanation of the second advantage.    ##### [35.5.1.1 Pitfall: mapping while converting between Typed Array types](#pitfall-mapping-while-converting-between-typed-array-types)    The static method `.from()` can optionally both map and convert between Typed Array types. Less can go wrong if we use that method.    To see why that is, let us first convert a Typed Array to a Typed Array with a higher precision. If we use `.from()` to map, the result is automatically correct. Otherwise, we must first convert and then map.    ```", "```   ```", "```````js````` If we go from a Typed Array to a Typed Array with a lower precision, mapping via `.from()` produces the correct result. Otherwise, we must first map and then convert.    ```js assert.deepEqual(  Int8Array.from(Int16Array.of(254, 252, 250), x => x / 2),  Int8Array.of(127, 126, 125));  `assert.deepEqual(`  `Int8Array.from(Int16Array.of(254, 252, 250).map(x => x / 2)),`  `Int8Array.of(127, 126, 125)); // OK` `assert.deepEqual(`  `Int8Array.from(Int16Array.of(254, 252, 250)).map(x => x / 2),`  `Int8Array.of(-1, -2, -3)); // wrong`  ```   ```js```````", "```` The problem is that if we map via `.map()`, then input type and output type are the same. In contrast, `.from()` goes from an arbitrary input type to an output type that we specify via its receiver.    #### [35.5.2 Typed Arrays are iterable](#typed-arrays-are-iterable)    Typed Arrays are [iterable](ch_sync-iteration.html#ch_sync-iteration). That means that we can use the `for-of` loop and other iteration-based mechanisms:    ```js const ui8 = Uint8Array.of(0, 1, 2); for (const byte of ui8) {  console.log(byte); }  ```    Output:    ```js 0 1 2  ```    ArrayBuffers and DataViews are not iterable.    #### [35.5.3 Converting Typed Arrays to and from normal Arrays](#converting-typed-arrays-to-and-from-normal-arrays)    To convert a normal Array to a Typed Array, we pass it to:    *   A Typed Array constructor – which accepts Typed Arrays, iterable values and Array-like objects. *   `«ElementType»Array.from()` – which accepts iterable values and Array-like values.    For example:    ```js const ta1 = new Uint8Array([0, 1, 2]); const ta2 = Uint8Array.from([0, 1, 2]); assert.deepEqual(ta1, ta2);  ```    To convert a Typed Array to a normal Array, we can use `Array.from()` or spreading (because Typed Arrays are iterable):    ```js assert.deepEqual(  [...Uint8Array.of(0, 1, 2)], [0, 1, 2] ); assert.deepEqual(  Array.from(Uint8Array.of(0, 1, 2)), [0, 1, 2] );  ```    #### [35.5.4 Converting a `Uint8Array` (UTF-8) to and from a string](#uint8array-to-from-string)    The class `TextEncoder` and `TextDecoder` are not part of ECMAScript proper but supported by all major JavaScript platforms (browsers, Node.js, etc.). Therefore, we can use them to convert between `Uint8Array` and string.    Converting a string to UTF-8-encoded bytes:    ```js const textEncoder = new TextEncoder(); function stringToUtf8(str) {  return textEncoder.encode(str); }  `assert.deepEqual(`  `stringToUtf8('abc'),`  `Uint8Array.of(97, 98, 99)` `);`  ```   ```js````", "```js```", "``` const textDecoder = new TextDecoder(); function utf8ToString(bytes) {  return textDecoder.decode(bytes); }  `assert.deepEqual(`  `utf8ToString(Uint8Array.of(97, 98, 99)),`  `'abc'` `);`  ```", "``````js``````", "```js     new ArrayBuffer(byteLength: number, options?: {maxByteLength?: number})          ```", "```js const resizableArrayBuffer = new ArrayBuffer(16, {maxByteLength: 32}); assert.equal(  resizableArrayBuffer.resizable, true );  `const fixedArrayBuffer = new ArrayBuffer(16);` `assert.equal(`  `fixedArrayBuffer.resizable, false` `);`  ```", "```js```", "````js` #### [35.6.2 How Typed Arrays react to changing ArrayBuffer sizes](#how-typed-arrays-react-to-changing-arraybuffer-sizes)    This is what constructors of Typed Arrays look like:    ``` new «TypedArray»(  buffer: ArrayBuffer | SharedArrayBuffer,  byteOffset?: number,  length?: number )  ```js    If `length` is `undefined` then the `.length` and `.byteLength` of the Typed Array instance automatically tracks the length of a resizable `buffer`:    ``` const buf = new ArrayBuffer(2, {maxByteLength: 4}); // `tarr1` starts at offset 0 (`length` is undefined) const tarr1 = new Uint8Array(buf); // `tarr2` starts at offset 2 (`length` is undefined) const tarr2 = new Uint8Array(buf, 2);  `assert.equal(`  `tarr1.length, 2` `);` `assert.equal(`  `tarr2.length, 0` `);`  ```js `buf.resize(4);`  `` `assert.equal(`  `tarr1.length, 4` `);` `assert.equal(`  `tarr2.length, 2` `);` `` ```  ```js   ````", "```` ```js````", "```js const buf = new ArrayBuffer(4, {maxByteLength: 4}); const tarr = new Uint8Array(buf, 2, 2); assert.equal(  tarr.length, 2 ); buf.resize(3); // `tarr` is now partially out of bounds assert.equal(  tarr.length, 0 ); assert.equal(  tarr.byteLength, 0 ); assert.equal(  tarr.byteOffset, 0 ); assert.equal(  tarr[0], undefined ); assert.throws(  () => tarr.at(0),  {  name: 'TypeError',  message: 'Cannot perform %TypedArray%.prototype.at '  + 'on a detached ArrayBuffer',  } );  ```", "```js const original = new ArrayBuffer(16); const clone = structuredClone(original, {transfer: [original]});  `assert.equal(`  `original.byteLength, 0` `);`  `` `assert.equal(`  `clone.byteLength, 16` `);` ``  ```", "```js```", "```js```", "```js assert.equal(  original.detached, true ); assert.equal(  clone.detached, false );  ```", "```js const original = new ArrayBuffer(16); const transferred = original.transfer();  `assert.equal(`  `original.detached, true` `);` `assert.equal(`  `transferred.detached, false` `);`  ```", "```js```", "``` async function validateAndWriteSafeAndFast(arrayBuffer) {  const owned = arrayBuffer.transfer();  ``// We have `owned` and no one can access its data via``  ``// `arrayBuffer` now because the latter is detached:``  `assert.equal(`  `arrayBuffer.detached, true`  `);`  ```", "```  ```", "````` ```js`#### [35.7.5 How does detaching an ArrayBuffer affect its wrappers?](#how-does-detaching-an-arraybuffer-affect-its-wrappers)    ##### [35.7.5.1 Typed Arrays with detached ArrayBuffers](#typed-arrays-with-detached-arraybuffers)    Preparation:    ``` > const arrayBuffer = new ArrayBuffer(16); > const typedArray = new Uint8Array(arrayBuffer); > arrayBuffer.transfer();  ```js    Lengths and offsets are all zero:    ``` > typedArray.length 0 > typedArray.byteLength 0 > typedArray.byteOffset 0  ```js    Getting elements returns `undefined`; setting elements fails silently:    ``` > typedArray[0] undefined > typedArray[0] = 128 128  ```js    All element-related methods throw exceptions:    ``` > typedArray.at(0) TypeError: Cannot perform %TypedArray%.prototype.at on a detached ArrayBuffer  ```js    ##### [35.7.5.2 DataViews with detached ArrayBuffers](#dataviews-with-detached-arraybuffers)    All data-related methods of DataViews throw:    ``` > const arrayBuffer = new ArrayBuffer(16); > const dataView = new DataView(arrayBuffer); > arrayBuffer.transfer(); > dataView.byteLength TypeError: Cannot perform get DataView.prototype.byteLength on a detached ArrayBuffer > dataView.getUint8(0) TypeError: Cannot perform DataView.prototype.getUint8 on a detached ArrayBuffer  ```js    ##### [35.7.5.3 We can’t create new wrappers with detached ArrayBuffers](#we-cant-create-new-wrappers-with-detached-arraybuffers)    ``` > const arrayBuffer = new ArrayBuffer(16); > arrayBuffer.transfer(); > new Uint8Array(arrayBuffer) TypeError: Cannot perform Construct on a detached ArrayBuffer > new DataView(arrayBuffer) TypeError: Cannot perform DataView constructor on a detached ArrayBuffer  ```js    #### [35.7.6 `ArrayBuffer.prototype.transferToFixedLength()`](#arraybufferprototypetransfertofixedlength)    This method rounds out the API: It transfers and converts a resizable ArrayBuffer to one with a fixed length. That may free up memory that was held in preparation for growth.    ### [35.8 Quick references: indices vs. offsets](#typed-arrays-indices-offsets)    In preparation for the quick references on ArrayBuffers, Typed Arrays, and DataViews, we need learn the differences between indices and offsets:    *   Indices for the bracket operator `[ ]`: We can only use non-negative indices (starting at 0).                    In normal Arrays, writing to negative indices creates properties:                    ```     const arr = [6, 7];     arr[-1] = 5;     assert.deepEqual(      Object.keys(arr), ['0', '1', '-1']);          ```js                    In Typed Arrays, writing to negative indices is ignored:                    ```     const tarr = Uint8Array.of(6, 7);     tarr[-1] = 5;     assert.deepEqual(      Object.keys(tarr), ['0', '1']);          ```js           *   Indices for methods of ArrayBuffers, Typed Arrays, and DataViews: Every index can be negative. If it is, it is added to the length of the entity to produce the actual index. Therefore, `-1` refers to the last element, `-2` to the second-last, etc. Methods of normal Arrays work the same way.                    ```     const ui8 = Uint8Array.of(0, 1, 2);     assert.deepEqual(ui8.slice(-1), Uint8Array.of(2));          ```js           *   Offsets passed to methods of Typed Arrays and DataViews: must be non-negative – for example:                    ```     const dataView = new DataView(new ArrayBuffer(4));     assert.throws(      () => dataView.getUint8(-1),      {      name: 'RangeError',      message: 'Offset is outside the bounds of the DataView',      });          ```js              Whether a parameter is an index or an offset can only be determined by looking at documentation; there is no simple rule.    ### [35.9 Quick reference: ArrayBuffers](#quick-reference-arraybuffers)    ArrayBuffers store binary data, which is meant to be accessed via Typed Arrays and DataViews.    #### [35.9.1 `new ArrayBuffer()`](#new-arraybuffer)    *   `new ArrayBuffer(byteLength, options?)` ES6                    ```     new ArrayBuffer(      byteLength: number,      options?: { // ES2024      maxByteLength?: number      }     )          ```js                    Invoking this constructor via `new` creates an instance whose capacity is `length` bytes. Each of those bytes is initially 0.                    If `options.maxByteLength` is provided, the ArrayBuffer can be resized. Otherwise, it has a fixed length.              #### [35.9.2 `ArrayBuffer.*`](#arraybuffer)    *   `ArrayBuffer.isView(arg)` ES6                    Returns `true` if `arg` is a *view* for an ArrayBuffer (i.e., if it is a Typed Array or a DataView).                    ```     > ArrayBuffer.isView(new Uint8Array())     true     > ArrayBuffer.isView(new DataView(new ArrayBuffer()))     true          ```js              #### [35.9.3 `ArrayBuffer.prototype.*`: getting and slicing](#arraybufferprototype-getting-and-slicing)    *   `get ArrayBuffer.prototype.byteLength` ES6                    Returns the capacity of this ArrayBuffer in bytes.           *   `ArrayBuffer.prototype.slice(startIndex=0, endIndex=this.byteLength)` ES6                    Creates a new ArrayBuffer that contains the bytes of this ArrayBuffer whose indices are greater than or equal to `startIndex` and less than `endIndex`. `start` and `endIndex` can be negative (see [“Quick references: indices vs. offsets” (§35.8)](#typed-arrays-indices-offsets)).              #### [35.9.4 `ArrayBuffer.prototype.*`: resizing](#arraybufferprototype-resizing)    *   `ArrayBuffer.prototype.resize(newByteLength)` ES2024                    Changes the size of this ArrayBuffer. For more information, see [“Resizing ArrayBuffers ^(ES2024)” (§35.6)](#resizing-array-buffers).           *   `get ArrayBuffer.prototype.resizable` ES2024                    Returns `true` if this ArrayBuffer is resizable and `false` if it is not.           *   `get ArrayBuffer.prototype.maxByteLength` ES2024                    Returns `options.maxByteLength` if it was provided to the constructor. Otherwise, it returns `this.byteLength`.              ### [35.10 Quick reference: Typed Arrays](#quick-reference-typed-arrays)    The properties of the various Typed Array objects are introduced in two steps:    1.  `TypedArray`: First, we look at the abstract superclass of all Typed Array classes (which was shown in the class diagram [at the beginning of this chapter](#fig:typed_arrays_class_diagram)). That superclass is called `TypedArray` but it does not have a global name in JavaScript:                    ```     > Object.getPrototypeOf(Uint8Array).name     'TypedArray'          ```js           2.  `«ElementType»Array`: The concrete Typed Array classes are called `Uint8Array`, `Int16Array`, `Float16Array`, etc. These are the classes that we use via `new`, `.of`, and `.from()`.              #### [35.10.1 `TypedArray.*`](#typedarray)    Both static `TypedArray` methods are inherited by its subclasses (`Uint8Array`, etc.). Therefore, we can use these methods via the subclasses, which are concrete and can have direct instances.    *   `TypedArray.from(iterableOrArrayLike, mapFunc?)` ES6                    ```     // BigInt64Array: bigint instead of number     TypedArray.from<T>(      iterableOrArrayLike: Iterable<number> | ArrayLike<number>     ): TypedArray<T>     TypedArray.from<S, T>(      iterableOrArrayLike: Iterable<S> | ArrayLike<S>,      mapFunc: (v: S, k: number) => T, thisArg?: any     ): TypedArray<T>          ```js                    Converts an iterable (including Arrays and Typed Arrays) or [an Array-like object](ch_arrays.html#array-like-objects) to an instance of the Typed Array class.                    ```     assert.deepEqual(      Uint16Array.from([0, 1, 2]),      Uint16Array.of(0, 1, 2));          ```js                    The optional `mapFunc` lets us transform the elements of `source` before they become elements of the result.                    ```     assert.deepEqual(      Int16Array.from(Int8Array.of(127, 126, 125), x => x * 2),      Int16Array.of(254, 252, 250));          ```js           *   `TypedArray.of(...items)` ES6                    ```     // BigInt64Array: bigint instead of number     TypedArray.of<T>(      ...items: Array<number>     ): TypedArray<T>          ```js                    Creates a new instance of the Typed Array class whose elements are `items` (coerced to the element type).                    ```     assert.deepEqual(      Int16Array.of(-1234, 5, 67),      new Int16Array([-1234, 5, 67]) );          ```js              #### [35.10.2 `TypedArray.prototype.*`](#typedarrayprototype)    Indices accepted by Typed Array methods can be negative (they work like traditional Array methods that way). Offsets must be non-negative. For details, see [“Quick references: indices vs. offsets” (§35.8)](#typed-arrays-indices-offsets).    ##### [35.10.2.1 Properties specific to Typed Arrays](#properties-specific-to-typed-arrays)    The following properties are specific to Typed Arrays; normal Arrays don’t have them:    *   `get TypedArray.prototype.buffer` ES6                    Returns the ArrayBuffer backing this Typed Array.           *   `get TypedArray.prototype.length` ES6                    Returns the length in elements of this Typed Array’s buffer.                    ```     > new Uint32Array(new ArrayBuffer(4)).length     1          ```js           *   `get TypedArray.prototype.byteLength` ES6                    Returns the size in bytes of this Typed Array’s buffer.                    ```     > new Uint32Array(new ArrayBuffer(4)).byteLength     4          ```js           *   `get TypedArray.prototype.byteOffset` ES6                    Returns the offset where this Typed Array “starts” inside its ArrayBuffer.           *   `TypedArray.prototype.set(typedArrayOrArrayLike, offset=0)` ES6                    Copies all elements of the first parameter to this Typed Array. The element at index 0 of the parameter is written to index `offset` of this Typed Array (etc.). For more information on Array-like objects, see [“Array-like objects” (§34.5)](ch_arrays.html#array-like-objects).           *   `TypedArray.prototype.subarray(startIndex=0, endIndex=this.length)` ES6                    Returns a new Typed Array that has the same buffer as this Typed Array, but a (generally) smaller range. If `startIndex` is non-negative then the first element of the resulting Typed Array is `this[startIndex]`, the second `this[startIndex+1]` (etc.). If `startIndex` in negative, it is converted appropriately.              ##### [35.10.2.2 Array methods](#array-methods)    The following methods are basically the same as the methods of normal Arrays (the ECMAScript versions specify when the methods were added to Arrays – Typed Arrays didn’t exist in ECMAScript before ES6):    *   `TypedArray.prototype.at(index)` ^(ES2022, R) *   `TypedArray.prototype.copyWithin(target, start, end=this.length)` ^(ES6, W) *   `TypedArray.prototype.entries()` ^(ES6, R) *   `TypedArray.prototype.every(predicate, thisArg?)` ^(ES5, R) *   `TypedArray.prototype.fill(start=0, end=this.length)` ^(ES6, W) *   `TypedArray.prototype.filter(predicate, thisArg?)` ^(ES5, R) *   `TypedArray.prototype.find(predicate, thisArg?)` ^(ES6, R) *   `TypedArray.prototype.findIndex(predicate, thisArg?)` ^(ES6, R) *   `TypedArray.prototype.findLast(predicate, thisArg?)` ^(ES2023, R) *   `TypedArray.prototype.findLastIndex(predicate, thisArg?)` ^(ES2023, R) *   `TypedArray.prototype.forEach(callback)` ^(ES5, R) *   `TypedArray.prototype.includes(searchElement, fromIndex)` ^(ES2016, R) *   `TypedArray.prototype.indexOf(searchElement, fromIndex)` ^(ES5, R) *   `TypedArray.prototype.join(separator = ',')` ^(ES1, R) *   `TypedArray.prototype.keys()` ^(ES6, R) *   `TypedArray.prototype.lastIndexOf(searchElement, fromIndex)` ^(ES5, R) *   `TypedArray.prototype.map(callback, thisArg?)` ^(ES5, R) *   `TypedArray.prototype.reduce(callback, initialValue?)` ^(ES5, R) *   `TypedArray.prototype.reduceRight(callback, initialValue?)` ^(ES5, R) *   `TypedArray.prototype.reverse()` ^(ES1, W) *   `TypedArray.prototype.slice(start?, end?)` ^(ES3, R) *   `TypedArray.prototype.some(predicate, thisArg?)` ^(ES5, R) *   `TypedArray.prototype.sort(compareFunc?)` ^(ES1, W) *   `TypedArray.prototype.toLocaleString()` ^(ES3, R) *   `TypedArray.prototype.toReversed()` ^(ES2023, R) *   `TypedArray.prototype.toSorted(compareFunc?)` ^(ES2023, R) *   `TypedArray.prototype.toSpliced(start?, deleteCount?, ...items)` ^(ES2023, R) *   `TypedArray.prototype.toString()` ^(ES1, R) *   `TypedArray.prototype.values()` ^(ES6, R) *   `TypedArray.prototype.with(index, value)` ^(ES2023, R)    For details on how these methods work, see [“Quick reference: `Array`” (§34.18)](ch_arrays.html#quickref-Array).    #### [35.10.3 `new «ElementType»Array()`](#new-elementtypearray)    Each Typed Array constructor has a name that follows the pattern `«ElementType»Array`, where `«ElementType»` is one of the element types listed in [Table 35.1](#tbl:typed-array-element-types). That means there are 12 constructors for Typed Arrays:    *   `Int8Array`, `Uint8Array`, `Uint8ClampedArray` *   `Int16Array`, `Uint16Array` *   `Int32Array`, `Uint32Array` *   `BigInt64Array`, `BigUint64Array` *   `Float16Array`, `Float32Array`, `Float64Array`    Each constructor has several *overloaded* versions – it behaves differently depending on how many arguments it receives and what their types are:    *   `new «ElementType»Array(length=0)`                    Creates a new `«ElementType»Array` with the given `length` and the appropriate buffer. The buffer’s size in bytes is:                    ```     length * «ElementType»Array.BYTES_PER_ELEMENT          ```js           *   `new «ElementType»Array(source: TypedArray)`                    Creates a new instance of `«ElementType»Array` whose elements have the same values as the elements of `source`, but coerced to `ElementType`.           *   `new «ElementType»Array(source: Iterable<number>)`               *   `BigInt64Array`, `BigUint64Array`: `bigint` instead of `number`                       *   Creates a new instance of `«ElementType»Array` whose elements have the same values as the items of `source`, but coerced to `ElementType`. For more information on iterables, see [“Synchronous iteration ^(ES6)” (§32)](ch_sync-iteration.html#ch_sync-iteration).                   *   `new «ElementType»Array(source: ArrayLike<number>)`               *   `BigInt64Array`, `BigUint64Array`: `bigint` instead of `number`                       *   Creates a new instance of `«ElementType»Array` whose elements have the same values as the elements of `source`, but coerced to `ElementType`. For more information on Array-like objects, see [“Array-like objects” (§34.5)](ch_arrays.html#array-like-objects).                   *   `new «ElementType»Array(buffer: ArrayBuffer, byteOffset=0, length=0)`                    Creates a new `«ElementType»Array` whose buffer is `buffer`. It starts accessing the buffer at the given `byteOffset` and will have the given `length`. Note that `length` counts elements of the Typed Array (with 1–8 bytes each), not bytes.              #### [35.10.4 `«ElementType»Array.*`](#elementtypearray)    *   `«ElementType»Array.BYTES_PER_ELEMENT: number`                    Counts how many bytes are needed to store a single element:                    ```     > Uint8Array.BYTES_PER_ELEMENT     1     > Int16Array.BYTES_PER_ELEMENT     2     > Float64Array.BYTES_PER_ELEMENT     8          ```js              #### [35.10.5 `«ElementType»Array.prototype.*`](#elementtypearrayprototype)    *   `«ElementType»Array.prototype.BYTES_PER_ELEMENT: number`                    The same as `«ElementType»Array.BYTES_PER_ELEMENT`.              ### [35.11 Quick reference: DataViews](#quick-reference-dataviews)    #### [35.11.1 `new DataView()`](#new-dataview)    *   `new DataView(arrayBuffer, byteOffset?, byteLength?)` ES6                    Creates a new DataView whose data is stored in the ArrayBuffer `buffer`. By default, the new DataView can access all of `buffer`. The last two parameters allow us to change that.              #### [35.11.2 `DataView.prototype.*`](#dataviewprototype)    In the remainder of this section, `«ElementType»` refers to either:    *   `Int8`, `Uint8` *   `Int16`, `Uint16` *   `Int32`, `Uint32` *   `BigInt64`, `BigUint64` *   `Float16`, `Float32`, `Float64`    These are the properties of `DataView.prototype`:    *   `get DataView.prototype.buffer` ES6                    Returns the ArrayBuffer of this DataView.           *   `get DataView.prototype.byteLength` ES6                    Returns how many bytes can be accessed by this DataView.           *   `get DataView.prototype.byteOffset` ES6                    Returns at which offset this DataView starts accessing the bytes in its buffer.           *   `DataView.prototype.get«ElementType»(byteOffset, littleEndian=false)` ES6                    Returns:               *   `BigInt64`, `BigUint64`: `bigint`     *   All other element types: `number`          Reads a value from the buffer of this DataView.           *   `DataView.prototype.set«ElementType»(byteOffset, value, littleEndian=false)` ES6                    Type of `value`:               *   `BigInt64`, `BigUint64`: `bigint`     *   All other element types: `number`          Writes `value` to the buffer of this DataView.```` ```js`` `````", "``````js` ``````", "``````js``` ``````", "```` ```js````", "```js` ```", "```js```", "``` ```", "```````js``` ``````js```````", "``````js``````", "``````js``````", "``` ```", "```js```", "````js````", "```js```", "````js````", "```js` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "``````js``````", "```````js` ``````js```````", "```````js`` ``````js```````", "```````js``` ``````js```````", "```````js```` ```js```````", "```````js```````", "``````js``````", "```````js`````` ```js```````", "```````js```````"]