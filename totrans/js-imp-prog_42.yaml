- en: 35 Sets (Set)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/impatient-js/ch_sets.html](https://exploringjs.com/impatient-js/ch_sets.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 35.1 [Using Sets](ch_sets.html#using-sets)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 35.1.1 [Creating Sets](ch_sets.html#creating-sets)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 35.1.2 [Adding, removing, checking membership](ch_sets.html#adding-removing-checking-membership)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 35.1.3 [Determining the size of a Set and clearing it](ch_sets.html#determining-the-size-of-a-set-and-clearing-it)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 35.1.4 [Iterating over Sets](ch_sets.html#iterating-over-sets-1)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 35.2 [Examples of using Sets](ch_sets.html#examples-of-using-sets)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 35.2.1 [Removing duplicates from an Array](ch_sets.html#removing-duplicates-from-an-array)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 35.2.2 [Creating a set of Unicode characters (code points)](ch_sets.html#creating-a-set-of-unicode-characters-code-points)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 35.3 [What Set elements are considered equal?](ch_sets.html#what-set-elements-are-considered-equal)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 35.4 [Missing Set operations](ch_sets.html#missing-set-operations)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 35.4.1 [Union (`a` ∪ `b`)](ch_sets.html#union-a-b)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 35.4.2 [Intersection (`a` ∩ `b`)](ch_sets.html#intersection-a-b)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 35.4.3 [Difference (`a` \ `b`)](ch_sets.html#difference-a-b)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 35.4.4 [Mapping over Sets](ch_sets.html#mapping-over-sets)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 35.4.5 [Filtering Sets](ch_sets.html#filtering-sets)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '35.5 [Quick reference: `Set<T>`](ch_sets.html#quickref-sets)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 35.5.1 [Constructor](ch_sets.html#constructor-1)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '35.5.2 [`Set<T>.prototype`: single Set elements](ch_sets.html#sett.prototype-single-set-elements)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '35.5.3 [`Set<T>.prototype`: all Set elements](ch_sets.html#sett.prototype-all-set-elements)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '35.5.4 [`Set<T>.prototype`: iterating and looping](ch_sets.html#sett.prototype-iterating-and-looping)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 35.5.5 [Symmetry with `Map`](ch_sets.html#symmetry-with-map)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '35.6 [FAQ: Sets](ch_sets.html#faq-sets)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 35.6.1 [Why do Sets have a `.size`, while Arrays have a `.length`?](ch_sets.html#why-do-sets-have-a-.size-while-arrays-have-a-.length)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before ES6, JavaScript didn’t have a data structure for sets. Instead, two
    workarounds were used:'
  prefs: []
  type: TYPE_NORMAL
- en: The keys of an object were used as a set of strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays were used as sets of arbitrary values. The downside is that checking
    *membership* (if an Array contains a value) is slower.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since ES6, JavaScript has the data structure `Set`, which can contain arbitrary
    values and performs membership checks quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 35.1 Using Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 35.1.1 Creating Sets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are three common ways of creating Sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you can use the constructor without any parameters to create an empty
    Set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, you can pass an iterable (e.g., an Array) to the constructor. The iterated
    values become elements of the new Set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Third, the `.add()` method adds elements to a Set and is chainable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 35.1.2 Adding, removing, checking membership
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`.add()` adds an element to a Set.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`.has()` checks if an element is a member of a Set.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`.delete()` removes an element from a Set.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 35.1.3 Determining the size of a Set and clearing it
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`.size` contains the number of elements in a Set.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`.clear()` removes all elements of a Set.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 35.1.4 Iterating over Sets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sets are iterable and the `for-of` loop works as you’d expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Sets preserve *insertion order*. That is, elements are always
    iterated over in the order in which they were added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that Sets are iterable, you can use [`Array.from()`](ch_arrays.html#Array.from)
    to convert them to Arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 35.2 Examples of using Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 35.2.1 Removing duplicates from an Array
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Converting an Array to a Set and back, removes duplicates from the Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 35.2.2 Creating a set of Unicode characters (code points)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Strings are iterable and can therefore be used as parameters for `new Set()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 35.3 What Set elements are considered equal?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with Map keys, Set elements are compared similarly to `===`, with the exception
    of `NaN` being equal to itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As with `===`, two different objects are never considered equal (and there
    is no way to change that at the moment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 35.4 Missing Set operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sets are missing several common operations. Such an operation can usually be
    implemented by:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting the input Sets to Arrays by [spreading into Array literals](ch_arrays.html#spreading-into-array-literals).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing the operation on Arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting the result to a Set and returning it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 35.4.1 Union (`a` ∪ `b`)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Computing the union of two Sets `a` and `b` means creating a Set that contains
    the elements of both `a` and `b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 35.4.2 Intersection (`a` ∩ `b`)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Computing the intersection of two Sets `a` and `b` means creating a Set that
    contains those elements of `a` that are also in `b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 35.4.3 Difference (`a` \ `b`)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Computing the difference between two Sets `a` and `b` means creating a Set that
    contains those elements of `a` that are not in `b`. This operation is also sometimes
    called *minus* (−).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 35.4.4 Mapping over Sets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sets don’t have a method `.map()`. But we can borrow the one that Arrays have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 35.4.5 Filtering Sets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can’t directly `.filter()` Sets, so we need to use the corresponding Array
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '35.5 Quick reference: `Set<T>`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 35.5.1 Constructor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`new Set<T>(values?: Iterable<T>)` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you don’t provide the parameter `values`, then an empty Set is created.
    If you do, then the iterated values are added as elements to the Set. For example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '35.5.2 `Set<T>.prototype`: single Set elements'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`.add(value: T): this` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds `value` to this Set. This method returns `this`, which means that it can
    be chained.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.delete(value: T): boolean` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removes `value` from this Set. Returns `true` if something was deleted and `false`,
    otherwise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.has(value: T): boolean` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checks whether `value` is in this Set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '35.5.3 `Set<T>.prototype`: all Set elements'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`get .size: number` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns how many elements there are in this Set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.clear(): void` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removes all elements from this Set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '35.5.4 `Set<T>.prototype`: iterating and looping'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`.values(): Iterable<T>` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns an iterable over all elements of this Set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`[Symbol.iterator](): Iterable<T>` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default way of iterating over Sets. Same as `.values()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.forEach(callback: (value: T, key: T, theSet: Set<T>) => void, thisArg?: any):
    void` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feeds each element of this Set to `callback()`. `value` and `key` both contain
    the current element. This redundancy was introduced so that this `callback` has
    the same type signature as the `callback` of `Map.prototype.forEach()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can specify the `this` of `callback` via `thisArg`. If you omit it, `this`
    is `undefined`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 35.5.5 Symmetry with `Map`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following two methods mainly exist so that Sets and Maps have similar interfaces.
    Each Set element is handled as if it were a Map entry whose key and value are
    both the element.
  prefs: []
  type: TYPE_NORMAL
- en: '`Set.prototype.entries(): Iterable<[T,T]>` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set.prototype.keys(): Iterable<T>` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.entries()` enables you to convert a Set to a Map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '35.6 FAQ: Sets'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 35.6.1 Why do Sets have a `.size`, while Arrays have a `.length`?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The answer to this question is given in [§33.6.4 “Why do Maps have a `.size`,
    while Arrays have a `.length`?”](ch_maps.html#collection-size-vs-length).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz**'
  prefs: []
  type: TYPE_NORMAL
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  prefs: []
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/37)'
  prefs: []
  type: TYPE_NORMAL
