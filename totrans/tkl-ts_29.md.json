["```ts\ntype ObjectLiteralType = {\n first: 1,\n second: 2,\n};\n\n// %inferred-type: \"first\" | \"second\"\ntype Result = keyof ObjectLiteralType; // (A)\n```", "```ts\ntype ObjectLiteralType = {\n prop1: string,\n prop2: number,\n};\n\ninterface InterfaceType {\n prop1: string;\n prop2: number;\n}\n\ntype TupleType = [boolean, bigint];\n\n//::::: Nullish types and literal types :::::\n// Same syntax as values, but they are all types!\n\ntype UndefinedType = undefined;\ntype NullType = null;\n\ntype BooleanLiteralType = true;\ntype NumberLiteralType = 12.34;\ntype BigIntLiteralType = 1234n;\ntype StringLiteralType = 'abc';\n```", "```ts\ntype Wrap<T> = [T];\n```", "```ts\n// %inferred-type: [string]\ntype Wrapped = Wrap<string>;\n```", "```ts\ntype A = 'a' | 'b' | 'c';\ntype B = 'b' | 'c' | 'd';\n\n// %inferred-type: \"a\" | \"b\" | \"c\" | \"d\"\ntype Union = A | B;\n```", "```ts\ntype A =\n | 'a'\n | 'b'\n | 'c'\n;\n```", "```ts\ntype Obj = {\n first: 1,\n second: 2,\n};\n\n// %inferred-type: \"first\" | \"second\"\ntype Result = keyof Obj;\n```", "```ts\ntype ObjectTypeA = {\n propA: bigint,\n sharedProp: string,\n}\ntype ObjectTypeB = {\n propB: boolean,\n sharedProp: string,\n}\n\ntype Union = ObjectTypeA | ObjectTypeB;\n\nfunction func(arg: Union) {\n // string\n arg.sharedProp; // (A) OK\n // @ts-expect-error: Property 'propB' does not exist on type 'Union'.\n arg.propB; // error\n\n if ('propB' in arg) { // (B) type guard\n // ObjectTypeB\n arg;\n\n // boolean\n arg.propB;\n }\n}\n```", "```ts\ntype A = 'a' | 'b' | 'c';\ntype B = 'b' | 'c' | 'd';\n\n// %inferred-type: \"b\" | \"c\"\ntype Intersection = A & B;\n```", "```ts\ntype Obj1 = { prop1: boolean };\ntype Obj2 = { prop2: number };\ntype Both = {\n prop1: boolean,\n prop2: number,\n};\n\n// Type Obj1 & Obj2 is assignable to type Both\n// %inferred-type: true\ntype IntersectionHasBothProperties = IsAssignableTo<Obj1 & Obj2, Both>;\n```", "```ts\ninterface Named {\n name: string;\n}\nfunction addName<Obj extends object>(obj: Obj, name: string)\n : Obj & Named // (A)\n{\n const namedObj = obj as (Obj & Named);\n namedObj.name = name;\n return namedObj;\n}\n\nconst obj = {\n last: 'Doe',\n};\n\n// %inferred-type: { last: string; } & Named\nconst namedObj = addName(obj, 'Jane');\n```", "```ts\n\u00abType2\u00bb extends \u00abType1\u00bb ? \u00abThenType\u00bb : \u00abElseType\u00bb\n```", "```ts\ntype Wrap<T> = T extends { length: number } ? [T] : T;\n\n// %inferred-type: [string]\ntype A = Wrap<string>;\n\n// %inferred-type: RegExp\ntype B = Wrap<RegExp>;\n```", "```ts\ntype IsAssignableTo<A, B> = A extends B ? true : false;\n\n// Type `123` is assignable to type `number`\n// %inferred-type: true\ntype Result1 = IsAssignableTo<123, number>;\n\n// Type `number` is not assignable to type `123`\n// %inferred-type: false\ntype Result2 = IsAssignableTo<number, 123>;\n```", "```ts\ntype Wrap<T> = T extends { length: number } ? [T] : T;\n\n// %inferred-type: boolean | [string] | [number[]]\ntype C1 = Wrap<boolean | string | number[]>;\n\n// Equivalent:\ntype C2 = Wrap<boolean> | Wrap<string> | Wrap<number[]>;\n```", "```ts\ntype AlwaysWrap<T> = T extends any ? [T] : [T];\n\n// %inferred-type: [\"a\"] | [\"d\"] | [{ a: 1; } & { b: 2; }]\ntype Result = AlwaysWrap<'a' | ({ a: 1 } & { b: 2 }) | 'd'>;\n```", "```ts\n// %inferred-type: \"a\" | \"b\"\ntype Result = 'a' | 'b' | never;\n```", "```ts\ntype DropNumbers<T> = T extends number ? never : T;\n\n// %inferred-type: \"a\" | \"b\"\ntype Result1 = DropNumbers<1 | 'a' | 2 | 'b'>;\n```", "```ts\ntype KeepNumbers<T> = T extends number ? T : never;\n\n// %inferred-type: 1 | 2\ntype Result2 = KeepNumbers<1 | 'a' | 2 | 'b'>;\n```", "```ts\n/**\n * Exclude from T those types that are assignable to U\n */\ntype Exclude<T, U> = T extends U ? never : T;\n\n// %inferred-type: \"a\" | \"b\"\ntype Result1 = Exclude<1 | 'a' | 2 | 'b', number>;\n\n// %inferred-type: \"a\" | 2\ntype Result2 = Exclude<1 | 'a' | 2 | 'b', 1 | 'b' | 'c'>;\n```", "```ts\n/**\n * Extract from T those types that are assignable to U\n */\ntype Extract<T, U> = T extends U ? T : never;\n\n// %inferred-type: 1 | 2\ntype Result1 = Extract<1 | 'a' | 2 | 'b', number>;\n\n// %inferred-type: 1 | \"b\"\ntype Result2 = Extract<1 | 'a' | 2 | 'b', 1 | 'b' | 'c'>;\n```", "```ts\ntype LiteralTypeName<T> =\n T extends undefined ? \"undefined\" :\n T extends null ? \"null\" :\n T extends boolean ? \"boolean\" :\n T extends number ? \"number\" :\n T extends bigint ? \"bigint\" :\n T extends string ? \"string\" :\n never;\n\n// %inferred-type: \"bigint\"\ntype Result1 = LiteralTypeName<123n>;\n\n// %inferred-type: \"string\" | \"number\" | \"boolean\"\ntype Result2 = LiteralTypeName<true | 1 | 'a'>;\n```", "```ts\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;\n```", "```ts\ntype Syncify<Interf> = {\n [K in keyof Interf]:\n Interf[K] extends (...args: any[]) => Promise<infer Result>\n ? (...args: Parameters<Interf[K]>) => Result\n : Interf[K];\n};\n\n// Example:\n\ninterface AsyncInterface {\n compute(arg: number): Promise<boolean>;\n createString(): Promise<String>;\n}\n\ntype SyncInterface = Syncify<AsyncInterface>;\n // type SyncInterface = {\n //     compute: (arg: number) => boolean;\n //     createString: () => String;\n // }\n```", "```ts\n// %inferred-type: { a: number; b: number; c: number; }\ntype Result = {\n [K in 'a' | 'b' | 'c']: number\n};\n```", "```ts\n/**\n * From T, pick a set of properties whose keys are in the union K\n */\ntype Pick<T, K extends keyof T> = {\n [P in K]: T[P];\n};\n```", "```ts\ntype ObjectLiteralType = {\n eeny: 1,\n meeny: 2,\n miny: 3,\n moe: 4,\n};\n\n// %inferred-type: { eeny: 1; miny: 3; }\ntype Result = Pick<ObjectLiteralType, 'eeny' | 'miny'>;\n```", "```ts\n/**\n * Construct a type with the properties of T except for those in type K.\n */\ntype Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;\n```", "```ts\n    // %inferred-type: string | number | symbol\n    type Result = keyof any;\n    ```", "```ts\ntype ObjectLiteralType = {\n eeny: 1,\n meeny: 2,\n miny: 3,\n moe: 4,\n};\n\n// %inferred-type: { meeny: 2; moe: 4; }\ntype Result = Omit<ObjectLiteralType, 'eeny' | 'miny'>;\n```", "```ts\ntype Obj = {\n 0: 'a',\n 1: 'b',\n prop0: 'c',\n prop1: 'd',\n};\n\n// %inferred-type: 0 | 1 | \"prop0\" | \"prop1\"\ntype Result = keyof Obj;\n```", "```ts\n// number | \"0\" | \"1\" | \"2\" | \"length\" | \"pop\" | \"push\" | \u00b7\u00b7\u00b7\ntype Result = keyof ['a', 'b', 'c'];\n```", "```ts\n// %inferred-type: never\ntype Result = keyof {};\n```", "```ts\ntype A = { a: number, shared: string };\ntype B = { b: number, shared: string };\n\n// %inferred-type: \"a\" | \"b\" | \"shared\"\ntype Result1 = keyof (A & B);\n\n// %inferred-type: \"shared\"\ntype Result2 = keyof (A | B);\n```", "```ts\ntype Obj = {\n 0: 'a',\n 1: 'b',\n prop0: 'c',\n prop1: 'd',\n};\n\n// %inferred-type: \"a\" | \"b\"\ntype Result1 = Obj[0 | 1];\n\n// %inferred-type: \"c\" | \"d\"\ntype Result2 = Obj['prop0' | 'prop1'];\n\n// %inferred-type: \"a\" | \"b\" | \"c\" | \"d\"\ntype Result3 = Obj[keyof Obj];\n```", "```ts\ntype Obj = {\n [key: string]: RegExp, // (A)\n};\n\n// %inferred-type: string | number\ntype KeysOfObj = keyof Obj;\n\n// %inferred-type: RegExp\ntype ValuesOfObj = Obj[string];\n```", "```ts\ntype Tuple = ['a', 'b', 'c', 'd'];\n\n// %inferred-type:  \"a\" | \"b\"\ntype Elements = Tuple[0 | 1];\n```", "```ts\ntype MyType = { prop: 1 } | { prop: 2 } | { prop: 3 };\n\n// %inferred-type: 1 | 2 | 3\ntype Result1 = MyType['prop'];\n\n// Equivalent:\ntype Result2 =\n | { prop: 1 }['prop']\n | { prop: 2 }['prop']\n | { prop: 3 }['prop']\n;\n```", "```ts\nconst str = 'abc';\n\n// %inferred-type: \"abc\"\ntype Result = typeof str;\n```", "```ts\nconst func = (x: number) => x + x;\n// %inferred-type: (x: number) => number\ntype Result = typeof func;\n```"]