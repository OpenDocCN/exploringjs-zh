["```js\n// single-line comment\n `/*`\n`Comment with`\n`multiple lines`\n`*/` \n```", "```js```", "````js````", "```js```", "```js true false  ```", "```js 1.141 -123  ```", "```js 17n -49n  ```", "```js 'abc' \"abc\" `String with interpolated values: ${256} and ${true}`  ```", "```js assert.equal(7 + 1, 8);  ```", "```js // Printing a value to standard out (another method call) console.log('Hello!');  `// Printing error information to standard error` `console.error('Something went wrong!');`  ```", "```js```", "````js````", "```js```", "``` // Operators for booleans assert.equal(true && false, false); // And assert.equal(true || false, true); // Or  `// Operators for numbers` `assert.equal(3 + 4, 7);` `assert.equal(5 - 1, 4);` `assert.equal(3 * 4, 12);` `assert.equal(10 / 4, 2.5);`  ```", "``` `// Operators for strings` `assert.equal('a' + 'b', 'ab');` `assert.equal('I see ' + 3 + ' monkeys', 'I see 3 monkeys');`  `` `// Comparison operators` `assert.equal(3 < 4, true);` `assert.equal(3 <= 4, true);` `assert.equal('abc' === 'abc', true);` `assert.equal('abc' !== 'def', true);` `` ```", "````  ```js   ````", "```````js`````` ```js```````", "```````js` JavaScript also has a `==` comparison operator. I recommend to avoid it – why is explained in [“Recommendation: always use strict equality” (§15.5.3)](ch_operators.html#recommendation-always-strict-equality).    ##### [9.1.1.6 Declaring variables](#declaring-variables)    `const` creates *immutable variable bindings*: Each variable must be initialized immediately and we can’t assign a different value later. However, the value itself may be mutable and we may be able to change its contents. In other words: `const` does not make values immutable.    ``` // Declaring and initializing x (immutable binding): const x = 8;  `// Would cause a TypeError:` `// x = 9;`  ```js   ``````js```````", "```` `let` creates *mutable variable bindings*:    ```js // Declaring y (mutable binding): let y;  `// We can assign a different value to y:` `y = 3 * 5;`  `` `// Declaring and initializing z:` `let z = 3 * 5;` ``  ```   ```js````", "```js```", "``` ```", "```````js````` ##### [9.1.1.7 Ordinary function declarations](#ordinary-function-declarations)    ```js // add1() has the parameters a and b function add1(a, b) {  return a + b; } // Calling function add1() assert.equal(add1(5, 2), 7);  ```    ##### [9.1.1.8 Arrow function expressions](#arrow-function-expressions)    Arrow function expressions are used especially as arguments of function calls and method calls:    ```js const add2 = (a, b) => { return a + b }; // Calling function add2() assert.equal(add2(5, 2), 7);  `// Equivalent to add2:` `const add3 = (a, b) => a + b;`  ```   ```js```````", "```` The previous code contains the following two arrow functions (the terms *expression* and *statement* are explained [later in this chapter](#statement-vs-expression)):    ```js // An arrow function whose body is a code block (a, b) => { return a + b }  `// An arrow function whose body is an expression` `(a, b) => a + b`  ```   ```js````", "```js```", "``` // Creating a plain object via an object literal const obj = {  first: 'Jane', // property  last: 'Doe', // property  getFullName() { // property (method)  return this.first + ' ' + this.last;  }, };  `// Getting a property value` `assert.equal(obj.first, 'Jane');` `// Setting a property value` `obj.first = 'Janey';`  `` `// Calling the method` `assert.equal(obj.getFullName(), 'Janey Doe');` ``  ```", "``````js``````", "```js```", "````js` ##### [9.1.1.10 Arrays](#arrays)    ``` // Creating an Array via an Array literal const arr = ['a', 'b', 'c']; assert.equal(arr.length, 3);  `// Getting an Array element` `assert.equal(arr[1], 'b');` `// Setting an Array element` `arr[1] = 'β';`  ```js `// Adding an element to an Array:` `arr.push('d');`  `` `assert.deepEqual(`  `arr, ['a', 'β', 'c', 'd']);` `` ```  ```js   ````", "```` ```js````", "```js if (x < 0) {  x = -x; }  ```", "```js const arr = ['a', 'b']; for (const element of arr) {  console.log(element); }  ```", "```js a b  ```", "```js file-tools.mjs main.mjs  ```", "```js export function isTextFilePath(filePath) {  return filePath.endsWith('.txt'); }  ```", "```js // Import whole module as namespace object `path` import * as path from 'node:path'; // Import a single export of module file-tools.mjs import {isTextFilePath} from './file-tools.mjs';  ```", "```js class Person {  constructor(name) {  this.name = name;  }  describe() {  return `Person named ${this.name}`;  }  static logNames(persons) {  for (const person of persons) {  console.log(person.name);  }  } }  `class Employee extends Person {`  `constructor(name, title) {`  `super(name);`  `this.title = title;`  `}`  `describe() {`  `return super.describe() +`  `` ` (${this.title})`; ``  `}` `}`  `` `const jane = new Employee('Jane', 'CTO');` `assert.equal(`  `jane.describe(),`  `'Person named Jane (CTO)');` ``  ```", "```js```", "```js```", "```js function throwsException() {  throw new Error('Problem!'); }  `function catchesException() {`  `try {`  `throwsException();`  `} catch (err) {`  `assert.ok(err instanceof Error);`  `assert.equal(err.message, 'Problem!');`  `}` `}`  ```", "```js```", "``` const if = 123;  // SyntaxError: Unexpected token if  ```", "``` > const obj = { if: 123 }; > obj.if 123  ```", "```     import * as theSpecialLibrary from './the-special-library.mjs';          ```", "``` arr.map((_x, i) => i)  ```", "``` class ValueWrapper {  constructor(value) {  this._value = value;  } }  ```", "``` const x = 123; func();  ```", "``` while (false) {  // ··· } // no semicolon  `function func() {`  `// ···` `} // no semicolon`  ```", "````` However, adding a semicolon after such a statement is not a syntax error – it is interpreted as an empty statement:    ```js // Function declaration followed by empty statement: function func() {  // ··· };  ```    ### [9.2 (Advanced)](#advanced)    All remaining sections of this chapter are advanced.    ### [9.3 Hashbang lines (Unix shell scripts)](#hashbang-lines)    In a Unix shell script, we can add a first line that starts with `#!` to tell Unix which executable should be used to run the script. These two characters have several names, including *hashbang*, *sharp-exclamation*, *sha-bang* (“sha” as in “sharp”) and *shebang*. Otherwise, hashbang lines are treated as comments by most shell scripting languages and JavaScript does so, too. This is a common hashbang line for Node.js:    ```js #!/usr/bin/env node  ```    If we want to pass arguments to `node`, we have to use the `env` option `-S` (to be safe, some Unixes don’t need it):    ```js #!/usr/bin/env -S node --enable-source-maps --no-warnings=ExperimentalWarning  ```    ### [9.4 Identifiers](#identifiers)    #### [9.4.1 Valid identifiers (variable names, etc.)](#valid-identifiers-variable-names-etc)    First character:    *   Unicode letter (including accented characters such as `é` and `ü` and characters from non-latin alphabets, such as `α`) *   `$` *   `_`    Subsequent characters:    *   Legal first characters *   Unicode digits (including Eastern Arabic numerals) *   Some other Unicode marks and punctuations    Examples:    ```js const ε = 0.0001; const строка = ''; let _tmp = 0; const $foo2 = true;  ```    #### [9.4.2 Reserved words](#reserved-words)    Reserved words can’t be variable names, but they can be property names.    All JavaScript *keywords* are reserved words:    > `await` `break` `case` `catch` `class` `const` `continue` `debugger` `default` `delete` `do` `else` `export` `extends` `finally` `for` `function` `if` `import` `in` `instanceof` `let` `new` `return` `static` `super` `switch` `this` `throw` `try` `typeof` `var` `void` `while` `with` `yield`    The following tokens are also keywords, but currently not used in the language:    > `enum` `implements` `package` `protected` `interface` `private` `public`    The following literals are reserved words:    > `true` `false` `null`    Technically, these words are not reserved, but you should avoid them, too, because they effectively are keywords:    > `Infinity` `NaN` `undefined` `async`    You shouldn’t use the names of global variables (`String`, `Math`, etc.) for your own variables and parameters, either.    ### [9.5 Statement vs. expression](#statement-vs-expression)    In this section, we explore how JavaScript distinguishes two kinds of syntactic constructs: *statements* and *expressions*. Afterward, we’ll see that that can cause problems because the same syntax can mean different things, depending on where it is used.    ![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **We pretend there are only statements and expressions**    For the sake of simplicity, we pretend that there are only statements and expressions in JavaScript.    #### [9.5.1 Statements](#statements)    A *statement* is a piece of code that can be executed and performs some kind of action. For example, `if` is a statement:    ```js let myStr; if (myBool) {  myStr = 'Yes'; } else {  myStr = 'No'; }  ```    One more example of a statement: a function declaration.    ```js function twice(x) {  return x + x; }  ```    #### [9.5.2 Expressions](#expressions)    An *expression* is a piece of code that can be *evaluated* to produce a value. For example, the code between the parentheses is an expression:    ```js let myStr = (myBool ? 'Yes' : 'No');  ```    The operator `_?_:_` used between the parentheses is called the *ternary operator*. It is the expression version of the `if` statement.    Let’s look at more examples of expressions. We enter expressions and the REPL evaluates them for us:    ```js > 'ab' + 'cd' 'abcd' > Number('123') 123 > true || false true  ```    #### [9.5.3 What is allowed where?](#what-is-allowed-where)    The current location within JavaScript source code determines which kind of syntactic constructs you are allowed to use:    *   The body of a function must be a sequence of statements:                    ```js     function max(x, y) {      if (x > y) {      return x;      } else {      return y;      }     }          ```           *   The arguments of a function call or a method call must be expressions:                    ```js     console.log('ab' + 'cd', Number('123'));          ```              However, expressions can be used as statements. Then they are called *expression statements*. The opposite is not true: when the context requires an expression, you can’t use a statement.    The following code demonstrates that any expression `bar()` can be either expression or statement – it depends on the context:    ```js function f() {  console.log(bar()); // bar() is expression  bar(); // bar(); is (expression) statement  }  ```    ### [9.6 Ambiguous syntax](#ambiguous-syntax)    JavaScript has several programming constructs that are syntactically ambiguous: the same syntax is interpreted differently, depending on whether it is used in statement context or in expression context. This section explores the phenomenon and the pitfalls it causes.    #### [9.6.1 Same syntax: function declaration and function expression](#same-syntax-function-declaration-and-function-expression)    A *function declaration* is a statement:    ```js function id(x) {  return x; }  ```    A *function expression* is an expression (right-hand side of `=`):    ```js const id = function me(x) {  return x; };  ```    #### [9.6.2 Same syntax: object literal and block](#same-syntax-object-literal-and-block)    In the following code, `{}` is an *object literal*: an expression that creates an empty object.    ```js const obj = {};  ```    This is an empty code block (a statement):    ```js { }  ```    #### [9.6.3 Disambiguation](#disambiguation)    The ambiguities are only a problem in statement context: If the JavaScript parser encounters ambiguous syntax, it doesn’t know if it’s a plain statement or an expression statement. For example:    *   If a statement starts with `function`: Is it a function declaration or a function expression? *   If a statement starts with `{`: Is it an object literal or a code block?    To resolve the ambiguity, statements starting with `function` or `{` are never interpreted as expressions. If you want an expression statement to start with either one of these tokens, you must wrap it in parentheses:    ```js (function (x) { console.log(x) })('abc');  ```    Output:    ```js abc  ```    In this code:    1.  We first create a function via a function expression:                    ```js     function (x) { console.log(x) }          ```           2.  Then we invoke that function: `('abc')`              The code fragment shown in (1) is only interpreted as an expression because we wrap it in parentheses. If we didn’t, we would get a syntax error because then JavaScript expects a function declaration and complains about the missing function name. Additionally, you can’t put a function call immediately after a function declaration.    Later in this book, we’ll see more examples of pitfalls caused by syntactic ambiguity:    *   [Assigning via object destructuring](ch_destructuring.html#assigning-via-object-destructuring) *   [Returning an object literal from an arrow function](ch_callables.html#returning-object-literal-from-arrow-function)    ### [9.7 Semicolons](#semicolons)    #### [9.7.1 Rule of thumb for semicolons](#rule-of-thumb-for-semicolons)    Each statement is terminated by a semicolon:    ```js const x = 3; someFunction('abc'); i++;  ```    except statements ending with blocks:    ```js function foo() {  // ··· } if (y > 0) {  // ··· }  ```    The following case is slightly tricky:    ```js const func = () => {}; // semicolon!  ```    The whole `const` declaration (a statement) ends with a semicolon, but inside it, there is an arrow function expression. That is, it’s not the statement per se that ends with a curly brace; it’s the embedded arrow function expression. That’s why there is a semicolon at the end.    #### [9.7.2 Semicolons: control statements](#semicolons-control-statements)    The body of a control statement is itself a statement. For example, this is the syntax of the `while` loop:    ```js while (condition)  statement  ```    The body can be a single statement:    ```js while (a > 0) a--;  ```    But blocks are also statements and therefore legal bodies of control statements:    ```js while (a > 0) {  a--; }  ```    If you want a loop to have an empty body, your first option is an empty statement (which is just a semicolon):    ```js while (processNextItem() > 0);  ```    Your second option is an empty block:    ```js while (processNextItem() > 0) {}  ```    ### [9.8 Automatic semicolon insertion (ASI)](#automatic-semicolon-insertion-asi)    While I recommend to always write semicolons, most of them are optional in JavaScript. The mechanism that makes this possible is called *automatic semicolon insertion* (ASI). In a way, it corrects syntax errors.    ASI works as follows. Parsing of a statement continues until there is either:    *   A semicolon *   A line terminator followed by an illegal token    In other words, ASI can be seen as inserting semicolons at line breaks. The next subsections cover the pitfalls of ASI.    #### [9.8.1 ASI triggered unexpectedly](#asi-triggered-unexpectedly)    The good news about ASI is that – if you don’t rely on it and always write semicolons – there is only one pitfall that you need to be aware of. It is that JavaScript forbids line breaks after some tokens. If you do insert a line break, a semicolon will be inserted, too.    The token where this is most practically relevant is `return`. Consider, for example, the following code:    ```js return {  first: 'jane' };  ```    This code is parsed as:    ```js return; {  first: 'jane'; } ;  ```    That is:    *   Return statement without operand: `return;` *   Start of code block: `{` *   Expression statement `'jane';` with [label](ch_control-flow.html#labels) `first:` *   End of code block: `}` *   Empty statement: `;`    Why does JavaScript do this? It protects against accidentally returning a value in a line after a `return`.    #### [9.8.2 ASI unexpectedly not triggered](#asi-unexpectedly-not-triggered)    In some cases, ASI is *not* triggered when you think it should be. That makes life more complicated for people who don’t like semicolons because they need to be aware of those cases. The following are three examples. There are more.    **Example 1:** Unintended function call.    ```js a = b + c (d + e).print()  ```    Parsed as:    ```js a = b + c(d + e).print();  ```    **Example 2:** Unintended division.    ```js a = b /hi/g.exec(c).map(d)  ```    Parsed as:    ```js a = b / hi / g.exec(c).map(d);  ```    **Example 3:** Unintended property access.    ```js someFunction() ['ul', 'ol'].map(x => x + x)  ```    Executed as:    ```js const propKey = ('ul','ol'); // comma operator assert.equal(propKey, 'ol');  `someFunction()[propKey].map(x => x + x);`  ```   ```js`### [9.9 Semicolons: best practices](#semicolons-best-practices)    I recommend that you always write semicolons:    *   I like the visual structure it gives code – you clearly see where a statement ends. *   There are fewer rules to keep in mind. *   The majority of JavaScript programmers use semicolons.    However, there are also many people who don’t like the added visual clutter of semicolons. If you are one of them: Code without them *is* legal. I recommend that you use tools to help you avoid mistakes. The following are two examples:    *   The automatic code formatter [Prettier](https://prettier.io) can be configured to not use semicolons. It then automatically fixes problems. For example, if it encounters a line that starts with a square bracket, it prefixes that line with a semicolon. *   The static checker [ESLint](https://eslint.org) has [a rule](https://eslint.org/docs/rules/semi) that you tell your preferred style (always semicolons or as few semicolons as possible) and that warns you about critical issues.    ### [9.10 Strict mode vs. sloppy mode](#strict-mode)    Starting with ECMAScript 5, JavaScript has two *modes* in which JavaScript can be executed:    *   Normal “sloppy” mode is the default in scripts (code fragments that are a precursor to modules and supported by browsers). *   Strict mode is the default in modules and classes, and can be switched on in scripts (how is explained later). In this mode, several pitfalls of normal mode are removed and more exceptions are thrown.    You’ll rarely encounter sloppy mode in modern JavaScript code, which is almost always located in modules. In this book, I assume that strict mode is always switched on.    #### [9.10.1 Switching on strict mode](#switching-on-strict-mode)    In script files and CommonJS modules, you switch on strict mode for a complete file, by putting the following code in the first line:    ``` 'use strict';  ```js    The neat thing about this “directive” is that ECMAScript versions before 5 simply ignore it: it’s an expression statement that does nothing.    You can also switch on strict mode for just a single function:    ``` function functionInStrictMode() {  'use strict'; }  ```js    #### [9.10.2 Improvements in strict mode](#improvements-in-strict-mode)    Let’s look at three things that strict mode does better than sloppy mode. Just in this one section, all code fragments are executed in sloppy mode.    ##### [9.10.2.1 Sloppy mode pitfall: changing an undeclared variable creates a global variable](#sloppy-mode-pitfall-changing-an-undeclared-variable-creates-a-global-variable)    In non-strict mode, changing an undeclared variable creates a global variable.    ``` function sloppyFunc() {  undeclaredVar1 = 123; } sloppyFunc(); // Created global variable `undeclaredVar1`: assert.equal(undeclaredVar1, 123);  ```js    Strict mode does it better and throws a `ReferenceError`. That makes it easier to detect typos.    ``` function strictFunc() {  'use strict';  undeclaredVar2 = 123; } assert.throws(  () => strictFunc(),  {  name: 'ReferenceError',  message: 'undeclaredVar2 is not defined',  });  ```js    The `assert.throws()` states that its first argument, a function, throws a `ReferenceError` when it is called.    ##### [9.10.2.2 Function declarations are block-scoped in strict mode, function-scoped in sloppy mode](#function-declarations-are-blockscoped-in-strict-mode-functionscoped-in-sloppy-mode)    In strict mode, a variable created via a function declaration only exists within the innermost enclosing block:    ``` function strictFunc() {  'use strict';  {  function foo() { return 123 }  }  return foo(); // ReferenceError } assert.throws(  () => strictFunc(),  {  name: 'ReferenceError',  message: 'foo is not defined',  });  ```js    In sloppy mode, function declarations are function-scoped:    ``` function sloppyFunc() {  {  function foo() { return 123 }  }  return foo(); // works } assert.equal(sloppyFunc(), 123);  ```js    ##### [9.10.2.3 Sloppy mode doesn’t throw exceptions when changing immutable data](#sloppy-mode-doesnt-throw-exceptions-when-changing-immutable-data)    In strict mode, you get an exception if you try to change immutable data:    ``` function strictFunc() {  'use strict';  true.prop = 1; // TypeError } assert.throws(  () => strictFunc(),  {  name: 'TypeError',  message: \"Cannot create property 'prop' on boolean 'true'\",  });  ```js    In sloppy mode, the assignment fails silently:    ``` function sloppyFunc() {  true.prop = 1; // fails silently  return true.prop; } assert.equal(sloppyFunc(), undefined);  ```js    ![Icon “external”](../Images/38e6ff55e8d602659f3cdb8893e63f62.png) **Further reading: sloppy mode**    For more information on how sloppy mode differs from strict mode, see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).```` ```js`` `````", "``````js` ``````", "``````js``` ``````", "```` ```js````", "```js` ```", "```js```", "``` ```", "```````js``` ``````js```````", "``````js``````", "``````js``````", "``` ```", "```js```", "````js````", "```js```", "````js````", "```js` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "``````js``````", "```````"]