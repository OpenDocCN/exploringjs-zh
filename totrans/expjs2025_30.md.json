["```js\nfor (const x of ['a', 'b', 'c']) {\n console.log(x);\n if (x === 'b') break;\n console.log('---')\n}\n\n```", "```js\na\n---\nb\n\n```", "```js\nmyLabel: { // label\n if (condition) break myLabel; // labeled break\n // ···\n}\n\n```", "```js\nfunction findSuffix(stringArray, suffix) {\n let result;\n searchBlock: {\n for (const str of stringArray) {\n if (str.endsWith(suffix)) {\n // Success:\n result = str;\n break searchBlock; // (A)\n }\n } // for\n // Failure:\n result = '(Untitled)'; // (B)\n } // searchBlock\n `return { suffix, result };`\n `// Same as: {suffix: suffix, result: result}`\n`}`\n`assert.deepEqual(`\n `findSuffix(['notes.txt', 'index.html'], '.html'),`\n `{ suffix: '.html', result: 'index.html' }`\n`);`\n`assert.deepEqual(`\n `findSuffix(['notes.txt', 'index.html'], '.mjs'),`\n `{ suffix: '.mjs', result: '(Untitled)' }`\n`);` \n```", "```js```", "```js const lines = [  'Normal line',  '# Comment',  'Another normal line', ]; for (const line of lines) {  if (line.startsWith('#')) continue;  console.log(line); }  ```", "```js Normal line Another normal line  ```", "```js if (value) {} if (Boolean(value) === true) {}  ```", "```js if (cond) {  // then branch }  `if (cond) {`  `// then branch` `} else {`  `// else branch` `}`  ```", "```js```", "``` if (cond1) {  // ··· } else if (cond2) {  // ··· }  `if (cond1) {`  `// ···` `} else if (cond2) {`  `// ···` `} else {`  `// ···` `}`  ```", "````` We can continue this chain with more `else if`s.    #### [25.3.1 The syntax of `if` statements](#the-syntax-of-if-statements)    The general syntax of `if` statements is:    ```js if («cond») «then_statement» else «else_statement»  ```    So far, the `then_statement` has always been a block, but we can use any statement. That statement must be terminated with a semicolon:    ```js if (true) console.log('Yes'); else console.log('No');  ```    That means that `else if` is not its own construct; it’s simply an `if` statement whose `else_statement` is another `if` statement.    ### [25.4 `switch` statements ^(ES3)](#switch)    A `switch` statement looks as follows:    ```js switch («switch_expression») {  «switch_body» }  ```    The body of `switch` consists of zero or more case clauses:    ```js case «case_expression»:  «statements»  ```    And, optionally, a default clause:    ```js default:  «statements»  ```    A `switch` is executed as follows:    *   It evaluates the switch expression. *   It jumps to the first case clause whose expression has the same result as the switch expression. *   Otherwise, if there is no such clause, it jumps to the default clause. *   Otherwise, if there is no default clause, it does nothing.    #### [25.4.1 A first example of a `switch` statement](#a-first-example-of-a-switch-statement)    Let’s look at an example: The following function converts a number from 1–7 to the name of a weekday.    ```js function dayOfTheWeek(num) {  switch (num) {  case 1:  return 'Monday';  case 2:  return 'Tuesday';  case 3:  return 'Wednesday';  case 4:  return 'Thursday';  case 5:  return 'Friday';  case 6:  return 'Saturday';  case 7:  return 'Sunday';  } } assert.equal(dayOfTheWeek(5), 'Friday');  ```    #### [25.4.2 Don’t forget to `return` or `break`!](#dont-forget-to-return-or-break)    At the end of a case clause, execution continues with the next case clause, unless we `return` or `break` – for example:    ```js function englishToFrench(english) {  let french;  switch (english) {  case 'hello':  french = 'bonjour';  case 'goodbye':  french = 'au revoir';  }  return french; } // The result should be 'bonjour'! assert.equal(englishToFrench('hello'), 'au revoir');  ```    That is, our implementation of `dayOfTheWeek()` only worked because we used `return`. We can fix `englishToFrench()` by using `break`:    ```js function englishToFrench(english) {  let french;  switch (english) {  case 'hello':  french = 'bonjour';  break;  case 'goodbye':  french = 'au revoir';  break;  }  return french; } assert.equal(englishToFrench('hello'), 'bonjour'); // ok  ```    #### [25.4.3 Empty case clauses](#empty-case-clauses)    The statements of a case clause can be omitted, which effectively gives us multiple case expressions per case clause:    ```js function isWeekDay(name) {  switch (name) {  case 'Monday':  case 'Tuesday':  case 'Wednesday':  case 'Thursday':  case 'Friday':  return true;  case 'Saturday':  case 'Sunday':  return false;  } } assert.equal(isWeekDay('Wednesday'), true); assert.equal(isWeekDay('Sunday'), false);  ```    #### [25.4.4 Checking for illegal values via a `default` clause](#checking-for-illegal-values-via-a-default-clause)    A `default` clause is jumped to if the `switch` expression has no other match. That makes it useful for error checking:    ```js function isWeekDay(name) {  switch (name) {  case 'Monday':  case 'Tuesday':  case 'Wednesday':  case 'Thursday':  case 'Friday':  return true;  case 'Saturday':  case 'Sunday':  return false;  default:  throw new Error('Illegal value: '+name);  } } assert.throws(  () => isWeekDay('January'),  {message: 'Illegal value: January'});  ```    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercises: `switch`**    *   `exercises/control-flow/number_to_month_test.mjs` *   Bonus: `exercises/control-flow/is_object_via_switch_test.mjs`    #### [25.4.5 Pitfall of `switch`: all cases exist in the same variable scope](#pitfall-switch-variable-scope)    Let’s say we want to implement a function `main()` that works as follows:    ```js assert.equal(  main(['repeat', '3', 'ho']),  'hohoho' ); assert.equal(  main(['once', 'hello']),  'hello' );  ```    We could implement `main()` like this (to reduce verbosity, error messages are omitted):    ```js function main(args) {  const command = args[0];  if (command === undefined) {  throw new Error();  }  switch (command) {  case 'once':  const text = args[1];  if (text === undefined) {  throw new Error();  }  return text;  case 'repeat':  const timesStr = args[1];  const text = args[2]; // (A)  if (timesStr === undefined || text === undefined) {  throw new Error();  }  const times = Number(timesStr);  return text.repeat(times);  default:  throw new Error();  } }  ```    Alas, in line A, we get the following syntax error:    ```js SyntaxError: Identifier 'text' has already been declared  ```    Why is that? The complete body of `switch` is a single variable scope and inside it, there are two declarations for the variable `text`.    But this problem is easy to fix – we can create a variable scope for each `switch` case by wrapping its code in curly braces:    ```js function main(args) {  const command = args[0];  if (command === undefined) {  throw new Error();  }  switch (command) {  case 'once': {  const text = args[1];  if (text === undefined) {  throw new Error();  }  return text;  }  case 'repeat': {  const timesStr = args[1];  const text = args[2]; // (A)  if (timesStr === undefined || text === undefined) {  throw new Error();  }  const times = Number(timesStr);  return text.repeat(times);  }  default:  throw new Error();  } }  ```    ### [25.5 `while` loops ^(ES1)](#while)    A `while` loop has the following syntax:    ```js while («condition») {  «statements» }  ```    Before each loop iteration, `while` evaluates `condition`:    *   If the result is falsy, the loop is finished. *   If the result is truthy, the `while` body is executed one more time.    #### [25.5.1 Examples of `while` loops](#examples-of-while-loops)    The following code uses a `while` loop. In each loop iteration, it removes the first element of `arr` via `.shift()` and logs it.    ```js const arr = ['a', 'b', 'c']; while (arr.length > 0) {  const elem = arr.shift(); // remove first element  console.log(elem); }  ```    Output:    ```js a b c  ```    If the condition always evaluates to `true`, then `while` is an infinite loop:    ```js while (true) {  if (Math.random() === 0) break; }  ```    ### [25.6 `do-while` loops ^(ES3)](#do-while)    The `do-while` loop works much like `while`, but it checks its condition *after* each loop iteration, not before.    ```js let input; do {  input = prompt('Enter text:');  console.log(input); } while (input !== ':q');  ```    `do-while` can also be viewed as a `while` loop that runs at least once.    [`prompt()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt) is a global function that is available in web browsers. It prompts the user to input text and returns it.    ### [25.7 `for` loops ^(ES1)](#for)    A `for` loop has the following syntax:    ```js for («initialization»; «condition»; «post_iteration») {  «statements» }  ```    The first line is the *head* of the loop and controls how often the *body* (the remainder of the loop) is executed. It has three parts and each of them is optional:    *   `initialization`: sets up variables, etc. for the loop. Variables declared here via `let` or `const` only exist inside the loop. *   `condition`: This condition is checked before each loop iteration. If it is falsy, the loop stops. *   `post_iteration`: This code is executed after each loop iteration.    A `for` loop is therefore roughly equivalent to the following `while` loop:    ```js «initialization» while («condition») {  «statements»  «post_iteration» }  ```    #### [25.7.1 Examples of `for` loops](#examples-of-for-loops)    As an example, this is how to count from zero to two via a `for` loop:    ```js for (let i=0; i<3; i++) {  console.log(i); }  ```    Output:    ```js 0 1 2  ```    This is how to log the contents of an Array via a `for` loop:    ```js const arr = ['a', 'b', 'c']; for (let i=0; i<arr.length; i++) {  console.log(arr[i]); }  ```    Output:    ```js a b c  ```    If we omit all three parts of the head, we get an infinite loop:    ```js for (;;) {  if (Math.random() === 0) break; }  ```    ### [25.8 `for-of` loops ^(ES6)](#for-of)    A `for-of` loop iterates over any *iterable* – a data container that supports [the *iteration protocol*](ch_sync-iteration.html#ch_sync-iteration). Each iterated value is stored in a variable, as specified in the head:    ```js for («iteration_variable» of «iterable») {  «statements» }  ```    The iteration variable is usually created via a variable declaration:    ```js const iterable = ['hello', 'world']; for (const elem of iterable) {  console.log(elem); }  ```    Output:    ```js hello world  ```    But we can also use a (mutable) variable that already exists:    ```js const iterable = ['hello', 'world']; let elem; for (elem of iterable) {  console.log(elem); }  ```    #### [25.8.1 `const`: `for-of` vs. `for`](#const-forof-vs-for)    Note that in `for-of` loops we can use `const`. The iteration variable can still be different for each iteration (it just can’t change during the iteration). Think of it as a new `const` declaration being executed each time in a fresh scope.    In contrast, in `for` loops we must declare variables via `let` or `var` if their values change.    #### [25.8.2 Iterating over iterables](#iterating-over-iterables)    As mentioned before, `for-of` works with any iterable object, not just with Arrays – for example, with Sets:    ```js const set = new Set(['hello', 'world']); for (const elem of set) {  console.log(elem); }  ```    #### [25.8.3 Iterating over [index, element] pairs of Arrays](#for-of-iterating-index-element)    Lastly, we can also use `for-of` to iterate over the [index, element] entries of Arrays:    ```js const arr = ['a', 'b', 'c']; for (const [index, element] of arr.entries()) {  console.log(`${index} -> ${element}`); }  ```    Output:    ```js 0 -> a 1 -> b 2 -> c  ```    With `[index, element]`, we are using [*destructuring*](ch_destructuring.html#ch_destructuring) to access Array elements.    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: `for-of`**    `exercises/control-flow/array_to_string_test.mjs`    ### [25.9 `for-await-of` loops ^(ES2018)](#forawaitof-loops-es2018)    `for-await-of` is like `for-of`, but it works with asynchronous iterables instead of synchronous ones. And it can only be used inside async functions and async generators.    ```js for await (const item of asyncIterable) {  // ··· }  ```    `for-await-of` is described in detail [in the chapter on asynchronous iteration](ch_async-iteration.html#for-await-of).    ### [25.10 `for-in` loops (avoid) ^(ES1)](#for-in)    The `for-in` loop visits all (own and inherited) enumerable property keys of an object. When looping over an Array, it is rarely a good choice:    *   It visits property keys, not values. *   As property keys, the indices of Array elements are strings, not numbers ([more information on how Array elements work](ch_arrays.html#array-indices)). *   It visits all enumerable property keys (both own and inherited ones), not just those of Array elements.    The following code demonstrates these points:    ```js const arr = ['a', 'b', 'c']; arr.propKey = 'property value';  `for (const key in arr) {`  `console.log(key);` `}`  ```   ```js`Output:    ``` 0 1 2 propKey  ```js    ### [25.11 Recommendations for looping](#recommendations-for-looping)    *   If you want to loop over an [asynchronous iterable](ch_async-iteration.html#ch_async-iteration) (in ES2018+), you must use `for-await-of`. *   For looping over any synchronous iterable (incl. Arrays), you must use `for-of`. Available in ES6+. *   For looping over an Array in ES5+, you can use [the Array method `.forEach()`](ch_arrays.html#qref-Array.prototype.forEach). *   Before ES5, you can use a plain `for` loop to loop over an Array. *   Don’t use `for-in` to loop over an Array.```` ```js`` `````", "```````"]