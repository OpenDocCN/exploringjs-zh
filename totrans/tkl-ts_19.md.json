["```ts\n    let obj1: Object;\n    ```", "```ts\n    let obj2: object;\n    ```", "```ts\n// Object type literal\nlet obj3: {prop: boolean};\n\n// Interface\ninterface ObjectType {\n prop: boolean;\n}\nlet obj4: ObjectType;\n```", "```ts\n> const obj1 = {};\n> obj1 instanceof Object\ntrue\n```", "```ts\n    > Object.prototype.isPrototypeOf(obj1)\n    true\n    ```", "```ts\n    > obj1.toString === Object.prototype.toString\n    true\n    ```", "```ts\n> const obj2 = Object.create(null);\n> Object.getPrototypeOf(obj2)\nnull\n```", "```ts\n> typeof obj2\n'object'\n> obj2 instanceof Object\nfalse\n```", "```ts\ninterface Object { // (A)\n constructor: Function;\n toString(): string;\n toLocaleString(): string;\n valueOf(): Object;\n hasOwnProperty(v: PropertyKey): boolean;\n isPrototypeOf(v: Object): boolean;\n propertyIsEnumerable(v: PropertyKey): boolean;\n}\n\ninterface ObjectConstructor {\n /** Invocation via `new` */\n new(value?: any): Object;\n /** Invocation via function calls */\n (value?: any): any;\n\n readonly prototype: Object; // (B)\n\n getPrototypeOf(o: any): any;\n\n // \u00b7\u00b7\u00b7\n}\ndeclare var Object: ObjectConstructor; // (C)\n```", "```ts\nfunction func1(x: Object) { }\nfunc1('abc'); // OK\n```", "```ts\n> 'abc'.hasOwnProperty === Object.prototype.hasOwnProperty\ntrue\n```", "```ts\nfunction func2(x: object) { }\n// @ts-expect-error: Argument of type '\"abc\"' is not assignable to\n// parameter of type 'object'. (2345)\nfunc2('abc');\n```", "```ts\n// @ts-expect-error: Type '() => number' is not assignable to\n// type '() => string'.\n//   Type 'number' is not assignable to type 'string'. (2322)\nconst obj1: Object = { toString() { return 123 } };\n```", "```ts\nconst obj2: object = { toString() { return 123 } };\n```", "```ts\n// Object type literal\ntype ObjType1 = {\n a: boolean,\n b: number;\n c: string,\n};\n\n// Interface\ninterface ObjType2 {\n a: boolean,\n b: number;\n c: string,\n}\n```", "```ts\n// Inlined object type literal:\nfunction f1(x: {prop: number}) {}\n\n// Referenced interface:\nfunction f2(x: ObjectInterface) {} \ninterface ObjectInterface {\n prop: number;\n}\n```", "```ts\n// @ts-expect-error: Duplicate identifier 'PersonAlias'. (2300)\ntype PersonAlias = {first: string};\n// @ts-expect-error: Duplicate identifier 'PersonAlias'. (2300)\ntype PersonAlias = {last: string};\n```", "```ts\ninterface PersonInterface {\n first: string;\n}\ninterface PersonInterface {\n last: string;\n}\nconst jane: PersonInterface = {\n first: 'Jane',\n last: 'Doe',\n};\n```", "```ts\ninterface Point {\n x: number;\n y: number;\n}\n\ntype PointCopy1 = {\n [Key in keyof Point]: Point[Key]; // (A)\n};\n\n// Syntax error:\n// interface PointCopy2 {\n//   [Key in keyof Point]: Point[Key];\n// };\n```", "```ts\ninterface AddsStrings {\n add(str: string): this;\n};\n\nclass StringBuilder implements AddsStrings {\n result = '';\n add(str: string) {\n this.result += str;\n return this;\n }\n}\n```", "```ts\ninterface Point {\n x: number;\n y: number;\n}\nconst point: Point = {x: 1, y: 2}; // OK\n```", "```ts\ninterface ExampleInterface {\n // Property signature\n myProperty: boolean;\n\n // Method signature\n myMethod(str: string): number;\n\n // Index signature\n [key: string]: any;\n\n // Call signature\n (num: number): string;\n\n // Construct signature\n new(str: string): ExampleInstance; \n}\ninterface ExampleInstance {}\n```", "```ts\n    myProperty: boolean;\n    ```", "```ts\n    myMethod(str: string): number;\n    ```", "```ts\n    [key: string]: any;\n    ```", "```ts\n    (num: number): string;\n    ```", "```ts\n    new(str: string): ExampleInstance; \n    ```", "```ts\ninterface HasMethodDef {\n simpleMethod(flag: boolean): void;\n}\ninterface HasFuncProp {\n simpleMethod: (flag: boolean) => void;\n}\n\nconst objWithMethod: HasMethodDef = {\n simpleMethod(flag: boolean): void {},\n};\nconst objWithMethod2: HasFuncProp = objWithMethod;\n\nconst objWithOrdinaryFunction: HasMethodDef = {\n simpleMethod: function (flag: boolean): void {},\n};\nconst objWithOrdinaryFunction2: HasFuncProp = objWithOrdinaryFunction;\n\nconst objWithArrowFunction: HasMethodDef = {\n simpleMethod: (flag: boolean): void => {},\n};\nconst objWithArrowFunction2: HasFuncProp = objWithArrowFunction;\n```", "```ts\nfunction translate(dict: TranslationDict, english: string): string {\n return dict[english];\n}\n```", "```ts\ninterface TranslationDict {\n [key:string]: string; // (A)\n}\nconst dict = {\n 'yes': 's\u00ed',\n 'no': 'no',\n 'maybe': 'tal vez',\n};\nassert.equal(\n translate(dict, 'maybe'),\n 'tal vez');\n```", "```ts\ninterface StringAndNumberKeys {\n [key: string]: Object;\n [key: number]: RegExp;\n}\n\n// %inferred-type: (x: StringAndNumberKeys) =>\n// { str: Object; num: RegExp; }\nfunction f(x: StringAndNumberKeys) {\n return { str: x['abc'], num: x[123] };\n}\n```", "```ts\ninterface I1 {\n [key: string]: boolean;\n\n // @ts-expect-error: Property 'myProp' of type 'number' is not assignable\n // to string index type 'boolean'. (2411)\n myProp: number;\n\n // @ts-expect-error: Property 'myMethod' of type '() => string' is not\n // assignable to string index type 'boolean'. (2411)\n myMethod(): string;\n}\n```", "```ts\ninterface I2 {\n [key: string]: number;\n myProp: number;\n}\n\ninterface I3 {\n [key: string]: () => string;\n myMethod(): string;\n}\n```", "```ts\nfunction f1(x: {}): Object {\n return x;\n}\n```", "```ts\nfunction f2(x: {}): { toString(): string } {\n return x;\n}\n```", "```ts\ninterface Point {\n x: number;\n y: number;\n}\n```", "```ts\nfunction computeDistance(point: Point) { /*...*/ }\n```", "```ts\nconst obj = { x: 1, y: 2, z: 3 };\ncomputeDistance(obj); // OK\n```", "```ts\n// @ts-expect-error: Argument of type '{ x: number; y: number; z: number; }'\n// is not assignable to parameter of type 'Point'.\n//   Object literal may only specify known properties, and 'z' does not\n//   exist in type 'Point'. (2345)\ncomputeDistance({ x: 1, y: 2, z: 3 }); // error\n\ncomputeDistance({x: 1, y: 2}); // OK\n```", "```ts\ninterface Person {\n first: string;\n middle?: string;\n last: string;\n}\nfunction computeFullName(person: Person) { /*...*/ }\n```", "```ts\n// @ts-expect-error: Argument of type '{ first: string; mdidle: string;\n// last: string; }' is not assignable to parameter of type 'Person'.\n//   Object literal may only specify known properties, but 'mdidle'\n//   does not exist in type 'Person'. Did you mean to write 'middle'?\ncomputeFullName({first: 'Jane', mdidle: 'Cecily', last: 'Doe'});\n```", "```ts\ninterface HasYear {\n year: number;\n}\n\nfunction getAge(obj: HasYear) {\n const yearNow = new Date().getFullYear();\n return yearNow - obj.year;\n}\n```", "```ts\ninterface Empty { }\ninterface OneProp {\n myProp: number;\n}\n\n// @ts-expect-error: Type '{ myProp: number; anotherProp: number; }' is not\n// assignable to type 'OneProp'.\n//   Object literal may only specify known properties, and\n//   'anotherProp' does not exist in type 'OneProp'. (2322)\nconst a: OneProp = { myProp: 1, anotherProp: 2 };\nconst b: Empty = {myProp: 1, anotherProp: 2}; // OK\n```", "```ts\ninterface WithoutProperties {\n [key: string]: never;\n}\n\n// @ts-expect-error: Type 'number' is not assignable to type 'never'. (2322)\nconst a: WithoutProperties = { prop: 1 };\nconst b: WithoutProperties = {}; // OK\n```", "```ts\ninterface Point {\n x: number;\n y: number;\n}\n\nfunction computeDistance1(point: Point) { /*...*/ }\n\n// @ts-expect-error: Argument of type '{ x: number; y: number; z: number; }'\n// is not assignable to parameter of type 'Point'.\n//   Object literal may only specify known properties, and 'z' does not\n//   exist in type 'Point'. (2345)\ncomputeDistance1({ x: 1, y: 2, z: 3 });\n```", "```ts\nconst obj = { x: 1, y: 2, z: 3 };\ncomputeDistance1(obj);\n```", "```ts\ncomputeDistance1({ x: 1, y: 2, z: 3 } as Point); // OK\n```", "```ts\nfunction computeDistance2<P extends Point>(point: P) { /*...*/ }\ncomputeDistance2({ x: 1, y: 2, z: 3 }); // OK\n```", "```ts\ninterface PointEtc extends Point {\n [key: string]: any;\n}\nfunction computeDistance3(point: PointEtc) { /*...*/ }\n\ncomputeDistance3({ x: 1, y: 2, z: 3 }); // OK\n```", "```ts\ninterface Incrementor {\n inc(): void\n}\nfunction createIncrementor(start = 0): Incrementor {\n return {\n // @ts-expect-error: Type '{ counter: number; inc(): void; }' is not\n // assignable to type 'Incrementor'.\n //   Object literal may only specify known properties, and\n //   'counter' does not exist in type 'Incrementor'. (2322)\n counter: start,\n inc() {\n // @ts-expect-error: Property 'counter' does not exist on type\n // 'Incrementor'. (2339)\n this.counter++;\n },\n };\n}\n```", "```ts\nfunction createIncrementor2(start = 0): Incrementor {\n return {\n counter: start,\n inc() {\n // @ts-expect-error: Property 'counter' does not exist on type\n // 'Incrementor'. (2339)\n this.counter++;\n },\n } as Incrementor;\n}\n```", "```ts\nfunction createIncrementor3(start = 0): Incrementor {\n const incrementor = {\n counter: start,\n inc() {\n this.counter++;\n },\n };\n return incrementor;\n}\n```", "```ts\nfunction compareDateStrings(\n a: {dateStr: string}, b: {dateStr: string}) {\n if (a.dateStr < b.dateStr) {\n return +1;\n } else if (a.dateStr > b.dateStr) {\n return -1;\n } else {\n return 0;\n }\n }\n```", "```ts\n// %inferred-type: Object\nconst obj1 = new Object();\n\n// %inferred-type: any\nconst obj2 = Object.create(null);\n\n// %inferred-type: {}\nconst obj3 = {};\n\n// %inferred-type: { prop: number; }\nconst obj4 = {prop: 123};\n\n// %inferred-type: object\nconst obj5 = Reflect.getPrototypeOf({});\n```", "```ts\ninterface Name {\n first: string;\n middle?: string;\n last: string;\n}\n```", "```ts\nconst john: Name = {first: 'Doe', last: 'Doe'}; // (A)\nconst jane: Name = {first: 'Jane', middle: 'Cecily', last: 'Doe'};\n```", "```ts\ninterface Interf {\n prop1?: string;\n prop2: undefined | string; \n}\n```", "```ts\nconst obj1: Interf = { prop1: undefined, prop2: undefined };\n```", "```ts\nconst obj2: Interf = { prop2: undefined };\n\n// @ts-expect-error: Property 'prop2' is missing in type '{}' but required\n// in type 'Interf'. (2741)\nconst obj3: Interf = { };\n```", "```ts\ninterface MyInterface {\n readonly prop: number;\n}\n```", "```ts\nconst obj: MyInterface = {\n prop: 1,\n};\n\nconsole.log(obj.prop); // OK\n\n// @ts-expect-error: Cannot assign to 'prop' because it is a read-only\n// property. (2540)\nobj.prop = 2;\n```", "```ts\ninterface MyInterface {\n toString(): string; // inherited property\n prop: number; // own property\n}\nconst obj: MyInterface = { // OK\n prop: 123,\n};\n```"]