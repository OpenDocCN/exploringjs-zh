["```js\nconst str = 'abc';\nassert.equal(str.length, 3);\nassert.throws(\n () => { str.length = 1 },\n /^TypeError: Cannot assign to read only property 'length'/\n);\n\n```", "```js\nconst x = 123;\nconst y = x;\n// `y` is the same as any other number 123\nassert.equal(y, 123);\n\n```", "```js\nassert.equal(123 === 123, true);\nassert.equal('abc' === 'abc', true);\n\n```", "```js\n    const obj = {\n     first: 'Jane',\n     last: 'Doe',\n    };\n\n    ```", "```js\n    const fruits = ['strawberry', 'apple'];\n\n    ```", "```js\nconst obj = {};\n `obj.count = 2; // add a property`\n`assert.equal(obj.count, 2);`\n `` `obj.count = 3; // change a property` `assert.equal(obj.count, 3);` `` \n```", "```js```", "``` ```", "````` #### [14.6.2 Objects are *passed by identity*](#objects-are-passed-by-identity)    Objects are *passed by identity* (new term): Variables (including parameters) store the *identities* of objects. The identity of an object is a *transparent reference* (think pointer) to the object’s actual data on the *heap* (the shared main memory of a JavaScript process). When assigning an object to a variable or passing it as an argument to a function, its identity is copied.    Each object literal creates a fresh object on the heap and returns its identity:    ```js const a = {}; // fresh empty object // Pass the identity in `a` to `b`: const b = a;  ``// Now `a` and `b` point to the same object`` `// (they “share” that object):` `assert.equal(a === b, true);`  ``` ``// Changing `a` also changes `b`:`` `a.name = 'Tessa';` `assert.equal(b.name, 'Tessa');` ```js  ```   ```js```` ```js``` JavaScript uses *garbage collection* to automatically manage memory:    ``` let obj = { prop: 'value' }; obj = {};  ```js    Now the old value `{ prop: 'value' }` of `obj` is *garbage* (not used anymore). JavaScript will automatically *garbage-collect* it (remove it from memory), at some point in time (possibly never if there is enough free memory).    #### [14.6.3 Objects are *compared by identity*](#objects-are-compared-by-identity)    Objects are *compared by identity* (new term): two variables are only equal if they contain the same object identity. They are not equal if they refer to different objects with the same content.    ``` const obj = {}; // fresh empty object assert.equal(obj === obj, true); // same identity assert.equal({} === {}, false); // different identities, same content  ```js    #### [14.6.4 Passing by reference vs. passing by identity (advanced)](#passing-by-reference-vs-passing-by-identity-advanced)    If a parameter is *passed by reference*, it points to a variable and assigning to the parameter changes the variable – e.g., in the following C++ code, the parameters `x` and `y` are passed by reference. The invocation in line A affects the variables `a` and `b` of the invoker.    ``` void swap_ints(int &x, int &y) {  int temp = x;  x = y;  y = temp; } int main() {  int a = 1;  int b = 2;  `swap_ints(a, b); // (A)`  ``// Now `a` is 2 and `b` is 1``  `` `return 0;` `}` ``  ```js   `````", "```js` If a parameter is *passed by identity* (which is a new, new term), the identity of an object (a transparent reference) is passed by value. Assigning to the parameter only has a local effect. This approach is also called [*passing by sharing*](https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing).    **Acknowledgement:** The term *passing by identity* was [suggested](https://x.com/awbjs/status/1086919101635801088) by Allen Wirfs-Brock in 2019.    #### [14.6.5 Identity in the ECMAScript specification (advanced)](#identity-in-the-ecmascript-specification-advanced)    The ECMAScript specification uses the term *identity* as follows ([source](https://tc39.es/ecma262/#sec-identity)):    *   *Values without identity* are equal to other values without identity if all of their innate characteristics are the same – characteristics such as the magnitude of an integer or the length of a sequence.               *   Values without identity may be manifest without prior reference by fully describing their characteristics. *   In contrast, each *value with identity* is unique and therefore only equal to itself. Values with identity are like values without identity but with an additional unguessable, unchangeable, universally-unique characteristic called identity.               *   References to existing values with identity cannot be manifest simply by describing them, as the identity itself is indescribable; instead, references to these values must be explicitly passed from one place to another.     *   Some values with identity are mutable and therefore can have their characteristics (except their identity) changed in-place, causing all holders of the value to observe the new characteristics.    At the language level:    *   Values that have identity: objects and symbols created via `Symbol()` *   Values that don’t have identity: primitive values and symbols created via `Symbol.for()`    ### [14.7 The operators `typeof` and `instanceof`: what’s the type of a value?](#the-operators-typeof-and-instanceof-whats-the-type-of-a-value)    The two operators `typeof` and `instanceof` let us determine what type a given value `x` has:    ```", "```js    How do they differ?    *   `typeof` distinguishes the 7 types of the specification (minus one omission, plus one addition). *   `instanceof` tests which class created a given value.    ![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Rule of thumb: `typeof` is for primitive values; `instanceof` is for objects**    #### [14.7.1 `typeof`](#typeof-operator)     | `x` | `typeof x` | | --- | --- | | `undefined` | `'undefined'` | | `null` | `'object'` | | Boolean | `'boolean'` | | Number | `'number'` | | Bigint | `'bigint'` | | String | `'string'` | | Symbol | `'symbol'` | | Function | `'function'` | | All other objects | `'object'` |      Table 14.1: The results of the `typeof` operator.      [Table 14.1](#tbl:typeof-results) lists all results of `typeof`. They roughly correspond to the 7 types of the language specification. Alas, there are two differences, and they are language quirks:    *   `typeof null` returns `'object'` and not `'null'`. That’s a bug. Unfortunately, it can’t be fixed. TC39 tried to do that, but it broke too much code on the web. *   `typeof` of a function should be `'object'` (functions are objects). Introducing a separate category for functions is confusing.    These are a few examples of using `typeof`:    ```", "```js    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercises: Two exercises on `typeof`**    *   `exercises/values/typeof_exrc.mjs` *   Bonus: `exercises/values/is_object_test.mjs`    #### [14.7.2 `instanceof`](#instanceof-operator)    This operator answers the question: has a value `x` been created by a class `C`?    ```", "```js    For example:    ```", "```js    Primitive values are not instances of anything:    ```", "```js    For more information on this operator, see [“The `instanceof` operator in detail (advanced)” (§31.7.3)](ch_classes.html#instanceof-operator-details).    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: `instanceof`**    `exercises/values/instanceof_exrc.mjs`    ### [14.8 Classes and constructor functions](#classes-and-constructor-functions)    JavaScript’s original factories for objects are *constructor functions*: ordinary functions that return “instances” of themselves if we invoke them via the `new` operator.    ES6 introduced *classes*, which are mainly better syntax for constructor functions.    In this book, I’m using the terms *constructor function* and *class* interchangeably.    Classes can be seen as partitioning the single type `object` of the specification into subtypes – they give us more types than the limited 7 ones of the specification. Each class is the type of the objects that were created by it.    #### [14.8.1 Constructor functions associated with primitive types](#constructor-functions-for-primitives)    Each primitive type (except for the types `undefined` and `null`) has an associated *constructor function* (think class):    *   The constructor function `Boolean` is associated with booleans. *   The constructor function `Number` is associated with numbers. *   The constructor function `String` is associated with strings. *   The constructor function `Symbol` is associated with symbols.    Each of these functions plays several roles – for example, `Number`:    *   We can use it as a function and convert values to numbers:                    ```", "```js           *   `Number.prototype` provides the properties for numbers – for example, method `.toString()`:                    ```", "```js           *   `Number` is a namespace/container object for tool functions for numbers – for example:                    ```", "```js           *   Lastly, we can also use `Number` as a class and create number objects. These objects are different from real numbers and should be avoided. They virtually never show up in normal code. See the next subsection for more information.              ##### [14.8.1.1 Wrapper classes for primitive values (advanced)](#wrapper-classes-for-primitive-values-advanced)    If we new-invoke a constructor function associated with a primitive type, it returns a so-called *wrapper object*. This is the standard way of converting a primitive value to an object – by “wrapping” it.    The primitive value is not an instance of the wrapper class:    ```", "```js    The wrapper object is not a primitive value:    ```", "```js    We can unwrap the wrapper object to get back the primitive value:    ```", "```js    ### [14.9 Converting between types](#converting-between-types)    There are two ways in which values are converted to other types in JavaScript:    *   Explicit conversion: via functions such as `String()`. *   *Coercion* (automatic conversion): happens when an operation receives operands/parameters that it can’t work with.    #### [14.9.1 Explicit conversion between types](#explicit-conversion-between-types)    The function associated with a primitive type explicitly converts values to that type:    ```", "```js    We can also use `Object()` to convert values to objects:    ```", "```js    The following table describes in more detail how this conversion works:     | `x` | `Object(x)` | | --- | --- | | `undefined` | `{}` | | `null` | `{}` | | boolean | `new Boolean(x)` | | number | `new Number(x)` | | bigint | An instance of `BigInt` (`new` throws `TypeError`) | | string | `new String(x)` | | symbol | An instance of `Symbol` (`new` throws `TypeError`) | | object | `x` |    #### [14.9.2 Coercion (automatic conversion between types)](#coercion)    For many operations, JavaScript automatically converts the operands/parameters if their types don’t fit. This kind of automatic conversion is called *coercion*.    For example, the multiplication operator coerces its operands to numbers:    ```", "```js    Many built-in functions coerce, too. For example, `Number.parseInt()` coerces its parameter to a string before parsing it. That explains the following result:    ```", "```js    The number `123.45` is converted to the string `'123.45'` before it is parsed. Parsing stops before the first non-digit character, which is why the result is `123`.    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Converting values to primitives**    `exercises/values/conversion_exrc.mjs` ```", "```js`` ```", "```js ```", "```js` ```", "```js`` ```"]