<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>27 Typing functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>27 Typing functions</h1>
<blockquote>原文：<a href="https://exploringjs.com/ts/book/ch_typing-functions.html">https://exploringjs.com/ts/book/ch_typing-functions.html</a></blockquote>

    
        <div id="adbox">
      <div id="adbox-explain">(Ad, please don’t block.)</div>
              
          </div>
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#defining-statically-typed-functions">27.1 Defining statically typed functions</a>
      <ol>
        <li>
          <a href="#function-declarations">27.1.1 Function declarations</a>
        </li>
        <li>
          <a href="#arrow-functions">27.1.2 Arrow functions</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#types-for-functions">27.2 Types for functions</a>
      <ol>
        <li>
          <a href="#function-type-signatures">27.2.1 Function type signatures</a>
        </li>
        <li>
          <a href="#call-signatures">27.2.2 Interfaces with call signatures</a>
        </li>
        <li>
          <a href="#checking-if-a-callable-value-matches-a-function-type">27.2.3 Checking if a callable value matches a function type</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#parameters">27.3 Parameters</a>
      <ol>
        <li>
          <a href="#when-do-parameters-have-to-be-type-annotated">27.3.1 When do parameters have to be type-annotated?</a>
        </li>
        <li>
          <a href="#optional-parameters-1">27.3.2 Optional parameters</a>
        </li>
        <li>
          <a href="#rest-parameters-1">27.3.3 Rest parameters</a>
        </li>
        <li>
          <a href="#named-parameters">27.3.4 Named parameters</a>
        </li>
        <li>
          <a href="#this-as-a-parameter-advanced">27.3.5 <code>this</code> as a parameter (advanced)</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#return-type-never">27.4 Return type <code>never</code>: functions that don’t return</a>
      <ol>
        <li>
          <a href="#reasons-against-the-return-type-never-t">27.4.1 Reasons against the return type <code>never | T</code></a>
        </li>
        <li>
          <a href="#the-return-type-never-in-types-node">27.4.2 The return type <code>never</code> in <code>@types/node</code></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#overloading-advanced">27.5 Overloading (advanced)</a>
      <ol>
        <li>
          <a href="#overloading-function-declarations">27.5.1 Overloading function declarations</a>
        </li>
        <li>
          <a href="#overloading-functions-via-a-union-of-tuple-types">27.5.2 Overloading functions via a union of tuple types</a>
        </li>
        <li>
          <a href="#overloading-functions-via-interfaces">27.5.3 Overloading functions via interfaces</a>
        </li>
        <li>
          <a href="#overloading-on-string-parameters">27.5.4 Overloading on string parameters (event handling etc.)</a>
        </li>
        <li>
          <a href="#overloading-methods">27.5.5 Overloading methods</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#assignability">27.6 Assignability (advanced)</a>
      <ol>
        <li>
          <a href="#the-rules-for-assignability">27.6.1 The rules for assignability</a>
        </li>
        <li>
          <a href="#consequences-of-the-assignment-rules-for-functions">27.6.2 Consequences of the assignment rules for functions</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#further-reading-and-sources-of-this-chapter">27.7 Further reading and sources of this chapter</a>
    </li>
  </ol>
</nav>
<p>This chapter explores static typing for functions in TypeScript.</p>
<div class="boxout">
  <p><img src="../Images/00b0d6029a045810b908b88d1a6733d2.png" height="24" class="boxout-icon" alt="Icon “reading”" data-original-src="https://exploringjs.com/ts/book/icon/reading.svg"/> <strong>in this chapter, “function” means “function or method or constructor”</strong></p>
  <div class="boxout-vspace"/>
  <p>In this chapter, most things that are said about functions (especially w.r.t. parameter handling), also apply to methods and constructors.</p>
</div>
<h3 id="defining-statically-typed-functions"><a class="heading-id-link" href="#defining-statically-typed-functions">27.1 Defining statically typed functions</a></h3>
<h4 id="function-declarations"><a class="heading-id-link" href="#function-declarations">27.1.1 Function declarations</a></h4>
<p>This is an example of a function declaration in TypeScript:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">repeat1</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span>, times: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> { <span class="hljs-comment">// (A)</span></code>
<code>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">repeat</span>(times);</code>
<code>}</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">repeat1</span>(<span class="hljs-string">'*'</span>, <span class="hljs-number">5</span>), <span class="hljs-string">'*****'</span></code>
<code>);</code>
</pre>
<ul>
  <li>
    <p>Parameters: If the compiler option <code>--noImplicitAny</code> is on (which it is if <code>--strict</code> is on), then the type of each parameter must be either inferrable or explicitly specified. (We’ll take a closer look at inference later.) For parameters, no inference is possible, which is why <code>str</code> and <code>times</code> have type annotations.</p>
  </li>
  <li>
    <p>Return type: By default, the return type of functions is inferred. That is usually good enough. We opted to explicitly specify that <code>repeat1()</code> has the return type <code>string</code> (last type annotation in line A).</p>
  </li>
</ul>
<h4 id="arrow-functions"><a class="heading-id-link" href="#arrow-functions">27.1.2 Arrow functions</a></h4>
<p>The arrow function version of <code>repeat1()</code> looks as follows:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> repeat2 = (<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">times</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> {</code>
<code>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">repeat</span>(times);</code>
<code>};</code>
</pre>
<p>Arrow functions can also have expression bodies:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> repeat3 = (<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">times</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span></code>
<code>  str.<span class="hljs-title function_">repeat</span>(times);</code>
</pre>
<h3 id="types-for-functions"><a class="heading-id-link" href="#types-for-functions">27.2 Types for functions</a></h3>
<h4 id="function-type-signatures"><a class="heading-id-link" href="#function-type-signatures">27.2.1 Function type signatures</a></h4>
<p>We can define types for functions via function type signatures:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Repeat</span> = <span class="hljs-function">(<span class="hljs-params">str: <span class="hljs-built_in">string</span>, times: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">string</span>;</code>
</pre>
<p>The name of this function type is <code>Repeat</code>. It has:</p>
<ul>
  <li>
    Two parameters whose types are <code>string</code> and <code>number</code>. We need to name parameters in function type signatures, but the names are ignored when checking if two function types are compatible.
  </li>
  <li>
    The return type <code>string</code>. Note that this time, the type is separated by an arrow and can’t be omitted.
  </li>
</ul>
<p>Which functions are assignable to this type? At least those that have the same parameter types and return type. But some others are assignable too. We’ll see which ones, when we explore the rules for <a href="#assignability"><em>assignability</em></a> later in this chapter.</p>
<h4 id="call-signatures"><a class="heading-id-link" href="#call-signatures">27.2.2 Interfaces with call signatures</a></h4>
<p><span id="index-entry-call-signature"/><span id="index-entry-signature--call"/></p>
<p>We can also use interfaces to define function types:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Repeat</span> {</code>
<code>  (<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">times</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>; <span class="hljs-comment">// (A)</span></code>
<code>}</code>
</pre>
<p>Note:</p>
<ul>
  <li>
    The interface member in line A is a <em>call signature</em>. It looks similar to a method signature, but doesn’t have a name.
  </li>
  <li>
    The type of the result is separated by a colon (not an arrow) and can’t be omitted.
  </li>
</ul>
<p>On one hand, interfaces are more verbose. On the other hand, they let us specify properties of functions (which is rare, but does happen):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Incrementor1</span> {</code>
<code>  (<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;</code>
<code>  <span class="hljs-attr">increment</span>: <span class="hljs-built_in">number</span>;</code>
<code>}</code>
</pre>
<p>We can also specify properties via an intersection type (<code>&amp;</code>) of a function signature type and an object literal type:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Incrementor2</span> =</code>
<code>  &amp; (<span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>)</code>
<code>  &amp; { <span class="hljs-attr">increment</span>: <span class="hljs-built_in">number</span> }</code>
<code>;</code>
</pre>
<h4 id="checking-if-a-callable-value-matches-a-function-type"><a class="heading-id-link" href="#checking-if-a-callable-value-matches-a-function-type">27.2.3 Checking if a callable value matches a function type</a></h4>
<p>As an example, consider this scenario: A library exports the following function type.</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">StringPredicate</span> = <span class="hljs-function">(<span class="hljs-params">str: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span>;</code>
</pre>
<p>We want to define a function whose type is compatible with <code>StringPredicate</code>. And we want to check immediately if that’s indeed the case (vs. finding out later when we use it for the first time).</p>
<h5 id="checking-arrow-functions"><a class="heading-id-link" href="#checking-arrow-functions">27.2.3.1 Checking arrow functions</a></h5>
<p>If we declare a variable via <code>const</code>, we can perform the check via a type annotation:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">pred1</span>: <span class="hljs-title class_">StringPredicate</span> = <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> str.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>;</code>
</pre>
<p>Note that we don’t need to specify the type of parameter <code>str</code> because TypeScript can use <code>StringPredicate</code> to infer it.</p>
<h5 id="checking-function-declarations-simple"><a class="heading-id-link" href="#checking-function-declarations-simple">27.2.3.2 Checking function declarations (simple)</a></h5>
<p>Checking function declarations is more complicated. Consider the following function declaration:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">pred2</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> {</code>
<code>  <span class="hljs-keyword">return</span> str.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>;</code>
<code>}</code>
</pre>
<p>These are two built-in ways in which we can check assignability:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">pred2ImplementsStringPredicate</span>: <span class="hljs-title class_">StringPredicate</span> = pred2;</code>
<code>pred2 satisfies <span class="hljs-title class_">StringPredicate</span>;</code>
</pre>
<p><code>satisfies</code> is explained in <a href="ch_satisfies.html#ch_satisfies">“The <code>satisfies</code> operator” (§29)</a>.</p>
<p>The following two checks require the library <code>asserttt</code>:</p>
<pre class="language-ts">
<code>assertType&lt;<span class="hljs-title class_">StringPredicate</span>&gt;(pred2);</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Assignable</span>&lt;</code>
<code>  <span class="hljs-title class_">StringPredicate</span>,</code>
<code>  <span class="hljs-keyword">typeof</span> pred2</code>
<code>&gt;&gt;;</code>
</pre>
<p>Note that all checks but the last one produce unnecessary JavaScript code.</p>
<h5 id="checking-function-declarations-extravagant"><a class="heading-id-link" href="#checking-function-declarations-extravagant">27.2.3.3 Checking function declarations (extravagant)</a></h5>
<p>The following solution is something you’d usually not do – so no worries if you don’t fully understand it. But it nicely demonstrates several advanced features:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">pred3</span>(</code>
<code><span class="hljs-params">  ...[str]: Parameters&lt;StringPredicate&gt;</span></code>
<code>): <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-title class_">StringPredicate</span>&gt;</code>
<code>{</code>
<code>  <span class="hljs-keyword">return</span> str.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>;</code>
<code>}</code>
</pre>
<ul>
  <li>
    <p>Parameters: We use the utility type <code>Parameters&lt;&gt;</code> to extract a tuple with the parameter types. The three dots declare a rest parameter, which collects all parameters in a tuple/Array. <code>[str]</code> destructures that tuple. (More on rest parameters later in this chapter.)</p>
  </li>
  <li>
    <p>Return value: We use the utility type <code>ReturnType&lt;&gt;</code> to extract the return type.</p>
  </li>
</ul>
<p>The built-in utility types <code>Parameters&lt;&gt;</code> and <code>ReturnType&lt;&gt;</code> are explained in <a href="ch_infer-keyword.html#extracting-parts-of-function-types">“Extracting parts of function types via <code>infer</code>” (§35.3.1)</a>.</p>
<h3 id="parameters"><a class="heading-id-link" href="#parameters">27.3 Parameters</a></h3>
<h4 id="when-do-parameters-have-to-be-type-annotated"><a class="heading-id-link" href="#when-do-parameters-have-to-be-type-annotated">27.3.1 When do parameters have to be type-annotated?</a></h4>
<p>Recap: If <code>--noImplicitAny</code> is switched on (<code>--strict</code> switches it on), the type of each parameter must either be inferrable or explicitly specified.</p>
<p>In the following example, TypeScript can’t infer the type of <code>str</code> and we must specify it:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">twice</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span></span>) {</code>
<code>  <span class="hljs-keyword">return</span> str + str;</code>
<code>}</code>
</pre>
<p>In line A, TypeScript can use the type <code>StringMapFunction</code> to infer the type of <code>str</code> and we don’t need to add a type annotation:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">StringMapFunction</span> = <span class="hljs-function">(<span class="hljs-params">str: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">string</span>;</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">twice</span>: <span class="hljs-title class_">StringMapFunction</span> = <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> str + str; <span class="hljs-comment">// (A)</span></code>
</pre>
<p>Here, TypeScript can use the type of <code>.map()</code> to infer the type of <code>str</code>:</p>
<pre class="language-ts">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> str + str),</code>
<code>  [<span class="hljs-string">'aa'</span>, <span class="hljs-string">'bb'</span>, <span class="hljs-string">'cc'</span>]</code>
<code>);</code>
</pre>
<p>This is the type of <code>.map()</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Array</span>&lt;T&gt; {</code>
<code>  map&lt;U&gt;(</code>
<code>    <span class="hljs-attr">callbackfn</span>: <span class="hljs-function">(<span class="hljs-params">value: T, index: <span class="hljs-built_in">number</span>, array: T[]</span>) =&gt;</span> U,</code>
<code>    thisArg?: <span class="hljs-built_in">any</span></code>
<code>  ): U[];</code>
<code>  <span class="hljs-comment">// ···</span></code>
<code>}</code>
</pre>
<h4 id="optional-parameters-1"><a class="heading-id-link" href="#optional-parameters-1">27.3.2 Optional parameters</a></h4>
<p>In this section, we look at several ways in which we can allow parameters to be omitted.</p>
<h5 id="optional-parameter-str-string"><a class="heading-id-link" href="#optional-parameter-str-string">27.3.2.1 Optional parameter: <code>str?: string</code></a></h5>
<p>If we put a question mark after the name of a parameter, that parameter becomes optional and can be omitted when calling the function:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">trim1</span>(<span class="hljs-params">str?: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span> {</code>
<code>  <span class="hljs-comment">// Internal type of str:</span></code>
<code>  assertType&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>&gt;(str);</code>
<code/>
<code>  <span class="hljs-keyword">if</span> (str === <span class="hljs-literal">undefined</span>) {</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;</code>
<code>  }</code>
<code>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">trim</span>();</code>
<code>}</code>
<code/>
<code><span class="hljs-comment">// External type of trim1:</span></code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-keyword">typeof</span> trim1,</code>
<code>  <span class="hljs-function">(<span class="hljs-params">str?: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span></span>) =&gt;</span> <span class="hljs-built_in">string</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>This is how <code>trim1()</code> can be invoked:</p>
<pre class="language-ts">
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">trim1</span>(<span class="hljs-string">'\n  abc \t'</span>), <span class="hljs-string">'abc'</span></code>
<code>);</code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">trim1</span>(), <span class="hljs-string">''</span></code>
<code>);</code>
<code/>
<code><span class="hljs-comment">// `undefined` is equivalent to omitting the parameter</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">trim1</span>(<span class="hljs-literal">undefined</span>), <span class="hljs-string">''</span></code>
<code>);</code>
</pre>
<p>As an aside, the following two types are equal (<code>Equal&lt;&gt;</code> is a strict check) because the optional modifier (<code>?</code>) implies the type <code>undefined</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-function">(<span class="hljs-params">str?: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span></span>) =&gt;</span> <span class="hljs-built_in">string</span>,</code>
<code>  <span class="hljs-function">(<span class="hljs-params">str?: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">string</span></code>
<code>&gt;&gt;;</code>
</pre>
<h5 id="union-type-str-string-undefined"><a class="heading-id-link" href="#union-type-str-string-undefined">27.3.2.2 Union type: <code>str: string | undefined</code></a></h5>
<p>Externally, parameter <code>str</code> of <code>trim1()</code> has the type <code>string | undefined</code>. Therefore, <code>trim1()</code> is mostly equivalent to the following function.</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">trim2</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span></span>): <span class="hljs-built_in">string</span> {</code>
<code>  <span class="hljs-comment">// Internal type of str:</span></code>
<code>  assertType&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>&gt;(str);</code>
<code/>
<code>  <span class="hljs-keyword">if</span> (str === <span class="hljs-literal">undefined</span>) {</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;</code>
<code>  }</code>
<code>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">trim</span>();</code>
<code>}</code>
<code/>
<code><span class="hljs-comment">// External type of trim2:</span></code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-keyword">typeof</span> trim2,</code>
<code>  <span class="hljs-function">(<span class="hljs-params">str: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span></span>) =&gt;</span> <span class="hljs-built_in">string</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>The only way in which <code>trim2()</code> is different from <code>trim1()</code> is that the parameter can’t be omitted in function calls (line A). In other words: We must be explicit when omitting a parameter whose type is <code>T|undefined</code>.</p>
<pre class="language-ts">
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">trim2</span>(<span class="hljs-string">'\n  abc \t'</span>), <span class="hljs-string">'abc'</span></code>
<code>);</code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Expected 1 arguments, but got 0.</span></code>
<code><span class="hljs-title function_">trim2</span>(); <span class="hljs-comment">// (A)</span></code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">trim2</span>(<span class="hljs-literal">undefined</span>), <span class="hljs-string">''</span> <span class="hljs-comment">// OK!</span></code>
<code>);</code>
</pre>
<h5 id="parameter-default-value-str"><a class="heading-id-link" href="#parameter-default-value-str">27.3.2.3 Parameter default value: <code>str = ''</code></a></h5>
<p>If we specify a parameter default value for <code>str</code>, we don’t need to provide a type annotation because TypeScript can infer the type:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">trim3</span>(<span class="hljs-params">str = <span class="hljs-string">''</span></span>): <span class="hljs-built_in">string</span> {</code>
<code>  <span class="hljs-comment">// Internal type of str:</span></code>
<code>  assertType&lt;<span class="hljs-built_in">string</span>&gt;(str);</code>
<code/>
<code>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">trim</span>();</code>
<code>}</code>
<code/>
<code><span class="hljs-comment">// External type of trim3:</span></code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-keyword">typeof</span> trim3,</code>
<code>  <span class="hljs-function">(<span class="hljs-params">str?: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span></span>) =&gt;</span> <span class="hljs-built_in">string</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>The internal type of <code>str</code> is <code>string</code> because the default value ensures that it is never <code>undefined</code>.</p>
<p>Let’s invoke <code>trim3()</code>:</p>
<pre class="language-ts">
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">trim3</span>(<span class="hljs-string">'\n  abc \t'</span>), <span class="hljs-string">'abc'</span>);</code>
<code/>
<code><span class="hljs-comment">// Omitting the parameter triggers the parameter default value:</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">trim3</span>(), <span class="hljs-string">''</span>);</code>
<code/>
<code><span class="hljs-comment">// `undefined` is allowed and triggers the parameter default value:</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">trim3</span>(<span class="hljs-literal">undefined</span>), <span class="hljs-string">''</span>);</code>
</pre>
<h5 id="parameter-default-value-plus-type-annotation"><a class="heading-id-link" href="#parameter-default-value-plus-type-annotation">27.3.2.4 Parameter default value plus type annotation</a></h5>
<p>We can also specify both a type and a default value:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">trim4</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span> = <span class="hljs-string">''</span></span>): <span class="hljs-built_in">string</span> {</code>
<code>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">trim</span>();</code>
<code>}</code>
</pre>
<h4 id="rest-parameters-1"><a class="heading-id-link" href="#rest-parameters-1">27.3.3 Rest parameters</a></h4>
<p>A rest parameter collects all remaining parameters in an Array. Therefore, its static type is an Array or a tuple.</p>
<h5 id="rest-parameters-with-array-types"><a class="heading-id-link" href="#rest-parameters-with-array-types">27.3.3.1 Rest parameters with Array types</a></h5>
<p>In the following example, the rest parameter <code>parts</code> has an Array type:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">join</span>(<span class="hljs-params">separator: <span class="hljs-built_in">string</span>, ...parts: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;</span>) {</code>
<code>  <span class="hljs-keyword">return</span> parts.<span class="hljs-title function_">join</span>(separator);</code>
<code>}</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">join</span>(<span class="hljs-string">'-'</span>, <span class="hljs-string">'state'</span>, <span class="hljs-string">'of'</span>, <span class="hljs-string">'the'</span>, <span class="hljs-string">'art'</span>),</code>
<code>  <span class="hljs-string">'state-of-the-art'</span>);</code>
</pre>
<h5 id="rest-parameters-with-tuple-types"><a class="heading-id-link" href="#rest-parameters-with-tuple-types">27.3.3.2 Rest parameters with tuple types</a></h5>
<p>The next example demonstrates two features:</p>
<ul>
  <li>
    We use the tuple type <code>[string, number]</code> for a rest parameter.
  </li>
  <li>
    We destructure the rest parameter – which is a JavaScript feature.
  </li>
</ul>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">repeat1</span>(<span class="hljs-params">...[str, times]: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>]</span>): <span class="hljs-built_in">string</span> {</code>
<code>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">repeat</span>(times);</code>
<code>}</code>
</pre>
<p><code>repeat1()</code> is equivalent to the following function:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">repeat2</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span>, times: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> {</code>
<code>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">repeat</span>(times);</code>
<code>}</code>
</pre>
<h4 id="named-parameters"><a class="heading-id-link" href="#named-parameters">27.3.4 Named parameters</a></h4>
<p><a href="https://exploringjs.com/js/book/ch_callables.html#named-parameters"><em>Named parameters</em></a> are a popular pattern in JavaScript where an object literal is used to give each parameter a name. That looks as follows:</p>
<pre class="language-ts">
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">padStart</span>({<span class="hljs-attr">str</span>: <span class="hljs-string">'7'</span>, <span class="hljs-attr">len</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">fillStr</span>: <span class="hljs-string">'0'</span>}),</code>
<code>  <span class="hljs-string">'007'</span></code>
<code>);</code>
</pre>
<p>In plain JavaScript, functions can use destructuring to access named parameter values. Alas, in TypeScript, we additionally have to specify a type for the object literal and that leads to redundancies:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">padStart</span>(</code>
<code><span class="hljs-params">  { str, len, fillStr = <span class="hljs-string">' '</span> } <span class="hljs-comment">// (A)</span></span></code>
<code><span class="hljs-params">  : { str: <span class="hljs-built_in">string</span>, len: <span class="hljs-built_in">number</span>, fillStr: <span class="hljs-built_in">string</span> } <span class="hljs-comment">// (B)</span></span></code>
<code>): <span class="hljs-built_in">string</span> {</code>
<code>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">padStart</span>(len, fillStr);</code>
<code>}</code>
</pre>
<p>Note that the destructuring (incl. the default value for <code>fillStr</code>) all happens in line A, while line B is exclusively about TypeScript.</p>
<p>We can also define a separate type instead of the inlined object literal type that we used in line B:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">padStart</span>(</code>
<code><span class="hljs-params">  { str, len, fillStr = <span class="hljs-string">' '</span> }: PadStartArgs</span></code>
<code>): <span class="hljs-built_in">string</span> {</code>
<code>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">padStart</span>(len, fillStr);</code>
<code>}</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">PadStartArgs</span> = {</code>
<code>  <span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>,</code>
<code>  <span class="hljs-attr">len</span>: <span class="hljs-built_in">number</span>,</code>
<code>  <span class="hljs-attr">fillStr</span>: <span class="hljs-built_in">string</span>,</code>
<code>};</code>
</pre>
<p>An upside is that the function declaration is less cluttered. A downside that we have to look elsewhere to see the types.</p>
<h4 id="this-as-a-parameter-advanced"><a class="heading-id-link" href="#this-as-a-parameter-advanced">27.3.5 <code>this</code> as a parameter (advanced)</a></h4>
<p>Each ordinary function always has the implicit parameter <code>this</code> – which enables it to be used as a method in objects. Sometimes we need to specify a type for <code>this</code>. There is TypeScript-only syntax for this use case: One of the parameters of an ordinary function can have the name <code>this</code>. Such a parameter only exists at compile time and disappears at runtime.</p>
<p>As an example, consider the following interface for DOM event sources (in a slightly simplified version):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">EventSource</span> {</code>
<code>  <span class="hljs-title function_">addEventListener</span>(</code>
<code>    <span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span>,</code>
<code>    <span class="hljs-attr">listener</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-variable language_">this</span>: EventSource, ev: Event</span>) =&gt;</span> <span class="hljs-built_in">any</span>,</code>
<code>    options?: <span class="hljs-built_in">boolean</span> | <span class="hljs-title class_">AddEventListenerOptions</span></code>
<code>  ): <span class="hljs-built_in">void</span>;</code>
<code>  <span class="hljs-comment">// ···</span></code>
<code>}</code>
</pre>
<p>The <code>this</code> of the callback <code>listener</code> is always an instance of <code>EventSource</code>.</p>
<p>The next example demonstrates that TypeScript uses the type information provided by the <code>this</code> parameter to check the first argument of <code>.call()</code> (line A and line B):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">toIsoString</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span>: <span class="hljs-built_in">Date</span></span>): <span class="hljs-built_in">string</span> {</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toISOString</span>();</code>
<code>}</code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Argument of type 'string' is not assignable to</span></code>
<code><span class="hljs-comment">// parameter of type 'Date'.</span></code>
<code>assert.<span class="hljs-title function_">throws</span>(<span class="hljs-function">() =&gt;</span> toIsoString.<span class="hljs-title function_">call</span>(<span class="hljs-string">'abc'</span>)); <span class="hljs-comment">// (A) error</span></code>
<code/>
<code>toIsoString.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()); <span class="hljs-comment">// (B) OK</span></code>
</pre>
<p>Additionally, we can’t invoke <code>toIsoString()</code> as a method of an object <code>obj</code> because then its receiver isn’t an instance of <code>Date</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> obj = { toIsoString };</code>
<code><span class="hljs-comment">// @ts-expect-error: The 'this' context of type</span></code>
<code><span class="hljs-comment">// '{ toIsoString: (this: Date) =&gt; string; }' is not assignable to</span></code>
<code><span class="hljs-comment">// method's 'this' of type 'Date'.</span></code>
<code>assert.<span class="hljs-title function_">throws</span>(<span class="hljs-function">() =&gt;</span> obj.<span class="hljs-title function_">toIsoString</span>()); <span class="hljs-comment">// error</span></code>
<code>obj.<span class="hljs-property">toIsoString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()); <span class="hljs-comment">// OK</span></code>
</pre>
<h3 id="return-type-never"><a class="heading-id-link" href="#return-type-never">27.4 Return type <code>never</code>: functions that don’t return</a></h3>
<p><code>never</code> also serves as a marker for functions that never return – e.g.:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">throwError</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">never</span> {</code>
<code>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(message);</code>
<code>}</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">infiniteLoop</span>(<span class="hljs-params">): <span class="hljs-built_in">never</span> {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {}</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p>TypeScript’s type inference takes such functions into consideration. For example, the inferred return type of <code>returnStringIfTrue()</code> is <code>string</code> because we invoke <code>throwError()</code> in line A.</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">returnStringIfTrue</span>(<span class="hljs-params">flag: <span class="hljs-built_in">boolean</span></span>) {</code>
<code>  <span class="hljs-keyword">if</span> (flag) {</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-string">'abc'</span>;</code>
<code>  }</code>
<code>  <span class="hljs-title function_">throwError</span>(<span class="hljs-string">'Flag must be true'</span>); <span class="hljs-comment">// (A)</span></code>
<code>}</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> returnStringIfTrue&gt;,</code>
<code>  <span class="hljs-built_in">string</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>If we omit line A then we get an error and the inferred return type is <code>'abc' | undefined</code>:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// @ts-expect-error: Not all code paths return a value.</span></code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">returnStringIfTrue</span>(<span class="hljs-params">flag: <span class="hljs-built_in">boolean</span></span>) {</code>
<code>  <span class="hljs-keyword">if</span> (flag) {</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-string">'abc'</span>;</code>
<code>  }</code>
<code>}</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> returnStringIfTrue&gt;,</code>
<code>  <span class="hljs-string">'abc'</span> | <span class="hljs-literal">undefined</span></code>
<code>&gt;&gt;;</code>
</pre>
<h4 id="reasons-against-the-return-type-never-t"><a class="heading-id-link" href="#reasons-against-the-return-type-never-t">27.4.1 Reasons against the return type <code>never | T</code></a></h4>
<p>In principle we could use the type <code>never | T</code> for a function that, in some cases, throws an exception and does not return normally. However there are two reasons against doing that:</p>
<ul>
  <li>
    Throwing an exception normally does not change the return type of a function. That’s why it’s called an <em>exception</em>.
  </li>
  <li>
    <code>never | T</code> is the same as <code>T</code> (as we have seen previously in this chapter).
  </li>
</ul>
<h4 id="the-return-type-never-in-types-node"><a class="heading-id-link" href="#the-return-type-never-in-types-node">27.4.2 The return type <code>never</code> in <code>@types/node</code></a></h4>
<p>In Node.js, the following functions have the return type <code>never</code>:</p>
<ul>
  <li>
    <code>process.exit()</code>
  </li>
  <li>
    <code>process.abort()</code>
  </li>
  <li>
    <code>assert.fail()</code>
  </li>
</ul>
<h3 id="overloading-advanced"><a class="heading-id-link" href="#overloading-advanced">27.5 Overloading (advanced)</a></h3>
<p>Sometimes a single type signature does not adequately describe how a function works.</p>
<h4 id="overloading-function-declarations"><a class="heading-id-link" href="#overloading-function-declarations">27.5.1 Overloading function declarations</a></h4>
<p>Consider function <code>getFullName()</code> which we are calling in the following example (line A and line B):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Customer</span> {</code>
<code>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;</code>
<code>  <span class="hljs-attr">fullName</span>: <span class="hljs-built_in">string</span>;</code>
<code>}</code>
<code><span class="hljs-keyword">const</span> jane = {<span class="hljs-attr">id</span>: <span class="hljs-string">'1234'</span>, <span class="hljs-attr">fullName</span>: <span class="hljs-string">'Jane Bond'</span>};</code>
<code><span class="hljs-keyword">const</span> lars = {<span class="hljs-attr">id</span>: <span class="hljs-string">'5678'</span>, <span class="hljs-attr">fullName</span>: <span class="hljs-string">'Lars Croft'</span>};</code>
<code><span class="hljs-keyword">const</span> idToCustomer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Customer</span>&gt;([</code>
<code>  [<span class="hljs-string">'1234'</span>, jane],</code>
<code>  [<span class="hljs-string">'5678'</span>, lars],</code>
<code>]);</code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">getFullName</span>(idToCustomer, <span class="hljs-string">'1234'</span>), <span class="hljs-string">'Jane Bond'</span> <span class="hljs-comment">// (A)</span></code>
<code>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">getFullName</span>(lars), <span class="hljs-string">'Lars Croft'</span> <span class="hljs-comment">// (B)</span></code>
<code>);</code>
</pre>
<p>How would we implement <code>getFullName()</code>? The following implementation works for the two function calls in the previous example:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFullName</span>(</code>
<code><span class="hljs-params">  customerOrMap: Customer | <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">string</span>, Customer&gt;,</span></code>
<code><span class="hljs-params">  id?: <span class="hljs-built_in">string</span></span></code>
<code>): <span class="hljs-built_in">string</span> {</code>
<code>  <span class="hljs-keyword">if</span> (customerOrMap <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Map</span>) {</code>
<code>    <span class="hljs-keyword">if</span> (id === <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();</code>
<code>    <span class="hljs-keyword">const</span> customer = customerOrMap.<span class="hljs-title function_">get</span>(id);</code>
<code>    <span class="hljs-keyword">if</span> (customer === <span class="hljs-literal">undefined</span>) {</code>
<code>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Unknown ID: '</span> + id);</code>
<code>    }</code>
<code>    customerOrMap = customer;</code>
<code>  } <span class="hljs-keyword">else</span> {</code>
<code>    <span class="hljs-keyword">if</span> (id !== <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();</code>
<code>  }</code>
<code>  <span class="hljs-keyword">return</span> customerOrMap.<span class="hljs-property">fullName</span>;</code>
<code>}</code>
</pre>
<p>However, with this type signature, function calls are legal at compile time that produce runtime errors:</p>
<pre class="language-ts">
<code>assert.<span class="hljs-title function_">throws</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">getFullName</span>(idToCustomer)); <span class="hljs-comment">// missing ID</span></code>
<code>assert.<span class="hljs-title function_">throws</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">getFullName</span>(lars, <span class="hljs-string">'5678'</span>)); <span class="hljs-comment">// ID not allowed</span></code>
</pre>
<p>The following code fixes these issues:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFullName</span>(<span class="hljs-params">customer: Customer</span>): <span class="hljs-built_in">string</span>; <span class="hljs-comment">// (A)</span></code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFullName</span>(<span class="hljs-params"> <span class="hljs-comment">// (B)</span></span></code>
<code><span class="hljs-params">  map: <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">string</span>, Customer&gt;, id: <span class="hljs-built_in">string</span></span></code>
<code>): <span class="hljs-built_in">string</span>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFullName</span>(<span class="hljs-params"> <span class="hljs-comment">// (C)</span></span></code>
<code><span class="hljs-params">  customerOrMap: Customer | <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">string</span>, Customer&gt;,</span></code>
<code><span class="hljs-params">  id?: <span class="hljs-built_in">string</span></span></code>
<code>): <span class="hljs-built_in">string</span> {</code>
<code>  <span class="hljs-comment">// ···</span></code>
<code>}</code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Argument of type 'Map&lt;string, Customer&gt;' is not</span></code>
<code><span class="hljs-comment">// assignable to parameter of type 'Customer'.</span></code>
<code><span class="hljs-title function_">getFullName</span>(idToCustomer); <span class="hljs-comment">// missing ID</span></code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Argument of type '{ id: string; fullName: string; }'</span></code>
<code><span class="hljs-comment">// is not assignable to parameter of type 'Map&lt;string, Customer&gt;'.</span></code>
<code><span class="hljs-comment">// [...]</span></code>
<code><span class="hljs-title function_">getFullName</span>(lars, <span class="hljs-string">'5678'</span>); <span class="hljs-comment">// ID not allowed</span></code>
</pre>
<p>What is going on here? The type signature of <code>getFullName()</code> is overloaded:</p>
<ul>
  <li>
    The function has two external <em>overload signatures</em>: type signatures without implementations (line A and line B).
  </li>
  <li>
    It also has one <em>implementation signature</em>: the type signature of the actual implementation, which is internal and must be compatible with both external signatures. Incidentally, it is the same as in the previous example.
  </li>
</ul>
<p>My advice is to only use overloading when it can’t be avoided. One alternative is to split an overloaded function into multiple functions with different names – for example:</p>
<ul>
  <li>
    <code>getFullName()</code>
  </li>
  <li>
    <code>getFullNameViaMap()</code>
  </li>
</ul>
<h4 id="overloading-functions-via-a-union-of-tuple-types"><a class="heading-id-link" href="#overloading-functions-via-a-union-of-tuple-types">27.5.2 Overloading functions via a union of tuple types</a></h4>
<p>We can also overload a function via a union of tuple types (line A):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Customer</span> {</code>
<code>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;</code>
<code>  <span class="hljs-attr">fullName</span>: <span class="hljs-built_in">string</span>;</code>
<code>}</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFullName</span>(</code>
<code><span class="hljs-params">  ...args: <span class="hljs-comment">// (A)</span></span></code>
<code><span class="hljs-params">    | [customer: Customer]</span></code>
<code><span class="hljs-params">    | [map: <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">string</span>, Customer&gt;, id: <span class="hljs-built_in">string</span>]</span></code>
<code>): <span class="hljs-built_in">string</span> {</code>
<code>  <span class="hljs-keyword">if</span> (args.<span class="hljs-property">length</span> === <span class="hljs-number">2</span>) {</code>
<code>    <span class="hljs-comment">// Type is narrowed:</span></code>
<code>    assertType&lt;</code>
<code>      [<span class="hljs-attr">map</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Customer</span>&gt;, <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>]</code>
<code>    &gt;(args);</code>
<code>    <span class="hljs-keyword">const</span> [map, id] = args;</code>
<code>    <span class="hljs-keyword">const</span> customer = map.<span class="hljs-title function_">get</span>(id);</code>
<code>    <span class="hljs-keyword">if</span> (customer === <span class="hljs-literal">undefined</span>) {</code>
<code>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Unknown ID: '</span> + id);</code>
<code>    }</code>
<code>    <span class="hljs-keyword">return</span> customer.<span class="hljs-property">fullName</span>;</code>
<code>  } <span class="hljs-keyword">else</span> {</code>
<code>    <span class="hljs-keyword">const</span> [customer] = args;</code>
<code>    <span class="hljs-keyword">return</span> customer.<span class="hljs-property">fullName</span>;</code>
<code>  }</code>
<code>}</code>
</pre>
<p>Keep in mind that this kind of overloading only works if the return type is the same for all cases.</p>
<p>Note the labels for the elements of the tuple types:</p>
<pre class="language-ts">
<code>[ <span class="hljs-attr">customer</span>: <span class="hljs-title class_">Customer</span> ]</code>
<code>[ <span class="hljs-attr">map</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Customer</span>&gt;, <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span> ]</code>
</pre>
<p>These labels are optional and mostly ignored, but may show up in auto-completions and type hints. In other words: They work more like comments. The previous two types are equivalent to:</p>
<pre class="language-ts">
<code>[ <span class="hljs-title class_">Customer</span> ]</code>
<code>[ <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Customer</span>&gt;, <span class="hljs-built_in">string</span> ]</code>
</pre>
<p>For more information, see <a href="ch_computing-with-tuple-types.html#labeled-tuple-elements">“Labeled tuple elements” (§37.1.3)</a>.</p>
<h4 id="overloading-functions-via-interfaces"><a class="heading-id-link" href="#overloading-functions-via-interfaces">27.5.3 Overloading functions via interfaces</a></h4>
<p>In interfaces, we can have multiple, different call signatures. That enables us to use the interface <code>GetFullName</code> for overloading in the following example:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Customer</span> {</code>
<code>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;</code>
<code>  <span class="hljs-attr">fullName</span>: <span class="hljs-built_in">string</span>;</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">GetFullName</span> {</code>
<code>  (<span class="hljs-attr">customerOrMap</span>: <span class="hljs-title class_">Customer</span>): <span class="hljs-built_in">string</span>;</code>
<code>  (<span class="hljs-attr">customerOrMap</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Customer</span>&gt;, <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">getFullName</span>: <span class="hljs-title class_">GetFullName</span> = (</code>
<code>  <span class="hljs-attr">customerOrMap</span>: <span class="hljs-title class_">Customer</span> | <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Customer</span>&gt;,</code>
<code>  id?: <span class="hljs-built_in">string</span></code>
<code>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> {</code>
<code>  <span class="hljs-keyword">if</span> (customerOrMap <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Map</span>) {</code>
<code>    <span class="hljs-keyword">if</span> (id === <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();</code>
<code>    <span class="hljs-keyword">const</span> customer = customerOrMap.<span class="hljs-title function_">get</span>(id);</code>
<code>    <span class="hljs-keyword">if</span> (customer === <span class="hljs-literal">undefined</span>) {</code>
<code>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Unknown ID: '</span> + id);</code>
<code>    }</code>
<code>    customerOrMap = customer;</code>
<code>  } <span class="hljs-keyword">else</span> {</code>
<code>    <span class="hljs-keyword">if</span> (id !== <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();</code>
<code>  }</code>
<code>  <span class="hljs-keyword">return</span> customerOrMap.<span class="hljs-property">fullName</span>;</code>
<code>}</code>
</pre>
<h4 id="overloading-on-string-parameters"><a class="heading-id-link" href="#overloading-on-string-parameters">27.5.4 Overloading on string parameters (event handling etc.)</a></h4>
<p>In the next example, we overload and use string literal types (such as <code>'click'</code>). That allows us to change the type of parameter <code>listener</code> depending on the value of parameter <code>type</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">addEventListener</span>(</code>
<code><span class="hljs-params">  elem: HTMLElement, <span class="hljs-keyword">type</span>: <span class="hljs-string">'click'</span>,</span></code>
<code><span class="hljs-params">  listener: (event: MouseEvent) =&gt; <span class="hljs-built_in">void</span></span></code>
<code>): <span class="hljs-built_in">void</span>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">addEventListener</span>(</code>
<code><span class="hljs-params">  elem: HTMLElement, <span class="hljs-keyword">type</span>: <span class="hljs-string">'keypress'</span>,</span></code>
<code><span class="hljs-params">  listener: (event: KeyboardEvent) =&gt; <span class="hljs-built_in">void</span></span></code>
<code>): <span class="hljs-built_in">void</span>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">addEventListener</span>(<span class="hljs-params"> <span class="hljs-comment">// (A)</span></span></code>
<code><span class="hljs-params">  elem: HTMLElement, <span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span>,</span></code>
<code><span class="hljs-params">  listener: (event: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">void</span></span></code>
<code>): <span class="hljs-built_in">void</span> {</code>
<code>  elem.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-keyword">type</span>, listener); <span class="hljs-comment">// (B)</span></code>
<code>}</code>
</pre>
<p>In this case, it is relatively difficult to get the types of the implementation (starting in line A) right, so that the statement in the body (line B) works. As a last resort, we used the type <code>any</code> for parameter <code>event</code> of <code>listener</code>.</p>
<h4 id="overloading-methods"><a class="heading-id-link" href="#overloading-methods">27.5.5 Overloading methods</a></h4>
<h5 id="overloading-concrete-methods"><a class="heading-id-link" href="#overloading-concrete-methods">27.5.5.1 Overloading concrete methods</a></h5>
<p>The next example demonstrates overloading of methods: Method <code>.add()</code> is overloaded.</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBuilder</span> {</code>
<code>  #data = <span class="hljs-string">''</span>;</code>
<code/>
<code>  <span class="hljs-title function_">add</span>(<span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span>): <span class="hljs-variable language_">this</span>;</code>
<code>  <span class="hljs-title function_">add</span>(<span class="hljs-attr">bool</span>: <span class="hljs-built_in">boolean</span>): <span class="hljs-variable language_">this</span>;</code>
<code>  <span class="hljs-title function_">add</span>(<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>): <span class="hljs-variable language_">this</span>;</code>
<code>  <span class="hljs-title function_">add</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">any</span>): <span class="hljs-variable language_">this</span> {</code>
<code>    <span class="hljs-variable language_">this</span>.#data += <span class="hljs-title class_">String</span>(value);</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;</code>
<code>  }</code>
<code/>
<code>  <span class="hljs-title function_">toString</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#data;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">}</span></code>
<code/>
<code><span class="hljs-params"><span class="hljs-keyword">const</span> sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();</span></code>
<code><span class="hljs-params">sb</span></code>
<code><span class="hljs-params">  .<span class="hljs-title function_">add</span>(<span class="hljs-string">'I can see '</span>)</span></code>
<code><span class="hljs-params">  .<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>)</span></code>
<code><span class="hljs-params">  .<span class="hljs-title function_">add</span>(<span class="hljs-string">' monkeys!'</span>)</span></code>
<code><span class="hljs-params">;</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span></code>
<code><span class="hljs-params">  sb.<span class="hljs-title function_">toString</span>(), <span class="hljs-string">'I can see 3 monkeys!'</span></span></code>
<code><span class="hljs-params">)</span></code>
</pre>
<h5 id="overloading-interface-methods"><a class="heading-id-link" href="#overloading-interface-methods">27.5.5.2 Overloading interface methods</a></h5>
<p>The type definition for <code>Array.from()</code> is an example of an overloaded interface method:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ArrayConstructor</span> {</code>
<code>  <span class="hljs-keyword">from</span>&lt;T&gt;(<span class="hljs-attr">arrayLike</span>: <span class="hljs-title class_">ArrayLike</span>&lt;T&gt;): T[];</code>
<code>  <span class="hljs-keyword">from</span>&lt;T, U&gt;(</code>
<code>    <span class="hljs-attr">arrayLike</span>: <span class="hljs-title class_">ArrayLike</span>&lt;T&gt;,</code>
<code>    <span class="hljs-attr">mapfn</span>: <span class="hljs-function">(<span class="hljs-params">v: T, k: <span class="hljs-built_in">number</span></span>) =&gt;</span> U,</code>
<code>    thisArg?: <span class="hljs-built_in">any</span></code>
<code>  ): U[];</code>
<code>}</code>
</pre>
<ul>
  <li>
    <p>In the first signature, the returned Array has the same element type as the parameter.</p>
  </li>
  <li>
    <p>In the second signature, the elements of the returned Array have the same type as the result of <code>mapfn</code>. This version of <code>Array.from()</code> is similar to <code>Array.prototype.map()</code>.</p>
  </li>
</ul>
<h3 id="assignability"><a class="heading-id-link" href="#assignability">27.6 Assignability (advanced)</a></h3>
<p>In this section we look at the type compatibility rules for <em>assignability</em>: Can functions of type <code>Src</code> be transferred to storage locations (variables, object properties, parameters, etc.) of type <code>Trg</code>?</p>
<p>Understanding assignability helps us answer questions such as:</p>
<ul>
  <li>
    Given the function type signature of a formal parameter, which functions can be passed as actual parameters in function calls?
  </li>
  <li>
    Given the function type signature of a property, which functions can be assigned to it?
  </li>
</ul>
<h4 id="the-rules-for-assignability"><a class="heading-id-link" href="#the-rules-for-assignability">27.6.1 The rules for assignability</a></h4>
<p>In this subsection, we examine general rules for assignability (including the rules for functions). In the next subsection, we explore what those rules mean for functions.</p>
<p>A type <code>Src</code> is <em>assignable</em> to a type <code>Trg</code> if one of the following conditions is true:</p>
<ul>
  <li>
    <code>Src</code> and <code>Trg</code> are identical types.
  </li>
  <li>
    <code>Src</code> or <code>Trg</code> is the <code>any</code> type.
  </li>
  <li>
    <code>Src</code> is a string literal type and <code>Trg</code> is the primitive type String.
  </li>
  <li>
    <code>Src</code> is a union type and each constituent type of <code>Src</code> is assignable to <code>Trg</code>.
  </li>
  <li>
    <code>Src</code> and <code>Trg</code> are function types and:
    <ul>
      <li>
        <code>Trg</code> has a rest parameter or the number of required parameters of <code>Src</code> is less than or equal to the total number of parameters of <code>Trg</code>.
      </li>
      <li>
        For parameters that are present in both signatures, each parameter type in <code>Trg</code> is assignable to the corresponding parameter type in <code>Src</code>.
      </li>
      <li>
        The return type of <code>Trg</code> is <code>void</code> or the return type of <code>Src</code> is assignable to the return type of <code>Trg</code>.
      </li>
    </ul>
  </li>
  <li>
    (Remaining conditions omitted.)
  </li>
</ul>
<h4 id="consequences-of-the-assignment-rules-for-functions"><a class="heading-id-link" href="#consequences-of-the-assignment-rules-for-functions">27.6.2 Consequences of the assignment rules for functions</a></h4>
<p>In this subsection, we look at what the assignment rules mean for the following two functions <code>targetFunc</code> and <code>sourceFunc</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">targetFunc</span>: <span class="hljs-title class_">Trg</span> = sourceFunc;</code>
</pre>
<h5 id="types-of-parameters-and-results"><a class="heading-id-link" href="#types-of-parameters-and-results">27.6.2.1 Types of parameters and results</a></h5>
<ul>
  <li>
    Target parameter types must be assignable to corresponding source parameter types.
    <ul>
      <li>
        Why? Anything that the target accepts must also be accepted by the source.
      </li>
    </ul>
  </li>
  <li>
    The source return type must be assignable to target return type.
    <ul>
      <li>
        Why? Anything that the source returns must be compatible with the expectations set by the target.
      </li>
    </ul>
  </li>
</ul>
<p>Example:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">trg1</span>: <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">RegExp</span></span>) =&gt;</span> <span class="hljs-title class_">Object</span> = <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">Object</span></span>) =&gt;</span> <span class="hljs-regexp">/abc/</span>;</code>
</pre>
<p>The following example demonstrates that if the target return type is <code>void</code>, then the source return type doesn’t matter. Why is that? <code>void</code> results are always ignored in TypeScript.</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">trg2</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();</code>
</pre>
<h5 id="numbers-of-parameters"><a class="heading-id-link" href="#numbers-of-parameters">27.6.2.2 Numbers of parameters</a></h5>
<p>The source must not have more parameters than the target:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// @ts-expect-error: Type '(x: string) =&gt; string' is not assignable to</span></code>
<code><span class="hljs-comment">// type '() =&gt; string'.</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">trg3</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span> = <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-string">'abc'</span>;</code>
</pre>
<p>The source can have fewer parameters than the target:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">trg4</span>: <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">string</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-string">'abc'</span>;</code>
</pre>
<p>Why is that? The target specifies the expectations for the source: It must accept the parameter <code>x</code>. Which it does (but it ignores it). This permissiveness enables:</p>
<pre class="language-ts">
<code>[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + x)</code>
</pre>
<p>The callback for <code>.map()</code> only has one of the three parameters that are mentioned in the type signature of <code>.map()</code>:</p>
<pre class="language-ts">
<code>map&lt;U&gt;(</code>
<code>  <span class="hljs-attr">callback</span>: <span class="hljs-function">(<span class="hljs-params">value: T, index: <span class="hljs-built_in">number</span>, array: T[]</span>) =&gt;</span> U,</code>
<code>  thisArg?: <span class="hljs-built_in">any</span></code>
<code>): U[];</code>
</pre>
<h3 id="further-reading-and-sources-of-this-chapter"><a class="heading-id-link" href="#further-reading-and-sources-of-this-chapter">27.7 Further reading and sources of this chapter</a></h3>
<ul>
  <li>
    <a href="https://www.typescriptlang.org/docs/handbook/basic-types.html">TypeScript Handbook</a>
  </li>
  <li>
    <a href="https://exploringjs.com/js/book/ch_callables.html">Chapter “Callable values”</a> in “Exploring JavaScript”
  </li>
</ul>

    
      
</body>
</html>