- en: 30 Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_objects.html](https://exploringjs.com/js/book/ch_objects.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[30.1 Cheat sheet: objects](#cheat-sheet-objects)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.1.1 Cheat sheet: single objects](#cheat-sheet-single-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.1.2 Cheat sheet: prototype chains](#cheat-sheet-prototype-chains)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.2 What is an object?](#what-is-an-object)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.2.1 The two ways of using objects](#ways-of-using-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.3 Fixed-layout objects](#fixed-layout-objects)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.3.1 Object literals: properties](#object-literals)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.3.2 Object literals: property value shorthands](#object-literals-property-value-shorthands)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.3.3 Getting properties](#getting-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.3.4 Setting properties](#setting-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.3.5 Object literals: methods](#object-literals-methods)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.3.6 Object literals: accessors](#object-literal-accessors)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.4 Spreading into object literals (`...`) ^(ES2018)](#spreading-into-object-literals)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.4.1 Use case for spreading: default values for missing properties](#use-case-for-spreading-default-values-for-missing-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.4.2 Use case for spreading: non-destructively changing properties](#use-case-for-spreading-nondestructively-changing-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.4.3 “Destructive spreading”: `Object.assign()` ^(ES6)](#Object.assign)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.5 Copying objects: spreading vs. `Object.assign()` vs. `structuredClone()`](#copying-objects)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.5.1 Copying objects via spreading is *shallow*](#copying-objects-via-spreading-is-shallow)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.5.2 Copying objects deeply via `structuredClone()`](#structuredClone)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.5.3 Which values can `structuredClone()` copy?](#which-values-can-structuredclone-copy)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.5.4 The property attributes of copied objects](#the-property-attributes-of-copied-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.5.5 Alternatives without the limitations of `structuredClone()`?](#alternatives-without-the-limitations-of-structuredclone)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.5.6 Sources of this section](#sources-of-this-section-1)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.6 Methods and the special variable `this`](#methods-and-this)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.6.1 Methods are properties whose values are functions](#methods-are-properties-whose-values-are-functions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.6.2 The special variable `this`](#the-special-variable-this)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.6.3 Methods and `.call()`](#methods-call)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.6.4 Methods and `.bind()`](#methods-bind)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.6.5 `this` pitfall: extracting methods](#extracting-methods)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.6.6 `this` pitfall: accidentally shadowing `this`](#shadowing-this)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.6.7 The value of `this` in various contexts (advanced)](#the-value-of-this-in-various-contexts-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.7 Optional chaining for property getting and method calls ^(ES2020) (advanced)](#optional-chaining)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.7.1 Example: optional fixed property getting](#example-optional-fixed-property-getting)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.7.2 The operators in more detail (advanced)](#the-operators-in-more-detail-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.7.3 Short-circuiting with optional property getting](#shortcircuiting-with-optional-property-getting)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.7.4 Optional chaining: downsides and alternatives](#optional-chaining-downsides-and-alternatives)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.7.5 Frequently asked questions](#frequently-asked-questions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.8 Prototype chains](#prototype-chains)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.8.1 JavaScript’s operations: all properties vs. own properties](#javascripts-operations-all-properties-vs-own-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.8.2 Pitfall: only the first member of a prototype chain is mutated](#pitfall-only-the-first-member-of-a-prototype-chain-is-mutated)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.8.3 Tips for working with prototypes (advanced)](#tips-for-working-with-prototypes-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.8.4 `Object.hasOwn()`: Is a given property own (non-inherited)? ^(ES2022)](#Object.hasOwn)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.8.5 Sharing data via prototypes](#sharing-data-via-prototypes)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9 Dictionary objects (advanced)](#dictionary-objects)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9.1 Quoted keys in object literals](#object-literals-quoted-keys)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9.2 Computed keys in object literals](#object-literals-computed-keys)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9.3 The `in` operator: is there a property with a given key?](#in-operator)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9.4 Deleting properties](#deleting-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9.5 Enumerability](#enumerability)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9.6 Listing property keys via `Object.keys()` etc.](#listing-property-keys)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9.7 Listing property values via `Object.values()`](#Object.values)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9.8 Listing property entries via `Object.entries()` ^(ES2017)](#Object.entries)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9.9 Properties are listed deterministically](#order-of-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9.10 Assembling objects via `Object.fromEntries()` ^(ES2019)](#Object.fromEntries)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9.11 Objects with `null` prototypes make good dictionaries and lookup tables](#null-prototype-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.10 Property attributes and property descriptors ^(ES5) (advanced)](#property-attributes-property-descriptors)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.11 Protecting objects from being changed ^(ES5) (advanced)](#protecting-objects)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.12 Quick reference: `Object`](#quickref-object-api)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.12.1 `Object.*`: creating objects, handling prototypes](#object-creating-objects-handling-prototypes)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.12.2 `Object.*`: property attributes](#object-property-attributes)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.12.3 `Object.*`: property keys, values, entries](#object-property-keys-values-entries)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.12.4 `Object.*`: protecting objects](#object-protecting-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.12.5 `Object.*`: miscellaneous](#object-miscellaneous)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.12.6 `Object.prototype.*`](#objectprototype)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.13 Quick reference: `Reflect`](#quickref-reflect)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.13.1 `Reflect.*` vs. `Object.*`](#reflect-vs-object)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this book, JavaScript’s style of object-oriented programming (OOP) is introduced
    in four steps. This chapter covers step 1 and 2; [the next chapter](ch_classes.html#ch_classes)
    covers step 3 and 4\. The steps are ([figure 30.1](#fig:oop_steps_1_2)):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single objects (this chapter):** How do *objects*, JavaScript’s basic OOP
    building blocks, work in isolation?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Prototype chains (this chapter):** Each object has a chain of zero or more
    *prototype objects*. Prototypes are JavaScript’s core inheritance mechanism.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Classes (next chapter):** JavaScript’s *classes* are factories for objects.
    The relationship between a class and its instances is based on prototypal inheritance
    (step 2).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Subclassing (next chapter):** The relationship between a *subclass* and its
    *superclass* is also based on prototypal inheritance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../Images/98f9d262c296ae1a67f569088f87168c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 30.1: This book introduces object-oriented programming in JavaScript
    in four steps.'
  prefs: []
  type: TYPE_NORMAL
- en: '[30.1 Cheat sheet: objects](#cheat-sheet-objects)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[30.1.1 Cheat sheet: single objects](#cheat-sheet-single-objects)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Creating an object via an *object literal* (starts and ends with a curly brace):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Being able to create objects directly (without classes) is one of the highlights
    of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spreading into objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use spreading to make an unmodified (shallow) copy of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[30.1.2 Cheat sheet: prototype chains](#cheat-sheet-prototype-chains)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Prototypes are JavaScript’s fundamental inheritance mechanism. Even classes
    are based on it. Each object has `null` or an object as its prototype. The latter
    object can also have a prototype, etc. In general, we get *chains* of prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prototypes are managed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Notes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting an object’s prototype while creating the object: line A, line C'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Retrieving the prototype of an object: line B'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each object inherits all the properties of its prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The non-inherited properties of an object are called its *own* properties.
  prefs: []
  type: TYPE_NORMAL
- en: The most important use case for prototypes is that several objects can share
    methods by inheriting them from a common prototype.
  prefs: []
  type: TYPE_NORMAL
- en: '[30.2 What is an object?](#what-is-an-object)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Objects in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: An object is a set of *slots* (key-value entries).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Public slots are called *properties*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A property key can only be a string or a symbol.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Private slots can only be created via classes and are explained in [“Public
    slots (properties) vs. private slots” (§31.2.4)](ch_classes.html#private-slots).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[30.2.1 The two ways of using objects](#ways-of-using-objects)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two ways of using objects in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixed-layout objects: Used this way, objects work like records in databases.
    They have a fixed number of properties, whose keys are known at development time.
    Their values generally have different types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Dictionary objects: Used this way, objects work like lookup tables or maps.
    They have a variable number of properties, whose keys are not known at development
    time. All of their values have the same type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that the two ways can also be mixed: Some objects are both fixed-layout
    objects and dictionary objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ways of using objects influence how they are explained in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[First, we’ll explore fixed-layout objects.](#fixed-layout-objects) Even though
    property keys are strings or symbols under the hood, they will appear as fixed
    identifiers to us.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Later, we’ll explore dictionary objects.](#dictionary-objects) Note that [Maps](ch_maps.html#ch_maps)
    are usually better dictionaries than objects. However, some of the operations
    that we’ll encounter are also useful for fixed-layout objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[30.3 Fixed-layout objects](#fixed-layout-objects)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s first explore *fixed-layout objects*.
  prefs: []
  type: TYPE_NORMAL
- en: '[30.3.1 Object literals: properties](#object-literals)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Object literals* are one way of creating fixed-layout objects. They are a
    stand-out feature of JavaScript: we can directly create objects – no need for
    classes! This is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example, we created an object via an object literal, which starts and
    ends with curly braces `{}`. Inside it, we defined two *properties* (key-value
    entries):'
  prefs: []
  type: TYPE_NORMAL
- en: The first property has the key `first` and the value `'Jane'`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second property has the key `last` and the value `'Doe'`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since ES5, trailing commas are allowed in object literals.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will later see other ways of specifying property keys, but with this way
    of specifying them, they must follow the rules of JavaScript variable names. For
    example, we can use `first_name` as a property key, but not `first-name`). However,
    reserved words are allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to check the effects of various operations on objects, we’ll occasionally
    use `Object.keys()` in this part of the chapter. It lists property keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[30.3.2 Object literals: property value shorthands](#object-literals-property-value-shorthands)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whenever the value of a property is defined via a variable that has the same
    name as the key, we can omit the key.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[30.3.3 Getting properties](#getting-properties)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is how we *get* (read) a property (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting an unknown property produces `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[30.3.4 Setting properties](#setting-properties)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is how we *set* (write to) a property (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We just changed an existing property via setting. If we set an unknown property,
    we create a new entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[30.3.5 Object literals: methods](#object-literals-methods)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following code shows how to create the method `.says()` via an object literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: During the method call `jane.says('hello')`, `jane` is called the *receiver*
    of the method call and assigned to the special variable `this` (more on `this`
    in [“Methods and the special variable `this`” (§30.6)](#methods-and-this)). That
    enables method `.says()` to access the sibling property `.first` in line A.
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Creating an object via an object literal**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/objects/color_point_object_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[30.3.6 Object literals: accessors](#object-literal-accessors)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Accessors* are methods that are invoked by accessing a property. It consists
    of either or both of:'
  prefs: []
  type: TYPE_NORMAL
- en: A *getter* is invoked by getting a property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *setter* is invoked by setting a property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[30.3.6.1 Getters](#getters)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A getter is created by prefixing a method definition with the modifier `get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[30.3.6.2 Setters](#setters)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A setter is created by prefixing a method definition with the modifier `set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[30.3.6.3 Use case for getters: ready-only properties whose values change](#use-case-for-getters-readyonly-properties-whose-values-change)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the following code, the actual value of the counter is private. From the
    outside, it can only be read, via a getter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Implementing a stack via an object**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/objects/stack-via-object_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[30.3.6.4 Use case for getters: switching from a property to more encapsulation](#use-case-for-getters-switching-from-a-property-to-more-encapsulation)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In object-oriented programming, we worry about exposing too much internal state.
    Accessors enable us to change our mind about properties without breaking existing
    code: We can start exposed, with a normal property and later switch to an accessor
    and more encapsulation.'
  prefs: []
  type: TYPE_NORMAL
- en: '[30.4 Spreading into object literals (`...`) ^(ES2018)](#spreading-into-object-literals)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inside an object literal, a *spread property* adds the properties of another
    object to the current one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If property keys clash, the property that is mentioned last “wins”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'All values are spreadable, even `undefined` and `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Property `.length` of strings and Arrays is hidden from this kind of operation
    (it is not *enumerable*; see [“Property attributes and property descriptors ^(ES5)
    (advanced)” (§30.10)](#property-attributes-property-descriptors) for more information).
  prefs: []
  type: TYPE_NORMAL
- en: 'Spreading includes properties whose keys are symbols (which are ignored by
    `Object.keys()`, `Object.values()` and `Object.entries()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[30.4.1 Use case for spreading: default values for missing properties](#use-case-for-spreading-default-values-for-missing-properties)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If one of the inputs of our code is an object with data, we can make properties
    optional by specifying default values that are used if those properties are missing.
    One technique for doing so is via an object whose properties contain the default
    values. In the following example, that object is `DEFAULTS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The result, the object `allData`, is created by copying `DEFAULTS` and overriding
    its properties with those of `providedData`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we don’t need an object to specify the default values; we can also specify
    them inside the object literal, individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[30.4.2 Use case for spreading: non-destructively changing properties](#use-case-for-spreading-nondestructively-changing-properties)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far, we have encountered one way of changing a property `.alpha` of an object:
    We *set* it (line A) and mutate the object. That is, this way of changing a property
    is destructive.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With spreading, we can change `.alpha` non-destructively – we make a copy of
    `obj` where `.alpha` has a different value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Non-destructively updating a property via spreading (fixed key)**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/objects/update_name_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[30.4.3 “Destructive spreading”: `Object.assign()` ^(ES6)](#Object.assign)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Object.assign()` is a tool method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This expression assigns all properties of `source_1` to `target`, then all
    properties of `source_2`, etc. At the end, it returns `target` – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The use cases for `Object.assign()` are similar to those for spread properties.
    In a way, it spreads destructively.
  prefs: []
  type: TYPE_NORMAL
- en: '[30.5 Copying objects: spreading vs. `Object.assign()` vs. `structuredClone()`](#copying-objects)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[30.5.1 Copying objects via spreading is *shallow*](#copying-objects-via-spreading-is-shallow)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One common way of copying Arrays and plain objects in JavaScript is via spreading.
    This code demonstrates the latter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Alas, this way of copying is *shallow*: The properties (key-value entries)
    are copied but not the property values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On one hand, the key-value entry `shallowCopy.id` is a copy, so changing it
    does not change `obj`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the Array in `shallowCopy.values` is shared with `obj`.
    If we change it, we also change `obj`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Copying via `Object.assign()` is similar to copying via spreading and also
    shallow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[30.5.2 Copying objects deeply via `structuredClone()`](#structuredClone)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`structuredClone()` is a function for copying objects. Even though it is not
    part of ECMAScript, it is [well-supported](https://developer.mozilla.org/en-US/docs/Web/API/Window/structuredClone#browser_compatibility)
    on all major JavaScript platforms. It has the following typeSignature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`structuredClone()` copies objects deeply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **`structuredClone()`
    has a second paramater**'
  prefs: []
  type: TYPE_NORMAL
- en: '`structuredClone()` has a second parameter which is beyond the scope of this
    chapter. For more information, see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[“Transferring ArrayBuffers via `structuredClone()`” (§35.7.3)](ch_typed-arrays.html#transferring-arraybuffers-via-structuredclone)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The MDN page for `structuredClone()`](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[30.5.3 Which values can `structuredClone()` copy?](#which-values-can-structuredclone-copy)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It can copy all primitive values except symbols.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can copy all built-in objects except functions and DOM nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instances of user-defined classes become plain objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private fields are not copied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cyclical references are copied correctly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given that the original use case for `structuredClone()` was copying objects
    to other processes, these limitations make sense.
  prefs: []
  type: TYPE_NORMAL
- en: Read on for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '[30.5.3.1 Most primitive values can be copied](#most-primitive-values-can-be-copied)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[30.5.3.2 Most built-in objects can be copied](#most-builtin-objects-can-be-copied)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Arrays and plain objects can be copied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Instances of most built-in classes can be copied – even though they have internal
    slots. They remain instances of their classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[30.5.3.3 Copying symbols and some objects produces exceptions](#copying-symbols-and-some-objects-produces-exceptions)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Symbols and some objects cannot be copied – `structuredClone()` throws a `DOMException`
    if we try to copy them or if we try to copy an object that contains them:'
  prefs: []
  type: TYPE_NORMAL
- en: Symbols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions (ordinary functions, arrow functions, classes, methods)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DOM nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples – cloning symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Examples – cloning functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: What does the exception look like that is thrown by `structuredClone()`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[30.5.3.4 Instances of user-defined classes become plain objects](#instances-of-userdefined-classes-become-plain-objects)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the following example, we copy an instance of the class `C`. The result,
    `copy`, is not an instance of `C`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[30.5.3.5 Private fields are not copied](#private-fields-are-not-copied)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This limitation is related to the previous subsection – private fields are
    not copied by `structuredClone()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[30.5.3.6 Cyclical references are copied correctly](#cyclical-references-are-copied-correctly)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If we copy an object with a reference cycle, the result has the same structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[30.5.4 The property attributes of copied objects](#the-property-attributes-of-copied-objects)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`structuredClone()` doesn’t always faithfully copy the [property attributes](#property-attributes-property-descriptors)
    of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessors are turned into data properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In copies, the property attributes always have default values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read on for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '[30.5.4.1 Accessors become data properties](#accessors-become-data-properties)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Accessors become data properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[30.5.4.2 Copies of properties have default attribute values](#copies-of-properties-have-default-attribute-values)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Data properties of copies always have the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[30.5.5 Alternatives without the limitations of `structuredClone()`?](#alternatives-without-the-limitations-of-structuredclone)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we can’t live with the limitations of `structuredClone()`, such as turning
    instances of classes into plain objects, we can use the Lodash function [`cloneDeep()`](https://lodash.com/docs#cloneDeep)
    – which has fewer limitations.
  prefs: []
  type: TYPE_NORMAL
- en: '[30.5.6 Sources of this section](#sources-of-this-section-1)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Section “Safe passing of structured data”](https://html.spec.whatwg.org/#safe-passing-of-structured-data)
    in the WHATWG HTML standard'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“The structured clone algorithm”](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm)
    on MDN'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“`structuredClone()`”](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone)
    on MDN'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[30.6 Methods and the special variable `this`](#methods-and-this)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[30.6.1 Methods are properties whose values are functions](#methods-are-properties-whose-values-are-functions)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s revisit the example that was used to introduce methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Somewhat surprisingly, methods are functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Why is that? We learned [in the chapter on callable values](ch_callables.html#roles-of-ordinary-functions)
    that ordinary functions play several roles. *Method* is one of those roles. Therefore,
    internally, `jane` roughly looks as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[30.6.2 The special variable `this`](#the-special-variable-this)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In line B, `obj` is the *receiver* of a method call. It is passed to the function
    stored in `obj.someMethod` via an implicit (hidden) parameter whose name is `this`
    (line A).
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **How to understand
    `this`**'
  prefs: []
  type: TYPE_NORMAL
- en: The best way to understand `this` is as an implicit parameter of ordinary functions
    and methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[30.6.3 Methods and `.call()`](#methods-call)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Methods are functions and functions have methods themselves. One of those methods
    is [`.call()`](ch_callables.html#Function.prototype.call). Let’s look at an example
    to understand how this method works.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, there was this method invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This invocation is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Which is also equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`.call()` makes the normally implicit parameter `this` explicit: When invoking
    a function via `.call()`, the first parameter is `this`, followed by the regular
    (explicit) function parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an aside, this means that there are actually two different dot operators:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One for accessing properties: `obj.prop`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another one for calling methods: `obj.prop()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They are different in that (2) is not just (1) followed by the function call
    operator `()`. Instead, (2) additionally provides a value for `this`.
  prefs: []
  type: TYPE_NORMAL
- en: '[30.6.4 Methods and `.bind()`](#methods-bind)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[`.bind()`](ch_callables.html#Function.prototype.bind) is another method of
    function objects. In the following code, we use `.bind()` to turn method `.says()`
    into the stand-alone function `func()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Setting `this` to `jane` via `.bind()` is crucial here. Otherwise, `func()`
    wouldn’t work properly because `this` is used in line A. In the next section,
    we’ll explore why that is.
  prefs: []
  type: TYPE_NORMAL
- en: '[30.6.5 `this` pitfall: extracting methods](#extracting-methods)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We now know quite a bit about functions and methods and are ready to take a
    look at the biggest pitfall involving methods and `this`: function-calling a method
    extracted from an object can fail if we are not careful.'
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we fail when we extract method `jane.says()`, store
    it in the variable `func`, and function-call `func`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In line A, we are making a normal function call. And in normal function calls,
    `this` is `undefined` (if [strict mode](ch_syntax.html#strict-mode) is active,
    which it almost always is). Line A is therefore equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'How do we fix this? We need to use `.bind()` to extract method `.says()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `.bind()` ensures that `this` is always `jane` when we call `func()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use arrow functions to extract methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[30.6.5.1 Example: extracting a method](#example-extracting-a-method)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following is a simplified version of code that we may see in actual web
    development:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In line A, we don’t extract the method `.handleClick()` properly. Instead,
    we should do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Each invocation of `.bind()` creates a new function. That’s why we need to store
    the result somewhere if we want to remove it later on.
  prefs: []
  type: TYPE_NORMAL
- en: '[30.6.5.2 How to avoid the pitfall of extracting methods](#how-to-avoid-the-pitfall-of-extracting-methods)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Alas, there is no simple way around the pitfall of extracting methods: Whenever
    we extract a method, we have to be careful and do it properly – for example, by
    binding `this` or by using an arrow function.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Extracting a method**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/objects/method_extraction_exrc.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[30.6.6 `this` pitfall: accidentally shadowing `this`](#shadowing-this)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Accidentally
    shadowing `this` is only an issue with ordinary functions**'
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions don’t shadow `this`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following problem: when we are inside an ordinary function, we
    can’t access the `this` of the surrounding scope because the ordinary function
    has its own `this`. In other words, a variable in an inner scope hides a variable
    in an outer scope. That is called [*shadowing*](ch_variables-assignment.html#shadowing-variables).
    The following code is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In line A, we want to access the `this` of `.prefixStringArray()`. But we can’t
    since the surrounding ordinary function has its own `this` that *shadows* (and
    blocks access to) the `this` of the method. The value of the former `this` is
    `undefined` due to the callback being function-called. That explains the error
    message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to fix this problem is via an arrow function, which doesn’t
    have its own `this` and therefore doesn’t shadow anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also store `this` in a different variable (line A), so that it doesn’t
    get shadowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option is to specify a fixed `this` for the callback via `.bind()`
    (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, `.map()` lets us specify a value for `this` (line A) that it uses when
    invoking the callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[30.6.6.1 Avoiding the pitfall of accidentally shadowing `this`](#avoiding-the-pitfall-of-accidentally-shadowing-this)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If we follow the advice in [“Recommendation: prefer specialized functions over
    ordinary functions” (§27.3.4)](ch_callables.html#prefer-specialized-functions),
    we can avoid the pitfall of accidentally shadowing `this`. This is a summary:'
  prefs: []
  type: TYPE_NORMAL
- en: Use arrow functions as anonymous inline functions. They don’t have `this` as
    an implicit parameter and don’t shadow it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For named stand-alone function declarations we can either use arrow functions
    or function declarations. If we do the latter, we have to make sure `this` isn’t
    mentioned in their bodies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[30.6.7 The value of `this` in various contexts (advanced)](#the-value-of-this-in-various-contexts-advanced)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What is the value of `this` in various contexts?
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside a callable entity, the value of `this` depends on how the callable entity
    is invoked and what kind of callable entity it is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Function call:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ordinary functions: `this === undefined` (in [strict mode](ch_syntax.html#strict-mode))'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Arrow functions: `this` is same as in surrounding scope (lexical `this`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Method call: `this` is receiver of call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new`: `this` refers to the newly created instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also access `this` in all common top-level scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<script>` element: `this === globalThis`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ECMAScript modules: `this === undefined`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CommonJS modules: `this === module.exports`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Tip: pretend
    that `this` doesn’t exist in top-level scopes**'
  prefs: []
  type: TYPE_NORMAL
- en: I like to do that because top-level `this` is confusing and there are better
    alternatives for its (few) use cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[30.7 Optional chaining for property getting and method calls ^(ES2020) (advanced)](#optional-chaining)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following kinds of optional chaining operations exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The rough idea is:'
  prefs: []
  type: TYPE_NORMAL
- en: If the value before the question mark is neither `undefined` nor `null`, then
    perform the operation after the question mark.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, return `undefined`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of the three syntaxes is covered in more detail later. These are a few
    first examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Mnemonic for
    the optional chaining operator (`?.`)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Are you occasionally unsure if the optional chaining operator starts with a
    dot (`.?`) or a question mark (`?.`)? Then this mnemonic may help you:'
  prefs: []
  type: TYPE_NORMAL
- en: '**If** (`?`) the left-hand side is not nullish'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**then** (`.`) access a property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[30.7.1 Example: optional fixed property getting](#example-optional-fixed-property-getting)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use optional chaining to safely extract street names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[30.7.1.1 Handling defaults via nullish coalescing](#handling-defaults-via-nullish-coalescing)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The [nullish coalescing operator](ch_undefined-null.html#nullish-coalescing-operator)
    allows us to use the default value `''(no name)''` instead of `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[30.7.2 The operators in more detail (advanced)](#the-operators-in-more-detail-advanced)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[30.7.2.1 Optional fixed property getting](#optional-fixed-property-getting)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following two expressions are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[30.7.2.2 Optional dynamic property getting](#optional-dynamic-property-getting)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following two expressions are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[30.7.2.3 Optional function or method call](#optional-function-or-method-call)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following two expressions are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this operator produces an error if its left-hand side is not callable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Why? The idea is that the operator only tolerates deliberate omissions. An uncallable
    value (other than `undefined` and `null`) is probably an error and should be reported,
    rather than worked around.
  prefs: []
  type: TYPE_NORMAL
- en: '[30.7.3 Short-circuiting with optional property getting](#shortcircuiting-with-optional-property-getting)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In a chain of property gettings and method invocations, evaluation stops once
    the first optional operator encounters `undefined` or `null` at its left-hand
    side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider `invokeM(undefined)` in line B: `undefined?.a` is `undefined`. Therefore
    we’d expect `.b` to fail in line A. But it doesn’t: The `?.` operator encounters
    the value `undefined` and the evaluation of the whole expression immediately returns
    `undefined`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This behavior differs from a normal operator where JavaScript always evaluates
    all operands before evaluating the operator. It is called *short-circuiting*.
    Other short-circuiting operators are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(a && b)`: `b` is only evaluated if `a` is truthy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(a || b)`: `b` is only evaluated if `a` is falsy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(c ? t : e)`: If `c` is truthy, `t` is evaluated. Otherwise, `e` is evaluated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[30.7.4 Optional chaining: downsides and alternatives](#optional-chaining-downsides-and-alternatives)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Optional chaining also has downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deeply nested structures are more difficult to manage. For example, refactoring
    is harder if there are many sequences of property names: Each one enforces the
    structure of multiple objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being so forgiving when accessing data hides problems that will surface much
    later and are then harder to debug. For example, a typo early in a sequence of
    optional property names has more negative effects than a normal typo.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An alternative to optional chaining is to extract the information once, in
    a single location:'
  prefs: []
  type: TYPE_NORMAL
- en: We can either write a helper function that extracts the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or we can write a function whose input is deeply nested data and whose output
    is simpler, normalized data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With either approach, it is possible to perform checks and to fail early if
    there are problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further reading:'
  prefs: []
  type: TYPE_NORMAL
- en: “[Overly defensive programming](https://blog.vcarl.com/overly-defensive-programming/)”
    by Carl Vitullo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[30.7.5 Frequently asked questions](#frequently-asked-questions)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[30.7.5.1 Why are there dots in `o?.[x]` and `f?.()`?](#why-are-there-dots-in-ox-and-f)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The syntaxes of the following two optional operator are not ideal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Alas, the less elegant syntax is necessary because distinguishing the ideal
    syntax (first expression) from the conditional operator (second expression) is
    too complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[30.7.5.2 Why does `null?.prop` evaluate to `undefined` and not `null`?](#why-does-nullprop-evaluate-to-undefined-and-not-null)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The operator `?.` is mainly about its right-hand side: Does property `.prop`
    exist? If not, stop early. Therefore, keeping information about its left-hand
    side is rarely useful. However, only having a single “early termination” value
    does simplify things.'
  prefs: []
  type: TYPE_NORMAL
- en: '[30.8 Prototype chains](#prototype-chains)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Prototypes are JavaScript’s only inheritance mechanism: Each object has a prototype
    that is either `null` or an object. In the latter case, the object inherits all
    of the prototype’s properties.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In an object literal, we can set the prototype via the special property `__proto__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Given that a prototype object can have a prototype itself, we get a chain of
    objects – the so-called *prototype chain*. Inheritance gives us the impression
    that we are dealing with single objects, but we are actually dealing with chains
    of objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 30.2](#fig:oo_proto_chain) shows what the prototype chain of `obj`
    looks like.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3f6a70b31e906acd64d926d104282b8f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 30.2: `obj` starts a chain of objects that continues with `proto` and
    other objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Non-inherited properties are called *own properties*. `obj` has one own property,
    `.objProp`.
  prefs: []
  type: TYPE_NORMAL
- en: '[30.8.1 JavaScript’s operations: all properties vs. own properties](#javascripts-operations-all-properties-vs-own-properties)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Some operations consider all properties (own and inherited) – for example,
    getting properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Other operations only consider own properties – for example, `Object.keys()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Read on for another operation that also only considers own properties: setting
    properties.'
  prefs: []
  type: TYPE_NORMAL
- en: '[30.8.2 Pitfall: only the first member of a prototype chain is mutated](#pitfall-only-the-first-member-of-a-prototype-chain-is-mutated)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Given an object `obj` with a chain of prototype objects, it makes sense that
    setting an own property of `obj` only changes `obj`. However, setting an inherited
    property via `obj` also only changes `obj`. It creates a new own property in `obj`
    that overrides the inherited property. Let’s explore how that works with the following
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next code snippet, we set the inherited property `obj.protoProp` (line
    A). That “changes” it by creating an own property: When reading `obj.protoProp`,
    the own property is found first and its value *overrides* the value of the inherited
    property.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The prototype chain of `obj` is depicted in [figure 30.3](#fig:oo_overriding).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a36ba2c417a363309e1b3616c9d7810b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 30.3: The own property `.protoProp` of `obj` overrides the property
    inherited from `proto`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[30.8.3 Tips for working with prototypes (advanced)](#tips-for-working-with-prototypes-advanced)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[30.8.3.1 Getting and setting prototypes](#get-set-prototype)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Recommendations for the property key `__proto__`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t use the accessor `Object.prototype.__proto__` that all instances of `Object`
    have:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can’t be used with all objects – e.g., objects that are not instances of
    `Object` don’t have it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is deprecated in the ECMAScript specification.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on this feature see [“`Object.prototype.__proto__` (accessor)
    ^(ES6)” (§31.9.7)](ch_classes.html#Object.prototype.__proto__).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using the property key `__proto__` in an object literal to specify a prototype
    is different: It’s a feature that is particular to object literals that just happens
    to have the same name as the deprecated accessor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The recommended ways of getting and setting prototypes are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting the prototype of an object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The best time to set the prototype of an object is when we are creating it.
    We can do so via `__proto__` in an object literal or via:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we have to, we can use `Object.setPrototypeOf()` to change the prototype
    of an existing object. But that may affect the performance of that object negatively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how these features are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[30.8.3.2 Checking if an object is in the prototype chain of another object](#check-if-object-in-prototype-chain)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'So far, “`proto` is a prototype of `obj`” always meant “`proto` is a *direct*
    prototype of `obj`”. But it can also be used more loosely and mean that `proto`
    is in the prototype chain of `obj`. That looser relationship can be checked via
    `.isPrototypeOf()`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: For more information on this method see [“`Object.prototype.isPrototypeOf()`
    ^(ES3)” (§31.9.5)](ch_classes.html#Object.prototype.isPrototypeOf).
  prefs: []
  type: TYPE_NORMAL
- en: '[30.8.4 `Object.hasOwn()`: Is a given property own (non-inherited)? ^(ES2022)](#Object.hasOwn)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `in` operator (line A) checks if an object has a given property. In contrast,
    `Object.hasOwn()` (lines B and C) checks if a property is own.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Alternative
    before ES2022: `.hasOwnProperty()`**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before ES2022, we can use another feature: [“`Object.prototype.hasOwnProperty()`
    ^(ES3)” (§31.9.8)](ch_classes.html#Object.prototype.hasOwnProperty). This feature
    has pitfalls, but the referenced section explains how to work around them.'
  prefs: []
  type: TYPE_NORMAL
- en: '[30.8.5 Sharing data via prototypes](#sharing-data-via-prototypes)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: We have two objects that are very similar. Both have two properties whose names
    are `.firstName` and `.describe`. Additionally, method `.describe()` is the same.
    How can we avoid duplicating that method?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can move it to an object `PersonProto` and make that object a prototype
    of both `jane` and `tarzan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The name of the prototype reflects that both `jane` and `tarzan` are persons.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/54ca73b37654dc412734fbf20bbd28dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 30.4: Objects `jane` and `tarzan` share method `.describe()`, via their
    common prototype `PersonProto`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 30.4](#fig:oo_person_shared) illustrates how the three objects are
    connected: The objects at the bottom now contain the properties that are specific
    to `jane` and `tarzan`. The object at the top contains the properties that are
    shared between them.'
  prefs: []
  type: TYPE_NORMAL
- en: When we make the method call `jane.describe()`, `this` points to the receiver
    of that method call, `jane` (in the bottom-left corner of the diagram). That’s
    why the method still works. `tarzan.describe()` works similarly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking ahead to the next chapter on classes – this is how classes are organized
    internally:'
  prefs: []
  type: TYPE_NORMAL
- en: All instances share a common prototype with methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance-specific data is stored in own properties in each instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“The internals of classes” (§31.3)](ch_classes.html#internals-of-classes)
    explains this in more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: '[30.9 Dictionary objects (advanced)](#dictionary-objects)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Objects work best as fixed-layout objects. But before ES6, JavaScript did not
    have a data structure for dictionaries (ES6 brought [Maps](ch_maps.html#ch_maps)).
    Therefore, objects had to be used as dictionaries, which imposed a signficant
    constraint: Dictionary keys had to be strings (symbols were also introduced with
    ES6).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first look at features of objects that are related to dictionaries but also
    useful for fixed-layout objects. This section concludes with tips for actually
    using objects as dictionaries. (Spoiler: If possible, it’s better to use Maps.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[30.9.1 Quoted keys in object literals](#object-literals-quoted-keys)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far, we have always used fixed-layout objects. Property keys were fixed
    tokens that had to be valid identifiers and internally became strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'As a next step, we’ll go beyond this limitation for property keys: In this
    subsection, we’ll use arbitrary fixed strings as keys. In the next subsection,
    we’ll dynamically compute keys.'
  prefs: []
  type: TYPE_NORMAL
- en: Two syntaxes enable us to use arbitrary strings as property keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, when creating property keys via object literals, we can quote property
    keys (with single or double quotes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, when getting or setting properties, we can use square brackets with
    strings inside them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use these syntaxes for methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[30.9.2 Computed keys in object literals](#object-literals-computed-keys)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the previous subsection, property keys were specified via fixed strings inside
    object literals. In this section we learn how to dynamically compute property
    keys. That enables us to use either arbitrary strings or symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of dynamically computed property keys in object literals is inspired
    by dynamically accessing properties. That is, we can use square brackets to wrap
    expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The main use case for computed keys is having symbols as property keys (line
    A).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the square brackets operator for getting and setting properties works
    with arbitrary expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Methods can have computed property keys, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: For the remainder of this chapter, we’ll mostly use fixed property keys again
    (because they are syntactically more convenient). But all features are also available
    for arbitrary strings and symbols.
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Non-destructively updating a property via spreading (computed key)**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/objects/update_property_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[30.9.3 The `in` operator: is there a property with a given key?](#in-operator)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `in` operator checks if an object has a property with a given key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[30.9.3.1 Checking if a property exists via truthiness](#checking-if-a-property-exists-via-truthiness)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can also use a truthiness check to determine if a property exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The previous checks work because `obj.alpha` is truthy and because reading a
    missing property returns `undefined` (which is falsy).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, one important caveat: truthiness checks fail if the property
    exists, but has a falsy value (`undefined`, `null`, `false`, `0`, `""`, etc.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[30.9.4 Deleting properties](#deleting-properties)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can delete properties via the `delete` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[30.9.5 Enumerability](#enumerability)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Enumerability* is an [*attribute*](#property-attributes-property-descriptors)
    of a property. Non-enumerable properties are ignored by some operations – for
    example, by `Object.keys()` and when spreading properties. By default, most properties
    are enumerable. The next example shows how to change that and how it affects spreading.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '`Object.defineProperties()` is explained [later in this chapter](#property-attributes-property-descriptors).
    The next subsection shows how these operations are affected by enumerability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[30.9.6 Listing property keys via `Object.keys()` etc.](#listing-property-keys)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '|  | enumerable | non-e. | string | symbol |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.keys()` | ✔ |  | ✔ |  |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.getOwnPropertyNames()` | ✔ | ✔ | ✔ |  |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.getOwnPropertySymbols()` | ✔ | ✔ |  | ✔ |'
  prefs: []
  type: TYPE_TB
- en: '| `Reflect.ownKeys()` | ✔ | ✔ | ✔ | ✔ |'
  prefs: []
  type: TYPE_TB
- en: 'Table 30.1: Standard library methods for listing *own* (non-inherited) property
    keys. All of them return Arrays with strings and/or symbols.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the methods in [table 30.1](#tbl:listing-property-keys) returns an
    Array with the own property keys of the parameter. In the names of the methods,
    we can see that the following distinction is made:'
  prefs: []
  type: TYPE_NORMAL
- en: A *property key* can be either a string or a symbol. (`Object.keys()` is older
    and does not yet follow this convention.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *property name* is a property key whose value is a string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *property symbol* is a property key whose value is a symbol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To demonstrate the four operations, we revisit the example from the previous
    subsection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[30.9.7 Listing property values via `Object.values()`](#Object.values)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Object.values()` lists the values of all own enumerable string-keyed properties
    of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[30.9.8 Listing property entries via `Object.entries()` ^(ES2017)](#Object.entries)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Object.entries(obj)` returns an Array with one key-value pair for each of
    its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Each pair is encoded as a two-element Array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only own enumerable properties with string keys are included.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[30.9.8.1 A simple implementation of `Object.entries()`](#a-simple-implementation-of-objectentries)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following function is a simplified version of `Object.entries()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    `Object.entries()`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/objects/find_key_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[30.9.9 Properties are listed deterministically](#order-of-properties)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Own (non-inherited) properties of objects are always listed in the following
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties with string keys that contain integer indices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In ascending numeric order
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Remaining properties with string keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the order in which they were added
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Properties with symbol keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the order in which they were added
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following example demonstrates that property keys are sorted according
    to these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **The order
    of properties**'
  prefs: []
  type: TYPE_NORMAL
- en: '[The ECMAScript specification](https://tc39.es/ecma262/#sec-ordinaryownpropertykeys)
    describes in more detail how properties are ordered.'
  prefs: []
  type: TYPE_NORMAL
- en: '[30.9.9.1 Why is the order of properties deterministic?](#why-is-the-order-of-properties-deterministic)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As a data structure, objects are mainly unordered. Therefore, we wouldn’t expect,
    e.g., `Object.keys()` to always return property keys in the same order. However,
    JavaScript does define a deterministic order for properties because that helps
    with testing and other use cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[30.9.10 Assembling objects via `Object.fromEntries()` ^(ES2019)](#Object.fromEntries)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Given an iterable over [key, value] pairs, `Object.fromEntries()` creates an
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '`Object.fromEntries()` does the opposite of [`Object.entries()`](#Object.entries).
    However, while `Object.entries()` ignores symbol-keyed properties, `Object.fromEntries()`
    doesn’t (see previous example).'
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate both, we’ll use them to implement two tool functions from the
    library [Underscore](https://underscorejs.org) in the next subsubsections.
  prefs: []
  type: TYPE_NORMAL
- en: '[30.9.10.1 Example: `pick()`](#underscore-pick)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[The Underscore function `pick()`](https://underscorejs.org/#pick) has the
    following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns a copy of `object` that has only those properties whose keys are
    mentioned in the trailing arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'We can implement `pick()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[30.9.10.2 Example: `invert()`](#underscore-invert)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[The Underscore function `invert()`](https://underscorejs.org/#invert) has
    the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns a copy of `object` where the keys and values of all properties are
    swapped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'We can implement `invert()` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[30.9.10.3 A simple implementation of `Object.fromEntries()`](#a-simple-implementation-of-objectfromentries)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following function is a simplified version of `Object.fromEntries()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Using `Object.entries()` and `Object.fromEntries()`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/objects/omit_properties_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[30.9.11 Objects with `null` prototypes make good dictionaries and lookup tables](#null-prototype-objects)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we use plain objects (created via object literals) as dictionaries, we have
    to look out for two pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: '[30.9.11.1 Pitfall 1: getting inherited properties](#pitfall-1-getting-inherited-properties)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following dictionary object should be empty. However, we get a value (and
    not `undefined`) if we read an inherited property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '`dict` is an instance of `Object` and inherits `.toString()` from `Object.prototype`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[30.9.11.2 Pitfall 2: checking if a property exists](#pitfall-2-checking-if-a-property-exists)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If we use the `in` operator to check if a property exists, we again detect
    inherited properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'As an aside: `Object.hasOwn()` does not have this pitfall. As its name indicates,
    it only considers *own* (non-inherited) properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[30.9.11.3 Pitfall 3: property key `''__proto__''`](#pitfall-3-property-key-proto)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can’t use the property key `''__proto__''` because it has special powers
    (it sets the prototype of the object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[30.9.11.4 Objects with `null` prototypes as dictionaries](#dictionary-objects-with-null-prototypes)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Maps are usually the best choice when it comes to dictionaries: They have a
    convenient method-based API and support keys beyond strings and symbols.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, objects with `null` prototypes are also decent dictionaries and don’t
    have the pitfalls we just encountered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'We avoided the pitfalls:'
  prefs: []
  type: TYPE_NORMAL
- en: An object without a prototype does not inherit anything. Therefore, it is always
    safe to get properties and to use the `in` operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The accessor `Object.prototype.__proto__` is switched off because `Object.prototype`
    is not in the prototype chain of `dict`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercises:
    Objects as dictionaries**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `null` prototype object as a dictionary: `exercises/objects/null-proto-obj-dict_test.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A plain object as a dictionary: `exercises/objects/plain-obj-dict_test.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[30.9.11.5 Objects with `null` prototypes as fixed lookup tables](#lookup-tables-with-null-prototypes)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Null prototypes are also useful for objects that we use as fixed lookup tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[30.9.11.6 `null` prototypes in the standard library](#null-prototypes-in-standard-library)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Because they are good dictionaries, the standard library also uses objects
    with `null` prototype in some locations – e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of `import.meta`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result of `Object.groupBy()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When matching regular expressions – the value of `matchObj.groups`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[30.10 Property attributes and property descriptors ^(ES5) (advanced)](#property-attributes-property-descriptors)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just as objects are composed of properties, properties are composed of *attributes*.
    There are two kinds of properties and they are characterized by their attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: A *data property* stores data. Its attribute `value` holds any JavaScript value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods are data properties whose values are functions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An *accessor property* consists of a getter function and/or a setter function.
    The former is stored in the attribute `get`, the latter in the attribute `set`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, there are attributes that both kinds of properties have. The following
    table lists all attributes and their default values.
  prefs: []
  type: TYPE_NORMAL
- en: '| Kind of property | Name and type of attribute | Default value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| All properties | `configurable: boolean` | `false` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `enumerable: boolean` | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| Data property | `value: any` | `undefined` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `writable: boolean` | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| Accessor property | `get: (this: any) => any` | `undefined` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `set: (this: any, v: any) => void` | `undefined` |'
  prefs: []
  type: TYPE_TB
- en: 'We have already encountered the attributes `value`, `get`, and `set`. The other
    attributes work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`writable` determines if the value of a data property can be changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`configurable` determines if the attributes of a property can be changed. If
    it is `false`, then:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot delete the property.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot change a property from a data property to an accessor property or
    vice versa.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot change any attribute other than `value`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, one more attribute change is allowed: We can change `writable` from
    `true` to `false`. The rationale behind this anomaly is [historical](https://stackoverflow.com/questions/9829817/why-can-i-set-enumerability-and-writability-of-unconfigurable-property-descrip/9843191#9843191):
    Property `.length` of Arrays has always been writable and non-configurable. Allowing
    its `writable` attribute to be changed enables us to freeze Arrays.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enumerable` influences some operations (such as `Object.keys()`). If it is
    `false`, then those operations ignore the property. Enumerability is covered in
    greater detail [earlier in this chapter](#enumerability).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we are using one of the operations for handling property attributes, attributes
    are specified via *property descriptors*: objects where each property represents
    one attribute. For example, this is how we read the attributes of a property `obj.myProp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is how we change the attributes of `obj.myProp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, let’s see what methods and getters look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “external”](../Images/38e6ff55e8d602659f3cdb8893e63f62.png) **Further
    reading**'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on property attributes and property descriptors, see [*Deep
    JavaScript*](https://exploringjs.com/deep-js/ch_property-attributes-intro.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[30.11 Protecting objects from being changed ^(ES5) (advanced)](#protecting-objects)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript has three levels of protecting objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Preventing extensions* makes it impossible to add new properties to an object
    and to change its prototype. We can still delete and change properties, though.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apply: `Object.preventExtensions(obj)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check: `Object.isExtensible(obj)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Sealing* prevents extensions and makes all properties *unconfigurable* (roughly:
    we can’t change how a property works anymore).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apply: `Object.seal(obj)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check: `Object.isSealed(obj)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Freezing* seals an object after making all of its properties non-writable.
    That is, the object is not extensible, all properties are read-only and there
    is no way to change that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apply: `Object.freeze(obj)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check: `Object.isFrozen(obj)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Icon “warning”](../Images/5aa4bf88dc66ecb2bac6be4022a1fed4.png) **Caveat:
    Objects are only protected shallowly**'
  prefs: []
  type: TYPE_NORMAL
- en: All three of the aforementioned `Object.*` methods only affect the top level
    of an object, not objects nested inside it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what using `Object.freeze()` looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Changing frozen properties only causes an exception in [strict mode](ch_syntax.html#strict-mode).
    In sloppy mode, it fails silently.
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “external”](../Images/38e6ff55e8d602659f3cdb8893e63f62.png) **Further
    reading**'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on freezing and other ways of locking down objects, see
    [*Deep JavaScript*](https://exploringjs.com/deep-js/ch_protecting-objects.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[30.12 Quick reference: `Object`](#quickref-object-api)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[30.12.1 `Object.*`: creating objects, handling prototypes](#object-creating-objects-handling-prototypes)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Object.create(proto, propDescObj?)` ES5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a new object whose prototype is `proto`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The optional `propDescObj` is an object with [property descriptors](#property-attributes-property-descriptors)
    that is used to define properties in the new object.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following example, we define own properties via the second parameter:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Object.getPrototypeOf(obj)` ES5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the prototype of `obj` – which is either an object or `null`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Object.setPrototypeOf(obj, proto)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the prototype of `obj` to `proto` (which must be `null` or an object) and
    returns the former.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[30.12.2 `Object.*`: property attributes](#object-property-attributes)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Object.defineProperty(obj, propKey, propDesc)` ES5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines one property in `obj`, as specified by the property key `propKey` and
    the [property descriptor](#property-attributes-property-descriptors) `propDesc`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `obj`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Object.defineProperties(obj, propDescObj)` ES5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines properties in `obj`, as specified by the object `propDescObj` with [property
    descriptors](#property-attributes-property-descriptors).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `obj`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Object.getOwnPropertyDescriptor(obj, propKey)` ES5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a property descriptor for the own property of `obj` whose key is `propKey`.
    If no such property exists, it returns `undefined`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information on property descriptors: [“Property attributes and property
    descriptors ^(ES5) (advanced)” (§30.10)](#property-attributes-property-descriptors)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Object.getOwnPropertyDescriptors(obj)` ES2017'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns an object with property descriptors, one for each own property of `obj`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information on property descriptors: [“Property attributes and property
    descriptors ^(ES5) (advanced)” (§30.10)](#property-attributes-property-descriptors)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[30.12.3 `Object.*`: property keys, values, entries](#object-property-keys-values-entries)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Object.keys(obj)` ES5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns an Array with all own enumerable property keys that are strings.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Object.getOwnPropertyNames(obj)` ES5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns an Array with all own property keys that are strings (enumerable and
    non-enumerable ones).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Object.getOwnPropertySymbols(obj)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns an Array with all own property keys that are symbols (enumerable and
    non-enumerable ones).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Object.values(obj)` ES2017'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns an Array with the values of all enumerable own string-keyed properties.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Object.entries(obj)` ES2017'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns an Array with one key-value pair (encoded as a two-element Array) per
    property of `obj`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Only own enumerable properties with string keys are included.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inverse operation: [`Object.fromEntries()`](#qref-Object.fromEntries)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Object.fromEntries(keyValueIterable)` ES2019'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates an object whose own properties are specified by `keyValueIterable`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inverse operation: [`Object.entries()`](#qref-Object.entries)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Object.hasOwn(obj, key)` ES2022'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if `obj` has an own property whose key is `key`. If not, it returns
    `false`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[30.12.4 `Object.*`: protecting objects](#object-protecting-objects)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'More information: [“Protecting objects from being changed ^(ES5) (advanced)”
    (§30.11)](#protecting-objects)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.preventExtensions(obj)` ES5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Makes `obj` non-extensible and returns it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Effect:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`obj` is non-extensible: We can’t add properties or change its prototype.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Only the top level of `obj` is changed (shallow change). Nested objects are
    not affected.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Related: [`Object.isExtensible()`](#qref-Object.isExtensible)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.isExtensible(obj)` ES5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if `obj` is extensible and `false` if it isn’t.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Related: [`Object.preventExtensions()`](#qref-Object.preventExtensions)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.seal(obj)` ES5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seals `obj` and returns it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Effect:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`obj` is non-extensible: We can’t add properties or change its prototype.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`obj` is sealed: Additionally, all of its properties are unconfigurable.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Only the top level of `obj` is changed (shallow change). Nested objects are
    not affected.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Related: [`Object.isSealed()`](#qref-Object.isSealed)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.isSealed(obj)` ES5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if `obj` is sealed and `false` if it isn’t.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Related: [`Object.seal()`](#qref-Object.seal)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.freeze(obj)` ES5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Freezes `obj` and returns it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Effect:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`obj` is non-extensible: We can’t add properties or change its prototype.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`obj` is sealed: Additionally, all of its properties are unconfigurable.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`obj` is frozen: Additionally, all of its properties are non-writable.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Only the top level of `obj` is changed (shallow change). Nested objects are
    not affected.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Related: [`Object.isFrozen()`](#qref-Object.isFrozen)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Object.isFrozen(obj)` ES5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if `obj` is frozen.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Related: [`Object.freeze()`](#qref-Object.freeze)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[30.12.5 `Object.*`: miscellaneous](#object-miscellaneous)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Object.assign(target, ...sources)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigns all enumerable own string-keyed properties of each of the `sources`
    to `target` and returns `target`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Object.groupBy(items, computeGroupKey)` ES2024'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The callback `computeGroupKey` returns a *group key* for each of the `items`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The result of `Object.groupBy()` is an object where:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The key of each property is a group key and
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: its value is an Array with all items that have that group key.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Object.is(value1, value2)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Is mostly equivalent to `value1 === value2` – with two exceptions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Considering all `NaN` values to be equal can be useful – e.g., when searching
    for a value in an Array.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The value `-0` is rare and it’s usually best to pretend it is the same as `0`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[30.12.6 `Object.prototype.*`](#objectprototype)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Object.prototype` has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.prototype.__proto__` (getter and setter)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.prototype.hasOwnProperty()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.prototype.isPrototypeOf()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.prototype.propertyIsEnumerable()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.prototype.toLocaleString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.prototype.toString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.prototype.valueOf()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These methods are explained in detail in [“Quick reference: `Object.prototype.*`”
    (§31.10)](ch_classes.html#quickref-object-prototype).'
  prefs: []
  type: TYPE_NORMAL
- en: '[30.13 Quick reference: `Reflect`](#quickref-reflect)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Reflect` provides functionality for [JavaScript proxies](https://exploringjs.com/deep-js/ch_proxies.html)
    that is also occasionally useful elsewhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Reflect.apply(target, thisArgument, argumentsList)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invokes `target` with the arguments provided by `argumentsList` and `this` set
    to `thisArgument`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Equivalent to `target.apply(thisArgument, argumentsList)`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reflect.construct(target, argumentsList, newTarget=target)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `new` operator as a function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`target` is the constructor to invoke.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The optional parameter `newTarget` points to the constructor that started the
    current chain of constructor calls.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reflect.defineProperty(target, propertyKey, propDesc)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to `Object.defineProperty()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a boolean indicating whether or not the operation succeeded.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reflect.deleteProperty(target, propertyKey)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `delete` operator as a function. It works slightly differently, though:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It returns `true` if it successfully deleted the property or if the property
    never existed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It returns `false` if the property could not be deleted and still exists.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In sloppy mode, the `delete` operator returns the same results as this method.
    But in strict mode, it throws a `TypeError` instead of returning `false`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The only way to protect properties from deletion is by making them non-configurable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Reflect.get(target, propertyKey, receiver=target)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that gets properties. The optional parameter `receiver` is needed
    if `get` reaches a getter (somewhere in the prototype chain). Then it provides
    the value for `this`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Reflect.getOwnPropertyDescriptor(target, propertyKey)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Same as `Object.getOwnPropertyDescriptor()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Reflect.getPrototypeOf(target)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Same as `Object.getPrototypeOf()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Reflect.has(target, propertyKey)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `in` operator as a function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Reflect.isExtensible(target)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Same as `Object.isExtensible()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Reflect.ownKeys(target)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns all own property keys (strings and symbols) in an Array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Reflect.preventExtensions(target)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to `Object.preventExtensions()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a boolean indicating whether or not the operation succeeded.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reflect.set(target, propertyKey, value, receiver=target)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets properties.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a boolean indicating whether or not the operation succeeded.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reflect.setPrototypeOf(target, proto)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Same as `Object.setPrototypeOf()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a boolean indicating whether or not the operation succeeded.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[30.13.1 `Reflect.*` vs. `Object.*`](#reflect-vs-object)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'General recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `Object.*` whenever you can.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `Reflect.*` when working with [ECMAScript proxies](https://exploringjs.com/deep-js/ch_proxies.html).
    Its methods are well adapted to ECMAScript’s meta-object protocol (MOP) which
    also return boolean error flags instead of exceptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are use cases for `Reflect` beyond proxies?
  prefs: []
  type: TYPE_NORMAL
- en: '`Reflect.ownKeys()` lists all own property keys – functionality that isn’t
    provided anywhere else.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Same functionality as `Object` but different return values: `Reflect` duplicates
    the following methods of `Object`, but its methods return booleans indicating
    whether the operation succeeded (where the `Object` methods return the object
    that was modified).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.defineProperty(obj, propKey, propDesc)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.preventExtensions(obj)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.setPrototypeOf(obj, proto)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Operators as functions: The following `Reflect` methods implement functionality
    that is otherwise only available via operators:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reflect.construct(target, argumentsList, newTarget=target)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reflect.deleteProperty(target, propertyKey)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reflect.get(target, propertyKey, receiver=target)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reflect.has(target, propertyKey)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reflect.set(target, propertyKey, value, receiver=target)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Shorter version of `apply()`: If we want to be completely safe about invoking
    the method `apply()` on a function, we can’t do so via dynamic dispatch, because
    the function may have an own property with the key `''apply''`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using `Reflect.apply()` is shorter:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'No exceptions when deleting properties: the `delete` operator throws in strict
    mode if we try to delete a non-configurable own property. `Reflect.deleteProperty()`
    returns `false` in that case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
