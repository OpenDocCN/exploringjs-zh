- en: 30 Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 30 对象
- en: 原文：[https://exploringjs.com/js/book/ch_objects.html](https://exploringjs.com/js/book/ch_objects.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/js/book/ch_objects.html](https://exploringjs.com/js/book/ch_objects.html)
- en: '[30.1 Cheat sheet: objects](#cheat-sheet-objects)'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.1 速查表：对象](#cheat-sheet-objects)'
- en: '[30.1.1 Cheat sheet: single objects](#cheat-sheet-single-objects)'
  id: totrans-3
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.1.1 速查表：单个对象](#cheat-sheet-single-objects)'
- en: '[30.1.2 Cheat sheet: prototype chains](#cheat-sheet-prototype-chains)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.1.2 速查表：原型链](#cheat-sheet-prototype-chains)'
- en: '[30.2 What is an object?](#what-is-an-object)'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.2 什么是对象？](#what-is-an-object)'
- en: '[30.2.1 The two ways of using objects](#ways-of-using-objects)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.2.1 使用对象的方式](#ways-of-using-objects)'
- en: '[30.3 Fixed-layout objects](#fixed-layout-objects)'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.3 固定布局对象](#fixed-layout-objects)'
- en: '[30.3.1 Object literals: properties](#object-literals)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.3.1 对象字面量：属性](#object-literals)'
- en: '[30.3.2 Object literals: property value shorthands](#object-literals-property-value-shorthands)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.3.2 对象字面量：属性值简写](#object-literals-property-value-shorthands)'
- en: '[30.3.3 Getting properties](#getting-properties)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.3.3 获取属性](#getting-properties)'
- en: '[30.3.4 Setting properties](#setting-properties)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.3.4 设置属性](#setting-properties)'
- en: '[30.3.5 Object literals: methods](#object-literals-methods)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.3.5 对象字面量：方法](#object-literals-methods)'
- en: '[30.3.6 Object literals: accessors](#object-literal-accessors)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.3.6 对象字面量：访问器](#object-literal-accessors)'
- en: '[30.4 Spreading into object literals (`...`) ^(ES2018)](#spreading-into-object-literals)'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.4 对象字面量中的展开（`...`）（ES2018）](#spreading-into-object-literals)'
- en: '[30.4.1 Use case for spreading: default values for missing properties](#use-case-for-spreading-default-values-for-missing-properties)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.4.1 展开的使用场景：缺失属性的默认值](#use-case-for-spreading-default-values-for-missing-properties)'
- en: '[30.4.2 Use case for spreading: non-destructively changing properties](#use-case-for-spreading-nondestructively-changing-properties)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.4.2 展开的使用场景：非破坏性更改属性](#use-case-for-spreading-nondestructively-changing-properties)'
- en: '[30.4.3 “Destructive spreading”: `Object.assign()` ^(ES6)](#Object.assign)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.4.3 “破坏性展开”：`Object.assign()`（ES6）](#Object.assign)'
- en: '[30.5 Copying objects: spreading vs. `Object.assign()` vs. `structuredClone()`](#copying-objects)'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.5 复制对象：展开与`Object.assign()`与`structuredClone()`的比较](#copying-objects)'
- en: '[30.5.1 Copying objects via spreading is *shallow*](#copying-objects-via-spreading-is-shallow)'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.5.1 通过展开复制对象是*浅拷贝*](#copying-objects-via-spreading-is-shallow)'
- en: '[30.5.2 Copying objects deeply via `structuredClone()`](#structuredClone)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.5.2 通过`structuredClone()`深度复制对象](#structuredClone)'
- en: '[30.5.3 Which values can `structuredClone()` copy?](#which-values-can-structuredclone-copy)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.5.3 `structuredClone()`可以复制哪些值？](#which-values-can-structuredclone-copy)'
- en: '[30.5.4 The property attributes of copied objects](#the-property-attributes-of-copied-objects)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.5.4 复制的对象属性](#the-property-attributes-of-copied-objects)'
- en: '[30.5.5 Alternatives without the limitations of `structuredClone()`?](#alternatives-without-the-limitations-of-structuredclone)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.5.5 没有`structuredClone()`限制的替代方案？](#alternatives-without-the-limitations-of-structuredclone)'
- en: '[30.5.6 Sources of this section](#sources-of-this-section-1)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.5.6 本节来源](#sources-of-this-section-1)'
- en: '[30.6 Methods and the special variable `this`](#methods-and-this)'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.6 方法和特殊变量`this`](#methods-and-this)'
- en: '[30.6.1 Methods are properties whose values are functions](#methods-are-properties-whose-values-are-functions)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.6.1 方法是其值为函数的属性](#methods-are-properties-whose-values-are-functions)'
- en: '[30.6.2 The special variable `this`](#the-special-variable-this)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.6.2 特殊变量`this`](#the-special-variable-this)'
- en: '[30.6.3 Methods and `.call()`](#methods-call)'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.6.3 方法和`.call()`](#methods-call)'
- en: '[30.6.4 Methods and `.bind()`](#methods-bind)'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.6.4 方法和`.bind()`](#methods-bind)'
- en: '[30.6.5 `this` pitfall: extracting methods](#extracting-methods)'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.6.5 `this`陷阱：提取方法](#extracting-methods)'
- en: '[30.6.6 `this` pitfall: accidentally shadowing `this`](#shadowing-this)'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.6.6 `this`陷阱：意外遮蔽`this`](#shadowing-this)'
- en: '[30.6.7 The value of `this` in various contexts (advanced)](#the-value-of-this-in-various-contexts-advanced)'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.6.7 不同上下文中`this`的值（高级）](#the-value-of-this-in-various-contexts-advanced)'
- en: '[30.7 Optional chaining for property getting and method calls ^(ES2020) (advanced)](#optional-chaining)'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.7 属性获取和方法调用中的可选链（ES2020）（高级）](#optional-chaining)'
- en: '[30.7.1 Example: optional fixed property getting](#example-optional-fixed-property-getting)'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.7.1 示例：可选固定属性获取](#example-optional-fixed-property-getting)'
- en: '[30.7.2 The operators in more detail (advanced)](#the-operators-in-more-detail-advanced)'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.7.2 运算符的详细说明（高级）](#the-operators-in-more-detail-advanced)'
- en: '[30.7.3 Short-circuiting with optional property getting](#shortcircuiting-with-optional-property-getting)'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.7.3 使用可选属性获取进行短路](#shortcircuiting-with-optional-property-getting)'
- en: '[30.7.4 Optional chaining: downsides and alternatives](#optional-chaining-downsides-and-alternatives)'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.7.4 可选链的缺点和替代方案](#optional-chaining-downsides-and-alternatives)'
- en: '[30.7.5 Frequently asked questions](#frequently-asked-questions)'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.7.5 常见问题](#frequently-asked-questions)'
- en: '[30.8 Prototype chains](#prototype-chains)'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.8 原型链](#prototype-chains)'
- en: '[30.8.1 JavaScript’s operations: all properties vs. own properties](#javascripts-operations-all-properties-vs-own-properties)'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.8.1 JavaScript 的操作：所有属性与自有属性](#javascripts-operations-all-properties-vs-own-properties)'
- en: '[30.8.2 Pitfall: only the first member of a prototype chain is mutated](#pitfall-only-the-first-member-of-a-prototype-chain-is-mutated)'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.8.2 陷阱：只有原型链的第一个成员会被修改](#pitfall-only-the-first-member-of-a-prototype-chain-is-mutated)'
- en: '[30.8.3 Tips for working with prototypes (advanced)](#tips-for-working-with-prototypes-advanced)'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.8.3 使用原型的技巧（高级）](#tips-for-working-with-prototypes-advanced)'
- en: '[30.8.4 `Object.hasOwn()`: Is a given property own (non-inherited)? ^(ES2022)](#Object.hasOwn)'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.8.4 `Object.hasOwn()`: 给定属性是否为自有（非继承的）？](#Object.hasOwn)'
- en: '[30.8.5 Sharing data via prototypes](#sharing-data-via-prototypes)'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.8.5 通过原型共享数据](#sharing-data-via-prototypes)'
- en: '[30.9 Dictionary objects (advanced)](#dictionary-objects)'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.9 字典对象（高级）](#dictionary-objects)'
- en: '[30.9.1 Quoted keys in object literals](#object-literals-quoted-keys)'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.9.1 对象字面量中的引号键](#object-literals-quoted-keys)'
- en: '[30.9.2 Computed keys in object literals](#object-literals-computed-keys)'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.9.2 对象字面量中的计算键](#object-literals-computed-keys)'
- en: '[30.9.3 The `in` operator: is there a property with a given key?](#in-operator)'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.9.3 `in` 操作符：是否存在具有给定键的属性？](#in-operator)'
- en: '[30.9.4 Deleting properties](#deleting-properties)'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.9.4 删除属性](#deleting-properties)'
- en: '[30.9.5 Enumerability](#enumerability)'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.9.5 可枚举性](#enumerability)'
- en: '[30.9.6 Listing property keys via `Object.keys()` etc.](#listing-property-keys)'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.9.6 通过 `Object.keys()` 等列出属性键](#listing-property-keys)'
- en: '[30.9.7 Listing property values via `Object.values()`](#Object.values)'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.9.7 通过 `Object.values()` 列出属性值](#Object.values)'
- en: '[30.9.8 Listing property entries via `Object.entries()` ^(ES2017)](#Object.entries)'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.9.8 通过 `Object.entries()` 列出属性条目（ES2017）](#Object.entries)'
- en: '[30.9.9 Properties are listed deterministically](#order-of-properties)'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.9.9 属性按确定性列出](#order-of-properties)'
- en: '[30.9.10 Assembling objects via `Object.fromEntries()` ^(ES2019)](#Object.fromEntries)'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.9.10 通过 `Object.fromEntries()` 组装对象（ES2019）](#Object.fromEntries)'
- en: '[30.9.11 Objects with `null` prototypes make good dictionaries and lookup tables](#null-prototype-objects)'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.9.11 具有 `null` 原型的对象是好的字典和查找表](#null-prototype-objects)'
- en: '[30.10 Property attributes and property descriptors ^(ES5) (advanced)](#property-attributes-property-descriptors)'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.10 属性属性和属性描述符（ES5）（高级）](#property-attributes-property-descriptors)'
- en: '[30.11 Protecting objects from being changed ^(ES5) (advanced)](#protecting-objects)'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.11 保护对象不被更改（ES5）（高级）](#protecting-objects)'
- en: '[30.12 Quick reference: `Object`](#quickref-object-api)'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.12 快速参考：`Object`](#quickref-object-api)'
- en: '[30.12.1 `Object.*`: creating objects, handling prototypes](#object-creating-objects-handling-prototypes)'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.12.1 `Object.*`：创建对象，处理原型](#object-creating-objects-handling-prototypes)'
- en: '[30.12.2 `Object.*`: property attributes](#object-property-attributes)'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.12.2 `Object.*`：属性属性](#object-property-attributes)'
- en: '[30.12.3 `Object.*`: property keys, values, entries](#object-property-keys-values-entries)'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.12.3 `Object.*`：属性键、值、条目](#object-property-keys-values-entries)'
- en: '[30.12.4 `Object.*`: protecting objects](#object-protecting-objects)'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.12.4 `Object.*`：保护对象](#object-protecting-objects)'
- en: '[30.12.5 `Object.*`: miscellaneous](#object-miscellaneous)'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.12.5 `Object.*`：杂项](#object-miscellaneous)'
- en: '[30.12.6 `Object.prototype.*`](#objectprototype)'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.12.6 `Object.prototype.*`](#objectprototype)'
- en: '[30.13 Quick reference: `Reflect`](#quickref-reflect)'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.13 快速参考：`Reflect`](#quickref-reflect)'
- en: '[30.13.1 `Reflect.*` vs. `Object.*`](#reflect-vs-object)'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[30.13.1 `Reflect.*` 与 `Object.*`](#reflect-vs-object)'
- en: 'In this book, JavaScript’s style of object-oriented programming (OOP) is introduced
    in four steps. This chapter covers step 1 and 2; [the next chapter](ch_classes.html#ch_classes)
    covers step 3 and 4\. The steps are ([figure 30.1](#fig:oop_steps_1_2)):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，JavaScript 的面向对象编程（OOP）风格分四步介绍。本章涵盖第 1 步和第 2 步；[下一章](ch_classes.html#ch_classes)涵盖第
    3 步和第 4 步。步骤如下（[图 30.1](#fig:oop_steps_1_2)）：
- en: '**Single objects (this chapter):** How do *objects*, JavaScript’s basic OOP
    building blocks, work in isolation?'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单个对象（本章）：**JavaScript 的基本 OOP 构建块 *对象* 在独立状态下是如何工作的？'
- en: '**Prototype chains (this chapter):** Each object has a chain of zero or more
    *prototype objects*. Prototypes are JavaScript’s core inheritance mechanism.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**原型链（本章）：**每个对象都有一个零个或多个 *原型对象* 的链。原型是 JavaScript 的核心继承机制。'
- en: '**Classes (next chapter):** JavaScript’s *classes* are factories for objects.
    The relationship between a class and its instances is based on prototypal inheritance
    (step 2).'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**类（下一章）：** JavaScript的*类*是对象的工厂。类与其实例之间的关系基于原型继承（步骤2）。'
- en: '**Subclassing (next chapter):** The relationship between a *subclass* and its
    *superclass* is also based on prototypal inheritance.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**子类化（下一章）：** 子类与其超类之间的关系也是基于原型继承。'
- en: '![](../Images/98f9d262c296ae1a67f569088f87168c.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/98f9d262c296ae1a67f569088f87168c.png)'
- en: 'Figure 30.1: This book introduces object-oriented programming in JavaScript
    in four steps.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图30.1：本书通过四个步骤介绍了JavaScript中的面向对象编程。
- en: '[30.1 Cheat sheet: objects](#cheat-sheet-objects)'
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[30.1 速查表：对象](#cheat-sheet-objects)'
- en: '[30.1.1 Cheat sheet: single objects](#cheat-sheet-single-objects)'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.1.1 速查表：单个对象](#cheat-sheet-single-objects)'
- en: 'Creating an object via an *object literal* (starts and ends with a curly brace):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过*对象字面量*创建对象（以花括号开始和结束）：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Being able to create objects directly (without classes) is one of the highlights
    of JavaScript.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 能够直接创建对象（而不使用类）是JavaScript的一个亮点。
- en: 'Spreading into objects:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的展开操作：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can also use spreading to make an unmodified (shallow) copy of an object:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用展开操作来创建一个未修改的（浅拷贝）对象：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[30.1.2 Cheat sheet: prototype chains](#cheat-sheet-prototype-chains)'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.1.2 速查表：原型链](#cheat-sheet-prototype-chains)'
- en: Prototypes are JavaScript’s fundamental inheritance mechanism. Even classes
    are based on it. Each object has `null` or an object as its prototype. The latter
    object can also have a prototype, etc. In general, we get *chains* of prototypes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 原型是JavaScript的基本继承机制。即使是类也是基于它。每个对象都有一个`null`或对象作为其原型。后者对象也可以有原型，等等。一般来说，我们得到*原型链*。
- en: 'Prototypes are managed like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 原型是这样管理的：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notes:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项：
- en: 'Setting an object’s prototype while creating the object: line A, line C'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建对象时设置对象的原型：行A，行C
- en: 'Retrieving the prototype of an object: line B'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取对象的原型：行B
- en: 'Each object inherits all the properties of its prototype:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象继承其原型的所有属性：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The non-inherited properties of an object are called its *own* properties.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的非继承属性称为其*自有*属性。
- en: The most important use case for prototypes is that several objects can share
    methods by inheriting them from a common prototype.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 原型的最重要用途是，多个对象可以通过从公共原型继承来共享方法。
- en: '[30.2 What is an object?](#what-is-an-object)'
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[30.2 什么是对象？](#what-is-an-object)'
- en: 'Objects in JavaScript:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的对象：
- en: An object is a set of *slots* (key-value entries).
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象是一组*槽位*（键值对）。
- en: 'Public slots are called *properties*:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共槽位称为*属性*：
- en: A property key can only be a string or a symbol.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性键只能是一个字符串或一个符号。
- en: Private slots can only be created via classes and are explained in [“Public
    slots (properties) vs. private slots” (§31.2.4)](ch_classes.html#private-slots).
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有槽位只能通过类创建，并在[“公共槽位（属性）与私有槽位”（§31.2.4）](ch_classes.html#private-slots)中解释。
- en: '[30.2.1 The two ways of using objects](#ways-of-using-objects)'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.2.1 使用对象的方式](#ways-of-using-objects)'
- en: 'There are two ways of using objects in JavaScript:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中有两种使用对象的方式：
- en: 'Fixed-layout objects: Used this way, objects work like records in databases.
    They have a fixed number of properties, whose keys are known at development time.
    Their values generally have different types.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定布局对象：以这种方式使用，对象就像数据库中的记录。它们有固定数量的属性，其键在开发时已知。它们的值通常具有不同的类型。
- en: '[PRE5]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Dictionary objects: Used this way, objects work like lookup tables or maps.
    They have a variable number of properties, whose keys are not known at development
    time. All of their values have the same type.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典对象：以这种方式使用，对象就像查找表或映射。它们有可变数量的属性，其键在开发时未知。它们的值具有相同的类型。
- en: '[PRE6]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that the two ways can also be mixed: Some objects are both fixed-layout
    objects and dictionary objects.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，两种方式也可以混合使用：一些对象既是固定布局对象也是字典对象。
- en: 'The ways of using objects influence how they are explained in this chapter:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象的方式会影响本章中对它们的解释：
- en: '[First, we’ll explore fixed-layout objects.](#fixed-layout-objects) Even though
    property keys are strings or symbols under the hood, they will appear as fixed
    identifiers to us.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[首先，我们将探索固定布局对象。](#fixed-layout-objects) 尽管在底层属性键是字符串或符号，但它们将对我们显示为固定标识符。'
- en: '[Later, we’ll explore dictionary objects.](#dictionary-objects) Note that [Maps](ch_maps.html#ch_maps)
    are usually better dictionaries than objects. However, some of the operations
    that we’ll encounter are also useful for fixed-layout objects.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[稍后我们将探索字典对象。](#dictionary-objects) 注意，[映射](ch_maps.html#ch_maps)通常比对象更好的字典。然而，我们将遇到的一些操作对于固定布局对象也是有用的。'
- en: '[30.3 Fixed-layout objects](#fixed-layout-objects)'
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[30.3 固定布局对象](#fixed-layout-objects)'
- en: Let’s first explore *fixed-layout objects*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先探索**固定布局对象**。
- en: '[30.3.1 Object literals: properties](#object-literals)'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.3.1 对象字面量：属性](#object-literals)'
- en: '*Object literals* are one way of creating fixed-layout objects. They are a
    stand-out feature of JavaScript: we can directly create objects – no need for
    classes! This is an example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象字面量**是创建固定布局对象的一种方式。它是 JavaScript 的一个突出特点：我们可以直接创建对象——不需要类！以下是一个示例：'
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the example, we created an object via an object literal, which starts and
    ends with curly braces `{}`. Inside it, we defined two *properties* (key-value
    entries):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们通过对象字面量创建了一个对象，它以大括号 `{}` 开头和结尾。在其中，我们定义了两个**属性**（键值对）：
- en: The first property has the key `first` and the value `'Jane'`.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个属性具有键 `first` 和值 `'Jane'`。
- en: The second property has the key `last` and the value `'Doe'`.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个属性具有键 `last` 和值 `'Doe'`。
- en: Since ES5, trailing commas are allowed in object literals.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 自 ES5 以来，对象字面量允许使用尾随逗号。
- en: 'We will later see other ways of specifying property keys, but with this way
    of specifying them, they must follow the rules of JavaScript variable names. For
    example, we can use `first_name` as a property key, but not `first-name`). However,
    reserved words are allowed:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将稍后看到其他指定属性键的方法，但使用这种方法指定时，它们必须遵循 JavaScript 变量名的规则。例如，我们可以使用 `first_name`
    作为属性键，但不能使用 `first-name`）。然而，允许使用保留字：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In order to check the effects of various operations on objects, we’ll occasionally
    use `Object.keys()` in this part of the chapter. It lists property keys:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查各种操作对对象的影响，我们将在本章的这一部分偶尔使用 `Object.keys()`。它列出了属性键：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[30.3.2 Object literals: property value shorthands](#object-literals-property-value-shorthands)'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.3.2 对象字面量：属性值简写](#object-literals-property-value-shorthands)'
- en: Whenever the value of a property is defined via a variable that has the same
    name as the key, we can omit the key.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当属性的值通过具有与键相同名称的变量定义时，我们可以省略键。
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[30.3.3 Getting properties](#getting-properties)'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.3.3 获取属性](#getting-properties)'
- en: 'This is how we *get* (read) a property (line A):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何**获取**（读取）一个属性（行 A）：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Getting an unknown property produces `undefined`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 获取一个未知属性会产生 `undefined`：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[30.3.4 Setting properties](#setting-properties)'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.3.4 设置属性](#setting-properties)'
- en: 'This is how we *set* (write to) a property (line A):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何**设置**（写入）一个属性（行 A）：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We just changed an existing property via setting. If we set an unknown property,
    we create a new entry:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过设置更改了一个现有的属性。如果我们设置一个未知的属性，我们将创建一个新的条目：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[30.3.5 Object literals: methods](#object-literals-methods)'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.3.5 对象字面量：方法](#object-literals-methods)'
- en: 'The following code shows how to create the method `.says()` via an object literal:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何通过对象字面量创建方法 `.says()`：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: During the method call `jane.says('hello')`, `jane` is called the *receiver*
    of the method call and assigned to the special variable `this` (more on `this`
    in [“Methods and the special variable `this`” (§30.6)](#methods-and-this)). That
    enables method `.says()` to access the sibling property `.first` in line A.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法调用 `jane.says('hello')` 中，`jane` 被称为方法调用的**接收者**，并分配给特殊变量 `this`（关于 `this`
    的更多信息请参阅[“方法和特殊变量 `this`” (§30.6)](#methods-and-this))。这使得方法 `.says()` 能够访问行 A
    中的兄弟属性 `.first`。
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Creating an object via an object literal**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![练习图标“exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：通过对象字面量创建对象**'
- en: '`exercises/objects/color_point_object_test.mjs`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/objects/color_point_object_test.mjs`'
- en: '[30.3.6 Object literals: accessors](#object-literal-accessors)'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.3.6 对象字面量：访问器](#object-literal-accessors)'
- en: '*Accessors* are methods that are invoked by accessing a property. It consists
    of either or both of:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问器**是通过访问属性来调用的方法。它由以下一个或两个组成：'
- en: A *getter* is invoked by getting a property.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取器**是通过获取属性来调用的。'
- en: A *setter* is invoked by setting a property.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置器**是通过设置属性来调用的。'
- en: '[30.3.6.1 Getters](#getters)'
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.3.6.1 获取器](#getters)'
- en: 'A getter is created by prefixing a method definition with the modifier `get`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在方法定义前缀添加修饰符 `get` 来创建获取器：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[30.3.6.2 Setters](#setters)'
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.3.6.2 设置器](#setters)'
- en: 'A setter is created by prefixing a method definition with the modifier `set`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在方法定义前缀添加修饰符 `set` 创建一个设置器：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[30.3.6.3 Use case for getters: ready-only properties whose values change](#use-case-for-getters-readyonly-properties-whose-values-change)'
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.3.6.3 getter 的使用场景：值会改变的只读属性](#use-case-for-getters-readyonly-properties-whose-values-change)'
- en: 'In the following code, the actual value of the counter is private. From the
    outside, it can only be read, via a getter:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，计数器的实际值是私有的。从外部，它只能通过 getter 读取：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Implementing a stack via an object**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：通过对象实现堆栈**'
- en: '`exercises/objects/stack-via-object_test.mjs`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/objects/stack-via-object_test.mjs`'
- en: '[30.3.6.4 Use case for getters: switching from a property to more encapsulation](#use-case-for-getters-switching-from-a-property-to-more-encapsulation)'
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.3.6.4 getter 的使用场景：从属性切换到更多封装](#use-case-for-getters-switching-from-a-property-to-more-encapsulation)'
- en: 'In object-oriented programming, we worry about exposing too much internal state.
    Accessors enable us to change our mind about properties without breaking existing
    code: We can start exposed, with a normal property and later switch to an accessor
    and more encapsulation.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，我们担心暴露过多的内部状态。访问器使我们能够在不破坏现有代码的情况下改变我们对属性的看法：我们可以从暴露开始，使用正常属性，然后切换到访问器和更多的封装。
- en: '[30.4 Spreading into object literals (`...`) ^(ES2018)](#spreading-into-object-literals)'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[30.4 将传播应用于对象字面量（`...`）^(ES2018)](#spreading-into-object-literals)'
- en: 'Inside an object literal, a *spread property* adds the properties of another
    object to the current one:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象字面量内部，一个 *传播属性* 将另一个对象的属性添加到当前对象中：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If property keys clash, the property that is mentioned last “wins”:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性键冲突，最后提到的属性“获胜”：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'All values are spreadable, even `undefined` and `null`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所有值都是可传播的，即使是 `undefined` 和 `null`：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Property `.length` of strings and Arrays is hidden from this kind of operation
    (it is not *enumerable*; see [“Property attributes and property descriptors ^(ES5)
    (advanced)” (§30.10)](#property-attributes-property-descriptors) for more information).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串和数组中 `.length` 属性对此类操作是隐藏的（它不是 *可枚举的*；有关更多信息，请参阅[“属性属性和属性描述符^(ES5) (高级)”
    (§30.10)](#property-attributes-property-descriptors)）。
- en: 'Spreading includes properties whose keys are symbols (which are ignored by
    `Object.keys()`, `Object.values()` and `Object.entries()`):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 传播包括键为符号（由 `Object.keys()`、`Object.values()` 和 `Object.entries()` 忽略）的属性：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[30.4.1 Use case for spreading: default values for missing properties](#use-case-for-spreading-default-values-for-missing-properties)'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.4.1 传播的使用场景：缺失属性的默认值](#use-case-for-spreading-default-values-for-missing-properties)'
- en: 'If one of the inputs of our code is an object with data, we can make properties
    optional by specifying default values that are used if those properties are missing.
    One technique for doing so is via an object whose properties contain the default
    values. In the following example, that object is `DEFAULTS`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的代码的输入之一是一个包含数据的对象，我们可以通过指定默认值来使属性可选，如果这些属性缺失，则使用这些默认值。完成此操作的一种技术是通过一个其属性包含默认值的对象。在以下示例中，该对象是
    `DEFAULTS`：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The result, the object `allData`, is created by copying `DEFAULTS` and overriding
    its properties with those of `providedData`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，对象 `allData` 是通过复制 `DEFAULTS` 并用 `providedData` 的属性覆盖其属性创建的。
- en: 'But we don’t need an object to specify the default values; we can also specify
    them inside the object literal, individually:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不需要对象来指定默认值；我们也可以在对象字面量内部单独指定它们：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[30.4.2 Use case for spreading: non-destructively changing properties](#use-case-for-spreading-nondestructively-changing-properties)'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.4.2 传播的使用场景：非破坏性地更改属性](#use-case-for-spreading-nondestructively-changing-properties)'
- en: 'So far, we have encountered one way of changing a property `.alpha` of an object:
    We *set* it (line A) and mutate the object. That is, this way of changing a property
    is destructive.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经遇到了一种更改对象属性 `.alpha` 的方法：我们 *设置* 它（行 A）并修改对象。也就是说，这种更改属性的方式是破坏性的。
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With spreading, we can change `.alpha` non-destructively – we make a copy of
    `obj` where `.alpha` has a different value:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传播，我们可以非破坏性地更改 `.alpha` – 我们创建一个 `obj` 的副本，其中 `.alpha` 的值不同：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Non-destructively updating a property via spreading (fixed key)**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：通过传播（固定键）非破坏性地更新属性**'
- en: '`exercises/objects/update_name_test.mjs`'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/objects/update_name_test.mjs`'
- en: '[30.4.3 “Destructive spreading”: `Object.assign()` ^(ES6)](#Object.assign)'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.4.3 “破坏性展开”：`Object.assign()` (ES6)](#Object.assign)'
- en: '`Object.assign()` is a tool method:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign()` 是一个工具方法：'
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This expression assigns all properties of `source_1` to `target`, then all
    properties of `source_2`, etc. At the end, it returns `target` – for example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式将 `source_1` 的所有属性赋值给 `target`，然后是 `source_2` 的所有属性，等等。最后，它返回 `target`——例如：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The use cases for `Object.assign()` are similar to those for spread properties.
    In a way, it spreads destructively.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign()` 的用例与展开属性的用例相似。在某种程度上，它是破坏性地展开。'
- en: '[30.5 Copying objects: spreading vs. `Object.assign()` vs. `structuredClone()`](#copying-objects)'
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[30.5 复制对象：展开与 `Object.assign()` 与 `structuredClone()`](#copying-objects)'
- en: '[30.5.1 Copying objects via spreading is *shallow*](#copying-objects-via-spreading-is-shallow)'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.5.1 通过展开复制对象是浅复制](#copying-objects-via-spreading-is-shallow)'
- en: 'One common way of copying Arrays and plain objects in JavaScript is via spreading.
    This code demonstrates the latter:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中复制数组和普通对象的一种常见方法是使用展开。以下代码演示了后者：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Alas, this way of copying is *shallow*: The properties (key-value entries)
    are copied but not the property values.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，这种复制方式是浅复制：属性（键值对）被复制，但属性值没有被复制。
- en: 'On one hand, the key-value entry `shallowCopy.id` is a copy, so changing it
    does not change `obj`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，键值对 `shallowCopy.id` 是一个复制，所以修改它不会改变 `obj`：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'On the other hand, the Array in `shallowCopy.values` is shared with `obj`.
    If we change it, we also change `obj`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`shallowCopy.values` 中的数组与 `obj` 共享。如果我们修改它，也会修改 `obj`：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Copying via `Object.assign()` is similar to copying via spreading and also
    shallow:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `Object.assign()` 复制与通过展开类似，也是浅复制：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[30.5.2 Copying objects deeply via `structuredClone()`](#structuredClone)'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.5.2 通过 `structuredClone()` 深度复制对象](#structuredClone)'
- en: '`structuredClone()` is a function for copying objects. Even though it is not
    part of ECMAScript, it is [well-supported](https://developer.mozilla.org/en-US/docs/Web/API/Window/structuredClone#browser_compatibility)
    on all major JavaScript platforms. It has the following typeSignature:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`structuredClone()` 是一个用于复制的函数。尽管它不是ECMAScript的一部分，但它被所有主要的JavaScript平台良好支持。[良好支持](https://developer.mozilla.org/en-US/docs/Web/API/Window/structuredClone#browser_compatibility)。它有以下类型签名：'
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`structuredClone()` copies objects deeply:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`structuredClone()` 深度复制对象：'
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **`structuredClone()`
    has a second paramater**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“详情”](../Images/38ba63de820aae6f94a019538ae0f222.png) **`structuredClone()`
    有第二个参数**'
- en: '`structuredClone()` has a second parameter which is beyond the scope of this
    chapter. For more information, see:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`structuredClone()` 有一个超出本章范围的第二个参数。更多信息，请参阅：'
- en: '[“Transferring ArrayBuffers via `structuredClone()`” (§35.7.3)](ch_typed-arrays.html#transferring-arraybuffers-via-structuredclone)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“通过 `structuredClone()` 转移 ArrayBuffer”（§35.7.3）](ch_typed-arrays.html#transferring-arraybuffers-via-structuredclone)'
- en: '[The MDN page for `structuredClone()`](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[关于 `structuredClone()` 的MDN页面](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone)'
- en: '[30.5.3 Which values can `structuredClone()` copy?](#which-values-can-structuredclone-copy)'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.5.3 `structuredClone()` 可以复制哪些值？](#which-values-can-structuredclone-copy)'
- en: It can copy all primitive values except symbols.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以复制所有原始值，除了符号。
- en: It can copy all built-in objects except functions and DOM nodes.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以复制所有内置对象，除了函数和DOM节点。
- en: Instances of user-defined classes become plain objects.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义类的实例变为普通对象。
- en: Private fields are not copied.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有字段不会被复制。
- en: Cyclical references are copied correctly.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环引用被正确复制。
- en: Given that the original use case for `structuredClone()` was copying objects
    to other processes, these limitations make sense.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `structuredClone()` 的原始用途是将对象复制到其他进程，这些限制是有意义的。
- en: Read on for more information.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 继续阅读以获取更多信息。
- en: '[30.5.3.1 Most primitive values can be copied](#most-primitive-values-can-be-copied)'
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.5.3.1 大多数原始值都可以复制](#most-primitive-values-can-be-copied)'
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[30.5.3.2 Most built-in objects can be copied](#most-builtin-objects-can-be-copied)'
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.5.3.2 大多数内置对象可以被复制](#most-builtin-objects-can-be-copied)'
- en: 'Arrays and plain objects can be copied:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和普通对象可以被复制：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Instances of most built-in classes can be copied – even though they have internal
    slots. They remain instances of their classes.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数内置类的实例可以被复制——即使它们有内部槽位。它们仍然是它们类的一个实例。
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[30.5.3.3 Copying symbols and some objects produces exceptions](#copying-symbols-and-some-objects-produces-exceptions)'
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.5.3.3 复制符号和一些对象会产生异常](#copying-symbols-and-some-objects-produces-exceptions)'
- en: 'Symbols and some objects cannot be copied – `structuredClone()` throws a `DOMException`
    if we try to copy them or if we try to copy an object that contains them:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 符号和一些对象不能被复制——如果我们尝试复制它们，或者尝试复制包含它们的对象，`structuredClone()` 会抛出 `DOMException`：
- en: Symbols
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号
- en: Functions (ordinary functions, arrow functions, classes, methods)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数（普通函数、箭头函数、类、方法）
- en: DOM nodes
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOM 节点
- en: 'Examples – cloning symbols:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 示例——克隆符号：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Examples – cloning functions:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 示例——克隆函数：
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: What does the exception look like that is thrown by `structuredClone()`?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`structuredClone()` 抛出的异常是什么样的？'
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[30.5.3.4 Instances of user-defined classes become plain objects](#instances-of-userdefined-classes-become-plain-objects)'
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.5.3.4 用户定义类的实例变为普通对象](#instances-of-userdefined-classes-become-plain-objects)'
- en: In the following example, we copy an instance of the class `C`. The result,
    `copy`, is not an instance of `C`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们复制了类 `C` 的一个实例。结果 `copy` 不是一个 `C` 的实例。
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[30.5.3.5 Private fields are not copied](#private-fields-are-not-copied)'
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.5.3.5 私有字段不会被复制](#private-fields-are-not-copied)'
- en: 'This limitation is related to the previous subsection – private fields are
    not copied by `structuredClone()`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这种限制与前面的子节有关——私有字段不会被 `structuredClone()` 复制：
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[30.5.3.6 Cyclical references are copied correctly](#cyclical-references-are-copied-correctly)'
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.5.3.6 循环引用被正确复制](#cyclical-references-are-copied-correctly)'
- en: 'If we copy an object with a reference cycle, the result has the same structure:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们复制一个具有引用循环的对象，结果具有相同的结构：
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[30.5.4 The property attributes of copied objects](#the-property-attributes-of-copied-objects)'
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.5.4 复制对象的属性属性](#the-property-attributes-of-copied-objects)'
- en: '`structuredClone()` doesn’t always faithfully copy the [property attributes](#property-attributes-property-descriptors)
    of objects:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`structuredClone()` 并不总是忠实地复制对象的 [属性属性](#property-attributes-property-descriptors)：'
- en: Accessors are turned into data properties.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问器被转换为数据属性。
- en: In copies, the property attributes always have default values.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在复制中，属性属性始终具有默认值。
- en: Read on for more information.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 查看更多信息。
- en: '[30.5.4.1 Accessors become data properties](#accessors-become-data-properties)'
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.5.4.1 访问器变为数据属性](#accessors-become-data-properties)'
- en: 'Accessors become data properties:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 访问器变为数据属性：
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[30.5.4.2 Copies of properties have default attribute values](#copies-of-properties-have-default-attribute-values)'
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.5.4.2 属性复制具有默认属性值](#copies-of-properties-have-default-attribute-values)'
- en: 'Data properties of copies always have the following attributes:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 复制的数据属性始终具有以下属性：
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[30.5.5 Alternatives without the limitations of `structuredClone()`?](#alternatives-without-the-limitations-of-structuredclone)'
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.5.5 没有 `structuredClone()` 限制的替代方案？](#alternatives-without-the-limitations-of-structuredclone)'
- en: If we can’t live with the limitations of `structuredClone()`, such as turning
    instances of classes into plain objects, we can use the Lodash function [`cloneDeep()`](https://lodash.com/docs#cloneDeep)
    – which has fewer limitations.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不能忍受 `structuredClone()` 的限制，例如将类的实例转换为普通对象，我们可以使用 Lodash 函数 `cloneDeep()`（它具有更少的限制）。
- en: '[30.5.6 Sources of this section](#sources-of-this-section-1)'
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.5.6 本节来源](#sources-of-this-section-1)'
- en: '[Section “Safe passing of structured data”](https://html.spec.whatwg.org/#safe-passing-of-structured-data)
    in the WHATWG HTML standard'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“安全传递结构化数据”部分](https://html.spec.whatwg.org/#safe-passing-of-structured-data)
    在 WHATWG HTML 标准中'
- en: '[“The structured clone algorithm”](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm)
    on MDN'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“结构化克隆算法”](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm)
    在 MDN'
- en: '[“`structuredClone()`”](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone)
    on MDN'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“`structuredClone()`”](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone)
    在 MDN'
- en: '[30.6 Methods and the special variable `this`](#methods-and-this)'
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[30.6 方法和特殊变量 `this`](#methods-and-this)'
- en: '[30.6.1 Methods are properties whose values are functions](#methods-are-properties-whose-values-are-functions)'
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.6.1 方法值是函数的属性](#methods-are-properties-whose-values-are-functions)'
- en: 'Let’s revisit the example that was used to introduce methods:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下用于介绍方法的示例：
- en: '[PRE47]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Somewhat surprisingly, methods are functions:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 有点令人惊讶，方法实际上是函数：
- en: '[PRE48]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Why is that? We learned [in the chapter on callable values](ch_callables.html#roles-of-ordinary-functions)
    that ordinary functions play several roles. *Method* is one of those roles. Therefore,
    internally, `jane` roughly looks as follows.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会这样？我们在关于可调用值的章节（ch_callables.html#roles-of-ordinary-functions）中了解到，普通函数扮演着多个角色。*方法*是其中之一。因此，在内部，`jane`
    大概如下所示。
- en: '[PRE49]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[30.6.2 The special variable `this`](#the-special-variable-this)'
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.6.2 特殊变量 `this`](#the-special-variable-this)'
- en: 'Consider the following code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE50]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In line B, `obj` is the *receiver* of a method call. It is passed to the function
    stored in `obj.someMethod` via an implicit (hidden) parameter whose name is `this`
    (line A).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在行B中，`obj`是方法调用的*接收者*。它通过一个名为`this`的隐式（隐藏）参数传递给存储在`obj.someMethod`中的函数（行A）。
- en: '![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **How to understand
    `this`**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“提示”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **如何理解`this`**'
- en: The best way to understand `this` is as an implicit parameter of ordinary functions
    and methods.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 理解`this`的最佳方式是将它视为普通函数和方法的隐式参数。
- en: '[30.6.3 Methods and `.call()`](#methods-call)'
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.6.3 方法与 `.call()`](#methods-call)'
- en: Methods are functions and functions have methods themselves. One of those methods
    is [`.call()`](ch_callables.html#Function.prototype.call). Let’s look at an example
    to understand how this method works.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是函数，函数本身也有方法。其中一种方法是[`.call()`](ch_callables.html#Function.prototype.call)。让我们通过一个示例来了解这个方法是如何工作的。
- en: 'In the previous section, there was this method invocation:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，有这个方法调用：
- en: '[PRE51]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This invocation is equivalent to:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用等价于：
- en: '[PRE52]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Which is also equivalent to:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是等价的：
- en: '[PRE53]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`.call()` makes the normally implicit parameter `this` explicit: When invoking
    a function via `.call()`, the first parameter is `this`, followed by the regular
    (explicit) function parameters.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`.call()`使通常隐式的参数`this`显式：通过`.call()`调用函数时，第一个参数是`this`，后面跟着常规（显式）函数参数。'
- en: 'As an aside, this means that there are actually two different dot operators:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，这意味着实际上存在两个不同的点操作符：
- en: 'One for accessing properties: `obj.prop`'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于访问属性：`obj.prop`
- en: 'Another one for calling methods: `obj.prop()`'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个用于调用方法：`obj.prop()`
- en: They are different in that (2) is not just (1) followed by the function call
    operator `()`. Instead, (2) additionally provides a value for `this`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在以下方面不同：（2）不仅仅是（1）后面跟着函数调用操作符`()`。相反，（2）还提供了`this`的值。
- en: '[30.6.4 Methods and `.bind()`](#methods-bind)'
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.6.4 方法与 `.bind()`](#methods-bind)'
- en: '[`.bind()`](ch_callables.html#Function.prototype.bind) is another method of
    function objects. In the following code, we use `.bind()` to turn method `.says()`
    into the stand-alone function `func()`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[`.bind()`](ch_callables.html#Function.prototype.bind)是函数对象的一种方法。在下面的代码中，我们使用`.bind()`将方法`.says()`转换为独立的函数`func()`：'
- en: '[PRE54]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Setting `this` to `jane` via `.bind()` is crucial here. Otherwise, `func()`
    wouldn’t work properly because `this` is used in line A. In the next section,
    we’ll explore why that is.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`.bind()`将`this`设置为`jane`在这里至关重要。否则，`func()`将无法正常工作，因为`this`在行A中使用。在下一节中，我们将探讨这是为什么。
- en: '[30.6.5 `this` pitfall: extracting methods](#extracting-methods)'
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.6.5 `this`陷阱：提取方法](#extracting-methods)'
- en: 'We now know quite a bit about functions and methods and are ready to take a
    look at the biggest pitfall involving methods and `this`: function-calling a method
    extracted from an object can fail if we are not careful.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对函数和方法有了相当多的了解，准备看看涉及方法和`this`的最大陷阱：如果我们不小心，从对象中提取的方法进行函数调用可能会失败。
- en: In the following example, we fail when we extract method `jane.says()`, store
    it in the variable `func`, and function-call `func`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，当我们从`jane.says()`中提取方法，将其存储在变量`func`中，并调用`func`时，我们失败了。
- en: '[PRE55]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In line A, we are making a normal function call. And in normal function calls,
    `this` is `undefined` (if [strict mode](ch_syntax.html#strict-mode) is active,
    which it almost always is). Line A is therefore equivalent to:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在行A中，我们正在进行正常的函数调用。在正常的函数调用中，`this`是`undefined`（如果[严格模式](ch_syntax.html#strict-mode)处于活动状态，这几乎总是如此）。因此，行A等价于：
- en: '[PRE56]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'How do we fix this? We need to use `.bind()` to extract method `.says()`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何修复这个问题？我们需要使用`.bind()`来提取方法`.says()`：
- en: '[PRE57]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `.bind()` ensures that `this` is always `jane` when we call `func()`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`.bind()`确保在调用`func()`时`this`始终是`jane`。'
- en: 'We can also use arrow functions to extract methods:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用箭头函数来提取方法：
- en: '[PRE58]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[30.6.5.1 Example: extracting a method](#example-extracting-a-method)'
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.6.5.1 示例：提取方法](#example-extracting-a-method)'
- en: 'The following is a simplified version of code that we may see in actual web
    development:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在实际Web开发中可能看到的简化代码版本：
- en: '[PRE59]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In line A, we don’t extract the method `.handleClick()` properly. Instead,
    we should do:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在行A中，我们没有正确提取方法`.handleClick()`。相反，我们应该这样做：
- en: '[PRE60]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Each invocation of `.bind()` creates a new function. That’s why we need to store
    the result somewhere if we want to remove it later on.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`.bind()`都会创建一个新的函数。这就是为什么如果我们想在以后删除它，我们需要将结果存储在某个地方的原因。
- en: '[30.6.5.2 How to avoid the pitfall of extracting methods](#how-to-avoid-the-pitfall-of-extracting-methods)'
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.6.5.2 避免提取方法的陷阱](#how-to-avoid-the-pitfall-of-extracting-methods)'
- en: 'Alas, there is no simple way around the pitfall of extracting methods: Whenever
    we extract a method, we have to be careful and do it properly – for example, by
    binding `this` or by using an arrow function.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，没有简单的方法可以绕过提取方法的陷阱：每次我们提取一个方法时，我们必须小心并正确地执行它——例如，通过绑定 `this` 或使用箭头函数。
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Extracting a method**'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“练习”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：提取方法**'
- en: '`exercises/objects/method_extraction_exrc.mjs`'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/objects/method_extraction_exrc.mjs`'
- en: '[30.6.6 `this` pitfall: accidentally shadowing `this`](#shadowing-this)'
  id: totrans-314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.6.6 `this` 陷阱：意外覆盖 `this`](#shadowing-this)'
- en: '![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Accidentally
    shadowing `this` is only an issue with ordinary functions**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“提示”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **意外覆盖 `this` 只是在普通函数中是一个问题**'
- en: Arrow functions don’t shadow `this`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数不会覆盖 `this`。
- en: 'Consider the following problem: when we are inside an ordinary function, we
    can’t access the `this` of the surrounding scope because the ordinary function
    has its own `this`. In other words, a variable in an inner scope hides a variable
    in an outer scope. That is called [*shadowing*](ch_variables-assignment.html#shadowing-variables).
    The following code is an example:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下问题：当我们处于普通函数内部时，我们无法访问周围作用域的 `this`，因为普通函数有自己的 `this`。换句话说，内层作用域中的变量会隐藏外层作用域中的变量。这被称为[*覆盖*](ch_variables-assignment.html#shadowing-variables)。以下代码是一个示例：
- en: '[PRE61]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In line A, we want to access the `this` of `.prefixStringArray()`. But we can’t
    since the surrounding ordinary function has its own `this` that *shadows* (and
    blocks access to) the `this` of the method. The value of the former `this` is
    `undefined` due to the callback being function-called. That explains the error
    message.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 A，我们想要访问 `.prefixStringArray()` 的 `this`。但我们无法做到，因为周围普通函数有自己的 `this`，它会*覆盖*（并阻止访问）方法的
    `this`。由于回调是函数调用，前者的 `this` 值是 `undefined`。这解释了错误信息。
- en: 'The simplest way to fix this problem is via an arrow function, which doesn’t
    have its own `this` and therefore doesn’t shadow anything:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最简单方法是使用箭头函数，它没有自己的 `this`，因此不会覆盖任何内容：
- en: '[PRE62]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can also store `this` in a different variable (line A), so that it doesn’t
    get shadowed:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将 `this` 存储在不同的变量中（行 A），这样它就不会被覆盖：
- en: '[PRE63]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Another option is to specify a fixed `this` for the callback via `.bind()`
    (line A):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是通过 `.bind()` 为回调指定一个固定的 `this`（行 A）：
- en: '[PRE64]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Lastly, `.map()` lets us specify a value for `this` (line A) that it uses when
    invoking the callback:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`.map()` 允许我们指定一个值作为 `this`（行 A），它在调用回调时使用：
- en: '[PRE65]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[30.6.6.1 Avoiding the pitfall of accidentally shadowing `this`](#avoiding-the-pitfall-of-accidentally-shadowing-this)'
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.6.6.1 避免意外覆盖 `this` 的陷阱](#avoiding-the-pitfall-of-accidentally-shadowing-this)'
- en: 'If we follow the advice in [“Recommendation: prefer specialized functions over
    ordinary functions” (§27.3.4)](ch_callables.html#prefer-specialized-functions),
    we can avoid the pitfall of accidentally shadowing `this`. This is a summary:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遵循[“建议：优先使用专用函数而不是普通函数”（§27.3.4）](ch_callables.html#prefer-specialized-functions)的建议，我们可以避免意外覆盖
    `this` 的陷阱。以下是总结：
- en: Use arrow functions as anonymous inline functions. They don’t have `this` as
    an implicit parameter and don’t shadow it.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将箭头函数用作匿名内联函数。它们没有 `this` 作为隐式参数，也不会覆盖它。
- en: For named stand-alone function declarations we can either use arrow functions
    or function declarations. If we do the latter, we have to make sure `this` isn’t
    mentioned in their bodies.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于命名的独立函数声明，我们可以使用箭头函数或函数声明。如果我们选择后者，我们必须确保在它们的主体中不提及 `this`。
- en: '[30.6.7 The value of `this` in various contexts (advanced)](#the-value-of-this-in-various-contexts-advanced)'
  id: totrans-332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.6.7 在各种上下文中 `this` 的值（高级）](#the-value-of-this-in-various-contexts-advanced)'
- en: What is the value of `this` in various contexts?
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在各种上下文中 `this` 的值是什么？
- en: 'Inside a callable entity, the value of `this` depends on how the callable entity
    is invoked and what kind of callable entity it is:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在可调用实体内部，`this` 的值取决于如何调用该可调用实体以及它是什么类型：
- en: 'Function call:'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数调用：
- en: 'Ordinary functions: `this === undefined` (in [strict mode](ch_syntax.html#strict-mode))'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通函数：`this === undefined`（在[严格模式](ch_syntax.html#strict-mode)下）
- en: 'Arrow functions: `this` is same as in surrounding scope (lexical `this`)'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数：`this` 与周围作用域相同（词法 `this`）
- en: 'Method call: `this` is receiver of call'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法调用：`this` 是调用的接收者
- en: '`new`: `this` refers to the newly created instance'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new`：`this` 指向新创建的实例'
- en: 'We can also access `this` in all common top-level scopes:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在所有常见的顶层作用域中访问 `this`：
- en: '`<script>` element: `this === globalThis`'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<script>` 元素：`this === globalThis`'
- en: 'ECMAScript modules: `this === undefined`'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 模块：`this === undefined`
- en: 'CommonJS modules: `this === module.exports`'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CommonJS 模块：`this === module.exports`
- en: '![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Tip: pretend
    that `this` doesn’t exist in top-level scopes**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“提示”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **提示：在顶层作用域中假装 `this`
    不存在**'
- en: I like to do that because top-level `this` is confusing and there are better
    alternatives for its (few) use cases.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢这样做，因为顶层 `this` 很令人困惑，并且有更好的替代方案来解决其（少数）用例。
- en: '[30.7 Optional chaining for property getting and method calls ^(ES2020) (advanced)](#optional-chaining)'
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[30.7 可选链用于属性获取和方法调用（ES2020）（高级）](#optional-chaining)'
- en: 'The following kinds of optional chaining operations exist:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 存在以下类型的可选链操作：
- en: '[PRE66]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The rough idea is:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 大致的想法是：
- en: If the value before the question mark is neither `undefined` nor `null`, then
    perform the operation after the question mark.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果问号前的值既不是 `undefined` 也不是 `null`，则执行问号后的操作。
- en: Otherwise, return `undefined`.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，返回 `undefined`。
- en: 'Each of the three syntaxes is covered in more detail later. These are a few
    first examples:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 三个语法中的每一个都会在稍后更详细地介绍。以下是一些初步示例：
- en: '[PRE67]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Mnemonic for
    the optional chaining operator (`?.`)**'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“提示”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **可选链操作符（`?.`）的助记符**'
- en: 'Are you occasionally unsure if the optional chaining operator starts with a
    dot (`.?`) or a question mark (`?.`)? Then this mnemonic may help you:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否偶尔不确定可选链操作符是以点（`.?`）还是问号（`?.`）开头？那么这个助记符可能对你有帮助：
- en: '**If** (`?`) the left-hand side is not nullish'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果** (`?`) 左侧不是空值'
- en: '**then** (`.`) access a property.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**then** (`.`) 访问一个属性。'
- en: '[30.7.1 Example: optional fixed property getting](#example-optional-fixed-property-getting)'
  id: totrans-358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.7.1 示例：可选固定属性获取](#example-optional-fixed-property-getting)'
- en: 'Consider the following data:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下数据：
- en: '[PRE68]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can use optional chaining to safely extract street names:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用可选链安全地提取街道名称：
- en: '[PRE69]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[30.7.1.1 Handling defaults via nullish coalescing](#handling-defaults-via-nullish-coalescing)'
  id: totrans-363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.7.1.1 通过空值合并处理默认值](#handling-defaults-via-nullish-coalescing)'
- en: 'The [nullish coalescing operator](ch_undefined-null.html#nullish-coalescing-operator)
    allows us to use the default value `''(no name)''` instead of `undefined`:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '[空值合并操作符](ch_undefined-null.html#nullish-coalescing-operator) 允许我们使用默认值 `''(no
    name)''` 而不是 `undefined`：'
- en: '[PRE70]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[30.7.2 The operators in more detail (advanced)](#the-operators-in-more-detail-advanced)'
  id: totrans-366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.7.2 详细介绍操作符（高级）](#the-operators-in-more-detail-advanced)'
- en: '[30.7.2.1 Optional fixed property getting](#optional-fixed-property-getting)'
  id: totrans-367
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.7.2.1 可选固定属性获取](#optional-fixed-property-getting)'
- en: 'The following two expressions are equivalent:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个表达式是等价的：
- en: '[PRE71]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Examples:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE72]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[30.7.2.2 Optional dynamic property getting](#optional-dynamic-property-getting)'
  id: totrans-372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.7.2.2 可选动态属性获取](#optional-dynamic-property-getting)'
- en: 'The following two expressions are equivalent:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个表达式是等价的：
- en: '[PRE73]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Examples:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE74]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[30.7.2.3 Optional function or method call](#optional-function-or-method-call)'
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.7.2.3 可选函数或方法调用](#optional-function-or-method-call)'
- en: 'The following two expressions are equivalent:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个表达式是等价的：
- en: '[PRE75]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Examples:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE76]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Note that this operator produces an error if its left-hand side is not callable:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果其左侧不是可调用的，则此操作符会产生错误：
- en: '[PRE77]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Why? The idea is that the operator only tolerates deliberate omissions. An uncallable
    value (other than `undefined` and `null`) is probably an error and should be reported,
    rather than worked around.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？这个想法是，操作符只容忍故意的省略。不可调用的值（除了 `undefined` 和 `null`）可能是一个错误，应该报告，而不是绕过。
- en: '[30.7.3 Short-circuiting with optional property getting](#shortcircuiting-with-optional-property-getting)'
  id: totrans-385
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.7.3 使用可选属性获取进行短路](#shortcircuiting-with-optional-property-getting)'
- en: 'In a chain of property gettings and method invocations, evaluation stops once
    the first optional operator encounters `undefined` or `null` at its left-hand
    side:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性获取和方法调用链中，一旦第一个可选操作符在其左侧遇到 `undefined` 或 `null`，评估就会停止：
- en: '[PRE78]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Consider `invokeM(undefined)` in line B: `undefined?.a` is `undefined`. Therefore
    we’d expect `.b` to fail in line A. But it doesn’t: The `?.` operator encounters
    the value `undefined` and the evaluation of the whole expression immediately returns
    `undefined`.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 B 行中的 `invokeM(undefined)`：`undefined?.a` 是 `undefined`。因此我们预计 A 行中的 `.b`
    会失败。但它没有：`?.` 操作符遇到值 `undefined`，整个表达式的评估立即返回 `undefined`。
- en: 'This behavior differs from a normal operator where JavaScript always evaluates
    all operands before evaluating the operator. It is called *short-circuiting*.
    Other short-circuiting operators are:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为与正常操作符不同，JavaScript 总是在评估操作符之前评估所有操作数。这被称为*短路*。其他短路操作符包括：
- en: '`(a && b)`: `b` is only evaluated if `a` is truthy.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(a && b)`: 只有当 `a` 是真值时，才会评估 `b`。'
- en: '`(a || b)`: `b` is only evaluated if `a` is falsy.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(a || b)`: 只有当 `a` 是假值时，才会评估 `b`。'
- en: '`(c ? t : e)`: If `c` is truthy, `t` is evaluated. Otherwise, `e` is evaluated.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(c ? t : e)`: 如果 `c` 是真值，则评估 `t`。否则，评估 `e`。'
- en: '[30.7.4 Optional chaining: downsides and alternatives](#optional-chaining-downsides-and-alternatives)'
  id: totrans-393
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.7.4 可选链：缺点和替代方案](#optional-chaining-downsides-and-alternatives)'
- en: 'Optional chaining also has downsides:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 可选链也有缺点：
- en: 'Deeply nested structures are more difficult to manage. For example, refactoring
    is harder if there are many sequences of property names: Each one enforces the
    structure of multiple objects.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深层嵌套的结构更难管理。例如，如果有许多属性名序列，重构会更困难：每个序列都强制多个对象的结构。
- en: Being so forgiving when accessing data hides problems that will surface much
    later and are then harder to debug. For example, a typo early in a sequence of
    optional property names has more negative effects than a normal typo.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在访问数据时过于宽容会隐藏出问题，这些问题会在以后显现出来，那时调试会更困难。例如，在一系列可选属性名中早期出现的拼写错误比普通拼写错误有更负面的影响。
- en: 'An alternative to optional chaining is to extract the information once, in
    a single location:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 可选链的另一种替代方法是提取信息一次，在单个位置：
- en: We can either write a helper function that extracts the data.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以编写一个辅助函数来提取数据。
- en: Or we can write a function whose input is deeply nested data and whose output
    is simpler, normalized data.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者我们可以编写一个函数，其输入是深层嵌套的数据，其输出是更简单、规范化的数据。
- en: With either approach, it is possible to perform checks and to fail early if
    there are problems.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何一种方法，如果存在问题，都有可能进行检查并在早期失败。
- en: 'Further reading:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步阅读：
- en: “[Overly defensive programming](https://blog.vcarl.com/overly-defensive-programming/)”
    by Carl Vitullo
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “[过度防御性编程](https://blog.vcarl.com/overly-defensive-programming/)” by Carl Vitullo
- en: '[30.7.5 Frequently asked questions](#frequently-asked-questions)'
  id: totrans-403
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.7.5 常见问题](#frequently-asked-questions)'
- en: '[30.7.5.1 Why are there dots in `o?.[x]` and `f?.()`?](#why-are-there-dots-in-ox-and-f)'
  id: totrans-404
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.7.5.1 为什么 `o?.[x]` 和 `f?.()` 中有点？](#why-are-there-dots-in-ox-and-f)'
- en: 'The syntaxes of the following two optional operator are not ideal:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个可选操作符的语法并不理想：
- en: '[PRE79]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Alas, the less elegant syntax is necessary because distinguishing the ideal
    syntax (first expression) from the conditional operator (second expression) is
    too complicated:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，这种不太优雅的语法是必要的，因为区分理想语法（第一个表达式）和条件操作符（第二个表达式）太复杂了：
- en: '[PRE80]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[30.7.5.2 Why does `null?.prop` evaluate to `undefined` and not `null`?](#why-does-nullprop-evaluate-to-undefined-and-not-null)'
  id: totrans-409
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.7.5.2 为什么 `null?.prop` 评估为 `undefined` 而不是 `null`？](#why-does-nullprop-evaluate-to-undefined-and-not-null)'
- en: 'The operator `?.` is mainly about its right-hand side: Does property `.prop`
    exist? If not, stop early. Therefore, keeping information about its left-hand
    side is rarely useful. However, only having a single “early termination” value
    does simplify things.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符 `?.` 主要关注其右侧：属性 `.prop` 是否存在？如果不存在，则提前停止。因此，保留其左侧的信息很少是有用的。然而，只有一个“早期终止”值确实简化了事情。
- en: '[30.8 Prototype chains](#prototype-chains)'
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[30.8 原型链](#prototype-chains)'
- en: 'Prototypes are JavaScript’s only inheritance mechanism: Each object has a prototype
    that is either `null` or an object. In the latter case, the object inherits all
    of the prototype’s properties.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 原型是 JavaScript 的唯一继承机制：每个对象都有一个原型，该原型要么是 `null`，要么是一个对象。在后一种情况下，对象继承原型上的所有属性。
- en: 'In an object literal, we can set the prototype via the special property `__proto__`:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象字面量中，我们可以通过特殊属性 `__proto__` 设置原型：
- en: '[PRE81]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Given that a prototype object can have a prototype itself, we get a chain of
    objects – the so-called *prototype chain*. Inheritance gives us the impression
    that we are dealing with single objects, but we are actually dealing with chains
    of objects.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 由于原型对象本身可以有原型，我们得到一个对象链——所谓的*原型链*。继承让我们有单对象的印象，但实际上我们处理的是对象链。
- en: '[Figure 30.2](#fig:oo_proto_chain) shows what the prototype chain of `obj`
    looks like.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 30.2](#fig:oo_proto_chain) 展示了 `obj` 的原型链看起来像什么。'
- en: '![](../Images/3f6a70b31e906acd64d926d104282b8f.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3f6a70b31e906acd64d926d104282b8f.png)'
- en: 'Figure 30.2: `obj` starts a chain of objects that continues with `proto` and
    other objects.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 图 30.2：`obj` 开始一个对象链，该链继续与 `proto` 和其他对象相连。
- en: Non-inherited properties are called *own properties*. `obj` has one own property,
    `.objProp`.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 非继承属性被称为*自身属性*。`obj`有一个自身属性，`.objProp`。
- en: '[30.8.1 JavaScript’s operations: all properties vs. own properties](#javascripts-operations-all-properties-vs-own-properties)'
  id: totrans-420
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.8.1 JavaScript的操作：所有属性与自身属性](#javascripts-operations-all-properties-vs-own-properties)'
- en: 'Some operations consider all properties (own and inherited) – for example,
    getting properties:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 一些操作考虑所有属性（自身和继承的）——例如，获取属性：
- en: '[PRE82]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Other operations only consider own properties – for example, `Object.keys()`:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 其他操作仅考虑自身属性——例如，`Object.keys()`：
- en: '[PRE83]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Read on for another operation that also only considers own properties: setting
    properties.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 继续阅读，了解另一个仅考虑自身属性的运算：设置属性。
- en: '[30.8.2 Pitfall: only the first member of a prototype chain is mutated](#pitfall-only-the-first-member-of-a-prototype-chain-is-mutated)'
  id: totrans-426
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.8.2 漏洞：原型链的第一个成员是唯一被修改的](#pitfall-only-the-first-member-of-a-prototype-chain-is-mutated)'
- en: 'Given an object `obj` with a chain of prototype objects, it makes sense that
    setting an own property of `obj` only changes `obj`. However, setting an inherited
    property via `obj` also only changes `obj`. It creates a new own property in `obj`
    that overrides the inherited property. Let’s explore how that works with the following
    object:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个具有原型对象链的对象`obj`，设置`obj`的自身属性只会改变`obj`是有意义的。然而，通过`obj`设置继承属性也只会改变`obj`。它在`obj`中创建了一个新的自身属性，覆盖了继承属性。让我们通过以下对象来探索它是如何工作的：
- en: '[PRE84]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In the next code snippet, we set the inherited property `obj.protoProp` (line
    A). That “changes” it by creating an own property: When reading `obj.protoProp`,
    the own property is found first and its value *overrides* the value of the inherited
    property.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码片段中，我们设置了继承属性`obj.protoProp`（行A）。通过创建一个自身属性来“改变”它：当读取`obj.protoProp`时，首先找到自身属性，其值*覆盖*了继承属性的值。
- en: '[PRE85]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The prototype chain of `obj` is depicted in [figure 30.3](#fig:oo_overriding).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj`的原型链在[图30.3](#fig:oo_overriding)中展示。'
- en: '![](../Images/a36ba2c417a363309e1b3616c9d7810b.png)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a36ba2c417a363309e1b3616c9d7810b.png)'
- en: 'Figure 30.3: The own property `.protoProp` of `obj` overrides the property
    inherited from `proto`.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 图30.3：`obj`的自身属性`.protoProp`覆盖了从`proto`继承的属性。
- en: '[30.8.3 Tips for working with prototypes (advanced)](#tips-for-working-with-prototypes-advanced)'
  id: totrans-434
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.8.3 使用原型的技巧（高级）](#tips-for-working-with-prototypes-advanced)'
- en: '[30.8.3.1 Getting and setting prototypes](#get-set-prototype)'
  id: totrans-435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.8.3.1 获取和设置原型](#get-set-prototype)'
- en: 'Recommendations for the property key `__proto__`:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 关于属性键`__proto__`的建议：
- en: 'Don’t use the accessor `Object.prototype.__proto__` that all instances of `Object`
    have:'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用所有`Object`实例都具有的访问器`Object.prototype.__proto__`：
- en: It can’t be used with all objects – e.g., objects that are not instances of
    `Object` don’t have it.
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能与所有对象一起使用——例如，不是`Object`实例的对象没有它。
- en: It is deprecated in the ECMAScript specification.
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在ECMAScript规范中已被弃用。
- en: For more information on this feature see [“`Object.prototype.__proto__` (accessor)
    ^(ES6)” (§31.9.7)](ch_classes.html#Object.prototype.__proto__).
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关此功能的更多信息，请参阅[“`Object.prototype.__proto__` (访问器) (§31.9.7)”](ch_classes.html#Object.prototype.__proto__).
- en: 'Using the property key `__proto__` in an object literal to specify a prototype
    is different: It’s a feature that is particular to object literals that just happens
    to have the same name as the deprecated accessor.'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象字面量中使用属性键`__proto__`来指定原型是不同的：这是一个仅适用于对象字面量的特性，碰巧与已弃用的访问器有相同的名称。
- en: 'The recommended ways of getting and setting prototypes are:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 获取和设置原型的推荐方法如下：
- en: 'Getting the prototype of an object:'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取对象的原型：
- en: '[PRE86]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The best time to set the prototype of an object is when we are creating it.
    We can do so via `__proto__` in an object literal or via:'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置对象原型的最佳时机是在创建对象时。我们可以通过对象字面量中的`__proto__`或以下方式来实现：
- en: '[PRE87]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: If we have to, we can use `Object.setPrototypeOf()` to change the prototype
    of an existing object. But that may affect the performance of that object negatively.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果必须，我们可以使用`Object.setPrototypeOf()`来更改现有对象的原型。但这可能会对该对象的表现产生负面影响。
- en: 'This is how these features are used:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这些功能的使用方式：
- en: '[PRE88]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[30.8.3.2 Checking if an object is in the prototype chain of another object](#check-if-object-in-prototype-chain)'
  id: totrans-450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.8.3.2 检查一个对象是否在另一个对象的原型链中](#check-if-object-in-prototype-chain)'
- en: 'So far, “`proto` is a prototype of `obj`” always meant “`proto` is a *direct*
    prototype of `obj`”. But it can also be used more loosely and mean that `proto`
    is in the prototype chain of `obj`. That looser relationship can be checked via
    `.isPrototypeOf()`:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，“`proto` 是 `obj` 的原型”总是意味着“`proto` 是 `obj` 的 *直接* 原型”。但它也可以更宽松地使用，表示 `proto`
    是 `obj` 的原型链中的一员。这种更宽松的关系可以通过 `.isPrototypeOf()` 来检查：
- en: 'For example:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE89]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: For more information on this method see [“`Object.prototype.isPrototypeOf()`
    ^(ES3)” (§31.9.5)](ch_classes.html#Object.prototype.isPrototypeOf).
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于此方法的信息，请参阅 [“`Object.prototype.isPrototypeOf()` (ES3)” (§31.9.5)](ch_classes.html#Object.prototype.isPrototypeOf)。
- en: '[30.8.4 `Object.hasOwn()`: Is a given property own (non-inherited)? ^(ES2022)](#Object.hasOwn)'
  id: totrans-455
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.8.4 `Object.hasOwn()`: 给定属性是自身的（非继承的）？^(ES2022)](#Object.hasOwn)'
- en: The `in` operator (line A) checks if an object has a given property. In contrast,
    `Object.hasOwn()` (lines B and C) checks if a property is own.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`in` 操作符（行 A）检查对象是否具有给定的属性。相比之下，`Object.hasOwn()`（行 B 和 C）检查属性是否是自身的。'
- en: '[PRE90]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Alternative
    before ES2022: `.hasOwnProperty()`**'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“提示”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **ES2022 之前的替代方案：`.hasOwnProperty()`**'
- en: 'Before ES2022, we can use another feature: [“`Object.prototype.hasOwnProperty()`
    ^(ES3)” (§31.9.8)](ch_classes.html#Object.prototype.hasOwnProperty). This feature
    has pitfalls, but the referenced section explains how to work around them.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES2022 之前，我们可以使用另一个特性：[“`Object.prototype.hasOwnProperty()` (ES3)” (§31.9.8)](ch_classes.html#Object.prototype.hasOwnProperty)。这个特性有陷阱，但参考部分解释了如何绕过它们。
- en: '[30.8.5 Sharing data via prototypes](#sharing-data-via-prototypes)'
  id: totrans-460
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.8.5 通过原型共享数据](#sharing-data-via-prototypes)'
- en: 'Consider the following code:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE91]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: We have two objects that are very similar. Both have two properties whose names
    are `.firstName` and `.describe`. Additionally, method `.describe()` is the same.
    How can we avoid duplicating that method?
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个非常相似的对象。它们都有两个属性，属性名为 `.firstName` 和 `.describe`。此外，方法 `.describe()` 是相同的。我们如何避免重复该方法？
- en: 'We can move it to an object `PersonProto` and make that object a prototype
    of both `jane` and `tarzan`:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其移动到对象 `PersonProto` 中，并使该对象成为 `jane` 和 `tarzan` 的原型：
- en: '[PRE92]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The name of the prototype reflects that both `jane` and `tarzan` are persons.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 原型的名称反映了 `jane` 和 `tarzan` 都是人的事实。
- en: '![](../Images/54ca73b37654dc412734fbf20bbd28dd.png)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/54ca73b37654dc412734fbf20bbd28dd.png)'
- en: 'Figure 30.4: Objects `jane` and `tarzan` share method `.describe()`, via their
    common prototype `PersonProto`.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 图 30.4：对象 `jane` 和 `tarzan` 通过它们的公共原型 `PersonProto` 共享方法 `.describe()`。
- en: '[Figure 30.4](#fig:oo_person_shared) illustrates how the three objects are
    connected: The objects at the bottom now contain the properties that are specific
    to `jane` and `tarzan`. The object at the top contains the properties that are
    shared between them.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 30.4](#fig:oo_person_shared) 展示了三个对象是如何连接的：底部的对象现在包含 `jane` 和 `tarzan` 特有的属性。顶部的对象包含它们之间共享的属性。'
- en: When we make the method call `jane.describe()`, `this` points to the receiver
    of that method call, `jane` (in the bottom-left corner of the diagram). That’s
    why the method still works. `tarzan.describe()` works similarly.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用方法 `jane.describe()` 时，`this` 指向该方法调用的接收者，即 `jane`（在图的下左角）。这就是为什么该方法仍然有效。`tarzan.describe()`
    的工作方式类似。
- en: '[PRE93]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Looking ahead to the next chapter on classes – this is how classes are organized
    internally:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 预览下一章关于类的章节——这是类是如何在内部组织的：
- en: All instances share a common prototype with methods.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有实例都共享一个具有方法的公共原型。
- en: Instance-specific data is stored in own properties in each instance.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例特定的数据存储在每个实例的自身属性中。
- en: '[“The internals of classes” (§31.3)](ch_classes.html#internals-of-classes)
    explains this in more detail.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '[“类的内部结构” (§31.3)](ch_classes.html#internals-of-classes) 更详细地解释了这一点。'
- en: '[30.9 Dictionary objects (advanced)](#dictionary-objects)'
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[30.9 字典对象（高级）](#dictionary-objects)'
- en: 'Objects work best as fixed-layout objects. But before ES6, JavaScript did not
    have a data structure for dictionaries (ES6 brought [Maps](ch_maps.html#ch_maps)).
    Therefore, objects had to be used as dictionaries, which imposed a signficant
    constraint: Dictionary keys had to be strings (symbols were also introduced with
    ES6).'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 对象作为固定布局对象工作得最好。但在 ES6 之前，JavaScript 没有字典数据结构（ES6 带来了 [Maps](ch_maps.html#ch_maps)）。因此，对象必须用作字典，这强加了一个显著的约束：字典键必须是字符串（ES6
    也引入了符号）。
- en: 'We first look at features of objects that are related to dictionaries but also
    useful for fixed-layout objects. This section concludes with tips for actually
    using objects as dictionaries. (Spoiler: If possible, it’s better to use Maps.)'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看看与字典相关但同时也适用于固定布局对象的对象特性。本节以实际使用对象作为字典的技巧结束。（剧透：如果可能的话，最好使用 Maps。）
- en: '[30.9.1 Quoted keys in object literals](#object-literals-quoted-keys)'
  id: totrans-479
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.9.1 对象字面量中的引号键](#object-literals-quoted-keys)'
- en: 'So far, we have always used fixed-layout objects. Property keys were fixed
    tokens that had to be valid identifiers and internally became strings:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用固定布局对象。属性键是固定的标记，必须是有效的标识符并在内部成为字符串：
- en: '[PRE94]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'As a next step, we’ll go beyond this limitation for property keys: In this
    subsection, we’ll use arbitrary fixed strings as keys. In the next subsection,
    we’ll dynamically compute keys.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，我们将超越属性键的限制：在本子节中，我们将使用任意的固定字符串作为键。在下一下子节中，我们将动态计算键。
- en: Two syntaxes enable us to use arbitrary strings as property keys.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 两种语法使我们能够使用任意字符串作为属性键。
- en: 'First, when creating property keys via object literals, we can quote property
    keys (with single or double quotes):'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在通过对象字面量创建属性键时，我们可以引用属性键（使用单引号或双引号）：
- en: '[PRE95]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Second, when getting or setting properties, we can use square brackets with
    strings inside them:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在获取或设置属性时，我们可以使用包含字符串的方括号：
- en: '[PRE96]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We can also use these syntaxes for methods:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用这些语法来定义方法：
- en: '[PRE97]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[30.9.2 Computed keys in object literals](#object-literals-computed-keys)'
  id: totrans-490
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.9.2 对象字面量中的计算键](#object-literals-computed-keys)'
- en: In the previous subsection, property keys were specified via fixed strings inside
    object literals. In this section we learn how to dynamically compute property
    keys. That enables us to use either arbitrary strings or symbols.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的子节中，属性键是通过对象字面量中的固定字符串指定的。在本节中，我们将学习如何动态计算属性键。这使我们能够使用任意字符串或符号。
- en: 'The syntax of dynamically computed property keys in object literals is inspired
    by dynamically accessing properties. That is, we can use square brackets to wrap
    expressions:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量中动态计算属性键的语法受到了动态访问属性的影响。也就是说，我们可以使用方括号来包裹表达式：
- en: '[PRE98]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The main use case for computed keys is having symbols as property keys (line
    A).
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 计算键的主要用途是作为属性键的符号（行A）。
- en: 'Note that the square brackets operator for getting and setting properties works
    with arbitrary expressions:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，用于获取和设置属性的方括号运算符与任意表达式一起工作：
- en: '[PRE99]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Methods can have computed property keys, too:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 方法也可以有计算属性键：
- en: '[PRE100]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: For the remainder of this chapter, we’ll mostly use fixed property keys again
    (because they are syntactically more convenient). But all features are also available
    for arbitrary strings and symbols.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将主要再次使用固定属性键（因为它们在语法上更方便）。但所有功能也适用于任意字符串和符号。
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Non-destructively updating a property via spreading (computed key)**'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '![“练习”图标](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：通过扩展（计算键）非破坏性地更新属性**'
- en: '`exercises/objects/update_property_test.mjs`'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/objects/update_property_test.mjs`'
- en: '[30.9.3 The `in` operator: is there a property with a given key?](#in-operator)'
  id: totrans-502
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.9.3 `in`运算符：是否存在具有给定键的属性？](#in-operator)'
- en: 'The `in` operator checks if an object has a property with a given key:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`运算符检查对象是否具有给定键的属性：'
- en: '[PRE101]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[30.9.3.1 Checking if a property exists via truthiness](#checking-if-a-property-exists-via-truthiness)'
  id: totrans-505
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.9.3.1 通过真值检查检查属性是否存在](#checking-if-a-property-exists-via-truthiness)'
- en: 'We can also use a truthiness check to determine if a property exists:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用真值检查来确定属性是否存在：
- en: '[PRE102]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The previous checks work because `obj.alpha` is truthy and because reading a
    missing property returns `undefined` (which is falsy).
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的检查之所以有效，是因为`obj.alpha`是真值，并且读取缺失的属性返回`undefined`（这是假值）。
- en: 'There is, however, one important caveat: truthiness checks fail if the property
    exists, but has a falsy value (`undefined`, `null`, `false`, `0`, `""`, etc.):'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个重要的注意事项：如果属性存在但具有假值（`undefined`、`null`、`false`、`0`、`""`等），则真值检查会失败：
- en: '[PRE103]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[30.9.4 Deleting properties](#deleting-properties)'
  id: totrans-511
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.9.4 删除属性](#deleting-properties)'
- en: 'We can delete properties via the `delete` operator:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`delete`运算符删除属性：
- en: '[PRE104]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[30.9.5 Enumerability](#enumerability)'
  id: totrans-514
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.9.5 可枚举性](#enumerability)'
- en: '*Enumerability* is an [*attribute*](#property-attributes-property-descriptors)
    of a property. Non-enumerable properties are ignored by some operations – for
    example, by `Object.keys()` and when spreading properties. By default, most properties
    are enumerable. The next example shows how to change that and how it affects spreading.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '*可枚举性* 是属性的一个[*属性*](#property-attributes-property-descriptors)。非可枚举属性在某些操作中被忽略——例如，在
    `Object.keys()` 和属性展开时。默认情况下，大多数属性都是可枚举的。下一个示例将展示如何更改这一点以及它如何影响展开。'
- en: '[PRE105]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '`Object.defineProperties()` is explained [later in this chapter](#property-attributes-property-descriptors).
    The next subsection shows how these operations are affected by enumerability:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.defineProperties()` 在本章的[后面解释](#property-attributes-property-descriptors)。下一小节将展示这些操作如何受可枚举性的影响：'
- en: '[30.9.6 Listing property keys via `Object.keys()` etc.](#listing-property-keys)'
  id: totrans-518
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.9.6 列出属性键通过 `Object.keys()` 等.](#listing-property-keys)'
- en: '|  | enumerable | non-e. | string | symbol |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '|  | 可枚举 | 不可枚举 | 字符串 | 符号 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `Object.keys()` | ✔ |  | ✔ |  |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
  zh: '| `Object.keys()` | ✔ |  | ✔ |  |'
- en: '| `Object.getOwnPropertyNames()` | ✔ | ✔ | ✔ |  |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
  zh: '| `Object.getOwnPropertyNames()` | ✔ | ✔ | ✔ |  |'
- en: '| `Object.getOwnPropertySymbols()` | ✔ | ✔ |  | ✔ |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
  zh: '| `Object.getOwnPropertySymbols()` | ✔ | ✔ |  | ✔ |'
- en: '| `Reflect.ownKeys()` | ✔ | ✔ | ✔ | ✔ |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
  zh: '| `Reflect.ownKeys()` | ✔ | ✔ | ✔ | ✔ |'
- en: 'Table 30.1: Standard library methods for listing *own* (non-inherited) property
    keys. All of them return Arrays with strings and/or symbols.'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 表30.1：列出*自有*（非继承）属性键的标准库方法。所有这些方法都返回包含字符串和/或符号的数组。
- en: 'Each of the methods in [table 30.1](#tbl:listing-property-keys) returns an
    Array with the own property keys of the parameter. In the names of the methods,
    we can see that the following distinction is made:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '[表30.1](#tbl:listing-property-keys) 中的每个方法都返回一个包含参数自有属性键的数组。在方法名称中，我们可以看到以下区分：'
- en: A *property key* can be either a string or a symbol. (`Object.keys()` is older
    and does not yet follow this convention.)
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*属性键* 可以是字符串或符号。（`Object.keys()` 较旧，尚未遵循此约定。）'
- en: A *property name* is a property key whose value is a string.
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*属性名* 是一个属性键，其值是一个字符串。'
- en: A *property symbol* is a property key whose value is a symbol.
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*属性符号* 是一个属性键，其值是一个符号。'
- en: 'To demonstrate the four operations, we revisit the example from the previous
    subsection:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示四种运算，我们回顾前一小节中的示例：
- en: '[PRE106]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[30.9.7 Listing property values via `Object.values()`](#Object.values)'
  id: totrans-532
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.9.7 列出属性值通过 `Object.values()`](#Object.values)'
- en: '`Object.values()` lists the values of all own enumerable string-keyed properties
    of an object:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.values()` 列出对象所有自有可枚举字符串键属性的值：'
- en: '[PRE107]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[30.9.8 Listing property entries via `Object.entries()` ^(ES2017)](#Object.entries)'
  id: totrans-535
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.9.8 列出属性条目通过 `Object.entries()` (ES2017)](#Object.entries)'
- en: '`Object.entries(obj)` returns an Array with one key-value pair for each of
    its properties:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.entries(obj)` 返回一个数组，其中包含每个属性的键值对：'
- en: Each pair is encoded as a two-element Array.
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每对都编码为一个两元素数组。
- en: Only own enumerable properties with string keys are included.
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只包括具有字符串键的自有可枚举属性。
- en: '[PRE108]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[30.9.8.1 A simple implementation of `Object.entries()`](#a-simple-implementation-of-objectentries)'
  id: totrans-540
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.9.8.1 `Object.entries()` 的简单实现](#a-simple-implementation-of-objectentries)'
- en: 'The following function is a simplified version of `Object.entries()`:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数是 `Object.entries()` 的简化版本：
- en: '[PRE109]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    `Object.entries()`**'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“练习”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：`Object.entries()`**'
- en: '`exercises/objects/find_key_test.mjs`'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/objects/find_key_test.mjs`'
- en: '[30.9.9 Properties are listed deterministically](#order-of-properties)'
  id: totrans-545
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.9.9 属性按确定性列出](#order-of-properties)'
- en: 'Own (non-inherited) properties of objects are always listed in the following
    order:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的自有（非继承）属性始终按以下顺序列出：
- en: 'Properties with string keys that contain integer indices:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含整数索引的字符串键属性：
- en: In ascending numeric order
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按升序数值顺序
- en: 'Remaining properties with string keys:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩余的字符串键属性：
- en: In the order in which they were added
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按照它们被添加的顺序
- en: 'Properties with symbol keys:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有符号键的属性：
- en: In the order in which they were added
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按照它们被添加的顺序
- en: 'The following example demonstrates that property keys are sorted according
    to these rules:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了属性键是按照这些规则排序的：
- en: '[PRE110]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **The order
    of properties**'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“详情”](../Images/38ba63de820aae6f94a019538ae0f222.png) **属性的顺序**'
- en: '[The ECMAScript specification](https://tc39.es/ecma262/#sec-ordinaryownpropertykeys)
    describes in more detail how properties are ordered.'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '[ECMAScript 规范](https://tc39.es/ecma262/#sec-ordinaryownpropertykeys)更详细地描述了属性是如何排序的。'
- en: '[30.9.9.1 Why is the order of properties deterministic?](#why-is-the-order-of-properties-deterministic)'
  id: totrans-557
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.9.9.1 属性顺序为什么是确定的？](#why-is-the-order-of-properties-deterministic)'
- en: As a data structure, objects are mainly unordered. Therefore, we wouldn’t expect,
    e.g., `Object.keys()` to always return property keys in the same order. However,
    JavaScript does define a deterministic order for properties because that helps
    with testing and other use cases.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种数据结构，对象主要是无序的。因此，我们不会期望，例如，`Object.keys()` 总是按相同的顺序返回属性键。然而，JavaScript 确实为属性定义了一个确定性的顺序，因为这有助于测试和其他用例。
- en: '[30.9.10 Assembling objects via `Object.fromEntries()` ^(ES2019)](#Object.fromEntries)'
  id: totrans-559
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.9.10 通过 `Object.fromEntries()` 组装对象（ES2019）](#Object.fromEntries)'
- en: 'Given an iterable over [key, value] pairs, `Object.fromEntries()` creates an
    object:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个 [键，值] 对的可迭代对象，`Object.fromEntries()` 创建一个对象：
- en: '[PRE111]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '`Object.fromEntries()` does the opposite of [`Object.entries()`](#Object.entries).
    However, while `Object.entries()` ignores symbol-keyed properties, `Object.fromEntries()`
    doesn’t (see previous example).'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.fromEntries()` 与 `Object.entries()` 的作用相反。然而，虽然 `Object.entries()`
    忽略了以符号为键的属性，但 `Object.fromEntries()` 不忽略（参见前一个示例）。'
- en: To demonstrate both, we’ll use them to implement two tool functions from the
    library [Underscore](https://underscorejs.org) in the next subsubsections.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这两个，我们将使用它们来实现下一个子子节中库 [Underscore](https://underscorejs.org) 的两个工具函数。
- en: '[30.9.10.1 Example: `pick()`](#underscore-pick)'
  id: totrans-564
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.9.10.1 示例：`pick()`](#underscore-pick)'
- en: '[The Underscore function `pick()`](https://underscorejs.org/#pick) has the
    following signature:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '[Underscore 函数 `pick()`](https://underscorejs.org/#pick) 的签名如下：'
- en: '[PRE112]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'It returns a copy of `object` that has only those properties whose keys are
    mentioned in the trailing arguments:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个 `object` 的副本，其中只包含在尾随参数中提到的键的属性：
- en: '[PRE113]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'We can implement `pick()` as follows:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样实现 `pick()`：
- en: '[PRE114]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[30.9.10.2 Example: `invert()`](#underscore-invert)'
  id: totrans-571
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.9.10.2 示例：`invert()`](#underscore-invert)'
- en: '[The Underscore function `invert()`](https://underscorejs.org/#invert) has
    the following signature:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '[Underscore 函数 `invert()`](https://underscorejs.org/#invert) 的签名如下：'
- en: '[PRE115]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'It returns a copy of `object` where the keys and values of all properties are
    swapped:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个 `object` 的副本，其中所有属性的键和值都被交换：
- en: '[PRE116]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'We can implement `invert()` like this:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样实现 `invert()`：
- en: '[PRE117]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[30.9.10.3 A simple implementation of `Object.fromEntries()`](#a-simple-implementation-of-objectfromentries)'
  id: totrans-578
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.9.10.3 `Object.fromEntries()` 的简单实现](#a-simple-implementation-of-objectfromentries)'
- en: 'The following function is a simplified version of `Object.fromEntries()`:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数是 `Object.fromEntries()` 的简化版本：
- en: '[PRE118]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Using `Object.entries()` and `Object.fromEntries()`**'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“练习”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：使用 `Object.entries()`
    和 `Object.fromEntries()`**'
- en: '`exercises/objects/omit_properties_test.mjs`'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/objects/omit_properties_test.mjs`'
- en: '[30.9.11 Objects with `null` prototypes make good dictionaries and lookup tables](#null-prototype-objects)'
  id: totrans-583
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[具有 `null` 原型的对象是好的字典和查找表](#null-prototype-objects)'
- en: If we use plain objects (created via object literals) as dictionaries, we have
    to look out for two pitfalls.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将普通对象（通过对象字面量创建）用作字典，我们必须注意两个陷阱。
- en: '[30.9.11.1 Pitfall 1: getting inherited properties](#pitfall-1-getting-inherited-properties)'
  id: totrans-585
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.9.11.1 陷阱 1：获取继承属性](#pitfall-1-getting-inherited-properties)'
- en: 'The following dictionary object should be empty. However, we get a value (and
    not `undefined`) if we read an inherited property:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 以下字典对象应该是空的。然而，如果我们读取继承属性，我们会得到一个值（而不是 `undefined`）：
- en: '[PRE119]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '`dict` is an instance of `Object` and inherits `.toString()` from `Object.prototype`.'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict` 是 `Object` 的一个实例，并从 `Object.prototype` 继承了 `.toString()`。'
- en: '[30.9.11.2 Pitfall 2: checking if a property exists](#pitfall-2-checking-if-a-property-exists)'
  id: totrans-589
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.9.11.2 陷阱 2：检查属性是否存在](#pitfall-2-checking-if-a-property-exists)'
- en: 'If we use the `in` operator to check if a property exists, we again detect
    inherited properties:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `in` 操作符来检查属性是否存在，我们再次检测到继承属性：
- en: '[PRE120]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'As an aside: `Object.hasOwn()` does not have this pitfall. As its name indicates,
    it only considers *own* (non-inherited) properties:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句：`Object.hasOwn()` 没有这个陷阱。正如其名称所示，它只考虑 *自己的*（非继承的）属性：
- en: '[PRE121]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[30.9.11.3 Pitfall 3: property key `''__proto__''`](#pitfall-3-property-key-proto)'
  id: totrans-594
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.9.11.3 陷阱 3：属性键 `''__proto__''`](#pitfall-3-property-key-proto)'
- en: 'We can’t use the property key `''__proto__''` because it has special powers
    (it sets the prototype of the object):'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用属性键 `'__proto__'`，因为它具有特殊功能（它设置对象的原型）：
- en: '[PRE122]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[30.9.11.4 Objects with `null` prototypes as dictionaries](#dictionary-objects-with-null-prototypes)'
  id: totrans-597
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.9.11.4 作为字典的对象具有 `null` 原型](#dictionary-objects-with-null-prototypes)'
- en: 'Maps are usually the best choice when it comes to dictionaries: They have a
    convenient method-based API and support keys beyond strings and symbols.'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到字典时，映射通常是最佳选择：它们有一个方便的方法式 API，并支持字符串和符号之外的键。
- en: 'However, objects with `null` prototypes are also decent dictionaries and don’t
    have the pitfalls we just encountered:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，具有 `null` 原型的对象也是相当好的字典，并且没有我们刚才遇到的陷阱：
- en: '[PRE123]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'We avoided the pitfalls:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 我们避免了陷阱：
- en: An object without a prototype does not inherit anything. Therefore, it is always
    safe to get properties and to use the `in` operator.
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有原型的对象不继承任何内容。因此，获取属性和使用 `in` 操作符总是安全的。
- en: The accessor `Object.prototype.__proto__` is switched off because `Object.prototype`
    is not in the prototype chain of `dict`.
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.prototype.__proto__` 访问器被关闭，因为 `Object.prototype` 不是 `dict` 的原型链中的一部分。'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercises:
    Objects as dictionaries**'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '![“练习”图标](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：对象作为字典**'
- en: 'A `null` prototype object as a dictionary: `exercises/objects/null-proto-obj-dict_test.mjs`'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以字典形式作为 `null` 原型对象：`exercises/objects/null-proto-obj-dict_test.mjs`
- en: 'A plain object as a dictionary: `exercises/objects/plain-obj-dict_test.mjs`'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以字典形式作为普通对象：`exercises/objects/plain-obj-dict_test.mjs`
- en: '[30.9.11.5 Objects with `null` prototypes as fixed lookup tables](#lookup-tables-with-null-prototypes)'
  id: totrans-607
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.9.11.5 作为固定查找表使用的 `null` 原型对象](#lookup-tables-with-null-prototypes)'
- en: 'Null prototypes are also useful for objects that we use as fixed lookup tables:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '`null` 原型对于用作固定查找表的对象也很有用：'
- en: '[PRE124]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[30.9.11.6 `null` prototypes in the standard library](#null-prototypes-in-standard-library)'
  id: totrans-610
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[30.9.11.6 标准库中的 `null` 原型](#null-prototypes-in-standard-library)'
- en: 'Because they are good dictionaries, the standard library also uses objects
    with `null` prototype in some locations – e.g.:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它们是好的字典，标准库也在某些位置使用具有 `null` 原型的对象 – 例如：
- en: 'The value of `import.meta`:'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import.meta` 的值：'
- en: '[PRE125]'
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The result of `Object.groupBy()`:'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.groupBy()` 的结果：'
- en: '[PRE126]'
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'When matching regular expressions – the value of `matchObj.groups`:'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当匹配正则表达式时 – `matchObj.groups` 的值：
- en: '[PRE127]'
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[30.10 Property attributes and property descriptors ^(ES5) (advanced)](#property-attributes-property-descriptors)'
  id: totrans-618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[30.10 属性属性和属性描述符 (ES5) (高级)](#property-attributes-property-descriptors)'
- en: 'Just as objects are composed of properties, properties are composed of *attributes*.
    There are two kinds of properties and they are characterized by their attributes:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 正如对象由属性组成一样，属性由 *属性* 组成。属性有两种类型，它们通过其属性来区分：
- en: A *data property* stores data. Its attribute `value` holds any JavaScript value.
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据属性*存储数据。其属性 `value` 保存任何 JavaScript 值。'
- en: Methods are data properties whose values are functions.
  id: totrans-621
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法是数据属性，其值是函数。
- en: An *accessor property* consists of a getter function and/or a setter function.
    The former is stored in the attribute `get`, the latter in the attribute `set`.
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*访问器属性*由一个获取器函数和/或一个设置器函数组成。前者存储在属性 `get` 中，后者存储在属性 `set` 中。'
- en: Additionally, there are attributes that both kinds of properties have. The following
    table lists all attributes and their default values.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些属性两种类型的属性都有。以下表格列出了所有属性及其默认值。
- en: '| Kind of property | Name and type of attribute | Default value |'
  id: totrans-624
  prefs: []
  type: TYPE_TB
  zh: '| 属性类型 | 属性名称和类型 | 默认值 |'
- en: '| --- | --- | --- |'
  id: totrans-625
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| All properties | `configurable: boolean` | `false` |'
  id: totrans-626
  prefs: []
  type: TYPE_TB
  zh: '| 所有属性 | `configurable: boolean` | `false` |'
- en: '|  | `enumerable: boolean` | `false` |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
  zh: '|  | `enumerable: boolean` | `false` |'
- en: '| Data property | `value: any` | `undefined` |'
  id: totrans-628
  prefs: []
  type: TYPE_TB
  zh: '| 数据属性 | `value: any` | `undefined` |'
- en: '|  | `writable: boolean` | `false` |'
  id: totrans-629
  prefs: []
  type: TYPE_TB
  zh: '|  | `writable: boolean` | `false` |'
- en: '| Accessor property | `get: (this: any) => any` | `undefined` |'
  id: totrans-630
  prefs: []
  type: TYPE_TB
  zh: '| 访问器属性 | `get: (this: any) => any` | `undefined` |'
- en: '|  | `set: (this: any, v: any) => void` | `undefined` |'
  id: totrans-631
  prefs: []
  type: TYPE_TB
  zh: '|  | `set: (this: any, v: any) => void` | `undefined` |'
- en: 'We have already encountered the attributes `value`, `get`, and `set`. The other
    attributes work as follows:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经遇到了属性 `value`、`get` 和 `set`。其他属性的工作方式如下：
- en: '`writable` determines if the value of a data property can be changed.'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`writable` 决定了数据属性值是否可以被更改。'
- en: '`configurable` determines if the attributes of a property can be changed. If
    it is `false`, then:'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configurable` 决定了属性的属性是否可以被更改。如果它是 `false`，那么：'
- en: We cannot delete the property.
  id: totrans-635
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能删除该属性。
- en: We cannot change a property from a data property to an accessor property or
    vice versa.
  id: totrans-636
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能将属性从数据属性更改为访问器属性，反之亦然。
- en: We cannot change any attribute other than `value`.
  id: totrans-637
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能更改除 `value` 之外的任何属性。
- en: 'However, one more attribute change is allowed: We can change `writable` from
    `true` to `false`. The rationale behind this anomaly is [historical](https://stackoverflow.com/questions/9829817/why-can-i-set-enumerability-and-writability-of-unconfigurable-property-descrip/9843191#9843191):
    Property `.length` of Arrays has always been writable and non-configurable. Allowing
    its `writable` attribute to be changed enables us to freeze Arrays.'
  id: totrans-638
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，还有一个属性更改是允许的：我们可以将 `writable` 从 `true` 更改为 `false`。这种异常背后的原因是[历史原因](https://stackoverflow.com/questions/9829817/why-can-i-set-enumerability-and-writability-of-unconfigurable-property-descrip/9843191#9843191)：数组的
    `.length` 属性始终是可写的和非可配置的。允许其 `writable` 属性被更改使我们能够冻结数组。
- en: '`enumerable` influences some operations (such as `Object.keys()`). If it is
    `false`, then those operations ignore the property. Enumerability is covered in
    greater detail [earlier in this chapter](#enumerability).'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enumerable` 影响某些操作（例如 `Object.keys()`）。如果它是 `false`，则这些操作会忽略该属性。可枚举性在本章的[早期部分](#enumerability)有更详细的介绍。'
- en: 'When we are using one of the operations for handling property attributes, attributes
    are specified via *property descriptors*: objects where each property represents
    one attribute. For example, this is how we read the attributes of a property `obj.myProp`:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用处理属性属性的操作之一时，属性通过 *属性描述符* 指定：每个属性代表一个属性的对象。例如，这就是我们读取属性 `obj.myProp` 的属性的方式：
- en: '[PRE128]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'And this is how we change the attributes of `obj.myProp`:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是改变 `obj.myProp` 属性的属性的方式：
- en: '[PRE129]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Lastly, let’s see what methods and getters look like:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看方法和获取器是什么样子：
- en: '[PRE130]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '![Icon “external”](../Images/38e6ff55e8d602659f3cdb8893e63f62.png) **Further
    reading**'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“外部”](../Images/38e6ff55e8d602659f3cdb8893e63f62.png) **进一步阅读**'
- en: For more information on property attributes and property descriptors, see [*Deep
    JavaScript*](https://exploringjs.com/deep-js/ch_property-attributes-intro.html).
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 关于属性属性和属性描述符的更多信息，请参阅[*深度 JavaScript*](https://exploringjs.com/deep-js/ch_property-attributes-intro.html)。
- en: '[30.11 Protecting objects from being changed ^(ES5) (advanced)](#protecting-objects)'
  id: totrans-648
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[30.11 保护对象不被更改（ES5）(高级)](#protecting-objects)'
- en: 'JavaScript has three levels of protecting objects:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 有三个级别的对象保护：
- en: '*Preventing extensions* makes it impossible to add new properties to an object
    and to change its prototype. We can still delete and change properties, though.'
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*防止扩展* 使无法向对象添加新属性和更改其原型成为可能。尽管如此，我们仍然可以删除和更改属性。'
- en: 'Apply: `Object.preventExtensions(obj)`'
  id: totrans-651
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用：`Object.preventExtensions(obj)`
- en: 'Check: `Object.isExtensible(obj)`'
  id: totrans-652
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查：`Object.isExtensible(obj)`
- en: '*Sealing* prevents extensions and makes all properties *unconfigurable* (roughly:
    we can’t change how a property works anymore).'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*密封* 阻止扩展并使所有属性 *不可配置*（大致上：我们不能再更改属性的工作方式了）。'
- en: 'Apply: `Object.seal(obj)`'
  id: totrans-654
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用：`Object.seal(obj)`
- en: 'Check: `Object.isSealed(obj)`'
  id: totrans-655
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查：`Object.isSealed(obj)`
- en: '*Freezing* seals an object after making all of its properties non-writable.
    That is, the object is not extensible, all properties are read-only and there
    is no way to change that.'
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*冻结* 在使所有属性不可写后密封对象。也就是说，对象不可扩展，所有属性都是只读的，并且无法更改。'
- en: 'Apply: `Object.freeze(obj)`'
  id: totrans-657
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用：`Object.freeze(obj)`
- en: 'Check: `Object.isFrozen(obj)`'
  id: totrans-658
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查：`Object.isFrozen(obj)`
- en: '![Icon “warning”](../Images/5aa4bf88dc66ecb2bac6be4022a1fed4.png) **Caveat:
    Objects are only protected shallowly**'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“警告”](../Images/5aa4bf88dc66ecb2bac6be4022a1fed4.png) **注意事项：对象仅进行浅层保护**'
- en: All three of the aforementioned `Object.*` methods only affect the top level
    of an object, not objects nested inside it.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 所述的三个 `Object.*` 方法仅影响对象的顶层，不影响其内部嵌套的对象。
- en: 'This is what using `Object.freeze()` looks like:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用 `Object.freeze()` 的样子：
- en: '[PRE131]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Changing frozen properties only causes an exception in [strict mode](ch_syntax.html#strict-mode).
    In sloppy mode, it fails silently.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下更改冻结属性只会导致异常。[宽松模式](ch_syntax.html#strict-mode)中，它将静默失败。
- en: '![Icon “external”](../Images/38e6ff55e8d602659f3cdb8893e63f62.png) **Further
    reading**'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“外部”](../Images/38e6ff55e8d602659f3cdb8893e63f62.png) **进一步阅读**'
- en: For more information on freezing and other ways of locking down objects, see
    [*Deep JavaScript*](https://exploringjs.com/deep-js/ch_protecting-objects.html).
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 关于冻结和其他锁定对象的方法的更多信息，请参阅[*深度 JavaScript*](https://exploringjs.com/deep-js/ch_protecting-objects.html)。
- en: '[30.12 Quick reference: `Object`](#quickref-object-api)'
  id: totrans-666
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[30.12 快速参考：`Object`](#quickref-object-api)'
- en: '[30.12.1 `Object.*`: creating objects, handling prototypes](#object-creating-objects-handling-prototypes)'
  id: totrans-667
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.12.1 `Object.*`: 创建对象，处理原型](#object-creating-objects-handling-prototypes)'
- en: '`Object.create(proto, propDescObj?)` ES5'
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.create(proto, propDescObj?)` ES5'
- en: Returns a new object whose prototype is `proto`.
  id: totrans-669
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个新的对象，其原型是 `proto`。
- en: The optional `propDescObj` is an object with [property descriptors](#property-attributes-property-descriptors)
    that is used to define properties in the new object.
  id: totrans-670
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的`propDescObj`是一个包含[属性描述符](#property-attributes-property-descriptors)的对象，用于在新的对象中定义属性。
- en: '[PRE132]'
  id: totrans-671
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'In the following example, we define own properties via the second parameter:'
  id: totrans-672
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下示例中，我们通过第二个参数定义自身属性：
- en: '[PRE133]'
  id: totrans-673
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '`Object.getPrototypeOf(obj)` ES5'
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.getPrototypeOf(obj)` ES5'
- en: Return the prototype of `obj` – which is either an object or `null`.
  id: totrans-675
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回`obj`的原型——它可以是对象或`null`。
- en: '[PRE134]'
  id: totrans-676
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '`Object.setPrototypeOf(obj, proto)` ES6'
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.setPrototypeOf(obj, proto)` ES6'
- en: Sets the prototype of `obj` to `proto` (which must be `null` or an object) and
    returns the former.
  id: totrans-678
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将`obj`的原型设置为`proto`（必须是`null`或对象）并返回前者。
- en: '[PRE135]'
  id: totrans-679
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[30.12.2 `Object.*`: property attributes](#object-property-attributes)'
  id: totrans-680
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.12.2 `Object.*`: 属性属性](#object-property-attributes)'
- en: '`Object.defineProperty(obj, propKey, propDesc)` ES5'
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.defineProperty(obj, propKey, propDesc)` ES5'
- en: Defines one property in `obj`, as specified by the property key `propKey` and
    the [property descriptor](#property-attributes-property-descriptors) `propDesc`.
  id: totrans-682
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`obj`中的一个属性，由属性键`propKey`和[属性描述符](#property-attributes-property-descriptors)
    `propDesc`指定。
- en: Returns `obj`.
  id: totrans-683
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回`obj`。
- en: '[PRE136]'
  id: totrans-684
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '`Object.defineProperties(obj, propDescObj)` ES5'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.defineProperties(obj, propDescObj)` ES5'
- en: Defines properties in `obj`, as specified by the object `propDescObj` with [property
    descriptors](#property-attributes-property-descriptors).
  id: totrans-686
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`obj`中的属性，由包含[属性描述符](#property-attributes-property-descriptors)的对象`propDescObj`指定。
- en: Returns `obj`.
  id: totrans-687
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回`obj`。
- en: '[PRE137]'
  id: totrans-688
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '`Object.getOwnPropertyDescriptor(obj, propKey)` ES5'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.getOwnPropertyDescriptor(obj, propKey)` ES5'
- en: Returns a property descriptor for the own property of `obj` whose key is `propKey`.
    If no such property exists, it returns `undefined`.
  id: totrans-690
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回`obj`的自身属性的一个属性描述符，其键是`propKey`。如果不存在这样的属性，则返回`undefined`。
- en: 'More information on property descriptors: [“Property attributes and property
    descriptors ^(ES5) (advanced)” (§30.10)](#property-attributes-property-descriptors)'
  id: totrans-691
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于属性描述符的信息：[“属性属性和属性描述符^(ES5) (高级)” (§30.10)](#property-attributes-property-descriptors)
- en: '[PRE138]'
  id: totrans-692
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '`Object.getOwnPropertyDescriptors(obj)` ES2017'
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.getOwnPropertyDescriptors(obj)` ES2017'
- en: Returns an object with property descriptors, one for each own property of `obj`.
  id: totrans-694
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个包含属性描述符的对象，每个`obj`的自身属性都有一个。
- en: 'More information on property descriptors: [“Property attributes and property
    descriptors ^(ES5) (advanced)” (§30.10)](#property-attributes-property-descriptors)'
  id: totrans-695
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于属性描述符的信息：[“属性属性和属性描述符^(ES5) (高级)” (§30.10)](#property-attributes-property-descriptors)
- en: '[PRE139]'
  id: totrans-696
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[30.12.3 `Object.*`: property keys, values, entries](#object-property-keys-values-entries)'
  id: totrans-697
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.12.3 `Object.*`: 属性键、值、条目](#object-property-keys-values-entries)'
- en: '`Object.keys(obj)` ES5'
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.keys(obj)` ES5'
- en: Returns an Array with all own enumerable property keys that are strings.
  id: totrans-699
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回一个包含所有自身可枚举属性键（字符串键）的数组。
- en: '[PRE140]'
  id: totrans-700
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '`Object.getOwnPropertyNames(obj)` ES5'
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.getOwnPropertyNames(obj)` ES5'
- en: Returns an Array with all own property keys that are strings (enumerable and
    non-enumerable ones).
  id: totrans-702
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回一个包含所有自身属性键（可枚举和不可枚举的字符串键）的数组。
- en: '[PRE141]'
  id: totrans-703
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '`Object.getOwnPropertySymbols(obj)` ES6'
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.getOwnPropertySymbols(obj)` ES6'
- en: Returns an Array with all own property keys that are symbols (enumerable and
    non-enumerable ones).
  id: totrans-705
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回一个包含所有自身属性键（可枚举和不可枚举的符号键）的数组。
- en: '[PRE142]'
  id: totrans-706
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '`Object.values(obj)` ES2017'
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.values(obj)` ES2017'
- en: Returns an Array with the values of all enumerable own string-keyed properties.
  id: totrans-708
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回一个包含所有可枚举的自身字符串键属性的值的数组。
- en: '[PRE143]'
  id: totrans-709
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '`Object.entries(obj)` ES2017'
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.entries(obj)` ES2017'
- en: Returns an Array with one key-value pair (encoded as a two-element Array) per
    property of `obj`.
  id: totrans-711
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个包含每个`obj`属性的一个键值对（编码为一个包含两个元素的数组）的数组。
- en: Only own enumerable properties with string keys are included.
  id: totrans-712
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅包含具有字符串键的自身可枚举属性。
- en: 'Inverse operation: [`Object.fromEntries()`](#qref-Object.fromEntries)'
  id: totrans-713
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逆操作：[`Object.fromEntries()`](#qref-Object.fromEntries)
- en: '[PRE144]'
  id: totrans-714
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '`Object.fromEntries(keyValueIterable)` ES2019'
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.fromEntries(keyValueIterable)` ES2019'
- en: Creates an object whose own properties are specified by `keyValueIterable`.
  id: totrans-716
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个对象，其自身属性由`keyValueIterable`指定。
- en: 'Inverse operation: [`Object.entries()`](#qref-Object.entries)'
  id: totrans-717
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逆操作：[`Object.entries()`](#qref-Object.entries)
- en: '[PRE145]'
  id: totrans-718
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '`Object.hasOwn(obj, key)` ES2022'
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.hasOwn(obj, key)` ES2022'
- en: Returns `true` if `obj` has an own property whose key is `key`. If not, it returns
    `false`.
  id: totrans-720
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`obj`有一个具有键`key`的自身属性，则返回`true`。如果没有，则返回`false`。
- en: '[PRE146]'
  id: totrans-721
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[30.12.4 `Object.*`: protecting objects](#object-protecting-objects)'
  id: totrans-722
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.12.4 `Object.*`: 保护对象](#object-protecting-objects)'
- en: 'More information: [“Protecting objects from being changed ^(ES5) (advanced)”
    (§30.11)](#protecting-objects)'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息：[“保护对象不被更改^(ES5) (高级)” (§30.11)](#protecting-objects)
- en: '`Object.preventExtensions(obj)` ES5'
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.preventExtensions(obj)` ES5'
- en: Makes `obj` non-extensible and returns it.
  id: totrans-725
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使 `obj` 不可扩展并返回它。
- en: 'Effect:'
  id: totrans-726
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影响：
- en: '`obj` is non-extensible: We can’t add properties or change its prototype.'
  id: totrans-727
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`obj` 不可扩展：我们无法添加属性或更改其原型。'
- en: Only the top level of `obj` is changed (shallow change). Nested objects are
    not affected.
  id: totrans-728
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只改变 `obj` 的顶层（浅改变）。嵌套对象不受影响。
- en: 'Related: [`Object.isExtensible()`](#qref-Object.isExtensible)'
  id: totrans-729
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关：[`Object.isExtensible()`](#qref-Object.isExtensible)
- en: '`Object.isExtensible(obj)` ES5'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.isExtensible(obj)` ES5'
- en: Returns `true` if `obj` is extensible and `false` if it isn’t.
  id: totrans-731
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `obj` 可扩展则返回 `true`，否则返回 `false`。
- en: 'Related: [`Object.preventExtensions()`](#qref-Object.preventExtensions)'
  id: totrans-732
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关：[`Object.preventExtensions()`](#qref-Object.preventExtensions)
- en: '`Object.seal(obj)` ES5'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.seal(obj)` ES5'
- en: Seals `obj` and returns it.
  id: totrans-734
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密封 `obj` 并返回它。
- en: 'Effect:'
  id: totrans-735
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影响：
- en: '`obj` is non-extensible: We can’t add properties or change its prototype.'
  id: totrans-736
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`obj` 不可扩展：我们无法添加属性或更改其原型。'
- en: '`obj` is sealed: Additionally, all of its properties are unconfigurable.'
  id: totrans-737
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `obj` 被密封：此外，它的所有属性都是不可配置的。
- en: Only the top level of `obj` is changed (shallow change). Nested objects are
    not affected.
  id: totrans-738
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只改变 `obj` 的顶层（浅改变）。嵌套对象不受影响。
- en: 'Related: [`Object.isSealed()`](#qref-Object.isSealed)'
  id: totrans-739
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关：[`Object.isSealed()`](#qref-Object.isSealed)
- en: '`Object.isSealed(obj)` ES5'
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.isSealed(obj)` ES5'
- en: Returns `true` if `obj` is sealed and `false` if it isn’t.
  id: totrans-741
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `obj` 被密封则返回 `true`，否则返回 `false`。
- en: 'Related: [`Object.seal()`](#qref-Object.seal)'
  id: totrans-742
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关：[`Object.seal()`](#qref-Object.seal)
- en: '`Object.freeze(obj)` ES5'
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.freeze(obj)` ES5'
- en: Freezes `obj` and returns it.
  id: totrans-744
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冻结 `obj` 并返回它。
- en: 'Effect:'
  id: totrans-745
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影响：
- en: '`obj` is non-extensible: We can’t add properties or change its prototype.'
  id: totrans-746
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`obj` 不可扩展：我们无法添加属性或更改其原型。'
- en: '`obj` is sealed: Additionally, all of its properties are unconfigurable.'
  id: totrans-747
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`obj` 被密封：此外，它的所有属性都是不可配置的。'
- en: '`obj` is frozen: Additionally, all of its properties are non-writable.'
  id: totrans-748
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`obj` 被冻结：此外，它的所有属性都是不可写的。'
- en: Only the top level of `obj` is changed (shallow change). Nested objects are
    not affected.
  id: totrans-749
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只改变 `obj` 的顶层（浅改变）。嵌套对象不受影响。
- en: 'Related: [`Object.isFrozen()`](#qref-Object.isFrozen)'
  id: totrans-750
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关：[`Object.isFrozen()`](#qref-Object.isFrozen)
- en: '[PRE147]'
  id: totrans-751
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '`Object.isFrozen(obj)` ES5'
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.isFrozen(obj)` ES5'
- en: Returns `true` if `obj` is frozen.
  id: totrans-753
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `obj` 被冻结则返回 `true`。
- en: 'Related: [`Object.freeze()`](#qref-Object.freeze)'
  id: totrans-754
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关：[`Object.freeze()`](#qref-Object.freeze)
- en: '[30.12.5 `Object.*`: miscellaneous](#object-miscellaneous)'
  id: totrans-755
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.12.5 `Object.*`：杂项](#object-miscellaneous)'
- en: '`Object.assign(target, ...sources)` ES6'
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.assign(target, ...sources)` ES6'
- en: Assigns all enumerable own string-keyed properties of each of the `sources`
    to `target` and returns `target`.
  id: totrans-757
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将每个 `sources` 的所有可枚举的自身字符串键属性分配给 `target` 并返回 `target`。
- en: '[PRE148]'
  id: totrans-758
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '`Object.groupBy(items, computeGroupKey)` ES2024'
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.groupBy(items, computeGroupKey)` ES2024'
- en: '[PRE149]'
  id: totrans-760
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: The callback `computeGroupKey` returns a *group key* for each of the `items`.
  id: totrans-761
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调 `computeGroupKey` 为每个 `items` 返回一个 *组键*。
- en: 'The result of `Object.groupBy()` is an object where:'
  id: totrans-762
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.groupBy()` 的结果是这样一个对象：'
- en: The key of each property is a group key and
  id: totrans-763
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个属性的键是一个组键，并且
- en: its value is an Array with all items that have that group key.
  id: totrans-764
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其值是一个包含所有具有该组键的项的数组。
- en: '[PRE150]'
  id: totrans-765
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '`Object.is(value1, value2)` ES6'
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.is(value1, value2)` ES6'
- en: 'Is mostly equivalent to `value1 === value2` – with two exceptions:'
  id: totrans-767
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 主要等同于 `value1 === value2` ——但有两个例外：
- en: '[PRE151]'
  id: totrans-768
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Considering all `NaN` values to be equal can be useful – e.g., when searching
    for a value in an Array.
  id: totrans-769
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有 `NaN` 值视为相等可能很有用——例如，在搜索数组中的值时。
- en: The value `-0` is rare and it’s usually best to pretend it is the same as `0`.
  id: totrans-770
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值 `-0` 很少见，通常最好假装它与 `0` 相同。
- en: '[30.12.6 `Object.prototype.*`](#objectprototype)'
  id: totrans-771
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.12.6 `Object.prototype.*`](#objectprototype)'
- en: '`Object.prototype` has the following properties:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.prototype` 有以下属性：'
- en: '`Object.prototype.__proto__` (getter and setter)'
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.prototype.__proto__`（获取器和设置器）'
- en: '`Object.prototype.hasOwnProperty()`'
  id: totrans-774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.prototype.hasOwnProperty()`'
- en: '`Object.prototype.isPrototypeOf()`'
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.prototype.isPrototypeOf()`'
- en: '`Object.prototype.propertyIsEnumerable()`'
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.prototype.propertyIsEnumerable()`'
- en: '`Object.prototype.toLocaleString()`'
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.prototype.toLocaleString()`'
- en: '`Object.prototype.toString()`'
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.prototype.toString()`'
- en: '`Object.prototype.valueOf()`'
  id: totrans-779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.prototype.valueOf()`'
- en: 'These methods are explained in detail in [“Quick reference: `Object.prototype.*`”
    (§31.10)](ch_classes.html#quickref-object-prototype).'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法在“快速参考：`Object.prototype.*`”（§31.10）中有详细解释。
- en: '[30.13 Quick reference: `Reflect`](#quickref-reflect)'
  id: totrans-781
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[30.13 快速参考：`Reflect`](#quickref-reflect)'
- en: '`Reflect` provides functionality for [JavaScript proxies](https://exploringjs.com/deep-js/ch_proxies.html)
    that is also occasionally useful elsewhere:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect` 提供了用于 [JavaScript 代理](https://exploringjs.com/deep-js/ch_proxies.html)
    的功能，这些功能偶尔在其他地方也很有用：'
- en: '`Reflect.apply(target, thisArgument, argumentsList)` ES6'
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflect.apply(target, thisArgument, argumentsList)` ES6'
- en: Invokes `target` with the arguments provided by `argumentsList` and `this` set
    to `thisArgument`.
  id: totrans-784
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`argumentsList`提供的参数调用`target`，并将`this`设置为`thisArgument`。
- en: Equivalent to `target.apply(thisArgument, argumentsList)`
  id: totrans-785
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等同于`target.apply(thisArgument, argumentsList)`。
- en: '`Reflect.construct(target, argumentsList, newTarget=target)` ES6'
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflect.construct(target, argumentsList, newTarget=target)` ES6'
- en: The `new` operator as a function.
  id: totrans-787
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为函数的`new`运算符。
- en: '`target` is the constructor to invoke.'
  id: totrans-788
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`是要调用的构造函数。'
- en: The optional parameter `newTarget` points to the constructor that started the
    current chain of constructor calls.
  id: totrans-789
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选参数`newTarget`指向启动当前构造函数调用链的构造函数。
- en: '`Reflect.defineProperty(target, propertyKey, propDesc)` ES6'
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflect.defineProperty(target, propertyKey, propDesc)` ES6'
- en: Similar to `Object.defineProperty()`.
  id: totrans-791
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于`Object.defineProperty()`。
- en: Returns a boolean indicating whether or not the operation succeeded.
  id: totrans-792
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个布尔值，指示操作是否成功。
- en: '`Reflect.deleteProperty(target, propertyKey)` ES6'
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflect.deleteProperty(target, propertyKey)` ES6'
- en: 'The `delete` operator as a function. It works slightly differently, though:'
  id: totrans-794
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为函数的`delete`运算符。尽管它的工作方式略有不同：
- en: It returns `true` if it successfully deleted the property or if the property
    never existed.
  id: totrans-795
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果成功删除了属性或属性原本不存在，则返回`true`。
- en: It returns `false` if the property could not be deleted and still exists.
  id: totrans-796
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性无法删除且仍然存在，则返回`false`。
- en: In sloppy mode, the `delete` operator returns the same results as this method.
    But in strict mode, it throws a `TypeError` instead of returning `false`.
  id: totrans-797
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在宽松模式下，`delete`运算符返回与该方法相同的结果。但在严格模式下，它抛出`TypeError`而不是返回`false`。
- en: The only way to protect properties from deletion is by making them non-configurable.
  id: totrans-798
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保护属性不被删除的唯一方法是将它们设置为不可配置。
- en: '`Reflect.get(target, propertyKey, receiver=target)` ES6'
  id: totrans-799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflect.get(target, propertyKey, receiver=target)` ES6'
- en: A function that gets properties. The optional parameter `receiver` is needed
    if `get` reaches a getter (somewhere in the prototype chain). Then it provides
    the value for `this`.
  id: totrans-800
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 获取属性的功能。如果`get`在原型链中的某个地方遇到getter，则需要可选参数`receiver`。然后它提供`this`的值。
- en: '`Reflect.getOwnPropertyDescriptor(target, propertyKey)` ES6'
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflect.getOwnPropertyDescriptor(target, propertyKey)` ES6'
- en: Same as `Object.getOwnPropertyDescriptor()`.
  id: totrans-802
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与`Object.getOwnPropertyDescriptor()`相同。
- en: '`Reflect.getPrototypeOf(target)` ES6'
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflect.getPrototypeOf(target)` ES6'
- en: Same as `Object.getPrototypeOf()`.
  id: totrans-804
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与`Object.getPrototypeOf()`相同。
- en: '`Reflect.has(target, propertyKey)` ES6'
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflect.has(target, propertyKey)` ES6'
- en: The `in` operator as a function.
  id: totrans-806
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为函数的`in`运算符。
- en: '`Reflect.isExtensible(target)` ES6'
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflect.isExtensible(target)` ES6'
- en: Same as `Object.isExtensible()`.
  id: totrans-808
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与`Object.isExtensible()`相同。
- en: '`Reflect.ownKeys(target)` ES6'
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflect.ownKeys(target)` ES6'
- en: Returns all own property keys (strings and symbols) in an Array.
  id: totrans-810
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以数组形式返回所有自有属性键（字符串和符号）。
- en: '`Reflect.preventExtensions(target)` ES6'
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflect.preventExtensions(target)` ES6'
- en: Similar to `Object.preventExtensions()`.
  id: totrans-812
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于`Object.preventExtensions()`。
- en: Returns a boolean indicating whether or not the operation succeeded.
  id: totrans-813
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个布尔值，指示操作是否成功。
- en: '`Reflect.set(target, propertyKey, value, receiver=target)` ES6'
  id: totrans-814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflect.set(target, propertyKey, value, receiver=target)` ES6'
- en: Sets properties.
  id: totrans-815
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置属性。
- en: Returns a boolean indicating whether or not the operation succeeded.
  id: totrans-816
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个布尔值，指示操作是否成功。
- en: '`Reflect.setPrototypeOf(target, proto)` ES6'
  id: totrans-817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflect.setPrototypeOf(target, proto)` ES6'
- en: Same as `Object.setPrototypeOf()`.
  id: totrans-818
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`Object.setPrototypeOf()`相同。
- en: Returns a boolean indicating whether or not the operation succeeded.
  id: totrans-819
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个布尔值，指示操作是否成功。
- en: '[30.13.1 `Reflect.*` vs. `Object.*`](#reflect-vs-object)'
  id: totrans-820
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[30.13.1 `Reflect.*` 与 `Object.*`](#reflect-vs-object)'
- en: 'General recommendations:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 一般建议：
- en: Use `Object.*` whenever you can.
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，使用`Object.*`。
- en: Use `Reflect.*` when working with [ECMAScript proxies](https://exploringjs.com/deep-js/ch_proxies.html).
    Its methods are well adapted to ECMAScript’s meta-object protocol (MOP) which
    also return boolean error flags instead of exceptions.
  id: totrans-823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用[ECMAScript代理](https://exploringjs.com/deep-js/ch_proxies.html)时使用`Reflect.*`。其方法很好地适应了ECMAScript的元对象协议（MOP），该方法也返回布尔错误标志而不是抛出异常。
- en: What are use cases for `Reflect` beyond proxies?
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect`除了代理之外还有什么用例？'
- en: '`Reflect.ownKeys()` lists all own property keys – functionality that isn’t
    provided anywhere else.'
  id: totrans-825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflect.ownKeys()`列出所有自有属性键——这是其他地方没有提供的功能。'
- en: 'Same functionality as `Object` but different return values: `Reflect` duplicates
    the following methods of `Object`, but its methods return booleans indicating
    whether the operation succeeded (where the `Object` methods return the object
    that was modified).'
  id: totrans-826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`Object`具有相同的功能，但返回值不同：`Reflect`复制了`Object`的以下方法，但其方法返回布尔值，指示操作是否成功（而`Object`方法返回被修改的对象）。
- en: '`Object.defineProperty(obj, propKey, propDesc)`'
  id: totrans-827
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.defineProperty(obj, propKey, propDesc)`'
- en: '`Object.preventExtensions(obj)`'
  id: totrans-828
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.preventExtensions(obj)`'
- en: '`Object.setPrototypeOf(obj, proto)`'
  id: totrans-829
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.setPrototypeOf(obj, proto)`'
- en: 'Operators as functions: The following `Reflect` methods implement functionality
    that is otherwise only available via operators:'
  id: totrans-830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为函数的运算符：以下`Reflect`方法实现了其他情况下仅通过运算符可用的功能：
- en: '`Reflect.construct(target, argumentsList, newTarget=target)`'
  id: totrans-831
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflect.construct(target, argumentsList, newTarget=target)`'
- en: '`Reflect.deleteProperty(target, propertyKey)`'
  id: totrans-832
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflect.deleteProperty(target, propertyKey)`'
- en: '`Reflect.get(target, propertyKey, receiver=target)`'
  id: totrans-833
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflect.get(target, propertyKey, receiver=target)`'
- en: '`Reflect.has(target, propertyKey)`'
  id: totrans-834
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflect.has(target, propertyKey)`'
- en: '`Reflect.set(target, propertyKey, value, receiver=target)`'
  id: totrans-835
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflect.set(target, propertyKey, value, receiver=target)`'
- en: 'Shorter version of `apply()`: If we want to be completely safe about invoking
    the method `apply()` on a function, we can’t do so via dynamic dispatch, because
    the function may have an own property with the key `''apply''`:'
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply()`函数的简短版本：如果我们想完全安全地在一个函数上调用`apply()`方法，我们不能通过动态分派来这样做，因为该函数可能有一个键为`''apply''`的自有属性：'
- en: '[PRE152]'
  id: totrans-837
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Using `Reflect.apply()` is shorter:'
  id: totrans-838
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`Reflect.apply()`更简洁：
- en: '[PRE153]'
  id: totrans-839
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'No exceptions when deleting properties: the `delete` operator throws in strict
    mode if we try to delete a non-configurable own property. `Reflect.deleteProperty()`
    returns `false` in that case.'
  id: totrans-840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除属性时无例外：在严格模式下，如果我们尝试删除一个不可配置的自有属性，`delete`运算符会抛出异常。`Reflect.deleteProperty()`在这种情况下返回`false`。
