- en: 30 Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_objects.html](https://exploringjs.com/js/book/ch_objects.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[30.1 Cheat sheet: objects](#cheat-sheet-objects)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.1.1 Cheat sheet: single objects](#cheat-sheet-single-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.1.2 Cheat sheet: prototype chains](#cheat-sheet-prototype-chains)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.2 What is an object?](#what-is-an-object)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.2.1 The two ways of using objects](#ways-of-using-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.3 Fixed-layout objects](#fixed-layout-objects)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.3.1 Object literals: properties](#object-literals)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.3.2 Object literals: property value shorthands](#object-literals-property-value-shorthands)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.3.3 Getting properties](#getting-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.3.4 Setting properties](#setting-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.3.5 Object literals: methods](#object-literals-methods)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.3.6 Object literals: accessors](#object-literal-accessors)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.4 Spreading into object literals (`...`) ^(ES2018)](#spreading-into-object-literals)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.4.1 Use case for spreading: default values for missing properties](#use-case-for-spreading-default-values-for-missing-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.4.2 Use case for spreading: non-destructively changing properties](#use-case-for-spreading-nondestructively-changing-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.4.3 “Destructive spreading”: `Object.assign()` ^(ES6)](#Object.assign)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.5 Copying objects: spreading vs. `Object.assign()` vs. `structuredClone()`](#copying-objects)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.5.1 Copying objects via spreading is *shallow*](#copying-objects-via-spreading-is-shallow)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.5.2 Copying objects deeply via `structuredClone()`](#structuredClone)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.5.3 Which values can `structuredClone()` copy?](#which-values-can-structuredclone-copy)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.5.4 The property attributes of copied objects](#the-property-attributes-of-copied-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.5.5 Alternatives without the limitations of `structuredClone()`?](#alternatives-without-the-limitations-of-structuredclone)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.5.6 Sources of this section](#sources-of-this-section-1)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.6 Methods and the special variable `this`](#methods-and-this)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.6.1 Methods are properties whose values are functions](#methods-are-properties-whose-values-are-functions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.6.2 The special variable `this`](#the-special-variable-this)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.6.3 Methods and `.call()`](#methods-call)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.6.4 Methods and `.bind()`](#methods-bind)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.6.5 `this` pitfall: extracting methods](#extracting-methods)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.6.6 `this` pitfall: accidentally shadowing `this`](#shadowing-this)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.6.7 The value of `this` in various contexts (advanced)](#the-value-of-this-in-various-contexts-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.7 Optional chaining for property getting and method calls ^(ES2020) (advanced)](#optional-chaining)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.7.1 Example: optional fixed property getting](#example-optional-fixed-property-getting)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.7.2 The operators in more detail (advanced)](#the-operators-in-more-detail-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.7.3 Short-circuiting with optional property getting](#shortcircuiting-with-optional-property-getting)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.7.4 Optional chaining: downsides and alternatives](#optional-chaining-downsides-and-alternatives)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.7.5 Frequently asked questions](#frequently-asked-questions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.8 Prototype chains](#prototype-chains)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.8.1 JavaScript’s operations: all properties vs. own properties](#javascripts-operations-all-properties-vs-own-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.8.2 Pitfall: only the first member of a prototype chain is mutated](#pitfall-only-the-first-member-of-a-prototype-chain-is-mutated)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.8.3 Tips for working with prototypes (advanced)](#tips-for-working-with-prototypes-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.8.4 `Object.hasOwn()`: Is a given property own (non-inherited)? ^(ES2022)](#Object.hasOwn)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.8.5 Sharing data via prototypes](#sharing-data-via-prototypes)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9 Dictionary objects (advanced)](#dictionary-objects)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9.1 Quoted keys in object literals](#object-literals-quoted-keys)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9.2 Computed keys in object literals](#object-literals-computed-keys)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9.3 The `in` operator: is there a property with a given key?](#in-operator)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9.4 Deleting properties](#deleting-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9.5 Enumerability](#enumerability)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9.6 Listing property keys via `Object.keys()` etc.](#listing-property-keys)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9.7 Listing property values via `Object.values()`](#Object.values)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9.8 Listing property entries via `Object.entries()` ^(ES2017)](#Object.entries)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9.9 Properties are listed deterministically](#order-of-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9.10 Assembling objects via `Object.fromEntries()` ^(ES2019)](#Object.fromEntries)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.9.11 Objects with `null` prototypes make good dictionaries and lookup tables](#null-prototype-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.10 Property attributes and property descriptors ^(ES5) (advanced)](#property-attributes-property-descriptors)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.11 Protecting objects from being changed ^(ES5) (advanced)](#protecting-objects)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.12 Quick reference: `Object`](#quickref-object-api)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.12.1 `Object.*`: creating objects, handling prototypes](#object-creating-objects-handling-prototypes)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.12.2 `Object.*`: property attributes](#object-property-attributes)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.12.3 `Object.*`: property keys, values, entries](#object-property-keys-values-entries)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.12.4 `Object.*`: protecting objects](#object-protecting-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.12.5 `Object.*`: miscellaneous](#object-miscellaneous)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.12.6 `Object.prototype.*`](#objectprototype)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.13 Quick reference: `Reflect`](#quickref-reflect)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[30.13.1 `Reflect.*` vs. `Object.*`](#reflect-vs-object)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this book, JavaScript’s style of object-oriented programming (OOP) is introduced
    in four steps. This chapter covers step 1 and 2; [the next chapter](ch_classes.html#ch_classes)
    covers step 3 and 4\. The steps are ([figure 30.1](#fig:oop_steps_1_2)):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single objects (this chapter):** How do *objects*, JavaScript’s basic OOP
    building blocks, work in isolation?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Prototype chains (this chapter):** Each object has a chain of zero or more
    *prototype objects*. Prototypes are JavaScript’s core inheritance mechanism.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Classes (next chapter):** JavaScript’s *classes* are factories for objects.
    The relationship between a class and its instances is based on prototypal inheritance
    (step 2).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Subclassing (next chapter):** The relationship between a *subclass* and its
    *superclass* is also based on prototypal inheritance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../Images/98f9d262c296ae1a67f569088f87168c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 30.1: This book introduces object-oriented programming in JavaScript
    in four steps.'
  prefs: []
  type: TYPE_NORMAL
- en: '[30.1 Cheat sheet: objects](#cheat-sheet-objects)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[30.1.1 Cheat sheet: single objects](#cheat-sheet-single-objects)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Creating an object via an *object literal* (starts and ends with a curly brace):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1][PRE2][PRE3][PRE4][PRE5][PRE6][PRE7][PRE8]  [PRE9][PRE10][PRE11][PRE12][PRE13][PRE14][PRE15][PRE16]``
    [PRE17][PRE18][PRE19][PRE20][PRE21][PRE22][PRE23][PRE24]``js[PRE25]js[PRE26]js[PRE27]js[PRE28]
    // `obj2` inherits .protoProp from `proto` assert.equal(  obj2.protoProp, ''protoProp''
    ); assert.deepEqual(  Reflect.ownKeys(obj2),  [''objProp''] // own properties
    of `obj2` );  [PRE29]     const fixedLayoutObject = {      product: ''carrot'',      quantity:
    4,     };          [PRE30]     const dictionaryObject = {      [''one'']: 1,      [''two'']:
    2,     };          [PRE31] const jane = {  first: ''Jane'',  last: ''Doe'', //
    optional trailing comma };  [PRE32] const obj = {  if: true,  const: true, };  [PRE33]
    > Object.keys({a:1, b:2}) [ ''a'', ''b'' ]  [PRE34] function createPoint(x, y)
    {  return {x, y}; // Same as: {x: x, y: y} } assert.deepEqual(  createPoint(9,
    2),  { x: 9, y: 2 } );  [PRE35] const jane = {  first: ''Jane'',  last: ''Doe'',
    };  `// Get property .first` `assert.equal(jane.first, ''Jane''); // (A)`  [PRE36][PRE37][PRE38][PRE39][PRE40][PRE41][PRE42][PRE43]
    assert.equal(jane.unknownProperty, undefined);  [PRE44] const obj = {  prop: 1,
    }; assert.equal(obj.prop, 1); obj.prop = 2; // (A) assert.equal(obj.prop, 2);  [PRE45]
    const obj = {}; // empty object assert.deepEqual(  Object.keys(obj), []);  `obj.unknownProperty
    = ''abc'';` `assert.deepEqual(`  `Object.keys(obj), [''unknownProperty'']);`  [PRE46][PRE47][PRE48][PRE49][PRE50][PRE51][PRE52][PRE53]
    const jane = {  first: ''Jane'', // value property  says(text) {   // method  return
    `${this.first} says “${text}”`; // (A)  }, // comma as separator (optional at
    end) }; assert.equal(jane.says(''hello''), ''Jane says “hello”'');  [PRE54] const
    jane = {  first: ''Jane'',  last: ''Doe'',  get full() {  return `${this.first}
    ${this.last}`;  }, };  `assert.equal(jane.full, ''Jane Doe'');` `jane.first =
    ''John'';` `assert.equal(jane.full, ''John Doe'');`  [PRE55][PRE56][PRE57][PRE58][PRE59][PRE60][PRE61][PRE62]
    const jane = {  first: ''Jane'',  last: ''Doe'',  set full(fullName) {  const
    parts = fullName.split('' '');  this.first = parts[0];  this.last = parts[1];  },
    };  `jane.full = ''Richard Roe'';` `assert.equal(jane.first, ''Richard'');` `assert.equal(jane.last,
    ''Roe'');`  [PRE63][PRE64][PRE65][PRE66][PRE67][PRE68][PRE69]`` ##### [30.3.6.3 Use
    case for getters: ready-only properties whose values change](#use-case-for-getters-readyonly-properties-whose-values-change)    In
    the following code, the actual value of the counter is private. From the outside,
    it can only be read, via a getter:    [PRE70] `counter.inc();` `assert.equal(counter.value,
    1);`  `` `assert.throws(`  `() => counter.value = 5,`  `/^TypeError: Cannot set
    property value of #<Object> which has only a getter$/` `);` `` [PRE71]   [PRE72][PRE73][PRE74][PRE75][PRE76][PRE77][PRE78][PRE79][PRE80][PRE81][PRE82][PRE83][PRE84]
    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Implementing a stack via an object**    `exercises/objects/stack-via-object_test.mjs`    #####
    [30.3.6.4 Use case for getters: switching from a property to more encapsulation](#use-case-for-getters-switching-from-a-property-to-more-encapsulation)    In
    object-oriented programming, we worry about exposing too much internal state.
    Accessors enable us to change our mind about properties without breaking existing
    code: We can start exposed, with a normal property and later switch to an accessor
    and more encapsulation.    ### [30.4 Spreading into object literals (`...`) ^(ES2018)](#spreading-into-object-literals)    Inside
    an object literal, a *spread property* adds the properties of another object to
    the current one:    [PRE85]    If property keys clash, the property that is mentioned
    last “wins”:    [PRE86]    All values are spreadable, even `undefined` and `null`:    [PRE87]    Property
    `.length` of strings and Arrays is hidden from this kind of operation (it is not
    *enumerable*; see [“Property attributes and property descriptors ^(ES5) (advanced)”
    (§30.10)](#property-attributes-property-descriptors) for more information).    Spreading
    includes properties whose keys are symbols (which are ignored by `Object.keys()`,
    `Object.values()` and `Object.entries()`):    [PRE88]    #### [30.4.1 Use case
    for spreading: default values for missing properties](#use-case-for-spreading-default-values-for-missing-properties)    If
    one of the inputs of our code is an object with data, we can make properties optional
    by specifying default values that are used if those properties are missing. One
    technique for doing so is via an object whose properties contain the default values.
    In the following example, that object is `DEFAULTS`:    [PRE89]   [PRE90][PRE91][PRE92][PRE93][PRE94][PRE95]``
    The result, the object `allData`, is created by copying `DEFAULTS` and overriding
    its properties with those of `providedData`.    But we don’t need an object to
    specify the default values; we can also specify them inside the object literal,
    individually:    [PRE96]   [PRE97][PRE98][PRE99][PRE100][PRE101][PRE102]` ####
    [30.4.2 Use case for spreading: non-destructively changing properties](#use-case-for-spreading-nondestructively-changing-properties)    So
    far, we have encountered one way of changing a property `.alpha` of an object:
    We *set* it (line A) and mutate the object. That is, this way of changing a property
    is destructive.    [PRE103]    With spreading, we can change `.alpha` non-destructively
    – we make a copy of `obj` where `.alpha` has a different value:    [PRE104]    ![Icon
    “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Non-destructively
    updating a property via spreading (fixed key)**    `exercises/objects/update_name_test.mjs`    ####
    [30.4.3 “Destructive spreading”: `Object.assign()` ^(ES6)](#Object.assign)    `Object.assign()`
    is a tool method:    [PRE105]    This expression assigns all properties of `source_1`
    to `target`, then all properties of `source_2`, etc. At the end, it returns `target`
    – for example:    [PRE106]   [PRE107][PRE108][PRE109][PRE110][PRE111][PRE112]
    [PRE113][PRE114][PRE115][PRE116][PRE117][PRE118]``js[PRE119]js[PRE120]js[PRE121]`js[PRE122]js[PRE123]js`
    What does the exception look like that is thrown by `structuredClone()`?    [PRE124]js    #####
    [30.5.3.4 Instances of user-defined classes become plain objects](#instances-of-userdefined-classes-become-plain-objects)    In
    the following example, we copy an instance of the class `C`. The result, `copy`,
    is not an instance of `C`.    [PRE125]js   [PRE126]`js[PRE127]js[PRE128]js[PRE129]js[PRE130]js[PRE131]js[PRE132]js[PRE133]js[PRE134]js[PRE135]js[PRE136]js[PRE137]js[PRE138]`js[PRE139]js[PRE140]js[PRE141]js[PRE142]
    `// We created an own property:` `assert.deepEqual(Object.keys(obj), [''protoProp'']);`  [PRE143]
    [PRE144]   [PRE145][PRE146][PRE147][PRE148]`` [PRE149][PRE150][PRE151][PRE152]`
    The prototype chain of `obj` is depicted in [figure 30.3](#fig:oo_overriding).    ![](../Images/a36ba2c417a363309e1b3616c9d7810b.png)      Figure
    30.3: The own property `.protoProp` of `obj` overrides the property inherited
    from `proto`.      #### [30.8.3 Tips for working with prototypes (advanced)](#tips-for-working-with-prototypes-advanced)    #####
    [30.8.3.1 Getting and setting prototypes](#get-set-prototype)    Recommendations
    for the property key `__proto__`:    *   Don’t use the accessor `Object.prototype.__proto__`
    that all instances of `Object` have:               *   It can’t be used with all
    objects – e.g., objects that are not instances of `Object` don’t have it.     *   It
    is deprecated in the ECMAScript specification.          For more information on
    this feature see [“`Object.prototype.__proto__` (accessor) ^(ES6)” (§31.9.7)](ch_classes.html#Object.prototype.__proto__).           *   Using
    the property key `__proto__` in an object literal to specify a prototype is different:
    It’s a feature that is particular to object literals that just happens to have
    the same name as the deprecated accessor.              The recommended ways of
    getting and setting prototypes are:    *   Getting the prototype of an object:                    [PRE153]           *   The
    best time to set the prototype of an object is when we are creating it. We can
    do so via `__proto__` in an object literal or via:                    [PRE154]           *   If
    we have to, we can use `Object.setPrototypeOf()` to change the prototype of an
    existing object. But that may affect the performance of that object negatively.              This
    is how these features are used:    [PRE155]   [PRE156][PRE157][PRE158][PRE159]
    [PRE160][PRE161][PRE162][PRE163]``js[PRE164]js[PRE165]`js[PRE166]js` For more
    information on this method see [“`Object.prototype.isPrototypeOf()` ^(ES3)” (§31.9.5)](ch_classes.html#Object.prototype.isPrototypeOf).    ####
    [30.8.4 `Object.hasOwn()`: Is a given property own (non-inherited)? ^(ES2022)](#Object.hasOwn)    The
    `in` operator (line A) checks if an object has a given property. In contrast,
    `Object.hasOwn()` (lines B and C) checks if a property is own.    [PRE167]js    ![Icon
    “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Alternative before ES2022:
    `.hasOwnProperty()`**    Before ES2022, we can use another feature: [“`Object.prototype.hasOwnProperty()`
    ^(ES3)” (§31.9.8)](ch_classes.html#Object.prototype.hasOwnProperty). This feature
    has pitfalls, but the referenced section explains how to work around them.    ####
    [30.8.5 Sharing data via prototypes](#sharing-data-via-prototypes)    Consider
    the following code:    [PRE168]js   [PRE169]`js[PRE170]js[PRE171]js[PRE172]js[PRE173]js[PRE174]js[PRE175]`js[PRE176]js[PRE177][PRE178][PRE179]js
    const enumerableSymbolKey = Symbol(''enumerableSymbolKey''); const nonEnumSymbolKey
    = Symbol(''nonEnumSymbolKey'');  `// We create enumerable properties via an object
    literal` `const obj = {`  `enumerableStringKey: 1,`  `[enumerableSymbolKey]: 2,`
    `}`  [PRE180]js  [PRE181]js[PRE182]js[PRE183][PRE184] [PRE185] #### [30.9.7 Listing
    property values via `Object.values()`](#Object.values)    `Object.values()` lists
    the values of all own enumerable string-keyed properties of an object:    [PRE186]    ####
    [30.9.8 Listing property entries via `Object.entries()` ^(ES2017)](#Object.entries)    `Object.entries(obj)`
    returns an Array with one key-value pair for each of its properties:    *   Each
    pair is encoded as a two-element Array. *   Only own enumerable properties with
    string keys are included.    [PRE187]    ##### [30.9.8.1 A simple implementation
    of `Object.entries()`](#a-simple-implementation-of-objectentries)    The following
    function is a simplified version of `Object.entries()`:    [PRE188]    ![Icon
    “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: `Object.entries()`**    `exercises/objects/find_key_test.mjs`    ####
    [30.9.9 Properties are listed deterministically](#order-of-properties)    Own
    (non-inherited) properties of objects are always listed in the following order:    1.  Properties
    with string keys that contain integer indices:     In ascending numeric order
    2.  Remaining properties with string keys:     In the order in which they were
    added 3.  Properties with symbol keys:     In the order in which they were added    The
    following example demonstrates that property keys are sorted according to these
    rules:    [PRE189]    ![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **The
    order of properties**    [The ECMAScript specification](https://tc39.es/ecma262/#sec-ordinaryownpropertykeys)
    describes in more detail how properties are ordered.    ##### [30.9.9.1 Why is
    the order of properties deterministic?](#why-is-the-order-of-properties-deterministic)    As
    a data structure, objects are mainly unordered. Therefore, we wouldn’t expect,
    e.g., `Object.keys()` to always return property keys in the same order. However,
    JavaScript does define a deterministic order for properties because that helps
    with testing and other use cases.    #### [30.9.10 Assembling objects via `Object.fromEntries()`
    ^(ES2019)](#Object.fromEntries)    Given an iterable over [key, value] pairs,
    `Object.fromEntries()` creates an object:    [PRE190]    `Object.fromEntries()`
    does the opposite of [`Object.entries()`](#Object.entries). However, while `Object.entries()`
    ignores symbol-keyed properties, `Object.fromEntries()` doesn’t (see previous
    example).    To demonstrate both, we’ll use them to implement two tool functions
    from the library [Underscore](https://underscorejs.org) in the next subsubsections.    #####
    [30.9.10.1 Example: `pick()`](#underscore-pick)    [The Underscore function `pick()`](https://underscorejs.org/#pick)
    has the following signature:    [PRE191]    It returns a copy of `object` that
    has only those properties whose keys are mentioned in the trailing arguments:    [PRE192]    We
    can implement `pick()` as follows:    [PRE193]    ##### [30.9.10.2 Example: `invert()`](#underscore-invert)    [The
    Underscore function `invert()`](https://underscorejs.org/#invert) has the following
    signature:    [PRE194]    It returns a copy of `object` where the keys and values
    of all properties are swapped:    [PRE195]    We can implement `invert()` like
    this:    [PRE196]    ##### [30.9.10.3 A simple implementation of `Object.fromEntries()`](#a-simple-implementation-of-objectfromentries)    The
    following function is a simplified version of `Object.fromEntries()`:    [PRE197]    ![Icon
    “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Using
    `Object.entries()` and `Object.fromEntries()`**    `exercises/objects/omit_properties_test.mjs`    ####
    [30.9.11 Objects with `null` prototypes make good dictionaries and lookup tables](#null-prototype-objects)    If
    we use plain objects (created via object literals) as dictionaries, we have to
    look out for two pitfalls.    ##### [30.9.11.1 Pitfall 1: getting inherited properties](#pitfall-1-getting-inherited-properties)    The
    following dictionary object should be empty. However, we get a value (and not
    `undefined`) if we read an inherited property:    [PRE198]    `dict` is an instance
    of `Object` and inherits `.toString()` from `Object.prototype`.    ##### [30.9.11.2 Pitfall
    2: checking if a property exists](#pitfall-2-checking-if-a-property-exists)    If
    we use the `in` operator to check if a property exists, we again detect inherited
    properties:    [PRE199]    As an aside: `Object.hasOwn()` does not have this pitfall.
    As its name indicates, it only considers *own* (non-inherited) properties:    [PRE200]    #####
    [30.9.11.3 Pitfall 3: property key `''__proto__''`](#pitfall-3-property-key-proto)    We
    can’t use the property key `''__proto__''` because it has special powers (it sets
    the prototype of the object):    [PRE201]   [PRE202][PRE203]``js[PRE204]`` We
    avoided the pitfalls:    *   An object without a prototype does not inherit anything.
    Therefore, it is always safe to get properties and to use the `in` operator. *   The
    accessor `Object.prototype.__proto__` is switched off because `Object.prototype`
    is not in the prototype chain of `dict`.    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercises:
    Objects as dictionaries**    *   A `null` prototype object as a dictionary: `exercises/objects/null-proto-obj-dict_test.mjs`
    *   A plain object as a dictionary: `exercises/objects/plain-obj-dict_test.mjs`    #####
    [30.9.11.5 Objects with `null` prototypes as fixed lookup tables](#lookup-tables-with-null-prototypes)    Null
    prototypes are also useful for objects that we use as fixed lookup tables:    [PRE205]    #####
    [30.9.11.6 `null` prototypes in the standard library](#null-prototypes-in-standard-library)    Because
    they are good dictionaries, the standard library also uses objects with `null`
    prototype in some locations – e.g.:    *   The value of `import.meta`:                    [PRE206]           *   The
    result of `Object.groupBy()`:                    [PRE207]           *   When matching
    regular expressions – the value of `matchObj.groups`:                    [PRE208]              ###
    [30.10 Property attributes and property descriptors ^(ES5) (advanced)](#property-attributes-property-descriptors)    Just
    as objects are composed of properties, properties are composed of *attributes*.
    There are two kinds of properties and they are characterized by their attributes:    *   A
    *data property* stores data. Its attribute `value` holds any JavaScript value.     *   Methods
    are data properties whose values are functions. *   An *accessor property* consists
    of a getter function and/or a setter function. The former is stored in the attribute
    `get`, the latter in the attribute `set`.    Additionally, there are attributes
    that both kinds of properties have. The following table lists all attributes and
    their default values.     | Kind of property | Name and type of attribute | Default
    value | | --- | --- | --- | | All properties | `configurable: boolean` | `false`
    | |  | `enumerable: boolean` | `false` | | Data property | `value: any` | `undefined`
    | |  | `writable: boolean` | `false` | | Accessor property | `get: (this: any)
    => any` | `undefined` | |  | `set: (this: any, v: any) => void` | `undefined`
    |    We have already encountered the attributes `value`, `get`, and `set`. The
    other attributes work as follows:    *   `writable` determines if the value of
    a data property can be changed. *   `configurable` determines if the attributes
    of a property can be changed. If it is `false`, then:     *   We cannot delete
    the property.     *   We cannot change a property from a data property to an accessor
    property or vice versa.     *   We cannot change any attribute other than `value`.     *   However,
    one more attribute change is allowed: We can change `writable` from `true` to
    `false`. The rationale behind this anomaly is [historical](https://stackoverflow.com/questions/9829817/why-can-i-set-enumerability-and-writability-of-unconfigurable-property-descrip/9843191#9843191):
    Property `.length` of Arrays has always been writable and non-configurable. Allowing
    its `writable` attribute to be changed enables us to freeze Arrays. *   `enumerable`
    influences some operations (such as `Object.keys()`). If it is `false`, then those
    operations ignore the property. Enumerability is covered in greater detail [earlier
    in this chapter](#enumerability).    When we are using one of the operations for
    handling property attributes, attributes are specified via *property descriptors*:
    objects where each property represents one attribute. For example, this is how
    we read the attributes of a property `obj.myProp`:    [PRE209]    And this is
    how we change the attributes of `obj.myProp`:    [PRE210]   [PRE211]`` [PRE212]`
    Lastly, let’s see what methods and getters look like:    [PRE213]    ![Icon “external”](../Images/38e6ff55e8d602659f3cdb8893e63f62.png) **Further
    reading**    For more information on property attributes and property descriptors,
    see [*Deep JavaScript*](https://exploringjs.com/deep-js/ch_property-attributes-intro.html).    ###
    [30.11 Protecting objects from being changed ^(ES5) (advanced)](#protecting-objects)    JavaScript
    has three levels of protecting objects:    *   *Preventing extensions* makes it
    impossible to add new properties to an object and to change its prototype. We
    can still delete and change properties, though.     *   Apply: `Object.preventExtensions(obj)`     *   Check:
    `Object.isExtensible(obj)` *   *Sealing* prevents extensions and makes all properties
    *unconfigurable* (roughly: we can’t change how a property works anymore).     *   Apply:
    `Object.seal(obj)`     *   Check: `Object.isSealed(obj)` *   *Freezing* seals
    an object after making all of its properties non-writable. That is, the object
    is not extensible, all properties are read-only and there is no way to change
    that.     *   Apply: `Object.freeze(obj)`     *   Check: `Object.isFrozen(obj)`    ![Icon
    “warning”](../Images/5aa4bf88dc66ecb2bac6be4022a1fed4.png) **Caveat: Objects are
    only protected shallowly**    All three of the aforementioned `Object.*` methods
    only affect the top level of an object, not objects nested inside it.    This
    is what using `Object.freeze()` looks like:    [PRE214]    Changing frozen properties
    only causes an exception in [strict mode](ch_syntax.html#strict-mode). In sloppy
    mode, it fails silently.    ![Icon “external”](../Images/38e6ff55e8d602659f3cdb8893e63f62.png) **Further
    reading**    For more information on freezing and other ways of locking down objects,
    see [*Deep JavaScript*](https://exploringjs.com/deep-js/ch_protecting-objects.html).    ###
    [30.12 Quick reference: `Object`](#quickref-object-api)    #### [30.12.1 `Object.*`:
    creating objects, handling prototypes](#object-creating-objects-handling-prototypes)    *   `Object.create(proto,
    propDescObj?)` ES5               *   Returns a new object whose prototype is `proto`.     *   The
    optional `propDescObj` is an object with [property descriptors](#property-attributes-property-descriptors)
    that is used to define properties in the new object.          [PRE215]                    In
    the following example, we define own properties via the second parameter:                    [PRE216]           *   `Object.getPrototypeOf(obj)`
    ES5                    Return the prototype of `obj` – which is either an object
    or `null`.                    [PRE217]           *   `Object.setPrototypeOf(obj,
    proto)` ES6                    Sets the prototype of `obj` to `proto` (which must
    be `null` or an object) and returns the former.                    [PRE218]              ####
    [30.12.2 `Object.*`: property attributes](#object-property-attributes)    *   `Object.defineProperty(obj,
    propKey, propDesc)` ES5               *   Defines one property in `obj`, as specified
    by the property key `propKey` and the [property descriptor](#property-attributes-property-descriptors)
    `propDesc`.     *   Returns `obj`.          [PRE219]           *   `Object.defineProperties(obj,
    propDescObj)` ES5               *   Defines properties in `obj`, as specified
    by the object `propDescObj` with [property descriptors](#property-attributes-property-descriptors).     *   Returns
    `obj`.          [PRE220]           *   `Object.getOwnPropertyDescriptor(obj, propKey)`
    ES5               *   Returns a property descriptor for the own property of `obj`
    whose key is `propKey`. If no such property exists, it returns `undefined`.     *   More
    information on property descriptors: [“Property attributes and property descriptors
    ^(ES5) (advanced)” (§30.10)](#property-attributes-property-descriptors)          [PRE221]           *   `Object.getOwnPropertyDescriptors(obj)`
    ES2017               *   Returns an object with property descriptors, one for
    each own property of `obj`.     *   More information on property descriptors:
    [“Property attributes and property descriptors ^(ES5) (advanced)” (§30.10)](#property-attributes-property-descriptors)          [PRE222]              ####
    [30.12.3 `Object.*`: property keys, values, entries](#object-property-keys-values-entries)    *   `Object.keys(obj)`
    ES5                    Returns an Array with all own enumerable property keys
    that are strings.                    [PRE223]           [PRE224] *   `Object.getOwnPropertyNames(obj)`
    ES5                    Returns an Array with all own property keys that are strings
    (enumerable and non-enumerable ones).                    [PRE225]js          [PRE226]`js    [PRE227]js
    [PRE228]js`` [PRE229]js[PRE230][PRE231][PRE232][PRE233]js[PRE234]js` [PRE235]`js``
    [PRE236]`js[PRE237][PRE238][PRE239] [PRE240][PRE241][PRE242][PRE243][PRE244]``
    [PRE245][PRE246][PRE247] [PRE248]`js[PRE249]js[PRE250]js[PRE251]js[PRE252]js[PRE253]js`
    [PRE254]`js[PRE255]js[PRE256]js[PRE257][PRE258][PRE259][PRE260][PRE261]``js[PRE262]js[PRE263]js[PRE264]js[PRE265][PRE266][PRE267][PRE268][PRE269]
    [PRE270][PRE271][PRE272][PRE273][PRE274][PRE275][PRE276][PRE277][PRE278]`` [PRE279][PRE280][PRE281][PRE282][PRE283]
    [PRE284]`js[PRE285]js[PRE286]js[PRE287]js[PRE288]js[PRE289]js[PRE290]js[PRE291]js[PRE292]js[PRE293]js[PRE294]js`
    [PRE295]`js[PRE296]js[PRE297]js[PRE298]js[PRE299]js[PRE300][PRE301][PRE302][PRE303][PRE304][PRE305][PRE306]``js[PRE307]js[PRE308]js[PRE309]js[PRE310]js[PRE311]js[PRE312][PRE313][PRE314][PRE315][PRE316][PRE317][PRE318]
    [PRE319][PRE320][PRE321][PRE322][PRE323][PRE324][PRE325][PRE326][PRE327][PRE328][PRE329][PRE330][PRE331]``
    [PRE332][PRE333][PRE334][PRE335][PRE336][PRE337][PRE338] [PRE339]`js[PRE340]js[PRE341]js[PRE342]js[PRE343]js[PRE344]js[PRE345]js[PRE346]js[PRE347]js[PRE348]js[PRE349]js[PRE350]js[PRE351]js[PRE352]js[PRE353]js[PRE354]js`
    [PRE355]`js[PRE356]js[PRE357]js[PRE358]'
  prefs: []
  type: TYPE_NORMAL
