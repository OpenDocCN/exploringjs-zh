- en: 11 Variables and assignment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/impatient-js/ch_variables-assignment.html](https://exploringjs.com/impatient-js/ch_variables-assignment.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 11.1 [`let`](ch_variables-assignment.html#let)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.2 [`const`](ch_variables-assignment.html#const)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.2.1 [`const` and immutability](ch_variables-assignment.html#const-and-immutability)
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.2.2 [`const` and loops](ch_variables-assignment.html#const-and-loops)
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.3 [Deciding between `const` and `let`](ch_variables-assignment.html#deciding-between-const-and-let)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.4 [The scope of a variable](ch_variables-assignment.html#the-scope-of-a-variable)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.4.1 [Shadowing variables](ch_variables-assignment.html#shadowing-variables)
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.5 [(Advanced)](ch_variables-assignment.html#advanced-1)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '11.6 [Terminology: static vs. dynamic](ch_variables-assignment.html#terminology-static-vs.-dynamic)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '11.6.1 [Static phenomenon: scopes of variables](ch_variables-assignment.html#static-phenomenon-scopes-of-variables)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '11.6.2 [Dynamic phenomenon: function calls](ch_variables-assignment.html#dynamic-phenomenon-function-calls)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.7 [Global variables and the global object](ch_variables-assignment.html#global-variables-and-the-global-object)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.7.1 [`globalThis` [ES2020]](ch_variables-assignment.html#globalThis)
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '11.8 [Declarations: scope and activation](ch_variables-assignment.html#declarations-scope-activation)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '11.8.1 [`const` and `let`: temporal dead zone](ch_variables-assignment.html#const-and-let-temporal-dead-zone)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.8.2 [Function declarations and early activation](ch_variables-assignment.html#function-declarations-and-early-activation)
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.8.3 [Class declarations are not activated early](ch_variables-assignment.html#class-declarations-are-not-activated-early)
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '11.8.4 [`var`: hoisting (partial early activation)](ch_variables-assignment.html#var-hoisting-partial-early-activation)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.9 [Closures](ch_variables-assignment.html#closures)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.9.1 [Bound variables vs. free variables](ch_variables-assignment.html#bound-variables-vs.-free-variables)
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.9.2 [What is a closure?](ch_variables-assignment.html#what-is-a-closure)
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '11.9.3 [Example: A factory for incrementors](ch_variables-assignment.html#example-a-factory-for-incrementors)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.9.4 [Use cases for closures](ch_variables-assignment.html#use-cases-for-closures)
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'These are JavaScript’s main ways of declaring variables:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '`let` declares mutable variables.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const` declares *constants* (immutable variables).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before ES6, there was also `var`. But it has several quirks, so it’s best to
    avoid it in modern JavaScript. You can read more about it in [*Speaking JavaScript*](http://speakingjs.com/es5/ch16.html).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 11.1 `let`
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Variables declared via `let` are mutable:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can also declare and assign at the same time:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 11.2 `const`
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Variables declared via `const` are immutable. You must always initialize immediately:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 11.2.1 `const` and immutability
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In JavaScript, `const` only means that the *binding* (the association between
    variable name and variable value) is immutable. The value itself may be mutable,
    like `obj` in the following example.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 11.2.2 `const` and loops
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use `const` with `for-of` loops, where a fresh binding is created for
    each iteration:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In plain `for` loops, you must use `let`, however:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 11.3 Deciding between `const` and `let`
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I recommend the following rules to decide between `const` and `let`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '`const` indicates an immutable binding and that a variable never changes its
    value. Prefer it.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`let` indicates that the value of a variable changes. Use it only when you
    can’t use `const`.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: `const`**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/variables-assignment/const_exrc.mjs`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 11.4 The scope of a variable
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *scope* of a variable is the region of a program where it can be accessed.
    Consider the following code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Scope A is the *(direct) scope* of `x`.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scopes B and C are *inner scopes* of scope A.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scope A is an *outer scope* of scope B and scope C.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each variable is accessible in its direct scope and all scopes nested within
    that scope.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量在其直接作用域以及所有嵌套在该作用域内的作用域中都是可访问的。
- en: The variables declared via `const` and `let` are called *block-scoped* because
    their scopes are always the innermost surrounding blocks.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`const`和`let`声明的变量被称为*块作用域*，因为它们的作用域始终是最内部的周围块。
- en: 11.4.1 Shadowing variables
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.1 遮蔽变量
- en: 'You can’t declare the same variable twice at the same level:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在同一级别两次声明相同的变量：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **Why `eval()`?**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png) **为什么使用`eval()`?**'
- en: '[`eval()`](ch_dynamic-code-evaluation.html#eval) delays parsing (and therefore
    the `SyntaxError`), until the callback of `assert.throws()` is executed. If we
    didn’t use it, we’d already get an error when this code is parsed and `assert.throws()`
    wouldn’t even be executed.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[`eval()`](ch_dynamic-code-evaluation.html#eval) 延迟解析（因此延迟了`SyntaxError`），直到执行`assert.throws()`的回调。如果我们不使用它，当这段代码被解析时，我们已经会得到一个错误，`assert.throws()`甚至不会被执行。'
- en: 'You can, however, nest a block and use the same variable name `x` that you
    used outside the block:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你可以嵌套一个块并使用与块外部相同的变量名`x`：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Inside the block, the inner `x` is the only accessible variable with that name.
    The inner `x` is said to *shadow* the outer `x`. Once you leave the block, you
    can access the old value again.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在块内部，内部的 `x` 是唯一可访问的具有该名称的变量。内部的 `x` 被称为*遮蔽*外部的 `x`。一旦离开块，你可以再次访问旧值。
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz: basic**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png) **测验：基础**'
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[测验应用](ch_quizzes-exercises.html#quizzes)。
- en: 11.5 (Advanced)
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5（高级）
- en: All remaining sections are advanced.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 其余部分都是高级的。
- en: '11.6 Terminology: static vs. dynamic'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6 术语：静态 vs. 动态
- en: 'These two adjectives describe phenomena in programming languages:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个形容词描述了编程语言中的现象：
- en: '*Static* means that something is related to source code and can be determined
    without executing code.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*静态*意味着某物与源代码相关，并且可以在不执行代码的情况下确定。'
- en: '*Dynamic* means at runtime.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动态*意味着在运行时。'
- en: Let’s look at examples for these two terms.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这两个术语的例子。
- en: '11.6.1 Static phenomenon: scopes of variables'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.6.1 静态现象：变量的作用域
- en: 'Variable scopes are a static phenomenon. Consider the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 变量作用域是一个静态现象。考虑以下代码：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`x` is *statically* (or *lexically*) *scoped*. That is, its scope is fixed
    and doesn’t change at runtime.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`是*静态*（或*词法*）*作用域*。也就是说，它的作用域是固定的，在运行时不会改变。'
- en: Variable scopes form a static tree (via static nesting).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 变量作用域形成静态树（通过静态嵌套）。
- en: '11.6.2 Dynamic phenomenon: function calls'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.6.2 动态现象：函数调用
- en: 'Function calls are a dynamic phenomenon. Consider the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用是一个动态现象。考虑以下代码：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Whether or not the function call in line A happens, can only be decided at runtime.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在A行的函数调用是否发生，只能在运行时决定。
- en: Function calls form a dynamic tree (via dynamic calls).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用形成一个动态树（通过动态调用）。
- en: 11.7 Global variables and the global object
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.7 全局变量和全局对象
- en: 'JavaScript’s variable scopes are nested. They form a tree:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的变量作用域是嵌套的。它们形成一个树：
- en: The outermost scope is the root of the tree.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最外层的作用域是树的根。
- en: The scopes directly contained in that scope are the children of the root.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接包含在该作用域中的作用域是根的子级。
- en: And so on.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等等。
- en: 'The root is also called the *global scope*. In web browsers, the only location
    where one is directly in that scope is at the top level of a script. The variables
    of the global scope are called *global variables* and accessible everywhere. There
    are two kinds of global variables:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 根也被称为*全局作用域*。在Web浏览器中，直接处于该作用域的唯一位置是在脚本的顶层。全局作用域的变量称为*全局变量*，并且可以在任何地方访问。有两种全局变量：
- en: '*Global declarative variables* are normal variables.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*全局声明变量*是普通变量。'
- en: They can only be created while at the top level of a script, via `const`, `let`,
    and class declarations.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们只能在脚本的顶层通过`const`、`let`和类声明创建。
- en: '*Global object variables* are stored in properties of the so-called *global
    object*.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*全局对象变量*存储在所谓的*全局对象*的属性中。'
- en: They are created in the top level of a script, via `var` and function declarations.
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是在脚本的顶层通过`var`和函数声明创建的。
- en: The global object can be accessed via the global variable `globalThis`. It can
    be used to create, read, and delete global object variables.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局对象可以通过全局变量`globalThis`访问。它可以用于创建、读取和删除全局对象变量。
- en: Other than that, global object variables work like normal variables.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除此之外，全局对象变量的工作方式与普通变量相同。
- en: The following HTML fragment demonstrates `globalThis` and the two kinds of global
    variables.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下HTML片段演示了`globalThis`和两种全局变量。
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Each ECMAScript module has its own scope. Therefore, variables that exist at
    the top level of a module are not global. Fig. [5](#fig:global-scope) illustrates
    how the various scopes are related.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 每个ECMAScript模块都有自己的作用域。因此，在模块的顶层存在的变量并不是全局的。图[5](#fig:global-scope)说明了各种作用域之间的关系。
- en: '![Figure 5: The global scope is JavaScript’s outermost scope. It has two kinds
    of variables: object variables (managed via the global object) and normal declarative
    variables. Each ECMAScript module has its own scope which is contained in the
    global scope.](../Images/50731076c488c6bf43423b1518edad6b.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图5：全局作用域是JavaScript的最外层作用域。它有两种变量：对象变量（通过全局对象管理）和普通的声明变量。每个ECMAScript模块都有自己的作用域，它包含在全局作用域中。](../Images/50731076c488c6bf43423b1518edad6b.png)'
- en: 'Figure 5: The global scope is JavaScript’s outermost scope. It has two kinds
    of variables: *object variables* (managed via the *global object*) and normal
    *declarative variables*. Each ECMAScript module has its own scope which is contained
    in the global scope.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：全局作用域是JavaScript的最外层作用域。它有两种变量：*对象变量*（通过*全局对象*管理）和普通的*声明变量*。每个ECMAScript模块都有自己的作用域，它包含在全局作用域中。
- en: 11.7.1 `globalThis` [ES2020]
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.7.1 `globalThis` [ES2020]
- en: The global variable `globalThis` is the new standard way of accessing the global
    object. It got its name from the fact that it has the same value as `this` in
    global scope.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量`globalThis`是访问全局对象的新标准方式。它的名称来自于它在全局作用域中与`this`具有相同的值。
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **`globalThis` does not
    always directly point to the global object**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png) **`globalThis`并不总是直接指向全局对象**'
- en: For example, in browsers, [there is an indirection](https://exploringjs.com/deep-js/ch_global-scope.html#window-proxy).
    That indirection is normally not noticable, but it is there and can be observed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在浏览器中，[存在一个间接访问](https://exploringjs.com/deep-js/ch_global-scope.html#window-proxy)。这种间接通常是不明显的，但它存在并且可以被观察到。
- en: 11.7.1.1 Alternatives to `globalThis`
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 11.7.1.1 `globalThis`的替代方案
- en: 'Older ways of accessing the global object depend on the platform:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 访问全局对象的旧方法取决于平台：
- en: 'Global variable `window`: is the classic way of referring to the global object.
    But it doesn’t work in Node.js and in Web Workers.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局变量`window`：是指全局对象的经典方式。但在Node.js和Web Workers中不起作用。
- en: 'Global variable `self`: is available in Web Workers and browsers in general.
    But it isn’t supported by Node.js.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局变量`self`：在Web Workers和通常的浏览器中可用。但Node.js不支持。
- en: 'Global variable `global`: is only available in Node.js.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局变量`global`：仅在Node.js中可用。
- en: 11.7.1.2 Use cases for `globalThis`
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 11.7.1.2 `globalThis`的用例
- en: The global object is now considered a mistake that JavaScript can’t get rid
    of, due to backward compatibility. It affects performance negatively and is generally
    confusing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 全局对象现在被认为是JavaScript无法摆脱的错误，因为向后兼容性。它对性能产生负面影响，通常令人困惑。
- en: 'ECMAScript 6 introduced several features that make it easier to avoid the global
    object – for example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6引入了一些功能，使得更容易避免全局对象-例如：
- en: '`const`, `let`, and class declarations don’t create global object properties
    when used in global scope.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const`、`let`和类声明在全局作用域中使用时不会创建全局对象属性。'
- en: Each ECMAScript module has its own local scope.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个ECMAScript模块都有自己的局部作用域。
- en: It is usually better to access global object variables via variables and not
    via properties of `globalThis`. The former has always worked the same on all JavaScript
    platforms.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最好通过变量访问全局对象变量，而不是通过`globalThis`的属性。前者在所有JavaScript平台上始终以相同的方式工作。
- en: 'Tutorials on the web occasionally access global variables `globVar` via `window.globVar`.
    But the prefix “`window.`” is not necessary and I recommend to omit it:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 网络教程偶尔通过`window.globVar`访问全局变量`globVar`。但前缀“`window.`”是不必要的，我建议省略它：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Therefore, there are relatively few use cases for `globalThis` – for example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`globalThis`的用例相对较少-例如：
- en: '[*Polyfills*](ch_modules.html#polyfills) that add new features to old JavaScript
    engines.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*Polyfills*](ch_modules.html#polyfills)为旧的JavaScript引擎添加新功能。'
- en: Feature detection, to find out what features a JavaScript engine supports.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性检测，以找出JavaScript引擎支持的功能。
- en: '11.8 Declarations: scope and activation'
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.8 声明：作用域和激活
- en: 'These are two key aspects of declarations:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是声明的两个关键方面：
- en: 'Scope: Where can a declared entity be seen? This is a static trait.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域：声明的实体可以在哪里看到？这是一个静态特征。
- en: 'Activation: When can I access an entity? This is a dynamic trait. Some entities
    can be accessed as soon as we enter their scopes. For others, we have to wait
    until execution reaches their declarations.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激活：何时可以访问实体？这是一个动态特征。一些实体可以在我们进入它们的作用域时立即访问。对于其他实体，我们必须等到执行到达它们的声明时才能访问。
- en: Tbl. [1](#tbl:aspects-of-declarations) summarizes how various declarations handle
    these aspects.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Tbl. [1](#tbl:aspects-of-declarations)总结了各种声明如何处理这些方面。
- en: 'Table 1: Aspects of declarations. “Duplicates” describes if a declaration can
    be used twice with the same name (per scope). “Global prop.” describes if a declaration
    adds a property to the global object, when it is executed in the global scope
    of a script. *TDZ* means *temporal dead zone* (which is explained later). (*)
    Function declarations are normally block-scoped, but function-scoped in [sloppy
    mode](ch_syntax.html#strict-mode).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 表1：声明的方面。“重复”描述了声明是否可以在相同的名称下两次使用（每个作用域）。“全局属性”描述了当在脚本的全局作用域中执行时，声明是否向全局对象添加属性。*TDZ*表示*暂时死区*（稍后会解释）。(*)
    函数声明通常是块作用域的，但在[松散模式](ch_syntax.html#strict-mode)中是函数作用域的。
- en: '|  | Scope | Activation | Duplicates | Global prop. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|  | 作用域 | 激活 | 重复 | 全局属性 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `const` | Block | decl. (TDZ) | `✘` | `✘` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `const` | 块 | 声明（TDZ） | `✘` | `✘` |'
- en: '| `let` | Block | decl. (TDZ) | `✘` | `✘` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `let` | 块 | 声明（TDZ） | `✘` | `✘` |'
- en: '| `function` | Block (*) | start | `✔` | `✔` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `function` | 块 (*) | 开始 | `✔` | `✔` |'
- en: '| `class` | Block | decl. (TDZ) | `✘` | `✘` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `class` | 块 | 声明（TDZ） | `✘` | `✘` |'
- en: '| `import` | Module | same as export | `✘` | `✘` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `import` | 模块 | 与导出相同 | `✘` | `✘` |'
- en: '| `var` | Function | start, partially | `✔` | `✔` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `var` | 函数 | 开始，部分 | `✔` | `✔` |'
- en: '`import` is described in [§27.5 “ECMAScript modules”](ch_modules.html#ecmascript-modules).
    The following sections describe the other constructs in more detail.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`在[§27.5“ECMAScript模块”](ch_modules.html#ecmascript-modules)中有描述。以下各节更详细地描述了其他构造。'
- en: '11.8.1 `const` and `let`: temporal dead zone'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.8.1 `const`和`let`：暂时死区
- en: 'For JavaScript, TC39 needed to decide what happens if you access a constant
    in its direct scope, before its declaration:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于JavaScript，TC39需要决定在直接作用域中访问常量时会发生什么：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Some possible approaches are:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可能的方法是：
- en: The name is resolved in the scope surrounding the current scope.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 名称在当前作用域周围的作用域中解析。
- en: You get `undefined`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会得到`undefined`。
- en: There is an error.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一个错误。
- en: Approach 1 was rejected because there is no precedent in the language for this
    approach. It would therefore not be intuitive to JavaScript programmers.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法被拒绝了，因为语言中没有这种方法的先例。因此，对JavaScript程序员来说不直观。
- en: Approach 2 was rejected because then `x` wouldn’t be a constant – it would have
    different values before and after its declaration.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法被拒绝了，因为`x`在其声明之前和之后将不是一个常量-它将具有不同的值。
- en: '`let` uses the same approach 3 as `const`, so that both work similarly and
    it’s easy to switch between them.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 使用与 `const` 相同的方法 3，因此两者的工作方式类似，很容易在它们之间切换。'
- en: 'The time between entering the scope of a variable and executing its declaration
    is called the *temporal dead zone* (TDZ) of that variable:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 进入变量作用域并执行其声明之间的时间称为*时间死区*（TDZ）：
- en: During this time, the variable is considered to be uninitialized (as if that
    were a special value it has).
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此期间，该变量被视为未初始化（就好像那是它的特殊值）。
- en: If you access an uninitialized variable, you get a `ReferenceError`.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果访问未初始化的变量，将会得到 `ReferenceError`。
- en: Once you reach a variable declaration, the variable is set to either the value
    of the initializer (specified via the assignment symbol) or `undefined` – if there
    is no initializer.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦到达变量声明，变量就会被设置为初始化程序的值（通过赋值符号指定），或者 `undefined` - 如果没有初始化程序。
- en: 'The following code illustrates the temporal dead zone:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码说明了时间死区：
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next example shows that the temporal dead zone is truly *temporal* (related
    to time):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例显示了时间死区确实是*时间*相关的：
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Even though `func()` is located before the declaration of `myVar` and uses that
    variable, we can call `func()`. But we have to wait until the temporal dead zone
    of `myVar` is over.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `func()` 位于 `myVar` 的声明之前并使用该变量，我们也可以调用 `func()`。但是我们必须等到 `myVar` 的时间死区结束。
- en: 11.8.2 Function declarations and early activation
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.8.2 函数声明和提前激活
- en: '![](../Images/ec8e6930fbe484fc519f3aa7b812c3fd.png)  **More information on
    functions**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/ec8e6930fbe484fc519f3aa7b812c3fd.png) **有关函数的更多信息**'
- en: In this section, we are using functions – before we had a chance to learn them
    properly. Hopefully, everything still makes sense. Whenever it doesn’t, please
    see [§25 “Callable values”](ch_callables.html).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们正在使用函数 - 在我们有机会正确学习它们之前。希望一切仍然有意义。每当不明白时，请参阅[§25“可调用值”](ch_callables.html)。
- en: 'A function declaration is always executed when entering its scope, regardless
    of where it is located within that scope. That enables you to call a function
    `foo()` before it is declared:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明总是在进入其作用域时执行，无论它在作用域内的位置如何。这使您可以在声明之前调用函数 `foo()`：
- en: '[PRE16]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The early activation of `foo()` means that the previous code is equivalent
    to:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo()` 的提前激活意味着前面的代码等同于：'
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you declare a function via `const` or `let`, then it is not activated early.
    In the following example, you can only use `bar()` after its declaration.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过 `const` 或 `let` 声明函数，则不会提前激活。在以下示例中，只能在声明后使用 `bar()`。
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 11.8.2.1 Calling ahead without early activation
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 11.8.2.1 提前调用而不提前激活
- en: 'Even if a function `g()` is not activated early, it can be called by a preceding
    function `f()` (in the same scope) if we adhere to the following rule: `f()` must
    be invoked after the declaration of `g()`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 即使函数 `g()` 没有提前激活，也可以通过前面的函数 `f()`（在相同的作用域中）调用它，如果我们遵守以下规则：`f()` 必须在 `g()` 的声明之后调用。
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The functions of a module are usually invoked after its complete body is executed.
    Therefore, in modules, you rarely need to worry about the order of functions.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的函数通常在其完整体执行后调用。因此，在模块中，您很少需要担心函数的顺序。
- en: 'Lastly, note how early activation automatically keeps the aforementioned rule:
    when entering a scope, all function declarations are executed first, before any
    calls are made.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，提前激活会自动遵守上述规则：进入作用域时，所有函数声明都会首先执行，然后再进行任何调用。
- en: 11.8.2.2 A pitfall of early activation
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 11.8.2.2 提前激活的一个陷阱
- en: If you rely on early activation to call a function before its declaration, then
    you need to be careful that it doesn’t access data that isn’t activated early.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您依赖提前激活来调用函数而不是声明它，那么您需要小心，不要访问未提前激活的数据。
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The problem goes away if you make the call to `funcDecl()` after the declaration
    of `MY_STR`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在声明 `MY_STR` 之后调用 `funcDecl()`，问题就会消失。
- en: 11.8.2.3 The pros and cons of early activation
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 11.8.2.3 提前激活的利弊
- en: We have seen that early activation has a pitfall and that you can get most of
    its benefits without using it. Therefore, it is better to avoid early activation.
    But I don’t feel strongly about this and, as mentioned before, often use function
    declarations because I like their syntax.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到提前激活有一个陷阱，并且您可以在不使用它的情况下获得大部分好处。因此，最好避免提前激活。但我对此并不感到强烈，并且如前所述，通常使用函数声明，因为我喜欢它们的语法。
- en: 11.8.3 Class declarations are not activated early
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.8.3 类声明不会提前激活
- en: 'Even though they are similar to function declarations in some ways, [class
    declarations](ch_classes.html#classes) are not activated early:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们在某些方面类似于函数声明，[类声明](ch_classes.html#classes) 不会提前激活：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Why is that? Consider the following class declaration:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？考虑以下类声明：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The operand of `extends` is an expression. Therefore, you can do things like
    this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`extends` 的操作数是一个表达式。因此，您可以做这样的事情：'
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Evaluating such an expression must be done at the location where it is mentioned.
    Anything else would be confusing. That explains why class declarations are not
    activated early.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对这样的表达式进行评估必须在提到它的位置进行。其他任何操作都会令人困惑。这就解释了为什么类声明不会提前激活。
- en: '11.8.4 `var`: hoisting (partial early activation)'
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.8.4 `var`：提升（部分提前激活）
- en: '`var` is an older way of declaring variables that predates `const` and `let`
    (which are preferred now). Consider the following `var` declaration.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`var` 是一种旧的声明变量的方式，早于 `const` 和 `let`（现在更受青睐）。考虑以下 `var` 声明。'
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This declaration has two parts:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此声明有两个部分：
- en: 'Declaration `var x`: The scope of a `var`-declared variable is the innermost
    surrounding function and not the innermost surrounding block, as for most other
    declarations. Such a variable is already active at the beginning of its scope
    and initialized with `undefined`.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明 `var x`：`var` 声明的变量的作用域是最内层的周围函数，而不是最内层的周围块，就像大多数其他声明一样。这样的变量在其作用域开始时已经激活并初始化为
    `undefined`。
- en: 'Assignment `x = 123`: The assignment is always executed in place.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值 `x = 123`：赋值总是在原地执行。
- en: 'The following code demonstrates the effects of `var`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了`var`的效果：
- en: '[PRE25]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 11.9 Closures
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.9 闭包
- en: Before we can explore closures, we need to learn about bound variables and free
    variables.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨闭包之前，我们需要了解绑定变量和自由变量。
- en: 11.9.1 Bound variables vs. free variables
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.9.1 绑定变量 vs. 自由变量
- en: 'Per scope, there is a set of variables that are mentioned. Among these variables
    we distinguish:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '每个作用域中都有一组被提及的变量。在这些变量中，我们区分： '
- en: '*Bound variables* are declared within the scope. They are parameters and local
    variables.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定变量*是在作用域内声明的。它们是参数和局部变量。'
- en: '*Free variables* are declared externally. They are also called *non-local variables*.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自由变量*是在外部声明的。它们也被称为*非局部变量*。'
- en: 'Consider the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE26]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the body of `func()`, `x` and `y` are bound variables. `z` is a free variable.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在`func()`的主体中，`x`和`y`是绑定变量。`z`是自由变量。
- en: 11.9.2 What is a closure?
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.9.2 闭包是什么？
- en: What is a closure then?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 那么闭包是什么呢？
- en: A *closure* is a function plus a connection to the variables that exist at its
    “birth place”.
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*闭包*是一个函数加上与其“诞生地”存在的变量的连接。'
- en: 'What is the point of keeping this connection? It provides the values for the
    free variables of the function – for example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 保持这种连接的意义是什么？它为函数的自由变量提供了值-例如：
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`funcFactory` returns a closure that is assigned to `func`. Because `func`
    has the connection to the variables at its birth place, it can still access the
    free variable `value` when it is called in line A (even though it “escaped” its
    scope).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`funcFactory`返回一个分配给`func`的闭包。因为`func`与其诞生地的变量有连接，所以当它在A行被调用时，它仍然可以访问自由变量`value`（尽管它“逃离”了它的作用域）。'
- en: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png)  **All functions in JavaScript
    are closures**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png)  **JavaScript中的所有函数都是闭包**'
- en: Static scoping is supported via closures in JavaScript. Therefore, every function
    is a closure.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中支持静态作用域。因此，每个函数都是一个闭包。
- en: '11.9.3 Example: A factory for incrementors'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.9.3 示例：增量器工厂
- en: The following function returns *incrementors* (a name that I just made up).
    An incrementor is a function that internally stores a number. When it is called,
    it updates that number by adding the argument to it and returns the new value.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数返回*增量器*（我刚刚编造的一个名字）。增量器是一个内部存储数字的函数。当它被调用时，它通过将参数添加到数字中来更新该数字，并返回新值。
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can see that the function created in line A keeps its internal number in
    the free variable `startValue`. This time, we don’t just read from the birth scope,
    we use it to store data that we change and that persists across function calls.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在A行创建的函数保留了其内部数字在自由变量`startValue`中。这一次，我们不仅仅是从诞生作用域中读取，我们使用它来存储我们改变的数据，并且这些数据在函数调用之间保持不变。
- en: 'We can create more storage slots in the birth scope, via local variables:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过局部变量在诞生作用域中创建更多的存储槽：
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 11.9.4 Use cases for closures
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.9.4 闭包的用例
- en: What are closures good for?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包有什么好处？
- en: For starters, they are simply an implementation of static scoping. As such,
    they provide context data for callbacks.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它们只是静态作用域的一种实现。因此，它们为回调提供上下文数据。
- en: They can also be used by functions to store state that persists across function
    calls. `createInc()` is an example of that.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们也可以被函数用来存储在函数调用之间持续存在的状态。`createInc()`就是一个例子。
- en: And they can provide private data for objects (produced via literals or classes).
    The details of how that works are explained in [*Exploring ES6*](https://exploringjs.com/es6/ch_classes.html#_private-data-via-constructor-environments).
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以为对象提供私有数据（通过字面量或类生成）。关于这是如何工作的细节在[*探索ES6*](https://exploringjs.com/es6/ch_classes.html#_private-data-via-constructor-environments)中有解释。
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz: advanced**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **测验：高级**'
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[测验应用](ch_quizzes-exercises.html#quizzes)。
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/6)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[评论](https://github.com/rauschma/impatient-js/issues/6)'
