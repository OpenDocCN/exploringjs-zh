- en: 11 Variables and assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/impatient-js/ch_variables-assignment.html](https://exploringjs.com/impatient-js/ch_variables-assignment.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 11.1 [`let`](ch_variables-assignment.html#let)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.2 [`const`](ch_variables-assignment.html#const)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.2.1 [`const` and immutability](ch_variables-assignment.html#const-and-immutability)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.2.2 [`const` and loops](ch_variables-assignment.html#const-and-loops)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.3 [Deciding between `const` and `let`](ch_variables-assignment.html#deciding-between-const-and-let)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.4 [The scope of a variable](ch_variables-assignment.html#the-scope-of-a-variable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.4.1 [Shadowing variables](ch_variables-assignment.html#shadowing-variables)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.5 [(Advanced)](ch_variables-assignment.html#advanced-1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '11.6 [Terminology: static vs. dynamic](ch_variables-assignment.html#terminology-static-vs.-dynamic)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '11.6.1 [Static phenomenon: scopes of variables](ch_variables-assignment.html#static-phenomenon-scopes-of-variables)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '11.6.2 [Dynamic phenomenon: function calls](ch_variables-assignment.html#dynamic-phenomenon-function-calls)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.7 [Global variables and the global object](ch_variables-assignment.html#global-variables-and-the-global-object)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.7.1 [`globalThis` [ES2020]](ch_variables-assignment.html#globalThis)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '11.8 [Declarations: scope and activation](ch_variables-assignment.html#declarations-scope-activation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '11.8.1 [`const` and `let`: temporal dead zone](ch_variables-assignment.html#const-and-let-temporal-dead-zone)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.8.2 [Function declarations and early activation](ch_variables-assignment.html#function-declarations-and-early-activation)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.8.3 [Class declarations are not activated early](ch_variables-assignment.html#class-declarations-are-not-activated-early)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '11.8.4 [`var`: hoisting (partial early activation)](ch_variables-assignment.html#var-hoisting-partial-early-activation)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.9 [Closures](ch_variables-assignment.html#closures)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.9.1 [Bound variables vs. free variables](ch_variables-assignment.html#bound-variables-vs.-free-variables)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.9.2 [What is a closure?](ch_variables-assignment.html#what-is-a-closure)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '11.9.3 [Example: A factory for incrementors](ch_variables-assignment.html#example-a-factory-for-incrementors)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.9.4 [Use cases for closures](ch_variables-assignment.html#use-cases-for-closures)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are JavaScript’s main ways of declaring variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`let` declares mutable variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const` declares *constants* (immutable variables).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before ES6, there was also `var`. But it has several quirks, so it’s best to
    avoid it in modern JavaScript. You can read more about it in [*Speaking JavaScript*](http://speakingjs.com/es5/ch16.html).
  prefs: []
  type: TYPE_NORMAL
- en: 11.1 `let`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Variables declared via `let` are mutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also declare and assign at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 11.2 `const`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Variables declared via `const` are immutable. You must always initialize immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 11.2.1 `const` and immutability
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In JavaScript, `const` only means that the *binding* (the association between
    variable name and variable value) is immutable. The value itself may be mutable,
    like `obj` in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 11.2.2 `const` and loops
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use `const` with `for-of` loops, where a fresh binding is created for
    each iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In plain `for` loops, you must use `let`, however:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 11.3 Deciding between `const` and `let`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I recommend the following rules to decide between `const` and `let`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const` indicates an immutable binding and that a variable never changes its
    value. Prefer it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`let` indicates that the value of a variable changes. Use it only when you
    can’t use `const`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: `const`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/variables-assignment/const_exrc.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: 11.4 The scope of a variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *scope* of a variable is the region of a program where it can be accessed.
    Consider the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Scope A is the *(direct) scope* of `x`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scopes B and C are *inner scopes* of scope A.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scope A is an *outer scope* of scope B and scope C.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each variable is accessible in its direct scope and all scopes nested within
    that scope.
  prefs: []
  type: TYPE_NORMAL
- en: The variables declared via `const` and `let` are called *block-scoped* because
    their scopes are always the innermost surrounding blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 11.4.1 Shadowing variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can’t declare the same variable twice at the same level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **Why `eval()`?**'
  prefs: []
  type: TYPE_NORMAL
- en: '[`eval()`](ch_dynamic-code-evaluation.html#eval) delays parsing (and therefore
    the `SyntaxError`), until the callback of `assert.throws()` is executed. If we
    didn’t use it, we’d already get an error when this code is parsed and `assert.throws()`
    wouldn’t even be executed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can, however, nest a block and use the same variable name `x` that you
    used outside the block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Inside the block, the inner `x` is the only accessible variable with that name.
    The inner `x` is said to *shadow* the outer `x`. Once you leave the block, you
    can access the old value again.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz: basic**'
  prefs: []
  type: TYPE_NORMAL
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  prefs: []
  type: TYPE_NORMAL
- en: 11.5 (Advanced)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All remaining sections are advanced.
  prefs: []
  type: TYPE_NORMAL
- en: '11.6 Terminology: static vs. dynamic'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These two adjectives describe phenomena in programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Static* means that something is related to source code and can be determined
    without executing code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dynamic* means at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at examples for these two terms.
  prefs: []
  type: TYPE_NORMAL
- en: '11.6.1 Static phenomenon: scopes of variables'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Variable scopes are a static phenomenon. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`x` is *statically* (or *lexically*) *scoped*. That is, its scope is fixed
    and doesn’t change at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: Variable scopes form a static tree (via static nesting).
  prefs: []
  type: TYPE_NORMAL
- en: '11.6.2 Dynamic phenomenon: function calls'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Function calls are a dynamic phenomenon. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Whether or not the function call in line A happens, can only be decided at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Function calls form a dynamic tree (via dynamic calls).
  prefs: []
  type: TYPE_NORMAL
- en: 11.7 Global variables and the global object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript’s variable scopes are nested. They form a tree:'
  prefs: []
  type: TYPE_NORMAL
- en: The outermost scope is the root of the tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scopes directly contained in that scope are the children of the root.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The root is also called the *global scope*. In web browsers, the only location
    where one is directly in that scope is at the top level of a script. The variables
    of the global scope are called *global variables* and accessible everywhere. There
    are two kinds of global variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Global declarative variables* are normal variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can only be created while at the top level of a script, via `const`, `let`,
    and class declarations.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Global object variables* are stored in properties of the so-called *global
    object*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are created in the top level of a script, via `var` and function declarations.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The global object can be accessed via the global variable `globalThis`. It can
    be used to create, read, and delete global object variables.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Other than that, global object variables work like normal variables.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The following HTML fragment demonstrates `globalThis` and the two kinds of global
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Each ECMAScript module has its own scope. Therefore, variables that exist at
    the top level of a module are not global. Fig. [5](#fig:global-scope) illustrates
    how the various scopes are related.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5: The global scope is JavaScript’s outermost scope. It has two kinds
    of variables: object variables (managed via the global object) and normal declarative
    variables. Each ECMAScript module has its own scope which is contained in the
    global scope.](../Images/50731076c488c6bf43423b1518edad6b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: The global scope is JavaScript’s outermost scope. It has two kinds
    of variables: *object variables* (managed via the *global object*) and normal
    *declarative variables*. Each ECMAScript module has its own scope which is contained
    in the global scope.'
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.1 `globalThis` [ES2020]
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The global variable `globalThis` is the new standard way of accessing the global
    object. It got its name from the fact that it has the same value as `this` in
    global scope.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **`globalThis` does not
    always directly point to the global object**'
  prefs: []
  type: TYPE_NORMAL
- en: For example, in browsers, [there is an indirection](https://exploringjs.com/deep-js/ch_global-scope.html#window-proxy).
    That indirection is normally not noticable, but it is there and can be observed.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.1.1 Alternatives to `globalThis`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Older ways of accessing the global object depend on the platform:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Global variable `window`: is the classic way of referring to the global object.
    But it doesn’t work in Node.js and in Web Workers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Global variable `self`: is available in Web Workers and browsers in general.
    But it isn’t supported by Node.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Global variable `global`: is only available in Node.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.7.1.2 Use cases for `globalThis`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The global object is now considered a mistake that JavaScript can’t get rid
    of, due to backward compatibility. It affects performance negatively and is generally
    confusing.
  prefs: []
  type: TYPE_NORMAL
- en: 'ECMAScript 6 introduced several features that make it easier to avoid the global
    object – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const`, `let`, and class declarations don’t create global object properties
    when used in global scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each ECMAScript module has its own local scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is usually better to access global object variables via variables and not
    via properties of `globalThis`. The former has always worked the same on all JavaScript
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tutorials on the web occasionally access global variables `globVar` via `window.globVar`.
    But the prefix “`window.`” is not necessary and I recommend to omit it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, there are relatively few use cases for `globalThis` – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Polyfills*](ch_modules.html#polyfills) that add new features to old JavaScript
    engines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature detection, to find out what features a JavaScript engine supports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '11.8 Declarations: scope and activation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These are two key aspects of declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scope: Where can a declared entity be seen? This is a static trait.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Activation: When can I access an entity? This is a dynamic trait. Some entities
    can be accessed as soon as we enter their scopes. For others, we have to wait
    until execution reaches their declarations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tbl. [1](#tbl:aspects-of-declarations) summarizes how various declarations handle
    these aspects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1: Aspects of declarations. “Duplicates” describes if a declaration can
    be used twice with the same name (per scope). “Global prop.” describes if a declaration
    adds a property to the global object, when it is executed in the global scope
    of a script. *TDZ* means *temporal dead zone* (which is explained later). (*)
    Function declarations are normally block-scoped, but function-scoped in [sloppy
    mode](ch_syntax.html#strict-mode).'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Scope | Activation | Duplicates | Global prop. |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `const` | Block | decl. (TDZ) | `✘` | `✘` |'
  prefs: []
  type: TYPE_TB
- en: '| `let` | Block | decl. (TDZ) | `✘` | `✘` |'
  prefs: []
  type: TYPE_TB
- en: '| `function` | Block (*) | start | `✔` | `✔` |'
  prefs: []
  type: TYPE_TB
- en: '| `class` | Block | decl. (TDZ) | `✘` | `✘` |'
  prefs: []
  type: TYPE_TB
- en: '| `import` | Module | same as export | `✘` | `✘` |'
  prefs: []
  type: TYPE_TB
- en: '| `var` | Function | start, partially | `✔` | `✔` |'
  prefs: []
  type: TYPE_TB
- en: '`import` is described in [§27.5 “ECMAScript modules”](ch_modules.html#ecmascript-modules).
    The following sections describe the other constructs in more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: '11.8.1 `const` and `let`: temporal dead zone'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For JavaScript, TC39 needed to decide what happens if you access a constant
    in its direct scope, before its declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Some possible approaches are:'
  prefs: []
  type: TYPE_NORMAL
- en: The name is resolved in the scope surrounding the current scope.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You get `undefined`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Approach 1 was rejected because there is no precedent in the language for this
    approach. It would therefore not be intuitive to JavaScript programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Approach 2 was rejected because then `x` wouldn’t be a constant – it would have
    different values before and after its declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '`let` uses the same approach 3 as `const`, so that both work similarly and
    it’s easy to switch between them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The time between entering the scope of a variable and executing its declaration
    is called the *temporal dead zone* (TDZ) of that variable:'
  prefs: []
  type: TYPE_NORMAL
- en: During this time, the variable is considered to be uninitialized (as if that
    were a special value it has).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you access an uninitialized variable, you get a `ReferenceError`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you reach a variable declaration, the variable is set to either the value
    of the initializer (specified via the assignment symbol) or `undefined` – if there
    is no initializer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code illustrates the temporal dead zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The next example shows that the temporal dead zone is truly *temporal* (related
    to time):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Even though `func()` is located before the declaration of `myVar` and uses that
    variable, we can call `func()`. But we have to wait until the temporal dead zone
    of `myVar` is over.
  prefs: []
  type: TYPE_NORMAL
- en: 11.8.2 Function declarations and early activation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '![](../Images/ec8e6930fbe484fc519f3aa7b812c3fd.png)  **More information on
    functions**'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are using functions – before we had a chance to learn them
    properly. Hopefully, everything still makes sense. Whenever it doesn’t, please
    see [§25 “Callable values”](ch_callables.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'A function declaration is always executed when entering its scope, regardless
    of where it is located within that scope. That enables you to call a function
    `foo()` before it is declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The early activation of `foo()` means that the previous code is equivalent
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you declare a function via `const` or `let`, then it is not activated early.
    In the following example, you can only use `bar()` after its declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 11.8.2.1 Calling ahead without early activation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Even if a function `g()` is not activated early, it can be called by a preceding
    function `f()` (in the same scope) if we adhere to the following rule: `f()` must
    be invoked after the declaration of `g()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The functions of a module are usually invoked after its complete body is executed.
    Therefore, in modules, you rarely need to worry about the order of functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, note how early activation automatically keeps the aforementioned rule:
    when entering a scope, all function declarations are executed first, before any
    calls are made.'
  prefs: []
  type: TYPE_NORMAL
- en: 11.8.2.2 A pitfall of early activation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you rely on early activation to call a function before its declaration, then
    you need to be careful that it doesn’t access data that isn’t activated early.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The problem goes away if you make the call to `funcDecl()` after the declaration
    of `MY_STR`.
  prefs: []
  type: TYPE_NORMAL
- en: 11.8.2.3 The pros and cons of early activation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We have seen that early activation has a pitfall and that you can get most of
    its benefits without using it. Therefore, it is better to avoid early activation.
    But I don’t feel strongly about this and, as mentioned before, often use function
    declarations because I like their syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 11.8.3 Class declarations are not activated early
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Even though they are similar to function declarations in some ways, [class
    declarations](ch_classes.html#classes) are not activated early:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Why is that? Consider the following class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The operand of `extends` is an expression. Therefore, you can do things like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Evaluating such an expression must be done at the location where it is mentioned.
    Anything else would be confusing. That explains why class declarations are not
    activated early.
  prefs: []
  type: TYPE_NORMAL
- en: '11.8.4 `var`: hoisting (partial early activation)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`var` is an older way of declaring variables that predates `const` and `let`
    (which are preferred now). Consider the following `var` declaration.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This declaration has two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaration `var x`: The scope of a `var`-declared variable is the innermost
    surrounding function and not the innermost surrounding block, as for most other
    declarations. Such a variable is already active at the beginning of its scope
    and initialized with `undefined`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assignment `x = 123`: The assignment is always executed in place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code demonstrates the effects of `var`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 11.9 Closures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we can explore closures, we need to learn about bound variables and free
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 11.9.1 Bound variables vs. free variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Per scope, there is a set of variables that are mentioned. Among these variables
    we distinguish:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Bound variables* are declared within the scope. They are parameters and local
    variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Free variables* are declared externally. They are also called *non-local variables*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the body of `func()`, `x` and `y` are bound variables. `z` is a free variable.
  prefs: []
  type: TYPE_NORMAL
- en: 11.9.2 What is a closure?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What is a closure then?
  prefs: []
  type: TYPE_NORMAL
- en: A *closure* is a function plus a connection to the variables that exist at its
    “birth place”.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What is the point of keeping this connection? It provides the values for the
    free variables of the function – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`funcFactory` returns a closure that is assigned to `func`. Because `func`
    has the connection to the variables at its birth place, it can still access the
    free variable `value` when it is called in line A (even though it “escaped” its
    scope).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png)  **All functions in JavaScript
    are closures**'
  prefs: []
  type: TYPE_NORMAL
- en: Static scoping is supported via closures in JavaScript. Therefore, every function
    is a closure.
  prefs: []
  type: TYPE_NORMAL
- en: '11.9.3 Example: A factory for incrementors'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following function returns *incrementors* (a name that I just made up).
    An incrementor is a function that internally stores a number. When it is called,
    it updates that number by adding the argument to it and returns the new value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the function created in line A keeps its internal number in
    the free variable `startValue`. This time, we don’t just read from the birth scope,
    we use it to store data that we change and that persists across function calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create more storage slots in the birth scope, via local variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 11.9.4 Use cases for closures
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What are closures good for?
  prefs: []
  type: TYPE_NORMAL
- en: For starters, they are simply an implementation of static scoping. As such,
    they provide context data for callbacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can also be used by functions to store state that persists across function
    calls. `createInc()` is an example of that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And they can provide private data for objects (produced via literals or classes).
    The details of how that works are explained in [*Exploring ES6*](https://exploringjs.com/es6/ch_classes.html#_private-data-via-constructor-environments).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz: advanced**'
  prefs: []
  type: TYPE_NORMAL
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  prefs: []
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/6)'
  prefs: []
  type: TYPE_NORMAL
