- en: '32 Typed Arrays: handling binary data (advanced)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/impatient-js/ch_typed-arrays.html](https://exploringjs.com/impatient-js/ch_typed-arrays.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 32.1 [The basics of the API](ch_typed-arrays.html#the-basics-of-the-api)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.1.1 [Use cases for Typed Arrays](ch_typed-arrays.html#use-cases-for-typed-arrays)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '32.1.2 [The core classes: `ArrayBuffer`, Typed Arrays, `DataView`](ch_typed-arrays.html#the-core-classes-arraybuffer-typed-arrays-dataview)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.1.3 [Using Typed Arrays](ch_typed-arrays.html#using-typed-arrays)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.1.4 [Using DataViews](ch_typed-arrays.html#using-dataviews)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.2 [Element types](ch_typed-arrays.html#element-types)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.2.1 [Handling overflow and underflow](ch_typed-arrays.html#handling-overflow-underflow)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.2.2 [Endianness](ch_typed-arrays.html#endianness)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.3 [More information on Typed Arrays](ch_typed-arrays.html#more-information-on-typed-arrays)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.3.1 [The static method `«ElementType»Array.from()`](ch_typed-arrays.html#the-static-method-elementtypearray.from)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.3.2 [Typed Arrays are iterable](ch_typed-arrays.html#typed-arrays-are-iterable)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.3.3 [Typed Arrays vs. normal Arrays](ch_typed-arrays.html#typed-arrays-vs.-normal-arrays)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.3.4 [Converting Typed Arrays to and from normal Arrays](ch_typed-arrays.html#converting-typed-arrays-to-and-from-normal-arrays)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.3.5 [Concatenating Typed Arrays](ch_typed-arrays.html#concatenating-typed-arrays)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '32.4 [Quick references: indices vs. offsets](ch_typed-arrays.html#typed-arrays-indices-offsets)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '32.5 [Quick reference: ArrayBuffers](ch_typed-arrays.html#quick-reference-arraybuffers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.5.1 [`new ArrayBuffer()`](ch_typed-arrays.html#new-arraybuffer)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.5.2 [Static methods of `ArrayBuffer`](ch_typed-arrays.html#static-methods-of-arraybuffer)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.5.3 [Properties of `ArrayBuffer.prototype`](ch_typed-arrays.html#properties-of-arraybuffer.prototype)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '32.6 [Quick reference: Typed Arrays](ch_typed-arrays.html#quick-reference-typed-arrays)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.6.1 [Static methods of `TypedArray<T>`](ch_typed-arrays.html#static-methods-of-typedarrayt)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.6.2 [Properties of `TypedArray<T>.prototype`](ch_typed-arrays.html#properties-of-typedarrayt.prototype)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.6.3 [`new «ElementType»Array()`](ch_typed-arrays.html#new-elementtypearray)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.6.4 [Static properties of `«ElementType»Array`](ch_typed-arrays.html#static-properties-of-elementtypearray)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.6.5 [Properties of `«ElementType»Array.prototype`](ch_typed-arrays.html#properties-of-elementtypearray.prototype)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '32.7 [Quick reference: DataViews](ch_typed-arrays.html#quick-reference-dataviews)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.7.1 [`new DataView()`](ch_typed-arrays.html#new-dataview)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.7.2 [Properties of `DataView.prototype`](ch_typed-arrays.html#properties-of-dataview.prototype)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 32.1 The basics of the API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Much data on the web is text: JSON files, HTML files, CSS files, JavaScript
    code, etc. JavaScript handles such data well via its built-in strings.'
  prefs: []
  type: TYPE_NORMAL
- en: However, before 2011, it did not handle binary data well. [The Typed Array Specification
    1.0](https://www.khronos.org/registry/typedarray/specs/1.0/) was introduced on
    February 8, 2011 and provides tools for working with binary data. With ECMAScript
    6, Typed Arrays were added to the core language and gained methods that were previously
    only available for normal Arrays (`.map()`, `.filter()`, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: 32.1.1 Use cases for Typed Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The main uses cases for Typed Arrays, are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Processing binary data: managing image data, manipulating binary files, handling
    binary network protocols, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interacting with native APIs: Native APIs often receive and return data in
    a binary format, which you could neither store nor manipulate well in pre-ES6
    JavaScript. That meant that whenever you were communicating with such an API,
    data had to be converted from JavaScript to binary and back for every call. Typed
    Arrays eliminate this bottleneck. One example of communicating with native APIs
    is WebGL, for which Typed Arrays were initially created. Section [“History of
    Typed Arrays”](http://www.html5rocks.com/en/tutorials/webgl/typed_arrays/#toc-history)
    of the article [“Typed Arrays: Binary Data in the Browser”](http://www.html5rocks.com/en/tutorials/webgl/typed_arrays/#toc-history)
    (by Ilmari Heikkinen for HTML5 Rocks) has more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '32.1.2 The core classes: `ArrayBuffer`, Typed Arrays, `DataView`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Typed Array API stores binary data in instances of `ArrayBuffer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An ArrayBuffer itself is a black box: if you want to access its data, you must
    wrap it in another object – a *view object*. Two kinds of view objects are available:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Typed Arrays: let you access the data as an indexed sequence of elements that
    all have the same type. Examples include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Uint8Array`: Elements are unsigned 8-bit integers. *Unsigned* means that their
    ranges start at zero.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int16Array`: Elements are signed 16-bit integers. *Signed* means that they
    have a sign and can be negative, zero, or positive.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Float32Array`: Elements are 32-bit floating point numbers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DataViews: let you interpret the data as various types (`Uint8`, `Int16`, `Float32`,
    etc.) that you can read and write at any byte offset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fig. [20](#fig:typed_arrays_class_diagram) shows a class diagram of the API.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20: The classes of the Typed Array API.](../Images/1598186f99439610a5dfe0e2c08f1a33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20: The classes of the Typed Array API.'
  prefs: []
  type: TYPE_NORMAL
- en: 32.1.3 Using Typed Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Typed Arrays are used much like normal Arrays with a few notable differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Typed Arrays store their data in ArrayBuffers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All elements are initialized with zeros.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All elements have the same type. Writing values to a Typed Array coerces them
    to that type. Reading values produces normal numbers or bigints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The length of a Typed Array is immutable; it can’t be changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typed Arrays can’t have holes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.1.3.1 Creating Typed Arrays
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following code shows three different ways of creating the same Typed Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 32.1.3.2 The wrapped ArrayBuffer
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 32.1.3.3 Getting and setting elements
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 32.1.4 Using DataViews
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is how DataViews are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 32.2 Element types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Table 20: Element types supported by the Typed Array API.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Element | Typed Array | Bytes | Description |  |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Int8` | `Int8Array` | 1 | 8-bit signed integer | ES6 |'
  prefs: []
  type: TYPE_TB
- en: '| `Uint8` | `Uint8Array` | 1 | 8-bit unsigned integer | ES6 |'
  prefs: []
  type: TYPE_TB
- en: '| `Uint8C` | `Uint8ClampedArray` | 1 | 8-bit unsigned integer | ES6 |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  | (clamped conversion) | ES6 |'
  prefs: []
  type: TYPE_TB
- en: '| `Int16` | `Int16Array` | 2 | 16-bit signed integer | ES6 |'
  prefs: []
  type: TYPE_TB
- en: '| `Uint16` | `Uint16Array` | 2 | 16-bit unsigned integer | ES6 |'
  prefs: []
  type: TYPE_TB
- en: '| `Int32` | `Int32Array` | 4 | 32-bit signed integer | ES6 |'
  prefs: []
  type: TYPE_TB
- en: '| `Uint32` | `Uint32Array` | 4 | 32-bit unsigned integer | ES6 |'
  prefs: []
  type: TYPE_TB
- en: '| `BigInt64` | `BigInt64Array` | 8 | 64-bit signed integer | ES2020 |'
  prefs: []
  type: TYPE_TB
- en: '| `BigUint64` | `BigUint64Array` | 8 | 64-bit unsigned integer | ES2020 |'
  prefs: []
  type: TYPE_TB
- en: '| `Float32` | `Float32Array` | 4 | 32-bit floating point | ES6 |'
  prefs: []
  type: TYPE_TB
- en: '| `Float64` | `Float64Array` | 8 | 64-bit floating point | ES6 |'
  prefs: []
  type: TYPE_TB
- en: 'Tbl. [20](#tbl:typed-array-element-types) lists the available element types.
    These types (e.g., `Int32`) show up in two locations:'
  prefs: []
  type: TYPE_NORMAL
- en: In Typed Arrays, they specify the types of the elements. For example, all elements
    of a `Int32Array` have the type `Int32`. The element type is the only aspect of
    Typed Arrays that differs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In DataViews, they are the lenses through which they access their ArrayBuffers
    when you use methods such as `.getInt32()` and `.setInt32()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The element type `Uint8C` is special: it is not supported by `DataView` and
    only exists to enable `Uint8ClampedArray`. This Typed Array is used by the `canvas`
    element (where it replaces `CanvasPixelArray`) and should otherwise be avoided.
    The only difference between `Uint8C` and `Uint8` is how overflow and underflow
    are handled (as explained in the next subsection).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Typed Arrays and Array Buffers use numbers and bigints to import and export
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: The types `BigInt64` and `BigUint64` are handled via bigints. For example, setters
    accept bigints and getters return bigints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All other element types are handled via numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.2.1 Handling overflow and underflow
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Normally, when a value is out of the range of the element type, modulo arithmetic
    is used to convert it to a value within range. For signed and unsigned integers
    that means that:'
  prefs: []
  type: TYPE_NORMAL
- en: The highest value plus one is converted to the lowest value (0 for unsigned
    integers).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lowest value minus one is converted to the highest value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following function helps illustrate how conversion works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Modulo conversion for unsigned 8-bit integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Modulo conversion for signed 8-bit integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Clamped conversion is different:'
  prefs: []
  type: TYPE_NORMAL
- en: All underflowing values are converted to the lowest value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All overflowing values are converted to the highest value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 32.2.2 Endianness
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Whenever a type (such as `Uint16`) is stored as a sequence of multiple bytes,
    *endianness* matters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Big endian: the most significant byte comes first. For example, the `Uint16`
    value 0x4321 is stored as two bytes – first 0x43, then 0x21\.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Little endian: the least significant byte comes first. For example, the `Uint16`
    value 0x4321 is stored as two bytes – first 0x21, then 0x43\.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Endianness tends to be fixed per CPU architecture and consistent across native
    APIs. Typed Arrays are used to communicate with those APIs, which is why their
    endianness follows the endianness of the platform and can’t be changed.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the endianness of protocols and binary files varies, but
    is fixed per format, across platforms. Therefore, we must be able to access data
    with either endianness. DataViews serve this use case and let you specify endianness
    when you get or set a value.
  prefs: []
  type: TYPE_NORMAL
- en: '[Quoting Wikipedia on Endianness](https://en.wikipedia.org/wiki/Endianness):'
  prefs: []
  type: TYPE_NORMAL
- en: Big-endian representation is the most common convention in data networking;
    fields in the protocols of the Internet protocol suite, such as IPv4, IPv6, TCP,
    and UDP, are transmitted in big-endian order. For this reason, big-endian byte
    order is also referred to as network byte order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Little-endian storage is popular for microprocessors in part due to significant
    historical influence on microprocessor designs by Intel Corporation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other orderings are also possible. Those are generically called *middle-endian*
    or *mixed-endian*.
  prefs: []
  type: TYPE_NORMAL
- en: 32.3 More information on Typed Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, `«ElementType»Array` stands for `Int8Array`, `Uint8Array`,
    etc. `ElementType` is `Int8`, `Uint8`, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 32.3.1 The static method `«ElementType»Array.from()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This method has the type signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`.from()` converts `source` into an instance of `this` (a Typed Array).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, normal Arrays are iterable and can be converted with this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Typed Arrays are also iterable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`source` can also be [an *Array-like object*](ch_arrays.html#array-like-objects):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The optional `mapfn` lets you transform the elements of `source` before they
    become elements of the result. Why perform the two steps *mapping* and *conversion*
    in one go? Compared to mapping separately via `.map()`, there are two advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: No intermediate Array or Typed Array is needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When converting between Typed Arrays with different precisions, less can go
    wrong.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read on for an explanation of the second advantage.
  prefs: []
  type: TYPE_NORMAL
- en: '32.3.1.1 Pitfall: mapping while converting between Typed Array types'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The static method `.from()` can optionally both map and convert between Typed
    Array types. Less can go wrong if you use that method.
  prefs: []
  type: TYPE_NORMAL
- en: To see why that is, let us first convert a Typed Array to a Typed Array with
    a higher precision. If we use `.from()` to map, the result is automatically correct.
    Otherwise, you must first convert and then map.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If we go from a Typed Array to a Typed Array with a lower precision, mapping
    via `.from()` produces the correct result. Otherwise, we must first map and then
    convert.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that if we map via `.map()`, then input type and output type
    are the same. In contrast, `.from()` goes from an arbitrary input type to an output
    type that you specify via its receiver.
  prefs: []
  type: TYPE_NORMAL
- en: 32.3.2 Typed Arrays are iterable
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Typed Arrays are [iterable](ch_sync-iteration.html). That means that you can
    use the `for-of` loop and other iteration-based mechanisms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: ArrayBuffers and DataViews are not iterable.
  prefs: []
  type: TYPE_NORMAL
- en: 32.3.3 Typed Arrays vs. normal Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Typed Arrays are much like normal Arrays: they have a `.length`, elements can
    be accessed via the bracket operator `[]`, and they have most of the standard
    Array methods. They differ from normal Arrays in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Typed Arrays have buffers. The elements of a Typed Array `ta` are not stored
    in `ta`, they are stored in an associated ArrayBuffer that can be accessed via
    `ta.buffer`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Typed Arrays are initialized with zeros:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new Array(4)` creates a normal Array without any elements. It only has four
    *holes* (indices less than the `.length` that have no associated elements).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new Uint8Array(4)` creates a Typed Array whose four elements are all 0.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All of the elements of a Typed Array have the same type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting elements converts values to that type.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Getting elements returns numbers or bigints.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The `.length` of a Typed Array is derived from its ArrayBuffer and never changes
    (unless you switch to a different ArrayBuffer).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normal Arrays can have holes; Typed Arrays can’t.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 32.3.4 Converting Typed Arrays to and from normal Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To convert a normal Array to a Typed Array, you pass it to a Typed Array constructor
    (which accepts Array-like objects and Typed Arrays) or to `«ElementType»Array.from()`
    (which accepts iterables and Array-like objects). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert a Typed Array to a normal Array, you can use `Array.from()` or spreading
    (because Typed Arrays are iterable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 32.3.5 Concatenating Typed Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Typed Arrays don’t have a method `.concat()`, like normal Arrays do. The workaround
    is to use their overloaded method `.set()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It copies the existing `typedArray` or `arrayLike` into the receiver, at index
    `offset`. `TypedArray` is a fictitious abstract superclass of all concrete Typed
    Array classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function uses that method to copy zero or more Typed Arrays (or
    Array-like objects) into an instance of `resultConstructor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '32.4 Quick references: indices vs. offsets'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In preparation for the quick references on ArrayBuffers, Typed Arrays, and
    DataViews, we need learn the differences between indices and offsets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Indices for the bracket operator `[ ]`: You can only use non-negative indices
    (starting at 0).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In normal Arrays, writing to negative indices creates properties:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In Typed Arrays, writing to negative indices is ignored:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Indices for methods of ArrayBuffers, Typed Arrays, and DataViews: Every index
    can be negative. If it is, it is added to the length of the entity to produce
    the actual index. Therefore, `-1` refers to the last element, `-2` to the second-last,
    etc. Methods of normal Arrays work the same way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Offsets passed to methods of Typed Arrays and DataViews: must be non-negative
    – for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Whether a parameter is an index or an offset can only be determined by looking
    at documentation; there is no simple rule.
  prefs: []
  type: TYPE_NORMAL
- en: '32.5 Quick reference: ArrayBuffers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ArrayBuffers store binary data, which is meant to be accessed via Typed Arrays
    and DataViews.
  prefs: []
  type: TYPE_NORMAL
- en: 32.5.1 `new ArrayBuffer()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The type signature of the constructor is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Invoking this constructor via `new` creates an instance whose capacity is `length`
    bytes. Each of those bytes is initially 0.
  prefs: []
  type: TYPE_NORMAL
- en: You can’t change the length of an ArrayBuffer; you can only create a new one
    with a different length.
  prefs: []
  type: TYPE_NORMAL
- en: 32.5.2 Static methods of `ArrayBuffer`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`ArrayBuffer.isView(arg: any)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if `arg` is an object and a *view* for an ArrayBuffer (i.e.,
    if it is a Typed Array or a DataView).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 32.5.3 Properties of `ArrayBuffer.prototype`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`get .byteLength(): number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the capacity of this ArrayBuffer in bytes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.slice(startIndex: number, endIndex=this.byteLength)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creates a new ArrayBuffer that contains the bytes of this ArrayBuffer whose
    indices are greater than or equal to `startIndex` and less than `endIndex`. `start`
    and `endIndex` can be negative (see [§32.4 “Quick references: indices vs. offsets”](ch_typed-arrays.html#typed-arrays-indices-offsets)).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '32.6 Quick reference: Typed Arrays'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The properties of the various Typed Array objects are introduced in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TypedArray`: First, we look at the abstract superclass of all Typed Array
    classes (which was shown in the class diagram [at the beginning of this chapter](#fig:typed_arrays_class_diagram)).
    I’m calling that superclass `TypedArray`, but it is not directly accessible from
    JavaScript. `TypedArray.prototype` houses all methods of Typed Arrays.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`«ElementType»Array`: The concrete Typed Array classes are called `Uint8Array`,
    `Int16Array`, `Float32Array`, etc. These are the classes that you use via `new`,
    `.of`, and `.from()`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 32.6.1 Static methods of `TypedArray<T>`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Both static `TypedArray` methods are inherited by its subclasses (`Uint8Array`,
    etc.). `TypedArray` is abstract. Therefore, you always use these methods via the
    subclasses, which are concrete and can have direct instances.
  prefs: []
  type: TYPE_NORMAL
- en: '`.from<S>(source: Iterable<S>|ArrayLike<S>, mapfn?: S => T, thisArg?: any)
    : instanceof this`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converts an iterable (including Arrays and Typed Arrays) or [an Array-like object](ch_arrays.html#array-like-objects)
    to an instance of `this` (`instanceof this` is my invention to express that fact).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The optional `mapfn` lets you transform the elements of `source` before they
    become elements of the result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.of(...items: bigint[]): instanceof this` (`BigInt64Array`, `BigUint64Array`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.of(...items: number[]): instanceof this` (all other Typed Arrays)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a new instance of `this` whose elements are `items` (coerced to the
    element type).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 32.6.2 Properties of `TypedArray<T>.prototype`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Indices accepted by Typed Array methods can be negative (they work like traditional
    Array methods that way). Offsets must be non-negative. For details, see [§32.4
    “Quick references: indices vs. offsets”](ch_typed-arrays.html#typed-arrays-indices-offsets).'
  prefs: []
  type: TYPE_NORMAL
- en: 32.6.2.1 Properties specific to Typed Arrays
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following properties are specific to Typed Arrays; normal Arrays don’t
    have them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get .buffer(): ArrayBuffer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the buffer backing this Typed Array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`get .length(): number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the length in elements of this Typed Array’s buffer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`get .byteLength(): number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the size in bytes of this Typed Array’s buffer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`get .byteOffset(): number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the offset where this Typed Array “starts” inside its ArrayBuffer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.set(typedArray: TypedArray, offset=0): void`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.set(arrayLike: ArrayLike<bigint>, offset=0): void` (`BigInt64Array`, `BigUint64Array`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.set(arrayLike: ArrayLike<number>, offset=0): void` (all other Typed Arrays)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copies all elements of the first parameter to this Typed Array. The element
    at index 0 of the parameter is written to index `offset` of this Typed Array (etc.).
    For more information on Array-like objects, consult [§31.5 “Array-like objects”](ch_arrays.html#array-like-objects).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.subarray(startIndex=0, endIndex=this.length): TypedArray<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a new Typed Array that has the same buffer as this Typed Array, but
    a (generally) smaller range. If `startIndex` is non-negative then the first element
    of the resulting Typed Array is `this[startIndex]`, the second `this[startIndex+1]`
    (etc.). If `startIndex` in negative, it is converted appropriately.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 32.6.2.2 Array methods
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following methods are basically the same as the methods of normal Arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.at(index: number): T | undefined` ^([R, ES2022])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.copyWithin(target: number, start: number, end=this.length): this` ^([W, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.entries(): Iterable<[number, T]>` ^([R, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.every(callback: (value: T, index: number, array: TypedArray<T>) => boolean,
    thisArg?: any): boolean` ^([R, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.fill(value: T, start=0, end=this.length): this` ^([W, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.filter(callback: (value: T, index: number, array: TypedArray<T>) => any,
    thisArg?: any): T[]` ^([R, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.find(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?:
    any): T | undefined` ^([R, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.findIndex(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?:
    any): number` ^([R, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.forEach(callback: (value: T, index: number, array: TypedArray<T>) => void,
    thisArg?: any): void` ^([R, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.includes(searchElement: T, fromIndex=0): boolean` ^([R, ES2016])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.indexOf(searchElement: T, fromIndex=0): number` ^([R, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.join(separator = '',''): string` ^([R, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.keys(): Iterable<number>` ^([R, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.lastIndexOf(searchElement: T, fromIndex=this.length-1): number` ^([R, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.map<U>(mapFunc: (value: T, index: number, array: TypedArray<T>) => U, thisArg?:
    any): U[]` ^([R, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.reduce<U>(callback: (accumulator: U, element: T, index: number, array: T[])
    => U, init?: U): U` ^([R, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.reduceRight<U>(callback: (accumulator: U, element: T, index: number, array:
    T[]) => U, init?: U): U` ^([R, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.reverse(): this` ^([W, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.slice(start=0, end=this.length): T[]` ^([R, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.some(callback: (value: T, index: number, array: TypedArray<T>) => boolean,
    thisArg?: any): boolean` ^([R, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.sort(compareFunc?: (a: T, b: T) => number): this` ^([W, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.toString(): string` ^([R, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.values(): Iterable<T>` ^([R, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For details on how these methods work, see [§31.13.3 “Methods of `Array.prototype`”](ch_arrays.html#quickref-array-prototype).
  prefs: []
  type: TYPE_NORMAL
- en: 32.6.3 `new «ElementType»Array()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Each Typed Array constructor has a name that follows the pattern `«ElementType»Array`,
    where `«ElementType»` is one of the element types in the table at the beginning.
    That means that there are 11 constructors for Typed Arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Float32Array`, `Float64Array`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int8Array`, `Int16Array`, `Int32Array`, `BigInt64Array`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Uint8Array`, `Uint8ClampedArray`, `Uint16Array`, `Uint32Array`, `BigUint64Array`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each constructor has four *overloaded* versions – it behaves differently depending
    on how many arguments it receives and what their types are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`new «ElementType»Array(buffer: ArrayBuffer, byteOffset=0, length=0)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a new `«ElementType»Array` whose buffer is `buffer`. It starts accessing
    the buffer at the given `byteOffset` and will have the given `length`. Note that
    `length` counts elements of the Typed Array (with 1–8 bytes each), not bytes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`new «ElementType»Array(length=0)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creates a new `«ElementType»Array` with the given `length` and the appropriate
    buffer. The buffer’s size in bytes is:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`new «ElementType»Array(source: TypedArray)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a new instance of `«ElementType»Array` whose elements have the same
    values as the elements of `source`, but coerced to `ElementType`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`new «ElementType»Array(source: ArrayLike<bigint>)` (`BigInt64Array`, `BigUint64Array`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new «ElementType»Array(source: ArrayLike<number>)` (all other Typed Arrays)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a new instance of `«ElementType»Array` whose elements have the same
    values as the elements of `source`, but coerced to `ElementType`. For more information
    on Array-like objects, consult [§31.5 “Array-like objects”](ch_arrays.html#array-like-objects).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 32.6.4 Static properties of `«ElementType»Array`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`«ElementType»Array.BYTES_PER_ELEMENT: number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Counts how many bytes are needed to store a single element:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 32.6.5 Properties of `«ElementType»Array.prototype`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`.BYTES_PER_ELEMENT: number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same as `«ElementType»Array.BYTES_PER_ELEMENT`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '32.7 Quick reference: DataViews'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 32.7.1 `new DataView()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`new DataView(buffer: ArrayBuffer, byteOffset=0, byteLength=buffer.byteLength-byteOffset)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a new DataView whose data is stored in the ArrayBuffer `buffer`. By
    default, the new DataView can access all of `buffer`. The last two parameters
    allow you to change that.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 32.7.2 Properties of `DataView.prototype`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the remainder of this section, `«ElementType»` refers to either:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Int8`, `Int16`, `Int32`, `BigInt64`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Uint8`, `Uint16`, `Uint32`, `BigUint64`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Float32`, `Float64`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the properties of `DataView.prototype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get .buffer(): ArrayBuffer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the ArrayBuffer of this DataView.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`get .byteLength(): number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns how many bytes can be accessed by this DataView.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`get .byteOffset(): number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns at which offset this DataView starts accessing the bytes in its buffer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.get«ElementType»(byteOffset: number, littleEndian=false): bigint` (`BigInt64`,
    `BigUint64`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.get«ElementType»(byteOffset: number, littleEndian=false): number` (all other
    element types)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reads a value from the buffer of this DataView.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.set«ElementType»(byteOffset: number, value: bigint, littleEndian=false):
    void` (`BigInt64`, `BigUint64`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.set«ElementType»(byteOffset: number, value: number, littleEndian=false):
    void` (all other element types)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Writes `value` to the buffer of this DataView.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/45)'
  prefs: []
  type: TYPE_NORMAL
