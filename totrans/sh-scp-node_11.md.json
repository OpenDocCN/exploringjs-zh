["```js\nassert.equal(\n fs.readFileSync(\n '/tmp/text-file.txt', {encoding: 'utf-8'}), // (A)\n 'Text content'\n);\nassert.equal(\n fs.readFileSync(\n new URL('file:///tmp/text-file.txt'), {encoding: 'utf-8'}), // (B)\n 'Text content'\n);\n```", "```js\n> new TextEncoder().encode('caf\u00e9')\nUint8Array.of(99, 97, 102, 195, 169)\n> new TextDecoder().decode(Uint8Array.of(99, 97, 102, 195, 169))\n'caf\u00e9'\n```", "```js\nassert.equal(\n fs.readFileSync('text-file.txt', {encoding: 'utf-8'}),\n 'there\\r\\nare\\nmultiple\\nlines'\n);\n```", "```js\nconst RE_SPLIT_EOL = /\\r?\\n/;\nfunction splitLines(str) {\n return str.split(RE_SPLIT_EOL);\n}\nassert.deepEqual(\n splitLines('there\\r\\nare\\nmultiple\\nlines'),\n ['there', 'are', 'multiple', 'lines']\n);\n```", "```js\nconst RE_SPLIT_AFTER_EOL = /(?<=\\r?\\n)/; // (A)\nfunction splitLinesWithEols(str) {\n return str.split(RE_SPLIT_AFTER_EOL);\n}\n\nassert.deepEqual(\n splitLinesWithEols('there\\r\\nare\\nmultiple\\nlines'),\n ['there\\r\\n', 'are\\n', 'multiple\\n', 'lines']\n);\nassert.deepEqual(\n splitLinesWithEols('first\\n\\nthird'),\n ['first\\n', '\\n', 'third']\n);\nassert.deepEqual(\n splitLinesWithEols('EOL at the end\\n'),\n ['EOL at the end\\n']\n);\nassert.deepEqual(\n splitLinesWithEols(''),\n ['']\n);\n```", "```js\nfunction splitLinesWithEols(str) {\n if (str.length === 0) return [''];\n const lines = [];\n let prevEnd = 0;\n while (prevEnd < str.length) {\n // Searching for '\\n' means we\u2019ll also find '\\r\\n'\n const newlineIndex = str.indexOf('\\n', prevEnd);\n // If there is a newline, it\u2019s included in the line\n const end = newlineIndex < 0 ? str.length : newlineIndex+1;\n lines.push(str.slice(prevEnd, end));\n prevEnd = end;\n }\n return lines;\n}\n```", "```js\nimport {Readable} from 'node:stream';\n\nconst nodeReadable = fs.createReadStream(\n 'text-file.txt', {encoding: 'utf-8'});\nconst webReadableStream = Readable.toWeb(nodeReadable);\nconst lineStream = webReadableStream.pipeThrough(\n new ChunksToLinesStream());\nfor await (const line of lineStream) {\n console.log(line);\n}\n\n// Output:\n// 'there\\r\\n'\n// 'are\\n'\n// 'multiple\\n'\n// 'lines'\n```", "```js\nfs.writeFileSync(\n 'new-file.txt',\n 'First line\\nSecond line\\n',\n {encoding: 'utf-8'}\n);\n```", "```js\nfs.appendFileSync(\n 'existing-file.txt',\n 'Appended line\\n',\n {encoding: 'utf-8'}\n);\n```", "```js\nfs.writeFileSync(\n 'existing-file.txt',\n 'Appended line\\n',\n {encoding: 'utf-8', flag: 'a'}\n);\n```", "```js\nimport {Writable} from 'node:stream';\n\nconst nodeWritable = fs.createWriteStream(\n 'new-file.txt', {encoding: 'utf-8'});\nconst webWritableStream = Writable.toWeb(nodeWritable);\n\nconst writer = webWritableStream.getWriter();\ntry {\n await writer.write('First line\\n');\n await writer.write('Second line\\n');\n await writer.close();\n} finally {\n writer.releaseLock()\n}\n```", "```js\nimport {Writable} from 'node:stream';\n\nconst nodeWritable = fs.createWriteStream(\n 'existing-file.txt', {encoding: 'utf-8', flags: 'a'});\nconst webWritableStream = Writable.toWeb(nodeWritable);\n\nconst writer = webWritableStream.getWriter();\ntry {\n await writer.write('First appended line\\n');\n await writer.write('Second appended line\\n');\n await writer.close();\n} finally {\n writer.releaseLock()\n}\n```", "```js\nconst RE_EOL_REMOVE = /\\r?\\n$/;\nfunction removeEol(line) {\n const match = RE_EOL_REMOVE.exec(line);\n if (!match) return line;\n return line.slice(0, match.index);\n}\n\nassert.equal(\n removeEol('Windows EOL\\r\\n'),\n 'Windows EOL'\n);\nassert.equal(\n removeEol('Unix EOL\\n'),\n 'Unix EOL'\n);\nassert.equal(\n removeEol('No EOL'),\n 'No EOL'\n);\n```", "```js\nimport * as path from 'node:path';\n\nfunction* traverseDirectory(dirPath) {\n const dirEntries = fs.readdirSync(dirPath, {withFileTypes: true});\n // Sort the entries to keep things more deterministic\n dirEntries.sort(\n (a, b) => a.name.localeCompare(b.name, 'en')\n );\n for (const dirEntry of dirEntries) {\n const fileName = dirEntry.name;\n const pathName = path.join(dirPath, fileName);\n yield pathName;\n if (dirEntry.isDirectory()) {\n yield* traverseDirectory(pathName);\n }\n }\n}\n```", "```js\nfor (const filePath of traverseDirectory('dir')) {\n console.log(filePath);\n}\n\n// Output:\n// 'dir/dir-file.txt'\n// 'dir/subdir'\n// 'dir/subdir/subdir-file1.txt'\n// 'dir/subdir/subdir-file2.csv'\n```", "```js\nfs.mkdirSync(thePath, options?): undefined | string\n```", "```js\nassert.deepEqual(\n Array.from(traverseDirectory('.')),\n [\n 'dir',\n ]\n);\nfs.mkdirSync('dir/sub/subsub', {recursive: true});\nassert.deepEqual(\n Array.from(traverseDirectory('.')),\n [\n 'dir',\n 'dir/sub',\n 'dir/sub/subsub',\n ]\n);\n```", "```js\nimport * as path from 'node:path';\n\nfunction ensureParentDirectory(filePath) {\n const parentDir = path.dirname(filePath);\n if (!fs.existsSync(parentDir)) {\n fs.mkdirSync(parentDir, {recursive: true});\n }\n}\n```", "```js\nassert.deepEqual(\n Array.from(traverseDirectory('.')),\n [\n 'dir',\n ]\n);\nconst filePath = 'dir/sub/subsub/new-file.txt';\nensureParentDirectory(filePath); // (A)\nfs.writeFileSync(filePath, 'content', {encoding: 'utf-8'});\nassert.deepEqual(\n Array.from(traverseDirectory('.')),\n [\n 'dir',\n 'dir/sub',\n 'dir/sub/subsub',\n 'dir/sub/subsub/new-file.txt',\n ]\n);\n```", "```js\nimport * as os from 'node:os';\nimport * as path from 'node:path';\n\nconst pathPrefix = path.resolve(os.tmpdir(), 'my-app');\n // e.g. '/var/folders/ph/sz0384m11vxf/T/my-app'\n\nconst tmpPath = fs.mkdtempSync(pathPrefix);\n // e.g. '/var/folders/ph/sz0384m11vxf/T/my-app1QXOXP'\n```", "```js\nassert.deepEqual(\n Array.from(traverseDirectory('.')),\n [\n 'dir-orig',\n 'dir-orig/some-file.txt',\n ]\n);\nfs.cpSync('dir-orig', 'dir-copy', {recursive: true});\nassert.deepEqual(\n Array.from(traverseDirectory('.')),\n [\n 'dir-copy',\n 'dir-copy/some-file.txt',\n 'dir-orig',\n 'dir-orig/some-file.txt',\n ]\n);\n```", "```js\nassert.deepEqual(\n Array.from(traverseDirectory('.')),\n [\n 'old-dir-name',\n 'old-dir-name/some-file.txt',\n ]\n);\nfs.renameSync('old-dir-name', 'new-dir-name');\nassert.deepEqual(\n Array.from(traverseDirectory('.')),\n [\n 'new-dir-name',\n 'new-dir-name/some-file.txt',\n ]\n);\n```", "```js\nassert.deepEqual(\n Array.from(traverseDirectory('.')),\n [\n 'dir',\n 'dir/subdir',\n 'dir/subdir/some-file.txt',\n ]\n);\nfs.renameSync('dir/subdir/some-file.txt', 'some-file.txt');\nassert.deepEqual(\n Array.from(traverseDirectory('.')),\n [\n 'dir',\n 'dir/subdir',\n 'some-file.txt',\n ]\n);\n```", "```js\nassert.deepEqual(\n Array.from(traverseDirectory('.')),\n [\n 'dir',\n 'dir/some-file.txt',\n ]\n);\nfs.rmSync('dir/some-file.txt');\nassert.deepEqual(\n Array.from(traverseDirectory('.')),\n [\n 'dir',\n ]\n);\n```", "```js\nassert.deepEqual(\n Array.from(traverseDirectory('.')),\n [\n 'dir',\n 'dir/subdir',\n 'dir/subdir/some-file.txt',\n ]\n);\nfs.rmSync('dir/subdir', {recursive: true});\nassert.deepEqual(\n Array.from(traverseDirectory('.')),\n [\n 'dir',\n ]\n);\n```", "```js\nassert.deepEqual(\n Array.from(traverseDirectory('.')),\n [\n 'dir',\n 'dir/subdir',\n ]\n);\nfs.rmdirSync('dir/subdir');\nassert.deepEqual(\n Array.from(traverseDirectory('.')),\n [\n 'dir',\n ]\n);\n```", "```js\nimport * as path from 'node:path';\n\nfunction clearDirectory(dirPath) {\n for (const fileName of fs.readdirSync(dirPath)) {\n const pathName = path.join(dirPath, fileName);\n fs.rmSync(pathName, {recursive: true});\n }\n}\n```", "```js\nassert.deepEqual(\n Array.from(traverseDirectory('.')),\n [\n 'dir',\n 'dir/dir-file.txt',\n 'dir/subdir',\n 'dir/subdir/subdir-file.txt'\n ]\n);\nclearDirectory('dir');\nassert.deepEqual(\n Array.from(traverseDirectory('.')),\n [\n 'dir',\n ]\n);\n```", "```js\nimport trash from 'trash';\n\nawait trash(['*.png', '!rainbow.png']);\n```", "```js\nassert.deepEqual(\n Array.from(traverseDirectory('.')),\n [\n 'dir',\n 'dir/some-file.txt',\n ]\n);\nassert.equal(\n fs.existsSync('dir'), true\n);\nassert.equal(\n fs.existsSync('dir/some-file.txt'), true\n);\nassert.equal(\n fs.existsSync('dir/non-existent-file.txt'), false\n);\n```", "```js\nfunction isDirectory(thePath) {\n const stats = fs.statSync(thePath, {throwIfNoEntry: false});\n return stats !== undefined && stats.isDirectory();\n}\n\nassert.deepEqual(\n Array.from(traverseDirectory('.')),\n [\n 'dir',\n 'dir/some-file.txt',\n ]\n);\n\nassert.equal(\n isDirectory('dir'), true\n);\nassert.equal(\n isDirectory('dir/some-file.txt'), false\n);\nassert.equal(\n isDirectory('non-existent-dir'), false\n);\n```"]