- en: 31 Classes ES6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_classes.html](https://exploringjs.com/js/book/ch_classes.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[31.1 Cheat sheet: classes](#cheat-sheet-classes)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.2 The essentials of classes](#classes)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.2.1 A class for persons](#a-class-for-persons)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.2.2 Class expressions](#class-expressions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.2.3 The `instanceof` operator](#the-instanceof-operator)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.2.4 Public slots (properties) vs. private slots](#private-slots)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.2.5 Private slots in more detail ^(ES2022) (advanced)](#private-slots-in-more-detail-es2022-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.2.6 The pros and cons of classes in JavaScript](#the-pros-and-cons-of-classes-in-javascript)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.2.7 Tips for using classes](#tips-for-using-classes)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.3 The internals of classes](#internals-of-classes)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.3.1 A class is actually two connected objects](#a-class-is-actually-two-connected-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.3.2 Classes set up the prototype chains of their instances](#classes-set-up-the-prototype-chains-of-their-instances)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.3.3 `.__proto__` vs. `.prototype`](#proto-vs-prototype)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.3.4 `Person.prototype.constructor` (advanced)](#personprototypeconstructor-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.3.5 Dispatched vs. direct method calls (advanced)](#method-calls-dispatched-direct)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.3.6 Classes evolved from ordinary functions (advanced)](#classes-evolved-from-ordinary-functions-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.4 Prototype members of classes](#prototype-members-of-classes)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.4.1 Public prototype methods and accessors](#public-prototype-methods-and-accessors)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.4.2 Private methods and accessors ^(ES2022)](#private-methods-accessors)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.5 Instance members of classes ^(ES2022)](#instance-members-of-classes-es2022)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.5.1 Instance public fields](#instance-public-fields)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.5.2 Instance private fields](#instance-private-fields)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.5.3 Private instance data before ES2022 (advanced)](#private-instance-data-before-es2022-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.5.4 Simulating protected visibility and friend visibility via WeakMaps
    (advanced)](#instance-protected-fields)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.6 Static members of classes](#static-members-of-classes)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.6.1 Static public methods and accessors](#static-public-methods-and-accessors)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.6.2 Static public fields ^(ES2022)](#static-public-fields)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.6.3 Static private methods, accessors, and fields ^(ES2022)](#static-private-methods-accessors-fields)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.6.4 Static initialization blocks in classes ^(ES2022)](#class-static-initialization-blocks)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.6.5 Pitfall: Using `this` to access static private fields](#this-and-static-private-fields)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.6.6 All members (static, prototype, instance) can access all private members](#all-members-static-prototype-instance-can-access-all-private-members)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.6.7 Static private methods and data before ES2022](#static-private-methods-and-data-before-es2022)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.6.8 Static factory methods](#static-factory-methods)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.7 Subclassing](#subclassing)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.7.1 Defining subclasses via `extends`](#defining-subclasses-via-extends)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.7.2 The internals of subclassing (advanced)](#internals-of-subclassing)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.7.3 The `instanceof` operator in detail (advanced)](#instanceof-operator-details)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.7.4 Not all objects are instances of `Object` (advanced)](#non-instances-of-object)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.7.5 Base class vs. derived class (advanced)](#base-class-vs-derived-class-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.7.6 The prototype chains of plain objects and Arrays (advanced)](#prototype-chains-of-builtin-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.8 Mixin classes (advanced)](#mixin-classes-advanced)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.8.1 Example: a mixin for name management](#example-a-mixin-for-name-management)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.8.2 The benefits of mixins](#the-benefits-of-mixins)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.9 The methods and accessors of `Object.prototype` (advanced)](#the-methods-and-accessors-of-objectprototype-advanced)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.9.1 Using `Object.prototype` methods safely](#using-object-methods-safely)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.9.2 `Object.prototype.toString()` ^(ES1)](#Object.prototype.toString)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.9.3 `Object.prototype.toLocaleString()` ^(ES3)](#Object.prototype.toLocaleString)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.9.4 `Object.prototype.valueOf()` ^(ES1)](#Object.prototype.valueOf)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.9.5 `Object.prototype.isPrototypeOf()` ^(ES3)](#Object.prototype.isPrototypeOf)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.9.6 `Object.prototype.propertyIsEnumerable()` ^(ES3)](#Object.prototype.propertyIsEnumerable)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.9.7 `Object.prototype.__proto__` (accessor) ^(ES6)](#Object.prototype.__proto__)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.9.8 `Object.prototype.hasOwnProperty()` ^(ES3)](#Object.prototype.hasOwnProperty)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.10 Quick reference: `Object.prototype.*`](#quickref-object-prototype)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.10.1 `Object.prototype.*`: configuring how objects are converted to primitive
    values](#objectprototype-configuring-how-objects-are-converted-to-primitive-values)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.10.2 `Object.prototype.*`: useful methods with pitfalls](#objectprototype-useful-methods-with-pitfalls)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.10.3 `Object.prototype.*`: methods to avoid](#objectprototype-methods-to-avoid)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.11 FAQ: classes](#faq-classes)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.11.1 Why are they called “instance private fields” in this book and not
    “private instance fields”?](#why-are-they-called-instance-private-fields-in-this-book-and-not-private-instance-fields)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.11.2 Why the identifier prefix `#`? Why not declare private fields via
    `private`?](#why-the-identifier-prefix--why-not-declare-private-fields-via-private)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this book, JavaScript’s style of object-oriented programming (OOP) is introduced
    in four steps. This chapter covers step 3 and 4, [the previous chapter](ch_objects.html#ch_objects)
    covers step 1 and 2\. The steps are ([figure 31.1](#fig:oop_steps_3_4)):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single objects (previous chapter):** How do *objects*, JavaScript’s basic
    OOP building blocks, work in isolation?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Prototype chains (previous chapter):** Each object has a chain of zero or
    more *prototype objects*. Prototypes are JavaScript’s core inheritance mechanism.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Classes (this chapter):** JavaScript’s *classes* are factories for objects.
    The relationship between a class and its instances is based on prototypal inheritance
    (step 2).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Subclassing (this chapter):** The relationship between a *subclass* and its
    *superclass* is also based on prototypal inheritance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../Images/211f8dccf8d4dc41541fb43a82eac91f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 31.1: This book introduces object-oriented programming in JavaScript
    in four steps.'
  prefs: []
  type: TYPE_NORMAL
- en: '[31.1 Cheat sheet: classes](#cheat-sheet-classes)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A JavaScript class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Explanations:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside a class, `this` refers to the current instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line A: constructor of the class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line B: Property `.firstName` (a public slot) is created (no prior declaration
    necessary).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line C: method `.describe()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public instance data such as `.firstName` is relatively common in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same class `Person`, but with private instance data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Explanations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Line A: private field `.#firstName`. In contrast to properties, private fields
    must be declared (line A) before they can be used (line B). A private field can
    only be accessed inside the class that declares it. It can’t even be accessed
    by subclasses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Class `Employee` is a subclass of `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3][PRE4][PRE5][PRE6][PRE7][PRE8][PRE9][PRE10]``js[PRE11]js[PRE12]js[PRE13]js[PRE14]``js[PRE15]js[PRE16]js[PRE17]js
    JavaScript also supports `static` members, but external functions and variables
    are often preferred.    ### [31.2 The essentials of classes](#classes)    Classes
    are basically a compact syntax for setting up prototype chains (which are explained
    in [the previous chapter](ch_objects.html#prototype-chains)). Under the hood,
    JavaScript’s classes are unconventional. But that is something we rarely see when
    working with them. They should normally feel familiar to people who have used
    other object-oriented programming languages.    Note that we don’t need classes
    to create objects. We can also do so via [object literals](ch_objects.html#object-literals).
    That’s why the singleton pattern isn’t needed in JavaScript and classes are used
    less than in many other languages that have them.    #### [31.2.1 A class for
    persons](#a-class-for-persons)    [We have previously worked with `jane` and `tarzan`,
    single objects representing persons](ch_objects.html#sharing-data-via-prototypes).
    Let’s use a *class declaration* to implement a factory for such objects:    [PRE18]js    `jane`
    and `tarzan` can now be created via `new Person()`:    [PRE19]js    Let’s examine
    what’s inside the body of class `Person`.    *   `.constructor()` is a special
    method that is called after the creation of a new instance. Inside it, `this`
    refers to that instance.           *   `.#firstName` ^(ES2022) is an *instance
    private field*: Such fields are stored in instances. They are accessed similarly
    to properties, but their names are separate – they always start with hash symbols
    (`#`). And they are invisible to the world outside the class:                    [PRE20]js                    Before
    we can initialize `.#firstName` in the constructor (line B), we need to declare
    it by mentioning it in the class body (line A).           *   `.describe()` is
    a method. If we invoke it via `obj.describe()` then `this` refers to `obj` inside
    the body of `.describe()`.                    [PRE21]js           *   `.extractName()`
    is a *static* method. “Static” means that it belongs to the class, not to instances:                    [PRE22]js              We
    can also create instance properties (public fields) in constructors:    [PRE23]js    In
    contrast to instance private fields, instance properties don’t have to be declared
    in class bodies.    #### [31.2.2 Class expressions](#class-expressions)    There
    are two kinds of *class definitions* (ways of defining classes):    *   *Class
    declarations*, which we have seen in the previous section. *   *Class expressions*,
    which we’ll see next.    Class expressions can be anonymous and named:    [PRE24]js   [PRE25]`js[PRE26]js[PRE27]js[PRE28]js[PRE29]js[PRE30]js[PRE31]js[PRE32]js[PRE33]js[PRE34]js[PRE35]js[PRE36]js[PRE37]js[PRE38]js[PRE39]js[PRE40]`js[PRE41]js[PRE42]js[PRE43]js[PRE44]js[PRE45]js[PRE46][PRE47][PRE48][PRE49][PRE50][PRE51][PRE52]js
    assert.deepEqual(  Reflect.ownKeys(Person.prototype),  [''constructor'', ''describe'']
    );  [PRE53]js const jane = new Person(''Jane''); assert.equal(  Object.getPrototypeOf(jane),
    Person.prototype );  `const tarzan = new Person(''Tarzan'');` `assert.equal(`  `Object.getPrototypeOf(tarzan),
    Person.prototype` `);`  [PRE54]js[PRE55]js[PRE56]js[PRE57]js[PRE58]js[PRE59]js[PRE60][PRE61][PRE62][PRE63][PRE64][PRE65]
    #### [31.3.6 Classes evolved from ordinary functions (advanced)](#classes-evolved-from-ordinary-functions-advanced)    Before
    ECMAScript 6, JavaScript didn’t have classes. Instead, [ordinary functions](ch_callables.html#ordinary-functions)
    were used as *constructor functions*:    [PRE66]js   [PRE67]`js[PRE68]js[PRE69]js[PRE70]js[PRE71]js`
    `extends` and subclassing are explained [later in this chapter](#subclassing).    #####
    [31.3.6.1 A class is the constructor](#a-class-is-the-constructor)    This brings
    us to an interesting insight. On one hand, `StringBuilderClass` refers to its
    constructor via `StringBuilderClass.prototype.constructor`.    On the other hand,
    the class *is* the constructor (a function):    [PRE72]js    ![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **Constructor
    (functions) vs. classes**    Due to how similar they are, I use the terms *constructor
    (function)* and *class* interchangeably.    ### [31.4 Prototype members of classes](#prototype-members-of-classes)    ####
    [31.4.1 Public prototype methods and accessors](#public-prototype-methods-and-accessors)    All
    members in the body of the following class declaration create properties of `PublicProtoClass.prototype`.    [PRE73]js   [PRE74]`js[PRE75]js[PRE76]js[PRE77]js[PRE78]js[PRE79]js[PRE80]js[PRE81]js[PRE82]js[PRE83]js[PRE84]js[PRE85]js[PRE86]`js[PRE87]js[PRE88]js[PRE89]js[PRE90][PRE91][PRE92][PRE93][PRE94]js
    const _counter = new WeakMap(); const _action = new WeakMap();  `class Countdown
    {`  `constructor(counter, action) {`  `_counter.set(this, counter);`  `_action.set(this,
    action);`  `}`  `dec() {`  `let counter = _counter.get(this);`  `counter--;`  `_counter.set(this,
    counter);`  `if (counter === 0) {`  `_action.get(this)();`  `}`  `}` `}`  `` `//
    The two pseudo-properties are truly private:` `assert.deepEqual(`  `Object.keys(new
    Countdown()),`  `[]);` ``  [PRE95]js[PRE96]js[PRE97]js[PRE98]js[PRE99][PRE100][PRE101][PRE102]
    This technique doesn’t really support private methods. But module-local functions
    that have access to `_superProp` are the next best thing:    [PRE103]js   [PRE104]`js[PRE105]js[PRE106]js`
    Note that `this` becomes the explicit function parameter `_this` (line A).    ####
    [31.5.4 Simulating protected visibility and friend visibility via WeakMaps (advanced)](#instance-protected-fields)    As
    previously discussed, instance private fields are only visible inside their classes
    and not even in subclasses. Thus, there is no built-in way to get:    *   Protected
    visibility: A class and all of its subclasses can access a piece instance data.
    *   Friend visibility: A class and its “friends” (designated functions, objects,
    or classes) can access a piece of instance data.    In the previous subsection,
    we simulated “module visibility” (everyone inside a module has access to a piece
    of instance data) via WeakMaps. Therefore:    *   If we put a class and its subclasses
    into the same module, we get protected visibility. *   If we put a class and its
    friends into the same module, we get friend visibility.    The next example demonstrates
    protected visibility:    [PRE107]js    [Subclassing via `extends`](#subclassing)
    is explained later in this chapter.    ### [31.6 Static members of classes](#static-members-of-classes)    ####
    [31.6.1 Static public methods and accessors](#static-public-methods-and-accessors)    All
    members in the body of the following class declaration create so-called *static*
    properties – properties of `StaticClass` itself.    [PRE108]js    ##### [31.6.1.1 All
    kinds of static public methods and accessors (advanced)](#all-kinds-of-static-public-methods-and-accessors-advanced)    [PRE109]js`
    `// Quoted keys`  `static get ''an accessor''() {}`  `static set ''an accessor''(value)
    {}`  `static ''sync method''() {}`  `static * ''sync generator method''() {}`  `static
    async ''async method''() {}`  `static async * ''async generator method''() {}`  [PRE110]js
    [PRE111]``js[PRE112]js[PRE113][PRE114][PRE115]`` Quoted and computed keys can
    also be used in object literals:    *   [“Quoted keys in object literals” (§30.9.1)](ch_objects.html#object-literals-quoted-keys)
    *   [“Computed keys in object literals” (§30.9.2)](ch_objects.html#object-literals-computed-keys)    More
    information on accessors (defined via getters and/or setters), generators, async
    methods, and async generator methods:    *   [“Object literals: accessors” (§30.3.6)](ch_objects.html#object-literal-accessors)
    *   [“Synchronous generators ^(ES6) (advanced)” (§33)](ch_sync-generators.html#ch_sync-generators)
    *   [“Async functions ^(ES2017)” (§44)](ch_async-functions.html#ch_async-functions)
    *   [“Asynchronous generators” (§45.2)](ch_async-iteration.html#async-generators)    ####
    [31.6.2 Static public fields ^(ES2022)](#static-public-fields)    The following
    code demonstrates static public fields. `StaticPublicFieldClass` has three of
    them:    [PRE116]   [PRE117][PRE118][PRE119]`` [PRE120][PRE121][PRE122]` ####
    [31.6.3 Static private methods, accessors, and fields ^(ES2022)](#static-private-methods-accessors-fields)    The
    following class has two static private slots (line A and line B):    [PRE123]   [PRE124][PRE125][PRE126]
    [PRE127]`js[PRE128]`js[PRE129]js[PRE130][PRE131][PRE132]js[PRE133]js[PRE134][PRE135]
    I like how descriptive static factory methods are: `fromPolar` describes how an
    instance is created. JavaScript’s standard library also has such factory methods
    – for example:    *   `Array.from()` *   `Object.create()`    I prefer to either
    have no static factory methods or *only* static factory methods. Things to consider
    in the latter case:    *   One factory method will probably directly call the
    constructor (but have a descriptive name). *   We need to find a way to prevent
    the constructor being called from outside.    In the following code, we use a
    secret token (line A) to prevent the constructor being called from outside the
    current module.    [PRE136]js   [PRE137] ### [31.7 Subclassing](#subclassing)    ####
    [31.7.1 Defining subclasses via `extends`](#defining-subclasses-via-extends)    Classes
    can extend existing classes. For example, the following class `Employee` extends
    `Person`:    [PRE138]   [PRE139][PRE140]``js[PRE141]`` In the next example, `obj1`
    and `obj2` are both objects (line A and line C), but they are not instances of
    `Object` (line B and line D): `Object.prototype` is not in their prototype chains
    because they don’t have any prototypes.    [PRE142]   [PRE143]`` `Object.prototype`
    is the object that ends most prototype chains. Its prototype is `null`, which
    means it isn’t an instance of `Object` either:    [PRE144]    #### [31.7.5 Base
    class vs. derived class (advanced)](#base-class-vs-derived-class-advanced)    A
    base class is different from a class that extends `Object`.    The following class
    is derived from class `Object`. [Figure 31.5](#fig:class-derived) shows its object
    diagram.    [PRE145]    ![](../Images/ccf6009e97e345718b2e2852460148fd.png)      Figure
    31.5: Object diagram for class `DerivedClass` and its instance `derivedInstance`:
    Both `Object` and `DerivedClass` appear in the class prototype chain (left column).
    They both contribute prototypes to the instance prototype chain (right column).      In
    contrast, the following class is a base class. [Figure 31.6](#fig:class-base)
    shows its object diagram.    [PRE146]    ![](../Images/d47fa0c82efa7280cc3139a980d91244.png)      Figure
    31.6: Object diagram for class `BaseClass` and its instance `baseInstance`: The
    instance prototype chain (right column) is the same as for `derivedInstance`.
    However, `Object` does not appear in the class prototype chain (left column).      ####
    [31.7.6 The prototype chains of plain objects and Arrays (advanced)](#prototype-chains-of-builtin-objects)    Next,
    we’ll use our knowledge of subclassing to understand the prototype chains of plain
    objects and Arrays. The following tool function `p()` helps us with our explorations:    [PRE147]    We
    extracted method `.getPrototypeOf()` of `Object` and assigned it to `p`.    #####
    [31.7.6.1 The prototype chains of plain objects](#the-prototype-chains-of-plain-objects)    Let’s
    explore the prototype chain of a plain object:    [PRE148]    [Figure 31.7](#fig:builtin-object)
    shows a diagram for a plain object and its class `Object`.    ![](../Images/9a2acdc1ab742c804e273ce5af871ba1.png)      Figure
    31.7: The prototype of the empty plain object `{}` is `Object.prototype` – which
    makes it an instance of the class `Object`.      ##### [31.7.6.2 The prototype
    chains of Arrays](#the-prototype-chains-of-arrays)    Let’s explore the prototype
    chain of an Array:    [PRE149]    [Figure 31.8](#fig:builtin-array) shows a diagram
    for an Array and its class `Array`.    ![](../Images/2d8acaa0b29263257e64a3d6f87074a8.png)      Figure
    31.8: The empty Array `[]` is an instance of `Array` (via `Array.prototype`) and
    an instance of `Object` (via `Object.prototype`). However, class `Array` is not
    derived from class `Object` – it is a base class.      It’s interesting that `Array`
    is a base class:    [PRE150]    Therefore, all instances of `Array` are also instances
    of `Object` – yet `Array` is not a subclass of `Object`. This divergence is only
    possible because the instance prototype chain is separate from the class prototype
    chain in JavaScript.    Why isn’t `Object` the prototype of `Array`? One reason
    is that it has been this way since long before classes were added to JavaScript
    and can’t really be changed due to the importance of backward compatibility in
    JavaScript. Another reason is that base classes are where instances are actually
    created. `Array` needs to create its own instances because they have so-called
    “internal slots” which can’t be added later to instances created by `Object`.    #####
    [31.7.6.3 The prototype chains of functions](#the-prototype-chains-of-functions)    Functions
    are similar to Arrays. On one hand, `Function` is a base class:    [PRE151]    On
    the other hand, function objects are instances of `Object`:    [PRE152]    ###
    [31.8 Mixin classes (advanced)](#mixin-classes-advanced)    JavaScript’s class
    system only supports *single inheritance*. That is, each class can have at most
    one superclass. One way around this limitation is via a technique called *mixin
    classes* (short: *mixins*).    The idea is as follows: Let’s say we want a class
    `C` to inherit from two superclasses `S1` and `S2`. That would be *multiple inheritance*,
    which JavaScript doesn’t support.    Our workaround is to turn `S1` and `S2` into
    *mixins*, factories for subclasses:    [PRE153]    Each of these two functions
    returns a class that extends a given superclass `Sup`. We create class `C` as
    follows:    [PRE154]    We now have a class `C` that extends the class returned
    by `S2()` which extends the class returned by `S1()` which extends `Object`.    ####
    [31.8.1 Example: a mixin for name management](#example-a-mixin-for-name-management)    We
    implement a mixin `Named` adds a property `.name` and a method `.toString()` to
    its superclass:    [PRE155]    We use this mixin to implement a class `City` that
    has a name:    [PRE156]    The following code confirms that the mixin works:    [PRE157]    ####
    [31.8.2 The benefits of mixins](#the-benefits-of-mixins)    Mixins free us from
    the constraints of single inheritance:    *   The same class can extend a single
    superclass and zero or more mixins. *   The same mixin can be used by multiple
    classes.    ### [31.9 The methods and accessors of `Object.prototype` (advanced)](#the-methods-and-accessors-of-objectprototype-advanced)    ####
    [31.9.1 Using `Object.prototype` methods safely](#using-object-methods-safely)    Invoking
    one of the methods of `Object.prototype` on an arbitrary object doesn’t always
    work. To illustrate why, we use method `Object.prototype.hasOwnProperty`, which
    returns `true` if an object has an own property with a given key:    [PRE158]    Invoking
    `.hasOwnProperty()` on an arbitrary object can fail in two ways. On one hand,
    this method isn’t available if an object is not an instance of `Object` (see [“Not
    all objects are instances of `Object` (advanced)” (§31.7.4)](#non-instances-of-object)):    [PRE159]    On
    the other hand, we can’t use `.hasOwnProperty()` if an object overrides it with
    an own property (line A):    [PRE160]    There is, however, a safe way to use
    `.hasOwnProperty()`:    [PRE161]    The method invocation in line A is explained
    in [“Dispatched vs. direct method calls (advanced)” (§31.3.5)](#method-calls-dispatched-direct).    We
    can also use [`.bind()`](ch_objects.html#methods-bind) to implement `hasOwnProp()`:    [PRE162]    How
    does this code work? In line A in the example before the code above, we used the
    function method `.call()` to turn the function `hasOwnProperty` with one implicit
    parameter (`this`) and one explicit parameter (`propName`) into a function that
    has two explicit parameters (`obj` and `propName`).    In other words – method
    `.call()` invokes the function `f` referred to by its receiver (`this`):    *   The
    first (explicit) parameter of `.call()` becomes the `this` of `f`. *   The second
    (explicit) parameter of `.call()` becomes the first argument of `f`. *   Etc.    We
    use `.bind()` to create a version `.call()` whose `this` always refers to `Object.prototype.hasOwnProperty`.
    That new version invokes `.hasOwnProperty()` in the same manner as we did in line
    A – which is what we want.    ![Icon “question”](../Images/3decb3ca67c240d2bb04742c1f28af18.png) **Is
    it never OK to use `Object.prototype` methods via dynamic dispatch?**    In some
    cases we can be lazy and call `Object.prototype` methods like normal methods:
    If we know the receivers and they are fixed-layout objects.    If, on the other
    hand, we don’t know their receivers and/or they are dictionary objects, then we
    need to take precautions.    #### [31.9.2 `Object.prototype.toString()` ^(ES1)](#Object.prototype.toString)    By
    overriding `.toString()` (in a subclass or an instance), we can configure how
    objects are converted to strings:    [PRE163]    For converting objects to strings
    it’s better to use `String()` because that also works with `undefined` and `null`:    [PRE164]    ####
    [31.9.3 `Object.prototype.toLocaleString()` ^(ES3)](#Object.prototype.toLocaleString)    `.toLocaleString()`
    is a version of `.toString()` that can be configured via a locale and often additional
    options. Any class or instance can implement this method. In the standard library,
    the following classes do:    *   `Number.prototype.toLocaleString()`                    [PRE165]           *   `BigInt.prototype.toLocaleString()`           *   `Array.prototype.toLocaleString()`                    [PRE166]           *   `TypedArray.prototype.toLocaleString()`           *   `Date.prototype.toLocaleString()`              Thanks
    to the [ECMAScript Internationalization API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Internationalization)
    (`Intl` etc.), there are a variety of formatting options:    [PRE167]   [PRE168]`
    #### [31.9.4 `Object.prototype.valueOf()` ^(ES1)](#Object.prototype.valueOf)    By
    overriding `.valueOf()` (in a subclass or an instance), we can configure how objects
    are converted to non-string values (often numbers):    [PRE169]    #### [31.9.5 `Object.prototype.isPrototypeOf()`
    ^(ES3)](#Object.prototype.isPrototypeOf)    `proto.isPrototypeOf(obj)` returns
    `true` if `proto` is in the prototype chain of `obj` and `false` otherwise.    [PRE170]   [PRE171]
    [PRE172]`js [PRE173]js`` [PRE174]js[PRE175][PRE176][PRE177][PRE178]js[PRE179]js`
    [PRE180]`js`` [PRE181]`js[PRE182][PRE183][PRE184] [PRE185][PRE186][PRE187][PRE188][PRE189]``
    [PRE190][PRE191][PRE192] [PRE193]`js[PRE194]js[PRE195]js[PRE196]js[PRE197]js[PRE198]js`
    [PRE199]`js[PRE200]js[PRE201]js[PRE202][PRE203][PRE204][PRE205][PRE206]``js[PRE207]js[PRE208]js[PRE209]js[PRE210][PRE211][PRE212][PRE213][PRE214]
    [PRE215][PRE216][PRE217][PRE218][PRE219][PRE220][PRE221][PRE222][PRE223]`` [PRE224][PRE225][PRE226][PRE227][PRE228]
    [PRE229]`js[PRE230]js[PRE231]js[PRE232]js[PRE233]js[PRE234]js[PRE235]js[PRE236]js[PRE237]js[PRE238]js[PRE239]js`
    [PRE240]`js[PRE241]js[PRE242]js[PRE243]js[PRE244]js[PRE245][PRE246][PRE247][PRE248][PRE249][PRE250][PRE251]``js[PRE252]js[PRE253]js[PRE254]js[PRE255]js[PRE256]js[PRE257][PRE258][PRE259][PRE260][PRE261][PRE262][PRE263]
    [PRE264][PRE265][PRE266][PRE267][PRE268][PRE269][PRE270][PRE271][PRE272][PRE273][PRE274][PRE275][PRE276]``
    [PRE277][PRE278][PRE279][PRE280][PRE281][PRE282][PRE283] [PRE284]`js[PRE285]js[PRE286]js[PRE287]js[PRE288]js[PRE289]js[PRE290]js[PRE291]js[PRE292]js[PRE293]js[PRE294]js[PRE295]js[PRE296]js[PRE297]js[PRE298]js[PRE299]js`
    [PRE300]`js[PRE301]js[PRE302]js[PRE303]'
  prefs: []
  type: TYPE_NORMAL
