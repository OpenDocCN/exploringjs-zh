- en: 31 Classes ES6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_classes.html](https://exploringjs.com/js/book/ch_classes.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[31.1 Cheat sheet: classes](#cheat-sheet-classes)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.2 The essentials of classes](#classes)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.2.1 A class for persons](#a-class-for-persons)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.2.2 Class expressions](#class-expressions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.2.3 The `instanceof` operator](#the-instanceof-operator)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.2.4 Public slots (properties) vs. private slots](#private-slots)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.2.5 Private slots in more detail ^(ES2022) (advanced)](#private-slots-in-more-detail-es2022-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.2.6 The pros and cons of classes in JavaScript](#the-pros-and-cons-of-classes-in-javascript)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.2.7 Tips for using classes](#tips-for-using-classes)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.3 The internals of classes](#internals-of-classes)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.3.1 A class is actually two connected objects](#a-class-is-actually-two-connected-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.3.2 Classes set up the prototype chains of their instances](#classes-set-up-the-prototype-chains-of-their-instances)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.3.3 `.__proto__` vs. `.prototype`](#proto-vs-prototype)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.3.4 `Person.prototype.constructor` (advanced)](#personprototypeconstructor-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.3.5 Dispatched vs. direct method calls (advanced)](#method-calls-dispatched-direct)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.3.6 Classes evolved from ordinary functions (advanced)](#classes-evolved-from-ordinary-functions-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.4 Prototype members of classes](#prototype-members-of-classes)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.4.1 Public prototype methods and accessors](#public-prototype-methods-and-accessors)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.4.2 Private methods and accessors ^(ES2022)](#private-methods-accessors)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.5 Instance members of classes ^(ES2022)](#instance-members-of-classes-es2022)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.5.1 Instance public fields](#instance-public-fields)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.5.2 Instance private fields](#instance-private-fields)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.5.3 Private instance data before ES2022 (advanced)](#private-instance-data-before-es2022-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.5.4 Simulating protected visibility and friend visibility via WeakMaps
    (advanced)](#instance-protected-fields)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.6 Static members of classes](#static-members-of-classes)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.6.1 Static public methods and accessors](#static-public-methods-and-accessors)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.6.2 Static public fields ^(ES2022)](#static-public-fields)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.6.3 Static private methods, accessors, and fields ^(ES2022)](#static-private-methods-accessors-fields)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.6.4 Static initialization blocks in classes ^(ES2022)](#class-static-initialization-blocks)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.6.5 Pitfall: Using `this` to access static private fields](#this-and-static-private-fields)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.6.6 All members (static, prototype, instance) can access all private members](#all-members-static-prototype-instance-can-access-all-private-members)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.6.7 Static private methods and data before ES2022](#static-private-methods-and-data-before-es2022)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.6.8 Static factory methods](#static-factory-methods)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.7 Subclassing](#subclassing)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.7.1 Defining subclasses via `extends`](#defining-subclasses-via-extends)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.7.2 The internals of subclassing (advanced)](#internals-of-subclassing)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.7.3 The `instanceof` operator in detail (advanced)](#instanceof-operator-details)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.7.4 Not all objects are instances of `Object` (advanced)](#non-instances-of-object)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.7.5 Base class vs. derived class (advanced)](#base-class-vs-derived-class-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.7.6 The prototype chains of plain objects and Arrays (advanced)](#prototype-chains-of-builtin-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.8 Mixin classes (advanced)](#mixin-classes-advanced)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.8.1 Example: a mixin for name management](#example-a-mixin-for-name-management)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.8.2 The benefits of mixins](#the-benefits-of-mixins)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.9 The methods and accessors of `Object.prototype` (advanced)](#the-methods-and-accessors-of-objectprototype-advanced)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.9.1 Using `Object.prototype` methods safely](#using-object-methods-safely)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.9.2 `Object.prototype.toString()` ^(ES1)](#Object.prototype.toString)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.9.3 `Object.prototype.toLocaleString()` ^(ES3)](#Object.prototype.toLocaleString)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.9.4 `Object.prototype.valueOf()` ^(ES1)](#Object.prototype.valueOf)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.9.5 `Object.prototype.isPrototypeOf()` ^(ES3)](#Object.prototype.isPrototypeOf)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.9.6 `Object.prototype.propertyIsEnumerable()` ^(ES3)](#Object.prototype.propertyIsEnumerable)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.9.7 `Object.prototype.__proto__` (accessor) ^(ES6)](#Object.prototype.__proto__)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.9.8 `Object.prototype.hasOwnProperty()` ^(ES3)](#Object.prototype.hasOwnProperty)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.10 Quick reference: `Object.prototype.*`](#quickref-object-prototype)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.10.1 `Object.prototype.*`: configuring how objects are converted to primitive
    values](#objectprototype-configuring-how-objects-are-converted-to-primitive-values)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.10.2 `Object.prototype.*`: useful methods with pitfalls](#objectprototype-useful-methods-with-pitfalls)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.10.3 `Object.prototype.*`: methods to avoid](#objectprototype-methods-to-avoid)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.11 FAQ: classes](#faq-classes)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.11.1 Why are they called “instance private fields” in this book and not
    “private instance fields”?](#why-are-they-called-instance-private-fields-in-this-book-and-not-private-instance-fields)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[31.11.2 Why the identifier prefix `#`? Why not declare private fields via
    `private`?](#why-the-identifier-prefix--why-not-declare-private-fields-via-private)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this book, JavaScript’s style of object-oriented programming (OOP) is introduced
    in four steps. This chapter covers step 3 and 4, [the previous chapter](ch_objects.html#ch_objects)
    covers step 1 and 2\. The steps are ([figure 31.1](#fig:oop_steps_3_4)):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single objects (previous chapter):** How do *objects*, JavaScript’s basic
    OOP building blocks, work in isolation?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Prototype chains (previous chapter):** Each object has a chain of zero or
    more *prototype objects*. Prototypes are JavaScript’s core inheritance mechanism.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Classes (this chapter):** JavaScript’s *classes* are factories for objects.
    The relationship between a class and its instances is based on prototypal inheritance
    (step 2).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Subclassing (this chapter):** The relationship between a *subclass* and its
    *superclass* is also based on prototypal inheritance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../Images/211f8dccf8d4dc41541fb43a82eac91f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 31.1: This book introduces object-oriented programming in JavaScript
    in four steps.'
  prefs: []
  type: TYPE_NORMAL
- en: '[31.1 Cheat sheet: classes](#cheat-sheet-classes)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A JavaScript class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Explanations:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside a class, `this` refers to the current instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line A: constructor of the class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line B: Property `.firstName` (a public slot) is created (no prior declaration
    necessary).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line C: method `.describe()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public instance data such as `.firstName` is relatively common in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same class `Person`, but with private instance data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Explanations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Line A: private field `.#firstName`. In contrast to properties, private fields
    must be declared (line A) before they can be used (line B). A private field can
    only be accessed inside the class that declares it. It can’t even be accessed
    by subclasses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Class `Employee` is a subclass of `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Line A: In subclasses, we can omit the constructor. If we don’t, we have to
    call `super()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line B: We can refer to overridden methods via `super`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next class demonstrates how to create properties via *public fields* (line
    A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript also supports `static` members, but external functions and variables
    are often preferred.
  prefs: []
  type: TYPE_NORMAL
- en: '[31.2 The essentials of classes](#classes)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes are basically a compact syntax for setting up prototype chains (which
    are explained in [the previous chapter](ch_objects.html#prototype-chains)). Under
    the hood, JavaScript’s classes are unconventional. But that is something we rarely
    see when working with them. They should normally feel familiar to people who have
    used other object-oriented programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we don’t need classes to create objects. We can also do so via [object
    literals](ch_objects.html#object-literals). That’s why the singleton pattern isn’t
    needed in JavaScript and classes are used less than in many other languages that
    have them.
  prefs: []
  type: TYPE_NORMAL
- en: '[31.2.1 A class for persons](#a-class-for-persons)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[We have previously worked with `jane` and `tarzan`, single objects representing
    persons](ch_objects.html#sharing-data-via-prototypes). Let’s use a *class declaration*
    to implement a factory for such objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`jane` and `tarzan` can now be created via `new Person()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let’s examine what’s inside the body of class `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: '`.constructor()` is a special method that is called after the creation of a
    new instance. Inside it, `this` refers to that instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.#firstName` ^(ES2022) is an *instance private field*: Such fields are stored
    in instances. They are accessed similarly to properties, but their names are separate
    – they always start with hash symbols (`#`). And they are invisible to the world
    outside the class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before we can initialize `.#firstName` in the constructor (line B), we need
    to declare it by mentioning it in the class body (line A).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.describe()` is a method. If we invoke it via `obj.describe()` then `this`
    refers to `obj` inside the body of `.describe()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.extractName()` is a *static* method. “Static” means that it belongs to the
    class, not to instances:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also create instance properties (public fields) in constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In contrast to instance private fields, instance properties don’t have to be
    declared in class bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '[31.2.2 Class expressions](#class-expressions)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two kinds of *class definitions* (ways of defining classes):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Class declarations*, which we have seen in the previous section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Class expressions*, which we’ll see next.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Class expressions can be anonymous and named:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The name of a named class expression works similarly to [the name of a named
    function expression](ch_callables.html#named-function-expressions): It can only
    be accessed inside the body of a class and stays the same, regardless of what
    the class is assigned to.'
  prefs: []
  type: TYPE_NORMAL
- en: '[31.2.3 The `instanceof` operator](#the-instanceof-operator)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `instanceof` operator tells us if a value is an instance of a given class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We’ll explore the `instanceof` operator in more detail [later](#instanceof-operator-details),
    after we have looked at subclassing.
  prefs: []
  type: TYPE_NORMAL
- en: '[31.2.4 Public slots (properties) vs. private slots](#private-slots)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the JavaScript language, objects can have two kinds of “slots”.
  prefs: []
  type: TYPE_NORMAL
- en: '*Public slots* (which are are also called *properties*). For example, methods
    are public slots.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Private slots* ^(ES2022). For example, private fields are private slots.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the most important rules we need to know about properties and private
    slots:'
  prefs: []
  type: TYPE_NORMAL
- en: In classes, we can use public and private versions of fields, methods, getters
    and setters. All of them are slots in objects. Which objects they are placed in
    depends on whether the keyword `static` is used and other factors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A getter and a setter that have the same key create a single *accessor* slot.
    An Accessor can also have only a getter or only a setter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Properties and private slots are very different – for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are stored separately.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Their keys are different. The keys of private slots can’t even be accessed directly
    (see [“Each private slot has a unique key (a *private name*)” (§31.2.5.2)](#private-names)
    later in this chapter).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties are inherited from prototypes, private slots aren’t.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Private slots can only be created via classes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following class demonstrates the two kinds of slots. Each of its instances
    has one private field and one property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, outside `MyClass`, we can only see the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **More information
    on properties**'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter doesn’t cover all details of properties (just the essentials).
    If you want to dig deeper, you can do so in [“Property attributes and property
    descriptors ^(ES5) (advanced)” (§30.10)](ch_objects.html#property-attributes-property-descriptors)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at some of the details of private slots.
  prefs: []
  type: TYPE_NORMAL
- en: '[31.2.5 Private slots in more detail ^(ES2022) (advanced)](#private-slots-in-more-detail-es2022-advanced)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[31.2.5.1 Private slots can’t be accessed in subclasses](#private-slots-cant-be-accessed-in-subclasses)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A private slot really can only be accessed inside the class that declares it.
    We can’t even access it from a subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[Subclassing via `extends`](#subclassing) is explained later in this chapter.
    How to work around this limitation is explained in [“Simulating protected visibility
    and friend visibility via WeakMaps (advanced)” (§31.5.4)](#instance-protected-fields).'
  prefs: []
  type: TYPE_NORMAL
- en: '[31.2.5.2 Each private slot has a unique key (a *private name*)](#private-names)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Private slots have unique keys that are similar to [symbols](ch_symbols.html#ch_symbols).
    Consider the following class from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Internally, the private field of `MyClass` is handled roughly like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The value of `instancePrivateFieldKey` is called a *private name*. We can’t
    use private names directly in JavaScript, we can only use them indirectly, via
    the fixed identifiers of private fields, private methods, and private accessors.
    Where the fixed identifiers of public slots (such as `getInstanceValues`) are
    interpreted as string keys, the fixed identifiers of private slots (such as `#instancePrivateField`)
    refer to private names (similarly to how variable names refer to values).
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **Private
    slots in the ECMAScript language specification**'
  prefs: []
  type: TYPE_NORMAL
- en: Section [“Object Internal Methods and Internal Slots”](https://tc39.es/ecma262/#sec-object-internal-methods-and-internal-slots)
    in the ECMAScript language specification explains how private slots work. Search
    for “`[[PrivateElements]]`”.
  prefs: []
  type: TYPE_NORMAL
- en: '[31.2.5.3 Private names are statically scoped (like variables)](#private-names-are-statically-scoped-like-variables)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A callable entity can only access the name of a private slot if it was born
    inside the scope where the name was declared. However, it doesn’t lose this ability
    if it moves somewhere else later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The arrow function `getter` was born inside `MyClass` (line A), but it can still
    access the private name `#privateData` after it left its birth scope (line B).
  prefs: []
  type: TYPE_NORMAL
- en: '[31.2.5.4 The same private identifier refers to different private names in
    different classes](#the-same-private-identifier-refers-to-different-private-names-in-different-classes)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Because the identifiers of private slots aren’t used as keys, using the same
    identifier in different classes produces different slots (line A and line C):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[31.2.5.5 The names of private fields never clash](#the-names-of-private-fields-never-clash)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Even if a subclass uses the same name for a private field, the two names never
    clash because they refer to private names (which are always unique). In the following
    example, `.#privateField` in `SuperClass` does not clash with `.#privateField`
    in `SubClass`, even though both slots are stored directly in `inst`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[Subclassing via `extends`](#subclassing) is explained later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[31.2.5.6 Using `in` to check if an object has a given private slot](#private-slot-checks)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `in` operator can be used to check if a private slot exists (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at more examples of `in` applied to private slots.
  prefs: []
  type: TYPE_NORMAL
- en: '**Private methods.** The following code shows that private methods create private
    slots in instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Static private fields.** We can also use `in` for a static private field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**Static private methods.** And we can check for the slot of a static private
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**Using the same private identifier in different classes.** In the next example,
    the two classes `Color` and `Person` both have a slot whose identifier is `#name`.
    The `in` operator distinguishes them correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[31.2.6 The pros and cons of classes in JavaScript](#the-pros-and-cons-of-classes-in-javascript)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I recommend using classes for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes are a common standard for object creation and inheritance that is now
    widely supported across libraries and frameworks. This is an improvement compared
    to how things were before, when almost every framework had its own inheritance
    library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They help tools such as IDEs and type checkers with their work and enable new
    features there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you come from another language to JavaScript and are used to classes, then
    you can get started more quickly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript engines optimize them. That is, code that uses classes is almost
    always faster than code that uses a custom inheritance library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can subclass built-in constructor functions such as `Error`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That doesn’t mean that classes are perfect:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a risk of overdoing inheritance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a risk of putting too much functionality in classes (when some of it
    is often better put in functions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes look familiar to programmers coming from other languages, but they work
    differently and are used differently (see next subsection). Therefore, there is
    a risk of those programmers writing code that doesn’t feel like JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How classes seem to work superficially is quite different from how they actually
    work. In other words, there is a disconnect between syntax and semantics. Two
    examples are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method definition inside a class `C` creates a method in the object `C.prototype`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes are functions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The motivation for the disconnect is backward compatibility. Thankfully, the
    disconnect causes few problems in practice; we are usually OK if we go along with
    what classes pretend to be.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This was a first look at classes. We’ll explore more features soon.
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Writing a class**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/classes/point_class_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[31.2.7 Tips for using classes](#tips-for-using-classes)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use inheritance sparingly – it tends to make code more complicated and spread
    out related functionality across multiple locations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead of static members, it is often better to use external functions and
    variables. We can even make those private to a module, simply by not exporting
    them. Two important exceptions to this rule are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations that need access to private slots
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Static factory methods](#static-factory-methods)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Only put core functionality in prototype methods. Other functionality is better
    implemented via functions – especially algorithms that involve instances of multiple
    classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[31.3 The internals of classes](#internals-of-classes)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[31.3.1 A class is actually two connected objects](#a-class-is-actually-two-connected-objects)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Under the hood, a class becomes two connected objects. Let’s revisit class
    `Person` to see how that works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The first object created by the class is stored in `Person`. It has four properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The two remaining properties are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Person.extractNames` is the static method that we have already seen in action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Person.prototype` points to the second object that is created by a class definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the contents of `Person.prototype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Person.prototype.constructor` points to the constructor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Person.prototype.describe` is the method that we have already used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[31.3.2 Classes set up the prototype chains of their instances](#classes-set-up-the-prototype-chains-of-their-instances)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The object `Person.prototype` is the prototype of all instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'That explains how the instances get their methods: They inherit them from the
    object `Person.prototype`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 31.2](#fig:oo_person_class) visualizes how everything is connected.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/96be80cce4461d811881a458537b27cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 31.2: The class `Person` has the property `.prototype` that points to
    an object that is the prototype of all instances of `Person`. The objects `jane`
    and `tarzan` are two such instances.'
  prefs: []
  type: TYPE_NORMAL
- en: '[31.3.3 `.__proto__` vs. `.prototype`](#proto-vs-prototype)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It is easy to confuse `.__proto__` and `.prototype`. Hopefully, [figure 31.2](#fig:oo_person_class)
    makes it clear how they differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Object.prototype.__proto__`](#Object.prototype.__proto__) is an accessor
    that most objects inherit that gets and sets the prototype of the receiver. Therefore
    the following two expressions are equivalent:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As are the following two expressions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`SomeClass.prototype` holds the object that becomes the prototype of all instances
    of `SomeClass`. A better name for `.prototype` would be `.instancePrototype`.
    This property is only special because the `new` operator uses it to set up instances
    of `SomeClass`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[31.3.4 `Person.prototype.constructor` (advanced)](#personprototypeconstructor-advanced)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There is one detail in [figure 31.2](#fig:oo_person_class) that we haven’t
    looked at, yet: `Person.prototype.constructor` points back to `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This setup exists due to backward compatibility. But it has two additional benefits.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, each instance of a class inherits property `.constructor`. Therefore,
    given an instance, we can make “similar” objects via it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we can get the name of the class that created a given instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[31.3.5 Dispatched vs. direct method calls (advanced)](#method-calls-dispatched-direct)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this subsection, we learn about two different ways of invoking methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Dispatched method calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Direct method calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding both of them will give us important insights into how methods
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll also need the second way [later](#using-object-methods-safely) in this
    chapter: It will allow us to borrow useful methods from `Object.prototype`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[31.3.5.1 Dispatched method calls](#dispatched-method-calls)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s examine how method calls work with classes. We are revisiting `jane`
    from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 31.3](#fig:jane_proto_chain) has a diagram with `jane`’s prototype
    chain.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/75efdfc55284976c46d9812c0dd3353b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 31.3: The prototype chain of `jane` starts with `jane` and continues
    with `Person.prototype`.'
  prefs: []
  type: TYPE_NORMAL
- en: Normal method calls are *dispatched* – the method call
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'happens in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dispatch: JavaScript traverses the prototype chain starting with `jane` to
    find the first object that has an own property with the key `''describe''`: It
    first looks at `jane` and doesn’t find an own property `.describe`. It continues
    with `jane`’s prototype, `Person.prototype` and finds an own property `describe`
    whose value it returns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Invocation: Method-invoking a value is different from function-invoking a value
    in that it not only calls what comes before the parentheses with the arguments
    inside the parentheses but also sets `this` to the receiver of the method call
    (in this case, `jane`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This way of dynamically looking for a method and invoking it is called *dynamic
    dispatch*.
  prefs: []
  type: TYPE_NORMAL
- en: '[31.3.5.2 Direct method calls](#direct-method-calls)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can also make method calls *directly*, without dispatching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This time, we directly point to the method via `Person.prototype.describe` and
    don’t search for it in the prototype chain. We also specify `this` differently
    – via `.call()`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **`this`
    always points to the instance**'
  prefs: []
  type: TYPE_NORMAL
- en: No matter where in the prototype chain of an instance a method is located, `this`
    always points to the instance (the beginning of the prototype chain). That enables
    `.describe()` to access `.#firstName` in the example.
  prefs: []
  type: TYPE_NORMAL
- en: 'When are direct method calls useful? Whenever we want to borrow a method from
    elsewhere that a given object doesn’t have – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[31.3.6 Classes evolved from ordinary functions (advanced)](#classes-evolved-from-ordinary-functions-advanced)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before ECMAScript 6, JavaScript didn’t have classes. Instead, [ordinary functions](ch_callables.html#ordinary-functions)
    were used as *constructor functions*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Classes provide better syntax for this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Subclassing is especially tricky with constructor functions. Classes also offer
    benefits that go beyond more convenient syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: Built-in constructor functions such as `Error` can be subclassed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can access overridden properties via `super`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes can’t be function-called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods can’t be `new`-called and don’t have the property `.prototype`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for private instance data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Classes are so compatible with constructor functions that they can even extend
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`extends` and subclassing are explained [later in this chapter](#subclassing).'
  prefs: []
  type: TYPE_NORMAL
- en: '[31.3.6.1 A class is the constructor](#a-class-is-the-constructor)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This brings us to an interesting insight. On one hand, `StringBuilderClass`
    refers to its constructor via `StringBuilderClass.prototype.constructor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the class *is* the constructor (a function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **Constructor
    (functions) vs. classes**'
  prefs: []
  type: TYPE_NORMAL
- en: Due to how similar they are, I use the terms *constructor (function)* and *class*
    interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: '[31.4 Prototype members of classes](#prototype-members-of-classes)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[31.4.1 Public prototype methods and accessors](#public-prototype-methods-and-accessors)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All members in the body of the following class declaration create properties
    of `PublicProtoClass.prototype`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[31.4.1.1 All kinds of public prototype methods and accessors (advanced)](#all-kinds-of-public-prototype-methods-and-accessors-advanced)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Quoted and computed keys can also be used in object literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[“Quoted keys in object literals” (§30.9.1)](ch_objects.html#object-literals-quoted-keys)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Computed keys in object literals” (§30.9.2)](ch_objects.html#object-literals-computed-keys)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information on accessors (defined via getters and/or setters), generators,
    async methods, and async generator methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[“Object literals: accessors” (§30.3.6)](ch_objects.html#object-literal-accessors)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Synchronous generators ^(ES6) (advanced)” (§33)](ch_sync-generators.html#ch_sync-generators)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Async functions ^(ES2017)” (§44)](ch_async-functions.html#ch_async-functions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Asynchronous generators” (§45.2)](ch_async-iteration.html#async-generators)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[31.4.2 Private methods and accessors ^(ES2022)](#private-methods-accessors)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Private methods (and accessors) are an interesting mix of prototype members
    and instance members.
  prefs: []
  type: TYPE_NORMAL
- en: 'On one hand, private methods are stored in slots in instances (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Why are they not stored in `.prototype` objects? Private slots are not inherited,
    only properties are.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, private methods are shared between instances – like prototype
    public methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Due to that and due to their syntax being similar to prototype public methods,
    they are covered here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates how private methods and accessors work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[31.4.2.1 All kinds of private methods and accessors (advanced)](#all-kinds-of-private-methods-and-accessors-advanced)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'With private slots, the keys are always identifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'More information on accessors (defined via getters and/or setters), generators,
    async methods, and async generator methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[“Object literals: accessors” (§30.3.6)](ch_objects.html#object-literal-accessors)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Synchronous generators ^(ES6) (advanced)” (§33)](ch_sync-generators.html#ch_sync-generators)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Async functions ^(ES2017)” (§44)](ch_async-functions.html#ch_async-functions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Asynchronous generators” (§45.2)](ch_async-iteration.html#async-generators)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[31.5 Instance members of classes ^(ES2022)](#instance-members-of-classes-es2022)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[31.5.1 Instance public fields](#instance-public-fields)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Instances of the following class have two instance properties (created in line
    A and line B):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If we create an instance property inside the constructor (line B), we don’t
    need to “declare” it elsewhere. As we have already seen, that is different for
    instance private fields.
  prefs: []
  type: TYPE_NORMAL
- en: Note that instance properties are relatively common in JavaScript; much more
    so than in, e.g., Java, where most instance state is private.
  prefs: []
  type: TYPE_NORMAL
- en: '[31.5.1.1 Instance public fields with quoted and computed keys (advanced)](#instance-public-fields-quoted-keys-computed-keys)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[31.5.1.2 What is the value of `this` in instance public fields? (advanced)](#what-is-the-value-of-this-in-instance-public-fields-advanced)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the initializer of a instance public field, `this` refers to the newly created
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[31.5.1.3 When are instance public fields executed? (advanced)](#when-are-instance-public-fields-executed-advanced)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The execution of instance public fields roughly follows these two rules:'
  prefs: []
  type: TYPE_NORMAL
- en: In base classes (classes without superclasses), instance public fields are executed
    immediately before the constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In derived classes (classes with superclasses):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The superclass sets up its instance slots when `super()` is called.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance public fields are executed immediately after `super()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example demonstrates these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`extends` and subclassing are explained [later in this chapter](#subclassing).'
  prefs: []
  type: TYPE_NORMAL
- en: '[31.5.2 Instance private fields](#instance-private-fields)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following class contains two instance private fields (line A and line B):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note that we can only use `.#privateField2` in line C if we declare it in the
    class body.
  prefs: []
  type: TYPE_NORMAL
- en: '[31.5.3 Private instance data before ES2022 (advanced)](#private-instance-data-before-es2022-advanced)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, we look at two techniques for keeping instance data private.
    Because they don’t rely on classes, we can also use them for objects that were
    created in other ways – e.g., via object literals.
  prefs: []
  type: TYPE_NORMAL
- en: '[31.5.3.1 Before ES6: private members via naming conventions](#before-es6-private-members-via-naming-conventions)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The first technique makes a property private by prefixing its name with an
    underscore. This doesn’t protect the property in any way; it merely signals to
    the outside: “You don’t need to know about this property.”'
  prefs: []
  type: TYPE_NORMAL
- en: In the following code, the properties `._counter` and `._action` are private.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: With this technique, we don’t get any protection and private names can clash.
    On the plus side, it is easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Private methods work similarly: They are normal methods whose names start with
    underscores.'
  prefs: []
  type: TYPE_NORMAL
- en: '[31.5.3.2 ES6 and later: private instance data via WeakMaps](#es6-and-later-private-instance-data-via-weakmaps)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can also manage private instance data via WeakMaps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: How exactly that works is explained [in the chapter on WeakMaps](ch_weakmaps.html#private-data-in-weakmaps).
  prefs: []
  type: TYPE_NORMAL
- en: This technique offers us considerable protection from outside access and there
    can’t be any name clashes. But it is also more complicated to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'We control the visibility of the pseudo-property `_superProp` by controlling
    who has access to it – for example: If the variable exists inside a module and
    isn’t exported, everyone inside the module and no one outside the module can access
    it. In other words: The scope of privacy isn’t the class in this case, it’s the
    module. We could narrow the scope, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This technique doesn’t really support private methods. But module-local functions
    that have access to `_superProp` are the next best thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Note that `this` becomes the explicit function parameter `_this` (line A).
  prefs: []
  type: TYPE_NORMAL
- en: '[31.5.4 Simulating protected visibility and friend visibility via WeakMaps
    (advanced)](#instance-protected-fields)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As previously discussed, instance private fields are only visible inside their
    classes and not even in subclasses. Thus, there is no built-in way to get:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Protected visibility: A class and all of its subclasses can access a piece
    instance data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Friend visibility: A class and its “friends” (designated functions, objects,
    or classes) can access a piece of instance data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the previous subsection, we simulated “module visibility” (everyone inside
    a module has access to a piece of instance data) via WeakMaps. Therefore:'
  prefs: []
  type: TYPE_NORMAL
- en: If we put a class and its subclasses into the same module, we get protected
    visibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we put a class and its friends into the same module, we get friend visibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next example demonstrates protected visibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[Subclassing via `extends`](#subclassing) is explained later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[31.6 Static members of classes](#static-members-of-classes)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[31.6.1 Static public methods and accessors](#static-public-methods-and-accessors)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All members in the body of the following class declaration create so-called
    *static* properties – properties of `StaticClass` itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[31.6.1.1 All kinds of static public methods and accessors (advanced)](#all-kinds-of-static-public-methods-and-accessors-advanced)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Quoted and computed keys can also be used in object literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[“Quoted keys in object literals” (§30.9.1)](ch_objects.html#object-literals-quoted-keys)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Computed keys in object literals” (§30.9.2)](ch_objects.html#object-literals-computed-keys)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information on accessors (defined via getters and/or setters), generators,
    async methods, and async generator methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[“Object literals: accessors” (§30.3.6)](ch_objects.html#object-literal-accessors)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Synchronous generators ^(ES6) (advanced)” (§33)](ch_sync-generators.html#ch_sync-generators)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Async functions ^(ES2017)” (§44)](ch_async-functions.html#ch_async-functions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Asynchronous generators” (§45.2)](ch_async-iteration.html#async-generators)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[31.6.2 Static public fields ^(ES2022)](#static-public-fields)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following code demonstrates static public fields. `StaticPublicFieldClass`
    has three of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[31.6.3 Static private methods, accessors, and fields ^(ES2022)](#static-private-methods-accessors-fields)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following class has two static private slots (line A and line B):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a complete list of all kinds of static private slots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[31.6.4 Static initialization blocks in classes ^(ES2022)](#class-static-initialization-blocks)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To set up instance data via classes, we have two constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Fields*, to create and optionally initialize instance data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Constructors*, blocks of code that are executed every time a new instance
    is created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For static data, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Static fields*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Static blocks* that are executed when a class is created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code demonstrates static blocks (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also execute the code inside the static block after the class (at
    the top level). However, using a static block has two benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: All class-related code is inside the class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code in a static block has access to private slots.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[31.6.4.1 Rules for static initialization blocks](#rules-for-static-initialization-blocks)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The rules for how static initialization blocks work, are relatively simple:'
  prefs: []
  type: TYPE_NORMAL
- en: There can be more than one static block per class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The execution of static blocks is interleaved with the execution of static field
    initializers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The static members of a superclass are executed before the static members of
    a subclass.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code demonstrates these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[Subclassing via `extends`](#subclassing) is explained later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[31.6.5 Pitfall: Using `this` to access static private fields](#this-and-static-private-fields)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In static public members, we can access static public slots via `this`. Alas,
    we should not use it to access static private slots.
  prefs: []
  type: TYPE_NORMAL
- en: '[31.6.5.1 `this` and static public fields](#this-and-static-public-fields)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[Subclassing via `extends`](#subclassing) is explained later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Static public fields are properties. If we make the method call
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'then `this` points to `SuperClass` and everything works as expected. We can
    also invoke `.getPublicViaThis()` via the subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '`SubClass` inherits `.getPublicViaThis()` from its prototype `SuperClass`.
    `this` points to `SubClass` and things continue to work, because `SubClass` also
    inherits the property `.publicData`.'
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, if we assigned to `this.publicData` in `getPublicViaThis()` and
    invoked it via `SubClass.getPublicViaThis()`, then we would create a new own poperty
    of `SubClass` that (non-destructively) overrides the property inherited from `SuperClass`.
  prefs: []
  type: TYPE_NORMAL
- en: '[31.6.5.2 `this` and static private fields](#this-and-static-private-fields-1)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoking `.getPrivateDataViaThis()` via `SuperClass` works, because `this`
    points to `SuperClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'However, invoking `.getPrivateDataViaThis()` via `SubClass` does not work,
    because `this` now points to `SubClass` and `SubClass` has no static private field
    `.#privateData` (private slots in prototype chains are not inherited):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The workaround is to accesss `.#privateData` directly, via `SuperClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: With static private methods, we are facing the same issue.
  prefs: []
  type: TYPE_NORMAL
- en: '[31.6.6 All members (static, prototype, instance) can access all private members](#all-members-static-prototype-instance-can-access-all-private-members)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Every member inside a class can access all other members inside that class
    – both public and private ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, no one outside can access the private members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[31.6.7 Static private methods and data before ES2022](#static-private-methods-and-data-before-es2022)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following code only works in ES2022 – due to every line that has a hash
    symbol (`#`) in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Since private slots only exist once per class, we can move `.#secret` and `.#getSecretInParens`
    to the scope surrounding the class and use a module to hide them from the world
    outside the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.#secret` becomes a top-level variable in the module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.getSecretInParens()` becomes a top-level function in the module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The result looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[31.6.8 Static factory methods](#static-factory-methods)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes there are multiple ways in which a class can be instantiated. Then
    we can implement *static factory methods* such as `Point.fromPolar()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'I like how descriptive static factory methods are: `fromPolar` describes how
    an instance is created. JavaScript’s standard library also has such factory methods
    – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.from()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.create()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I prefer to either have no static factory methods or *only* static factory
    methods. Things to consider in the latter case:'
  prefs: []
  type: TYPE_NORMAL
- en: One factory method will probably directly call the constructor (but have a descriptive
    name).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to find a way to prevent the constructor being called from outside.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following code, we use a secret token (line A) to prevent the constructor
    being called from outside the current module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[31.7 Subclassing](#subclassing)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[31.7.1 Defining subclasses via `extends`](#defining-subclasses-via-extends)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Classes can extend existing classes. For example, the following class `Employee`
    extends `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Terminology related to extending:'
  prefs: []
  type: TYPE_NORMAL
- en: Another word for *extending* is *subclassing*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Person` is the superclass of `Employee`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Employee` is the subclass of `Person`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *base class* is a class that has no superclasses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *derived class* is a class that has a superclass.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the `.constructor()` of a derived class, we must call the super-constructor
    via `super()` before we can access `this`. Why is that?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a chain of classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Base class `A`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `B` extends `A`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `C` extends `B`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we invoke `new C()`, `C`’s constructor super-calls `B`’s constructor which
    super-calls `A`’s constructor. Instances are always created in base classes, before
    the constructors of subclasses add their slots. Therefore, the instance doesn’t
    exist before we call `super()` and we can’t access it via `this`, yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that static public slots are inherited. For example, `Employee` inherits
    the static method `.extractNames()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Subclassing**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/classes/color_point_class_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[31.7.2 The internals of subclassing (advanced)](#internals-of-subclassing)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '![](../Images/9e9cfd8d183a6ecd074a55a7eb578773.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 31.4: These are the objects that make up class `Person` and its subclass,
    `Employee`. The left column is about classes. The right column is about the `Employee`
    instance `jane` and its prototype chain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The classes `Person` and `Employee` from the previous section are made up of
    several objects ([figure 31.4](#fig:oo_subclassing)). One key insight for understanding
    how these objects are related is that there are two prototype chains:'
  prefs: []
  type: TYPE_NORMAL
- en: The instance prototype chain, on the right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class prototype chain, on the left.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each class contributes a prototype to the instance prototype chain but is also
    in its own chain of prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: '[31.7.2.1 The instance prototype chain (right column)](#the-instance-prototype-chain-right-column)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The instance prototype chain starts with `jane` and continues with `Employee.prototype`
    and `Person.prototype`. In principle, the prototype chain ends at this point,
    but we get one more object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '`Object.prototype` provides services to virtually all objects, which is why
    it is included here, too. The prototype of `Object.prototype` is `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[31.7.2.2 The class prototype chain (left column)](#the-class-prototype-chain-left-column)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the class prototype chain, `Employee` comes first, `Person` next. In principle,
    the prototype chain ends at this point, but `Person` does have a prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '`Person` only has this prototype because it’s a function and `Function.prototype`
    is the prototype of all functions. (As an aside, the prototype of `Function.prototype`
    is `Object.prototype`.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[31.7.3 The `instanceof` operator in detail (advanced)](#instanceof-operator-details)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have not yet learned how `instanceof` really works: How does `instanceof`
    determine if a value `x` is an instance of a class `C`? Note that “instance of
    `C`” means direct instance of `C` or direct instance of a subclass of `C`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`instanceof` checks if `C.prototype` is in the prototype chain of `x`. That
    is, the following two expressions are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'If we go back to [figure 31.4](#fig:oo_subclassing), we can confirm that the
    prototype chain does lead us to the following correct answers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `instanceof` always returns `false` if its self-hand side is a primitive
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[31.7.4 Not all objects are instances of `Object` (advanced)](#non-instances-of-object)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An object (a non-primitive value) is only an instance of `Object` if `Object.prototype`
    is in its prototype chain [(see previous subsection)](#instanceof-operator-details).
    Virtually all objects are instances of `Object` – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next example, `obj1` and `obj2` are both objects (line A and line C),
    but they are not instances of `Object` (line B and line D): `Object.prototype`
    is not in their prototype chains because they don’t have any prototypes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '`Object.prototype` is the object that ends most prototype chains. Its prototype
    is `null`, which means it isn’t an instance of `Object` either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[31.7.5 Base class vs. derived class (advanced)](#base-class-vs-derived-class-advanced)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A base class is different from a class that extends `Object`.
  prefs: []
  type: TYPE_NORMAL
- en: The following class is derived from class `Object`. [Figure 31.5](#fig:class-derived)
    shows its object diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/ccf6009e97e345718b2e2852460148fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 31.5: Object diagram for class `DerivedClass` and its instance `derivedInstance`:
    Both `Object` and `DerivedClass` appear in the class prototype chain (left column).
    They both contribute prototypes to the instance prototype chain (right column).'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the following class is a base class. [Figure 31.6](#fig:class-base)
    shows its object diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/d47fa0c82efa7280cc3139a980d91244.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 31.6: Object diagram for class `BaseClass` and its instance `baseInstance`:
    The instance prototype chain (right column) is the same as for `derivedInstance`.
    However, `Object` does not appear in the class prototype chain (left column).'
  prefs: []
  type: TYPE_NORMAL
- en: '[31.7.6 The prototype chains of plain objects and Arrays (advanced)](#prototype-chains-of-builtin-objects)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we’ll use our knowledge of subclassing to understand the prototype chains
    of plain objects and Arrays. The following tool function `p()` helps us with our
    explorations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: We extracted method `.getPrototypeOf()` of `Object` and assigned it to `p`.
  prefs: []
  type: TYPE_NORMAL
- en: '[31.7.6.1 The prototype chains of plain objects](#the-prototype-chains-of-plain-objects)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s explore the prototype chain of a plain object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 31.7](#fig:builtin-object) shows a diagram for a plain object and its
    class `Object`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9a2acdc1ab742c804e273ce5af871ba1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 31.7: The prototype of the empty plain object `{}` is `Object.prototype`
    – which makes it an instance of the class `Object`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[31.7.6.2 The prototype chains of Arrays](#the-prototype-chains-of-arrays)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s explore the prototype chain of an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 31.8](#fig:builtin-array) shows a diagram for an Array and its class
    `Array`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2d8acaa0b29263257e64a3d6f87074a8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 31.8: The empty Array `[]` is an instance of `Array` (via `Array.prototype`)
    and an instance of `Object` (via `Object.prototype`). However, class `Array` is
    not derived from class `Object` – it is a base class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s interesting that `Array` is a base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, all instances of `Array` are also instances of `Object` – yet `Array`
    is not a subclass of `Object`. This divergence is only possible because the instance
    prototype chain is separate from the class prototype chain in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Why isn’t `Object` the prototype of `Array`? One reason is that it has been
    this way since long before classes were added to JavaScript and can’t really be
    changed due to the importance of backward compatibility in JavaScript. Another
    reason is that base classes are where instances are actually created. `Array`
    needs to create its own instances because they have so-called “internal slots”
    which can’t be added later to instances created by `Object`.
  prefs: []
  type: TYPE_NORMAL
- en: '[31.7.6.3 The prototype chains of functions](#the-prototype-chains-of-functions)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Functions are similar to Arrays. On one hand, `Function` is a base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, function objects are instances of `Object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[31.8 Mixin classes (advanced)](#mixin-classes-advanced)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript’s class system only supports *single inheritance*. That is, each
    class can have at most one superclass. One way around this limitation is via a
    technique called *mixin classes* (short: *mixins*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is as follows: Let’s say we want a class `C` to inherit from two superclasses
    `S1` and `S2`. That would be *multiple inheritance*, which JavaScript doesn’t
    support.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our workaround is to turn `S1` and `S2` into *mixins*, factories for subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these two functions returns a class that extends a given superclass
    `Sup`. We create class `C` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: We now have a class `C` that extends the class returned by `S2()` which extends
    the class returned by `S1()` which extends `Object`.
  prefs: []
  type: TYPE_NORMAL
- en: '[31.8.1 Example: a mixin for name management](#example-a-mixin-for-name-management)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We implement a mixin `Named` adds a property `.name` and a method `.toString()`
    to its superclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'We use this mixin to implement a class `City` that has a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code confirms that the mixin works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[31.8.2 The benefits of mixins](#the-benefits-of-mixins)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Mixins free us from the constraints of single inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: The same class can extend a single superclass and zero or more mixins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same mixin can be used by multiple classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[31.9 The methods and accessors of `Object.prototype` (advanced)](#the-methods-and-accessors-of-objectprototype-advanced)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[31.9.1 Using `Object.prototype` methods safely](#using-object-methods-safely)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Invoking one of the methods of `Object.prototype` on an arbitrary object doesn’t
    always work. To illustrate why, we use method `Object.prototype.hasOwnProperty`,
    which returns `true` if an object has an own property with a given key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoking `.hasOwnProperty()` on an arbitrary object can fail in two ways. On
    one hand, this method isn’t available if an object is not an instance of `Object`
    (see [“Not all objects are instances of `Object` (advanced)” (§31.7.4)](#non-instances-of-object)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, we can’t use `.hasOwnProperty()` if an object overrides
    it with an own property (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'There is, however, a safe way to use `.hasOwnProperty()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The method invocation in line A is explained in [“Dispatched vs. direct method
    calls (advanced)” (§31.3.5)](#method-calls-dispatched-direct).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use [`.bind()`](ch_objects.html#methods-bind) to implement `hasOwnProp()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: How does this code work? In line A in the example before the code above, we
    used the function method `.call()` to turn the function `hasOwnProperty` with
    one implicit parameter (`this`) and one explicit parameter (`propName`) into a
    function that has two explicit parameters (`obj` and `propName`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words – method `.call()` invokes the function `f` referred to by its
    receiver (`this`):'
  prefs: []
  type: TYPE_NORMAL
- en: The first (explicit) parameter of `.call()` becomes the `this` of `f`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second (explicit) parameter of `.call()` becomes the first argument of `f`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `.bind()` to create a version `.call()` whose `this` always refers to
    `Object.prototype.hasOwnProperty`. That new version invokes `.hasOwnProperty()`
    in the same manner as we did in line A – which is what we want.
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “question”](../Images/3decb3ca67c240d2bb04742c1f28af18.png) **Is it
    never OK to use `Object.prototype` methods via dynamic dispatch?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases we can be lazy and call `Object.prototype` methods like normal
    methods: If we know the receivers and they are fixed-layout objects.'
  prefs: []
  type: TYPE_NORMAL
- en: If, on the other hand, we don’t know their receivers and/or they are dictionary
    objects, then we need to take precautions.
  prefs: []
  type: TYPE_NORMAL
- en: '[31.9.2 `Object.prototype.toString()` ^(ES1)](#Object.prototype.toString)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'By overriding `.toString()` (in a subclass or an instance), we can configure
    how objects are converted to strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'For converting objects to strings it’s better to use `String()` because that
    also works with `undefined` and `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[31.9.3 `Object.prototype.toLocaleString()` ^(ES3)](#Object.prototype.toLocaleString)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`.toLocaleString()` is a version of `.toString()` that can be configured via
    a locale and often additional options. Any class or instance can implement this
    method. In the standard library, the following classes do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Number.prototype.toLocaleString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`BigInt.prototype.toLocaleString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.toLocaleString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`TypedArray.prototype.toLocaleString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.toLocaleString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thanks to the [ECMAScript Internationalization API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Internationalization)
    (`Intl` etc.), there are a variety of formatting options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[31.9.4 `Object.prototype.valueOf()` ^(ES1)](#Object.prototype.valueOf)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'By overriding `.valueOf()` (in a subclass or an instance), we can configure
    how objects are converted to non-string values (often numbers):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[31.9.5 `Object.prototype.isPrototypeOf()` ^(ES3)](#Object.prototype.isPrototypeOf)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`proto.isPrototypeOf(obj)` returns `true` if `proto` is in the prototype chain
    of `obj` and `false` otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how to use this method safely (for details see [“Using `Object.prototype`
    methods safely” (§31.9.1)](#using-object-methods-safely)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'An object is an instance of a class `C` if `C.prototype` is in its chain of
    prototypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[31.9.6 `Object.prototype.propertyIsEnumerable()` ^(ES3)](#Object.prototype.propertyIsEnumerable)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`obj.propertyIsEnumerable(propKey)` returns `true` if `obj` has an own enumerable
    property whose key is `propKey` and `false` otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how to use this method safely (for details see [“Using `Object.prototype`
    methods safely” (§31.9.1)](#using-object-methods-safely)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Another safe alternative is to use [property descriptors](ch_objects.html#property-attributes-property-descriptors):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[31.9.7 `Object.prototype.__proto__` (accessor) ^(ES6)](#Object.prototype.__proto__)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Property `__proto__` exists in two versions:'
  prefs: []
  type: TYPE_NORMAL
- en: An accessor that all instances of `Object` have.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A property of object literals that sets the prototypes of the objects created
    by them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I recommend to avoid the former feature:'
  prefs: []
  type: TYPE_NORMAL
- en: As explained in [“Using `Object.prototype` methods safely” (§31.9.1)](#using-object-methods-safely),
    it doesn’t work with all objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ECMAScript specification has deprecated it and calls it [“optional” and
    “legacy”](https://tc39.es/ecma262/#sec-object.prototype.__proto__).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In contrast, `__proto__` in object literals always works and is not deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: Read on if you are interested in how the accessor `__proto__` works.
  prefs: []
  type: TYPE_NORMAL
- en: '`__proto__` is an accessor of `Object.prototype` that is inherited by all instances
    of `Object`. Implementing it via a class would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `__proto__` is inherited from `Object.prototype`, we can remove this
    feature by creating an object that doesn’t have `Object.prototype` in its prototype
    chain (see [“Not all objects are instances of `Object` (advanced)” (§31.7.4)](#non-instances-of-object)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[31.9.8 `Object.prototype.hasOwnProperty()` ^(ES3)](#Object.prototype.hasOwnProperty)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '![Icon “warning”](../Images/5aa4bf88dc66ecb2bac6be4022a1fed4.png) **Better
    alternative to `.hasOwnProperty()`: `Object.hasOwn()` ^(ES2022)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'See [“`Object.hasOwn()`: Is a given property own (non-inherited)? ^(ES2022)”
    (§30.8.4)](ch_objects.html#Object.hasOwn).'
  prefs: []
  type: TYPE_NORMAL
- en: '`obj.hasOwnProperty(propKey)` returns `true` if `obj` has an own (non-inherited)
    property whose key is `propKey` and `false` otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how to use this method safely (for details see [“Using `Object.prototype`
    methods safely” (§31.9.1)](#using-object-methods-safely)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[31.10 Quick reference: `Object.prototype.*`](#quickref-object-prototype)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[31.10.1 `Object.prototype.*`: configuring how objects are converted to primitive
    values](#objectprototype-configuring-how-objects-are-converted-to-primitive-values)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following methods have default implementations but are often overridden
    in subclasses or instances. They determine how objects are converted to primitive
    values (e.g. by the `+` operator).
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.prototype.toString()` ES1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configures how an object is converted to a string.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[More information](#Object.prototype.toString).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Object.prototype.toLocaleString()` ES3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A version of `.toString()` that can be configured in various ways via arguments
    (language, region, etc.). [More information](#Object.prototype.toLocaleString).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Object.prototype.valueOf()` ES1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configures how an object is converted to a non-string primitive value (often
    a number).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[More information](#Object.prototype.valueOf).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[31.10.2 `Object.prototype.*`: useful methods with pitfalls](#objectprototype-useful-methods-with-pitfalls)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following methods are useful but can’t be invoked on an object if:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.prototype` isn’t a prototype of that object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Object.prototype` method is overridden somewhere in the prototype chain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work around that limitation is explained in [“Using `Object.prototype`
    methods safely” (§31.9.1)](#using-object-methods-safely).
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.prototype.isPrototypeOf()` ES3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the receiver in the prototype chain of a given object?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You’ll usually be fine if you invoke this method on an object. If you want
    to be safe, you can use the following pattern (line A):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[More information](#Object.prototype.isPrototypeOf).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Object.prototype.propertyIsEnumerable()` ES3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the receiver have an enumerable own property with the given key?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You’ll usually be fine if you invoke this method on an object. If you want
    to be safe, you can use the following pattern:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[More information](#Object.prototype.propertyIsEnumerable).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[31.10.3 `Object.prototype.*`: methods to avoid](#objectprototype-methods-to-avoid)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Avoid the following features (there are better alternatives):'
  prefs: []
  type: TYPE_NORMAL
- en: '`get Object.prototype.__proto__` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Avoid:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Instead, use `Object.getPrototypeOf()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[More information](#Object.prototype.__proto__).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set Object.prototype.__proto__` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Avoid:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Instead, use `Object.setPrototypeOf()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[More information](#Object.prototype.__proto__).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.prototype.hasOwnProperty` ES3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Avoid:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Instead, use `Object.hasOwn()` ^(ES2022)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[More information](#Object.prototype.hasOwnProperty).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[31.11 FAQ: classes](#faq-classes)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[31.11.1 Why are they called “instance private fields” in this book and not
    “private instance fields”?](#why-are-they-called-instance-private-fields-in-this-book-and-not-private-instance-fields)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'That is done to highlight how different properties (public slots) and private
    slots are: By changing the order of the adjectives, the words “public” and “field”
    and the words “private” and “field” are always mentioned together.'
  prefs: []
  type: TYPE_NORMAL
- en: '[31.11.2 Why the identifier prefix `#`? Why not declare private fields via
    `private`?](#why-the-identifier-prefix--why-not-declare-private-fields-via-private)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Could private fields be declared via `private` and use normal identifiers?
    Let’s examine what would happen if that were possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever an expression such as `other.value` appears in the body of `MyClass`,
    JavaScript has to decide:'
  prefs: []
  type: TYPE_NORMAL
- en: Is `.value` a property?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is `.value` a private field?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At compile time, JavaScript doesn’t know if the declaration in line A applies
    to `other` (due to it being an instance of `MyClass`) or not. That leaves two
    options for making the decision:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.value` is always interpreted as a private field.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'JavaScript decides at runtime:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `other` is an instance of `MyClass`, then `.value` is interpreted as a private
    field.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise `.value` is interpreted as a property.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both options have downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: With option (1), we can’t use `.value` as a property, anymore – for any object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With option (2), performance is affected negatively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That’s why the name prefix `#` was introduced. The decision is now easy: If
    we use `#`, we want to access a private field. If we don’t, we want to access
    a property.'
  prefs: []
  type: TYPE_NORMAL
- en: '`private` works for statically typed languages (such as TypeScript) because
    they know at compile time if `other` is an instance of `MyClass` and can then
    treat `.value` as private or public.'
  prefs: []
  type: TYPE_NORMAL
