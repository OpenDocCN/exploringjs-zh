- en: 31 Classes ES6
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 31 类 ES6
- en: 原文：[https://exploringjs.com/js/book/ch_classes.html](https://exploringjs.com/js/book/ch_classes.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/js/book/ch_classes.html](https://exploringjs.com/js/book/ch_classes.html)
- en: '[31.1 Cheat sheet: classes](#cheat-sheet-classes)'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.1 类速查表](#cheat-sheet-classes)'
- en: '[31.2 The essentials of classes](#classes)'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.2 类的基本要素](#classes)'
- en: '[31.2.1 A class for persons](#a-class-for-persons)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.2.1 人员类](#a-class-for-persons)'
- en: '[31.2.2 Class expressions](#class-expressions)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.2.2 类表达式](#class-expressions)'
- en: '[31.2.3 The `instanceof` operator](#the-instanceof-operator)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.2.3 `instanceof` 操作符](#the-instanceof-operator)'
- en: '[31.2.4 Public slots (properties) vs. private slots](#private-slots)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.2.4 公共槽位（属性）与私有槽位](#private-slots)'
- en: '[31.2.5 Private slots in more detail ^(ES2022) (advanced)](#private-slots-in-more-detail-es2022-advanced)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.2.5 私有槽位详细说明（ES2022）（高级）](#private-slots-in-more-detail-es2022-advanced)'
- en: '[31.2.6 The pros and cons of classes in JavaScript](#the-pros-and-cons-of-classes-in-javascript)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.2.6 JavaScript 类的优缺点](#the-pros-and-cons-of-classes-in-javascript)'
- en: '[31.2.7 Tips for using classes](#tips-for-using-classes)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.2.7 使用类的技巧](#tips-for-using-classes)'
- en: '[31.3 The internals of classes](#internals-of-classes)'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.3 类的内部机制](#internals-of-classes)'
- en: '[31.3.1 A class is actually two connected objects](#a-class-is-actually-two-connected-objects)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.3.1 类实际上是由两个连接的对象组成](#a-class-is-actually-two-connected-objects)'
- en: '[31.3.2 Classes set up the prototype chains of their instances](#classes-set-up-the-prototype-chains-of-their-instances)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.3.2 类为其实例设置原型链](#classes-set-up-the-prototype-chains-of-their-instances)'
- en: '[31.3.3 `.__proto__` vs. `.prototype`](#proto-vs-prototype)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.3.3 `.__proto__` 与 `.prototype`](#proto-vs-prototype)'
- en: '[31.3.4 `Person.prototype.constructor` (advanced)](#personprototypeconstructor-advanced)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.3.4 `Person.prototype.constructor`（高级）](#personprototypeconstructor-advanced)'
- en: '[31.3.5 Dispatched vs. direct method calls (advanced)](#method-calls-dispatched-direct)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.3.5 分发调用与直接方法调用（高级）](#method-calls-dispatched-direct)'
- en: '[31.3.6 Classes evolved from ordinary functions (advanced)](#classes-evolved-from-ordinary-functions-advanced)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.3.6 类是从普通函数演变而来的（高级）](#classes-evolved-from-ordinary-functions-advanced)'
- en: '[31.4 Prototype members of classes](#prototype-members-of-classes)'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.4 类的原型成员](#prototype-members-of-classes)'
- en: '[31.4.1 Public prototype methods and accessors](#public-prototype-methods-and-accessors)'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.4.1 公共原型方法和访问器](#public-prototype-methods-and-accessors)'
- en: '[31.4.2 Private methods and accessors ^(ES2022)](#private-methods-accessors)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.4.2 私有方法和访问器（ES2022）](#private-methods-accessors)'
- en: '[31.5 Instance members of classes ^(ES2022)](#instance-members-of-classes-es2022)'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.5 类的实例成员（ES2022）](#instance-members-of-classes-es2022)'
- en: '[31.5.1 Instance public fields](#instance-public-fields)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.5.1 实例公共字段](#instance-public-fields)'
- en: '[31.5.2 Instance private fields](#instance-private-fields)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.5.2 实例私有字段](#instance-private-fields)'
- en: '[31.5.3 Private instance data before ES2022 (advanced)](#private-instance-data-before-es2022-advanced)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.5.3 在 ES2022 之前私有实例数据（高级）](#private-instance-data-before-es2022-advanced)'
- en: '[31.5.4 Simulating protected visibility and friend visibility via WeakMaps
    (advanced)](#instance-protected-fields)'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.5.4 通过 WeakMaps 模拟受保护的可视性和友元可视性（高级）](#instance-protected-fields)'
- en: '[31.6 Static members of classes](#static-members-of-classes)'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.6 类的静态成员](#static-members-of-classes)'
- en: '[31.6.1 Static public methods and accessors](#static-public-methods-and-accessors)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.6.1 静态公共方法和访问器](#static-public-methods-and-accessors)'
- en: '[31.6.2 Static public fields ^(ES2022)](#static-public-fields)'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.6.2 静态公共字段（ES2022）](#static-public-fields)'
- en: '[31.6.3 Static private methods, accessors, and fields ^(ES2022)](#static-private-methods-accessors-fields)'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.6.3 静态私有方法、访问器和字段（ES2022）](#static-private-methods-accessors-fields)'
- en: '[31.6.4 Static initialization blocks in classes ^(ES2022)](#class-static-initialization-blocks)'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.6.4 类中的静态初始化块（ES2022）](#class-static-initialization-blocks)'
- en: '[31.6.5 Pitfall: Using `this` to access static private fields](#this-and-static-private-fields)'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.6.5 漏洞：使用 `this` 访问静态私有字段](#this-and-static-private-fields)'
- en: '[31.6.6 All members (static, prototype, instance) can access all private members](#all-members-static-prototype-instance-can-access-all-private-members)'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.6.6 所有成员（静态、原型、实例）都可以访问所有私有成员](#all-members-static-prototype-instance-can-access-all-private-members)'
- en: '[31.6.7 Static private methods and data before ES2022](#static-private-methods-and-data-before-es2022)'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.6.7 在 ES2022 之前静态私有方法和数据](#static-private-methods-and-data-before-es2022)'
- en: '[31.6.8 Static factory methods](#static-factory-methods)'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.6.8 静态工厂方法](#static-factory-methods)'
- en: '[31.7 Subclassing](#subclassing)'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.7 子类化](#subclassing)'
- en: '[31.7.1 Defining subclasses via `extends`](#defining-subclasses-via-extends)'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.7.1 通过 `extends` 定义子类](#defining-subclasses-via-extends)'
- en: '[31.7.2 The internals of subclassing (advanced)](#internals-of-subclassing)'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.7.2 子类化的内部机制（高级）](#internals-of-subclassing)'
- en: '[31.7.3 The `instanceof` operator in detail (advanced)](#instanceof-operator-details)'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.7.3 `instanceof`运算符的详细说明（高级）](#instanceof-operator-details)'
- en: '[31.7.4 Not all objects are instances of `Object` (advanced)](#non-instances-of-object)'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.7.4 并非所有对象都是`Object`的实例（高级）](#non-instances-of-object)'
- en: '[31.7.5 Base class vs. derived class (advanced)](#base-class-vs-derived-class-advanced)'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.7.5 基类与派生类（高级）](#base-class-vs-derived-class-advanced)'
- en: '[31.7.6 The prototype chains of plain objects and Arrays (advanced)](#prototype-chains-of-builtin-objects)'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.7.6 普通对象和数组的原型链（高级）](#prototype-chains-of-builtin-objects)'
- en: '[31.8 Mixin classes (advanced)](#mixin-classes-advanced)'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.8 混入类（高级）](#mixin-classes-advanced)'
- en: '[31.8.1 Example: a mixin for name management](#example-a-mixin-for-name-management)'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.8.1 示例：用于名称管理的混入](#example-a-mixin-for-name-management)'
- en: '[31.8.2 The benefits of mixins](#the-benefits-of-mixins)'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.8.2 混入类的优势](#the-benefits-of-mixins)'
- en: '[31.9 The methods and accessors of `Object.prototype` (advanced)](#the-methods-and-accessors-of-objectprototype-advanced)'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.9 `Object.prototype`的方法和访问器（高级）](#the-methods-and-accessors-of-objectprototype-advanced)'
- en: '[31.9.1 Using `Object.prototype` methods safely](#using-object-methods-safely)'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.9.1 安全使用`Object.prototype`方法](#using-object-methods-safely)'
- en: '[31.9.2 `Object.prototype.toString()` ^(ES1)](#Object.prototype.toString)'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.9.2 `Object.prototype.toString()` (ES1)](#Object.prototype.toString)'
- en: '[31.9.3 `Object.prototype.toLocaleString()` ^(ES3)](#Object.prototype.toLocaleString)'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.9.3 `Object.prototype.toLocaleString()` (ES3)](#Object.prototype.toLocaleString)'
- en: '[31.9.4 `Object.prototype.valueOf()` ^(ES1)](#Object.prototype.valueOf)'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.9.4 `Object.prototype.valueOf()` (ES1)](#Object.prototype.valueOf)'
- en: '[31.9.5 `Object.prototype.isPrototypeOf()` ^(ES3)](#Object.prototype.isPrototypeOf)'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.9.5 `Object.prototype.isPrototypeOf()` (ES3)](#Object.prototype.isPrototypeOf)'
- en: '[31.9.6 `Object.prototype.propertyIsEnumerable()` ^(ES3)](#Object.prototype.propertyIsEnumerable)'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.9.6 `Object.prototype.propertyIsEnumerable()` (ES3)](#Object.prototype.propertyIsEnumerable)'
- en: '[31.9.7 `Object.prototype.__proto__` (accessor) ^(ES6)](#Object.prototype.__proto__)'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.9.7 `Object.prototype.__proto__` (访问器) (ES6)](#Object.prototype.__proto__)'
- en: '[31.9.8 `Object.prototype.hasOwnProperty()` ^(ES3)](#Object.prototype.hasOwnProperty)'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.9.8 `Object.prototype.hasOwnProperty()` (ES3)](#Object.prototype.hasOwnProperty)'
- en: '[31.10 Quick reference: `Object.prototype.*`](#quickref-object-prototype)'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.10 快速参考：`Object.prototype.*`](#quickref-object-prototype)'
- en: '[31.10.1 `Object.prototype.*`: configuring how objects are converted to primitive
    values](#objectprototype-configuring-how-objects-are-converted-to-primitive-values)'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.10.1 `Object.prototype.*`: 配置对象转换为原始值的方式](#objectprototype-configuring-how-objects-are-converted-to-primitive-values)'
- en: '[31.10.2 `Object.prototype.*`: useful methods with pitfalls](#objectprototype-useful-methods-with-pitfalls)'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.10.2 `Object.prototype.*`: 有用的方法及其陷阱](#objectprototype-useful-methods-with-pitfalls)'
- en: '[31.10.3 `Object.prototype.*`: methods to avoid](#objectprototype-methods-to-avoid)'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.10.3 `Object.prototype.*`: 需要避免的方法](#objectprototype-methods-to-avoid)'
- en: '[31.11 FAQ: classes](#faq-classes)'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.11 常见问题：类](#faq-classes)'
- en: '[31.11.1 Why are they called “instance private fields” in this book and not
    “private instance fields”?](#why-are-they-called-instance-private-fields-in-this-book-and-not-private-instance-fields)'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.11.1 为什么本书中称其为“实例私有字段”而不是“私有实例字段”？](#why-are-they-called-instance-private-fields-in-this-book-and-not-private-instance-fields)'
- en: '[31.11.2 Why the identifier prefix `#`? Why not declare private fields via
    `private`?](#why-the-identifier-prefix--why-not-declare-private-fields-via-private)'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[31.11.2 为什么标识符前缀是`#`？为什么不通过`private`声明私有字段？](#why-the-identifier-prefix--why-not-declare-private-fields-via-private)'
- en: 'In this book, JavaScript’s style of object-oriented programming (OOP) is introduced
    in four steps. This chapter covers step 3 and 4, [the previous chapter](ch_objects.html#ch_objects)
    covers step 1 and 2\. The steps are ([figure 31.1](#fig:oop_steps_3_4)):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，JavaScript的面向对象编程（OOP）风格分四步介绍。本章涵盖第3步和第4步，[前一章](ch_objects.html#ch_objects)涵盖第1步和第2步。步骤如下（[图31.1](#fig:oop_steps_3_4)）：
- en: '**Single objects (previous chapter):** How do *objects*, JavaScript’s basic
    OOP building blocks, work in isolation?'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单个对象（前一章）：** JavaScript的基本OOP构建块*对象*在独立状态下是如何工作的？'
- en: '**Prototype chains (previous chapter):** Each object has a chain of zero or
    more *prototype objects*. Prototypes are JavaScript’s core inheritance mechanism.'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**原型链（前一章）：** 每个对象都有一个零个或多个*原型对象*的链。原型是JavaScript的核心继承机制。'
- en: '**Classes (this chapter):** JavaScript’s *classes* are factories for objects.
    The relationship between a class and its instances is based on prototypal inheritance
    (step 2).'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**类（本章）：** JavaScript的*类*是对象的工厂。类与其实例之间的关系基于原型继承（第2步）。'
- en: '**Subclassing (this chapter):** The relationship between a *subclass* and its
    *superclass* is also based on prototypal inheritance.'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**子类化（本章）：** 子类与其超类之间的关系也基于原型继承。'
- en: '![](../Images/211f8dccf8d4dc41541fb43a82eac91f.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/211f8dccf8d4dc41541fb43a82eac91f.png)'
- en: 'Figure 31.1: This book introduces object-oriented programming in JavaScript
    in four steps.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 31.1：本书通过四个步骤介绍了 JavaScript 中的面向对象编程。
- en: '[31.1 Cheat sheet: classes](#cheat-sheet-classes)'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[31.1 速查表：类](#cheat-sheet-classes)'
- en: 'A JavaScript class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 JavaScript 类：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Explanations:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：
- en: Inside a class, `this` refers to the current instance
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类内部，`this` 指的是当前实例
- en: 'Line A: constructor of the class'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 A：类的构造函数
- en: 'Line B: Property `.firstName` (a public slot) is created (no prior declaration
    necessary).'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 B：属性 `.firstName`（一个公共槽位）被创建（不需要先声明）。
- en: 'Line C: method `.describe()`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 C：方法 `.describe()`
- en: Public instance data such as `.firstName` is relatively common in JavaScript.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 公共实例数据，如 `.firstName`，在 JavaScript 中相对常见。
- en: 'The same class `Person`, but with private instance data:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相同的 `Person` 类，但带有私有实例数据：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Explanations:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：
- en: 'Line A: private field `.#firstName`. In contrast to properties, private fields
    must be declared (line A) before they can be used (line B). A private field can
    only be accessed inside the class that declares it. It can’t even be accessed
    by subclasses.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 A：私有字段 `.#firstName`。与属性不同，私有字段必须在它们可以使用之前声明（行 A）。私有字段只能在其声明的类内部访问。它甚至不能被子类访问。
- en: 'Class `Employee` is a subclass of `Person`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `Employee` 是 `Person` 的子类：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Line A: In subclasses, we can omit the constructor. If we don’t, we have to
    call `super()`.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 A：在子类中，我们可以省略构造函数。如果我们不省略，我们必须调用 `super()`。
- en: 'Line B: We can refer to overridden methods via `super`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 B：我们可以通过 `super` 来引用重写的方法。
- en: 'The next class demonstrates how to create properties via *public fields* (line
    A):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个类演示了如何通过 *公共字段* 来创建属性（行 A）：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: JavaScript also supports `static` members, but external functions and variables
    are often preferred.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 也支持 `static` 成员，但外部函数和变量通常更受欢迎。
- en: '[31.2 The essentials of classes](#classes)'
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[31.2 类的基本知识](#classes)'
- en: Classes are basically a compact syntax for setting up prototype chains (which
    are explained in [the previous chapter](ch_objects.html#prototype-chains)). Under
    the hood, JavaScript’s classes are unconventional. But that is something we rarely
    see when working with them. They should normally feel familiar to people who have
    used other object-oriented programming languages.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 类基本上是设置原型链（在 [上一章](ch_objects.html#prototype-chains) 中解释）的紧凑语法。在底层，JavaScript
    的类是非传统的。但这是我们很少在处理它们时看到的。对于使用过其他面向对象编程语言的人来说，它们应该感觉很熟悉。
- en: Note that we don’t need classes to create objects. We can also do so via [object
    literals](ch_objects.html#object-literals). That’s why the singleton pattern isn’t
    needed in JavaScript and classes are used less than in many other languages that
    have them.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要类来创建对象。我们也可以通过 [对象字面量](ch_objects.html#object-literals) 来这样做。这就是为什么在
    JavaScript 中不需要单例模式，并且类比许多其他有它们的语言使用得少。
- en: '[31.2.1 A class for persons](#a-class-for-persons)'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.2.1 个人类](#a-class-for-persons)'
- en: '[We have previously worked with `jane` and `tarzan`, single objects representing
    persons](ch_objects.html#sharing-data-via-prototypes). Let’s use a *class declaration*
    to implement a factory for such objects:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[我们之前已经与 `jane` 和 `tarzan` 一起工作过，它们是代表个人的单个对象](ch_objects.html#sharing-data-via-prototypes)。让我们使用
    *类声明* 来实现此类对象的工厂：'
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`jane` and `tarzan` can now be created via `new Person()`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`jane` 和 `tarzan` 现在可以通过 `new Person()` 来创建：'
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let’s examine what’s inside the body of class `Person`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查类 `Person` 的内部结构。
- en: '`.constructor()` is a special method that is called after the creation of a
    new instance. Inside it, `this` refers to that instance.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.constructor()` 是一个特殊的方法，在创建新实例之后被调用。在其中，`this` 指的是该实例。'
- en: '`.#firstName` ^(ES2022) is an *instance private field*: Such fields are stored
    in instances. They are accessed similarly to properties, but their names are separate
    – they always start with hash symbols (`#`). And they are invisible to the world
    outside the class:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.#firstName` (ES2022) 是一个 *实例私有字段*：此类字段存储在实例中。它们以类似于属性的方式访问，但它们的名称是分开的——它们总是以哈希符号（`#`）开头。并且它们对类外部的世界是不可见的：'
- en: '[PRE6]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Before we can initialize `.#firstName` in the constructor (line B), we need
    to declare it by mentioning it in the class body (line A).
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们可以在构造函数（行 B）中初始化 `.#firstName` 之前，我们需要通过在类体中提及它来声明它（行 A）。
- en: '`.describe()` is a method. If we invoke it via `obj.describe()` then `this`
    refers to `obj` inside the body of `.describe()`.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.describe()` 是一个方法。如果我们通过 `obj.describe()` 来调用它，那么 `.describe()` 体内的 `this`
    指向 `obj`。'
- en: '[PRE7]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`.extractName()` is a *static* method. “Static” means that it belongs to the
    class, not to instances:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.extractName()` 是一个*静态*方法。“静态”意味着它属于类，而不是实例：'
- en: '[PRE8]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can also create instance properties (public fields) in constructors:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在构造函数中创建实例属性（公共字段）：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In contrast to instance private fields, instance properties don’t have to be
    declared in class bodies.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与实例私有字段不同，实例属性不必在类体中声明。
- en: '[31.2.2 Class expressions](#class-expressions)'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.2.2 类表达式](#class-expressions)'
- en: 'There are two kinds of *class definitions* (ways of defining classes):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 类的定义有两种（定义类的方式）：
- en: '*Class declarations*, which we have seen in the previous section.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类声明*，我们在上一节中已经见过。'
- en: '*Class expressions*, which we’ll see next.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类表达式*，我们将在下一节中看到。'
- en: 'Class expressions can be anonymous and named:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 类表达式可以是匿名的和命名的：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The name of a named class expression works similarly to [the name of a named
    function expression](ch_callables.html#named-function-expressions): It can only
    be accessed inside the body of a class and stays the same, regardless of what
    the class is assigned to.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 命名类表达式的名称与[命名函数表达式的名称](ch_callables.html#named-function-expressions)类似：它只能在类体内部访问，并且保持不变，无论类被分配给什么。
- en: '[31.2.3 The `instanceof` operator](#the-instanceof-operator)'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.2.3 `instanceof` 操作符](#the-instanceof-operator)'
- en: 'The `instanceof` operator tells us if a value is an instance of a given class:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof` 操作符告诉我们一个值是否是给定类的实例：'
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’ll explore the `instanceof` operator in more detail [later](#instanceof-operator-details),
    after we have looked at subclassing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们研究了子类化之后，我们将在[“属性属性和属性描述符（ES5）（高级）”（§30.10）](ch_objects.html#property-attributes-property-descriptors)中更详细地探讨
    `instanceof` 操作符。
- en: '[31.2.4 Public slots (properties) vs. private slots](#private-slots)'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.2.4 公共槽位（属性）与私有槽位](#private-slots)'
- en: In the JavaScript language, objects can have two kinds of “slots”.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 语言中，对象可以有两大类“槽位”。
- en: '*Public slots* (which are are also called *properties*). For example, methods
    are public slots.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*公共槽位*（也称为*属性*）。例如，方法就是公共槽位。'
- en: '*Private slots* ^(ES2022). For example, private fields are private slots.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*私有槽位*（ES2022）。例如，私有字段是私有槽位。'
- en: 'These are the most important rules we need to know about properties and private
    slots:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们需要了解的关于属性和私有槽位最重要的规则：
- en: In classes, we can use public and private versions of fields, methods, getters
    and setters. All of them are slots in objects. Which objects they are placed in
    depends on whether the keyword `static` is used and other factors.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类中，我们可以使用公共和私有版本的字段、方法、获取器和设置器。所有这些都是对象的槽位。它们放置在哪个对象中取决于是否使用了关键字 `static` 以及其他因素。
- en: A getter and a setter that have the same key create a single *accessor* slot.
    An Accessor can also have only a getter or only a setter.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有相同键的获取器和设置器创建一个单一的*访问器*槽位。访问器也可以只包含获取器或只包含设置器。
- en: 'Properties and private slots are very different – for example:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性和私有槽位非常不同——例如：
- en: They are stored separately.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们被单独存储。
- en: Their keys are different. The keys of private slots can’t even be accessed directly
    (see [“Each private slot has a unique key (a *private name*)” (§31.2.5.2)](#private-names)
    later in this chapter).
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的键是不同的。私有槽位的键甚至不能直接访问（参见本章后面的[“每个私有槽位都有一个唯一的键（一个*私有名称*）”（§31.2.5.2）](#private-names)）。
- en: Properties are inherited from prototypes, private slots aren’t.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性是从原型继承的，私有槽位不是。
- en: Private slots can only be created via classes.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有槽位只能通过类来创建。
- en: 'The following class demonstrates the two kinds of slots. Each of its instances
    has one private field and one property:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类演示了两种槽位。它的每个实例都有一个私有字段和一个属性：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As expected, outside `MyClass`, we can only see the property:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，在 `MyClass` 之外，我们只能看到属性：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **More information
    on properties**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“细节”](../Images/38ba63de820aae6f94a019538ae0f222.png) **关于属性的更多信息**'
- en: This chapter doesn’t cover all details of properties (just the essentials).
    If you want to dig deeper, you can do so in [“Property attributes and property
    descriptors ^(ES5) (advanced)” (§30.10)](ch_objects.html#property-attributes-property-descriptors)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有涵盖所有属性细节（只包含基本内容）。如果您想深入了解，可以在[“属性属性和属性描述符（ES5）（高级）”（§30.10）](ch_objects.html#property-attributes-property-descriptors)中找到相关信息。
- en: Next, we’ll look at some of the details of private slots.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨一些私有槽位的细节。
- en: '[31.2.5 Private slots in more detail ^(ES2022) (advanced)](#private-slots-in-more-detail-es2022-advanced)'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.2.5 私有槽位更详细地说明^(ES2022) (高级)](#private-slots-in-more-detail-es2022-advanced)'
- en: '[31.2.5.1 Private slots can’t be accessed in subclasses](#private-slots-cant-be-accessed-in-subclasses)'
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.2.5.1 私有槽位在子类中无法访问](#private-slots-cant-be-accessed-in-subclasses)'
- en: 'A private slot really can only be accessed inside the class that declares it.
    We can’t even access it from a subclass:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 私有槽位实际上只能在其声明的类内部访问。我们甚至无法从子类中访问它：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Subclassing via `extends`](#subclassing) is explained later in this chapter.
    How to work around this limitation is explained in [“Simulating protected visibility
    and friend visibility via WeakMaps (advanced)” (§31.5.4)](#instance-protected-fields).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[通过`extends`进行子类化]将在本章后面解释。如何解决这个问题将在[“通过WeakMaps模拟受保护可见性和友元可见性（高级）”（§31.5.4）](#instance-protected-fields)中解释。'
- en: '[31.2.5.2 Each private slot has a unique key (a *private name*)](#private-names)'
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.2.5.2 每个私有槽位都有一个唯一的键（一个*私有名称*）](#private-names)'
- en: 'Private slots have unique keys that are similar to [symbols](ch_symbols.html#ch_symbols).
    Consider the following class from earlier:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 私有槽位具有独特的键，类似于[symbols](ch_symbols.html#ch_symbols)。考虑以下之前提到的类：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Internally, the private field of `MyClass` is handled roughly like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`MyClass`的私有字段大致是这样处理的：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The value of `instancePrivateFieldKey` is called a *private name*. We can’t
    use private names directly in JavaScript, we can only use them indirectly, via
    the fixed identifiers of private fields, private methods, and private accessors.
    Where the fixed identifiers of public slots (such as `getInstanceValues`) are
    interpreted as string keys, the fixed identifiers of private slots (such as `#instancePrivateField`)
    refer to private names (similarly to how variable names refer to values).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`instancePrivateFieldKey`的值被称为*私有名称*。我们无法直接在JavaScript中使用私有名称，我们只能通过私有字段、私有方法和私有访问器的固定标识符间接使用它们。公共槽位的固定标识符（如`getInstanceValues`）被解释为字符串键，而私有槽位的固定标识符（如`#instancePrivateField`）指向私有名称（类似于变量名称指向值）。'
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **Private
    slots in the ECMAScript language specification**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“详情”](../Images/38ba63de820aae6f94a019538ae0f222.png) **ECMAScript语言规范中的私有槽位**'
- en: Section [“Object Internal Methods and Internal Slots”](https://tc39.es/ecma262/#sec-object-internal-methods-and-internal-slots)
    in the ECMAScript language specification explains how private slots work. Search
    for “`[[PrivateElements]]`”.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript语言规范中的[“对象内部方法和内部槽位”](https://tc39.es/ecma262/#sec-object-internal-methods-and-internal-slots)部分解释了私有槽位是如何工作的。搜索“`[[PrivateElements]]`”。
- en: '[31.2.5.3 Private names are statically scoped (like variables)](#private-names-are-statically-scoped-like-variables)'
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.2.5.3 私有名称是静态作用域的（像变量一样）](#private-names-are-statically-scoped-like-variables)'
- en: 'A callable entity can only access the name of a private slot if it was born
    inside the scope where the name was declared. However, it doesn’t lose this ability
    if it moves somewhere else later on:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 可调用实体只能在其名称声明的范围内访问私有槽位的名称。然而，如果它后来移动到其他地方，它不会失去这种能力：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The arrow function `getter` was born inside `MyClass` (line A), but it can still
    access the private name `#privateData` after it left its birth scope (line B).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数`getter`是在`MyClass`（行A）内部创建的，但即使它离开了其出生的作用域（行B），它仍然可以访问私有名称`#privateData`。
- en: '[31.2.5.4 The same private identifier refers to different private names in
    different classes](#the-same-private-identifier-refers-to-different-private-names-in-different-classes)'
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.2.5.4 相同的私有标识符在不同类中指向不同的私有名称](#the-same-private-identifier-refers-to-different-private-names-in-different-classes)'
- en: 'Because the identifiers of private slots aren’t used as keys, using the same
    identifier in different classes produces different slots (line A and line C):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因为私有槽位的标识符不作为键使用，所以在不同的类中使用相同的标识符会产生不同的槽位（行A和行C）：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[31.2.5.5 The names of private fields never clash](#the-names-of-private-fields-never-clash)'
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.2.5.5 私有字段的名称永远不会冲突](#the-names-of-private-fields-never-clash)'
- en: 'Even if a subclass uses the same name for a private field, the two names never
    clash because they refer to private names (which are always unique). In the following
    example, `.#privateField` in `SuperClass` does not clash with `.#privateField`
    in `SubClass`, even though both slots are stored directly in `inst`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 即使子类使用相同的名称为私有字段命名，这两个名称也永远不会冲突，因为它们指向私有名称（这些名称始终是唯一的）。在以下示例中，`SuperClass`中的`.#privateField`不会与`SubClass`中的`.#privateField`冲突，尽管这两个槽位都直接存储在`inst`中：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[Subclassing via `extends`](#subclassing) is explained later in this chapter.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[通过`extends`进行子类化](#subclassing)将在本章后面解释。'
- en: '[31.2.5.6 Using `in` to check if an object has a given private slot](#private-slot-checks)'
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.2.5.6 使用`in`检查对象是否具有特定的私有槽](#private-slot-checks)'
- en: 'The `in` operator can be used to check if a private slot exists (line A):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`运算符可以用来检查是否存在私有槽（行A）：'
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let’s look at more examples of `in` applied to private slots.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看将`in`应用于私有槽的更多示例。
- en: '**Private methods.** The following code shows that private methods create private
    slots in instances:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**私有方法**。以下代码显示私有方法在实例中创建了私有槽位：'
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Static private fields.** We can also use `in` for a static private field:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态私有字段**。我们也可以使用`in`来检查静态私有字段：'
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Static private methods.** And we can check for the slot of a static private
    method:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态私有方法**。我们还可以检查静态私有方法的槽位：'
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Using the same private identifier in different classes.** In the next example,
    the two classes `Color` and `Person` both have a slot whose identifier is `#name`.
    The `in` operator distinguishes them correctly:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**在不同类中使用相同的私有标识符**。在下一个示例中，两个类`Color`和`Person`都有一个标识符为`#name`的槽位。`in`运算符可以正确地区分它们：'
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[31.2.6 The pros and cons of classes in JavaScript](#the-pros-and-cons-of-classes-in-javascript)'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.2.6 JavaScript中类的优缺点](#the-pros-and-cons-of-classes-in-javascript)'
- en: 'I recommend using classes for the following reasons:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议出于以下原因使用类：
- en: Classes are a common standard for object creation and inheritance that is now
    widely supported across libraries and frameworks. This is an improvement compared
    to how things were before, when almost every framework had its own inheritance
    library.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类是对象创建和继承的常见标准，现在在库和框架中得到广泛支持。这与之前的情况相比是一个改进，因为在之前，几乎每个框架都有自己的继承库。
- en: They help tools such as IDEs and type checkers with their work and enable new
    features there.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们帮助IDE和类型检查器等工具完成工作，并使新功能成为可能。
- en: If you come from another language to JavaScript and are used to classes, then
    you can get started more quickly.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你来自其他语言，并且习惯了类，那么你可以更快地开始。
- en: JavaScript engines optimize them. That is, code that uses classes is almost
    always faster than code that uses a custom inheritance library.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript引擎对它们进行了优化。也就是说，使用类的代码几乎总是比使用自定义继承库的代码更快。
- en: We can subclass built-in constructor functions such as `Error`.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将内置构造函数如`Error`进行子类化。
- en: 'That doesn’t mean that classes are perfect:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着类是完美的：
- en: There is a risk of overdoing inheritance.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过度使用继承存在风险。
- en: There is a risk of putting too much functionality in classes (when some of it
    is often better put in functions).
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类中放入过多的功能存在风险（当其中一些功能更适合放在函数中时）。
- en: Classes look familiar to programmers coming from other languages, but they work
    differently and are used differently (see next subsection). Therefore, there is
    a risk of those programmers writing code that doesn’t feel like JavaScript.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于来自其他语言的程序员来说，类看起来很熟悉，但它们的工作方式和用途不同（参见下一小节）。因此，这些程序员编写出的代码可能不符合JavaScript的风格。
- en: 'How classes seem to work superficially is quite different from how they actually
    work. In other words, there is a disconnect between syntax and semantics. Two
    examples are:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类表面上看起来是如何工作的，与它们实际工作方式相当不同。换句话说，语法和语义之间存在不连接。两个例子是：
- en: A method definition inside a class `C` creates a method in the object `C.prototype`.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类`C`内部定义的方法会在对象`C.prototype`中创建一个方法。
- en: Classes are functions.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类是函数。
- en: The motivation for the disconnect is backward compatibility. Thankfully, the
    disconnect causes few problems in practice; we are usually OK if we go along with
    what classes pretend to be.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种不连接的原因是向后兼容性。幸运的是，在实践中，这种不连接造成的问题很少；如果我们遵循类所表现出的行为，通常不会有问题。
- en: This was a first look at classes. We’ll explore more features soon.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们对类的第一次了解。我们很快将探索更多功能。
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Writing a class**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![“练习”图标](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：编写一个类**'
- en: '`exercises/classes/point_class_test.mjs`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/classes/point_class_test.mjs`'
- en: '[31.2.7 Tips for using classes](#tips-for-using-classes)'
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.2.7 使用类的技巧](#tips-for-using-classes)'
- en: Use inheritance sparingly – it tends to make code more complicated and spread
    out related functionality across multiple locations.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适度使用继承——它往往会使代码更加复杂，并将相关功能分散到多个位置。
- en: 'Instead of static members, it is often better to use external functions and
    variables. We can even make those private to a module, simply by not exporting
    them. Two important exceptions to this rule are:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与静态成员相比，通常更好的做法是使用外部函数和变量。我们甚至可以通过不导出它们来将这些函数和变量私有化。这个规则的两个重要例外是：
- en: Operations that need access to private slots
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要访问私有槽位的操作
- en: '[Static factory methods](#static-factory-methods)'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[静态工厂方法](#static-factory-methods)'
- en: Only put core functionality in prototype methods. Other functionality is better
    implemented via functions – especially algorithms that involve instances of multiple
    classes.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只应在原型方法中放置核心功能。其他功能最好通过函数实现，尤其是涉及多个类实例的算法。
- en: '[31.3 The internals of classes](#internals-of-classes)'
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[31.3 类的内部结构](#internals-of-classes)'
- en: '[31.3.1 A class is actually two connected objects](#a-class-is-actually-two-connected-objects)'
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.3.1 类实际上是两个连接的对象](#a-class-is-actually-two-connected-objects)'
- en: 'Under the hood, a class becomes two connected objects. Let’s revisit class
    `Person` to see how that works:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，一个类变成了两个连接的对象。让我们回顾一下 `Person` 类，看看它是如何工作的：
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The first object created by the class is stored in `Person`. It has four properties:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 类创建的第一个对象存储在 `Person` 中。它有四个属性：
- en: '[PRE26]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The two remaining properties are:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的两个属性是：
- en: '`Person.extractNames` is the static method that we have already seen in action.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Person.extractNames` 是我们之前已经看到过作用的静态方法。'
- en: '`Person.prototype` points to the second object that is created by a class definition.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Person.prototype` 指向由类定义创建的第二个对象。'
- en: 'These are the contents of `Person.prototype`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 `Person.prototype` 的内容：
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There are two properties:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个属性：
- en: '`Person.prototype.constructor` points to the constructor.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Person.prototype.constructor` 指向构造函数。'
- en: '`Person.prototype.describe` is the method that we have already used.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Person.prototype.describe` 是我们已经使用过的那个方法。'
- en: '[31.3.2 Classes set up the prototype chains of their instances](#classes-set-up-the-prototype-chains-of-their-instances)'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.3.2 类的实例原型链的设置](#classes-set-up-the-prototype-chains-of-their-instances)'
- en: 'The object `Person.prototype` is the prototype of all instances:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person.prototype` 对象是所有实例的原型：'
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That explains how the instances get their methods: They inherit them from the
    object `Person.prototype`.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了实例如何获得它们的方法：它们从 `Person.prototype` 对象继承。
- en: '[Figure 31.2](#fig:oo_person_class) visualizes how everything is connected.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 31.2](#fig:oo_person_class) 可视化了所有连接的方式。'
- en: '![](../Images/96be80cce4461d811881a458537b27cb.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/96be80cce4461d811881a458537b27cb.png)'
- en: 'Figure 31.2: The class `Person` has the property `.prototype` that points to
    an object that is the prototype of all instances of `Person`. The objects `jane`
    and `tarzan` are two such instances.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 31.2：类 `Person` 有一个属性 `.prototype`，它指向一个对象，该对象是 `Person` 所有实例的原型。`jane` 和
    `tarzan` 是这样的两个实例。
- en: '[31.3.3 `.__proto__` vs. `.prototype`](#proto-vs-prototype)'
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.3.3 `.__proto__` 与 `.prototype`](#proto-vs-prototype)'
- en: 'It is easy to confuse `.__proto__` and `.prototype`. Hopefully, [figure 31.2](#fig:oo_person_class)
    makes it clear how they differ:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 容易混淆 `.__proto__` 和 `.prototype`。希望图 31.2 能清楚地说明它们之间的区别：
- en: '[`Object.prototype.__proto__`](#Object.prototype.__proto__) is an accessor
    that most objects inherit that gets and sets the prototype of the receiver. Therefore
    the following two expressions are equivalent:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Object.prototype.__proto__`](#Object.prototype.__proto__) 是一个访问器，大多数对象都继承它，用于获取和设置接收者的原型。因此，以下两个表达式是等价的：'
- en: '[PRE29]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As are the following two expressions:'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如下两个表达式也是一样：
- en: '[PRE30]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`SomeClass.prototype` holds the object that becomes the prototype of all instances
    of `SomeClass`. A better name for `.prototype` would be `.instancePrototype`.
    This property is only special because the `new` operator uses it to set up instances
    of `SomeClass`.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SomeClass.prototype` 存储了将成为 `SomeClass` 所有实例原型的对象。`.prototype` 的更好名称可能是 `.instancePrototype`。这个属性之所以特别，是因为
    `new` 操作符使用它来设置 `SomeClass` 的实例。'
- en: '[PRE31]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[31.3.4 `Person.prototype.constructor` (advanced)](#personprototypeconstructor-advanced)'
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.3.4 `Person.prototype.constructor`（高级）](#personprototypeconstructor-advanced)'
- en: 'There is one detail in [figure 31.2](#fig:oo_person_class) that we haven’t
    looked at, yet: `Person.prototype.constructor` points back to `Person`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 31.2 中有一个细节我们还没有看过：`Person.prototype.constructor` 指向 `Person`：
- en: '[PRE32]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This setup exists due to backward compatibility. But it has two additional benefits.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置存在是因为向后兼容性。但它有两个额外的优点。
- en: 'First, each instance of a class inherits property `.constructor`. Therefore,
    given an instance, we can make “similar” objects via it:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，类的每个实例都继承属性 `.constructor`。因此，给定一个实例，我们可以通过它创建“类似”的对象：
- en: '[PRE33]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Second, we can get the name of the class that created a given instance:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可以获取创建给定实例的类的名称：
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[31.3.5 Dispatched vs. direct method calls (advanced)](#method-calls-dispatched-direct)'
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.3.5   分发与直接方法调用（高级）](#method-calls-dispatched-direct)'
- en: 'In this subsection, we learn about two different ways of invoking methods:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将学习两种调用方法的不同方式：
- en: Dispatched method calls
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发方法调用
- en: Direct method calls
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接方法调用
- en: Understanding both of them will give us important insights into how methods
    work.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这两者将使我们深入了解方法的工作原理。
- en: 'We’ll also need the second way [later](#using-object-methods-safely) in this
    chapter: It will allow us to borrow useful methods from `Object.prototype`.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们还需要第二种方式[稍后](#using-object-methods-safely)：它将允许我们从 `Object.prototype`
    中借用有用的方法。
- en: '[31.3.5.1 Dispatched method calls](#dispatched-method-calls)'
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.3.5.1   分发方法调用](#dispatched-method-calls)'
- en: 'Let’s examine how method calls work with classes. We are revisiting `jane`
    from earlier:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看类中方法调用是如何工作的。我们将重新审视之前提到的 `jane`：
- en: '[PRE35]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[Figure 31.3](#fig:jane_proto_chain) has a diagram with `jane`’s prototype
    chain.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 31.3](#fig:jane_proto_chain) 展示了 `jane` 的原型链。'
- en: '![](../Images/75efdfc55284976c46d9812c0dd3353b.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/75efdfc55284976c46d9812c0dd3353b.png)'
- en: 'Figure 31.3: The prototype chain of `jane` starts with `jane` and continues
    with `Person.prototype`.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 31.3：`jane` 的原型链从 `jane` 开始，然后继续到 `Person.prototype`。
- en: Normal method calls are *dispatched* – the method call
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 正常方法调用是*分发的*——方法调用
- en: '[PRE36]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'happens in two steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 发生在两个步骤中：
- en: 'Dispatch: JavaScript traverses the prototype chain starting with `jane` to
    find the first object that has an own property with the key `''describe''`: It
    first looks at `jane` and doesn’t find an own property `.describe`. It continues
    with `jane`’s prototype, `Person.prototype` and finds an own property `describe`
    whose value it returns.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发：JavaScript 从 `jane` 开始遍历原型链，寻找第一个具有键 `'describe'` 的自有属性的对象：它首先查看 `jane` 并未找到自有属性
    `.describe`。然后继续到 `jane` 的原型，`Person.prototype`，并找到一个自有属性 `describe`，其值被返回。
- en: '[PRE37]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Invocation: Method-invoking a value is different from function-invoking a value
    in that it not only calls what comes before the parentheses with the arguments
    inside the parentheses but also sets `this` to the receiver of the method call
    (in this case, `jane`):'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用：方法调用与函数调用不同，它不仅调用括号前的内容，并将括号内的参数作为参数传递，而且还设置 `this` 为方法调用的接收者（在这种情况下，`jane`）：
- en: '[PRE38]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This way of dynamically looking for a method and invoking it is called *dynamic
    dispatch*.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这种动态查找方法并调用它的方式被称为*动态分发*。
- en: '[31.3.5.2 Direct method calls](#direct-method-calls)'
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.3.5.2   直接方法调用](#direct-method-calls)'
- en: 'We can also make method calls *directly*, without dispatching:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以直接进行方法调用，而不进行分发：
- en: '[PRE39]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This time, we directly point to the method via `Person.prototype.describe` and
    don’t search for it in the prototype chain. We also specify `this` differently
    – via `.call()`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们通过 `Person.prototype.describe` 直接指向该方法，而不是在原型链中搜索它。我们还通过 `.call()` 以不同的方式指定
    `this`。
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **`this`
    always points to the instance**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![“详情”图标](../Images/38ba63de820aae6f94a019538ae0f222.png) **`this` 总是指向实例**'
- en: No matter where in the prototype chain of an instance a method is located, `this`
    always points to the instance (the beginning of the prototype chain). That enables
    `.describe()` to access `.#firstName` in the example.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 无论方法位于实例原型链的哪个位置，`this` 总是指向实例（原型链的开始）。这使得 `.describe()` 能够在示例中访问 `.#firstName`。
- en: 'When are direct method calls useful? Whenever we want to borrow a method from
    elsewhere that a given object doesn’t have – for example:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 直接方法调用何时有用？当我们想要从其他地方借用一个给定对象没有的方法时——例如：
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[31.3.6 Classes evolved from ordinary functions (advanced)](#classes-evolved-from-ordinary-functions-advanced)'
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.3.6   类从普通函数演变而来（高级）](#classes-evolved-from-ordinary-functions-advanced)'
- en: 'Before ECMAScript 6, JavaScript didn’t have classes. Instead, [ordinary functions](ch_callables.html#ordinary-functions)
    were used as *constructor functions*:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ECMAScript 6 之前，JavaScript 没有类。相反，使用[普通函数](ch_callables.html#ordinary-functions)作为*构造函数*：
- en: '[PRE41]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Classes provide better syntax for this approach:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 类提供了更好的语法来实现这种方法：
- en: '[PRE42]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Subclassing is especially tricky with constructor functions. Classes also offer
    benefits that go beyond more convenient syntax:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，继承尤其复杂。类还提供了比更方便的语法更多的好处：
- en: Built-in constructor functions such as `Error` can be subclassed.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置构造函数，如 `Error`，可以被继承。
- en: We can access overridden properties via `super`.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过 `super` 访问重写的属性。
- en: Classes can’t be function-called.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类不能被函数调用。
- en: Methods can’t be `new`-called and don’t have the property `.prototype`.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法不能被 `new` 调用，并且没有 `.prototype` 属性。
- en: Support for private instance data.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持私有实例数据。
- en: And more.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有更多。
- en: 'Classes are so compatible with constructor functions that they can even extend
    them:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 类与构造函数的兼容性如此之高，以至于它们甚至可以扩展它们：
- en: '[PRE43]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`extends` and subclassing are explained [later in this chapter](#subclassing).'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`extends` 和子类化将在本章 [后面](#subclassing) 解释。'
- en: '[31.3.6.1 A class is the constructor](#a-class-is-the-constructor)'
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.3.6.1 类是构造函数](#a-class-is-the-constructor)'
- en: This brings us to an interesting insight. On one hand, `StringBuilderClass`
    refers to its constructor via `StringBuilderClass.prototype.constructor`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个有趣的见解。一方面，`StringBuilderClass` 通过 `StringBuilderClass.prototype.constructor`
    引用其构造函数。
- en: 'On the other hand, the class *is* the constructor (a function):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，类 *就是* 构造函数（一个函数）：
- en: '[PRE44]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **Constructor
    (functions) vs. classes**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“详情”](../Images/38ba63de820aae6f94a019538ae0f222.png) **构造函数（函数）与类**'
- en: Due to how similar they are, I use the terms *constructor (function)* and *class*
    interchangeably.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们非常相似，我交替使用术语 *构造函数（函数）* 和 *类*。
- en: '[31.4 Prototype members of classes](#prototype-members-of-classes)'
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[31.4 类的原型成员](#prototype-members-of-classes)'
- en: '[31.4.1 Public prototype methods and accessors](#public-prototype-methods-and-accessors)'
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.4.1 公共原型方法和访问器](#public-prototype-methods-and-accessors)'
- en: All members in the body of the following class declaration create properties
    of `PublicProtoClass.prototype`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类声明体中的所有成员都创建 `PublicProtoClass.prototype` 的属性。
- en: '[PRE45]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[31.4.1.1 All kinds of public prototype methods and accessors (advanced)](#all-kinds-of-public-prototype-methods-and-accessors-advanced)'
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.4.1.1 所有类型的公共原型方法和访问器（高级）](#all-kinds-of-public-prototype-methods-and-accessors-advanced)'
- en: '[PRE46]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Quoted and computed keys can also be used in object literals:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 引号键和计算键也可以用在对象字面量中：
- en: '[“Quoted keys in object literals” (§30.9.1)](ch_objects.html#object-literals-quoted-keys)'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“对象字面量中的引号键” (§30.9.1)](ch_objects.html#object-literals-quoted-keys)'
- en: '[“Computed keys in object literals” (§30.9.2)](ch_objects.html#object-literals-computed-keys)'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“对象字面量中的计算键” (§30.9.2)](ch_objects.html#object-literals-computed-keys)'
- en: 'More information on accessors (defined via getters and/or setters), generators,
    async methods, and async generator methods:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 关于访问器（通过获取器和/或设置器定义）、生成器、异步方法和异步生成器方法的更多信息：
- en: '[“Object literals: accessors” (§30.3.6)](ch_objects.html#object-literal-accessors)'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“对象字面量：访问器” (§30.3.6)](ch_objects.html#object-literal-accessors)'
- en: '[“Synchronous generators ^(ES6) (advanced)” (§33)](ch_sync-generators.html#ch_sync-generators)'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“同步生成器 (ES6)（高级）”(§33)](ch_sync-generators.html#ch_sync-generators)'
- en: '[“Async functions ^(ES2017)” (§44)](ch_async-functions.html#ch_async-functions)'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“异步函数 (ES2017)” (§44)](ch_async-functions.html#ch_async-functions)'
- en: '[“Asynchronous generators” (§45.2)](ch_async-iteration.html#async-generators)'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“异步生成器” (§45.2)](ch_async-iteration.html#async-generators)'
- en: '[31.4.2 Private methods and accessors ^(ES2022)](#private-methods-accessors)'
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.4.2 私有方法和访问器 (ES2022)](#private-methods-accessors)'
- en: Private methods (and accessors) are an interesting mix of prototype members
    and instance members.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 私有方法（和访问器）是原型成员和实例成员的一个有趣混合。
- en: 'On one hand, private methods are stored in slots in instances (line A):'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，私有方法存储在实例的槽位中（行 A）：
- en: '[PRE47]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Why are they not stored in `.prototype` objects? Private slots are not inherited,
    only properties are.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它们不存储在 `.prototype` 对象中？私有槽位不继承，只有属性才继承。
- en: 'On the other hand, private methods are shared between instances – like prototype
    public methods:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，私有方法在实例之间共享——就像原型公共方法一样：
- en: '[PRE48]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Due to that and due to their syntax being similar to prototype public methods,
    they are covered here.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这一点以及它们的语法与原型公共方法相似，因此它们在这里被涵盖。
- en: 'The following code demonstrates how private methods and accessors work:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了私有方法和访问器是如何工作的：
- en: '[PRE49]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[31.4.2.1 All kinds of private methods and accessors (advanced)](#all-kinds-of-private-methods-and-accessors-advanced)'
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.4.2.1 所有类型的私有方法和访问器（高级）](#all-kinds-of-private-methods-and-accessors-advanced)'
- en: 'With private slots, the keys are always identifiers:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 使用私有槽位，键始终是标识符：
- en: '[PRE50]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'More information on accessors (defined via getters and/or setters), generators,
    async methods, and async generator methods:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 关于访问器（通过获取器和/或设置器定义）、生成器、异步方法和异步生成器方法的更多信息：
- en: '[“Object literals: accessors” (§30.3.6)](ch_objects.html#object-literal-accessors)'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“对象字面量：访问器” (§30.3.6)](ch_objects.html#object-literal-accessors)'
- en: '[“Synchronous generators ^(ES6) (advanced)” (§33)](ch_sync-generators.html#ch_sync-generators)'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“同步生成器（ES6）”（§33）](ch_sync-generators.html#ch_sync-generators)'
- en: '[“Async functions ^(ES2017)” (§44)](ch_async-functions.html#ch_async-functions)'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“异步函数（ES2017）”（§44）](ch_async-functions.html#ch_async-functions)'
- en: '[“Asynchronous generators” (§45.2)](ch_async-iteration.html#async-generators)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“异步生成器”（§45.2）](ch_async-iteration.html#async-generators)'
- en: '[31.5 Instance members of classes ^(ES2022)](#instance-members-of-classes-es2022)'
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[31.5 类实例成员（ES2022）](#instance-members-of-classes-es2022)'
- en: '[31.5.1 Instance public fields](#instance-public-fields)'
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.5.1 实例公共字段](#instance-public-fields)'
- en: 'Instances of the following class have two instance properties (created in line
    A and line B):'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类的实例有两个实例属性（在行A和行B创建）：
- en: '[PRE51]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If we create an instance property inside the constructor (line B), we don’t
    need to “declare” it elsewhere. As we have already seen, that is different for
    instance private fields.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在构造函数内创建一个实例属性（行B），我们就不需要在其他地方“声明”它。正如我们之前看到的，这与实例私有字段不同。
- en: Note that instance properties are relatively common in JavaScript; much more
    so than in, e.g., Java, where most instance state is private.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，实例属性在JavaScript中相对常见；比例如Java中的实例状态私有得多。
- en: '[31.5.1.1 Instance public fields with quoted and computed keys (advanced)](#instance-public-fields-quoted-keys-computed-keys)'
  id: totrans-322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.5.1.1 具有引号和计算键的实例公共字段（高级）](#instance-public-fields-quoted-keys-computed-keys)'
- en: '[PRE52]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[31.5.1.2 What is the value of `this` in instance public fields? (advanced)](#what-is-the-value-of-this-in-instance-public-fields-advanced)'
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.5.1.2 实例公共字段中的`this`的值是什么？（高级）](#what-is-the-value-of-this-in-instance-public-fields-advanced)'
- en: 'In the initializer of a instance public field, `this` refers to the newly created
    instance:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例公共字段的初始化器中，`this`指向新创建的实例：
- en: '[PRE53]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[31.5.1.3 When are instance public fields executed? (advanced)](#when-are-instance-public-fields-executed-advanced)'
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.5.1.3 实例公共字段何时执行？（高级）](#when-are-instance-public-fields-executed-advanced)'
- en: 'The execution of instance public fields roughly follows these two rules:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 实例公共字段的执行大致遵循以下两个规则：
- en: In base classes (classes without superclasses), instance public fields are executed
    immediately before the constructor.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基类（没有超类的类）中，实例公共字段在构造函数调用之前立即执行。
- en: 'In derived classes (classes with superclasses):'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在派生类（有超类的类）中：
- en: The superclass sets up its instance slots when `super()` is called.
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用`super()`时，超类设置其实例槽位。
- en: Instance public fields are executed immediately after `super()`.
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例公共字段在`super()`之后立即执行。
- en: 'The following example demonstrates these rules:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了这些规则：
- en: '[PRE54]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Output:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE55]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`extends` and subclassing are explained [later in this chapter](#subclassing).'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`extends`和子类化将在本章[后面解释](#subclassing)。'
- en: '[31.5.2 Instance private fields](#instance-private-fields)'
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.5.2 实例私有字段](#instance-private-fields)'
- en: 'The following class contains two instance private fields (line A and line B):'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类包含两个实例私有字段（行A和行B）：
- en: '[PRE56]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note that we can only use `.#privateField2` in line C if we declare it in the
    class body.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只能在行C中使用`.#privateField2`，前提是我们已经在类体中声明了它。
- en: '[31.5.3 Private instance data before ES2022 (advanced)](#private-instance-data-before-es2022-advanced)'
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.5.3 ES2022之前的私有实例数据（高级）](#private-instance-data-before-es2022-advanced)'
- en: In this section, we look at two techniques for keeping instance data private.
    Because they don’t rely on classes, we can also use them for objects that were
    created in other ways – e.g., via object literals.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨两种保持实例数据私有的技术。因为它们不依赖于类，所以也可以用于以其他方式创建的对象——例如，通过对象字面量。
- en: '[31.5.3.1 Before ES6: private members via naming conventions](#before-es6-private-members-via-naming-conventions)'
  id: totrans-344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.5.3.1 在ES6之前：通过命名约定使用私有成员](#before-es6-private-members-via-naming-conventions)'
- en: 'The first technique makes a property private by prefixing its name with an
    underscore. This doesn’t protect the property in any way; it merely signals to
    the outside: “You don’t need to know about this property.”'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种技术通过在属性名称前加上下划线使其成为私有属性。这并不能以任何方式保护属性；它仅仅向外界发出信号：“你不需要了解这个属性。”
- en: In the following code, the properties `._counter` and `._action` are private.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，属性`._counter`和`._action`是私有的。
- en: '[PRE57]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: With this technique, we don’t get any protection and private names can clash.
    On the plus side, it is easy to use.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，我们不会得到任何保护，私有名称可能会冲突。优点是易于使用。
- en: 'Private methods work similarly: They are normal methods whose names start with
    underscores.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 私有方法的工作方式类似：它们是正常方法，其名称以下划线开头。
- en: '[31.5.3.2 ES6 and later: private instance data via WeakMaps](#es6-and-later-private-instance-data-via-weakmaps)'
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.5.3.2 ES6 及以后版本：通过 WeakMaps 的私有实例数据](#es6-and-later-private-instance-data-via-weakmaps)'
- en: 'We can also manage private instance data via WeakMaps:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过 WeakMaps 管理私有实例数据：
- en: '[PRE58]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How exactly that works is explained [in the chapter on WeakMaps](ch_weakmaps.html#private-data-in-weakmaps).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这究竟是如何工作的，将在关于 WeakMaps 的章节中解释。
- en: This technique offers us considerable protection from outside access and there
    can’t be any name clashes. But it is also more complicated to use.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术为我们提供了相当大的外部访问保护，并且不会出现任何名称冲突。但使用起来也更复杂。
- en: 'We control the visibility of the pseudo-property `_superProp` by controlling
    who has access to it – for example: If the variable exists inside a module and
    isn’t exported, everyone inside the module and no one outside the module can access
    it. In other words: The scope of privacy isn’t the class in this case, it’s the
    module. We could narrow the scope, though:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过控制谁可以访问伪属性 `_superProp` 来控制其可见性 – 例如：如果变量在模块内部存在且未导出，则模块内部的所有人和模块外部的人都无法访问它。换句话说：在这种情况下，隐私的范围不是类，而是模块。尽管我们可以缩小范围：
- en: '[PRE59]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This technique doesn’t really support private methods. But module-local functions
    that have access to `_superProp` are the next best thing:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术实际上并不支持私有方法。但可以访问 `_superProp` 的模块本地函数是次优选择：
- en: '[PRE60]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note that `this` becomes the explicit function parameter `_this` (line A).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`this` 变成了显式函数参数 `_this`（行 A）。
- en: '[31.5.4 Simulating protected visibility and friend visibility via WeakMaps
    (advanced)](#instance-protected-fields)'
  id: totrans-360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.5.4 通过 WeakMaps 模拟受保护的可见性和朋友可见性（高级）](#instance-protected-fields)'
- en: 'As previously discussed, instance private fields are only visible inside their
    classes and not even in subclasses. Thus, there is no built-in way to get:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，实例私有字段仅在它们的类内部可见，甚至在子类中也不可见。因此，没有内置的方法可以获取：
- en: 'Protected visibility: A class and all of its subclasses can access a piece
    instance data.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受保护的可见性：一个类及其所有子类都可以访问一部分实例数据。
- en: 'Friend visibility: A class and its “friends” (designated functions, objects,
    or classes) can access a piece of instance data.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 朋友可见性：一个类及其“朋友”（指定的函数、对象或类）可以访问一部分实例数据。
- en: 'In the previous subsection, we simulated “module visibility” (everyone inside
    a module has access to a piece of instance data) via WeakMaps. Therefore:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的子节中，我们通过 WeakMaps 模拟了“模块可见性”（模块内部的人可以访问实例数据的一部分）。因此：
- en: If we put a class and its subclasses into the same module, we get protected
    visibility.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们将一个类及其子类放入同一个模块中，我们将获得受保护的可见性。
- en: If we put a class and its friends into the same module, we get friend visibility.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们将一个类及其朋友放入同一个模块中，我们将获得朋友可见性。
- en: 'The next example demonstrates protected visibility:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例演示了受保护的可见性：
- en: '[PRE61]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[Subclassing via `extends`](#subclassing) is explained later in this chapter.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `extends` 进行子类化将在本章后面进行解释。
- en: '[31.6 Static members of classes](#static-members-of-classes)'
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[31.6 类的静态成员](#static-members-of-classes)'
- en: '[31.6.1 Static public methods and accessors](#static-public-methods-and-accessors)'
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.6.1 静态公共方法和访问器](#static-public-methods-and-accessors)'
- en: All members in the body of the following class declaration create so-called
    *static* properties – properties of `StaticClass` itself.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下类声明体中的所有成员都创建所谓的 *静态* 属性 – `StaticClass` 自身的属性。
- en: '[PRE62]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[31.6.1.1 All kinds of static public methods and accessors (advanced)](#all-kinds-of-static-public-methods-and-accessors-advanced)'
  id: totrans-374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.6.1.1 所有静态公共方法和访问器（高级）](#all-kinds-of-static-public-methods-and-accessors-advanced)'
- en: '[PRE63]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Quoted and computed keys can also be used in object literals:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 引号键和计算键也可以用于对象字面量：
- en: '[“Quoted keys in object literals” (§30.9.1)](ch_objects.html#object-literals-quoted-keys)'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“对象字面量中的引号键”（§30.9.1）](ch_objects.html#object-literals-quoted-keys)'
- en: '[“Computed keys in object literals” (§30.9.2)](ch_objects.html#object-literals-computed-keys)'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“对象字面量中的计算键”（§30.9.2）](ch_objects.html#object-literals-computed-keys)'
- en: 'More information on accessors (defined via getters and/or setters), generators,
    async methods, and async generator methods:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 关于访问器（通过获取器和/或设置器定义）、生成器、异步方法和异步生成器方法的更多信息：
- en: '[“Object literals: accessors” (§30.3.6)](ch_objects.html#object-literal-accessors)'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“对象字面量：访问器”（§30.3.6）](ch_objects.html#object-literal-accessors)'
- en: '[“Synchronous generators ^(ES6) (advanced)” (§33)](ch_sync-generators.html#ch_sync-generators)'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“同步生成器（ES6）（高级）”（§33）](ch_sync-generators.html#ch_sync-generators)'
- en: '[“Async functions ^(ES2017)” (§44)](ch_async-functions.html#ch_async-functions)'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“异步函数（ES2017）” (§44)](ch_async-functions.html#ch_async-functions)'
- en: '[“Asynchronous generators” (§45.2)](ch_async-iteration.html#async-generators)'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“异步生成器”（§45.2）](ch_async-iteration.html#async-generators)'
- en: '[31.6.2 Static public fields ^(ES2022)](#static-public-fields)'
  id: totrans-384
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.6.2 静态公共字段^(ES2022)](#static-public-fields)'
- en: 'The following code demonstrates static public fields. `StaticPublicFieldClass`
    has three of them:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了静态公共字段。`StaticPublicFieldClass`有三个这样的字段：
- en: '[PRE64]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[31.6.3 Static private methods, accessors, and fields ^(ES2022)](#static-private-methods-accessors-fields)'
  id: totrans-387
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.6.3 静态私有方法、访问器和字段^(ES2022)](#static-private-methods-accessors-fields)'
- en: 'The following class has two static private slots (line A and line B):'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类有两个静态私有槽位（行A和行B）：
- en: '[PRE65]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This is a complete list of all kinds of static private slots:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个所有静态私有槽位的完整列表：
- en: '[PRE66]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[31.6.4 Static initialization blocks in classes ^(ES2022)](#class-static-initialization-blocks)'
  id: totrans-392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.6.4 类中的静态初始化块^(ES2022)](#class-static-initialization-blocks)'
- en: 'To set up instance data via classes, we have two constructs:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过类设置实例数据，我们有两种构造：
- en: '*Fields*, to create and optionally initialize instance data'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*字段*，用于创建和可选地初始化实例数据'
- en: '*Constructors*, blocks of code that are executed every time a new instance
    is created'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构造函数*，每次创建新实例时执行的代码块'
- en: 'For static data, we have:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 对于静态数据，我们有：
- en: '*Static fields*'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*静态字段*'
- en: '*Static blocks* that are executed when a class is created'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*静态块*，在创建类时执行'
- en: 'The following code demonstrates static blocks (line A):'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了静态块（行A）：
- en: '[PRE67]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We could also execute the code inside the static block after the class (at
    the top level). However, using a static block has two benefits:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在类（在顶层）之后执行静态块中的代码。然而，使用静态块有两个好处：
- en: All class-related code is inside the class.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有与类相关的代码都位于类内部。
- en: The code in a static block has access to private slots.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态块中的代码可以访问私有槽位。
- en: '[31.6.4.1 Rules for static initialization blocks](#rules-for-static-initialization-blocks)'
  id: totrans-404
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.6.4.1 静态初始化块的规则](#rules-for-static-initialization-blocks)'
- en: 'The rules for how static initialization blocks work, are relatively simple:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 静态初始化块如何工作的规则相对简单：
- en: There can be more than one static block per class.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个类可以有多个静态块。
- en: The execution of static blocks is interleaved with the execution of static field
    initializers.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态块的执行与静态字段初始化的执行交织在一起。
- en: The static members of a superclass are executed before the static members of
    a subclass.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超类中的静态成员在子类中的静态成员之前执行。
- en: 'The following code demonstrates these rules:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了这些规则：
- en: '[PRE68]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Output:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE69]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[Subclassing via `extends`](#subclassing) is explained later in this chapter.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '[通过`extends`进行子类化](#subclassing)将在本章后面解释。'
- en: '[31.6.5 Pitfall: Using `this` to access static private fields](#this-and-static-private-fields)'
  id: totrans-414
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.6.5 陷阱：使用`this`访问静态私有字段](#this-and-static-private-fields)'
- en: In static public members, we can access static public slots via `this`. Alas,
    we should not use it to access static private slots.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态公共成员中，我们可以通过`this`访问静态公共槽位。然而，我们不应该用它来访问静态私有槽位。
- en: '[31.6.5.1 `this` and static public fields](#this-and-static-public-fields)'
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.6.5.1 `this`和静态公共字段](#this-and-static-public-fields)'
- en: 'Consider the following code:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE70]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[Subclassing via `extends`](#subclassing) is explained later in this chapter.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '[通过`extends`进行子类化](#subclassing)将在本章后面解释。'
- en: Static public fields are properties. If we make the method call
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 静态公共字段是属性。如果我们调用方法
- en: '[PRE71]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'then `this` points to `SuperClass` and everything works as expected. We can
    also invoke `.getPublicViaThis()` via the subclass:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`this`指向`SuperClass`，一切按预期工作。我们也可以通过子类调用`.getPublicViaThis()`：
- en: '[PRE72]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`SubClass` inherits `.getPublicViaThis()` from its prototype `SuperClass`.
    `this` points to `SubClass` and things continue to work, because `SubClass` also
    inherits the property `.publicData`.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`SubClass`从其原型`SuperClass`继承了`.getPublicViaThis()`。`this`指向`SubClass`，一切继续正常，因为`SubClass`也继承了属性`.publicData`。'
- en: As an aside, if we assigned to `this.publicData` in `getPublicViaThis()` and
    invoked it via `SubClass.getPublicViaThis()`, then we would create a new own poperty
    of `SubClass` that (non-destructively) overrides the property inherited from `SuperClass`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，如果我们把`this.publicData`分配到`getPublicViaThis()`中并通过`SubClass.getPublicViaThis()`调用它，那么我们就会创建一个`SubClass`的新自有属性，该属性（非破坏性地）覆盖了从`SuperClass`继承的属性。
- en: '[31.6.5.2 `this` and static private fields](#this-and-static-private-fields-1)'
  id: totrans-426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.6.5.2 `this`和静态私有字段](#this-and-static-private-fields-1)'
- en: 'Consider the following code:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE73]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Invoking `.getPrivateDataViaThis()` via `SuperClass` works, because `this`
    points to `SuperClass`:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`SuperClass`调用`.getPrivateDataViaThis()`是有效的，因为`this`指向`SuperClass`：
- en: '[PRE74]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'However, invoking `.getPrivateDataViaThis()` via `SubClass` does not work,
    because `this` now points to `SubClass` and `SubClass` has no static private field
    `.#privateData` (private slots in prototype chains are not inherited):'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过 `SubClass` 调用 `.getPrivateDataViaThis()` 不会工作，因为 `this` 现在指向 `SubClass`，而
    `SubClass` 没有静态私有字段 `.#privateData`（原型链中的私有槽位不会继承）：
- en: '[PRE75]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The workaround is to accesss `.#privateData` directly, via `SuperClass`:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是直接通过 `SuperClass` 访问 `.#privateData`：
- en: '[PRE76]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: With static private methods, we are facing the same issue.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态私有方法时，我们面临相同的问题。
- en: '[31.6.6 All members (static, prototype, instance) can access all private members](#all-members-static-prototype-instance-can-access-all-private-members)'
  id: totrans-436
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.6.6 所有成员（静态、原型、实例）都可以访问所有私有成员](#all-members-static-prototype-instance-can-access-all-private-members)'
- en: 'Every member inside a class can access all other members inside that class
    – both public and private ones:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 类内部的所有成员都可以访问该类内部的所有其他成员——无论是公共的还是私有的：
- en: '[PRE77]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In contrast, no one outside can access the private members:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，外部没有人可以访问私有成员：
- en: '[PRE78]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[31.6.7 Static private methods and data before ES2022](#static-private-methods-and-data-before-es2022)'
  id: totrans-441
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.6.7 ES2022 之前的静态私有方法和数据](#static-private-methods-and-data-before-es2022)'
- en: 'The following code only works in ES2022 – due to every line that has a hash
    symbol (`#`) in it:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码仅在 ES2022 中有效——因为每一行都包含一个哈希符号（`#`）：
- en: '[PRE79]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Since private slots only exist once per class, we can move `.#secret` and `.#getSecretInParens`
    to the scope surrounding the class and use a module to hide them from the world
    outside the module:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 由于私有槽位在每个类中只存在一次，我们可以将 `.#secret` 和 `.#getSecretInParens` 移到类周围的范围内，并使用模块来隐藏它们，使其对模块外部的世界不可见：
- en: '`.#secret` becomes a top-level variable in the module.'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.#secret` 成为模块中的顶级变量。'
- en: '`.getSecretInParens()` becomes a top-level function in the module.'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.getSecretInParens()` 成为模块中的顶级函数。'
- en: 'The result looks as follows:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来如下：
- en: '[PRE80]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[31.6.8 Static factory methods](#static-factory-methods)'
  id: totrans-449
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.6.8 静态工厂方法](#static-factory-methods)'
- en: 'Sometimes there are multiple ways in which a class can be instantiated. Then
    we can implement *static factory methods* such as `Point.fromPolar()`:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个类可以有多种实例化的方式。然后我们可以实现如 `Point.fromPolar()` 这样的静态工厂方法：
- en: '[PRE81]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'I like how descriptive static factory methods are: `fromPolar` describes how
    an instance is created. JavaScript’s standard library also has such factory methods
    – for example:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢静态工厂方法的描述性：`fromPolar` 描述了实例是如何创建的。JavaScript 的标准库也有这样的工厂方法——例如：
- en: '`Array.from()`'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.from()`'
- en: '`Object.create()`'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.create()`'
- en: 'I prefer to either have no static factory methods or *only* static factory
    methods. Things to consider in the latter case:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢要么没有静态工厂方法，要么 *只有* 静态工厂方法。在后一种情况下需要考虑的事项：
- en: One factory method will probably directly call the constructor (but have a descriptive
    name).
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个工厂方法可能会直接调用构造函数（但有一个描述性的名称）。
- en: We need to find a way to prevent the constructor being called from outside.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要找到一种方法来防止构造函数从外部被调用。
- en: In the following code, we use a secret token (line A) to prevent the constructor
    being called from outside the current module.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们使用一个密钥令牌（行A）来防止构造函数从当前模块外部被调用。
- en: '[PRE82]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[31.7 Subclassing](#subclassing)'
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[31.7 子类化](#subclassing)'
- en: '[31.7.1 Defining subclasses via `extends`](#defining-subclasses-via-extends)'
  id: totrans-461
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.7.1 通过 `extends` 定义子类](#defining-subclasses-via-extends)'
- en: 'Classes can extend existing classes. For example, the following class `Employee`
    extends `Person`:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以扩展现有的类。例如，以下类 `Employee` 继承自 `Person`：
- en: '[PRE83]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Terminology related to extending:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 与扩展相关的术语：
- en: Another word for *extending* is *subclassing*.
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个表示 *扩展* 的词是 *子类化*。
- en: '`Person` is the superclass of `Employee`.'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Person` 是 `Employee` 的超类。'
- en: '`Employee` is the subclass of `Person`.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Employee` 是 `Person` 的子类。'
- en: A *base class* is a class that has no superclasses.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *基类* 是一个没有超类的类。
- en: A *derived class* is a class that has a superclass.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *派生类* 是一个具有超类的类。
- en: Inside the `.constructor()` of a derived class, we must call the super-constructor
    via `super()` before we can access `this`. Why is that?
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在派生类的 `.constructor()` 中，我们必须在可以访问 `this` 之前通过 `super()` 调用超构造函数。为什么是这样？
- en: 'Let’s consider a chain of classes:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个类链：
- en: Base class `A`
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基类 `A`
- en: Class `B` extends `A`.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类 `B` 继承自 `A`。
- en: Class `C` extends `B`.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类 `C` 继承自 `B`。
- en: If we invoke `new C()`, `C`’s constructor super-calls `B`’s constructor which
    super-calls `A`’s constructor. Instances are always created in base classes, before
    the constructors of subclasses add their slots. Therefore, the instance doesn’t
    exist before we call `super()` and we can’t access it via `this`, yet.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`new C()`，`C`的构造函数会调用`B`的构造函数，而`B`的构造函数又会调用`A`的构造函数。实例总是在基类中创建，在子类的构造函数添加它们的槽位之前。因此，在调用`super()`之前，实例还不存在，我们也不能通过`this`来访问它。
- en: 'Note that static public slots are inherited. For example, `Employee` inherits
    the static method `.extractNames()`:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，静态公共槽位是继承的。例如，`Employee`继承了静态方法`.extractNames()`：
- en: '[PRE84]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Subclassing**'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '![“练习”图标](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：子类化**'
- en: '`exercises/classes/color_point_class_test.mjs`'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/classes/color_point_class_test.mjs`'
- en: '[31.7.2 The internals of subclassing (advanced)](#internals-of-subclassing)'
  id: totrans-480
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.7.2 子类化的内部机制（高级）](#internals-of-subclassing)'
- en: '![](../Images/9e9cfd8d183a6ecd074a55a7eb578773.png)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9e9cfd8d183a6ecd074a55a7eb578773.png)'
- en: 'Figure 31.4: These are the objects that make up class `Person` and its subclass,
    `Employee`. The left column is about classes. The right column is about the `Employee`
    instance `jane` and its prototype chain.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 图31.4：这些是组成`Person`类及其子类`Employee`的对象。左侧是关于类的。右侧是`Employee`实例`jane`及其原型链。
- en: 'The classes `Person` and `Employee` from the previous section are made up of
    several objects ([figure 31.4](#fig:oo_subclassing)). One key insight for understanding
    how these objects are related is that there are two prototype chains:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的`Person`和`Employee`类由几个对象组成（[图31.4](#fig:oo_subclassing)）。理解这些对象之间关系的一个关键洞察是存在两个原型链：
- en: The instance prototype chain, on the right.
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例原型链，在右侧。
- en: The class prototype chain, on the left.
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类原型链，在左侧。
- en: Each class contributes a prototype to the instance prototype chain but is also
    in its own chain of prototypes.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都向实例原型链贡献一个原型，但同时也在其自己的原型链中。
- en: '[31.7.2.1 The instance prototype chain (right column)](#the-instance-prototype-chain-right-column)'
  id: totrans-487
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.7.2.1 实例原型链（右侧列）](#the-instance-prototype-chain-right-column)'
- en: 'The instance prototype chain starts with `jane` and continues with `Employee.prototype`
    and `Person.prototype`. In principle, the prototype chain ends at this point,
    but we get one more object:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 实例原型链从`jane`开始，然后是`Employee.prototype`和`Person.prototype`。原则上，原型链在这里结束，但我们又得到了一个对象：
- en: '[PRE85]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '`Object.prototype` provides services to virtually all objects, which is why
    it is included here, too. The prototype of `Object.prototype` is `null`:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.prototype`为几乎所有对象提供服务，这也是它被包括在这里的原因。`Object.prototype`的原型是`null`：'
- en: '[PRE86]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[31.7.2.2 The class prototype chain (left column)](#the-class-prototype-chain-left-column)'
  id: totrans-492
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.7.2.2 类原型链（左侧列）](#the-class-prototype-chain-left-column)'
- en: 'In the class prototype chain, `Employee` comes first, `Person` next. In principle,
    the prototype chain ends at this point, but `Person` does have a prototype:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在类原型链中，`Employee`排在第一位，`Person`排在第二位。原则上，原型链在这里结束，但`Person`确实有一个原型：
- en: '[PRE87]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '`Person` only has this prototype because it’s a function and `Function.prototype`
    is the prototype of all functions. (As an aside, the prototype of `Function.prototype`
    is `Object.prototype`.)'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`只有这个原型，因为它是一个函数，而`Function.prototype`是所有函数的原型。（顺便提一下，`Function.prototype`的原型是`Object.prototype`。）'
- en: '[31.7.3 The `instanceof` operator in detail (advanced)](#instanceof-operator-details)'
  id: totrans-496
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.7.3 `instanceof`运算符的详细说明（高级）](#instanceof-operator-details)'
- en: 'We have not yet learned how `instanceof` really works: How does `instanceof`
    determine if a value `x` is an instance of a class `C`? Note that “instance of
    `C`” means direct instance of `C` or direct instance of a subclass of `C`.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有学会`instanceof`真正是如何工作的：`instanceof`是如何确定一个值`x`是否是类`C`的实例？请注意，“`instance
    of C`”意味着`C`的直接实例或者`C`的子类的直接实例。
- en: '`instanceof` checks if `C.prototype` is in the prototype chain of `x`. That
    is, the following two expressions are equivalent:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof`检查`C.prototype`是否在`x`的原型链中。也就是说，以下两个表达式是等价的：'
- en: '[PRE88]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'If we go back to [figure 31.4](#fig:oo_subclassing), we can confirm that the
    prototype chain does lead us to the following correct answers:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到[图31.4](#fig:oo_subclassing)，我们可以确认原型链确实引导我们得到了以下正确的答案：
- en: '[PRE89]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Note that `instanceof` always returns `false` if its self-hand side is a primitive
    value:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果`instanceof`的自身一侧是原始值，它总是返回`false`：
- en: '[PRE90]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[31.7.4 Not all objects are instances of `Object` (advanced)](#non-instances-of-object)'
  id: totrans-504
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.7.4 并非所有对象都是`Object`的实例（高级）](#non-instances-of-object)'
- en: 'An object (a non-primitive value) is only an instance of `Object` if `Object.prototype`
    is in its prototype chain [(see previous subsection)](#instanceof-operator-details).
    Virtually all objects are instances of `Object` – for example:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象（一个非原始值）只有在 `Object.prototype` 在其原型链中时才是一个 `Object` 的实例（参见前面的子节）[(见前一小节)](#instanceof-operator-details)。几乎所有的对象都是
    `Object` 的实例——例如：
- en: '[PRE91]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'In the next example, `obj1` and `obj2` are both objects (line A and line C),
    but they are not instances of `Object` (line B and line D): `Object.prototype`
    is not in their prototype chains because they don’t have any prototypes.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，`obj1` 和 `obj2` 都是对象（行A和行C），但它们不是 `Object` 的实例（行B和行D）：因为它们没有任何原型，所以
    `Object.prototype` 不在它们的原型链中。
- en: '[PRE92]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '`Object.prototype` is the object that ends most prototype chains. Its prototype
    is `null`, which means it isn’t an instance of `Object` either:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.prototype` 是结束大多数原型链的对象。它的原型是 `null`，这意味着它也不是 `Object` 的一个实例：'
- en: '[PRE93]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[31.7.5 Base class vs. derived class (advanced)](#base-class-vs-derived-class-advanced)'
  id: totrans-511
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.7.5   基类与派生类（高级）](#base-class-vs-derived-class-advanced)'
- en: A base class is different from a class that extends `Object`.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 基类与扩展 `Object` 的类不同。
- en: The following class is derived from class `Object`. [Figure 31.5](#fig:class-derived)
    shows its object diagram.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类是从类 `Object` 派生的。[图31.5](#fig:class-derived) 展示了其对象图。
- en: '[PRE94]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '![](../Images/ccf6009e97e345718b2e2852460148fd.png)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ccf6009e97e345718b2e2852460148fd.png)'
- en: 'Figure 31.5: Object diagram for class `DerivedClass` and its instance `derivedInstance`:
    Both `Object` and `DerivedClass` appear in the class prototype chain (left column).
    They both contribute prototypes to the instance prototype chain (right column).'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 图31.5：类 `DerivedClass` 及其实例 `derivedInstance` 的对象图：`Object` 和 `DerivedClass`
    都出现在类原型链中（左侧列）。它们都向实例原型链贡献了原型（右侧列）。
- en: In contrast, the following class is a base class. [Figure 31.6](#fig:class-base)
    shows its object diagram.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，以下类是一个基类。[图31.6](#fig:class-base) 展示了其对象图。
- en: '[PRE95]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '![](../Images/d47fa0c82efa7280cc3139a980d91244.png)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d47fa0c82efa7280cc3139a980d91244.png)'
- en: 'Figure 31.6: Object diagram for class `BaseClass` and its instance `baseInstance`:
    The instance prototype chain (right column) is the same as for `derivedInstance`.
    However, `Object` does not appear in the class prototype chain (left column).'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 图31.6：类 `BaseClass` 及其实例 `baseInstance` 的对象图：实例原型链（右侧列）与 `derivedInstance` 相同。然而，`Object`
    不出现在类原型链中（左侧列）。
- en: '[31.7.6 The prototype chains of plain objects and Arrays (advanced)](#prototype-chains-of-builtin-objects)'
  id: totrans-521
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.7.6   平凡对象和数组的原型链（高级）](#prototype-chains-of-builtin-objects)'
- en: 'Next, we’ll use our knowledge of subclassing to understand the prototype chains
    of plain objects and Arrays. The following tool function `p()` helps us with our
    explorations:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将利用我们对子类化的知识来理解平凡对象和数组的原型链。以下工具函数 `p()` 帮助我们进行探索：
- en: '[PRE96]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We extracted method `.getPrototypeOf()` of `Object` and assigned it to `p`.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `Object` 中提取了方法 `.getPrototypeOf()` 并将其分配给 `p`。
- en: '[31.7.6.1 The prototype chains of plain objects](#the-prototype-chains-of-plain-objects)'
  id: totrans-525
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.7.6.1   平凡对象的原型链](#the-prototype-chains-of-plain-objects)'
- en: 'Let’s explore the prototype chain of a plain object:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索平凡对象的原型链：
- en: '[PRE97]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[Figure 31.7](#fig:builtin-object) shows a diagram for a plain object and its
    class `Object`.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '[图31.7](#fig:builtin-object) 展示了平凡对象及其类 `Object` 的图示。'
- en: '![](../Images/9a2acdc1ab742c804e273ce5af871ba1.png)'
  id: totrans-529
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9a2acdc1ab742c804e273ce5af871ba1.png)'
- en: 'Figure 31.7: The prototype of the empty plain object `{}` is `Object.prototype`
    – which makes it an instance of the class `Object`.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 图31.7：空平凡对象 `{}` 的原型是 `Object.prototype` —— 这使其成为 `Object` 类的一个实例。
- en: '[31.7.6.2 The prototype chains of Arrays](#the-prototype-chains-of-arrays)'
  id: totrans-531
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.7.6.2   数组的原型链](#the-prototype-chains-of-arrays)'
- en: 'Let’s explore the prototype chain of an Array:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索数组的原型链：
- en: '[PRE98]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[Figure 31.8](#fig:builtin-array) shows a diagram for an Array and its class
    `Array`.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '[图31.8](#fig:builtin-array) 展示了数组和其类 `Array` 的图示。'
- en: '![](../Images/2d8acaa0b29263257e64a3d6f87074a8.png)'
  id: totrans-535
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2d8acaa0b29263257e64a3d6f87074a8.png)'
- en: 'Figure 31.8: The empty Array `[]` is an instance of `Array` (via `Array.prototype`)
    and an instance of `Object` (via `Object.prototype`). However, class `Array` is
    not derived from class `Object` – it is a base class.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 图31.8：空数组 `[]` 是 `Array` 的一个实例（通过 `Array.prototype`）以及 `Object` 的一个实例（通过 `Object.prototype`）。然而，类
    `Array` 并不是从类 `Object` 派生的 —— 它是一个基类。
- en: 'It’s interesting that `Array` is a base class:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 很有趣的是，`Array` 是一个基类：
- en: '[PRE99]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Therefore, all instances of `Array` are also instances of `Object` – yet `Array`
    is not a subclass of `Object`. This divergence is only possible because the instance
    prototype chain is separate from the class prototype chain in JavaScript.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有 `Array` 的实例也都是 `Object` 的实例——然而 `Array` 并不是 `Object` 的子类。这种差异之所以可能，仅仅是因为
    JavaScript 中实例原型链与类原型链是分开的。
- en: Why isn’t `Object` the prototype of `Array`? One reason is that it has been
    this way since long before classes were added to JavaScript and can’t really be
    changed due to the importance of backward compatibility in JavaScript. Another
    reason is that base classes are where instances are actually created. `Array`
    needs to create its own instances because they have so-called “internal slots”
    which can’t be added later to instances created by `Object`.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 `Object` 不是 `Array` 的原型？一个原因是自从在 JavaScript 中添加类之前就是这样的，由于 JavaScript 中向后兼容性的重要性，实际上无法改变。另一个原因是基类是实例实际创建的地方。`Array`
    需要创建自己的实例，因为它们有所谓的“内部槽位”，这些槽位不能添加到由 `Object` 创建的实例中。
- en: '[31.7.6.3 The prototype chains of functions](#the-prototype-chains-of-functions)'
  id: totrans-541
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[31.7.6.3 函数的原型链](#the-prototype-chains-of-functions)'
- en: 'Functions are similar to Arrays. On one hand, `Function` is a base class:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 函数与数组类似。一方面，`Function` 是一个基类：
- en: '[PRE100]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'On the other hand, function objects are instances of `Object`:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，函数对象是 `Object` 的实例：
- en: '[PRE101]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[31.8 Mixin classes (advanced)](#mixin-classes-advanced)'
  id: totrans-546
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[31.8 混合类（高级）](#mixin-classes-advanced)'
- en: 'JavaScript’s class system only supports *single inheritance*. That is, each
    class can have at most one superclass. One way around this limitation is via a
    technique called *mixin classes* (short: *mixins*).'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的类系统只支持 *单一继承*。也就是说，每个类最多只能有一个超类。绕过这种限制的一种方法是通过称为 *混合类*（简称：*mixins*）的技术。
- en: 'The idea is as follows: Let’s say we want a class `C` to inherit from two superclasses
    `S1` and `S2`. That would be *multiple inheritance*, which JavaScript doesn’t
    support.'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 理念如下：假设我们想让类 `C` 从两个超类 `S1` 和 `S2` 继承。这将是一个 *多重继承*，而 JavaScript 不支持。
- en: 'Our workaround is to turn `S1` and `S2` into *mixins*, factories for subclasses:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解决方案是将 `S1` 和 `S2` 转换为 *混合类*，子类的工厂：
- en: '[PRE102]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Each of these two functions returns a class that extends a given superclass
    `Sup`. We create class `C` as follows:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数中的每一个都返回一个扩展给定超类 `Sup` 的类。我们创建类 `C` 如下：
- en: '[PRE103]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: We now have a class `C` that extends the class returned by `S2()` which extends
    the class returned by `S1()` which extends `Object`.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个类 `C`，它扩展了由 `S2()` 返回的类，该类扩展了由 `S1()` 返回的类，该类又扩展了 `Object`。
- en: '[31.8.1 Example: a mixin for name management](#example-a-mixin-for-name-management)'
  id: totrans-554
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.8.1 示例：用于名称管理的混合类](#example-a-mixin-for-name-management)'
- en: 'We implement a mixin `Named` adds a property `.name` and a method `.toString()`
    to its superclass:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个混合 `Named`，它为其超类添加了一个属性 `.name` 和一个方法 `.toString()`：
- en: '[PRE104]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'We use this mixin to implement a class `City` that has a name:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个混合类来实现一个具有名称的类 `City`。
- en: '[PRE105]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The following code confirms that the mixin works:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码确认了混合类的有效性：
- en: '[PRE106]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[31.8.2 The benefits of mixins](#the-benefits-of-mixins)'
  id: totrans-561
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.8.2 混合类的优势](#the-benefits-of-mixins)'
- en: 'Mixins free us from the constraints of single inheritance:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 混合类使我们摆脱了单一继承的约束：
- en: The same class can extend a single superclass and zero or more mixins.
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一个类可以扩展一个单一的超类和零个或多个混合类。
- en: The same mixin can be used by multiple classes.
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一个混合类可以被多个类使用。
- en: '[31.9 The methods and accessors of `Object.prototype` (advanced)](#the-methods-and-accessors-of-objectprototype-advanced)'
  id: totrans-565
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[31.9 `Object.prototype` 的方法和访问器（高级）](#the-methods-and-accessors-of-objectprototype-advanced)'
- en: '[31.9.1 Using `Object.prototype` methods safely](#using-object-methods-safely)'
  id: totrans-566
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.9.1 使用 `Object.prototype` 方法的安全方式](#using-object-methods-safely)'
- en: 'Invoking one of the methods of `Object.prototype` on an arbitrary object doesn’t
    always work. To illustrate why, we use method `Object.prototype.hasOwnProperty`,
    which returns `true` if an object has an own property with a given key:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 在任意对象上调用 `Object.prototype` 的一个方法并不总是有效。为了说明原因，我们使用方法 `Object.prototype.hasOwnProperty`，如果对象有一个具有给定键的自有属性，则它返回
    `true`：
- en: '[PRE107]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Invoking `.hasOwnProperty()` on an arbitrary object can fail in two ways. On
    one hand, this method isn’t available if an object is not an instance of `Object`
    (see [“Not all objects are instances of `Object` (advanced)” (§31.7.4)](#non-instances-of-object)):'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 在任意对象上调用 `.hasOwnProperty()` 可能以两种方式失败。一方面，如果对象不是 `Object` 的实例，则此方法不可用（参见[“并非所有对象都是
    `Object` 的实例（高级）” (§31.7.4)](#non-instances-of-object))）：
- en: '[PRE108]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'On the other hand, we can’t use `.hasOwnProperty()` if an object overrides
    it with an own property (line A):'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果一个对象用自有属性覆盖了`.hasOwnProperty()`（行A），我们就不能使用`.hasOwnProperty()`。
- en: '[PRE109]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'There is, however, a safe way to use `.hasOwnProperty()`:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个安全的方法可以使用`.hasOwnProperty()`：
- en: '[PRE110]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The method invocation in line A is explained in [“Dispatched vs. direct method
    calls (advanced)” (§31.3.5)](#method-calls-dispatched-direct).
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 行A中的方法调用在[“分派方法调用与直接方法调用（高级）”（§31.3.5）](https://wiki.example.org/method-calls-dispatched-direct)中解释。
- en: 'We can also use [`.bind()`](ch_objects.html#methods-bind) to implement `hasOwnProp()`:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用[`.bind()`](ch_objects.html#methods-bind)来实现`hasOwnProp()`：
- en: '[PRE111]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: How does this code work? In line A in the example before the code above, we
    used the function method `.call()` to turn the function `hasOwnProperty` with
    one implicit parameter (`this`) and one explicit parameter (`propName`) into a
    function that has two explicit parameters (`obj` and `propName`).
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是如何工作的？在上面的代码示例之前的行A中，我们使用了函数方法`.call()`将具有一个隐式参数（`this`）和一个显式参数（`propName`）的函数`hasOwnProperty`转换为一个具有两个显式参数（`obj`和`propName`）的函数。
- en: 'In other words – method `.call()` invokes the function `f` referred to by its
    receiver (`this`):'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说——`.call()`方法通过其接收者（`this`）调用函数`f`：
- en: The first (explicit) parameter of `.call()` becomes the `this` of `f`.
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.call()`的第一个（显式）参数成为`f`的`this`。'
- en: The second (explicit) parameter of `.call()` becomes the first argument of `f`.
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.call()`的第二个（显式）参数成为`f`的第一个参数。'
- en: Etc.
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等等。
- en: We use `.bind()` to create a version `.call()` whose `this` always refers to
    `Object.prototype.hasOwnProperty`. That new version invokes `.hasOwnProperty()`
    in the same manner as we did in line A – which is what we want.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`.bind()`创建一个版本`.call()`，其`this`始终指向`Object.prototype.hasOwnProperty`。这个新版本以与我们在行A中相同的方式调用`.hasOwnProperty()`——这正是我们想要的。
- en: '![Icon “question”](../Images/3decb3ca67c240d2bb04742c1f28af18.png) **Is it
    never OK to use `Object.prototype` methods via dynamic dispatch?**'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“问题”](../Images/3decb3ca67c240d2bb04742c1f28af18.png) **是否永远都不应该通过动态分派使用`Object.prototype`方法？**'
- en: 'In some cases we can be lazy and call `Object.prototype` methods like normal
    methods: If we know the receivers and they are fixed-layout objects.'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可以偷懒，像调用普通方法一样调用`Object.prototype`方法：如果我们知道接收者并且它们是固定布局对象。
- en: If, on the other hand, we don’t know their receivers and/or they are dictionary
    objects, then we need to take precautions.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 如果，另一方面，我们不知道它们的接收者并且/或者它们是字典对象，那么我们需要采取预防措施。
- en: '[31.9.2 `Object.prototype.toString()` ^(ES1)](#Object.prototype.toString)'
  id: totrans-587
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.9.2 `Object.prototype.toString()` (ES1)](https://wiki.example.org/Object.prototype.toString)'
- en: 'By overriding `.toString()` (in a subclass or an instance), we can configure
    how objects are converted to strings:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在子类或实例中覆盖`.toString()`，我们可以配置对象如何转换为字符串：
- en: '[PRE112]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'For converting objects to strings it’s better to use `String()` because that
    also works with `undefined` and `null`:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象转换为字符串时，最好使用`String()`，因为它也适用于`undefined`和`null`：
- en: '[PRE113]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[31.9.3 `Object.prototype.toLocaleString()` ^(ES3)](#Object.prototype.toLocaleString)'
  id: totrans-592
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.9.3 `Object.prototype.toLocaleString()` (ES3)](https://wiki.example.org/Object.prototype.toLocaleString)'
- en: '`.toLocaleString()` is a version of `.toString()` that can be configured via
    a locale and often additional options. Any class or instance can implement this
    method. In the standard library, the following classes do:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '`.toLocaleString()`是`.toString()`的一个版本，可以通过区域设置和通常的附加选项进行配置。任何类或实例都可以实现此方法。在标准库中，以下类实现了此方法：'
- en: '`Number.prototype.toLocaleString()`'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number.prototype.toLocaleString()`'
- en: '[PRE114]'
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '`BigInt.prototype.toLocaleString()`'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BigInt.prototype.toLocaleString()`'
- en: '`Array.prototype.toLocaleString()`'
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.toLocaleString()`'
- en: '[PRE115]'
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '`TypedArray.prototype.toLocaleString()`'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TypedArray.prototype.toLocaleString()`'
- en: '`Date.prototype.toLocaleString()`'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.toLocaleString()`'
- en: 'Thanks to the [ECMAScript Internationalization API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Internationalization)
    (`Intl` etc.), there are a variety of formatting options:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了[ECMAScript国际化API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Internationalization)（`Intl`等），有各种各样的格式化选项：
- en: '[PRE116]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[31.9.4 `Object.prototype.valueOf()` ^(ES1)](#Object.prototype.valueOf)'
  id: totrans-603
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.9.4 `Object.prototype.valueOf()` (ES1)](https://wiki.example.org/Object.prototype.valueOf)'
- en: 'By overriding `.valueOf()` (in a subclass or an instance), we can configure
    how objects are converted to non-string values (often numbers):'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在子类或实例中覆盖`.valueOf()`，我们可以配置对象如何转换为非字符串值（通常是数字）：
- en: '[PRE117]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[31.9.5 `Object.prototype.isPrototypeOf()` ^(ES3)](#Object.prototype.isPrototypeOf)'
  id: totrans-606
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.9.5 `Object.prototype.isPrototypeOf()` (ES3)](https://wiki.example.org/Object.prototype.isPrototypeOf)'
- en: '`proto.isPrototypeOf(obj)` returns `true` if `proto` is in the prototype chain
    of `obj` and `false` otherwise.'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '`proto.isPrototypeOf(obj)`如果`proto`在`obj`的原型链中返回`true`，否则返回`false`。'
- en: '[PRE118]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'This is how to use this method safely (for details see [“Using `Object.prototype`
    methods safely” (§31.9.1)](#using-object-methods-safely)):'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '这就是如何安全地使用这种方法（详情请见[“安全使用`Object.prototype`方法”（§31.9.1）](https://wiki.example.org/using-object-methods-safely)):'
- en: '[PRE119]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'An object is an instance of a class `C` if `C.prototype` is in its chain of
    prototypes:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`C.prototype`在其原型链中，则一个对象是类`C`的实例：
- en: '[PRE120]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[31.9.6 `Object.prototype.propertyIsEnumerable()` ^(ES3)](#Object.prototype.propertyIsEnumerable)'
  id: totrans-613
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.9.6 `Object.prototype.propertyIsEnumerable()` (ES3)](#Object.prototype.propertyIsEnumerable)'
- en: '`obj.propertyIsEnumerable(propKey)` returns `true` if `obj` has an own enumerable
    property whose key is `propKey` and `false` otherwise.'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj.propertyIsEnumerable(propKey)`如果`obj`有一个自己的可枚举属性，其键为`propKey`，则返回`true`，否则返回`false`。'
- en: '[PRE121]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'This is how to use this method safely (for details see [“Using `Object.prototype`
    methods safely” (§31.9.1)](#using-object-methods-safely)):'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '这就是如何安全地使用这种方法（详情请见[“安全使用`Object.prototype`方法”（§31.9.1）](https://wiki.example.org/using-object-methods-safely)):'
- en: '[PRE122]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Another safe alternative is to use [property descriptors](ch_objects.html#property-attributes-property-descriptors):'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '另一个安全的替代方案是使用[属性描述符](ch_objects.html#property-attributes-property-descriptors):'
- en: '[PRE123]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[31.9.7 `Object.prototype.__proto__` (accessor) ^(ES6)](#Object.prototype.__proto__)'
  id: totrans-620
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.9.7 `Object.prototype.__proto__` (访问器) (ES6)](#Object.prototype.__proto__)'
- en: 'Property `__proto__` exists in two versions:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 属性`__proto__`存在两种版本：
- en: An accessor that all instances of `Object` have.
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有`Object`实例都具有的访问器。
- en: A property of object literals that sets the prototypes of the objects created
    by them.
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象字面量中的一个属性，用于设置它们创建的对象的原型。
- en: 'I recommend to avoid the former feature:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议避免使用前者功能：
- en: As explained in [“Using `Object.prototype` methods safely” (§31.9.1)](#using-object-methods-safely),
    it doesn’t work with all objects.
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如[“安全使用`Object.prototype`方法”（§31.9.1）](https://wiki.example.org/using-object-methods-safely)中所述，它并不适用于所有对象。
- en: The ECMAScript specification has deprecated it and calls it [“optional” and
    “legacy”](https://tc39.es/ecma262/#sec-object.prototype.__proto__).
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript规范已经弃用了它，并称其为[“可选”和“遗留”](https://tc39.es/ecma262/#sec-object.prototype.__proto__)。
- en: In contrast, `__proto__` in object literals always works and is not deprecated.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，对象字面量中的`__proto__`始终有效，并且没有被弃用。
- en: Read on if you are interested in how the accessor `__proto__` works.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对访问器`__proto__`的工作方式感兴趣，请继续阅读。
- en: '`__proto__` is an accessor of `Object.prototype` that is inherited by all instances
    of `Object`. Implementing it via a class would look like this:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '`__proto__`是`Object.prototype`的一个访问器，它被所有`Object`实例继承。通过类实现它看起来像这样：'
- en: '[PRE124]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Since `__proto__` is inherited from `Object.prototype`, we can remove this
    feature by creating an object that doesn’t have `Object.prototype` in its prototype
    chain (see [“Not all objects are instances of `Object` (advanced)” (§31.7.4)](#non-instances-of-object)):'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`__proto__`是从`Object.prototype`继承的，我们可以通过创建一个没有`Object.prototype`在其原型链中的对象来移除此功能（参见[“并非所有对象都是`Object`的实例（高级）”
    (§31.7.4)](#non-instances-of-object))）：
- en: '[PRE125]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[31.9.8 `Object.prototype.hasOwnProperty()` ^(ES3)](#Object.prototype.hasOwnProperty)'
  id: totrans-633
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.9.8 `Object.prototype.hasOwnProperty()` (ES3)](#Object.prototype.hasOwnProperty)'
- en: '![Icon “warning”](../Images/5aa4bf88dc66ecb2bac6be4022a1fed4.png) **Better
    alternative to `.hasOwnProperty()`: `Object.hasOwn()` ^(ES2022)**'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“警告”](../Images/5aa4bf88dc66ecb2bac6be4022a1fed4.png) **比`.hasOwnProperty()`更好的替代方案：`Object.hasOwn()`
    (ES2022)**'
- en: 'See [“`Object.hasOwn()`: Is a given property own (non-inherited)? ^(ES2022)”
    (§30.8.4)](ch_objects.html#Object.hasOwn).'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '请参阅[“`Object.hasOwn()`: 给定的属性是自己的（非继承的）吗？（ES2022）” (§30.8.4)](ch_objects.html#Object.hasOwn)。'
- en: '`obj.hasOwnProperty(propKey)` returns `true` if `obj` has an own (non-inherited)
    property whose key is `propKey` and `false` otherwise.'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj.hasOwnProperty(propKey)`如果`obj`有一个自己的（非继承的）属性，其键为`propKey`，则返回`true`，否则返回`false`。'
- en: '[PRE126]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'This is how to use this method safely (for details see [“Using `Object.prototype`
    methods safely” (§31.9.1)](#using-object-methods-safely)):'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '这就是如何安全地使用这种方法（详情请见[“安全使用`Object.prototype`方法”（§31.9.1）](https://wiki.example.org/using-object-methods-safely)):'
- en: '[PRE127]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[31.10 Quick reference: `Object.prototype.*`](#quickref-object-prototype)'
  id: totrans-640
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[31.10 快速参考：`Object.prototype.*`](#quickref-object-prototype)'
- en: '[31.10.1 `Object.prototype.*`: configuring how objects are converted to primitive
    values](#objectprototype-configuring-how-objects-are-converted-to-primitive-values)'
  id: totrans-641
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.10.1 `Object.prototype.*`: 配置对象如何转换为原始值](#objectprototype-configuring-how-objects-are-converted-to-primitive-values)'
- en: The following methods have default implementations but are often overridden
    in subclasses or instances. They determine how objects are converted to primitive
    values (e.g. by the `+` operator).
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法具有默认实现，但通常在子类或实例中被覆盖。它们确定对象如何转换为原始值（例如，通过`+`运算符）。
- en: '`Object.prototype.toString()` ES1'
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.prototype.toString()` ES1'
- en: Configures how an object is converted to a string.
  id: totrans-644
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 配置对象如何转换为字符串。
- en: '[PRE128]'
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[More information](#Object.prototype.toString).'
  id: totrans-646
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[更多信息](#Object.prototype.toString).'
- en: '`Object.prototype.toLocaleString()` ES3'
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.prototype.toLocaleString()` ES3'
- en: A version of `.toString()` that can be configured in various ways via arguments
    (language, region, etc.). [More information](#Object.prototype.toLocaleString).
  id: totrans-648
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一种可以通过参数以各种方式配置的`.toString()`版本（语言、区域等）。[更多信息](#Object.prototype.toLocaleString).
- en: '`Object.prototype.valueOf()` ES1'
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.prototype.valueOf()` ES1'
- en: Configures how an object is converted to a non-string primitive value (often
    a number).
  id: totrans-650
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 配置对象如何转换为非字符串原始值（通常是数字）。
- en: '[PRE129]'
  id: totrans-651
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[More information](#Object.prototype.valueOf).'
  id: totrans-652
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[更多信息](#Object.prototype.valueOf).'
- en: '[31.10.2 `Object.prototype.*`: useful methods with pitfalls](#objectprototype-useful-methods-with-pitfalls)'
  id: totrans-653
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.10.2 `Object.prototype.*`：具有陷阱的有用方法](#objectprototype-useful-methods-with-pitfalls)'
- en: 'The following methods are useful but can’t be invoked on an object if:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法很有用，但如果在对象上调用它们，则无法使用：
- en: '`Object.prototype` isn’t a prototype of that object.'
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.prototype`不是该对象的原型。'
- en: The `Object.prototype` method is overridden somewhere in the prototype chain.
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在原型链的某个地方重写了`Object.prototype`方法。
- en: How to work around that limitation is explained in [“Using `Object.prototype`
    methods safely” (§31.9.1)](#using-object-methods-safely).
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 如何绕过这种限制在[“安全使用`Object.prototype`方法”（§31.9.1）]中解释。
- en: 'These are the methods:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是方法：
- en: '`Object.prototype.isPrototypeOf()` ES3'
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.prototype.isPrototypeOf()` ES3'
- en: Is the receiver in the prototype chain of a given object?
  id: totrans-660
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接收器是否是给定对象的原型链中的一部分？
- en: 'You’ll usually be fine if you invoke this method on an object. If you want
    to be safe, you can use the following pattern (line A):'
  id: totrans-661
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你在一个对象上调用此方法，通常没问题。如果你想确保安全，可以使用以下模式（行A）：
- en: '[PRE130]'
  id: totrans-662
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[More information](#Object.prototype.isPrototypeOf).'
  id: totrans-663
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[更多信息](#Object.prototype.isPrototypeOf).'
- en: '`Object.prototype.propertyIsEnumerable()` ES3'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.prototype.propertyIsEnumerable()` ES3'
- en: Does the receiver have an enumerable own property with the given key?
  id: totrans-665
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接收器是否具有给定键的可枚举自有属性？
- en: 'You’ll usually be fine if you invoke this method on an object. If you want
    to be safe, you can use the following pattern:'
  id: totrans-666
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你在一个对象上调用此方法，通常没问题。如果你想确保安全，可以使用以下模式：
- en: '[PRE131]'
  id: totrans-667
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[More information](#Object.prototype.propertyIsEnumerable).'
  id: totrans-668
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[更多信息](#Object.prototype.propertyIsEnumerable).'
- en: '[31.10.3 `Object.prototype.*`: methods to avoid](#objectprototype-methods-to-avoid)'
  id: totrans-669
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.10.3 `Object.prototype.*`：要避免的方法](#objectprototype-methods-to-avoid)'
- en: 'Avoid the following features (there are better alternatives):'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 避免以下特性（有更好的替代方案）：
- en: '`get Object.prototype.__proto__` ES6'
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get Object.prototype.__proto__` ES6'
- en: 'Avoid:'
  id: totrans-672
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 避免使用：
- en: Instead, use `Object.getPrototypeOf()`.
  id: totrans-673
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相反，使用`Object.getPrototypeOf()`。
- en: '[More information](#Object.prototype.__proto__).'
  id: totrans-674
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[更多信息](#Object.prototype.__proto__).'
- en: '`set Object.prototype.__proto__` ES6'
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set Object.prototype.__proto__` ES6'
- en: 'Avoid:'
  id: totrans-676
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 避免使用：
- en: Instead, use `Object.setPrototypeOf()`.
  id: totrans-677
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相反，使用`Object.setPrototypeOf()`。
- en: '[More information](#Object.prototype.__proto__).'
  id: totrans-678
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[更多信息](#Object.prototype.__proto__).'
- en: '`Object.prototype.hasOwnProperty` ES3'
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.prototype.hasOwnProperty` ES3'
- en: 'Avoid:'
  id: totrans-680
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 避免使用：
- en: Instead, use `Object.hasOwn()` ^(ES2022)
  id: totrans-681
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相反，使用`Object.hasOwn()` (ES2022)
- en: '[More information](#Object.prototype.hasOwnProperty).'
  id: totrans-682
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[更多信息](#Object.prototype.hasOwnProperty).'
- en: '[31.11 FAQ: classes](#faq-classes)'
  id: totrans-683
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[31.11 FAQ：类](#faq-classes)'
- en: '[31.11.1 Why are they called “instance private fields” in this book and not
    “private instance fields”?](#why-are-they-called-instance-private-fields-in-this-book-and-not-private-instance-fields)'
  id: totrans-684
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.11.1 为什么这本书中称其为“实例私有字段”而不是“私有实例字段”？](#why-are-they-called-instance-private-fields-in-this-book-and-not-private-instance-fields)'
- en: 'That is done to highlight how different properties (public slots) and private
    slots are: By changing the order of the adjectives, the words “public” and “field”
    and the words “private” and “field” are always mentioned together.'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了突出不同的属性（公共槽位）和私有槽位之间的差异：通过改变形容词的顺序，"public"和"field"以及"private"和"field"这些词总是同时出现。
- en: '[31.11.2 Why the identifier prefix `#`? Why not declare private fields via
    `private`?](#why-the-identifier-prefix--why-not-declare-private-fields-via-private)'
  id: totrans-686
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[31.11.2 为什么这本书中称其为“实例私有字段”而不是“私有实例字段”？](#why-the-identifier-prefix--why-not-declare-private-fields-via-private)'
- en: 'Could private fields be declared via `private` and use normal identifiers?
    Let’s examine what would happen if that were possible:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 是否可以通过`private`声明私有字段并使用普通标识符？让我们看看如果这是可能的话会发生什么：
- en: '[PRE132]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Whenever an expression such as `other.value` appears in the body of `MyClass`,
    JavaScript has to decide:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 每当在`MyClass`的主体中出现类似`other.value`的表达式时，JavaScript必须决定：
- en: Is `.value` a property?
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.value`是一个属性吗？'
- en: Is `.value` a private field?
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.value`是一个私有字段吗？'
- en: 'At compile time, JavaScript doesn’t know if the declaration in line A applies
    to `other` (due to it being an instance of `MyClass`) or not. That leaves two
    options for making the decision:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，JavaScript 无法确定行 A 中的声明是否适用于 `other`（因为它是一个 `MyClass` 的实例）。这留下了两个做出决定的选项：
- en: '`.value` is always interpreted as a private field.'
  id: totrans-693
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.value` 总是被解释为一个私有字段。'
- en: 'JavaScript decides at runtime:'
  id: totrans-694
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaScript 在运行时做出决定：
- en: If `other` is an instance of `MyClass`, then `.value` is interpreted as a private
    field.
  id: totrans-695
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `other` 是 `MyClass` 的一个实例，那么 `.value` 被解释为一个私有字段。
- en: Otherwise `.value` is interpreted as a property.
  id: totrans-696
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则 `.value` 被解释为一个属性。
- en: 'Both options have downsides:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个选项都有缺点：
- en: With option (1), we can’t use `.value` as a property, anymore – for any object.
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用选项（1），我们不能再将 `.value` 作为属性使用——对于任何对象。
- en: With option (2), performance is affected negatively.
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用选项（2）会负面影响性能。
- en: 'That’s why the name prefix `#` was introduced. The decision is now easy: If
    we use `#`, we want to access a private field. If we don’t, we want to access
    a property.'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 因此引入了名称前缀 `#`。现在决定变得简单：如果我们使用 `#`，我们想要访问一个私有字段。如果我们不使用，我们想要访问一个属性。
- en: '`private` works for statically typed languages (such as TypeScript) because
    they know at compile time if `other` is an instance of `MyClass` and can then
    treat `.value` as private or public.'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '`private` 对静态类型语言（如 TypeScript）有效，因为它们在编译时知道 `other` 是否是 `MyClass` 的实例，然后可以将
    `.value` 作为私有或公共来处理。'
