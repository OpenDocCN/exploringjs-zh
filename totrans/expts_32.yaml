- en: 26 Enums and enum patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/ts/book/ch_enums.html](https://exploringjs.com/ts/book/ch_enums.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Ad, please don’t block.)
  prefs: []
  type: TYPE_NORMAL
- en: '[26.1 Making sense of enums](#making-sense-of-enums)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.1.1 Use case 1: namespace for constants with primitive values](#use-case-1-namespace-for-constants-with-primitive-values)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.1.2 Use case 2: custom type with unique values](#use-case-2-custom-type-with-unique-values)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.1.3 Use case 3: namespace for constants with object values](#use-case-3-namespace-for-constants-with-object-values)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.2 TypeScript enums](#typescript-enums)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.2.1 Number enums](#number-enums)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.2.2 String enums](#string-enums)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.2.3 Heterogeneous enums](#heterogeneous-enums)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.2.4 Omitting initializers](#omitting-initializers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.2.5 Quoting enum member names](#quoting-enum-member-names)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.2.6 Casing of enum member names](#casing-of-enum-member-names)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.2.7 An enum defines a value and a type](#an-enum-defines-a-value-and-a-type)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.2.8 Values accepted by enum types](#values-accepted-by-enum-types)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.2.9 Enums at runtime](#enums-at-runtime)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.2.10 Handling the enum use cases with enums](#handling-the-enum-use-cases-with-enums)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.3 TypeScript const enums](#typescript-const-enums)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.3.1 Const enums at runtime](#const-enums-at-runtime)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.3.2 Downsides of const enums](#downsides-of-const-enums)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.4 Enum pattern: enum objects](#enum-pattern-enum-objects)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.4.1 Ways of improving object literals](#ways-of-improving-object-literals)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.4.2 A helper function for creating enum objects](#a-helper-function-for-creating-enum-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.4.3 Handling the enum use cases with enum objects](#handling-the-enum-use-cases-with-enum-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.4.4 Using the members of enum objects at the type level](#using-the-members-of-enum-objects-at-the-type-level)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.4.5 Symbols as property values](#enum-object-with-symbols)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.4.6 Use case: an enum as a namespace for constants with object values](#use-case-an-enum-as-a-namespace-for-constants-with-object-values)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.5 Enum pattern: enum classes](#enum-pattern-enum-classes)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.6 Enum pattern: string literal unions](#enum-pattern-string-literal-unions)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.6.1 Reifying string literal unions](#reifying-string-literal-unions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.7 More things we can do with enums](#more-things-we-can-do-with-enums)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.7.1 Enum values as keys in Maps](#enum-values-as-keys-in-maps)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.7.2 Mapping between keys (strings) of enum members and their values](#mapping-between-keys-strings-of-enum-members-and-their-values)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.7.3 Iterating over enum members](#iterating-over-enum-members)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.7.4 Specifying bit vectors](#specifying-bit-vectors)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.7.5 Type validation for enums via Zod](#type-validation-for-enums-via-zod)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[26.8 Recommendations](#recommendations)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: TypeScript has built-in support for *enums* which are basically namespaces for
    constants. In this chapter we explore how they work, what patterns we can use
    instead and how to choose between them.
  prefs: []
  type: TYPE_NORMAL
- en: '[26.1 Making sense of enums](#making-sense-of-enums)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For TypeScript, it has become desirable to only use JavaScript at the non-type
    level because that makes compilation easier to understand and faster (thanks to
    a technique called [*type stripping*](ch_tsconfig-json.html#type-stripping)).
    That coding style can be enforced via the compiler option [`erasableSyntaxOnly`](ch_tsconfig-json.html#erasableSyntaxOnly)).
  prefs: []
  type: TYPE_NORMAL
- en: '*Enums* are one of the few non-type features that are not JavaScript. That’s
    why, after examining how they work, we’ll also look into JavaScript alternatives:
    patterns that we can use instead of enums. In order to find them, we’ll focus
    on three use cases.'
  prefs: []
  type: TYPE_NORMAL
- en: '[26.1.1 Use case 1: namespace for constants with primitive values](#use-case-1-namespace-for-constants-with-primitive-values)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This use case is about grouping related constants – think lookup table – e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We’d like to have a namespace for these constants and access them via `Color.Red`
    etc.
  prefs: []
  type: TYPE_NORMAL
- en: '[26.1.2 Use case 2: custom type with unique values](#use-case-2-custom-type-with-unique-values)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes, we want to define a custom type that has a limited set of values
    – e.g. to express program states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For this use case, we want to be able to [check exhaustiveness](ch_never.html#exhaustiveness-checks):
    When we handle cases (e.g. via `switch`), TypeScript should warn us during type
    checking if we forget a case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple version of `UnexpectedValueError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'How does it work? TypeScript infers the type `never` if there are no more values
    a variable can have. So that’s the type of `status` after `switch` checked all
    values it can have. The constructor `UnexpectedValueError` produces a type error
    if its parameter does *not* have the type `never`. For more information and a
    more sophisticated version of `UnexpectedValueError`, see [“Use case for `never`:
    exhaustiveness checks at compile time” (§15.4)](ch_never.html#exhaustiveness-checks).'
  prefs: []
  type: TYPE_NORMAL
- en: '[26.1.3 Use case 3: namespace for constants with object values](#use-case-3-namespace-for-constants-with-object-values)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is an example of such constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, this use case expands both use case 1 and use case 2:'
  prefs: []
  type: TYPE_NORMAL
- en: On one hand, we can look up more values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, we can define a type for the constants and then get type
    members with more information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: TypeScript enums do not support this use case. But there are enum patterns that
    do.
  prefs: []
  type: TYPE_NORMAL
- en: '[26.2 TypeScript enums](#typescript-enums)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[26.2.1 Number enums](#number-enums)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is a numeric enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This enum looks and works similarly to an object literal:'
  prefs: []
  type: TYPE_NORMAL
- en: It has the *members* `No` and `Yes`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each member has a name and (in this case) is explicitly assigned a value via
    an *initializer*: an equal sign followed by a value. We access those values via
    the dot operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As in object literals, trailing commas are allowed and ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how `NoYes` is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[26.2.2 String enums](#string-enums)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Instead of numbers, we can also use strings as enum member values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[26.2.3 Heterogeneous enums](#heterogeneous-enums)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last kind of enum is called *heterogeneous*. The member values of a heterogeneous
    enum are a mix of numbers and strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Heterogeneous enums are not used often because they have few applications.
  prefs: []
  type: TYPE_NORMAL
- en: Alas, TypeScript only supports numbers and strings as enum member values. Other
    values, such as symbols, are not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: '[26.2.4 Omitting initializers](#omitting-initializers)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can also completely omit initializers – in which case TypeScript automatically
    assigns numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s also possible to only omit some of the initializers. However, my recommendation
    is to avoid that and either omit none or all. We won’t go into the details of
    how exactly partial omissions work, but this is a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[26.2.5 Quoting enum member names](#quoting-enum-member-names)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Similar to JavaScript objects, we can quote the names of enum members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There is no way to compute the names of enum members. Object literals support
    computed property keys via square brackets.
  prefs: []
  type: TYPE_NORMAL
- en: '[26.2.6 Casing of enum member names](#casing-of-enum-member-names)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are several precedents for naming constants (in enums or elsewhere):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, JavaScript has used all-caps names, which is a convention it
    inherited from Java and C:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.MAX_VALUE`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Math.SQRT2`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Well-known symbols are camel-cased and start with lowercase letters because
    they are related to property names:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol.asyncIterator`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The TypeScript manual uses camel-cased names that start with uppercase letters.
    This is the standard TypeScript style and we used it for the `NoYes` enum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[26.2.7 An enum defines a value and a type](#an-enum-defines-a-value-and-a-type)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[26.2.7.1 The enum `ShapeKind` as a value](#the-enum-shapekind-as-a-value)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'On one hand, `ShapeKind` is a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[26.2.7.2 The enum `ShapeKind` as a type](#the-enum-shapekind-as-a-type)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'On the other hand, `ShapeKind` is also a type – whose structure is quite different
    from its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words: Even though the value of an enum is similar to an object, its
    type is quite different from an object type (whose keys are the types of the property
    keys, etc.).'
  prefs: []
  type: TYPE_NORMAL
- en: '[26.2.7.3 `ShapeKind` as a namespace for enum member types](#shapekind-as-a-namespace-for-enum-member-types)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Even though `ShapeKind` is basically a union type, it is additionally a namespace
    for the types of its members – e.g., the type `ShapeKind.Circle` is assignable
    to and from the literal number type `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'That means we can use enum member types at the type level – e.g. for parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Or for discriminants in discriminated unions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[26.2.8 Values accepted by enum types](#values-accepted-by-enum-types)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[26.2.8.1 Values accepted by number enum types](#values-accepted-by-number-enum-types)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If a parameter has a number enum type, it accepts both enum member values and
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can only use numbers that are values of enum members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[26.2.8.2 Values accepted by string enum types](#values-accepted-by-string-enum-types)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If a parameter has a string enum type, member values are considered to be unique
    – it does not accept strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[26.2.9 Enums at runtime](#enums-at-runtime)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TypeScript compiles enums to JavaScript objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[26.2.9.1 Number enums at runtime](#number-enums-at-runtime)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As an example, take the following enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript compiles this enum to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, the following assignments are made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two groups of assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mappings: The first two assignments map enum member names to values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reverse mappings: The second two assignments map values to names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TypeScript lets us use the reverse mappings to look up an enum key, given an
    enum value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[26.2.9.2 String enums at runtime](#string-enums-at-runtime)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: String-based enums have a simpler representation at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following enum.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'It is compiled to this JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript does not support reverse mappings for string-based enums.
  prefs: []
  type: TYPE_NORMAL
- en: '[26.2.10 Handling the enum use cases with enums](#handling-the-enum-use-cases-with-enums)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s get back to the use cases mentioned at the beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[26.2.10.1 Use case: namespace for constants with primitive values](#use-case-namespace-for-constants-with-primitive-values)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can use an enum as a namespace for constants with primitive values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Enums work well for this use case – but their values can only be numbers or
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[26.2.10.2 Use case: custom type with unique values](#use-case-custom-type-with-unique-values)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following enum defines a custom type with unique values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Benefit of explicitly specify string values via `=`: We get more type safety
    and can’t accidentally use string equal to enum values where a `Status` is expected.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we don’t need to explicitly define a type – `Status` is already a
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exhaustiveness checks for enums are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[26.3 TypeScript const enums](#typescript-const-enums)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If an enum is prefixed with the keyword `const`, it doesn’t have a representation
    at runtime. Instead, the values of its member are used directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[26.3.1 Const enums at runtime](#const-enums-at-runtime)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following const enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compile it, the const enum is not represented at runtime. Only the values
    of its members remain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare that to the compilation output of a normal enum `Vegetable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[26.3.2 Downsides of const enums](#downsides-of-const-enums)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For most projects, it is better to avoid const enums:'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to normal enums, they are not allowed if the compiler option [`erasableSyntaxOnly`](ch_tsconfig-json.html#erasableSyntaxOnly)
    is active.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a library package exports a const enum, clients won’t be able to use the
    compiler option [`isolatedModules`](ch_tsconfig-json.html#isolatedModules).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enum values at compile time can differ from enum values at runtime – which can
    lead to surprising bugs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The TypeScript handbook](https://www.typescriptlang.org/docs/handbook/enums.html#const-enum-pitfalls)
    describes these and other pitfalls in more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: '[26.4 Enum pattern: enum objects](#enum-pattern-enum-objects)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s time to look at plain JavaScript patterns that we can use instead of enums.
    One common pattern is to define “enum objects” via object literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[26.4.1 Ways of improving object literals](#ways-of-improving-object-literals)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have just seen the basic form of enum objects. There are several ways in
    which we can improve that pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Const object via `{} as const`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Frozen object via `Object.freeze({})`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`null` prototype via `{__proto__: null}`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '#1 is required if we want to derive a type from an enum object. The other two
    improvements are optional. They produce better results but also add visual clutter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[26.4.1.1 `as const` object literal: deriving a type for enum values and keys](#as-const-object-literal-deriving-a-type-for-enum-values-and-keys)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If we apply `as const` to an object literal, we get more specific property
    values at the type level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '**Deriving a type for the property values.** How is that useful? It enables
    us to create a type for the property values of `Tree`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Being able to create a type for enum object values will help us with the use
    case “custom type with unique values”.
  prefs: []
  type: TYPE_NORMAL
- en: 'The helper type `ValueOf` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The [*indexed access type* `Obj[K]`](ch_computing-with-types-overview.html#indexed-access-types)
    contains the values of all properties whose keys are in `K`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Deriving a type for the property keys.** We can also derive a type for the
    keys of `Tree`. But for that, we don’t need `as const`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[26.4.1.2 Frozen object literal: no modifications at runtime](#frozen-object-literal-no-modifications-at-runtime)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'At the JavaScript level, we can freeze objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'That helps us at runtime because `TreeFrozen` can’t be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'At the type level, `Object.freeze()` has the same effect as `as const`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[26.4.1.3 Object literal with `null` prototype: no inherited properties](#object-literal-with-null-prototype-no-inherited-properties)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can use the pseudo property key `__proto__` to set the prototype of `constants`
    to `null`. That is a good practice because then we don’t have to deal with inherited
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following two versions of `Tree`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can’t use the `in` operator to check if the enum `Tree` has a given key
    because it also considers inherited properties – which are not enum members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also read inherited properties and that looks like as if the enum `Tree`
    has more members than it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `Object.keys()` and `Object.values()` are safe to use – they only
    consider own (non-inherited) properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[26.4.1.4 Isn’t `__proto__` deprecated?](#isn-t-proto-deprecated)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Note that `__proto__` also exists as a getter and a setter in `Object.prototype`.
    This feature is deprecated in favor of `Object.getPrototypeOf()` and `Object.setPrototypeOf()`.
    However, that is different from using this name in an object literal – which is
    not deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information, check out these sections of “Exploring JavaScript”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[“The pitfalls of using an object as a dictionary”](https://exploringjs.com/js/book/ch_objects.html#the-pitfalls-of-using-an-object-as-a-dictionary)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Tips for working with prototypes”](https://exploringjs.com/js/book/ch_objects.html#tips-for-working-with-prototypes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“`Object.prototype.__proto__` (accessor)”](https://exploringjs.com/js/book/ch_classes.html#Object.prototype.__proto__)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[26.4.1.5 Caveat of `{__proto__}`: additional property at type level](#caveat-of-proto-additional-property-at-type-level)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If an object literal uses `.__proto__` then TypeScript includes that property
    at the type level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: I’d prefer that weren’t the case – given that `.__proto__` is not a real property
    ([related GitHub issue](https://github.com/microsoft/TypeScript/issues/38385)).
  prefs: []
  type: TYPE_NORMAL
- en: 'As a consequence, we have to manually exclude the key `''__proto__''` when
    deriving a type from `TreeProtoNull` via `ValueOf` (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Another workaround is to create a helper function for creating enums that sets
    the prototype to null at runtime but doesn’t use expose `.__proto__` at the type
    level. We’ll do that next.
  prefs: []
  type: TYPE_NORMAL
- en: '[26.4.2 A helper function for creating enum objects](#a-helper-function-for-creating-enum-objects)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is what the enum object pattern looks like if we use all of the improvements
    mentioned in the previous subsections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note that we don’t need `as const` because `Object.freeze()` has the same effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'A helper function can make this code slightly less verbose. The result has
    a type with specific property value types, from which we can derive a type for
    `Tree`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[26.4.3 Handling the enum use cases with enum objects](#handling-the-enum-use-cases-with-enum-objects)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[26.4.3.1 Use case: namespace for constants with primitive values](#use-case-namespace-for-constants-with-primitive-values-1)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For this use case, an object literal is a very good alternative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We can use a `null` prototype and freezing but they are not required in this
    case.
  prefs: []
  type: TYPE_NORMAL
- en: '[26.4.3.2 Use case: custom type with unique values](#use-case-custom-type-with-unique-values-1)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s use an object literal to define the value part of an enum (we’ll get
    to the type part next):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to `as const` in line A, we can derive a type from `Status`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The utility type `ValueOf` was defined [previously](#enums-ValueOf).
  prefs: []
  type: TYPE_NORMAL
- en: 'Why is this type called `StatusType` and not `Status`? Since the namespaces
    of values and types are separate in TypeScript, we could indeed use the same name.
    However, I’ve had issues when using Visual Studio Code to rename value and type:
    You can’t do both at the same time and VSC gets confused because importing `Status`
    imports both value and type.'
  prefs: []
  type: TYPE_NORMAL
- en: A benefit of using the name `StatusType` and not `TStatus` is that the former
    shows up in auto-completions for `Status`.
  prefs: []
  type: TYPE_NORMAL
- en: '[26.4.3.3 Exhaustiveness checks](#exhaustiveness-checks-1)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'TypeScript supports exhaustiveness checks for unions of literal types. And
    that’s what `StatusType` is. Therefore, we can use the same pattern as we did
    with enums:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note that in line A, the type of `status` is `StatusType`, not `Status` (which
    is a value).
  prefs: []
  type: TYPE_NORMAL
- en: '[26.4.4 Using the members of enum objects at the type level](#using-the-members-of-enum-objects-at-the-type-level)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An enum defines a value, a type and types for members. For enum objects, we
    have to create the latter two manually. We have already derived a type from an
    enum object. How about the types for members? Consider the following enum object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The members `ShapeKind.Circle` and `ShapeKind.Rectangle` only exist as values,
    not as types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, if we want to use those values at the type level, we have to apply
    `typeof` to them (line A and line B):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[26.4.5 Symbols as property values](#enum-object-with-symbols)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One downside of using strings as the property values of an enum object is that
    they are not unique: A derived type accepts both the property values and strings
    created via string literals (if they are equal to them). We can get more type
    safety if we use symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The utility type `ValueOf` was defined [previously](#enums-ValueOf).
  prefs: []
  type: TYPE_NORMAL
- en: 'This seems overly complicated: Why the intermediate step of first declaring
    variables for the symbols before using them? Why not create the symbols inside
    the object literal? Alas, that’s a current limitation of symbols in `as const`
    objects – they don’t produce unique types ([related GitHub issue](https://github.com/microsoft/TypeScript/issues/54100)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[26.4.6 Use case: an enum as a namespace for constants with object values](#use-case-an-enum-as-a-namespace-for-constants-with-object-values)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes, it’s useful to have an enum-like construct for looking up richer
    data – stored in objects. That’s something enums can’t do, but it is possible
    via enum objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Because each property value of `TextStyle` has the property `.key` with a unique
    value, `TextStyleType` is a [discriminated union](ch_unions-object-types.html#discriminated-unions).
  prefs: []
  type: TYPE_NORMAL
- en: '[26.4.6.1 Exhaustiveness check](#exhaustiveness-check)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Due to `TextStyleType` being a discriminated union, we can do an exhaustiveness
    check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In the `default` case, after we have checked all values that `textStyle.key`
    can have, `textStyle` itself has the type `never`.
  prefs: []
  type: TYPE_NORMAL
- en: '[26.5 Enum pattern: enum classes](#enum-pattern-enum-classes)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also use a class as an enum – a pattern that is borrowed from Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a type with the static properties of `TextStyle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'An upside of enum classes is that we can use methods to add behavior to enum
    values. A downside is that there is no simple way to get an exhaustiveness check:
    With an `as const` enum object whose property values are objects, we can create
    a discriminated union as an associated type – where we can check exhaustiveness.
    However, each static property of class `TextStyle` simply has the type `TextStyle`
    (the type of the instances of `TextStyle`) and that prevents us from creating
    a discriminated union.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.keys()` and `Object.values()` ignore non-enumerable properties of `TextStyle`
    such as `.prototype` – which is why we can use them to enumerate keys and values
    – e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[26.6 Enum pattern: string literal unions](#enum-pattern-string-literal-unions)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A union of string literal types is an interesting alternative to an enum when
    it comes to defining a type with a fixed set of members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: What are the pros and cons of this pattern?
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s a concise and simple solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports exhaustiveness checks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renaming members works reasonably well in Visual Studio Code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons:'
  prefs: []
  type: TYPE_NORMAL
- en: The type members are not unique. We could change that by using symbols but then
    we’d lose much of the convenience of string literal union types – e.g., we’d have
    to import the values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can’t use JSDoc comments for the elements of the union. That means we can’t
    `@deprecate` them either.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[26.6.1 Reifying string literal unions](#reifying-string-literal-unions)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Reification* means creating an entity at the object level (think JavaScript
    values) for an entity that exists at the meta level (think TypeScript types).
    We need to do that for string literal unions if, e.g., we want to iterate over
    their elements (which don’t exist at runtime). Other enum patterns support that
    out of the box.'
  prefs: []
  type: TYPE_NORMAL
- en: '[26.6.1.1 Deriving a string literal union from a Set](#deriving-a-string-literal-union-from-a-set)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can use a Set to reify a string literal union type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[26.6.1.2 Deriving a string literal union from an Array](#deriving-a-string-literal-union-from-an-array)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When it comes to reifying a string literal union, a Set is often the best choice
    because we can check at runtime if a given string is a member. However, we can
    also use an Array to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[26.7 More things we can do with enums](#more-things-we-can-do-with-enums)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we explore more things we can do with enums. We’ll mostly use
    enum objects but enums and other enum patterns will also be mentioned occasionally.
  prefs: []
  type: TYPE_NORMAL
- en: '[26.7.1 Enum values as keys in Maps](#enum-values-as-keys-in-maps)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes we want use enum values to look up other values. Let’s explore how
    that works for the following enum object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The utility type `ValueOf` was defined [previously](#enums-ValueOf).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Map uses the values of `Status` as keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are wondering why we didn’t directly use the value of `statusPairs`
    as the argument of `new Map()` and omit the type parameters: TypeScript isn’t
    able to infer the type parameters if the keys are symbols and reports a compile-time
    error. With strings, the code would be simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'As a final step, check manually if we used all enum values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In line A, we extract the type of the keys from `statusMap` and demand that
    it be equal to `StatusType`.
  prefs: []
  type: TYPE_NORMAL
- en: '[26.7.1.1 Exhaustiveness checks via `Record`](#exhaustiveness-checks-via-record)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'TypeScript can check if a union type is used exhaustively if we use `Record`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'However, such a union type can only have elements that are subtypes of `string`,
    `number` or `symbol`. That means that `Record` works well for unions of string
    literal types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[26.7.2 Mapping between keys (strings) of enum members and their values](#mapping-between-keys-strings-of-enum-members-and-their-values)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes it’s useful to map enum keys to values or vice versa. One important
    use case for that is deserializing enums of symbols or objects from JSON and serializing
    them to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[26.7.2.1 From enum key to enum value](#from-enum-key-to-enum-value)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One use case for mapping from the key of an enum member to its value, is parsing
    JSON data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to make both the type of `enumKey` and the return type more specific
    (see next subsection) but then we couldn’t parse values of type `string` anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '[26.7.2.2 From enum value to enum key](#from-enum-value-to-enum-key)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One use case for mapping from the value of an enum member to its key, is creating
    JSON data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[26.7.3 Iterating over enum members](#iterating-over-enum-members)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One use case for iterating over enum members is creating a user interface that
    lists options collected in an enum. Which enum patterns do support iteration?
  prefs: []
  type: TYPE_NORMAL
- en: We can only iterate over string enums – due to enums with number members having
    reverse mappings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For an enum object `enumObj`, we can use `Object.keys(enumObj)` and `Object.values(enumObj)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For an enum class `enumClass`, we can use `Object.keys(enumClass)` and `Object.values(enumClass)`.
    The own property `enumClass.prototype` is not enumerable and therefore ignored
    by both methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we want to iterate over the values of a string literal union, we have to
    [reify it via a Set or an Array](#reifying-string-literal-unions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[26.7.4 Specifying bit vectors](#specifying-bit-vectors)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One use case for enums is specifying bit vectors (multiple independent bit flags).
  prefs: []
  type: TYPE_NORMAL
- en: '[26.7.4.1 Specifying bit vectors via bit masks](#specifying-bit-vectors-via-bit-masks)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The traditional way of specifying bit vectors is via bit masks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: For more information on this kind of bit manipulation, see section [“Bitwise
    operators”](https://exploringjs.com/js/book/ch_numbers.html#bitwise-operators)
    in “Exploring JavaScript”.
  prefs: []
  type: TYPE_NORMAL
- en: '[26.7.4.2 Specifying bit vectors via Sets](#specifying-bit-vectors-via-sets)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another option for specifying bit vectors is via Sets. I often prefer that option.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[26.7.5 Type validation for enums via Zod](#type-validation-for-enums-via-zod)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Zod](https://zod.dev/) is a tool for *validating* parsed data (often JSON)
    – checking if the runtime data matches an expected type. That increases type safety
    when working with untyped data.'
  prefs: []
  type: TYPE_NORMAL
- en: Zod also supports enums, but the recommendation is to use string literal unions.
    They have to be defined via Arrays of strings because Zod needs data that it can
    use at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[26.8 Recommendations](#recommendations)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How should we choose between enums and various enum patterns?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go through the use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Namespace for constants with primitive values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this use case, enum objects are the best choice.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also use enums, as long as the primitive values are strings or numbers.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Custom type with unique values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I like enum objects with symbols for this use case. However, they are slightly
    verbose.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One more lightweight alternative are string literal unions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enums are also an option but it should be string enums because those are more
    type safe and logging their values (e.g. for debugging) works better.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Namespace for constants with object values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an enum object if you want exhaustiveness checks.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an enum class if you want enum values to have methods.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We can’t use enums for this use case.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Various considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned at the beginning of this chapter, with type stripping and `erasableSyntaxOnly`,
    we can’t use enums. Additionally, the code that enums are transpiled to is a bit
    difficult to read – especially if an enum has number members.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With string literal unions, there is no way to provide JSDoc comments for the
    members – which enables deprecation via `@deprecated`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If enum values are strings then comparing can be slower. However, that should
    only matter if your code does many comparisons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (I have heard of a TypeScript project where a switch away from strings improved
    performance significantly. Alas, I can’t find the link anymore – tips appreciated!)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enums with strings, symbols and objects are easier to work with than those with
    numbers – because you see names when you log enum values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
