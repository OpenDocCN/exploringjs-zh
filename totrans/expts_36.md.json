["```ts\nvalue satisfies Type\n\n```", "```ts\nconst sayHello = (name) => `Hello ${name}!`\n // @ts-expect-error: Cannot find name 'satisfies'.\n satisfies (str: string) => string;\n\n```", "```ts\nconst sayHello = (\n (name) => `Hello ${name}!`\n) satisfies (str: string) => string;\n\n```", "```ts\nconst point1 = { x: 2, y: 5 };\nassertType<\n { x: number, y: number }\n>(point1);\n\n```", "```ts\nconst point2 = { x: 2, y: 5 } as const;\nassertType<\n { readonly x: 2, readonly y: 5 }\n>(point2);\n\n```", "```ts\ntype Point = { x: number, y: number };\nconst point3: Point = { x: 2, y: 5 } as const;\nassertType<\n Point\n>(point3);\n\n```", "```ts\nconst point4 = { x: 2, y: 5 } as const satisfies Point;\nassertType<\n { readonly x: 2, readonly y: 5 }\n>(point4);\n\n```", "```ts\n// Should warn about missing property but doesn’t!\nconst point5 = { x: 2 } as const as Point; // OK\nassertType<\n Point\n>(point5);\n\n```", "```ts\n// @ts-expect-error: Type '{ readonly x: 2; }' does not satisfy\n// the expected type 'Point'.\nconst point6 = { x: 2 } as const satisfies Point;\n\n```", "```ts\ntype PartialPoint = { x?: number, y?: number };\n\nconst partialPoint1: PartialPoint = { y: 7 };\n\n// Should be an error\nconst x1 = partialPoint1.x;\nassertType<number | undefined>(x1);\n\n// Type should be `number`\nconst y1 = partialPoint1.y;\nassertType<number | undefined>(y1);\n\n```", "```ts\nconst partialPoint2 = { y: 7 } satisfies PartialPoint;\n\n// @ts-expect-error: Property 'x' does not exist on type\n// '{ y: number; }'.\nconst x2 = partialPoint2.x;\n\nconst y2 = partialPoint2.y;\nassertType<number>(y2);\n\n```", "```ts\nconst TextStyle = {\n Bold: {\n html: 'b',\n latex: 'textbf',\n },\n Italics: {\n html: 'i',\n // Missing: latex\n },\n};\n\ntype TextStyleKeys = keyof typeof TextStyle;\ntype _ = Assert<Equal<\n TextStyleKeys, \"Bold\" | \"Italics\"\n>>;\n\n```", "```ts\ntype TTextStyle = {\n html: string,\n latex: string,\n};\n\n```", "```ts\nconst TextStyle: Record<string, TTextStyle>  = {\n Bold: {\n html: 'b',\n latex: 'textbf',\n },\n // @ts-expect-error: Property 'latex' is missing in type\n // '{ html: string; }' but required in type 'TTextStyle'.\n Italics: {\n html: 'i',\n },\n};\n\ntype TextStyleKeys = keyof typeof TextStyle;\ntype _ = Assert<Equal<\n TextStyleKeys, string\n>>;\n\n```", "```ts\nconst TextStyle  = {\n Bold: {\n html: 'b',\n latex: 'textbf',\n },\n // @ts-expect-error: Property 'latex' is missing in type\n // '{ html: string; }' but required in type 'TTextStyle'.\n Italics: {\n html: 'i',\n },\n} satisfies Record<string, TTextStyle>;\n\ntype TextStyleKeys = keyof typeof TextStyle;\ntype _ = Assert<Equal<\n TextStyleKeys, \"Bold\" | \"Italics\"\n>>;\n\n```", "```ts\ntype ColorName = 'red' | 'green' | 'blue';\ntype Color =\n | string // hex\n | [number, number, number] // RGB\n;\nconst fullColorTable = {\n red: [255, 0, 0],\n green: '#00FF00',\n// @ts-expect-error:\n// Type '{ red: [number, number, number]; green: string; }'\n// does not satisfy the expected type 'Record<ColorName, Color>'.\n} satisfies Record<ColorName, Color>;\n\n```", "```ts\nconst partialColorTable = {\n red: [255, 0, 0],\n // @ts-expect-error: Object literal may only specify known\n // properties, but 'greenn' does not exist in type\n // 'Partial<Record<ColorName, Color>>'.\n // Did you mean to write 'green'?\n greenn: '#00FF00',\n} satisfies Partial<Record<ColorName, Color>>; // (A)\n\n```", "```ts\nconst partialColorTable2 = {\n red: [255, 0, 0],\n green: '#00FF00',\n} satisfies Partial<Record<ColorName, Color>>;\n\ntype PropKeys = keyof typeof partialColorTable2;\ntype _ = Assert<Equal<\n PropKeys, \"red\" | \"green\"\n>>;\n\n```", "```ts\nJSON.stringify({ /*···*/ });\n\n```", "```ts\nconst obj: SomeType = { /*···*/ };\nJSON.stringify(obj);\n\n```", "```ts\nJSON.stringify({ /*···*/ } satisfies SomeType);\n\n```", "```ts\ntype Product = {\n name: string,\n quantity: number,\n};\n\nconst response = await fetch('/api/products', {\n method: 'POST',\n body: JSON.stringify(\n {\n name: 'Toothbrush',\n quantity: 3,\n } satisfies Product\n ),\n headers: {\n 'Content-Type': 'application/json',\n },\n});\n\n```", "```ts\nimport type { StringCallback } from './core.js';\n\nexport const toUpperCase: StringCallback =\n (str) => str.toUpperCase();\n\n```", "```ts\nimport type { StringCallback } from './core.js';\n\nexport default (\n (str) => str.toUpperCase()\n) satisfies StringCallback;\n\n```", "```ts\ntype StrOrNum = string | number;\n\nconst str1 = 'abc' as StrOrNum;\n// @ts-expect-error: Property 'toUpperCase' does not exist on\n// type 'StrOrNum'.\nstr1.toUpperCase();\n\nconst str2: StrOrNum = 'abc';\nstr2.toUpperCase(); // OK\n\nlet str3: StrOrNum = 'abc';\nstr3.toUpperCase(); // OK\n\n```", "```ts\ntype LinkHref =\n | {\n kind: 'LinkHrefUrl',\n url: string,\n }\n | {\n kind: 'LinkHrefId',\n id: string,\n }\n;\nconst linkToIntro: LinkHref = {\n kind: 'LinkHrefId',\n id: '#intro',\n};\n// Type was narrowed:\nassertType<\n {\n kind: 'LinkHrefId',\n id: string,\n }\n>(linkToIntro);\n\n```", "```ts\ntype Robin = {\n name: 'Robin',\n};\n\nconst robin1 = { name: 'Robin' };\nassertType<string>(robin1.name);\n\nconst robin2 = { name: 'Robin' } satisfies Robin;\nassertType<'Robin'>(robin2.name);\n\n```", "```ts\n// No `satisfies`\nconst tuple1 = ['a', 1];\nassertType<\n (string | number)[]\n>(tuple1);\n\n// Non-empty tuple\nconst tuple2 = ['a', 1] satisfies [unknown, ...unknown[]];\nassertType<\n [string, number]\n>(tuple2);\n\n// Any tuple\nconst tuple3 = [] satisfies [unknown?, ...unknown[]];\nassertType<\n []\n>(tuple3);\n\n// Any tuple\nconst tuple4 = ['a', 1] satisfies [] | unknown[];\nassertType<\n [string, number]\n>(tuple4);\n\n```", "```ts\nconst tuple1: Array<string | number> = ['a', 1];\n\n// @ts-expect-error: Type '(string | number)[]' does not satisfy\n// the expected type '[unknown, ...unknown[]]'.\nconst tuple2 = tuple1 satisfies [unknown, ...unknown[]];\n\n```", "```ts\ntype Satisfies<Type extends Constraint, Constraint> = Type;\n\ntype T1 = Satisfies<123, number>; // 123\ntype _ = Assert<Equal<\n T1, 123\n>>;\n\n// @ts-expect-error: Type 'number' does not satisfy\n// the constraint 'string'.\ntype T2 = Satisfies<123, string>;\n\n```"]