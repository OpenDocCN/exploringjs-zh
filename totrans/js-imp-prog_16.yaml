- en: 13 Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/impatient-js/ch_operators.html](https://exploringjs.com/impatient-js/ch_operators.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 13.1 [Making sense of operators](ch_operators.html#making-sense-of-operators)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.1.1 [Operators coerce their operands to appropriate types](ch_operators.html#operators-coerce-their-operands-to-appropriate-types)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.1.2 [Most operators only work with primitive values](ch_operators.html#most-operators-only-work-with-primitive-values)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.2 [The plus operator (`+`)](ch_operators.html#the-plus-operator)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.3 [Assignment operators](ch_operators.html#assignment-operators)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.3.1 [The plain assignment operator](ch_operators.html#the-plain-assignment-operator)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.3.2 [Compound assignment operators](ch_operators.html#compound-assignment-operators)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '13.4 [Equality: `==` vs. `===`](ch_operators.html#equality-vs.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.4.1 [Loose equality (`==` and `!=`)](ch_operators.html#loose-equality-and)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.4.2 [Strict equality (`===` and `!==`)](ch_operators.html#strict-equality)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '13.4.3 [Recommendation: always use strict equality](ch_operators.html#recommendation-always-strict-equality)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '13.4.4 [Even stricter than `===`: `Object.is()`](ch_operators.html#Object.is)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.5 [Ordering operators](ch_operators.html#ordering-operators)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.6 [Various other operators](ch_operators.html#various-other-operators)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.6.1 [Comma operator](ch_operators.html#comma-operator)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.6.2 [`void` operator](ch_operators.html#void-operator)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 13.1 Making sense of operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript’s operators may seem quirky. With the following two rules, they
    are easier to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: Operators coerce their operands to appropriate types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most operators only work with primitive values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.1.1 Operators coerce their operands to appropriate types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If an operator gets operands that don’t have the proper types, it rarely throws
    an exception. Instead, it *coerces* (automatically converts) the operands so that
    it can work with them. Let’s look at two examples.
  prefs: []
  type: TYPE_NORMAL
- en: First, the multiplication operator can only work with numbers. Therefore, it
    converts strings to numbers before computing its result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, the square brackets operator (`[ ]`) for accessing the properties of
    an object can only handle strings and symbols. All other values are coerced to
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 13.1.2 Most operators only work with primitive values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As mentioned before, most operators only work with primitive values. If an
    operand is an object, it is usually coerced to a primitive value – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Why? The plus operator first coerces its operands to primitive values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, it concatenates the two strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 13.2 The plus operator (`+`)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The plus operator works as follows in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it converts both operands to primitive values. Then it switches to one
    of two modes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'String mode: If one of the two primitive values is a string, then it converts
    the other one to a string, concatenates both strings, and returns the result.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Number mode: Otherwise, It converts both operands to numbers, adds them, and
    returns the result.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'String mode lets us use `+` to assemble strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Number mode means that if neither operand is a string (or an object that becomes
    a string) then everything is coerced to numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`Number(true)` is `1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 13.3 Assignment operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 13.3.1 The plain assignment operator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The plain assignment operator is used to change storage locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Initializers in variable declarations can also be viewed as a form of assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 13.3.2 Compound assignment operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'JavaScript supports the following assignment operators:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Arithmetic assignment operators: `+= -= *= /= %=` [ES1]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+=` can also be used for string concatenation'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Introduced later: `**=` [ES2016]'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bitwise assignment operators: `&= ^= |=` [ES1]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bitwise shift assignment operators: `<<= >>= >>>=` [ES1]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Logical assignment operators: `||= &&= ??=` [ES2021]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.3.2.1 Logical assignment operators [ES2021]
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Logical assignment operators work differently from other compound assignment
    operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Assignment operator | Equivalent to | Only assigns if `a` is |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `a &#124;&#124;= b` | `a &#124;&#124; (a = b)` | Falsy |'
  prefs: []
  type: TYPE_TB
- en: '| `a &&= b` | `a && (a = b)` | Truthy |'
  prefs: []
  type: TYPE_TB
- en: '| `a ??= b` | `a ?? (a = b)` | Nullish |'
  prefs: []
  type: TYPE_TB
- en: Why is `a ||= b` equivalent to the following expression?
  prefs: []
  type: TYPE_NORMAL
- en: '`a || (a = b)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why not to this expression?
  prefs: []
  type: TYPE_NORMAL
- en: '`a = a || b`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The former expression has the benefit of [short-circuiting](ch_booleans.html#short-circuiting):
    The assignment is only evaluated if `a` evaluates to `false`. Therefore, the assignment
    is only performed if it’s necessary. In contrast, the latter expression always
    performs an assignment.'
  prefs: []
  type: TYPE_NORMAL
- en: For more on `??=`, see [§14.4.5 “The nullish coalescing assignment operator
    (`??=`) [ES2021]”](ch_undefined-null.html#nullish-coalescing-assignment-operator).
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.2.2 The remaining compound assignment operators
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For operators `op` other than `|| && ??`, the following two ways of assigning
    are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If, for example, `op` is `+`, then we get the operator `+=` that works as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '13.4 Equality: `==` vs. `===`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript has two kinds of equality operators: loose equality (`==`) and strict
    equality (`===`). The recommendation is to always use the latter.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **Other names for `==`
    and `===`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`==` is also called *double equals*. Its official name in the language specification
    is [*abstract equality comparison*](https://tc39.github.io/ecma262/#sec-abstract-equality-comparison).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`===` is also called *triple equals*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.4.1 Loose equality (`==` and `!=`)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Loose equality is one of JavaScript’s quirks. It often coerces operands. Some
    of those coercions make sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Others less so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Objects are coerced to primitives if (and only if!) the other operand is primitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If both operands are objects, they are only equal if they are the same object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, `==` considers `undefined` and `null` to be equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 13.4.2 Strict equality (`===` and `!==`)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Strict equality never coerces. Two values are only equal if they have the same
    type. Let’s revisit our previous interaction with the `==` operator and see what
    the `===` operator does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'An object is only equal to another value if that value is the same object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `===` operator does not consider `undefined` and `null` to be equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '13.4.3 Recommendation: always use strict equality'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I recommend to always use `===`. It makes your code easier to understand and
    spares you from having to think about the quirks of `==`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at two use cases for `==` and what I recommend to do instead.
  prefs: []
  type: TYPE_NORMAL
- en: '13.4.3.1 Use case for `==`: comparing with a number or a string'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`==` lets you check if a value `x` is a number or that number as a string –
    with a single comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'I prefer either of the following two alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can also convert `x` to a number when you first encounter it.
  prefs: []
  type: TYPE_NORMAL
- en: '13.4.3.2 Use case for `==`: comparing with `undefined` or `null`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Another use case for `==` is to check if a value `x` is either `undefined`
    or `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The problem with this code is that you can’t be sure if someone meant to write
    it that way or if they made a typo and meant `=== null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I prefer either of the following two alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: A downside of the second alternative is that it accepts values other than `undefined`
    and `null`, but it is a well-established pattern in JavaScript (to be explained
    in detail in [§15.3 “Truthiness-based existence checks”](ch_booleans.html#truthiness-existence-checks)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following three conditions are also roughly equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '13.4.4 Even stricter than `===`: `Object.is()`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Method `Object.is()` compares two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It is even stricter than `===`. For example, it considers `NaN`, [the error
    value for computations involving numbers](ch_numbers.html#nan), to be equal to
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'That is occasionally useful. For example, you can use it to implement an improved
    version of the Array method `.indexOf()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`myIndexOf()` finds `NaN` in an Array, while `.indexOf()` doesn’t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The result `-1` means that `.indexOf()` couldn’t find its argument in the Array.
  prefs: []
  type: TYPE_NORMAL
- en: 13.5 Ordering operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Table 3: JavaScript’s ordering operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `<` | less than |'
  prefs: []
  type: TYPE_TB
- en: '| `<=` | Less than or equal |'
  prefs: []
  type: TYPE_TB
- en: '| `>` | Greater than |'
  prefs: []
  type: TYPE_TB
- en: '| `>=` | Greater than or equal |'
  prefs: []
  type: TYPE_TB
- en: 'JavaScript’s ordering operators (tbl. [3](#tbl:ordering_operators)) work for
    both numbers and strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`<=` and `>=` are based on strict equality.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0ac255e56dc93a43365d8502301c8688.png)  **The ordering operators
    don’t work well for human languages**'
  prefs: []
  type: TYPE_NORMAL
- en: The ordering operators don’t work well for comparing text in a human language,
    e.g., when capitalization or accents are involved. The details are explained in
    [§20.6 “Comparing strings”](ch_strings.html#comparing-strings).
  prefs: []
  type: TYPE_NORMAL
- en: 13.6 Various other operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following operators are covered elsewhere in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: Operators for [booleans](ch_booleans.html), [numbers](ch_numbers.html), [strings](ch_strings.html),
    [objects](ch_objects.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The nullish coalescing operator (`??`) for default values](ch_undefined-null.html#nullish-coalescing-operator)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next two subsections discuss two operators that are rarely used.
  prefs: []
  type: TYPE_NORMAL
- en: 13.6.1 Comma operator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The comma operator has two operands, evaluates both of them and returns the
    second one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: For more information on this operator, see [*Speaking JavaScript*](http://speakingjs.com/es5/ch09.html#comma_operator).
  prefs: []
  type: TYPE_NORMAL
- en: 13.6.2 `void` operator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `void` operator evaluates its operand and returns `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For more information on this operator, see [*Speaking JavaScript*](http://speakingjs.com/es5/ch09.html#void_operator).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz**'
  prefs: []
  type: TYPE_NORMAL
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  prefs: []
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/8)'
  prefs: []
  type: TYPE_NORMAL
