- en: 13 Alternatives to enums in TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/tackling-ts/ch_enum-alternatives.html](https://exploringjs.com/tackling-ts/ch_enum-alternatives.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 13.1 [Unions of singleton values](ch_enum-alternatives.html#unions-of-singleton-values)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.1.1 [Primitive literal types](ch_enum-alternatives.html#primitive-literal-types)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.1.2 [Unions of string literal types](ch_enum-alternatives.html#unions-of-string-literal-types)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.1.3 [Unions of symbol singleton types](ch_enum-alternatives.html#unions-of-symbol-singleton-types)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '13.1.4 [Conclusion of this section: union types vs. enums](ch_enum-alternatives.html#conclusion-of-this-section-union-types-vs.-enums)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.2 [Discriminated unions](ch_enum-alternatives.html#discriminated-union)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '13.2.1 [Step 1: the syntax tree as a class hierarchy](ch_enum-alternatives.html#step-1-the-syntax-tree-as-a-class-hierarchy)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '13.2.2 [Step 2: the syntax tree as a union type of classes](ch_enum-alternatives.html#step-2-the-syntax-tree-as-a-union-type-of-classes)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '13.2.3 [Step 3: the syntax tree as a discriminated union](ch_enum-alternatives.html#step-3-the-syntax-tree-as-a-discriminated-union)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.2.4 [Discriminated unions vs. normal union types](ch_enum-alternatives.html#discriminated-unions-vs.-normal-union-types)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.3 [Object literals as enums](ch_enum-alternatives.html#object-literals-as-enums)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.3.1 [Object literals with string-valued properties](ch_enum-alternatives.html#object-literals-with-string-valued-properties)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.3.2 [Upsides and downsides of using object literals as enums](ch_enum-alternatives.html#upsides-and-downsides-of-using-object-literals-as-enums)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.4 [Enum pattern](ch_enum-alternatives.html#enum-pattern)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.5 [Summary of enums and enum alternatives](ch_enum-alternatives.html#summary-of-enums-and-enum-alternatives)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.6 [Acknowledgement](ch_enum-alternatives.html#acknowledgement)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[The previous chapter](ch_enums.html) explored how TypeScript enums work. In
    this chapter, we take a look at alternatives to enums.'
  prefs: []
  type: TYPE_NORMAL
- en: 13.1 Unions of singleton values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An enum maps member names to member values. If we don’t need or want the indirection,
    we can use a union of so-called *primitive literal types* – one per value. Before
    we can go into details, we need to learn about primitive literal types.
  prefs: []
  type: TYPE_NORMAL
- en: 13.1.1 Primitive literal types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Quick recap](ch_typescript-essentials.html#types-in-typescript): We can consider
    types to be sets of values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *singleton type* is a type with one element. Primitive literal types are
    singleton types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`UndefinedLiteralType` is the type with the single element `undefined`, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to be aware of the two language levels at play here (we have
    already encountered those levels [earlier in this book](ch_typescript-essentials.html#language-levels)).
    Consider the following variable declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first `'abc'` represents a type (a string literal type).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second `'abc'` represents a value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two use cases for primitive literal types are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Overloading on string parameters](ch_typing-functions.html#overloading-on-string-parameters)
    which enables the first argument of the following method call to determine the
    type of the second argument:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use a union of primitive literal types to define a type by enumerating
    its members:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Read on for more information about the second use case.
  prefs: []
  type: TYPE_NORMAL
- en: 13.1.2 Unions of string literal types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll start with an enum and convert it to a union of string literal types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`NoYesStrings` is the union type version of `NoYesEnum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The type `NoYesStrings` is the union of the string literal types `'No'` and
    `'Yes'`. The union type operator `|` is related to the set-theoretic union operator
    `∪`.
  prefs: []
  type: TYPE_NORMAL
- en: 13.1.2.1 Unions of string literal types can be checked for exhaustiveness
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following code demonstrates that exhaustiveness checks work for unions
    of string literal types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We forgot the case for `'No'` and TypeScript warns us that the function may
    return values that are not strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have also checked exhaustiveness more explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now TypeScript warns us that we reach the `default` case if `value` is `'No'`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/65d35c0a2478236e12cc4321e1b02db6.png)  **More information on
    exhaustiveness checking**'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on this topic, see [§12.7.2.2 “Protecting against forgetting
    cases via exhaustiveness checks”](ch_enums.html#exhaustiveness-checks).
  prefs: []
  type: TYPE_NORMAL
- en: '13.1.2.2 Downside: unions of string literals are less type-safe'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One downside of string literal unions is that non-member values can mistaken
    for members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is logical because the Spanish `'no'` and the English `'no'` are the same
    value. The actual problem is that there is no way to give them different identities.
  prefs: []
  type: TYPE_NORMAL
- en: 13.1.3 Unions of symbol singleton types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '13.1.3.1 Example: `LogLevel`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Instead of unions of string literal types, we can also use unions of symbol
    singleton types. Let’s start with a different enum this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Translated to a union of symbol singleton types, it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Why do we need `typeof` here? `off` etc. are values and can’t appear in type
    equations. The type operator `typeof` fixes this issue by converting values to
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider two variations of the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: '13.1.3.2 Variation #1: inlined symbols'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Can we inline the symbols (instead of referring to separate `const` declarations)?
    Alas, the operand of the type operator `typeof` must be an identifier or a “path”
    of identifiers separated by dots. Therefore, this syntax is illegal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '13.1.3.3 Variation #2: `let` instead of `const`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Can we use `let` instead of `const` to declare the variables? (That’s not necessarily
    an improvement but still an interesting question.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can’t because we need the narrower types that TypeScript infers for `const`-declared
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With `let`, `LogLevel` would simply have been an alias for `symbol`.
  prefs: []
  type: TYPE_NORMAL
- en: '`const` assertions normally solve this kind of problem. But they don’t work
    in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 13.1.3.4 Using `LogLevel` in a function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following function translates members of `LogLevel` to strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 13.1.3.5 Unions of symbol singleton types vs. unions of string literal types
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: How do the two approaches compare?
  prefs: []
  type: TYPE_NORMAL
- en: Exhaustiveness checks work for both.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using symbols is more verbose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each symbol “literal” creates a unique symbol that can’t be confused with any
    other symbol. That’s not true for string literals. Read on for details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Recall this example where the Spanish `''no''` was confused with the English
    `''no''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use symbols, we don’t have this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '13.1.4 Conclusion of this section: union types vs. enums'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Union types and enums have some things in common:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can auto-complete member values. However, we do it differently:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With enums, we get auto-completion after the enum name and a dot.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With union types, we have to explicitly trigger auto-completion.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Exhaustiveness checks also work for both.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But they also differ. Downsides of unions of symbol singleton types are:'
  prefs: []
  type: TYPE_NORMAL
- en: They are slightly verbose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no namespace for their members.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s slightly harder to migrate from them to different constructs (should it
    be necessary): It’s easier to find where enum member values are mentioned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Upsides of unions of symbol singleton types are:'
  prefs: []
  type: TYPE_NORMAL
- en: They are not a custom TypeScript language construct and therefore closer to
    plain JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String enums are only type-safe at compile time. Unions of symbol singleton
    types are additionally type-safe at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This matters especially if our compiled TypeScript code interacts with plain
    JavaScript code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.2 Discriminated unions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Discriminated unions](https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions)
    are related to [algebraic data types](https://wiki.haskell.org/Algebraic_data_type)
    in functional programming languages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how they work, consider the data structure *syntax tree* that
    represents expressions such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A syntax tree is either:'
  prefs: []
  type: TYPE_NORMAL
- en: A number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The addition of two syntax trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating an object-oriented class hierarchy for syntax trees.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we’ll transform it into something slightly more functional.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And finally, we’ll end up with a discriminated union.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '13.2.1 Step 1: the syntax tree as a class hierarchy'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is a typical object-oriented implementation of a syntax tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`SyntaxTree1` is the superclass of `NumberValue1` and `Addition1`. The keyword
    `public` is syntactic sugar for:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the instance property `.numberValue`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing this property via the parameter `numberValue`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is an example of using `SyntaxTree1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: [Trailing commas in argument lists](https://exploringjs.com/es2016-es2017/ch_trailing-comma-parameters.html)
    are allowed in JavaScript since ECMAScript 2016.'
  prefs: []
  type: TYPE_NORMAL
- en: '13.2.2 Step 2: the syntax tree as a union type of classes'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we define the syntax tree via a union type (line A), we don’t need object-oriented
    inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Since `NumberValue2` and `Addition2` don’t have a superclass, they don’t need
    to invoke `super()` in their constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, we create trees in the same manner as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '13.2.3 Step 3: the syntax tree as a discriminated union'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Finally, we get to discriminated unions. These are the type definitions for
    `SyntaxTree3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We have switched from classes to interfaces and therefore from instances of
    classes to plain objects.
  prefs: []
  type: TYPE_NORMAL
- en: The interfaces of a discriminated union must have at least one property in common
    and that property must have a different value for each one of them. That property
    is called the *discriminant* or *tag*. The discriminant of `SyntaxTree3` is `.kind`.
    Its types are [string literal types](ch_enum-alternatives.html#primitive-literal-types).
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare:'
  prefs: []
  type: TYPE_NORMAL
- en: The direct class of an instance is determined by its prototype.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of a member of a discriminated union is determined by its discriminant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is an object that matches `SyntaxTree3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We don’t need the type annotation in line A, but it helps ensure that the data
    has the correct structure. If we don’t do it here, we’ll find out about problems
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, the type of `tree` is a discriminated union. Every time
    we check its discriminant (line C), TypeScript updates its static type accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In line A, we haven’t checked the discriminant `.kind`, yet. Therefore, the
    current type of `tree` is still `SyntaxTree3` and we can’t access property `.numberValue`
    in line B (because only one of the types of the union has this property).
  prefs: []
  type: TYPE_NORMAL
- en: In line D, TypeScript knows that `.kind` is `'number-value'` and can therefore
    infer the type `NumberValue3` for `tree`. That’s why accessing `.numberValue`
    in the next line is OK, this time.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.3.1 Implementing functions for discriminated unions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We conclude this step with an example of how to implement functions for discriminated
    unions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is an operation that can be applied to members of all subtypes, the
    approaches for classes and discriminated unions differ:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Object-oriented approach: With classes, it is common to use a polymorphic method
    where each class has a different implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Functional approach: With discriminated unions, it is common to use a single
    function that handles all possibles cases and decides what to do by examining
    the discriminant of its parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following example demonstrates the functional approach. The discriminant
    is examined in line A and determines which of the two `switch` cases is executed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that TypeScript performs exhaustiveness checking for discriminated unions:
    If we forget a case, TypeScript will warn us.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the object-oriented version of the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '13.2.3.2 Extensibility: object-oriented approach vs. functional approach'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Each approach does one kind of extensibility well:'
  prefs: []
  type: TYPE_NORMAL
- en: With the object-oriented approach, we have to modify each class if we want to
    add a new operation. However, adding a new type does not require any changes to
    existing code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the functional approach, we have to modify each function if we want to
    add a new type. In contrast, adding new operations is simple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.2.4 Discriminated unions vs. normal union types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Discriminated unions and normal union types have two things in common:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no namespace for member values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript performs exhaustiveness checking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next two subsections explore two advantages of discriminated unions over
    normal unions:'
  prefs: []
  type: TYPE_NORMAL
- en: '13.2.4.1 Benefit: descriptive property names'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'With discriminated unions, values get descriptive property names. Let’s compare:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Normal union:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Discriminated union:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now people who read the source code immediately know what the string is: a
    native pathname.'
  prefs: []
  type: TYPE_NORMAL
- en: '13.2.4.2 Benefit: We can also use it when the parts are indistinguishable'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The following discriminated union cannot be implemented as a normal union because
    we can’t distinguish the types of the union in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 13.3 Object literals as enums
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following pattern for implementing enums is common in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can attempt to use it in TypeScript as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Alas, the type of each property of `Color` is `symbol` (line A) and `TColor`
    (line B) is an alias for `symbol`. As a consequence, we can pass any symbol to
    `toGerman()` and TypeScript won’t complain at compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'A `const` assertion often helps in this kind of situation but not this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The only way to fix this is via constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 13.3.1 Object literals with string-valued properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We need [`as const`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions)
    in line A so that the properties of `Color` don’t have the more general type `string`.
    Then `TColor` also has a type that is more specific than `string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to using an object with symbol-valued properties as an enum, string-valued
    properties are:'
  prefs: []
  type: TYPE_NORMAL
- en: Better at development time because we get exhaustiveness checks and can derive
    a narrow type for the values (without using external constants).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Worse at runtime because strings can be mistaken for enum values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.3.2 Upsides and downsides of using object literals as enums
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Upsides:'
  prefs: []
  type: TYPE_NORMAL
- en: We have a namespace for the values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don’t use a custom construct and are closer to plain JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can derive a narrow type for enum values (if we use string-valued properties).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exhaustiveness checks are performed for such a type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: No dynamic membership check is possible (without extra work).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-enum values can be mistaken for enum values statically or at runtime (if
    we use string-valued properties).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.4 Enum pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following example demonstrates [a Java-inspired enum pattern](https://2ality.com/2020/01/enum-pattern.html)
    that works in plain JavaScript and TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Alas, TypeScript doesn’t perform exhaustiveness checks, which is why we get
    an error in line A.
  prefs: []
  type: TYPE_NORMAL
- en: 13.5 Summary of enums and enum alternatives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following table summarizes the characteristics of enums and their alternatives
    in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Unique | Namesp. | Iter. | Mem. CT | Mem. RT | Exhaust. |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Number enums | `-` | `✔` | `✔` | `✔` | `-` | `✔` |'
  prefs: []
  type: TYPE_TB
- en: '| String enums | `✔` | `✔` | `✔` | `✔` | `-` | `✔` |'
  prefs: []
  type: TYPE_TB
- en: '| String unions | `-` | `-` | `-` | `✔` | `-` | `✔` |'
  prefs: []
  type: TYPE_TB
- en: '| Symbol unions | `✔` | `-` | `-` | `✔` | `-` | `✔` |'
  prefs: []
  type: TYPE_TB
- en: '| Discrim. unions | `-` (1) | `-` | `-` | `✔` | `-` (2) | `✔` |'
  prefs: []
  type: TYPE_TB
- en: '| Symbol properties | `✔` | `✔` | `✔` | `-` | `-` | `-` |'
  prefs: []
  type: TYPE_TB
- en: '| String properties | `-` | `✔` | `✔` | `✔` | `-` | `✔` |'
  prefs: []
  type: TYPE_TB
- en: '| Enum pattern | `✔` | `✔` | `✔` | `✔` | `✔` | `-` |'
  prefs: []
  type: TYPE_TB
- en: 'Titles of table columns:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unique values: No non-enum value can be mistaken for an enum value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespace for enum keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it possible to iterate over enum values?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Membership check for values at compile time: Is there a narrow type for the
    enum values?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Membership check for values at runtime:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the enum pattern, the runtime membership test is `instanceof`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that a membership test can be implemented relatively easily if it is possible
    to iterate over enum values.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Exhaustiveness check (statically by TypeScript)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Footnotes in table cells:'
  prefs: []
  type: TYPE_NORMAL
- en: Discriminated unions are not really unique, but mistaking values for union members
    is relatively unlikely (especially if we use a unique name for the discriminant
    property).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the discriminant property has a unique enough name, it can be used to check
    membership.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 13.6 Acknowledgement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thanks to [Kirill Sukhomlin](https://twitter.com/kirilloid_ru) for his suggestion
    on how to define `TColor` for an object literal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/tackling-ts/issues/13)'
  prefs: []
  type: TYPE_NORMAL
