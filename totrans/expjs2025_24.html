<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>20 Bigints – arbitrary-precision integers ES2020 (advanced)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>20 Bigints – arbitrary-precision integers ES2020 (advanced)</h1>
<blockquote>原文：<a href="https://exploringjs.com/js/book/ch_bigints.html">https://exploringjs.com/js/book/ch_bigints.html</a></blockquote>

        
    
    
    
<p><span id="index-entry-bigint"/></p>
<nav class="local-toc">
  <ol>
    <li>
      <a href="#why-bigints">20.1 Why bigints?</a>
    </li>
    <li>
      <a href="#bigints-overview">20.2 Bigints</a>
      <ol>
        <li>
          <a href="#going-beyond-53-bits-for-integers">20.2.1 Going beyond 53 bits for integers</a>
        </li>
        <li>
          <a href="#example-using-bigints">20.2.2 Example: using bigints</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#bigint-literals">20.3 Bigint literals</a>
      <ol>
        <li>
          <a href="#numeric-separator-bigint-literals">20.3.1 Underscores (<code>_</code>) as separators in bigint literals<span> <sup>ES2021</sup></span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#reusing-number-operators-for-bigints-overloading">20.4 Reusing number operators for bigints (overloading)</a>
      <ol>
        <li>
          <a href="#arithmetic-operators-1">20.4.1 Arithmetic operators</a>
        </li>
        <li>
          <a href="#loose-equality--and-inequality-">20.4.2 Loose equality (<code>==</code>) and inequality (<code>!=</code>)</a>
        </li>
        <li>
          <a href="#strict-equality--and-inequality-">20.4.3 Strict equality (<code>===</code>) and inequality (<code>!==</code>)</a>
        </li>
        <li>
          <a href="#ordering-operators-1">20.4.4 Ordering operators</a>
        </li>
        <li>
          <a href="#bitwise-operators-advanced-1">20.4.5 Bitwise operators<span> (advanced)</span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#the-wrapper-constructor-bigint">20.5 The wrapper constructor <code>BigInt</code></a>
      <ol>
        <li>
          <a href="#bigint-as-a-constructor-and-as-a-function">20.5.1 <code>BigInt</code> as a constructor and as a function</a>
        </li>
        <li>
          <a href="#bigintprototype-methods">20.5.2 <code>BigInt.prototype.*</code> methods</a>
        </li>
        <li>
          <a href="#bigint-methods-casting">20.5.3 <code>BigInt.*</code> methods: casting</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#coercing-bigints-to-other-primitive-types">20.6 Coercing bigints to other primitive types</a>
    </li>
    <li>
      <a href="#typed-array-and-dataview-operations-for-64bit-values">20.7 Typed Array and DataView operations for 64-bit values</a>
    </li>
    <li>
      <a href="#bigints-and-json">20.8 Bigints and JSON</a>
      <ol>
        <li>
          <a href="#stringifying-bigints">20.8.1 Stringifying bigints</a>
        </li>
        <li>
          <a href="#parsing-bigints">20.8.2 Parsing bigints</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#faq-bigints">20.9 FAQ: Bigints</a>
      <ol>
        <li>
          <a href="#how-do-i-decide-when-to-use-numbers-and-when-to-use-bigints">20.9.1 How do I decide when to use numbers and when to use bigints?</a>
        </li>
        <li>
          <a href="#why-not-just-increase-the-precision-of-numbers-in-the-same-manner-as-is-done-for-bigints">20.9.2 Why not just increase the precision of numbers in the same manner as is done for bigints?</a>
        </li>
      </ol>
    </li>
  </ol>
</nav>
<p>In this chapter, we take a look at <em>bigints</em>, JavaScript’s integers whose storage space grows and shrinks as needed.</p>
<h3 id="why-bigints"><a class="heading-id-link" href="#why-bigints">20.1 Why bigints?</a></h3>
<p>Before ECMAScript 2020, JavaScript handled integers as follows:</p>
<ul>
  <li>
    <p>There only was a single type for floating point numbers and integers: 64-bit floating point numbers (IEEE 754 double precision).</p>
  </li>
  <li>
    <p>Under the hood, most JavaScript engines transparently supported integers: If a number has no decimal digits and is within a certain range, it can internally be stored as a genuine integer. This representation is called <em>small integer</em> and usually fits into 32 bits. For example, the range of small integers on the 64-bit version of the V8 engine is from −2<sup>31</sup> to 2<sup>31</sup>−1 (<a href="https://medium.com/fhinkel/v8-internals-how-small-is-a-small-integer-e0badc18b6da">source</a>).</p>
  </li>
  <li>
    <p>JavaScript numbers could also represent integers beyond the small integer range, as floating point numbers. Here, the safe range is plus/minus 53 bits. For more information on this topic, see <a href="ch_numbers.html#safe-integers">“Safe integers” (§18.9.4)</a>.</p>
  </li>
</ul>
<p>Sometimes, we need more than signed 53 bits – for example:</p>
<ul>
  <li>
    X (formerly Twitter) uses 64-bit integers as IDs for posts (<a href="https://developer.x.com/en/docs/twitter-ids">source</a>). In JavaScript, these IDs had to be stored in strings.
  </li>
  <li>
    Financial technology uses so-called <em>big integers</em> (integers with arbitrary precision) to represent amounts of money. Internally, the amounts are multiplied so that the decimal numbers disappear. For example, USD amounts are multiplied by 100 so that the cents disappear.
  </li>
</ul>
<h3 id="bigints-overview"><a class="heading-id-link" href="#bigints-overview">20.2 Bigints</a></h3>
<p><em>Bigint</em> is a primitive data type for integers. Bigints don’t have a fixed storage size in bits; their sizes adapt to the integers they represent:</p>
<ul>
  <li>
    Small integers are represented with fewer bits than large integers.
  </li>
  <li>
    There is no negative lower limit or positive upper limit for the integers that can be represented.
  </li>
</ul>
<p>A bigint literal is a sequence of one or more digits, suffixed with an <code>n</code> – for example:</p>
<pre class="language-js">
<code><span class="hljs-number">123n</span></code>
</pre>
<p>Operators such as <code>-</code> and <code>*</code> are overloaded and work with bigints:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">123n</span> * <span class="hljs-number">456n</span></span></code>
<code>56088n</code>
</pre>
<p>Bigints are primitive values. <code>typeof</code> returns a distinct result for them:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-number">123n</span></span></code>
<code>'bigint'</code>
</pre>
<h4 id="going-beyond-53-bits-for-integers"><a class="heading-id-link" href="#going-beyond-53-bits-for-integers">20.2.1 Going beyond 53 bits for integers</a></h4>
<p>JavaScript numbers are internally represented as a fraction multiplied by an exponent (see <a href="ch_numbers.html#floating-point-precision">“Background: floating point precision” (§18.8)</a> for details). As a consequence, if we go beyond the highest <a href="ch_numbers.html#safe-integers"><em>safe integer</em></a> 2<sup>53</sup>−1, there are still <em>some</em> integers that can be represented, but with gaps between them:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">2</span>**<span class="hljs-number">53</span> <span class="hljs-comment">// can be represented but same as next number</span></span></code>
<code>9007199254740992</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">2</span>**<span class="hljs-number">53</span> + <span class="hljs-number">1</span> <span class="hljs-comment">// wrong</span></span></code>
<code>9007199254740992</code>
</pre>
<p>Bigints enable us to go beyond 53 bits:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">2n</span>**<span class="hljs-number">53n</span></span></code>
<code>9007199254740992n</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">2n</span>**<span class="hljs-number">53n</span> + <span class="hljs-number">1n</span></span></code>
<code>9007199254740993n</code>
</pre>
<h4 id="example-using-bigints"><a class="heading-id-link" href="#example-using-bigints">20.2.2 Example: using bigints</a></h4>
<p>This is what using bigints looks like (code based on an example in the proposal):</p>
<pre class="language-js">
<code><span class="hljs-comment">/**</span></code>
<code><span class="hljs-comment"> * Takes a bigint as an argument and returns a bigint</span></code>
<code><span class="hljs-comment"> */</span></code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">nthPrime</span>(<span class="hljs-params">nth</span>) {</code>
<code>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nth !== <span class="hljs-string">'bigint'</span>) {</code>
<code>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>();</code>
<code>  }</code>
<code>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isPrime</span>(<span class="hljs-params">p</span>) {</code>
<code>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2n</span>; i &lt; p; i++) {</code>
<code>      <span class="hljs-keyword">if</span> (p % i === <span class="hljs-number">0n</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</code>
<code>    }</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</code>
<code>  }</code>
<code>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2n</span>; ; i++) {</code>
<code>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isPrime</span>(i)) {</code>
<code>      <span class="hljs-keyword">if</span> (--nth === <span class="hljs-number">0n</span>) <span class="hljs-keyword">return</span> i;</code>
<code>    }</code>
<code>  }</code>
<code>}</code>
<code/>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  [<span class="hljs-number">1n</span>, <span class="hljs-number">2n</span>, <span class="hljs-number">3n</span>, <span class="hljs-number">4n</span>, <span class="hljs-number">5n</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">nth</span> =&gt;</span> <span class="hljs-title function_">nthPrime</span>(nth)),</code>
<code>  [<span class="hljs-number">2n</span>, <span class="hljs-number">3n</span>, <span class="hljs-number">5n</span>, <span class="hljs-number">7n</span>, <span class="hljs-number">11n</span>]</code>
<code>);</code>
</pre>
<h3 id="bigint-literals"><a class="heading-id-link" href="#bigint-literals">20.3 Bigint literals</a></h3>
<p>Like number literals, bigint literals support several bases:</p>
<ul>
  <li>
    Decimal: <code>123n</code>
  </li>
  <li>
    Hexadecimal: <code>0xFFn</code>
  </li>
  <li>
    Binary: <code>0b1101n</code>
  </li>
  <li>
    Octal: <code>0o777n</code>
  </li>
</ul>
<p>Negative bigints are produced by prefixing the unary minus operator: <code>-0123n</code></p>
<h4 id="numeric-separator-bigint-literals"><a class="heading-id-link" href="#numeric-separator-bigint-literals">20.3.1 Underscores (<code>_</code>) as separators in bigint literals<span> <sup>ES2021</sup></span></a></h4>
<p><a href="ch_numbers.html#numeric-separator-number-literals">Just like in number literals</a>, we can use underscores (<code>_</code>) as separators in bigint literals:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> massOfEarthInKg = <span class="hljs-number">6_000_000_000_000_000_000_000_000n</span>;</code>
</pre>
<p>Bigints are often used to represent money in the financial technical sector. Separators can help here, too:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> priceInCents = <span class="hljs-number">123_000_00n</span>; <span class="hljs-comment">// 123 thousand dollars</span></code>
</pre>
<p>As with number literals, two restrictions apply:</p>
<ul>
  <li>
    We can only put an underscore between two digits.
  </li>
  <li>
    We can use at most one underscore in a row.
  </li>
</ul>
<h3 id="reusing-number-operators-for-bigints-overloading"><a class="heading-id-link" href="#reusing-number-operators-for-bigints-overloading">20.4 Reusing number operators for bigints (overloading)</a></h3>
<p>With most operators, we are not allowed to mix bigints and numbers. If we do, exceptions are thrown:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">2n</span> + <span class="hljs-number">1</span></span></code>
<code>TypeError: Cannot mix BigInt and other types, use explicit conversions</code>
</pre>
<p>The reason for this rule is that there is no general way of coercing a number and a bigint to a common type: numbers can’t represent bigints beyond 53 bits, bigints can’t represent fractions. Therefore, the exceptions warn us about typos that may lead to unexpected results.</p>
<p>Consider the following expression:</p>
<pre class="language-js">
<code><span class="hljs-number">2</span>**<span class="hljs-number">53</span> + <span class="hljs-number">1n</span></code>
</pre>
<p>Should the result be <code>9007199254740993n</code> or <code>9007199254740992</code>?</p>
<p>It is also not clear what the result of the following expression should be:</p>
<pre class="language-js">
<code><span class="hljs-number">2n</span>**<span class="hljs-number">53n</span> * <span class="hljs-number">3.3</span></code>
</pre>
<h4 id="arithmetic-operators-1"><a class="heading-id-link" href="#arithmetic-operators-1">20.4.1 Arithmetic operators</a></h4>
<p>Binary <code>+</code>,  binary <code>-</code>, <code>*</code>, <code>**</code> work as expected:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">7n</span> * <span class="hljs-number">3n</span></span></code>
<code>21n</code>
</pre>
<p>It is OK to mix bigints and strings:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">6n</span> + <span class="hljs-string">' apples'</span></span></code>
<code>'6 apples'</code>
</pre>
<p><code>/</code> and <code>%</code> round towards zero by removing the fraction (like <code>Math.trunc()</code>):</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">1n</span> / <span class="hljs-number">2n</span></span></code>
<code>0n</code>
</pre>
<p>Unary <code>-</code> works as expected:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">-(-<span class="hljs-number">64n</span>)</span></code>
<code>64n</code>
</pre>
<p>Unary <code>+</code> is not supported for bigints because much code relies on it coercing its operand to number:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">+<span class="hljs-number">23n</span></span></code>
<code>TypeError: Cannot convert a BigInt value to a number</code>
</pre>
<h4 id="loose-equality--and-inequality-"><a class="heading-id-link" href="#loose-equality--and-inequality-">20.4.2 Loose equality (<code>==</code>) and inequality (<code>!=</code>)</a></h4>
<p>Loose equality (<code>==</code>) and inequality (<code>!=</code>) coerce values:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">0n</span> == <span class="hljs-literal">false</span></span></code>
<code>true</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">1n</span> == <span class="hljs-literal">true</span></span></code>
<code>true</code>
<code/>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">123n</span> == <span class="hljs-number">123</span></span></code>
<code>true</code>
<code/>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">123n</span> == <span class="hljs-string">'123'</span></span></code>
<code>true</code>
</pre>
<h4 id="strict-equality--and-inequality-"><a class="heading-id-link" href="#strict-equality--and-inequality-">20.4.3 Strict equality (<code>===</code>) and inequality (<code>!==</code>)</a></h4>
<p>Strict equality (<code>===</code>) and inequality (<code>!==</code>) only consider values to be equal if they have the same type:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">123n</span> === <span class="hljs-number">123</span></span></code>
<code>false</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">123n</span> === <span class="hljs-number">123n</span></span></code>
<code>true</code>
</pre>
<h4 id="ordering-operators-1"><a class="heading-id-link" href="#ordering-operators-1">20.4.4 Ordering operators</a></h4>
<p>Ordering operators <code>&lt;</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;=</code> work as expected:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">17n</span> &lt;= <span class="hljs-number">17n</span></span></code>
<code>true</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">3n</span> &gt; -<span class="hljs-number">1n</span></span></code>
<code>true</code>
</pre>
<p>Comparing bigints and numbers does not pose any risks. Therefore, we can mix bigints and numbers:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">3n</span> &gt; -<span class="hljs-number">1</span></span></code>
<code>true</code>
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Converting numbers-based code to bigints</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/bigints/gcd-bigint_test.mjs</code></p>
</div>
<h4 id="bitwise-operators-advanced-1"><a class="heading-id-link" href="#bitwise-operators-advanced-1">20.4.5 Bitwise operators<span> (advanced)</span></a></h4>
<h5 id="bitwise-operators-for-numbers"><a class="heading-id-link" href="#bitwise-operators-for-numbers">20.4.5.1 Bitwise operators for numbers</a></h5>
<p>Bitwise operators interpret numbers as 32-bit integers. These integers are either unsigned or signed. If they are signed, the negative of an integer is its <em>two’s complement</em>: If we add an integer to its two’s complement and ignore overflow (digits beyond 32 bits) then the result is zero.</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">2</span>**<span class="hljs-number">32</span> - <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">0</span> <span class="hljs-comment">// 0b11111111111111111111111111111111</span></span></code>
<code>-1</code>
</pre>
<p>If we add <code>1</code> to the binary number consisting of 32 ones, we get a one followed by 32 zeros. Everything beyond 32 bits is overflow, which means that that number is zero.</p>
<p>We used signed right shift operator (<code>&gt;&gt;</code>): We shifted the left operand by zero bits, which converted it to Int32 (which is signed) and back to number.</p>
<p>Due to these integers having a fixed size, their highest bits indicate their signs:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">2</span>**<span class="hljs-number">31</span> &gt;&gt; <span class="hljs-number">0</span> <span class="hljs-comment">// highest bit is 1</span></span></code>
<code>-2147483648</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">2</span>**<span class="hljs-number">31</span> - <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">0</span> <span class="hljs-comment">// highest bit is 0</span></span></code>
<code>2147483647</code>
</pre>
<h5 id="bitwise-operators-for-bigints"><a class="heading-id-link" href="#bitwise-operators-for-bigints">20.4.5.2 Bitwise operators for bigints</a></h5>
<p>For bigints, bitwise operators interpret a negative sign as an infinite two’s complement – for example:</p>
<ul>
  <li>
    <code>-1</code> is <code>···111111</code> (ones extend infinitely to the left)
  </li>
  <li>
    <code>-2</code> is <code>···111110</code>
  </li>
  <li>
    <code>-3</code> is <code>···111101</code>
  </li>
  <li>
    <code>-4</code> is <code>···111100</code>
  </li>
</ul>
<p>That is, a negative sign is more of an external flag and not represented as an actual bit.</p>
<h5 id="bitwise-not-"><a class="heading-id-link" href="#bitwise-not-">20.4.5.3 Bitwise Not (<code>~</code>)</a></h5>
<p>Bitwise Not (<code>~</code>) inverts all bits:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  ~<span class="hljs-number">0b10n</span>,</code>
<code>  -<span class="hljs-number">3n</span> <span class="hljs-comment">// ···111101</span></code>
<code>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  ~-<span class="hljs-number">2n</span>, <span class="hljs-comment">// ···111110</span></code>
<code>  <span class="hljs-number">1n</span></code>
<code>);</code>
</pre>
<h5 id="binary-bitwise-operators---"><a class="heading-id-link" href="#binary-bitwise-operators---">20.4.5.4 Binary bitwise operators (<code>&amp;</code>, <code>|</code>, <code>^</code>)</a></h5>
<p>Applying binary bitwise operators to bigints works analogously to applying them to numbers:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">(<span class="hljs-number">0b1010n</span> |  <span class="hljs-number">0b0111n</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>)</span></code>
<code>'1111'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">(<span class="hljs-number">0b1010n</span> &amp;  <span class="hljs-number">0b0111n</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>)</span></code>
<code>'10'</code>
<code/>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">(<span class="hljs-number">0b1010n</span> | -<span class="hljs-number">1n</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>)</span></code>
<code>'-1'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">(<span class="hljs-number">0b1010n</span> &amp; -<span class="hljs-number">1n</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>)</span></code>
<code>'1010'</code>
</pre>
<h5 id="bitwise-signed-shift-operators--and-"><a class="heading-id-link" href="#bitwise-signed-shift-operators--and-">20.4.5.5 Bitwise signed shift operators (<code>&lt;&lt;</code> and <code>&gt;&gt;</code>)</a></h5>
<p>The signed shift operators for bigints preserve the sign of a number:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">2n</span> &lt;&lt; <span class="hljs-number">1n</span></span></code>
<code>4n</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">-<span class="hljs-number">2n</span> &lt;&lt; <span class="hljs-number">1n</span></span></code>
<code>-4n</code>
<code/>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">2n</span> &gt;&gt; <span class="hljs-number">1n</span></span></code>
<code>1n</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">-<span class="hljs-number">2n</span> &gt;&gt; <span class="hljs-number">1n</span></span></code>
<code>-1n</code>
</pre>
<p>Recall that <code>-1n</code> is a sequence of ones that extends infinitely to the left. That’s why shifting it left doesn’t change it:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">-<span class="hljs-number">1n</span> &gt;&gt; <span class="hljs-number">20n</span></span></code>
<code>-1n</code>
</pre>
<h5 id="bitwise-unsigned-right-shift-operator-"><a class="heading-id-link" href="#bitwise-unsigned-right-shift-operator-">20.4.5.6 Bitwise unsigned right shift operator (<code>&gt;&gt;&gt;</code>)</a></h5>
<p>There is no unsigned right shift operator for bigints:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">2n</span> &gt;&gt;&gt; <span class="hljs-number">1n</span></span></code>
<code>TypeError: BigInts have no unsigned right shift, use &gt;&gt; instead</code>
</pre>
<p>Why? The idea behind unsigned right shifting is that a zero is shifted in “from the left”. In other words, the assumption is that there is a finite amount of binary digits.</p>
<p>However, with negative bigints (especially negative ones), there is no “left”; their binary digits extend infinitely.</p>
<p>Signed right shift works even with an infinite number of digits because the highest digit is preserved. Therefore, it can be adapted to bigints.</p>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Implementing a bit set via bigints</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/bigints/bit-set_test.mjs</code></p>
</div>
<h3 id="the-wrapper-constructor-bigint"><a class="heading-id-link" href="#the-wrapper-constructor-bigint">20.5 The wrapper constructor <code>BigInt</code></a></h3>
<p>Analogously to numbers, bigints have the associated wrapper constructor <code>BigInt</code>.</p>
<h4 id="bigint-as-a-constructor-and-as-a-function"><a class="heading-id-link" href="#bigint-as-a-constructor-and-as-a-function">20.5.1 <code>BigInt</code> as a constructor and as a function</a></h4>
<ul>
  <li>
    <p><code>new BigInt()</code>: throws a <code>TypeError</code>.</p>
  </li>
  <li>
    <p><code>BigInt(x)</code> converts arbitrary values <code>x</code> to bigint. This works similarly to <code>Number()</code>, with several differences which are summarized in <a href="#tbl:converting-values-to-bigints">table 20.1</a> and explained in more detail in the following subsections.</p>
  </li>
</ul>
<figure id="tbl:converting-values-to-bigints" class="float">
  <table class="framed">
    <style>
      th:nth-child(1), td:nth-child(1) {
        text-align: left;
      }
      th:nth-child(2), td:nth-child(2) {
        text-align: left;
      }
    </style>
    <thead>
      <tr>
        <th><code>x</code></th><th><code>BigInt(x)</code></th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>undefined</code></td><td>Throws <code>TypeError</code></td>
      </tr>
      <tr>
        <td><code>null</code></td><td>Throws <code>TypeError</code></td>
      </tr>
      <tr>
        <td>boolean</td><td><code>false</code> → <code>0n</code>, <code>true</code> → <code>1n</code></td>
      </tr>
      <tr>
        <td>number</td><td>Example: <code>123</code> → <code>123n</code></td>
      </tr>
      <tr>
        <td/><td>Non-integer → throws <code>RangeError</code></td>
      </tr>
      <tr>
        <td>bigint</td><td><code>x</code> (no change)</td>
      </tr>
      <tr>
        <td>string</td><td>Example: <code>'123'</code> → <code>123n</code></td>
      </tr>
      <tr>
        <td/><td>Unparsable → throws <code>SyntaxError</code></td>
      </tr>
      <tr>
        <td>symbol</td><td>Throws <code>TypeError</code></td>
      </tr>
      <tr>
        <td>object</td><td>Configurable (e.g. via <code>.valueOf()</code>)</td>
      </tr>
    </tbody>
  </table>
  <figcaption>
    <p><span class="float-label">Table 20.1:</span> Converting values to bigints.</p>
  </figcaption>
</figure>
<h5 id="converting-undefined-and-null"><a class="heading-id-link" href="#converting-undefined-and-null">20.5.1.1 Converting <code>undefined</code> and <code>null</code></a></h5>
<p>A <code>TypeError</code> is thrown if <code>x</code> is either <code>undefined</code> or <code>null</code>:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">BigInt</span>(<span class="hljs-literal">undefined</span>)</span></code>
<code>TypeError: Cannot convert undefined to a BigInt</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">BigInt</span>(<span class="hljs-literal">null</span>)</span></code>
<code>TypeError: Cannot convert null to a BigInt</code>
</pre>
<h5 id="converting-strings"><a class="heading-id-link" href="#converting-strings">20.5.1.2 Converting strings</a></h5>
<p>If a string does not represent an integer, <code>BigInt()</code> throws a <code>SyntaxError</code> (whereas <code>Number()</code> returns the error value <code>NaN</code>):</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">BigInt</span>(<span class="hljs-string">'abc'</span>)</span></code>
<code>SyntaxError: Cannot convert abc to a BigInt</code>
</pre>
<p>The suffix <code>'n'</code> is not allowed:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">BigInt</span>(<span class="hljs-string">'123n'</span>)</span></code>
<code>SyntaxError: Cannot convert 123n to a BigInt</code>
</pre>
<p>All bases of bigint literals are allowed:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">BigInt</span>(<span class="hljs-string">'123'</span>)</span></code>
<code>123n</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">BigInt</span>(<span class="hljs-string">'0xFF'</span>)</span></code>
<code>255n</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">BigInt</span>(<span class="hljs-string">'0b1101'</span>)</span></code>
<code>13n</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">BigInt</span>(<span class="hljs-string">'0o777'</span>)</span></code>
<code>511n</code>
</pre>
<h5 id="noninteger-numbers-produce-exceptions"><a class="heading-id-link" href="#noninteger-numbers-produce-exceptions">20.5.1.3 Non-integer numbers produce exceptions</a></h5>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">BigInt</span>(<span class="hljs-number">123.45</span>)</span></code>
<code>RangeError: The number 123.45 cannot be converted to a BigInt because</code>
<code>it is not an integer</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">BigInt</span>(<span class="hljs-number">123</span>)</span></code>
<code>123n</code>
</pre>
<h5 id="converting-objects"><a class="heading-id-link" href="#converting-objects">20.5.1.4 Converting objects</a></h5>
<p>How objects are converted to bigints can be configured – for example, by overriding <code>.valueOf()</code>:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">BigInt</span>({<span class="hljs-title function_">valueOf</span>(<span class="hljs-params"/>) {<span class="hljs-keyword">return</span> <span class="hljs-number">123n</span>}})</span></code>
<code>123n</code>
</pre>
<h4 id="bigintprototype-methods"><a class="heading-id-link" href="#bigintprototype-methods">20.5.2 <code>BigInt.prototype.*</code> methods</a></h4>
<p><code>BigInt.prototype</code> holds the methods “inherited” by primitive bigints:</p>
<ul>
  <li>
    <code>BigInt.prototype.toLocaleString(locales?, options?)</code>
  </li>
  <li>
    <code>BigInt.prototype.toString(radix?)</code>
  </li>
  <li>
    <code>BigInt.prototype.valueOf()</code>
  </li>
</ul>
<h4 id="bigint-methods-casting"><a class="heading-id-link" href="#bigint-methods-casting">20.5.3 <code>BigInt.*</code> methods: casting</a></h4>
<ul>
  <li>
    <p><code>BigInt.asIntN(width, theInt)</code><br/>
    Casts <code>theInt</code> to <code>width</code> bits (signed). This influences how the value is represented internally.</p>
  </li>
  <li>
    <p><code>BigInt.asUintN(width, theInt)</code><br/>
    Casts <code>theInt</code> to <code>width</code> bits (unsigned).</p>
  </li>
</ul>
<h5 id="example-using-64bit-integers"><a class="heading-id-link" href="#example-using-64bit-integers">20.5.3.1 Example: using 64-bit integers</a></h5>
<p>Casting allows us to create integer values with a specific number of bits – e.g., if we want to restrict ourselves to 64-bit integers, we always have to cast:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> uint64a = <span class="hljs-title class_">BigInt</span>.<span class="hljs-title function_">asUintN</span>(<span class="hljs-number">64</span>, <span class="hljs-number">12345n</span>);</code>
<code><span class="hljs-keyword">const</span> uint64b = <span class="hljs-title class_">BigInt</span>.<span class="hljs-title function_">asUintN</span>(<span class="hljs-number">64</span>, <span class="hljs-number">67890n</span>);</code>
<code><span class="hljs-keyword">const</span> result = <span class="hljs-title class_">BigInt</span>.<span class="hljs-title function_">asUintN</span>(<span class="hljs-number">64</span>, uint64a * uint64b);</code>
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Implementing the analog of <code>Number.parseInt()</code> for bigints</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/bigints/parse-bigint_test.mjs</code></p>
</div>
<h3 id="coercing-bigints-to-other-primitive-types"><a class="heading-id-link" href="#coercing-bigints-to-other-primitive-types">20.6 Coercing bigints to other primitive types</a></h3>
<p>This table show what happens if we convert bigints to other primitive types:</p>
<table class="framed">
  <style>
    th:nth-child(1), td:nth-child(1) {
      text-align: left;
    }
    th:nth-child(2), td:nth-child(2) {
      text-align: left;
    }
    th:nth-child(3), td:nth-child(3) {
      text-align: left;
    }
  </style>
  <thead>
    <tr>
      <th>Convert to</th><th>Explicit conversion</th><th>Coercion (implicit conversion)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>boolean</td><td><code>Boolean(0n)</code> → <code>false</code></td><td><code>!0n</code> → <code>true</code></td>
    </tr>
    <tr>
      <td/><td><code>Boolean(int)</code> → <code>true</code></td><td><code>!int</code> → <code>false</code></td>
    </tr>
    <tr>
      <td>number</td><td><code>Number(7n)</code> → <code>7</code> (example)</td><td><code>+int</code> → <code>TypeError</code> (1)</td>
    </tr>
    <tr>
      <td>string</td><td><code>String(7n)</code> → <code>'7'</code> (example)</td><td><code>''+7n</code> → <code>'7'</code> (example)</td>
    </tr>
  </tbody>
</table>
<p>Footnote:</p>
<ul>
  <li>
    (1) Unary <code>+</code> is not supported for bigints, because much code relies on it coercing its operand to number.
  </li>
</ul>
<h3 id="typed-array-and-dataview-operations-for-64bit-values"><a class="heading-id-link" href="#typed-array-and-dataview-operations-for-64bit-values">20.7 Typed Array and DataView operations for 64-bit values</a></h3>
<p>Thanks to bigints, Typed Arrays and DataViews can support 64-bit values:</p>
<ul>
  <li>
    Typed Array constructors:
    <ul>
      <li>
        <code>BigInt64Array</code>
      </li>
      <li>
        <code>BigUint64Array</code>
      </li>
    </ul>
  </li>
  <li>
    DataView methods:
    <ul>
      <li>
        <code>DataView.prototype.getBigInt64()</code>
      </li>
      <li>
        <code>DataView.prototype.setBigInt64()</code>
      </li>
      <li>
        <code>DataView.prototype.getBigUint64()</code>
      </li>
      <li>
        <code>DataView.prototype.setBigUint64()</code>
      </li>
    </ul>
  </li>
</ul>
<h3 id="bigints-and-json"><a class="heading-id-link" href="#bigints-and-json">20.8 Bigints and JSON</a></h3>
<p>The JSON standard is fixed and won’t change. The upside is that old JSON parsing code will never be outdated. The downside is that JSON can’t be extended to contain bigints.</p>
<p>Stringifying bigints throws exceptions:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-number">123n</span>)</span></code>
<code>TypeError: Do not know how to serialize a BigInt</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>([<span class="hljs-number">123n</span>])</span></code>
<code>TypeError: Do not know how to serialize a BigInt</code>
</pre>
<h4 id="stringifying-bigints"><a class="heading-id-link" href="#stringifying-bigints">20.8.1 Stringifying bigints</a></h4>
<p>Therefore, our best option is to store bigints in strings:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> bigintPrefix = <span class="hljs-string">'[[bigint]]'</span>;</code>
<code/>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">bigintReplacer</span>(<span class="hljs-params">_key, value</span>) {</code>
<code>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'bigint'</span>) {</code>
<code>    <span class="hljs-keyword">return</span> bigintPrefix + value;</code>
<code>  }</code>
<code>  <span class="hljs-keyword">return</span> value;</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">const</span> data = { <span class="hljs-attr">value</span>: <span class="hljs-number">9007199254740993n</span> };</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data, bigintReplacer),</code>
<code>  <span class="hljs-string">'{"value":"[[bigint]]9007199254740993"}'</span></code>
<code>);</code>
</pre>
<h4 id="parsing-bigints"><a class="heading-id-link" href="#parsing-bigints">20.8.2 Parsing bigints</a></h4>
<p>The following code shows how to parse strings such as the one that we have produced in the previous example.</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">bigintReviver</span>(<span class="hljs-params">_key, value</span>) {</code>
<code>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'string'</span> &amp;&amp; value.<span class="hljs-title function_">startsWith</span>(bigintPrefix)) {</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">BigInt</span>(value.<span class="hljs-title function_">slice</span>(bigintPrefix.<span class="hljs-property">length</span>));</code>
<code>  }</code>
<code>  <span class="hljs-keyword">return</span> value;</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">const</span> str = <span class="hljs-string">'{"value":"[[bigint]]9007199254740993"}'</span>;</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str, bigintReviver),</code>
<code>  { <span class="hljs-attr">value</span>: <span class="hljs-number">9007199254740993n</span> }</code>
<code>);</code>
</pre>
<h3 id="faq-bigints"><a class="heading-id-link" href="#faq-bigints">20.9 FAQ: Bigints</a></h3>
<h4 id="how-do-i-decide-when-to-use-numbers-and-when-to-use-bigints"><a class="heading-id-link" href="#how-do-i-decide-when-to-use-numbers-and-when-to-use-bigints">20.9.1 How do I decide when to use numbers and when to use bigints?</a></h4>
<p>My recommendations:</p>
<ul>
  <li>
    Use numbers for up to 53 bits and for Array indices. Rationale: They already appear everywhere and are handled efficiently by most engines (especially if they fit into 31 bits). Appearances include:
    <ul>
      <li>
        <code>Array.prototype.forEach()</code>
      </li>
      <li>
        <code>Array.prototype.entries()</code>
      </li>
    </ul>
  </li>
  <li>
    Use bigints for large numeric values: If your fraction-less values don’t fit into 53 bits, you have no choice but to move to bigints.
  </li>
</ul>
<p>All existing web APIs return and accept only numbers and will only upgrade to bigint on a case-by-case basis.</p>
<h4 id="why-not-just-increase-the-precision-of-numbers-in-the-same-manner-as-is-done-for-bigints"><a class="heading-id-link" href="#why-not-just-increase-the-precision-of-numbers-in-the-same-manner-as-is-done-for-bigints">20.9.2 Why not just increase the precision of numbers in the same manner as is done for bigints?</a></h4>
<p>One could conceivably split <code>number</code> into <code>integer</code> and <code>double</code>, but that would add many new complexities to the language (several integer-only operators etc.). I’ve sketched the consequences in <a href="https://gist.github.com/rauschma/13d48d1c49615ce2396ce7c9e45d4cd1">a Gist</a>.</p>
<hr/>
<p><strong>Acknowledgements:</strong></p>
<ul>
  <li>
    Thanks to Daniel Ehrenberg for reviewing an earlier version of this content.
  </li>
  <li>
    Thanks to Dan Callahan for reviewing an earlier version of this content.
  </li>
</ul>

    
      
</body>
</html>