- en: 24 Symbols ES6
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 24 符号 ES6
- en: 原文：[https://exploringjs.com/js/book/ch_symbols.html](https://exploringjs.com/js/book/ch_symbols.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/js/book/ch_symbols.html](https://exploringjs.com/js/book/ch_symbols.html)
- en: '[24.1 Symbols are primitive values with unique identities](#nature-of-symbols)'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[24.1 符号是具有唯一标识的原始值](#nature-of-symbols)'
- en: '[24.1.1 Symbols are primitive values](#symbols-are-primitive-values)'
  id: totrans-3
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[24.1.1 符号是原始值](#symbols-are-primitive-values)'
- en: '[24.1.2 Symbols have unique identities and are not compared by value](#symbols-have-unique-identities-and-are-not-compared-by-value)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[24.1.2 符号具有唯一标识且不按值比较](#symbols-have-unique-identities-and-are-not-compared-by-value)'
- en: '[24.2 The descriptions of symbols](#symbol-descriptions)'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[24.2 符号的描述](#symbol-descriptions)'
- en: '[24.3 Use cases for symbols](#use-cases-for-symbols)'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[24.3 符号的用途](#use-cases-for-symbols)'
- en: '[24.3.1 Symbols as values for constants](#symbols-as-values-for-constants)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[24.3.1 符号作为常数的值](#symbols-as-values-for-constants)'
- en: '[24.3.2 Symbols as unique property keys](#symbols-as-unique-property-keys)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[24.3.2 符号作为唯一属性键](#symbols-as-unique-property-keys)'
- en: '[24.4 Publicly known symbols](#publicly-known-symbols)'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[24.4 公开已知的符号](#publicly-known-symbols)'
- en: '[24.5 Converting symbols](#converting-symbols)'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[24.5 转换符号](#converting-symbols)'
- en: '[24.1 Symbols are primitive values with unique identities](#nature-of-symbols)'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[24.1 符号是具有唯一标识的原始值](#nature-of-symbols)'
- en: 'Symbols are primitive values that are created via the factory function `Symbol()`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 符号是通过`Symbol()`工厂函数创建的原始值：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The parameter is optional and provides a description, which is mainly useful
    for debugging.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是可选的，提供描述，这对于调试非常有用。
- en: '[24.1.1 Symbols are primitive values](#symbols-are-primitive-values)'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[24.1.1 符号是原始值](#symbols-are-primitive-values)'
- en: 'Symbols are primitive values:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 符号是原始值：
- en: 'They have to be categorized via `typeof`:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们必须通过`typeof`进行分类：
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'They can be property keys in objects:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以作为对象的属性键：
- en: '[PRE2]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[24.1.2 Symbols have unique identities and are not compared by value](#symbols-have-unique-identities-and-are-not-compared-by-value)'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[24.1.2 符号具有唯一标识且不按值比较](#symbols-have-unique-identities-and-are-not-compared-by-value)'
- en: 'Even though symbols are primitives, they are also like objects in that values
    created by `Symbol()` have unique identities and are not compared by value:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管符号是原始值，但它们也像对象一样，由`Symbol()`创建的值具有唯一标识，并且不是通过值来比较的：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Prior to symbols, an object was the best choice if we needed a values that
    had a unique identity (was only equal to itself):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在符号出现之前，如果需要一个具有唯一标识（仅等于自身）的值，对象是最好的选择：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[24.2 The descriptions of symbols](#symbol-descriptions)'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[24.2 符号的描述](#symbol-descriptions)'
- en: 'The parameter we pass to the symbol factory function provides a description
    for the created symbol:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给符号工厂函数的参数为创建的符号提供描述：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The description can be accessed in two ways.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 描述可以通过两种方式访问。
- en: 'First, it is part of the string returned by `.toString()`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它是`.toString()`返回的字符串的一部分：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Second, since ES2019, we can retrieve the description via the property `.description`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，自ES2019以来，我们可以通过属性`.description`检索描述：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[24.3 Use cases for symbols](#use-cases-for-symbols)'
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[24.3 符号的用途](#use-cases-for-symbols)'
- en: 'The main use cases for symbols, are:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 符号的主要用途包括：
- en: Values for constants
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常数的值
- en: Unique property keys
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一属性键
- en: '[24.3.1 Symbols as values for constants](#symbols-as-values-for-constants)'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[24.3.1 符号作为常数的值](#symbols-as-values-for-constants)'
- en: 'Let’s assume you want to create constants representing the colors red, orange,
    yellow, green, blue, and violet. One simple way of doing so would be to use strings:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想创建代表红色、橙色、黄色、绿色、蓝色和紫色的常量。一个简单的方法是使用字符串：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On the plus side, logging that constant produces helpful output. On the minus
    side, there is a risk of mistaking an unrelated value for a color because two
    strings with the same content are considered equal:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 优点是，记录该常量会产生有用的输出。缺点是，有误将无关的值误认为是颜色的风险，因为内容相同的两个字符串被认为是相等的：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can fix that problem via symbols:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过符号解决这个问题：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s use symbol-valued constants to implement a function:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用符号值常数来实现一个函数：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[24.3.2 Symbols as unique property keys](#symbols-as-unique-property-keys)'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[24.3.2 符号作为唯一属性键](#symbols-as-unique-property-keys)'
- en: 'The keys of properties (fields) in objects are used at two levels:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对象中属性（字段）的键在两个级别上使用：
- en: 'The program operates at a *base level*. The keys at that level reflect the
    *problem domain* – the area in which a program solves a problem – for example:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序在*基本级别*上运行。该级别的键反映了*问题域*——程序解决问题的领域——例如：
- en: If a program manages employees, the property keys may be about job titles, salary
    categories, department IDs, etc.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个程序管理员工，属性键可能涉及职位名称、薪资类别、部门 ID 等。
- en: If the program is a chess app, the property keys may be about chess pieces,
    chess boards, player colors, etc.
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果程序是一个棋盘游戏应用，属性键可能涉及棋子、棋盘、玩家颜色等。
- en: 'ECMAScript and many libraries operate at a *meta-level*. They manage data and
    provide services that are not part of the problem domain. – for example:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 和许多库在元级别上运行。它们管理数据并提供不属于问题域的服务。例如：
- en: 'The standard method `.toString()` is used by ECMAScript when creating a string
    representation of an object (line A):'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 ECMAScript 创建对象的字符串表示时，会使用标准方法 `.toString()`（行 A）：
- en: '[PRE12]'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`.x` and `.y` are base-level properties – they are used to solve the problem
    of computing with points. `.toString()` is a meta-level property – it doesn’t
    have anything to do with the problem domain.'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`.x` 和 `.y` 是基础级别的属性——它们用于解决使用点进行计算的问题。`.toString()` 是元级别的属性——它与问题域无关。'
- en: The standard ECMAScript method `.toJSON()` can be used to customize how an object
    is converted to
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准 ECMAScript 方法 `.toJSON()` 可以用来自定义对象转换为其他形式的方式。
- en: '[PRE13]'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`.x` and `.y` are base-level properties, `.toJSON()` is a meta-level property.'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`.x` 和 `.y` 是基础级别的属性，`.toJSON()` 是元级别的属性。'
- en: 'The base level and the meta-level of a program must be independent: Base-level
    property keys should not be in conflict with meta-level property keys.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的基础级别和元级别必须是独立的：基础级别的属性键不应与元级别的属性键冲突。
- en: 'If we use names (strings) as property keys, we are facing two challenges:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用名称（字符串）作为属性键，我们将面临两个挑战：
- en: When a language is first created, it can use any meta-level names it wants.
    Base-level code is forced to avoid those names. Later, however, when much base-level
    code already exists, meta-level names can’t be chosen freely anymore.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一种语言最初被创建时，它可以使用它想要的任何元级别名称。基础级别代码被迫避免这些名称。然而，当大量基础级别代码已经存在时，元级别名称不能再自由选择。
- en: 'We could introduce naming rules to separate base level and meta-level. For
    example, Python brackets meta-level names with two underscores: `__init__`, `__iter__`,
    `__hash__`, etc. However, the meta-level names of the language and the meta-level
    names of libraries would still exist in the same namespace and can clash.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以引入命名规则来区分基础级别和元级别。例如，Python 使用两个下划线括起来元级别名称：`__init__`、`__iter__`、`__hash__`
    等。然而，语言和库的元级别名称仍然存在于同一个命名空间中，可能会发生冲突。
- en: 'These are two examples of where the latter was an issue for JavaScript:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个例子说明了后者对 JavaScript 产生的问题：
- en: In May 2018, the Array method `.flatten()` had to be renamed to `.flat()` because
    the former name was already used by libraries ([source](https://github.com/tc39/proposal-flatMap/commit/093eacc7fe0906e70f7626bf6c7d6e9dfc53cce9)).
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2018 年 5 月，Array 方法 `.flatten()` 必须更名为 `.flat()`，因为之前的名称已被库使用（[来源](https://github.com/tc39/proposal-flatMap/commit/093eacc7fe0906e70f7626bf6c7d6e9dfc53cce9))。
- en: In November 2020, the Array method `.item()` had to be renamed to `.at()` because
    the former name was already used by a library ([source](https://github.com/tc39/proposal-relative-indexing-method#web-incompatibility-history)).
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2020 年 11 月，Array 方法 `.item()` 必须更名为 `.at()`，因为之前的名称已被库使用（[来源](https://github.com/tc39/proposal-relative-indexing-method#web-incompatibility-history))。
- en: 'Symbols, used as property keys, help us here: Each symbol is unique and a symbol
    key never clashes with any other string or symbol key.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 作为属性键使用的符号在这里很有帮助：每个符号都是唯一的，符号键永远不会与任何其他字符串或符号键冲突。
- en: '[24.3.2.1 Example: a library with a meta-level method](#example-a-library-with-a-metalevel-method)'
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[24.3.2.1 示例：具有元级别方法的库](#example-a-library-with-a-metalevel-method)'
- en: 'As an example, let’s assume we are writing a library that treats objects differently
    if they implement a special method. This is what defining a property key for such
    a method and implementing it for an object would look like:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们正在编写一个库，该库根据对象是否实现特殊方法以不同的方式处理对象。定义此类方法的属性键并为其对象实现它的样子如下：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The square brackets in line A enable us to specify that the method must have
    the key `specialMethod`. More details are explained in [“Computed keys in object
    literals” (§30.9.2)](ch_objects.html#object-literals-computed-keys).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 行 A 中的方括号使我们能够指定该方法必须具有键 `specialMethod`。更多细节请参阅[“对象字面量中的计算键”（§30.9.2）](ch_objects.html#object-literals-computed-keys)。
- en: '[24.4 Publicly known symbols](#publicly-known-symbols)'
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[24.4 公共符号](#publicly-known-symbols)'
- en: 'Symbols that play special roles within ECMAScript are called *publicly known
    symbols*. Examples include:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ECMAScript 中扮演特殊角色的符号被称为*公开已知符号*。例如包括：
- en: '`Symbol.iterator`: makes an object *iterable*. It’s the key of a method that
    returns an iterator. For more information on this topic, see [“Synchronous iteration
    ^(ES6)” (§32)](ch_sync-iteration.html#ch_sync-iteration).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.iterator`: 使一个对象可迭代。它是返回迭代器的方法的键。有关此主题的更多信息，请参阅[“同步迭代（ES6）”（§32）](ch_sync-iteration.html#ch_sync-iteration)。'
- en: '`Symbol.hasInstance`: customizes how `instanceof` works. If an object implements
    a method with that key, it can be used on the right-hand side of that operator.
    For example:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.hasInstance`: 自定义 `instanceof` 的工作方式。如果一个对象实现了具有该键的方法，则可以在该运算符的右侧使用它。例如：'
- en: '[PRE15]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`Symbol.toStringTag`: influences the default `.toString()` method.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.toStringTag`: 影响默认的 `.toString()` 方法。'
- en: '[PRE16]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note: It’s usually better to override `.toString()`.'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：通常最好重写 `.toString()`。
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercises:
    Publicly known symbols**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“练习”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：公开已知符号**'
- en: '`Symbol.toStringTag`: `exercises/symbols/to_string_tag_test.mjs`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.toStringTag`: `exercises/symbols/to_string_tag_test.mjs`'
- en: '`Symbol.hasInstance`: `exercises/symbols/has_instance_test.mjs`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.hasInstance`: `exercises/symbols/has_instance_test.mjs`'
- en: '[24.5 Converting symbols](#converting-symbols)'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[24.5 符号转换](#converting-symbols)'
- en: What happens if we convert a symbol `sym` to another primitive type? [Table
    24.1](#tbl:converting-to-symbol) has the answers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将符号 `sym` 转换为其他原始类型会发生什么？[表 24.1](#tbl:converting-to-symbol) 中有答案。
- en: '| Convert to | Explicit conversion | Coercion (implicit conv.) |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 转换为 | 显式转换 | 强制转换（隐式转换） |'
- en: '| --- | --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| boolean | `Boolean(sym)` → OK | `!sym` → OK |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 布尔值 | `Boolean(sym)` → 正确 | `!sym` → 正确 |'
- en: '| number | `Number(sym)` → `TypeError` | `sym*2` → `TypeError` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 数字 | `Number(sym)` → `TypeError` | `sym*2` → `TypeError` |'
- en: '| string | `String(sym)` → OK | `''''+sym` → `TypeError` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | `String(sym)` → 正确 | `''''+sym` → `TypeError` |'
- en: '|  | `sym.toString()` → OK | `` `${sym}` `` → `TypeError` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '|  | `sym.toString()` → 正确 | `` `${sym}` `` → `TypeError` |'
- en: 'Table 24.1: The results of converting symbols to other primitive types.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 表 24.1：将符号转换为其他原始类型的结果。
- en: 'One key pitfall with symbols is how often exceptions are thrown when converting
    them to something else. What is the thinking behind that? First, conversion to
    number never makes sense and should be warned about. Second, converting a symbol
    to a string is indeed useful for diagnostic output. But it also makes sense to
    warn about accidentally turning a symbol into a string (which is a different kind
    of property key):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 符号的一个关键陷阱是转换它们时抛出异常的频率。背后的想法是什么？首先，转换为数字永远没有意义，应该警告。其次，将符号转换为字符串确实对诊断输出很有用。但同时也应该警告意外地将符号转换为字符串（这是一种不同类型的属性键）：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The downside is that the exceptions make working with symbols more complicated.
    You have to explicitly convert symbols when assembling strings via the plus operator:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是异常使得使用符号变得更加复杂。您必须显式转换符号，当通过加号运算符组装字符串时：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
