["```js\ninterface Iterable<T> {\n [Symbol.iterator]() : Iterator<T>;\n}\n `abstract class Iterator<T> {`\n `abstract next() : IteratorResult<T>;`\n`}`\n `` `interface IteratorResult<T> {`  `value: T;`  `done: boolean;` `}` `` \n```", "```js```", "````js````", "```js```", "``` ```", "```````js```````", "````` The interfaces are used as follows:    *   We ask an `Iterable` for an iterator via the method whose key is `Symbol.iterator`. *   An iterator extends the abstract class `Iterator` and returns the iterated values via its method `.next()`.     *   Note: Before ECMAScript 2025, `Iterator` was simply an interface. No globally accessible class `Iterator` existed. *   The values are not returned directly, but wrapped in objects with two properties:     *   `.value` is the iterated value.     *   `.done` indicates if the end of the iteration has been reached yet. It is `true` after the last iterated value and `false` beforehand.    ### [32.3 Iterating over data](#iterating-over-data)    #### [32.3.1 Manually iterating over data](#manually-iterating-over-data)    This is an example of using the iteration protocol:    ```js const iterable = ['a', 'b'];  `// The iterable is a factory for iterators:` `const iterator = iterable[Symbol.iterator]();`  `` `// Call .next() until .done is true:` `assert.deepEqual(`  `iterator.next(), { value: 'a', done: false }` `);` `assert.deepEqual(`  `iterator.next(), { value: 'b', done: false }` `);` `assert.deepEqual(`  `iterator.next(), { value: undefined, done: true }` `);` ``  ```   ```js`````", "```````js```` ```js```````", "```````js``` #### [32.3.2 Using `while` to iterate manually](#using-while-to-iterate-manually)    The following code demonstrates how to use a `while` loop to iterate over an iterable:    ``` function logAll(iterable) {  const iterator = iterable[Symbol.iterator]();  while (true) {  const {value, done} = iterator.next();  if (done) break;  console.log(value);  } } logAll(['a', 'b']);  ```js    Output:    ``` a b  ```js    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Using sync iteration manually**    `exercises/sync-iteration/sync_iteration_manually_exrc.mjs`    #### [32.3.3 Retrieving an iterator via `Iterator.from()` ^(ES2024)](#retrieving-an-iterator-via-iteratorfrom-es2024)    The built-in static method `Iterator.from()` provides us with a more elegant way of retrieving iterators:    ``` > const iterable = ['a', 'b']; > iterable[Symbol.iterator]() instanceof Iterator true > Iterator.from(iterable) instanceof Iterator true  ```js    #### [32.3.4 Iterating via iteration-based language constructs](#iterating-via-iterationbased-language-constructs)    We have seen how to use the iteration protocol manually and it is relatively cumbersome. But the protocol is not meant to be used directly – it is meant to be used via higher-level language constructs built on top of it. We’ll notice that we never see iterators when we do so. They are only used internally.    ##### [32.3.4.1 Iterating over Arrays](#iterating-over-arrays)    The most important iteration-based language construct is the `for-of` loop:    ``` const iterable = ['hello', 'beautiful', 'world']; for (const x of iterable) {  console.log(x); }  ```js    Output:    ``` hello beautiful world  ```js    Another iteration-based construct is spreading into Array literals:    ``` assert.deepEqual(  ['BEFORE', ...iterable, 'AFTER'],  ['BEFORE', 'hello', 'beautiful', 'world', 'AFTER'] );  ```js    [Destructuring](ch_destructuring.html#ch_destructuring) via Array patterns also uses iteration under the hood:    ``` const [first, second] = iterable; assert.equal(first, 'hello'); assert.equal(second, 'beautiful');  ```js    ##### [32.3.4.2 Iterating over Sets](#iterating-over-sets)    Sets are also iterable. Note that the iterating code is the same: It sees neither Arrays nor Sets, only iterables.    ``` const iterable = ['hello', 'beautiful', 'world'];  `for (const x of iterable) {`  `console.log(x);` `}`  ```js `assert.deepEqual(`  `['BEFORE', ...iterable, 'AFTER'],`  `['BEFORE', 'hello', 'beautiful', 'world', 'AFTER']` `);`  `` `const [first, second] = iterable;` `assert.equal(first, 'hello');` `assert.equal(second, 'beautiful');` `` ```  ```js   ``````js```````", "`````` ```js``````", "```````js` #### [32.3.5 Converting iterables to Arrays: `[...i]` and `Array.from(i)`](#converting-iterables-to-arrays-i-and-arrayfromi)    These are ways of converting iterables to Arrays:    ``` const iterable = new Set().add('a').add('b').add('c'); assert.deepEqual(  [...iterable],  ['a', 'b', 'c'] ); assert.deepEqual(  Array.from(iterable),  ['a', 'b', 'c'] );  ```js    I tend to prefer `Array.from()` because it’s more self-descriptive.    More information: [“Converting iterables, iterators and Array-like values to Arrays” (§34.6)](ch_arrays.html#converting-to-array)    We can also create an iterator and use an iterator method to create an Array. Iterator methods are explained later.    ``` assert.deepEqual(  Iterator.from(iterable).toArray(),  ['a', 'b', 'c'] );  ```js    ### [32.4 Processing iterables via generators](#processing-iterables-via-generators)    Synchronous generator functions and methods expose their yielded values via iterators (that are also iterable) that they return:    ``` /** Synchronous generator function */ function* createSyncIterable() {  yield 'a';  yield 'b';  yield 'c'; }  ```js    Generators produce iterables, but they can also consume them. That makes them a versatile tool for transforming iterables:    ``` function* map(iterable, callback) {  for (const x of iterable) {  yield callback(x);  } } assert.deepEqual(  Array.from(  map([1, 2, 3, 4], x => x ** 2)  ),  [1, 4, 9, 16] );  `function* filter(iterable, callback) {`  `for (const x of iterable) {`  `if (callback(x)) {`  `yield x;`  `}`  `}` `}` `assert.deepEqual(`  `Array.from(`  `filter([1, 2, 3, 4], x => (x % 2) === 0`  `)),`  `[2, 4]` `);`  ```js   ``````js```````", "```` More information: [“Synchronous generators ^(ES6) (advanced)” (§33)](ch_sync-generators.html#ch_sync-generators)    ### [32.5 The inheritance of the iteration API (advanced)](#the-inheritance-of-the-iteration-api-advanced)    All of the iterators created by JavaScript’s standard library have a common prototype which the ECMAScript specification calls [`%IteratorPrototype%`](https://tc39.es/ecma262/#sec-%iteratorprototype%-object) and uses internally. We can access it from JavaScript via `Iterator.prototype`.    #### [32.5.1 Array iterators](#array-iterators)    We create an Array iterator like this:    ```js const arrayIterator = [][Symbol.iterator]();  ```    This object has a prototype with two properties. Let’s call it `ArrayIteratorPrototype`:    ```js const ArrayIteratorPrototype = Object.getPrototypeOf(arrayIterator); assert.deepEqual(  Reflect.ownKeys(ArrayIteratorPrototype),  [ 'next', Symbol.toStringTag ] ); assert.equal(  ArrayIteratorPrototype[Symbol.toStringTag],  'Array Iterator' );  ```    The prototype of `ArrayIteratorPrototype` is `%IteratorPrototype%`. This object has a method whose key is `Symbol.iterator`. Therefore, all built-in iterators are iterable.    ```js const IteratorPrototype = Object.getPrototypeOf(ArrayIteratorPrototype); assert.equal(  IteratorPrototype, Iterator.prototype ); assert.equal(  Object.hasOwn(Iterator.prototype, Symbol.iterator),  true ); assert.equal(  typeof Iterator.prototype[Symbol.iterator],  'function' );  ```    The prototype of `Iterator.prototype` is `Object.prototype`.    ```js assert.equal(  Object.getPrototypeOf(Iterator.prototype) === Object.prototype,  true );  ```    [Figure 32.3](#fig:inheritance-array-iterator) contains a diagram for this chain of prototypes.    ![](../Images/7114dc60cff41ea48eb99d0bb278db66.png)      Figure 32.3: A chain of prototypes (from bottom to top):    *   First the result of `[][Symbol.iterator]()` (an instance of `%ArrayIterator%`) *   Then `%ArrayIteratorPrototype%` *   Then `%IteratorPrototype%` *   Finally `Object.prototype`      #### [32.5.2 Generator objects](#generator-objects)    Roughly, a generator object is an iterator for the values yielded by a generator function `genFunc()`. We create it by calling `genFunc()`:    ```js function* genFunc() {  yield 'a';  yield 'b'; } const genObj = genFunc();  ```    A generator object is an iterator:    ```js assert.deepEqual(  genObj.next(),  { value: 'a', done: false } ); assert.equal(  genObj instanceof Iterator,  true ); assert.equal(  Iterator.prototype.isPrototypeOf(genObj),  true );  ```    ### [32.6 Iterable iterators](#iterable-iterators)    #### [32.6.1 Why are the built-in iterators iterable?](#why-are-the-builtin-iterators-iterable)    As we have seen, all built-in iterators are iterable:    ```js // Array iterator const arrayIterator = ['a', 'b'].values(); assert.equal(  // arrayIterator is a built-in iterator  arrayIterator instanceof Iterator, true ); assert.equal(  // arrayIterator is iterable  Symbol.iterator in arrayIterator, true );  `// Generator object` `function* gen() { yield 'hello' }` `const genObj = gen();` `assert.equal(`  `genObj instanceof Iterator, true` `);` `assert.equal(`  `Symbol.iterator in genObj, true` `);`  ``` ``// Iterator returned by `Iterator` method`` `const iter = Iterator.from([1, 2]).map(x => x * 2);` `assert.equal(`  `iter instanceof Iterator, true` `);` `assert.equal(`  `Symbol.iterator in iter, true` `);` ```js  ```   ```js````", "```js```", "``` ```", "```````js````` That has the benefit of us being able to iterate over the iterator’s values – e.g., via `for-of` and `Array.from()`.    Another benefit is that generators become more versatile. On one hand, we can use them to implement iterators:    ```js class MyIterable {  /** This method must return an iterator */  * [Symbol.iterator]() {  yield 'good';  yield 'morning';  } } assert.deepEqual(  Array.from(new MyIterable()),  ['good', 'morning'] );  ```    On the other hand, we can use them to implement iterables:    ```js function* createIterable() {  yield 'a';  yield 'b'; } assert.deepEqual(  Array.from(createIterable()),  ['good', 'morning'] );  ```    #### [32.6.2 An iterator returns itself when asked for an iterator](#an-iterator-returns-itself-when-asked-for-an-iterator)    If an iterator is iterable: What are the iterators it produces? It simply returns itself when asked for an iterator:    ```js const iterator = Iterator.from(['a', 'b']) assert.equal(  iterator[Symbol.iterator](),  iterator );  ```    #### [32.6.3 Iteration quirk: two kinds of iterables](#one-time-iterable-vs-many-times-iterable)    Alas, iterable iterators mean that there are two kinds of iterables:    1.  An iterable iterator is a *one-time iterable*: It always returns the same iterator (itself) when `[Symbol.iterator]()` is called (iteration continues).           2.  A normal iterable (an Array, a Set, etc.) is a *many-times iterable*: It always returns a fresh iterator (iteration restarts).              With a one-time iterable, each time we iterate, we remove more elements, until, eventually, no more are left:    ```js const oneTime = ['a', 'b', 'c'].values(); for (const x of oneTime) {  assert.equal(  x, 'a'  );  break; } assert.deepEqual(  Array.from(oneTime),  ['b', 'c'] ); assert.deepEqual(  Array.from(oneTime),  [] );  ```    With a many-times iterable, each iteration starts fresh:    ```js const manyTimes = ['a', 'b', 'c']; for (const x of manyTimes) {  assert.equal(  x, 'a'  );  break; } assert.deepEqual(  Array.from(manyTimes),  ['a', 'b', 'c'] ); assert.deepEqual(  Array.from(manyTimes),  ['a', 'b', 'c'] );  ```    The following code is another demonstration of the difference:    ```js const oneTime = ['a', 'b', 'c'].values(); assert.deepEqual(  [...oneTime, ...oneTime, ...oneTime],  ['a', 'b', 'c'] );  `const manyTimes = ['a', 'b', 'c'];` `assert.deepEqual(`  `[...manyTimes, ...manyTimes, ...manyTimes],`  `['a','b','c', 'a','b','c', 'a','b','c']` `);`  ```   ```js```````", "```` ### [32.7 Class `Iterator` and iterator helper methods ^(ES2025)](#class-iterator)    We have already seen that `%IteratorPrototype%` is the prototype of all built-in iterators. ECMAScript 2025 introduces a class `Iterator`:    *   `Iterator.prototype` refers to `%IteratorPrototype%`. *   `%IteratorPrototype%.constructor` refers to `Iterator`.    The class provides the following functionality:    *   `Iterator.from(iterable)` returns an iterator for `iterable`. We’ll explore it in detail [later](#Iterator.from). *   `Iterator.prototype` contains various helper methods that are inherited by iterators.    #### [32.7.1 `Iterator.prototype.*` methods](#iteratorprototype-methods)    The following iterator helper methods work like the Array methods with the same names:    *   Methods that return iterators:     *   `iterator.filter(filterFn)`     *   `iterator.map(mapFn)`     *   `iterator.flatMap(mapFn)` *   Methods that return booleans:     *   `iterator.some(fn)`     *   `iterator.every(fn)` *   Methods that return other values:     *   `iterator.find(fn)`     *   `iterator.reduce(reducer, initialValue?)` *   Methods that return no values:     *   `iterator.forEach(fn)`    These helper methods are unique to iterators:    *   `iterator.drop(limit)`     *   Returns an iterator without the first `limit` elements of `iterator`. *   `iterator.take(limit)`     *   Returns an iterator with the first `limit` elements of `iterator`. *   `iterator.toArray()`     *   Collects all remaining elements of `iterator` in an Array and returns it.    For a brief description of each method, see [“Quick reference: class `Iterator` ^(ES2025)” (§32.10)](#quickref-iterator). These are examples of the methods in action:    ```js assert.deepEqual(  ['a', 'b', 'c'].values().map(x => `=${x}=`).toArray(),  ['=a=', '=b=', '=c='] ); assert.deepEqual(  ['a', 'b', 'c'].values().drop(1).toArray(),  ['b', 'c'] ); assert.deepEqual(  ['a', 'b', 'c'].values().take(2).toArray(),  ['a', 'b'] );  ```    The Array method `arr.values()` returns an iterator over the elements of `arr`.    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercises: Working with iterators**    *   Implementing `.at()` for iterators: `exercises/sync-iteration/iterator-at_test.mjs` *   Implementing `.findIndex()` for iterators: `exercises/sync-iteration/iterator-find-index_test.mjs` *   Implementing `.slice()` for iterators: `exercises/sync-iteration/slice-iterator_test.mjs` *   Adding indices to iterator elements: `exercises/sync-iteration/add-index-to-iterator_test.mjs` *   Using `iterator.reduce()` to compute the length of an iterator: `exercises/sync-iteration/iterator-length_test.mjs`    #### [32.7.2 The benefits of iterator helper methods](#benefits-of-iterator-helper-methods)    ##### [32.7.2.1 Benefit: more operations for data structures that support iteration](#benefit-more-operations-for-data-structures-that-support-iteration)    With iterator helper methods, any data structure that supports iteration automatically gains functionality.    For example, Sets don’t support the operations `filter` and `map`, but we can get them via iterator methods:    ```js assert.deepEqual(  new Set( // (A)  new Set([-5, 2, 6, -3]).values().filter(x => x >= 0)  ),  new Set([2, 6]) ); assert.deepEqual(  new Set( // (B)  new Set([-5, 2, 6, -3]).values().map(x => x / 2)  ),  new Set([-2.5, 1, 3, -1.5]) );  ```    Note that `new Set()` accepts iterables and therefore iterable iterators (line A and line B).    DOM collections also don’t have the methods `.filter()` and `.map()`:    ```js const domCollection = document.querySelectorAll('a');  `// Alas, the collection doesn’t have a method .map()` `assert.equal('map' in domCollection, false);`  `` `// Solution: use an iterator` `assert.deepEqual(`  `domCollection.values().map(x => x.href).toArray(),`  `['https://2ality.com', 'https://exploringjs.com']` `);` ``  ```   ```js````", "```js```", "``````js``````", "```js function quoteNonEmptyLinesArray(str) {  return str  .split(/(?<=\\r?\\n)/) // (A)  .filter(line => line.trim().length > 0) // (B)  .map(line => '> ' + line) // (C)  ; }  ```", "```js function quoteNonEmptyLinesIter(str) {  return splitLinesIter(str) // (A)  .filter(line => line.trim().length > 0) // (B)  .map(line => '> ' + line) // (C)  ; }  `function* splitLinesIter(str) {`  `let prevIndex = 0;`  `while (true) {`  `const eolIndex = str.indexOf('\\n', prevIndex);`  `if (eolIndex < 0) break;`  `// Including EOL`  `const line = str.slice(prevIndex, eolIndex + 1);`  `yield line;`  `prevIndex = eolIndex + 1;`  `}`  `if (prevIndex < str.length) {`  `yield str.slice(prevIndex);`  `}` `}`  ```", "```js```", "````js` Example of using `quoteNonEmptyLinesIter()`:    ``` assert.deepEqual(  Array.from(quoteNonEmptyLinesIter('have\\n\\na nice\\n\\nday')),  [  '> have\\n',  '> a nice\\n',  '> day',  ] );  ```js    Note that the empty lines between the three lines of text were filtered out.    In addition to no intermediate Arrays being created, iterators also give us incremental processing:    ``` > const iter = quoteNonEmptyLinesIter('have\\n\\na nice\\n\\nday'); > iter.next() { value: '> have\\n', done: false } > iter.next() { value: '> a nice\\n', done: false } > iter.next() { value: '> day', done: false } > iter.next() { value: undefined, done: true }  ```js    In contrast, `quoteNonEmptyLinesArray()` first splits all lines, then filters all lines and then maps all lines. Incremental processing matters when dealing with a large amount of data. Iterator helper methods complement generators as tools for incremental processing.    #### [32.7.3 `Iterator.from()`: creating API iterators](#Iterator.from)    All built-in iterables automatically support the new API because their iterators already have `Iterator.prototype` as a prototype (and are therefore instances of `Iterator`). However, that’s not the case for all iterables in libraries and user code.    Terminology:    *   Entities that support the `Iterator` API: *API iterators* and *API iterables* *   Entities that don’t: *legacy iterators* and *legacy iterables*    How does `Iterator.from(obj)` work?    *   If `obj` is iterable, then it creates an iterator by calling `obj[Symbol.iterator]()`.     *   If the new iterator is an instance of `Iterator`, it is returned as is.     *   Otherwise, it is wrapped so that it becomes an instance of `Iterator`. *   If `obj` is an iterator, `Iterator.from()` ensures that it is an instance of `Iterator` and returns it.    In the following example, we use `Iterator.from()` to convert a legacy iterator to an API iterator:    ``` // Not an instance of `Iterator` const legacyIterator = {  next() {  // Infinite iterator (never done)  return { done: false, value: '#' };  } }; assert.equal(  Iterator.from(legacyIterator) instanceof Iterator,  true ); assert.deepEqual(  Iterator.from(legacyIterator).take(3).toArray(),  ['#', '#', '#'] );  ```js    #### [32.7.4 Iterator methods change how we use iteration](#iterator-methods-change-how-we-use-iteration)    The iterator methods change how we use iteration:    *   Previously, we never saw iterators and always worked with iterables, e.g. via `for-of` or `Array.from()`. *   Now, using iterators is useful, too, and we have to be aware of how to create them.    It’s interesting how our focus shifts with methods such as `Array.prototype.keys()` that return iterable iterators: Before iterator methods, we used the result as an iterable. With iterator methods, we also use them as iterators:    ``` > Array.from(['a', 'b'].keys()) // iterable [ 0, 1 ] > ['a', 'b'].keys().toArray() // iterator [ 0, 1 ]  ```js    For more information, see [“Creating iterators” (§32.10.1)](#creating-iterators).    #### [32.7.5 Upgrading a legacy iterable to the `Iterator` API](#upgrading-a-legacy-iterable-to-the-iterator-api)    This is an example of a legacy iterable:    ``` class ValueIterable {  #values;  #index = 0;  constructor(...values) {  this.#values = values;  }  [Symbol.iterator]() {  return {  // Arrow function so that we can use the outer `this`  next: () => {  if (this.#index >= this.#values.length) {  return {done: true};  }  const value = this.#values[this.#index];  this.#index++;  return {done: false, value};  },  };  } }  `// legacyIterable is an iterable` `const legacyIterable = new ValueIterable('a', 'b', 'c');` `assert.deepEqual(`  `Array.from(new ValueIterable('a', 'b', 'c')),`  `['a', 'b', 'c']` `);`  `` `// But its iterators are not instances of Iterator` `const legacyIterator = legacyIterable[Symbol.iterator]();` `assert.equal(`  `legacyIterator instanceof Iterator, false` `);` ``  ```js   ````", "```` ```js````", "```js class ValueIterable {  // ···  [Symbol.iterator]() {  return {  __proto__: Iterator.prototype,  next: () => {  // ···  },  };  } }  ```", "```js class ValueIterable {  // ···  [Symbol.iterator]() {  return Iterator.from({  next: () => {  // ···  },  });  } }  ```", "```js class ValueIterable {  #values;  #index = 0;  constructor(...values) {  this.#values = values;  }  [Symbol.iterator]() {  const outerThis = this;  // Because ValueIterator is nested, it can access the private fields of  // ValueIterable  class ValueIterator extends Iterator {  next() {  if (outerThis.#index >= outerThis.#values.length) {  return {done: true};  }  const value = outerThis.#values[outerThis.#index];  outerThis.#index++;  return {done: false, value};  }  }  return new ValueIterator();  } }  ```", "```js assert.deepEqual(  Map.groupBy([0, -5, 3, -4, 8, 9], x => Math.sign(x)),  new Map().set(0, [0]).set(-1, [-5,-4]).set(1, [3,8,9]) );  ```", "```js function* generateNumbers() {  yield 2;  yield -7;  yield 4; } assert.deepEqual(  Map.groupBy(generateNumbers(), x => Math.sign(x)),  new Map().set(1, [2,4]).set(-1, [-7]) );  ```", "```js assert.deepEqual(  Object.groupBy([0, -5, 3, -4, 8, 9], x => Math.sign(x)),  {'0': [0], '-1': [-5,-4], '1': [3,8,9], __proto__: null} );  ```", "```js const settled = [  { status: 'rejected', reason: 'Jhon' },  { status: 'fulfilled', value: 'Jane' },  { status: 'fulfilled', value: 'John' },  { status: 'rejected', reason: 'Jaen' },  { status: 'rejected', reason: 'Jnoh' }, ];  ```", "```js const {fulfilled, rejected} = Object.groupBy(settled, x => x.status); // (A)  `// Handle fulfilled results` `assert.deepEqual(`  `fulfilled,`  `[`  `{ status: 'fulfilled', value: 'Jane' },`  `{ status: 'fulfilled', value: 'John' },`  `]` `);`  `` `// Handle rejected results` `assert.deepEqual(`  `rejected,`  `[`  `{ status: 'rejected', reason: 'Jhon' },`  `{ status: 'rejected', reason: 'Jaen' },`  `{ status: 'rejected', reason: 'Jnoh' },`  `]` `);` ``  ```", "```js```", "```js```", "```js const persons = [  { name: 'Louise', country: 'France' },  { name: 'Felix', country: 'Germany' },  { name: 'Ava', country: 'USA' },  { name: 'Léo', country: 'France' },  { name: 'Oliver', country: 'USA' },  { name: 'Leni', country: 'Germany' }, ];  `assert.deepEqual(`  `Map.groupBy(persons, (person) => person.country),`  `new Map([`  `[`  `'France',`  `[`  `{ name: 'Louise', country: 'France' },`  `{ name: 'Léo', country: 'France' },`  `]`  `],`  `[`  `'Germany',`  `[`  `{ name: 'Felix', country: 'Germany' },`  `{ name: 'Leni', country: 'Germany' },`  `]`  `],`  `[`  `'USA',`  `[`  `{ name: 'Ava', country: 'USA' },`  `{ name: 'Oliver', country: 'USA' },`  `]`  `],`  `])` `);`  ```", "```js```", "``` /** Synchronous generator function */ function* createSyncIterable() {  yield 'a';  yield 'b';  yield 'c'; }  `assert.deepEqual(`  `Array.from(createSyncIterable()),`  `['a', 'b', 'c']` `);`  ```", "````` #### [32.9.2 Synchronous iteration: data consumers](#synchronous-iteration-data-consumers)    This section lists constructs that consume data via synchronous iteration.    ##### [32.9.2.1 Language constructs that iterate](#language-constructs-that-iterate)    *   The `for-of` loop:                    ```js     for (const x of iterable) { /*···*/ }          ```           *   Spreading (via `...`) into Array literals and function calls:                    ```js     const arr = ['a', ...iterable, 'z'];     func('a', ...iterable, 'z');          ```           *   Destructuring via an Array pattern:                    ```js     const [x, y] = iterable;          ```           *   `yield*`:                    ```js     function* generatorFunction() {      yield* iterable;     }          ```              ##### [32.9.2.2 Converting iterables to data structures](#converting-iterables-to-data-structures)    *   [`Object.fromEntries()`](ch_objects.html#Object.fromEntries):                    ```js     const obj = Object.fromEntries(iterableOverKeyValuePairs);          ```           *   [`Array.from()`](ch_arrays.html#Array.from):                    ```js     const arr = Array.from(iterable);          ```                    Alternative – [spreading](ch_arrays.html#spreading-into-array-literals):                    ```js     const arr = [...iterable];          ```           *   [`new Map()`](ch_maps.html#ch_maps) and [`new WeakMap()`](ch_weakmaps.html#ch_weakmaps):                    ```js     const m  = new Map(iterableOverKeyValuePairs);     const wm = new WeakMap(iterableOverKeyValuePairs);          ```           *   [`new Set()`](ch_sets.html#ch_sets) and [`new WeakSet()`](ch_weaksets.html#ch_weaksets):                    ```js     const s  = new Set(iterableOverElements);     const ws = new WeakSet(iterableOverElements);          ```              ##### [32.9.2.3 Converting iterables over Promises to Promises](#converting-iterables-over-promises-to-promises)    *   [Promise combinator functions](ch_promises.html#promise-combinators): `Promise.all()` etc.                    ```js     const promise1 = Promise.all(iterableOverPromises);     const promise2 = Promise.race(iterableOverPromises);     const promise3 = Promise.any(iterableOverPromises);     const promise4 = Promise.allSettled(iterableOverPromises);          ```              ##### [32.9.2.4 Grouping an iterable into a Map or an object](#grouping-an-iterable-into-a-map-or-an-object)    *   [“`Map.groupBy(items, computeGroupKey)`”](ch_maps.html#qref-Map.groupBy) *   [“`Object.groupBy(items, computeGroupKey)`”](ch_objects.html#qref-Object.groupBy)    ### [32.10 Quick reference: class `Iterator` ^(ES2025)](#quickref-iterator)    #### [32.10.1 Creating iterators](#creating-iterators)    The methods of class `Iterator` let us process data incrementally. Let’s explore where we can use them.    ##### [32.10.1.1 Getting iterators from iterables](#getting-iterators-from-iterables)    *   `Iterator.from(iterable)` always returns instances of `Iterator` (converting non-instances to instances as needed). *   `iterable[Symbol.iterator]()` returns an iterator:     *   With all built-in data structures, the result is an instance of `Iterator`.     *   With other, older iterable objects, the result may not be an instance of `Iterator`.    ##### [32.10.1.2 Built-in methods that return iterators](#builtin-methods-that-return-iterators)    Arrays, Typed Arrays, Sets and Maps have additional methods that return iterators:    *   Arrays (similarly: Typed Arrays):     *   `Array.prototype.keys()` returns an iterator over numbers.     *   `Array.prototype.values()` returns an iterator.     *   `Array.prototype.entries()` returns an iterator over key-value pairs. The keys are numbers. *   Sets:     *   `Set.prototype.values()` returns an iterator.     *   `Set.prototype.keys()` returns an iterator. Equivalent to `.values()`.     *   `Set.prototype.entries()` returns an iterator over value-value pairs (i.e., both components of the pair are the same value). *   Maps:     *   `Map.prototype.keys()` returns an iterator.     *   `Map.prototype.values()` returns an iterator.     *   `Map.prototype.entries()` returns an iterator over key-value pairs.    The following methods return iterators:    *   `String.prototype.matchAll()` returns an iterator over match objects.    ##### [32.10.1.3 Other sources of iterators](#other-sources-of-iterators)    Generators also return iterators:    ```js function* gen() {}  `assert.equal(`  `gen() instanceof Iterator,`  `true` `);`  ```   ```js` #### [32.10.2 `Iterator.*`](#iterator)    *   `Iterator.from(iterableOrIterator)` returns an iterator that is guaranteed to be an instance of `Iterator`. If the parameter is a legacy iterable or a legacy iterator, it wraps the result so that it becomes an instance of `Iterator`.    #### [32.10.3 `Iterator.prototype.*`: methods that pass indices to callbacks](#iteratorprototype-methods-that-pass-indices-to-callbacks)    Some of the iterator methods keep a counter for the iterated values and pass it on to their callbacks:    *   `.every()` *   `.filter()` *   `.find()` *   `.flatMap()` *   `.forEach()` *   `.map()` *   `.reduce()` *   `.some()`    #### [32.10.4 `Iterator.prototype.*`: methods that return iterators](#iteratorprototype-methods-that-return-iterators)    *   `Iterator.prototype.drop(limit)` ES2025                    ```     Iterator<T>.prototype.drop(limit: number): Iterator<T>          ```js                    This method returns an iterator that with all values of `iterator`, except for the first `limit` ones. That is, iteration starts when the iteration counter is `limit`.                    ```     assert.deepEqual(      Iterator.from(['a', 'b', 'c', 'd']).drop(1).toArray(),      ['b', 'c', 'd']     );          ```js           *   `Iterator.prototype.filter(filterFn)`     ES2025 | Callback gets counter                    ```     Iterator<T>.prototype.filter(      filterFn: (value: T, counter: number) => boolean     ): Iterator<T>          ```js                    This method returns an iterator whose values are the values of `iterator` for which `filterFn` returns `true`.                    ```     assert.deepEqual(      Iterator.from(['a', 'b', 'c', 'd']).filter(x => x <= 'b').toArray(),      ['a', 'b']     );          ```js           *   `Iterator.prototype.flatMap(mapFn)`     ES2025 | Callback gets counter                    ```     Iterator<T>.prototype.flatMap<U>(      mapFn: (value: T, counter: number) => Iterable<U> | Iterator<U>     ): Iterator<U>          ```js                    This method returns an iterator whose values are the values of the iterables or iterators that are the results of applying `mapFn` to the values of `iterator`.                    ```     assert.deepEqual(      Iterator.from(['a', 'b', 'c', 'd'])      .flatMap((value, counter) => new Array(counter).fill(value))      .toArray(),      ['b', 'c', 'c', 'd', 'd', 'd']     );          ```js                    For more information see the section on the Array method with the same name: [“`.flatMap()`: Each input element produces zero or more output elements ^(ES2019)” (§34.14.3)](ch_arrays.html#Array.prototype.flatMap).           *   `Iterator.prototype.map(mapFn)`     ES2025 | Callback gets counter                    ```     Iterator<T>.prototype.map<U>(      mapFn: (value: T, counter: number) => U     ): Iterator<U>          ```js                    This method returns an iterator whose values are the result of applying `mapFn` to the values of `iterator`.                    ```     assert.deepEqual(      Iterator.from(['a', 'b', 'c', 'd']).map(x => x + x).toArray(),      ['aa', 'bb', 'cc', 'dd']     );          ```js           *   `Iterator.prototype.take(limit)` ES2025                    ```     Iterator<T>.prototype.take(limit: number): Iterator<T>          ```js                    This method returns an iterator with the first `limit` values of `iterator`.                    ```     assert.deepEqual(      Iterator.from(['a', 'b', 'c', 'd']).take(1).toArray(),      ['a']     );          ```js              #### [32.10.5 `Iterator.prototype.*`: methods that return booleans](#iteratorprototype-methods-that-return-booleans)    *   `Iterator.prototype.every(fn)`     ES2025 | Callback gets counter                    ```     Iterator<T>.prototype.every(      fn: (value: T, counter: number) => boolean     ): boolean          ```js                    This method returns `true` if `fn` returns `true` for every value of `iterator`. Otherwise, it returns `false`.                    ```     assert.equal(      Iterator.from(['a', 'b', 'c', 'd']).every(x => x === 'c'),      false     );          ```js           *   `Iterator.prototype.some(fn)`     ES2025 | Callback gets counter                    ```     Iterator<T>.prototype.some(      fn: (value: T, counter: number) => boolean     ): boolean          ```js                    This method returns `true` if `fn` returns `true` for at least one value of `iterator`. Otherwise, it returns `false`.                    ```     assert.equal(      Iterator.from(['a', 'b', 'c', 'd']).some(x => x === 'c'),      true     );          ```js              #### [32.10.6 `Iterator.prototype.*`: methods that return other kinds of values](#iteratorprototype-methods-that-return-other-kinds-of-values)    *   `Iterator.prototype.find(fn)`     ES2025 | Callback gets counter                    ```     Iterator<T>.prototype.find(      fn: (value: T, counter: number) => boolean     ): T          ```js                    This method returns the first value of `iterator` for which `fn` returns `true`. If there is no such value, it returns `undefined`.                    ```     assert.equal(      Iterator.from(['a', 'b', 'c', 'd']).find((_, counter) => counter === 1),      'b'     );          ```js           *   `Iterator.prototype.reduce(reducer, initialValue?)`     ES2025 | Callback gets counter                    ```     Iterator<T>.prototype.reduce<U>(      reducer: (accumulator: U, value: T, counter: number) => U,      initialValue?: U     ): U          ```js                    This method uses the function `reducer` to combine the values of `iterator` into a single value.                    Example – concatenating the strings of an iterator:                    ```     assert.deepEqual(      Iterator.from(['a', 'b', 'c', 'd']).reduce((acc, v) => acc + v),      'abcd'     );          ```js                    Example – computing the minimum of a Set of numbers:                    ```     const set = new Set([3, -2, -5, 4]);     assert.equal(      set.values().reduce((min, cur) => cur < min ? cur : min, Infinity),      -5     );          ```js                    For more information see the section on the Array method with the same name: [“`.reduce()`: computing a summary for an Array” (§34.15)](ch_arrays.html#Array.prototype.reduce).           *   `Iterator.prototype.toArray()` ES2025                    ```     Iterator<T>.prototype.toArray(): Array<T>          ```js                    This method returns the values of `iterator` in an Array.                    ```     assert.deepEqual(      Iterator.from(['a', 'b', 'c', 'd']).toArray(),      ['a', 'b', 'c', 'd']     );          ```js              #### [32.10.7 `Iterator.prototype.*`: other methods](#iteratorprototype-other-methods)    *   `Iterator.prototype.forEach(fn)`     ES2025 | Callback gets counter                    ```     Iterator<T>.prototype.forEach(      fn: (value: T, counter: number) => void     ): void          ```js                    This method applies `fn` to each value in `iterator`.                    ```     const result = [];     Iterator.from(['a', 'b', 'c', 'd']).forEach(x => result.unshift(x))     assert.deepEqual(      result,      ['d', 'c', 'b', 'a']     );          ```js ```` ```js`` `````", "``````js` ``````", "``````js``` ``````", "```` ```js````", "```js` ```", "```js```", "``` ```", "```````js``` ``````js```````", "``````js``````", "``````js``````", "``` ```", "```js```", "````js````", "```js```", "````js````", "```js` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "``````js``````", "```````js` ``````js```````", "```````js`` ``````js```````", "`````````"]