["```js\n// Function declaration (a statement)\nfunction ordinary1(a, b, c) {\n // \u00b7\u00b7\u00b7\n}\n\n// const plus anonymous (nameless) function expression\nconst ordinary2 = function (a, b, c) {\n // \u00b7\u00b7\u00b7\n};\n```", "```js\nconst anonFuncExpr = function (a, b, c) {\n // \u00b7\u00b7\u00b7\n};\n```", "```js\nconst namedFuncExpr = function myName(a, b, c) {\n // `myName` is only accessible in here\n};\n```", "```js\nconst func = function funcExpr() { return funcExpr };\nassert.equal(func(), func);\n\n// The name `funcExpr` only exists inside the function body:\nassert.throws(() => funcExpr(), ReferenceError);\n```", "```js\nfunction getNameOfCallback(callback) {\n return callback.name;\n}\n\nassert.equal(\n getNameOfCallback(function () {}), ''); // anonymous\n\nassert.equal(\n getNameOfCallback(function named() {}), 'named'); // (A)\n```", "```js\nfunction funcDecl() {}\nassert.equal(\n getNameOfCallback(funcDecl), 'funcDecl');\n\nconst funcExpr = function () {};\nassert.equal(\n getNameOfCallback(funcExpr), 'funcExpr');\n```", "```js\nfunction add(x, y) {\n return x + y;\n}\n```", "```js\n// Declaration\nfunction retrieveData(\n contentText,\n keyword,\n {unique, ignoreCase, pageSize}, // trailing comma\n) {\n // \u00b7\u00b7\u00b7\n}\n\n// Invocation\nretrieveData(\n '',\n null,\n {ignoreCase: true, pageSize: 10}, // trailing comma\n);\n```", "```js\nfunction add(x, y) {\n return x + y;\n}\n```", "```js\n    assert.equal(add(2, 1), 3);\n    ```", "```js\n    const obj = { addAsMethod: add };\n    assert.equal(obj.addAsMethod(2, 4), 6); // (A)\n    ```", "```js\n    const inst = new add();\n    assert.equal(inst instanceof add, true);\n    ```", "```js\n    const arrow = () => {\n     return 123;\n    };\n    assert.equal(arrow(), 123);\n    ```", "```js\n    const obj = {\n     myMethod() {\n     return 'abc';\n     }\n    };\n    assert.equal(obj.myMethod(), 'abc');\n    ```", "```js\n    class MyClass {\n     /* \u00b7\u00b7\u00b7 */\n    }\n    const inst = new MyClass();\n    ```", "```js\n> (() => {}) instanceof Function\ntrue\n> ({ method() {} }.method) instanceof Function\ntrue\n> (class SomeClass {}) instanceof Function\ntrue\n```", "```js\nconst f = function (x, y, z) { return 123 };\n```", "```js\nconst f = (x, y, z) => { return 123 };\n```", "```js\nconst f = (x, y, z) => 123;\n```", "```js\nconst id = x => x;\n```", "```js\n> [1,2,3].map(x => x+1)\n[ 2, 3, 4 ]\n```", "```js\n[1,2,3].map(function (x) { return x+1 });\n```", "```js\nconst func1 = () => ({a: 1});\nassert.deepEqual(func1(), { a: 1 });\n```", "```js\nconst func2 = () => {a: 1};\nassert.deepEqual(func2(), undefined);\n```", "```js\nconst obj = {\n myMethod() {\n assert.equal(this, obj);\n }\n};\nobj.myMethod();\n```", "```js\nconst obj = {\n myMethod: function () {\n assert.equal(this, obj);\n }\n};\nobj.myMethod();\n```", "```js\nfunction ordinaryFunc() {\n assert.equal(this, undefined);\n}\nordinaryFunc();\n```", "```js\nconst jill = {\n name: 'Jill',\n someMethod() {\n function ordinaryFunc() {\n assert.throws(\n () => this.name, // (A)\n /^TypeError: Cannot read properties of undefined \\(reading 'name'\\)$/);\n }\n ordinaryFunc();\n\n const arrowFunc = () => {\n assert.equal(this.name, 'Jill'); // (B)\n };\n arrowFunc();\n },\n};\njill.someMethod();\n```", "```js\n    const twiceOrdinary = [1, 2, 3].map(function (x) {return x * 2});\n    const twiceArrow = [1, 2, 3].map(x => x * 2);\n    ```", "```js\n    function timesOrdinary(x, y) {\n     return x * y;\n    }\n    const timesArrow = (x, y) => {\n     return x * y;\n    };\n    ```", "```js\nfunction func() {\n return 123;\n}\nassert.equal(func(), 123);\n```", "```js\nfunction boolToYesNo(bool) {\n if (bool) {\n return 'Yes';\n } else {\n return 'No';\n }\n}\nassert.equal(boolToYesNo(true), 'Yes');\nassert.equal(boolToYesNo(false), 'No');\n```", "```js\nfunction noReturn() {\n // No explicit return\n}\nassert.equal(noReturn(), undefined);\n```", "```js\nconst myArray = ['a', 'b'];\nconst callback = (x) => console.log(x);\nmyArray.forEach(callback);\n\n// Output:\n// 'a'\n// 'b'\n```", "```js\nfunction foo(x, y) {\n return [x, y];\n}\n\n// Too many arguments:\nassert.deepEqual(foo('a', 'b', 'c'), ['a', 'b']);\n\n// The expected number of arguments:\nassert.deepEqual(foo('a', 'b'), ['a', 'b']);\n\n// Not enough arguments:\nassert.deepEqual(foo('a'), ['a', undefined]);\n```", "```js\nfunction f(x, y=0) {\n return [x, y];\n}\n\nassert.deepEqual(f(1), [1, 0]);\nassert.deepEqual(f(), [undefined, 0]);\n```", "```js\nassert.deepEqual(\n f(undefined, undefined),\n [undefined, 0]);\n```", "```js\nfunction f(x, ...y) {\n return [x, y];\n}\nassert.deepEqual(\n f('a', 'b', 'c'), ['a', ['b', 'c']]\n);\nassert.deepEqual(\n f(), [undefined, []]\n);\n```", "```js\n    assert.throws(\n     () => eval('function f(...x, ...y) {}'),\n     /^SyntaxError: Rest parameter must be last formal parameter$/\n    );\n    ```", "```js\n    assert.throws(\n     () => eval('function f(...restParams, lastParam) {}'),\n     /^SyntaxError: Rest parameter must be last formal parameter$/\n    );\n    ```", "```js\nfunction createPoint(x, y) {\n return {x, y};\n // same as {x: x, y: y}\n}\n```", "```js\nfunction createPoint(...args) {\n if (args.length !== 2) {\n throw new Error('Please provide exactly 2 arguments!');\n }\n const [x, y] = args; // (A)\n return {x, y};\n}\n```", "```js\n    selectEntries(3, 20, 2)\n    ```", "```js\n    selectEntries({start: 3, end: 20, step: 2})\n    ```", "```js\nfunction selectEntries({start=0, end=-1, step=1}) {\n return {start, end, step};\n}\n```", "```js\n{start: start=0, end: end=-1, step: step=1}\n```", "```js\n> selectEntries({})\n{ start: 0, end: -1, step: 1 }\n```", "```js\n> selectEntries()\nTypeError: Cannot read properties of undefined (reading 'start')\n```", "```js\nfunction selectEntries({start=0, end=-1, step=1} = {}) {\n return {start, end, step};\n}\nassert.deepEqual(\n selectEntries(),\n { start: 0, end: -1, step: 1 });\n```", "```js\nfunction func(x, y) {\n console.log(x);\n console.log(y);\n}\nconst someIterable = ['a', 'b'];\nfunc(...someIterable);\n // same as func('a', 'b')\n\n// Output:\n// 'a'\n// 'b'\n```", "```js\n> Math.max(-1, 5, 11, 3)\n11\n> Math.max(...[-1, 5, 11, 3])\n11\n> Math.max(-1, ...[-5, 11], 3)\n11\n```", "```js\nconst arr1 = ['a', 'b'];\nconst arr2 = ['c', 'd'];\n\narr1.push(...arr2);\nassert.deepEqual(arr1, ['a', 'b', 'c', 'd']);\n```", "```js\nsomeFunc.call(thisValue, arg1, arg2, arg3);\n```", "```js\nsomeFunc(arg1, arg2, arg3);\n```", "```js\nfunction func(x, y) {\n return [this, x, y];\n}\n\nassert.deepEqual(\n func.call('hello', 'a', 'b'),\n ['hello', 'a', 'b']);\n```", "```js\nassert.deepEqual(\n func('a', 'b'),\n [undefined, 'a', 'b']);\n```", "```js\nassert.deepEqual(\n func.call(undefined, 'a', 'b'),\n [undefined, 'a', 'b']);\n```", "```js\nsomeFunc.apply(thisValue, [arg1, arg2, arg3]);\n```", "```js\nsomeFunc(...[arg1, arg2, arg3]);\n```", "```js\nfunction func(x, y) {\n return [this, x, y];\n}\n\nconst args = ['a', 'b'];\nassert.deepEqual(\n func.apply('hello', args),\n ['hello', 'a', 'b']);\n```", "```js\nconst boundFunc = someFunc.bind(thisValue, arg1, arg2);\n```", "```js\nboundFunc('a', 'b')\nsomeFunc.call(thisValue, arg1, arg2, 'a', 'b')\n```", "```js\nconst boundFunc2 = (...args) =>\n someFunc.call(thisValue, arg1, arg2, ...args);\n```", "```js\nfunction bind(func, thisValue, ...boundArgs) {\n return (...args) =>\n func.call(thisValue, ...boundArgs, ...args);\n}\n```", "```js\nfunction add(x, y) {\n return x + y;\n}\n\nconst add8 = add.bind(undefined, 8);\nassert.equal(add8(1), 9);\n```"]