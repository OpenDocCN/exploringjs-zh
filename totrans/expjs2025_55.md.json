["```js\n    /abc/iv\n\n    ```", "```js\n    new RegExp('abc', 'iv')\n\n    ```", "```js\n> /^\\*$/.test('*')\ntrue\n> new RegExp('^\\\\*$', 'v').test('*')\ntrue\n> new RegExp(String.raw`^\\*$`, 'v').test('*')\ntrue\n\n```", "```js\n// ‚ÄúImport‚Äù from namespace `String`\nconst {raw} = String;\n\nconst regExp = new RegExp(raw`^\\*$`, 'v');\n\n```", "```js\nfunction copyAndAddFlags(regExp, flagsToAdd='') {\n  // The constructor doesn‚Äôt allow duplicate flags;\n  // make sure there aren‚Äôt any:\n  const newFlags = Array.from(\n    new Set(regExp.flags + flagsToAdd)\n  ).join('');\n  return new RegExp(regExp, newFlags);\n}\nassert.equal(/abc/i.flags, 'i');\nassert.equal(copyAndAddFlags(/abc/i, 'g').flags, 'gi');\n\n```", "```js\n^ $ \\ . * + ? ( ) [ ] { } |\n\n```", "```js\n> /\\*/v.test('*')\ntrue\n\n```", "```js\n> /\\//v.test('/')\ntrue\n\n```", "```js\n> new RegExp('/', 'v').test('/')\ntrue\n\n```", "```js\nassert.throws(\n  () => eval(String.raw`/\\a/v`),\n  {\n    name: 'SyntaxError',\n    message: 'Invalid regular expression: /\\\\a/v: Invalid escape',\n  }\n);\nassert.throws(\n  () => eval(String.raw`/\\-/v`),\n  {\n    name: 'SyntaxError',\n    message: 'Invalid regular expression: /\\\\-/v: Invalid escape',\n  }\n);\n\n```", "```js\n> /\\a/.test('a')\ntrue\n\n```", "```js\n    ^ $ \\ . * + ? ( ) [ ] { } |\n\n    ```", "```js\n    /\n\n    ```", "```js\n    & - ! # % , : ; < = > @ ` ~\n\n    ```", "```js\n    ( ) [ ] { } / - \\ |\n\n    ```", "```js\n    && !! ## $$ %% ** ++ ,, .. :: ;; << == >> ?? @@ ^^ `` ~~\n\n    ```", "```js\n> 'üôÇ'.match(/./g) // code point with 2 code units\n[ '\\uD83D', '\\uDE42' ]\n> 'üôÇ'.match(/./gv)\n[ 'üôÇ' ]\n\n```", "```js\n            ^ $ \\ . * + ? ( ) [ ] { } |\n\n            ```", "```js\n> 'a7x4'.match(/\\d/g)\n[ '7', '4' ]\n> 'a7x4'.match(/\\D/g)\n[ 'a', 'x' ]\n> 'high - low'.match(/\\w+/g)\n[ 'high', 'low' ]\n> 'hello\\t\\n everyone'.replaceAll(/\\s/g, '-')\n'hello---everyone'\n\n```", "```js\n// Match all code points that are whitespace\nassert.deepEqual(\n  'a\\tb c'.match(/\\p{White_Space}/gv),\n  ['\\t', ' ']\n);\n\n// Match all code points that are not whitespace\nassert.deepEqual(\n  'a\\tb c'.match(/\\P{White_Space}/gv),\n  ['a', 'b', 'c']\n);\n\n```", "```js\n    \\p{Uppercase_Letter}\n    \\p{General_Category=Uppercase_Letter}\n\n    ```", "```js\n    > /^\\p{White_Space}+$/v.test('\\t \\n\\r')\n    true\n\n    ```", "```js\n    > /^\\p{Script=Greek}+$/v.test('ŒºŒµœÑŒ¨')\n    true\n\n    ```", "```js\n    > '1œÄ2√º3√©4'.replace(/\\p{Letter}/gv, '')\n    '1234'\n\n    ```", "```js\n    > 'AbCdEf'.replace(/\\p{Lowercase_Letter}/gv, '')\n    'ACE'\n\n    ```", "```js\n> /^\\p{RGI_Emoji}$/v.test('‚õî') // 1 code point (1 code unit)\ntrue\n> /^\\p{RGI_Emoji}$/v.test('üôÇ') // 1 code point (2 code units)\ntrue\n> /^\\p{RGI_Emoji}$/v.test('üòµ‚Äçüí´') // 3 code points\ntrue\n\n```", "```js\n> /^\\p{Emoji}$/v.test('‚õî') // 1 code point (1 code unit)\ntrue\n> /^\\p{Emoji}$/v.test('üôÇ') // 1 code point (2 code units)\ntrue\n> /^\\p{Emoji}$/v.test('üòµ‚Äçüí´') // 3 code points\nfalse\n\n```", "```js\n0023 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: \\x{23}\n002A FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: *\n0030 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 0\n0031 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 1\n0032 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 2\n0033 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 3\n0034 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 4\n0035 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 5\n0036 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 6\n0037 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 7\n0038 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 8\n0039 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 9\n\n```", "```js\n            ^ $ \\ . * + ? ( ) [ ] { } |\n\n            ```", "```js\n            /\n\n            ```", "```js\n            & - ! # % , : ; < = > @ ` ~\n\n            ```", "```js\n> /^[\\q{üòµ‚Äçüí´}]$/v.test('üòµ‚Äçüí´')\ntrue\n\n```", "```js\n> /^[üòµ‚Äçüí´]$/v.test('üòµ‚Äçüí´')\nfalse\n> /^[\\u{1F635}\\u{200D}\\u{1F4AB}]$/v.test('üòµ‚Äçüí´') // equivalent\nfalse\n> /^[üòµ‚Äçüí´]$/v.test('\\u{1F635}')\ntrue\n\n```", "```js\n> /^[\\q{abc|def}]$/v.test('abc')\ntrue\n> /^[\\q{abc|def}]$/v.test('def')\ntrue\n\n```", "```js\n> /^[\\d\\w]$/v.test('7')\ntrue\n> /^[\\d\\w]$/v.test('H')\ntrue\n> /^[\\d\\w]$/v.test('?')\nfalse\n\n```", "```js\n> /^[[0-9][A-Za-z0-9_]]$/v.test('7')\ntrue\n> /^[[0-9][A-Za-z0-9_]]$/v.test('H')\ntrue\n> /^[[0-9][A-Za-z0-9_]]$/v.test('?')\nfalse\n\n```", "```js\n> /^[\\w--[a-g]]$/v.test('a')\nfalse\n> /^[\\w--[a-g]]$/v.test('h')\ntrue\n\n> /^[\\p{Number}--[0-9]]$/v.test('Ÿ£')\ntrue\n> /^[\\p{Number}--[0-9]]$/v.test('3')\nfalse\n\n> /^[\\p{RGI_Emoji}--\\q{üòµ‚Äçüí´}]$/v.test('üòµ‚Äçüí´') // emoji has 3 code points\nfalse\n> /^[\\p{RGI_Emoji}--\\q{üòµ‚Äçüí´}]$/v.test('üôÇ')\ntrue\n\n```", "```js\n> /^[\\w--a]$/v.test('a')\nfalse\n> /^[\\w--a]$/v.test('b')\ntrue\n\n```", "```js\n> /[\\p{ASCII}&&\\p{Letter}]/v.test('D')\ntrue\n> /[\\p{ASCII}&&\\p{Letter}]/v.test('Œî')\nfalse\n\n> /^[\\p{Script=Arabic}&&\\p{Number}]$/v.test('Ÿ£')\ntrue\n> /^[\\p{Script=Arabic}&&\\p{Number}]$/v.test('ÿ¨')\nfalse\n\n```", "```js\n> /^[\\p{Emoji_Keycap_Sequence}[a-z]]+$/v.test('a2Ô∏è‚É£c')\ntrue\n\n```", "```js\n> /X.*X/.exec('XabcXdefX')[0]  // greedy\n'XabcXdefX'\n> /X.*?X/.exec('XabcXdefX')[0] // reluctant\n'XabcX'\n\n```", "```js\n> 'abcX def'.match(/[a-z]+(?=X)/g)\n[ 'abc' ]\n\n```", "```js\n> 'abcX def'.match(/[a-z]+(?!X)/g)\n[ 'ab', 'def' ]\n\n```", "```js\n> 'Xabc def'.match(/(?<=X)[a-z]+/g)\n[ 'abc' ]\n\n```", "```js\n> 'Xabc def'.match(/(?<!X)[a-z]+/g)\n[ 'bc', 'def' ]\n\n```", "```js\n> 'Node.js: index.js and main.js'.replace(/(?<!Node)\\.js/g, '.html')\n'Node.js: index.html and main.html'\n\n```", "```js\n    > /a/.test('A')\n    false\n    > /a/i.test('A')\n    true\n\n    ```", "```js\n    > 'a1\\na2\\na3'.match(/^a./gm)\n    [ 'a1', 'a2', 'a3' ]\n    > 'a1\\na2\\na3'.match(/^a./g)\n    [ 'a1' ]\n\n    ```", "```js\n    > /./.test('\\n')\n    false\n    > /./s.test('\\n')\n    true\n\n    ```", "```js\n    > /[^]/.test('\\n')\n    true\n\n    ```", "```js\n    > 'a1a2 a3'.match(/a./gy)\n    [ 'a1', 'a2' ]\n    > '_a1a2 a3'.match(/a./gy) // first match must be at index 0\n    null\n\n    > 'a1a2 a3'.match(/a./g)\n    [ 'a1', 'a2', 'a3' ]\n    > '_a1a2 a3'.match(/a./g)\n    [ 'a1', 'a2', 'a3' ]\n\n    ```", "```js\n> /-/gymdivs.flags\n'dgimsvy'\n\n```", "```js\n> 'üôÇ'.length\n2\n\n```", "```js\n> /^\\uD83D\\uDE42$/.test('üôÇ')\ntrue\n\n```", "```js\n> 'üôÇ'.match(/./g)\n[ '\\uD83D', '\\uDE42' ]\n\n```", "```js\n> /^üôÇ{2}$/.test('\\uD83D\\uDE42\\uDE42')\ntrue\n> /^\\uD83D\\uDE42{2}$/.test('\\uD83D\\uDE42\\uDE42') // equivalent\ntrue\n\n```", "```js\n> 'üôÇ'.match(/\\D/g)\n[ '\\uD83D', '\\uDE42' ]\n\n```", "```js\n> /^[üôÇ]$/.test('üôÇ')\nfalse\n> /^[\\uD83D\\uDE42]$/.test('\\uD83D\\uDE42') // equivalent\nfalse\n> /^[üôÇ]$/.test('\\uD83D')\ntrue\n\n```", "```js\n> /^\\u{1F642}$/u.test('üôÇ')\ntrue\n\n```", "```js\n> 'üôÇ'.match(/./gu)\n[ 'üôÇ' ]\n\n```", "```js\n> /^üôÇ{2}$/u.test('üôÇüôÇ')\ntrue\n\n```", "```js\n> 'üôÇ'.match(/\\D/gu)\n[ 'üôÇ' ]\n\n```", "```js\n> /^\\p{Emoji}$/u.test('‚õî') // 1 code point (1 code unit)\ntrue\n> /^\\p{Emoji}$/u.test('üôÇ') // 1 code point (2 code units)\ntrue\n\n```", "```js\n> /^[üôÇ]$/u.test('üôÇ')\ntrue\n> /^[üôÇ]$/u.test('\\uD83D')\nfalse\n\n```", "```js\n    assert.throws(\n      () => eval('/-/uv'),\n      SyntaxError\n    );\n\n    ```", "```js\n> Array.from('üòµ‚Äçüí´').length // count code points\n3\n\n```", "```js\n// Grapheme cluster is not matched by single dot\nassert.equal(\n  'üòµ‚Äçüí´'.match(/./gu).length, 3\n);\n\n// Quantifiers only repeat last code point of grapheme cluster\nassert.equal(\n  /^üòµ‚Äçüí´{2}$/u.test('üòµ‚Äçüí´üòµ‚Äçüí´'), false\n);\n\n// Character class escapes only match single code points\nassert.equal(\n  /^\\p{Emoji}$/u.test('üòµ‚Äçüí´'), false\n);\n\n// Character classes only match single code points\nassert.equal(\n  /^[üòµ‚Äçüí´]$/u.test('üòµ‚Äçüí´'), false\n);\n\n```", "```js\n    > /^\\p{RGI_Emoji}$/v.test('‚õî') // 1 code point (1 code unit)\n    true\n    > /^\\p{RGI_Emoji}$/v.test('üôÇ') // 1 code point (2 code units)\n    true\n    > /^\\p{RGI_Emoji}$/v.test('üòµ‚Äçüí´') // 3 code points\n    true\n\n    ```", "```js\n    > /^[\\q{üòµ‚Äçüí´}]$/v.test('üòµ‚Äçüí´')\n    true\n\n    ```", "```js\n> /^\\P{Lowercase_Letter}$/iu.test('A')\ntrue\n> /^\\P{Lowercase_Letter}$/iu.test('a')\ntrue\n\n> /^[^\\p{Lowercase_Letter}]$/iu.test('A')\nfalse\n> /^[^\\p{Lowercase_Letter}]$/iu.test('a')\nfalse\n\n```", "```js\n> /^\\P{Lowercase_Letter}$/iv.test('A')\nfalse\n> /^\\P{Lowercase_Letter}$/iv.test('a')\nfalse\n\n> /^[^\\p{Lowercase_Letter}]$/iv.test('A')\nfalse\n> /^[^\\p{Lowercase_Letter}]$/iv.test('a')\nfalse\n\n```", "```js\n> /^x(?i:HELLO)x$/.test('xHELLOx')\ntrue\n> /^x(?i:HELLO)x$/.test('xhellox')\ntrue\n> /^x(?i:HELLO)x$/.test('XhelloX')\nfalse\n\n```", "```js\n(?ims-ims:pattern)\n(?ims:pattern)\n(?-ims:pattern)\n\n```", "```js\n> /^x(?-i:HELLO)x$/i.test('xHELLOx')\ntrue\n> /^x(?-i:HELLO)x$/i.test('XHELLOX')\ntrue\n> /^x(?-i:HELLO)x$/i.test('XhelloX')\nfalse\n\n```", "```js\nconst re = /(?-m:^)---\\r?\\n((?:^(?!---$).*\\r?\\n)*)^---$/m;\nassert.equal(re.test('---a'), false);\nassert.equal(re.test('---\\n---'), true);\nassert.equal(\n  re.exec('---\\n---')[1],\n  ''\n);\nassert.equal(\n  re.exec('---\\na: b\\n---')[1],\n  'a: b\\n'\n);\n\n```", "```js\n(?-m:^)---\\r?\\n  # first line of string\n(  # capturing group for the frontmatter\n  (?:  # pattern for one line (non-capturing group)\n    ^(?!---$)  # line must not start with \"---\" + EOL (lookahead)\n    .*\\r?\\n\n  )*\n)\n^---$  # closing delimiter of frontmatter\n\n```", "```js\n    regex('i')`world`\n    regex`(?i:world)`\n\n    ```", "```js\n> /a/i.ignoreCase\ntrue\n> /a/.ignoreCase\nfalse\n\n```", "```js\n    > /abc/ig.source\n    'abc'\n\n    ```", "```js\n    > /abc/ig.flags\n    'gi'\n\n    ```", "```js\nassert.deepEqual(\n  /(a+)b/d.exec('ab aaab'),\n  {\n    0: 'ab',\n    1: 'a',\n    index: 0,\n    input: 'ab aaab',\n    groups: undefined,\n    indices: {\n      0: [0, 2],\n      1: [0, 1],\n      groups: undefined\n    },\n  }\n);\n\n```", "```js\nconst matchObj = /(a+)(b+)/d.exec('aaaabb');\nassert.equal(\n  matchObj[1], 'aaaa'\n);\nassert.equal(\n  matchObj[2], 'bb'\n);\n\n```", "```js\nassert.deepEqual(\n  matchObj.indices[1], [0, 4]\n);\nassert.deepEqual(\n  matchObj.indices[2], [4, 6]\n);\n\n```", "```js\nconst matchObj = /(?<as>a+)(?<bs>b+)/d.exec('aaaabb');\nassert.equal(\n  matchObj.groups.as, 'aaaa'\n);\nassert.equal(\n  matchObj.groups.bs, 'bb'\n);\n\n```", "```js\nassert.deepEqual(\n  matchObj.indices.groups.as, [0, 4]\n);\nassert.deepEqual(\n  matchObj.indices.groups.bs, [4, 6]\n);\n\n```", "```js\nconst reQuoted = /‚Äú([^‚Äù]+)‚Äù/dgv;\nfunction pointToQuotedText(str) {\n  const startIndices = new Set();\n  const endIndices = new Set();\n  for (const match of str.matchAll(reQuoted)) {\n    const [start, end] = match.indices[1];\n    startIndices.add(start);\n    endIndices.add(end);\n  }\n  let result = '';\n  for (let index=0; index < str.length; index++) {\n    if (startIndices.has(index)) {\n      result += '[';\n    } else if (endIndices.has(index+1)) {\n      result += ']';\n    } else {\n      result += ' ';\n    }\n  }\n  return result;\n}\n\nassert.equal(\n  pointToQuotedText(\n    'They said ‚Äúhello‚Äù and ‚Äúgoodbye‚Äù.'),\n    '           [   ]       [     ]  '\n);\n\n```", "```js\n> /a/.test('__a__')\ntrue\n\n```", "```js\n> /^a/.test('__a__')\nfalse\n> /^a/.test('a__')\ntrue\n\n```", "```js\nassert.deepEqual(\n  'ab aab'.match(/(a+)b/),\n  {\n    0: 'ab',\n    1: 'a',\n    index: 0,\n    input: 'ab aab',\n    groups: undefined,\n  }\n);\n\n```", "```js\nassert.deepEqual(\n  'ab aab'.match(/(?<as>a+)b/),\n  {\n    0: 'ab',\n    1: 'a',\n    index: 0,\n    input: 'ab aab',\n    groups: { as: 'a' },\n  }\n);\n\n```", "```js\nconst RE = /(?<a>a(?<xs>x+))|(?<b>b(?<xs>x+))/v;\nassert.deepEqual(\n  'axx'.match(RE).groups,\n  {\n    a: 'axx',\n    xs: 'xx',\n    b: undefined,\n    __proto__: null,\n  }\n);\nassert.deepEqual(\n  'bxx'.match(RE).groups,\n  {\n    a: undefined,\n    xs: 'xx',\n    b: 'bxx',\n    __proto__: null,\n  }\n);\n\n```", "```js\nassert.throws(\n  () => eval('/(?<a>a(?<xs>x+))(?<b>b(?<xs>x+))/v'),\n  /^SyntaxError:.* Duplicate capture group name$/\n);\n\n```", "```js\n> 'ab aab'.match(/(a+)b/g)\n[ 'ab', 'aab' ]\n\n```", "```js\n> 'xyz'.match(/(a+)b/g)\nnull\n\n```", "```js\nconst numberOfMatches = (str.match(regExp) ?? []).length;\n\n```", "```js\nconst numberOfMatches = str.match(regExp)?.length ?? 0;\n\n```", "```js\nconst matchIterable = str.matchAll(regExp);\n\n```", "```js\n> Array.from('-a-a-a'.matchAll(/-(a)/gv))\n[\n  { 0:'-a', 1:'a', index: 0, input: '-a-a-a', groups: undefined },\n  { 0:'-a', 1:'a', index: 2, input: '-a-a-a', groups: undefined },\n  { 0:'-a', 1:'a', index: 4, input: '-a-a-a', groups: undefined },\n]\n\n```", "```js\n> Array.from('-a-a-a'.matchAll(/-(a)/v))\nTypeError: String.prototype.matchAll called with a non-global\nRegExp argument\n\n```", "```js\nfunction* matchAll(str, regExp) {\n  if (!regExp.global) {\n    throw new TypeError('Flag /g must be set!');\n  }\n  // Preserve and reset flags\n  const localCopy = new RegExp(regExp, regExp.flags);\n  let match;\n  while (match = localCopy.exec(str)) {\n    yield match;\n  }\n}\n\n```", "```js\nconst str = '\"fee\" \"fi\" \"fo\" \"fum\"';\nconst regex = /\"([^\"]*)\"/g;\n\nfor (const match of matchAll(str, regex)) {\n  console.log(match[1]);\n}\n\n```", "```js\nfee\nfi\nfo\nfum\n\n```", "```js\n> const regExp = /(a+)b/g;\n> regExp.exec('ab aab')\n{ 0: 'ab', 1: 'a', index: 0, input: 'ab aab', groups: undefined }\n> regExp.exec('ab aab')\n{ 0: 'aab', 1: 'aa', index: 3, input: 'ab aab', groups: undefined }\n> regExp.exec('ab aab')\nnull\n\n```", "```js\nconst regExp = /(a+)b/g;\nconst str = 'ab aab';\n\nlet match;\n// Check for null via truthiness\n// Alternative: while ((match = regExp.exec(str)) !== null)\nwhile (match = regExp.exec(str)) {\n  console.log(match[1]);\n}\n\n```", "```js\na\naa\n\n```", "```js\n    > 'aaa'.replace(/a/, 'x')\n    'xaa'\n\n    ```", "```js\n    > 'aaa'.replace('a', 'x')\n    'xaa'\n\n    ```", "```js\n    > 'aaa'.replace(/a/g, 'x')\n    'xxx'\n\n    ```", "```js\n    > 'aaa'.replaceAll(/a/g, 'x')\n    'xxx'\n\n    ```", "```js\n    > 'aaa'.replaceAll('a', 'x')\n    'xxx'\n\n    ```", "```js\n    > 'aaa'.replaceAll(/a/, 'x')\n    TypeError: String.prototype.replaceAll called with\n    a non-global RegExp argument\n\n    ```", "```js\n> 'a1 a2'.replaceAll(/a/g, \"($`|$&|$')\")\n'(|a|1 a2)1 (a1 |a|2)2'\n\n```", "```js\n> const regExp = /^([A-Za-z]+): (.*)$/gv;\n> 'first: Jane'.replaceAll(regExp, 'KEY: $1, VALUE: $2')\n'KEY: first, VALUE: Jane'\n\n```", "```js\n> const regExp = /^(?<key>[A-Za-z]+): (?<value>.*)$/gv;\n> 'first: Jane'.replaceAll(regExp, 'KEY: $<key>, VALUE: $<value>')\n'KEY: first, VALUE: Jane'\n\n```", "```js\nassert.equal(\n  '3 cats and 4 dogs'.replaceAll(/[0-9]+/g, (all) => 2 * Number(all)),\n  '6 cats and 8 dogs'\n);\n\n```", "```js\nconst result = 'first=jane, last=doe'.replace(\n  /(?<key>[a-z]+)=(?<value>[a-z]+)/g,\n  (...args) => { // (A)\n    const groups = args.at(-1); // (B)\n    const {key, value} = groups;\n    return key.toUpperCase() + '=' + value.toUpperCase();\n  });\nassert.equal(result, 'FIRST=JANE, LAST=DOE');\n\n```", "```js\n> /bc/.test('ABCD')\nfalse\n> /bc/i.test('ABCD')\ntrue\n> /\\.mjs$/.test('main.mjs')\ntrue\n\n```", "```js\n> const r = /a/g;\n> r.test('aab')\ntrue\n> r.test('aab')\ntrue\n> r.test('aab')\nfalse\n\n```", "```js\n> '_abc_'.search(/abc/)\n1\n> 'main.mjs'.search(/\\.mjs$/)\n4\n\n```", "```js\n> 'a : b : c'.split(':')\n[ 'a ', ' b ', ' c' ]\n\n```", "```js\n> 'a x:yyy b'.split(/x+:y+/)\n[ 'a ', ' b' ]\n> 'a x:yyy b'.split(/(x+):(y+)/)\n[ 'a ', 'x', 'yyy', ' b' ]\n\n```", "```js\n> 'a: b: c'.split(/(?<=:) */)\n[ 'a:', 'b:', 'c' ]\n> 'a :b :c'.split(/ *(?=:)/)\n[ 'a', ':b', ':c' ]\n\n```", "```js\n> const re = /#/; re.lastIndex = 1;\n> ['##-#'.match(re), re.lastIndex]\n[{ 0: '#', index: 0, input: '##-#' }, 1]\n> ['##-#'.match(re), re.lastIndex]\n[{ 0: '#', index: 0, input: '##-#' }, 1]\n\n```", "```js\n> const re = /#/y; re.lastIndex = 1;\n> ['##-#'.match(re), re.lastIndex]\n[{ 0: '#', index: 1, input: '##-#' }, 2]\n> ['##-#'.match(re), re.lastIndex]\n[null, 0]\n\n```", "```js\n> const re = /#/g; re.lastIndex = 1;\n> '##-#'.match(re)\n['#', '#', '#']\n> re.lastIndex\n0\n\n```", "```js\n> const re = /#/gy; re.lastIndex = 1;\n> '##-#'.match(re)\n['#', '#']\n> re.lastIndex\n0\n\n```", "```js\n> const re = /#/y; re.lastIndex = 1;\n> '##-#'.matchAll(re)\nTypeError: String.prototype.matchAll called with\na non-global RegExp argument\n\n```", "```js\n> const re = /#/g; re.lastIndex = 1;\n> Array.from('##-#'.matchAll(re))\n[\n  { 0: '#', index: 1, input: '##-#' },\n  { 0: '#', index: 3, input: '##-#' },\n]\n> re.lastIndex\n1\n\n```", "```js\n> const re = /#/gy; re.lastIndex = 1;\n> Array.from('##-#'.matchAll(re))\n[\n  { 0: '#', index: 1, input: '##-#' },\n]\n> re.lastIndex\n1\n\n```", "```js\n> const re = /#/; re.lastIndex = 1;\n> [re.exec('##-#'), re.lastIndex]\n[{ 0: '#', index: 0, input: '##-#' }, 1]\n> [re.exec('##-#'), re.lastIndex]\n[{ 0: '#', index: 0, input: '##-#' }, 1]\n\n```", "```js\n> const re = /#/g; re.lastIndex = 1;\n> [re.exec('##-#'), re.lastIndex]\n[{ 0: '#', index: 1, input: '##-#' }, 2]\n> [re.exec('##-#'), re.lastIndex]\n[{ 0: '#', index: 3, input: '##-#' }, 4]\n> [re.exec('##-#'), re.lastIndex]\n[null, 0]\n\n```", "```js\n> const re = /#/y; re.lastIndex = 1;\n> [re.exec('##-#'), re.lastIndex]\n[{ 0: '#', index: 1, input: '##-#' }, 2]\n> [re.exec('##-#'), re.lastIndex]\n[null, 0]\n\n```", "```js\n> const re = /#/; re.lastIndex = 1;\n> '##-#'.replace(re, 'x')\n'x#-#'\n> re.lastIndex\n1\n\n```", "```js\n> const re = /#/g; re.lastIndex = 1;\n> '##-#'.replace(re, 'x')\n'xx-x'\n> re.lastIndex\n0\n\n```", "```js\n> const re = /#/y; re.lastIndex = 1;\n> '##-#'.replace(re, 'x')\n'#x-#'\n> re.lastIndex\n2\n\n```", "```js\n> const re = /#/gy; re.lastIndex = 1;\n> '##-#'.replace(re, 'x')\n'xx-#'\n> re.lastIndex\n0\n\n```", "```js\n> const re = /#/y; re.lastIndex = 1;\n> '##-#'.replaceAll(re, 'x')\nTypeError: String.prototype.replaceAll called\nwith a non-global RegExp argument\n\n```", "```js\n> const re = /#/; re.lastIndex = 1;\n> [re.test('##-#'), re.lastIndex]\n[true, 1]\n> [re.test('##-#'), re.lastIndex]\n[true, 1]\n\n```", "```js\n> const re = /#/g; re.lastIndex = 1;\n> [re.test('##-#'), re.lastIndex]\n[true, 2]\n> [re.test('##-#'), re.lastIndex]\n[true, 4]\n> [re.test('##-#'), re.lastIndex]\n[false, 0]\n\n```", "```js\n> const re = /#/y; re.lastIndex = 1;\n> [re.test('##-#'), re.lastIndex]\n[true, 2]\n> [re.test('##-#'), re.lastIndex]\n[false, 0]\n\n```", "```js\nlet matchObj;\n// Infinite loop\nwhile (matchObj = /a+/g.exec('bbbaabaaa')) {\n  console.log(matchObj[0]);\n}\n\n```", "```js\nfunction collectMatches(regExp, str) {\n  const matches = [];\n  let matchObj;\n  // Infinite loop\n  while (matchObj = regExp.exec(str)) {\n    matches.push(matchObj[0]);\n  }\n  return matches;\n}\ncollectMatches(/a+/, 'bbbaabaaa'); // Missing: flag /g\n\n```", "```js\n> const regExp = /^X/g;\n> [regExp.test('Xa'), regExp.lastIndex]\n[ true, 1 ]\n> [regExp.test('Xa'), regExp.lastIndex]\n[ false, 0 ]\n> [regExp.test('Xa'), regExp.lastIndex]\n[ true, 1 ]\n\n```", "```js\n> const regExp = /^X/y;\n> regExp.test('Xa')\ntrue\n> regExp.test('Xa')\nfalse\n> regExp.test('Xa')\ntrue\n\n```", "```js\nfunction countMatches(regExp, str) {\n  let count = 0;\n  while (regExp.test(str)) {\n    count++;\n  }\n  return count;\n}\n\nconst myRegExp = /a/g;\nmyRegExp.lastIndex = 4;\nassert.equal(\n  countMatches(myRegExp, 'babaa'), 1 // should be 3\n);\n\n```", "```js\nfunction countMatches(regExp, str) {\n  if (!regExp.global) {\n    throw new Error('Flag /g of regExp must be set');\n  }\n  if (regExp.lastIndex !== 0) {\n    throw new Error('regExp.lastIndex must be zero');\n  }\n\n  let count = 0;\n  while (regExp.test(str)) {\n    count++;\n  }\n  return count;\n}\n\n```", "```js\nfunction countMatches(regExp, str) {\n  const cloneFlags = regExp.flags + (regExp.global ? '' : 'g');\n  const clone = new RegExp(regExp, cloneFlags);\n\n  let count = 0;\n  while (clone.test(str)) {\n    count++;\n  }\n  return count;\n}\n\n```", "```js\nfunction countMatches(regExp, str) {\n  if (!regExp.global) {\n    throw new Error('Flag /g of regExp must be set');\n  }\n  return (str.match(regExp) ?? []).length;\n}\n\nconst myRegExp = /a/g;\nmyRegExp.lastIndex = 4;\nassert.equal(countMatches(myRegExp, 'babaa'), 3); // OK!\n\n```", "```js\nfunction startsWith(regExp, str, index) {\n  if (!regExp.sticky || regExp.global) {\n    throw new Error('Flag /y must be set. Flag /g must not be set.');\n  }\n  regExp.lastIndex = index;\n  return regExp.test(str);\n}\nassert.equal(\n  startsWith(/x+/y, 'aaxxx', 0), false\n);\nassert.equal(\n  startsWith(/x+/y, 'aaxxx', 2), true\n);\n\n```", "```js\n> '#--#'.search(/#/)\n0\n\n```", "```js\nfunction searchFrom(regExp, str, index) {\n  if (!regExp.global || regExp.sticky) {\n    throw new Error('Flag /g must be set. Flag /y must not be set.');\n  }\n  regExp.lastIndex = index;\n  const match = regExp.exec(str);\n  if (match) {\n    return match.index;\n  } else {\n    return -1;\n  }\n}\n\nassert.equal(\n  searchFrom(/#/g, '#--#', 0), 0\n);\nassert.equal(\n  searchFrom(/#/g, '#--#', 1), 3\n);\n\n```", "```js\nfunction replaceOnceAt(str, regExp, replacement, index) {\n  if (!regExp.sticky || regExp.global) {\n    throw new Error('Flag /y must be set. Flag /g must not be set.');\n  }\n  regExp.lastIndex = index;\n  return str.replace(regExp, replacement);\n}\nassert.equal(\n  replaceOnceAt('aa aaaa a', /a+/y, 'X', 0), 'X aaaa a')\n;\nassert.equal(\n  replaceOnceAt('aa aaaa a', /a+/y, 'X', 3), 'aa X a'\n);\nassert.equal(\n  replaceOnceAt('aa aaaa a', /a+/y, 'X', 8), 'aa aaaa X'\n);\n\n```", "```js\n> RegExp.escape('(*)')\n'\\\\(\\\\*\\\\)'\n\n```", "```js\n> '\\\\(\\\\*\\\\)' === String.raw`\\(\\*\\)`\ntrue\n\n```", "```js\n> RegExp.escape('_abc123')\n'_abc123'\n\n```", "```js\nfunction replacePlainText(str, searchText, replace) {\n  const searchRegExp = new RegExp(\n    RegExp.escape(searchText),\n    'gu'\n  );\n  return str.replace(searchRegExp, replace)\n}\nassert.equal(\n  replacePlainText('(a) and (a)', '(a)', '@'),\n  '@ and @'\n);\n\n```", "```js\nassert.equal(\n  '(a) and (a)'.replaceAll('(a)', '@'),\n  '@ and @'\n);\n\n```", "```js\nfunction removeUnquotedText(str, text) {\n  const regExp = new RegExp(\n    `(?<!‚Äú)${RegExp.escape(text)}(?!‚Äù)`,\n    'gu'\n  );\n  return str.replaceAll(regExp, '‚Ä¢');\n}\nassert.equal(\n  removeUnquotedText('‚Äúyes‚Äù and yes and ‚Äúyes‚Äù', 'yes'),\n  '‚Äúyes‚Äù and ‚Ä¢ and ‚Äúyes‚Äù'\n);\n\n```", "```js\n    > /(?:)/.test('')\n    true\n    > /(?:)/.test('abc')\n    true\n\n    ```", "```js\n    > /.^/.test('')\n    false\n    > /.^/.test('abc')\n    false\n\n    ```", "```js\n> new RegExp('')\n/(?:)/\n\n```", "```js\nconst RE_API_SIGNATURE =\n  /^(new |get )?([A-Za-z0-9_.\\[\\]]+)/;\n\n```", "```js\nconst RE_API_SIGNATURE =\n  /^(new |get )?([A-Za-z0-9_.\\[\\]]+)/v;\n\n```", "```js\n/pattern/giv\n\n```", "```js\n> String(/pattern/vgi)\n'/pattern/giv'\n\n```", "```js\nconst RE_API_SIGNATURE =\n  /^(?<prefix>new |get )?(?<name>[A-Za-z0-9_.\\[\\]]+)/;\n\n```", "```js\nimport {regex} from 'regex';\n\nconst RE_API_SIGNATURE = regex`\n ^\n (?<prefix>\n new \\x20  # constructor\n |\n get \\x20  # getter\n )?\n (?<name>\n # Square brackets are needed for symbol keys\n [\n A-Z a-z 0-9 _\n .\n \\[ \\]\n ]+\n )\n`;\n\n```", "```js\nassert.deepEqual(\n  getCaptures(`get Map.prototype.size`),\n  {\n    prefix: 'get ',\n    name: 'Map.prototype.size',\n  }\n);\nassert.deepEqual(\n  getCaptures(`new Array(len = 0)`),\n  {\n    prefix: 'new ',\n    name: 'Array',\n  }\n);\nassert.deepEqual(\n  getCaptures(`Array.prototype.push(...items)`),\n  {\n    prefix: undefined,\n    name: 'Array.prototype.push',\n  }\n);\nassert.deepEqual(\n  getCaptures(`Map.prototype[Symbol.iterator]()`),\n  {\n    prefix: undefined,\n    name: 'Map.prototype[Symbol.iterator]',\n  }\n);\n\nfunction getCaptures(apiSignature) {\n  const match = RE_API_SIGNATURE.exec(apiSignature);\n  // Spread so that the result does not have a null prototype\n  // and is easier to compare.\n  return {...match.groups};\n}\n\n```", "```js\n/**\n * Matches API signatures ‚Äì e.g.:\n * ```", "```js\n */\nconst RE_API_SIGNATURE = regex`\n ¬∑¬∑¬∑\n`;\n\n```", "```js\nimport { pattern, regex } from 'regex';\n\nconst LABEL = pattern`[a-z\\-]+`;\nconst ARGS = pattern`\n (?<args>\n \\x20+\n ${LABEL}\n )*\n`;\nconst NAME = pattern`\n (?<name> ${LABEL} )\n`;\n\nconst TAG = regex`\n (?<openingTag>\n \\[\n \\x20*\n ${NAME}\n ${ARGS}\n \\x20*\n \\]\n )\n |\n (?<singletonTag>\n \\[\n \\x20*\n ${NAME}\n ${ARGS}\n \\x20*\n / \\]\n )\n`;\n\nassert.deepEqual(\n  TAG.exec('[pre js line-numbers]').groups,\n  {\n    openingTag: '[pre js line-numbers]',\n    name: 'pre',\n    args: ' line-numbers',\n    singletonTag: undefined,\n    __proto__: null,\n  }\n);\n\nassert.deepEqual(\n  TAG.exec('[hr /]').groups,\n  {\n    openingTag: undefined,\n    name: 'hr',\n    args: undefined,\n    singletonTag: '[hr /]',\n    __proto__: null,\n  }\n);\n\n```", "```js\nconst RE_API_SIGNATURE = new RegExp(\n  String.raw`\n ^\n (?<prefix>\n new \\x20\n |\n get \\x20\n )?\n (?<name>\n [\n A-Z a-z 0-9 _\n .\n \\[ \\]\n ]+\n )\n `.replaceAll(/\\s+/g, ''), // (A)\n  'v'\n);\nassert.equal(\n  String(RE_API_SIGNATURE),\n  String.raw`/^(?<prefix>new\\x20|get\\x20)?(?<name>[A-Za-z0-9_.\\[\\]]+)/v`\n);\n\n```", "```js\n// Template tag function\nconst cmt = () => '';\nconst RE = new RegExp(\n String.raw`\n a+ ${cmt`one or more as`}\n `.replaceAll(/\\s+/g, ''),\n 'v'\n);\nassert.equal(\n String(RE), '/a+/v'\n);\n\n```", "```js\n        match(\n          regExpOrString: string | RegExp\n        ): null | RegExpMatchArray\n\n        interface RegExpMatchArray extends Array<string> {\n          index: number;\n          input: string;\n          groups: undefined | {\n            [key: string]: string\n          };\n        }\n\n        ```", "```js\n        > 'ababb'.match(/a(b+)/)\n        { 0: 'ab', 1: 'b', index: 0, input: 'ababb', groups: undefined }\n        > 'ababb'.match(/a(?<bs>b+)/)\n        { 0: 'ab', 1: 'b', index: 0, input: 'ababb', groups: { bs: 'b' } }\n        > 'abab'.match(/x/)\n        null\n\n        ```", "```js\n        match(\n          regExpOrString: RegExp\n        ): null | Array<string>\n\n        ```", "```js\n        > 'ababb'.match(/a(b+)/g)\n        [ 'ab', 'abb' ]\n        > 'ababb'.match(/a(?<bs>b+)/g)\n        [ 'ab', 'abb' ]\n        > 'abab'.match(/x/g)\n        null\n\n        ```", "```js\n    matchAll(regexp: RegExp): Iterator<RegExpExecArray>\n    interface RegExpMatchArray extends Array<string> {\n      index: number;\n      input: string;\n      groups: undefined | {\n        [key: string]: string\n      };\n    }\n\n    ```", "```js\n    > 'yes'.matchAll(/(y|s)/gv).toArray()\n    [\n      { 0: 'y', 1: 'y', index: 0, input: 'yes', groups: undefined },\n      { 0: 's', 1: 's', index: 2, input: 'yes', groups: undefined },\n    ]\n\n    ```", "```js\n    > 'a2b'.search(/[0-9]/)\n    1\n    > 'a2b'.search('[0-9]')\n    1\n\n    ```", "```js\n    split(separator: string | RegExp, limit?: number): Array<string>\n\n    ```", "```js\n    // Splitting with a string\n    assert.deepEqual(\n      'a.b.c'.split('.'),\n      [ 'a', 'b', 'c' ]\n    );\n\n    // Splitting with a regular expression\n    assert.deepEqual(\n      'a x:yyy b'.split(/x+:y+/),\n      [ 'a ', ' b' ]\n    );\n\n    // Group captures appear in the result\n    assert.deepEqual(\n      'a x:yyy b'.split(/(x+):(y+)/),\n      [ 'a ', 'x', 'yyy', ' b' ]\n    );\n\n    ```", "```js\n    > 'a: b: c'.split(/(?<=:) */)\n    [ 'a:', 'b:', 'c' ]\n    > 'a :b :c'.split(/ *(?=:)/)\n    [ 'a', ':b', ':c' ]\n\n    ```", "```js\n        replace(\n          searchValue: string | RegExp,\n          replaceValue: string | (...args: any[]) => string\n        ): string\n\n        ```", "```js\n        > 'x.x.'.replace('.', '#') // interpreted literally\n        'x#x.'\n        > 'x.x.'.replace(/./, '#')\n        '#.x.'\n\n        ```", "```js\n        replace(\n          searchValue: RegExp,\n          replaceValue: string | (...args: any[]) => string\n        ): string\n\n        ```", "```js\n        > 'x.x.'.replace(/./g, '#')\n        '####'\n        > 'x.x.'.replace(/\\./g, '#')\n        'x#x#'\n\n        ```", "```js\n        replaceAll(\n          searchValue: string | RegExp,\n          replaceValue: string\n        ): string\n\n        ```", "```js\n        > 'x.x.'.replaceAll('.', '#') // interpreted literally\n        'x#x#'\n        > 'x.x.'.replaceAll(/./g, '#')\n        '####'\n        > 'x.x.'.replaceAll(/./, '#')\n        TypeError: String.prototype.replaceAll called with\n        a non-global RegExp argument\n\n        ```", "```js\n        replaceAll(\n          searchValue: string | RegExp,\n          replaceValue: (...args: any[]) => string\n        ): string\n\n        ```", "```js\n        const regexp = /([0-9]{2})\\.([0-9]{4})/g;\n        const replacer = (all, month, year) => `|${year}-${month}|`;\n        assert.equal(\n          'a 12.1995 b'.replaceAll(regexp, replacer),\n          'a |1995-12| b'\n        );\n\n        ```", "```js\n        const regexp = /(?<month>[0-9]{2})\\.(?<year>[0-9]{4})/g;\n        const replacer = (...args) => {\n          const groups = args.at(-1);\n          return `|${groups.year}-${groups.month}|`;\n        };\n        assert.equal(\n          'a 12.1995 b'.replaceAll(regexp, replacer),\n          'a |1995-12| b'\n        );\n\n        ```", "```js\n    test(string: string): boolean\n\n    ```", "```js\n    > /^# /.test('# comment')\n    true\n    > /^# /.test('#comment')\n    false\n    > /^# /.test('abc')\n    false\n\n    ```", "```js\n        exec(string: string): RegExpExecArray | null\n\n        interface RegExpExecArray extends Array<string> {\n          index: number;\n          input: string;\n          groups: undefined | {\n            [key: string]: string\n          };\n        }\n\n        ```", "```js\n        > const regExp = /(a+)b/g, str = 'ab aab';\n\n        > regExp.exec(str)\n        {0: 'ab', 1: 'a', index: 0, input: 'ab aab', groups: undefined}\n        > regExp.lastIndex\n        2\n\n        > regExp.exec(str)\n        {0: 'aab', 1: 'aa', index: 3, input: 'ab aab', groups: undefined}\n        > regExp.lastIndex\n        6\n\n        > regExp.exec(str)\n        null\n        > regExp.lastIndex\n        0\n\n        ```"]