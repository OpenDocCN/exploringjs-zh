["```js\n    /abc/iv\n\n    ```", "```js\n    new RegExp('abc', 'iv')\n\n    ```", "```js\n> /^\\*$/.test('*')\ntrue\n> new RegExp('^\\\\*$', 'v').test('*')\ntrue\n> new RegExp(String.raw`^\\*$`, 'v').test('*')\ntrue\n\n```", "```js\n// ‚ÄúImport‚Äù from namespace `String`\nconst {raw} = String;\n ``const regExp = new RegExp(raw`^\\*$`, 'v');`` \n```", "```js```", "````js````", "```js```", "````js````", "```js function copyAndAddFlags(regExp, flagsToAdd='') {  // The constructor doesn‚Äôt allow duplicate flags;  // make sure there aren‚Äôt any:  const newFlags = Array.from(  new Set(regExp.flags + flagsToAdd)  ).join('');  return new RegExp(regExp, newFlags); } assert.equal(/abc/i.flags, 'i'); assert.equal(copyAndAddFlags(/abc/i, 'g').flags, 'gi');  ```", "```js ^ $ \\ . * + ? ( ) [ ] { } |  ```", "```js > /\\*/v.test('*') true  ```", "```js > /\\//v.test('/') true  ```", "```js > new RegExp('/', 'v').test('/') true  ```", "```js assert.throws(  () => eval(String.raw`/\\a/v`),  {  name: 'SyntaxError',  message: 'Invalid regular expression: /\\\\a/v: Invalid escape',  } ); assert.throws(  () => eval(String.raw`/\\-/v`),  {  name: 'SyntaxError',  message: 'Invalid regular expression: /\\\\-/v: Invalid escape',  } );  ```", "```js > /\\a/.test('a') true  ```", "```js     ^ $ \\ . * + ? ( ) [ ] { } |          ```", "```js     /          ```", "```js     & - ! # % , : ; < = > @ ` ~          ```", "```js     ( ) [ ] { } / - \\ |          ```", "```js     && !! ## $$ %% ** ++ ,, .. :: ;; << == >> ?? @@ ^^ `` ~~          ```", "```js > 'üôÇ'.match(/./g) // code point with 2 code units [ '\\uD83D', '\\uDE42' ] > 'üôÇ'.match(/./gv) [ 'üôÇ' ]  ```", "```js             ^ $ \\ . * + ? ( ) [ ] { } |                          ```", "```js > 'a7x4'.match(/\\d/g) [ '7', '4' ] > 'a7x4'.match(/\\D/g) [ 'a', 'x' ] > 'high - low'.match(/\\w+/g) [ 'high', 'low' ] > 'hello\\t\\n everyone'.replaceAll(/\\s/g, '-') 'hello---everyone'  ```", "```js // Match all code points that are whitespace assert.deepEqual(  'a\\tb c'.match(/\\p{White_Space}/gv),  ['\\t', ' '] );  `// Match all code points that are not whitespace` `assert.deepEqual(`  `'a\\tb c'.match(/\\P{White_Space}/gv),`  `['a', 'b', 'c']` `);`  ```", "```js```", "````js````", "```js```", "````js``` #### [46.5.3‚ÄÉUnicode character property escapes ^(ES2018)](#unicode-character-property-escapes)    With flag `/u` or flag `/v`, we can use `\\p{}` and `\\P{}` to specify sets of code points via *Unicode character properties* (we‚Äôll learn more about those in the next subsection). That looks like this:    1.  `\\p{prop=value}`: matches all characters whose Unicode character property `prop` has the value `value`. 2.  `\\P{prop=value}`: matches all characters that do not have a Unicode character property `prop` whose value is `value`. 3.  `\\p{bin_prop}`: matches all characters whose binary Unicode character property `bin_prop` is True. 4.  `\\P{bin_prop}`: matches all characters whose binary Unicode character property `bin_prop` is False.    Comments:    *   Forms (3) and (4) can be used as abbreviations if the property is `General_Category`. For example, the following two escapes are equivalent:                    ```     \\p{Uppercase_Letter}     \\p{General_Category=Uppercase_Letter}          ```js           *   Without the flags `/u` and `/v`, `\\p` is the same as `p`.              Examples:    *   Checking for whitespace:                    ```     > /^\\p{White_Space}+$/v.test('\\t \\n\\r')     true          ```js           *   Checking for Greek letters:                    ```     > /^\\p{Script=Greek}+$/v.test('ŒºŒµœÑŒ¨')     true          ```js           *   Deleting any letters:                    ```     > '1œÄ2√º3√©4'.replace(/\\p{Letter}/gv, '')     '1234'          ```js           *   Deleting lowercase letters:                    ```     > 'AbCdEf'.replace(/\\p{Lowercase_Letter}/gv, '')     'ACE'          ```js              ##### [46.5.3.1‚ÄÉUnicode character properties](#unicode-character-properties)    In the Unicode standard, each character has *properties* ‚Äì metadata describing it. Properties play an important role in defining the nature of a character. Quoting [the Unicode Standard, Sect. 3.3, D3](http://www.unicode.org/versions/Unicode9.0.0/ch03.pdf):    > The semantics of a character are determined by its identity, normative properties, and behavior.    These are a few examples of properties:    *   `Name`: a unique name, composed of uppercase letters, digits, hyphens, and spaces ‚Äì for example:     *   A: `Name = LATIN CAPITAL LETTER A`     *   üôÇ: `Name = SLIGHTLY SMILING FACE` *   `General_Category`: categorizes characters ‚Äì for example:     *   x: `General_Category = Lowercase_Letter`     *   3: `General_Category = Number`     *   $: `General_Category = Currency_Symbol` *   `White_Space`: used for marking invisible spacing characters, such as spaces, tabs and newlines ‚Äì for example:     *   \\t: `White_Space = True`     *   œÄ: `White_Space = False` *   `Age`: version of the Unicode Standard in which a character was introduced ‚Äì for example: The Euro sign ‚Ç¨ was added in version 2.1 of the Unicode standard.     *   ‚Ç¨: `Age = 2.1` *   `Block`: a contiguous range of code points. Blocks don‚Äôt overlap and their names are unique. For example:     *   S: `Block = Basic_Latin` (range 0x0000..0x007F)     *   üôÇ: `Block = Emoticons` (range 0x1F600..0x1F64F) *   `Script`: is a collection of characters used by one or more writing systems.     *   Some scripts support several writing systems. For example, the Latin script supports the writing systems English, French, German, Latin, etc.     *   Some languages can be written in multiple alternate writing systems that are supported by multiple scripts. For example, Turkish used the Arabic script before it transitioned to the Latin script in the early 20th century.     *   Examples:         *   Œ±: `Script = Greek`         *   –î: `Script = Cyrillic`    Further reading:    *   Lists of Unicode properties and their values: [‚ÄúUnicode Standard Annex #44: Unicode Character Database‚Äù](https://unicode.org/reports/tr44/#Properties) (Editors: Mark Davis, Lauren»õiu Iancu, Ken Whistler)    #### [46.5.4‚ÄÉUnicode string property escapes ^(ES2024)](#unicode-string-property-escapes)    Only flag `/v` lets us use `\\p{}` to specify sets of code point sequences via *Unicode string properties* (negation via `\\P{}` is not supported). For example, `RGI_Emoji` is a Unicode string property:    ``` > /^\\p{RGI_Emoji}$/v.test('‚õî') // 1 code point (1 code unit) true > /^\\p{RGI_Emoji}$/v.test('üôÇ') // 1 code point (2 code units) true > /^\\p{RGI_Emoji}$/v.test('üòµ‚Äçüí´') // 3 code points true  ```js    Let‚Äôs see how the Unicode character property `Emoji` does with these inputs:    ``` > /^\\p{Emoji}$/v.test('‚õî') // 1 code point (1 code unit) true > /^\\p{Emoji}$/v.test('üôÇ') // 1 code point (2 code units) true > /^\\p{Emoji}$/v.test('üòµ‚Äçüí´') // 3 code points false  ```js    As expected, it only matches single code points.    ##### [46.5.4.1‚ÄÉUnicode string properties](#unicode-string-properties)    For now, only the following Unicode string properties are supported by JavaScript:    *   `Basic_Emoji`: single code points *   `Emoji_Keycap_Sequence` *   `RGI_Emoji_Modifier_Sequence` *   `RGI_Emoji_Flag_Sequence` *   `RGI_Emoji_Tag_Sequence` *   `RGI_Emoji_ZWJ_Sequence` *   `RGI_Emoji`: union of all of the above sets    The semantics of Unicode string properties are defined in [text files](https://www.unicode.org/reports/tr51/#Emoji_Properties_and_Data_Files) that enumerate code point sequences likes this (`\\x{23}` is `#`):    ``` 0023 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: \\x{23} 002A FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: * 0030 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 0 0031 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 1 0032 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 2 0033 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 3 0034 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 4 0035 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 5 0036 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 6 0037 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 7 0038 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 8 0039 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 9  ```js    Further reading:    *   [Section ‚ÄúProperties of Strings‚Äù](https://www.unicode.org/reports/tr23/#PropertyStringsDefinitions) in ‚ÄúUnicode Technical Report #23: The Unicode Character Property Model‚Äù defines what properties of strings are.           *   [Table ‚ÄúBinary Unicode properties of strings‚Äù](https://tc39.es/ecma262/#table-binary-unicode-properties-of-strings) in the ECMAScript specification lists the properties of strings that are supported by JavaScript.              ### [46.6‚ÄÉSyntax: character classes](#syntax-character-classes)    A *character class* wraps *class ranges* in square brackets. The class ranges specify a set of characters:    *   `[¬´class ranges¬ª]` matches any character in the set. *   `[^¬´class ranges¬ª]` matches any character not in the set.    Rules for class ranges:    *   Non-syntax characters stand for themselves: `[abc]`           *   What characters must be escaped depends on the flags:               *   Flag `/v`: Some of the following characters only have to be escaped if they appear twice, but it‚Äôs easier to always escape them. For details, see [‚ÄúEscaping inside character classes (`[¬∑¬∑¬∑]`)‚Äù (¬ß46.2.3)](#escaping-inside-character-classes).                           *   [Syntax Characters](https://tc39.es/ecma262/#prod-SyntaxCharacter):                                                    ```             ^ $ \\ . * + ? ( ) [ ] { } |                          ```js                                   *   Slash:                                                    ```             /                          ```js                                   *   [Class Set Reserved Punctuators](https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator):                                                    ```             & - ! # % , : ; < = > @ ` ~                          ```js                               *   No Unicode flag (neither `/v` nor `/u`):                           *   We always must escape: `\\ ]`                                   *   Some characters only have to be escaped in some locations:                                       *   `^` only has to be escaped if it comes first.             *   `-` only has to be escaped if it doesn‚Äôt come first or last. *   Character escapes (`\\n`, `\\x20`, `\\u{1F44D}`, etc.) have the usual meanings.               *   Watch out: `\\b` stands for backspace. Elsewhere in a regular expression, it matches word boundaries. *   Character class escapes (`\\d`, `\\P{White_Space}`, `\\p{RGI_Emoji}`, etc.) have the usual meanings.           *   A range of characters is specified via a dash: `[a-z]`              #### [46.6.1‚ÄÉCode point sequences in character classes ^(ES2024)](#character-class-code-point-sequences)    With flag `/v`, we can use `\\q{}` to add code point sequences to the set defined by a character class. This syntax is also called:    *   *Class string disjunction* (by [the ECMAScript specification](https://tc39.es/ecma262/#prod-ClassStringDisjunction)) *   *String literal* (by [the ECMAScript proposal for flag `/v`](https://github.com/tc39/proposal-regexp-v-flag))    This is an example of using `\\q{}`:    ``` > /^[\\q{üòµ‚Äçüí´}]$/v.test('üòµ‚Äçüí´') true  ```js    Without `\\q{}`, a [grapheme cluster](ch_unicode.html#grapheme-clusters) with multiple code points is still treated as multiple characters:    ``` > /^[üòµ‚Äçüí´]$/v.test('üòµ‚Äçüí´') false > /^[\\u{1F635}\\u{200D}\\u{1F4AB}]$/v.test('üòµ‚Äçüí´') // equivalent false > /^[üòµ‚Äçüí´]$/v.test('\\u{1F635}') true  ```js    We can use a single `\\q{}` to add multiple code point sequences ‚Äì if we separate them with pipes:    ``` > /^[\\q{abc|def}]$/v.test('abc') true > /^[\\q{abc|def}]$/v.test('def') true  ```js    #### [46.6.2‚ÄÉSet operations for character classes ^(ES2024)](#regexp-character-class-set-operations)    Flag `/v` enables set operations for character classes.    ##### [46.6.2.1‚ÄÉNesting character classes](#nesting-character-classes)    To enable set operations for character classes, we must be able to nest them. Character class escapes already provide some kind of nesting:    ``` > /^[\\d\\w]$/v.test('7') true > /^[\\d\\w]$/v.test('H') true > /^[\\d\\w]$/v.test('?') false  ```js    With flag `/v`, we can additionally nest character classes (the regular expression below is equivalent to the regular expression in the previous example):    ``` > /^[[0-9][A-Za-z0-9_]]$/v.test('7') true > /^[[0-9][A-Za-z0-9_]]$/v.test('H') true > /^[[0-9][A-Za-z0-9_]]$/v.test('?') false  ```js    ##### [46.6.2.2‚ÄÉSubtraction of character sets via `--`](#subtraction-of-character-sets-via-)    We can use the `--` operator to set-theoretically subtract the character sets defined by character classes or character class escapes:    ``` > /^[\\w--[a-g]]$/v.test('a') false > /^[\\w--[a-g]]$/v.test('h') true  `> /^[\\p{Number}--[0-9]]$/v.test('Ÿ£')` `true` `> /^[\\p{Number}--[0-9]]$/v.test('3')` `false`  `` `> /^[\\p{RGI_Emoji}--\\q{üòµ‚Äçüí´}]$/v.test('üòµ‚Äçüí´') // emoji has 3 code points` `false` `> /^[\\p{RGI_Emoji}--\\q{üòµ‚Äçüí´}]$/v.test('üôÇ')` `true` ``  ```js   ````", "```````js```````", "`````` ```js``````", "```````js```````", "``` > /^[\\w--a]$/v.test('a') false > /^[\\w--a]$/v.test('b') true  ```", "``` > /[\\p{ASCII}&&\\p{Letter}]/v.test('D') true > /[\\p{ASCII}&&\\p{Letter}]/v.test('Œî') false  `> /^[\\p{Script=Arabic}&&\\p{Number}]$/v.test('Ÿ£')` `true` `> /^[\\p{Script=Arabic}&&\\p{Number}]$/v.test('ÿ¨')` `false`  ```", "``````js``````", "```````js```` ##### [46.6.2.4‚ÄÉUnion of characters sets](#union-of-characters-sets)    Two compute the set-theoretical union of character sets, we only need to write their definining constructs next to each other inside a character class:    ```js > /^[\\p{Emoji_Keycap_Sequence}[a-z]]+$/v.test('a2Ô∏è‚É£c') true  ```    ### [46.7‚ÄÉSyntax: capture groups](#regexp-capture-groups)    *   Numbered capture group: `(a+)`     *   Backreference: `\\1`, `\\2`, etc. *   Named capture group ^(ES2018): `(?<as>a+)`     *   Backreference: `\\k<as>` *   Noncapturing group: `(?:a+)`    ### [46.8‚ÄÉSyntax: quantifiers](#regexp-quantifiers)    By default, all of the following quantifiers are *greedy* (they match as many characters as possible):    *   `?`: match never or once *   `*`: match zero or more times *   `+`: match one or more times *   `{n}`: match `n` times *   `{n,}`: match `n` or more times *   `{n,m}`: match at least `n` times, at most `m` times.    To make them *reluctant* (so that they match as few characters as possible), put question marks (`?`) after them:    ```js > /X.*X/.exec('XabcXdefX')[0]  // greedy 'XabcXdefX' > /X.*?X/.exec('XabcXdefX')[0] // reluctant 'XabcX'  ```    ### [46.9‚ÄÉSyntax: assertions](#regexp-assertions)    *   `^` matches only at the beginning of the input *   `$` matches only at the end of the input *   `\\b` matches only at a word boundary     *   `\\B` matches only when not at a word boundary    Overview of available lookaround assertions:     | Pattern | Name |  | | --- | --- | --- | | `(?=¬´pattern¬ª)` | Positive lookahead | ES3 | | `(?!¬´pattern¬ª)` | Negative lookahead | ES3 | | `(?<=¬´pattern¬ª)` | Positive lookbehind | ES2018 | | `(?<!¬´pattern¬ª)` | Negative lookbehind | ES2018 |    #### [46.9.1‚ÄÉLookahead assertions](#regexp-lookahead-assertions)    **Positive lookahead:** `(?=¬´pattern¬ª)` matches if `pattern` matches what comes next.    Example: sequences of lowercase letters that are followed by an `X`.    ```js > 'abcX def'.match(/[a-z]+(?=X)/g) [ 'abc' ]  ```    Note that the `X` itself is not part of the matched substring.    **Negative lookahead:** `(?!¬´pattern¬ª)` matches if `pattern` does not match what comes next.    Example: sequences of lowercase letters that are not followed by an `X`.    ```js > 'abcX def'.match(/[a-z]+(?!X)/g) [ 'ab', 'def' ]  ```    #### [46.9.2‚ÄÉLookbehind assertions ^(ES2018)](#regexp-lookbehind-assertions)    **Positive lookbehind:** `(?<=¬´pattern¬ª)` matches if `pattern` matches what came before.    Example: sequences of lowercase letters that are preceded by an `X`.    ```js > 'Xabc def'.match(/(?<=X)[a-z]+/g) [ 'abc' ]  ```    **Negative lookbehind:** `(?<!¬´pattern¬ª)` matches if `pattern` does not match what came before.    Example: sequences of lowercase letters that are not preceded by an `X`.    ```js > 'Xabc def'.match(/(?<!X)[a-z]+/g) [ 'bc', 'def' ]  ```    Example: replace ‚Äú.js‚Äù with ‚Äú.html‚Äù, but not in ‚ÄúNode.js‚Äù.    ```js > 'Node.js: index.js and main.js'.replace(/(?<!Node)\\.js/g, '.html') 'Node.js: index.html and main.html'  ```    ### [46.10‚ÄÉSyntax: disjunction (`|`)](#syntax-disjunction-)    Caveat: this operator has low precedence (binds very weakly). Use groups if necessary:    *   `^aa|zz$` matches all strings that start with `aa` and/or end with `zz`.     *   Note that `|` has a lower precedence than `^` and `$`. *   `^(aa|zz)$` matches the two strings `'aa'` and `'zz'`. *   `^a(a|z)z$` matches the two strings `'aaz'` and `'azz'`.    ### [46.11‚ÄÉRegular expression flags](#regexp-flags)     | Literal flag | Property name | ES | Description | | --- | --- | --- | --- | | `d` | `hasIndices` | ES2022 | Switch on match indices | | `g` | `global` | ES3 | Match multiple times | | `i` | `ignoreCase` | ES3 | Match case-insensitively | | `m` | `multiline` | ES3 | `^` and `$` match per line | | `s` | `dotAll` | ES2018 | Dot matches line terminators | | `u` | `unicode` | ES6 | Unicode mode | | `v` | `unicodeSets` | ES2024 | Unicode sets mode (**recommended**) | | `y` | `sticky` | ES6 | No characters between matches |      Table 46.1: These are the regular expression flags supported by JavaScript.      The following regular expression flags are available in JavaScript ([table 46.1](#tbl:reg-exp-flags-table) provides a compact overview):    *   `/d` (`.hasIndices`): Some RegExp-related methods return *match objects* that describe where the regular expression matched in an input string. If this flag is on, each match object includes *match indices* which tell us where each group capture starts and ends. More information: [‚ÄúMatch indices in match objects ^(ES2022)‚Äù (¬ß46.14.1)](#regexp-match-indices).           *   `/g` (`.global`) fundamentally changes how the following methods work.               *   `String.prototype.match()`     *   `RegExp.prototype.exec()`     *   `RegExp.prototype.test()`          How, is explained in [‚ÄúThe flags `/g` and `/y`, and the property `.lastIndex` (advanced)‚Äù (¬ß46.16)](#regexp-flags-gy). In a nutshell: Without `/g`, the methods only consider the first match for a regular expression in an input string. With `/g`, they consider all matches.           *   `/i` (`.ignoreCase`) switches on case-insensitive matching:                    ```js     > /a/.test('A')     false     > /a/i.test('A')     true          ```           *   `/m` (`.multiline`): If this flag is on, `^` matches the beginning of each line and `$` matches the end of each line. If it is off, `^` matches the beginning of the whole input string and `$` matches the end of the whole input string.                    ```js     > 'a1\\na2\\na3'.match(/^a./gm)     [ 'a1', 'a2', 'a3' ]     > 'a1\\na2\\na3'.match(/^a./g)     [ 'a1' ]          ```           *   `/s` (`.dotAll`): By default, the dot does not match line terminators. With this flag, it does:                    ```js     > /./.test('\\n')     false     > /./s.test('\\n')     true          ```                    Workaround: If `/s` isn‚Äôt supported, we can use `[^]` instead of a dot.                    ```js     > /[^]/.test('\\n')     true          ```           *   Better support for Unicode (the ‚ÄúUnicode flags‚Äù):               *   `/u` (`.unicode`): By default, the atomic units of matching are JavaScript characters (Unicode code units). This flag switches to Unicode code points as atomic units. It is explained in [‚ÄúFlag `/u`: characters are code points ^(ES6)‚Äù (¬ß46.11.3)](#regexp-flag-unicode).                       *   `/v` (`.unicodeSets`): This flag improves and replaces flag `/u`. It supports multi-code-point grapheme clusters and set operations in character classes. It is explained in [‚ÄúFlag `/v`: limited support for multi-code-point grapheme clusters ^(ES2024)‚Äù (¬ß46.11.4)](#regexp-flag-unicode-sets). **I recommend to use flag `/v` with all regular expressions** ‚Äì due to all the features it enables.                   *   `/y` (`.sticky`): This flag mainly makes sense in conjunction with `/g`. When both are switched on, any match must directly follow the previous one (that is, it must start at index `.lastIndex` of the regular expression object). Therefore, the first match must be at index 0.                    ```js     > 'a1a2 a3'.match(/a./gy)     [ 'a1', 'a2' ]     > '_a1a2 a3'.match(/a./gy) // first match must be at index 0     null      `> 'a1a2 a3'.match(/a./g)`     `[ 'a1', 'a2', 'a3' ]`     `> '_a1a2 a3'.match(/a./g)`     `[ 'a1', 'a2', 'a3' ]`      ```           ``The main use case for `/y` is tokenization (during parsing). More information on this flag: [‚ÄúThe flags `/g` and `/y`, and the property `.lastIndex` (advanced)‚Äù (¬ß46.16)](#regexp-flags-gy).``     ```js```````", "```````js`````` #### [46.11.1‚ÄÉHow to order regular expression flags?](#order-of-regexp-flags)    Consider the following regular expression: `/‚Äú([^‚Äù]+)‚Äù/vdg`    In which order should we list its flags? Two options are:    1.  Alphabetical order: `/dgv` 2.  In order of importance (arguably, `/v` is most fundamental etc.): `/vgd`    Given that (2) is not obvious, (1) is the better choice. JavaScript also uses it for the RegExp property `.flags` :    ```js > /-/gymdivs.flags 'dgimsvy'  ```    #### [46.11.2‚ÄÉWithout the Unicode flags `/u` and `/v`: characters are UTF-16 code units](#without-the-unicode-flags-u-and-v-characters-are-utf16-code-units)    Without the Unicode flags `/u` and `/v`, most constructs work with single UTF-16 code units, which is problematic whenever a character has more than one code unit ‚Äì e.g. üôÇ:    ```js > 'üôÇ'.length 2  ```    Without Unicode flags, the largest character we can escape is a code unit, via a *code unit escape*. It consists of `\\u` followed by four hexadecimal digits:    ```js > /^\\uD83D\\uDE42$/.test('üôÇ') true  ```    The dot operator (`.`) matches code units, which is why we get two matches instead of one:    ```js > 'üôÇ'.match(/./g) [ '\\uD83D', '\\uDE42' ]  ```    Quantifiers apply to code units and therefore only repeat the second half of üôÇ:    ```js > /^üôÇ{2}$/.test('\\uD83D\\uDE42\\uDE42') true > /^\\uD83D\\uDE42{2}$/.test('\\uD83D\\uDE42\\uDE42') // equivalent true  ```    Character class escapes define sets of code units. Therefore, the class escape `\\D` for ‚Äúnot a decimal digit‚Äù gets two matches:    ```js > 'üôÇ'.match(/\\D/g) [ '\\uD83D', '\\uDE42' ]  ```    Character classes define sets of code units. Therefore, putting üôÇ in a character class has unintuitive consequences:    ```js > /^[üôÇ]$/.test('üôÇ') false > /^[\\uD83D\\uDE42]$/.test('\\uD83D\\uDE42') // equivalent false > /^[üôÇ]$/.test('\\uD83D') true  ```    #### [46.11.3‚ÄÉFlag `/u`: characters are code points ^(ES6)](#regexp-flag-unicode)    In the previous subsection, we encountered problems when we wanted to match a code point with more than one UTF-16 code unit ‚Äì such as üôÇ. Flag `/u` enables support for code points and fixes those problems.    We can escape code points via *code point escapes* ‚Äì `\\u{}` with one to six hexadecimal digits:    ```js > /^\\u{1F642}$/u.test('üôÇ') true  ```    The dot operator (`.`) matches code points:    ```js > 'üôÇ'.match(/./gu) [ 'üôÇ' ]  ```    Quantifiers apply to code points:    ```js > /^üôÇ{2}$/u.test('üôÇüôÇ') true  ```    Character class escapes define sets of code points:    ```js > 'üôÇ'.match(/\\D/gu) [ 'üôÇ' ]  ```    A new kind of character class escapes is supported ‚Äì [Unicode character property escapes](#unicode-character-property-escapes) specify sets of code points:    ```js > /^\\p{Emoji}$/u.test('‚õî') // 1 code point (1 code unit) true > /^\\p{Emoji}$/u.test('üôÇ') // 1 code point (2 code units) true  ```    Character classes also define sets of code points:    ```js > /^[üôÇ]$/u.test('üôÇ') true > /^[üôÇ]$/u.test('\\uD83D') false  ```    #### [46.11.4‚ÄÉFlag `/v`: limited support for multi-code-point grapheme clusters ^(ES2024)](#regexp-flag-unicode-sets)    ![Icon ‚Äútip‚Äù](../Images/8440b17bb8219cda9f9405ac83c36db0.png)‚ÄÇ**Use flag `/v` whenever you can**    This flag improves many aspects of JavaScript‚Äôs regular expressions and should be used by default. If a platform doesn‚Äôt support it yet, you should at least use `/u`.    *   Flag `/v` builds on the improvements brought by flag `/u` and fixes several of its shortcomings.           *   Note that flag `/v` and flag `/u` are mutually exclusive ‚Äì we can‚Äôt use both at the same time:                    ```js     assert.throws(      () => eval('/-/uv'),      SyntaxError     );          ```              ##### [46.11.4.1‚ÄÉLimitation of flag `/u`: handling grapheme clusters with more than one code point](#limitation-of-flag-u-handling-grapheme-clusters-with-more-than-one-code-point)    Some font glyphs are represented by *grapheme clusters* (code point sequences) with more than one code point ‚Äì¬†e.g. üòµ‚Äçüí´:    ```js > Array.from('üòµ‚Äçüí´').length // count code points 3  ```    Flag `/u` does not help us with those kinds of grapheme clusters:    ```js // Grapheme cluster is not matched by single dot assert.equal(  'üòµ‚Äçüí´'.match(/./gu).length, 3 );  `// Quantifiers only repeat last code point of grapheme cluster` `assert.equal(`  `/^üòµ‚Äçüí´{2}$/u.test('üòµ‚Äçüí´üòµ‚Äçüí´'), false` `);`  ``` `// Character class escapes only match single code points` `assert.equal(`  `/^\\p{Emoji}$/u.test('üòµ‚Äçüí´'), false` `);`  `` `// Character classes only match single code points` `assert.equal(`  `/^[üòµ‚Äçüí´]$/u.test('üòµ‚Äçüí´'), false` `);` `` ```js  ```   ```js```````", "```````js````` ```js```````", "```````js```` ##### [46.11.4.2‚ÄÉFlag `/v`: Unicode string property escapes and character class string literals](#flag-v-unicode-string-property-escapes-and-character-class-string-literals)    Flag `/v` works like flag `/u` but provides better support for multi-code-point grapheme clusters. It doesn‚Äôt switch from code points to grapheme clusters everywhere, but it does fix the last two issues we encountered in the previous subsection ‚Äì by adding support for multi-code-point grapheme clusters to:    *   Character class escapes: We can refer to [Unicode string properties](#unicode-string-properties) via `\\p{}`.                    ```js     > /^\\p{RGI_Emoji}$/v.test('‚õî') // 1 code point (1 code unit)     true     > /^\\p{RGI_Emoji}$/v.test('üôÇ') // 1 code point (2 code units)     true     > /^\\p{RGI_Emoji}$/v.test('üòµ‚Äçüí´') // 3 code points     true          ```           *   Character classes: `\\q{}` lets us define [code point sequences](#character-class-code-point-sequences).                    ```js     > /^[\\q{üòµ‚Äçüí´}]$/v.test('üòµ‚Äçüí´')     true          ```              ##### [46.11.4.3‚ÄÉFlag `/v`: character class set operations](#flag-v-character-class-set-operations)    Character classes can be nested and combined via the set operations subtraction and intersection ‚Äì see [‚ÄúSet operations for character classes ^(ES2024)‚Äù (¬ß46.6.2)](#regexp-character-class-set-operations).    ##### [46.11.4.4‚ÄÉFlag `/v`: improved case-insensitive matching](#flag-v-improved-caseinsensitive-matching)    Flag `/u` has a quirk when it comes to case-insensitive matching: Using `\\P{¬∑¬∑¬∑}` produces different results than `[^\\p{¬∑¬∑¬∑}]`:    ```js > /^\\P{Lowercase_Letter}$/iu.test('A') true > /^\\P{Lowercase_Letter}$/iu.test('a') true  `> /^[^\\p{Lowercase_Letter}]$/iu.test('A')` `false` `> /^[^\\p{Lowercase_Letter}]$/iu.test('a')` `false`  ```   ```js```````", "```````js``` Observations:    *   Both ways of negating should produce the same results. *   Intuitively, if we add `/i` to a regular expression, it should match at least as many strings as before ‚Äì not fewer.    Flag `/v` fixes that quirk:    ``` > /^\\P{Lowercase_Letter}$/iv.test('A') false > /^\\P{Lowercase_Letter}$/iv.test('a') false  `> /^[^\\p{Lowercase_Letter}]$/iv.test('A')` `false` `> /^[^\\p{Lowercase_Letter}]$/iv.test('a')` `false`  ```js   ``````js```````", "`````` Further reading:    *   [A 2ality blog post](https://2ality.com/2022/11/regexp-v-flag.html#improved-case-insensitive-matching) explains why `/u` causes this behavior. *   Source of this section: [GitHub issue ‚ÄúIgnoreCase vs. complement vs. nested class‚Äù](https://github.com/tc39/proposal-regexp-v-flag/issues/30)    ### [46.12‚ÄÉPattern modifiers (inline flags) ^(ES2025)](#regexp-pattern-modifiers)    Pattern modifiers let us apply a flag to a part of a regular expression (vs. all of the regular expression) ‚Äì for example, in the following regular expression, the flag `i` is only applied to ‚ÄúHELLO‚Äù:    ```js > /^x(?i:HELLO)x$/.test('xHELLOx') true > /^x(?i:HELLO)x$/.test('xhellox') true > /^x(?i:HELLO)x$/.test('XhelloX') false  ```    #### [46.12.1‚ÄÉThe syntax of pattern modifiers](#the-syntax-of-pattern-modifiers)    This is what the syntax looks like:    ```js (?ims-ims:pattern) (?ims:pattern) (?-ims:pattern)  ```    Notes:    *   A flag that follows the question mark (`?`) is activated. *   A flag that follows the hyphen (`-`) is deactivated. *   A flag cannot appear in both the ‚Äúactivation section‚Äù and the ‚Äúdeactivation section‚Äù. *   Without any flags, this syntax is simply a non-capturing group: `(?:pattern)`    Let‚Äôs change the previous example: Now all of the regular expression is case-insensitive ‚Äì except for ‚ÄúHELLO‚Äù:    ```js > /^x(?-i:HELLO)x$/i.test('xHELLOx') true > /^x(?-i:HELLO)x$/i.test('XHELLOX') true > /^x(?-i:HELLO)x$/i.test('XhelloX') false  ```    #### [46.12.2‚ÄÉWhich flags are supported?](#which-flags-are-supported)    The following flags can be used in pattern modifiers:     | Literal flag | Property name | ES | Description | | --- | --- | --- | --- | | i | ignoreCase | ES3 | Match case-insensitively | | m | multiline | ES3 | `^` and `$` match per line | | s | dotAll | ES2018 | Dot matches line terminators |    For more information, see [‚ÄúRegular expression flags‚Äù (¬ß46.11)](#regexp-flags).    The remaining flags are not supported because they would either make regular expression semantics too complicated (e.g. flag `v`) or because they only make sense if applied to the whole regular expression (e.g. flag `g`).    #### [46.12.3‚ÄÉUse case: changing flags for part of a regular expression](#use-case-changing-flags-for-part-of-a-regular-expression)    It‚Äôs sometimes useful to change flags for part of a regular expression. For example, Ron Buckton [explains](https://github.com/tc39/proposal-regexp-modifiers/issues/1) that changing flag `m` helps with matching a Markdown frontmatter block at the start of a file (I slightly edited his version):    ```js const re = /(?-m:^)---\\r?\\n((?:^(?!---$).*\\r?\\n)*)^---$/m; assert.equal(re.test('---a'), false); assert.equal(re.test('---\\n---'), true); assert.equal(  re.exec('---\\n---')[1],  '' ); assert.equal(  re.exec('---\\na: b\\n---')[1],  'a: b\\n' );  ```    How does this regular expression work?    *   By default, flag `m` is on and the anchor `^` matches at the beginning of a line and the anchor `$` matches at the end of a line. *   The very first `^` is different: It must match at the beginning of a string. That‚Äôs why we use a pattern modifier there and switch flag `m` off.    This is the regular expression, formatted with insignificant whitespace and explanatory comments:    ```js (?-m:^)---\\r?\\n  # first line of string (  # capturing group for the frontmatter  (?:  # pattern for one line (non-capturing group)  ^(?!---$)  # line must not start with \"---\" + EOL (lookahead)  .*\\r?\\n  )* ) ^---$  # closing delimiter of frontmatter  ```    #### [46.12.4‚ÄÉUse case: inlining flags](#use-case-inlining-flags)    In some situations, flags being outside the actual regular expressions is inconvenient. Then pattern modifiers help. Examples include:    *   Storing regular expressions in configuration files, e.g. in JSON format.           *   [The Regex+ library](https://github.com/slevithan/regex) provides a template literal that makes creating regular expressions much more convenient. The syntax for specifying flags adds a bit of clutter that can be avoided via pattern modifiers (if they support the required flags):                    ```js     regex('i')`world`     regex`(?i:world)`          ```              #### [46.12.5‚ÄÉUse case: regular expression fragments that change flags](#use-case-regular-expression-fragments-that-change-flags)    In complex applications, it helps if you can compose large regular expressions out of smaller regular expressions. The aforementioned Regex+ library supports that. If a smaller regular expression needs different flags (e.g. because it wants to ignore case) then it can ‚Äì thanks to pattern modifiers.    ### [46.13‚ÄÉProperties of regular expression objects](#properties-of-regular-expression-objects)    Noteworthy:    *   Strictly speaking, only `.lastIndex` is a real instance property. All other properties are implemented via getters. *   Accordingly, `.lastIndex` is the only mutable property. All other properties are read-only. If we want to change them, we need to copy the regular expression (see [‚ÄúCloning and non-destructively modifying regular expressions‚Äù (¬ß46.1.3)](#cloning-regexps) for details).    #### [46.13.1‚ÄÉFlags as properties](#flags-as-properties)    Each regular expression flag exists as a property with a longer, more descriptive name:    ```js > /a/i.ignoreCase true > /a/.ignoreCase false  ```    This is the complete list of flag properties:    *   `.dotAll` (`/s`) *   `.global` (`/g`) *   `.hasIndices` (`/d`) *   `.ignoreCase` (`/i`) *   `.multiline` (`/m`) *   `.sticky` (`/y`) *   `.unicode` (`/u`) *   `.unicodeSets` (`/v`)    #### [46.13.2‚ÄÉOther properties](#other-properties)    Each regular expression also has the following properties:    *   `.source` ^(ES3): The regular expression pattern                    ```js     > /abc/ig.source     'abc'          ```           *   `.flags` ^(ES6): The flags of the regular expression                    ```js     > /abc/ig.flags     'gi'          ```           *   `.lastIndex` ^(ES3): Used when flag `/g` is switched on. See [‚ÄúThe flags `/g` and `/y`, and the property `.lastIndex` (advanced)‚Äù (¬ß46.16)](#regexp-flags-gy) for details.              ### [46.14‚ÄÉMatch objects](#match-objects)    Several regular expression-related methods return so-called *match objects* to provide detailed information for the locations where a regular expression matches an input string. These methods are:    *   `RegExp.prototype.exec()` returns `null` or a single match object. *   `String.prototype.match()` returns `null` or a single match object (if flag `/g` is not set). *   `String.prototype.matchAll()` returns an iterable of match objects (flag `/g` must be set; otherwise, an exception is thrown).    This is an example:    ```js assert.deepEqual(  /(a+)b/d.exec('ab aaab'),  {  0: 'ab',  1: 'a',  index: 0,  input: 'ab aaab',  groups: undefined,  indices: {  0: [0, 2],  1: [0, 1],  groups: undefined  },  } );  ```    The result of `.exec()` is a *match object* for the first match with the following properties:    *   `[0]`: the complete substring matched by the regular expression *   `[1]`: capture of numbered group 1 (etc.) *   `.index`: where did the match occur? *   `.input`: the string that was matched against *   `.groups`: captures of named groups (see [‚ÄúNamed capture groups ^(ES2018)‚Äù (¬ß46.15.2.1)](#named-capture-groups)) *   `.indices`: the index ranges of captured groups     *   This property is only created if flag `/d` is switched on.    #### [46.14.1‚ÄÉMatch indices in match objects ^(ES2022)](#regexp-match-indices)    *Match indices* are a feature of match objects: If we turn it on via the regular expression flag `/d` (property `.hasIndices`), they record the start and end indices of where groups were captured.    ##### [46.14.1.1‚ÄÉMatch indices for numbered groups](#match-indices-for-numbered-groups)    This is how we access the captures of numbered groups:    ```js const matchObj = /(a+)(b+)/d.exec('aaaabb'); assert.equal(  matchObj[1], 'aaaa' ); assert.equal(  matchObj[2], 'bb' );  ```    Due to the regular expression flag `/d`, `matchObj` also has a property `.indices` that records for each numbered group where it was captured in the input string:    ```js assert.deepEqual(  matchObj.indices[1], [0, 4] ); assert.deepEqual(  matchObj.indices[2], [4, 6] );  ```    ##### [46.14.1.2‚ÄÉMatch indices for named groups](#match-indices-for-named-groups)    The captures of named groups are accessed like this:    ```js const matchObj = /(?<as>a+)(?<bs>b+)/d.exec('aaaabb'); assert.equal(  matchObj.groups.as, 'aaaa' ); assert.equal(  matchObj.groups.bs, 'bb' );  ```    Their indices are stored in `matchObj.indices.groups`:    ```js assert.deepEqual(  matchObj.indices.groups.as, [0, 4] ); assert.deepEqual(  matchObj.indices.groups.bs, [4, 6] );  ```    ##### [46.14.1.3‚ÄÉA more realistic example](#a-more-realistic-example)    One important use case for match indices are parsers that point to where exactly a syntactic error is located. The following code solves a related problem: It points to where quoted content starts and where it ends (see demonstration at the end).    ```js const reQuoted = /‚Äú([^‚Äù]+)‚Äù/dgv; function pointToQuotedText(str) {  const startIndices = new Set();  const endIndices = new Set();  for (const match of str.matchAll(reQuoted)) {  const [start, end] = match.indices[1];  startIndices.add(start);  endIndices.add(end);  }  let result = '';  for (let index=0; index < str.length; index++) {  if (startIndices.has(index)) {  result += '[';  } else if (endIndices.has(index+1)) {  result += ']';  } else {  result += ' ';  }  }  return result; }  `assert.equal(`  `pointToQuotedText(`  `'They said ‚Äúhello‚Äù and ‚Äúgoodbye‚Äù.'),`  `'           [   ]       [     ]  '` `);`  ```   ```js``````", "```````js` ### [46.15‚ÄÉMethods for working with regular expressions](#methods-for-working-with-regular-expressions)    #### [46.15.1‚ÄÉBy default, regular expressions match anywhere in a string](#by-default-regular-expressions-match-anywhere-in-a-string)    By default, regular expressions match anywhere in a string:    ``` > /a/.test('__a__') true  ```js    We can change that by using assertions such as `^` (or by using the flag `/y`):    ``` > /^a/.test('__a__') false > /^a/.test('a__') true  ```js    #### [46.15.2‚ÄÉ`string.match(regExp)` without `/g`: getting a match object for the first match](#String.prototype.match)    Without the flag `/g`, `string.match(regExp)` returns [a match object](#match-objects) for the first match of `regExp` in `str`:    ``` assert.deepEqual(  'ab aab'.match(/(a+)b/),  {  0: 'ab',  1: 'a',  index: 0,  input: 'ab aab',  groups: undefined,  } );  ```js    ##### [46.15.2.1‚ÄÉNamed capture groups ^(ES2018)](#named-capture-groups)    The previous example contained a single numbered group. The following example demonstrates named groups:    ``` assert.deepEqual(  'ab aab'.match(/(?<as>a+)b/),  {  0: 'ab',  1: 'a',  index: 0,  input: 'ab aab',  groups: { as: 'a' },  } );  ```js    In the result of `.match()`, we can see that a named group is also a numbered group ‚Äì its capture exists twice:    *   Once as a numbered capture (property `'1'`). *   Once as a named capture (property `groups.as`).    ##### [46.15.2.2‚ÄÉDuplicate named capture groups ^(ES2025)](#duplicate-named-capture-groups)    Since ECMAScript 2025, we can use the same group name twice ‚Äì as long as it appears in different alternatives:    ``` const RE = /(?<a>a(?<xs>x+))|(?<b>b(?<xs>x+))/v; assert.deepEqual(  'axx'.match(RE).groups,  {  a: 'axx',  xs: 'xx',  b: undefined,  __proto__: null,  } ); assert.deepEqual(  'bxx'.match(RE).groups,  {  a: undefined,  xs: 'xx',  b: 'bxx',  __proto__: null,  } );  ```js    The following is not allowed (group `xs` would match twice):    ``` assert.throws(  () => eval('/(?<a>a(?<xs>x+))(?<b>b(?<xs>x+))/v'),  /^SyntaxError:.* Duplicate capture group name$/ );  ```js    #### [46.15.3‚ÄÉ`string.match(regExp)` with `/g`: getting all group 0 captures ^(ES3)](#stringmatchregexp-with-g-getting-all-group-0-captures-es3)    With flag `/g`, `string.match(regExp)` returns all substrings of `str` that match `regExp`:    ``` > 'ab aab'.match(/(a+)b/g) [ 'ab', 'aab' ]  ```js    If there is no match, `.match()` returns `null`:    ``` > 'xyz'.match(/(a+)b/g) null  ```js    We can use [the nullish coalescing operator (`??`)](ch_undefined-null.html#nullish-coalescing-operator) to protect ourselves against `null`:    ``` const numberOfMatches = (str.match(regExp) ?? []).length;  ```js    We can also use [optional chaining (`?.`)](ch_objects.html#optional-chaining) and combine it with the nullish coalescing operator:    ``` const numberOfMatches = str.match(regExp)?.length ?? 0;  ```js    #### [46.15.4‚ÄÉ`string.matchAll(regExp)`: getting an iterable over all match objects ^(ES2020)](#String.prototype.matchAll)    This is how `.matchAll()` is invoked:    ``` const matchIterable = str.matchAll(regExp);  ```js    Given a string and a regular expression, `.matchAll()` returns an iterable over the match objects of all matches.    In the following example, we use [`Array.from()`](ch_arrays.html#Array.from) to convert iterables to Arrays so that we can compare them better.    ``` > Array.from('-a-a-a'.matchAll(/-(a)/gv)) [  { 0:'-a', 1:'a', index: 0, input: '-a-a-a', groups: undefined },  { 0:'-a', 1:'a', index: 2, input: '-a-a-a', groups: undefined },  { 0:'-a', 1:'a', index: 4, input: '-a-a-a', groups: undefined }, ]  ```js    Flag `/g` must be set:    ``` > Array.from('-a-a-a'.matchAll(/-(a)/v)) TypeError: String.prototype.matchAll called with a non-global RegExp argument  ```js    `.matchAll()` isn‚Äôt affected by `regExp.lastIndex` and doesn‚Äôt change it.    ![Icon ‚Äúexercise‚Äù](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png)‚ÄÇ**Exercise: Extracting quoted text via `.matchAll()`**    `exercises/regexps/extract_quoted_test.mjs`    ##### [46.15.4.1‚ÄÉImplementing `.matchAll()`](#implementing-matchall)    `.matchAll()` could be implemented via `.exec()` as follows:    ``` function* matchAll(str, regExp) {  if (!regExp.global) {  throw new TypeError('Flag /g must be set!');  }  // Preserve and reset flags  const localCopy = new RegExp(regExp, regExp.flags);  let match;  while (match = localCopy.exec(str)) {  yield match;  } }  ```js    Making a local copy ensures two things:    *   `regex.lastIndex` isn‚Äôt changed. *   `localCopy.lastIndex` is zero.    Using `matchAll()`:    ``` const str = '\"fee\" \"fi\" \"fo\" \"fum\"'; const regex = /\"([^\"]*)\"/g;  `for (const match of matchAll(str, regex)) {`  `console.log(match[1]);` `}`  ```js   ``````js```````", "```` Output:    ```js fee fi fo fum  ```    #### [46.15.5‚ÄÉ`regExp.exec(str)`: capturing groups ^(ES3)](#RegExp.prototype.exec)    ##### [46.15.5.1‚ÄÉ`regExp.exec(str)` without `/g`: getting a match object for the first match](#regexpexecstr-without-g-getting-a-match-object-for-the-first-match)    Without flag `/g`, `regExp.exec()` works like `string.match()` ‚Äì it returns a single match object.    ##### [46.15.5.2‚ÄÉ`regExp.exec(str)` with `/g`: looping over all matches](#regexpexecstr-with-g-looping-over-all-matches)    ![Icon ‚Äútip‚Äù](../Images/8440b17bb8219cda9f9405ac83c36db0.png)‚ÄÇ**Better alternative for retrieving all matches: `string.matchAll(regExp)` ^(ES2020)**    Since ECMAScript 2020, JavaScript has another method for retrieving all matches: [`string.matchAll(regExp)`](#String.prototype.matchAll). That method is easier and safer to use: It returns an iterable, is unaffected by `.lastIndex` and throws an exception if flag `/g` is missing.    If we want to retrieve all matches of a regular expression (not just the first one), we need to switch on the flag `/g`. Then we can call `.exec()` multiple times and get one match each time. After the last match, `.exec()` returns `null`.    ```js > const regExp = /(a+)b/g; > regExp.exec('ab aab') { 0: 'ab', 1: 'a', index: 0, input: 'ab aab', groups: undefined } > regExp.exec('ab aab') { 0: 'aab', 1: 'aa', index: 3, input: 'ab aab', groups: undefined } > regExp.exec('ab aab') null  ```    Therefore, we can loop over all matches as follows:    ```js const regExp = /(a+)b/g; const str = 'ab aab';  `let match;` `// Check for null via truthiness` `// Alternative: while ((match = regExp.exec(str)) !== null)` `while (match = regExp.exec(str)) {`  `console.log(match[1]);` `}`  ```   ```js````", "```js```", "``` Output:    ```", "```    #### [46.15.6‚ÄÉ`string.match()` vs. `string.matchAll()` vs. `regExp.exec()`](#match-vs-matchall-vs-exec)    The following table summarizes the differences between three methods:     |  | Without `/g` | With `/g` | | --- | --- | --- | | `string.match(regExp)` | First match object | Array of group 0 captures | | `string.matchAll(regExp)` | `TypeError` | Iterable over match objects | | `regExp.exec(string)` | First match object | Next match object or `null` |    #### [46.15.7‚ÄÉReplacing with `string.replace()` and `string.replaceAll()`](#replace-replaceAll)    Both replacing methods have two parameters:    *   `string.replace(searchValue, replacementValue)` *   `string.replaceAll(searchValue, replacementValue)`    `searchValue` can be:    *   A string *   A regular expression    `replacementValue` can be:    *   String: Replace matches with this string. The character `$` has special meaning and lets us insert captures of groups and more (details are explained later). *   Function: Compute strings that replace matches via this function.    The two methods differ as follows:    *   `.replace()` replaces the first occurrence of a string or a regular expression without `/g`. *   `.replaceAll()` replaces all occurrences of a string or a regular expression with `/g`.    This table summarizes how that works:     | Search for: ‚Üí | string | RegExp w/o `/g` | RegExp with `/g` | | --- | --- | --- | --- | | `.replace` | First occurrence | First occurrence | (All occurrences) | | `.replaceAll` | All occurrences | `TypeError` | All occurrences |    The last column of `.replace()` is in parentheses because this method existed long before `.replaceAll()` and therefore supports functionality that should now be handled via the latter method. If we could change that, `.replace()` would throw a `TypeError` here.    We first explore how `.replace()` and `.replaceAll()` work individually when `replacementValue` is a simple string (without the character `$`). Then we examine how both are affected by more complicated replacement values.    ##### [46.15.7.1‚ÄÉ`string.replace(searchValue, replacementValue)` ^(ES3)](#String.prototype.replace)    How `.replace()` operates is influenced by its first parameter `searchValue`:    *   Regular expression without `/g`: Replace first match of this regular expression.                    ```", "```           *   String: Replace first occurrence of this string (the string is interpreted verbatim, not as a regular expression).                    ```", "```           *   Regular expression with `/g`: Replace all matches of this regular expression.                    ```", "```                    Recommendation: If `.replaceAll()` is available, it‚Äôs better to use that method in this case ‚Äì its purpose is to replace multiple occurrences.              If we want to replace every occurrence of a string, we have two options:    *   We can use `.replaceAll()` (which was introduced in ES2021).           *   Later in this chapter, we will encounter [the tool function `escapeForRegExp()`) which will help us convert a string into a regular expression that matches that string multiple times (e.g., `'*'` becomes `/\\*/g`).              ##### [46.15.7.2‚ÄÉ`string.replaceAll(searchValue, replacementValue)` ^(ES2021)](#String.prototype.replaceAll)    How `.replaceAll()` operates is influenced by its first parameter `searchValue`:    *   Regular expression with `/g`: Replace all matches of this regular expression.                    ```", "```           *   String: Replace all occurrences of this string (the string is interpreted verbatim, not as a regular expression).                    ```", "```           *   Regular expression without `/g`: A `TypeError` is thrown (because the purpose of `.replaceAll()` is to replace multiple occurrences).                    ```", "```              ##### [46.15.7.3‚ÄÉThe parameter `replacementValue` of `.replace()` and `.replaceAll()`](#the-parameter-replacementvalue-of-replace-and-replaceall)    So far, we have only used the parameter `replacementValue` with simple strings, but it can do more. If its value is:    *   A string, then matches are replaced with this string. The character `$` has special meaning and lets us insert captures of groups and more (read on for details).           *   A function, then matches are replaced by strings that are computed via this function.              ##### [46.15.7.4‚ÄÉ`replacementValue` is a string](#replacementvalue-is-a-string)    If the replacement value is a string, the dollar sign has special meaning ‚Äì it inserts text matched by the regular expression:     | Text | Result | | --- | --- | | `$$` | single `$` | | `$&` | complete match | | `` $` `` | text before match | | `$'` | text after match | | `$n` | capture of numbered group `n` (`n` > 0) | | `$<name>` | capture of named group `name` (ES2018) |    Example: Inserting the text before, inside, and after the matched substring.    ```", "```    Example: Inserting the captures of numbered groups.    ```", "```    Example: Inserting the captures of named groups.    ```", "```    ![Icon ‚Äúexercise‚Äù](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png)‚ÄÇ**Exercise: Change quotes via `.replace()` and a named group**    `exercises/regexps/change_quotes_test.mjs`    ##### [46.15.7.5‚ÄÉ`replacementValue` is a function](#replacementvalue-is-a-function)    If the replacement value is a function, we can compute each replacement. In the following example, we multiply each non-negative integer that we find by two.    ```", "```    The replacement function gets the following parameters. Note how similar they are to match objects. These parameters are all positional, but I‚Äôve included how one might name them:    *   `all`: complete match *   `g1`: capture of numbered group 1 *   Etc. *   `index`: where did the match occur? *   `input`: the string in which we are replacing *   `groups` ^(ES2018): captures of named groups (an object). Always the last parameter.    If we are only interested in `groups`, we can use the following technique:    ```", "```    Due to the [rest parameter](ch_callables.html#rest-parameters) in line A, `args` contains an Array with all parameters. We access the last parameter via [the Array method `.at()`](ch_arrays.html#Array.prototype.at) in line B.    #### [46.15.8‚ÄÉ`regExp.test(str)`: is there a match? ^(ES3)](#RegExp.prototype.test)    The regular expression method `regExp.test(str)` returns `true` if `regExp` matches `str`:    ```", "```    With `.test()` we should normally avoid the `/g` flag. If we use it, we generally don‚Äôt get the same result every time we call the method:    ```", "```    The results are due to `/a/` having two matches in the string. After all of those were found, `.test()` returns `false`. For more information, see [‚ÄúThe flags `/g` and `/y`, and the property `.lastIndex` (advanced)‚Äù (¬ß46.16)](#regexp-flags-gy).    #### [46.15.9‚ÄÉ`string.search(regExp)`: at what index is the match? ^(ES3)](#String.prototype.search)    The string method `.search()` returns the first index of `str` at which there is a match for `regExp`:    ```", "```    #### [46.15.10‚ÄÉ`string.split(separator, limit?)`: splitting strings ^(ES3)](#String.prototype.split)    Splits the string into an Array of substrings ‚Äì the strings that occur between the separators.    The separator can be a string:    ```", "```    It can also be a regular expression:    ```", "```    The last invocation demonstrates that captures made by groups in the regular expression become elements of the returned Array.    If we want the separators to be part of the returned string fragments, we can use a regular expression with a [lookbehind assertion](#regexp-lookbehind-assertions) or a [lookahead assertion](#regexp-lookahead-assertions):    ```", "```    Thanks to the lookaround assertions, the regular expression used for splitting leaves the colons in the fragments and only removes the spaces following or preceding the colons.    **Pitfall:** `.split('')` splits into JavaScript characters, but we usually want to split into grapheme clusters or at least Unicode code points. Therefore, it‚Äôs better to use `Intl.Segmenter` or `Array.from()` for splitting. For more information, see [‚ÄúAtoms of text: code points, JavaScript characters, grapheme clusters‚Äù (¬ß22.7)](ch_strings.html#atoms-of-text).    ### [46.16‚ÄÉThe flags `/g` and `/y`, and the property `.lastIndex` (advanced)](#regexp-flags-gy)    In this section, we examine how the RegExp flags `/g` and `/y` work and how they depend on the RegExp property `.lastIndex`. We‚Äôll also discover an interesting use case for `.lastIndex` that you may find surprising.    #### [46.16.1‚ÄÉThe flags `/g` and `/y`](#the-flags-g-and-y)    Every method reacts differently to `/g` and `/y`; this gives us a rough general idea:    *   `/g` (`.global`, ES3): The regular expression should match multiple times, anywhere in a string. *   `/y` (`.sticky`, ES6): Any match inside a string should immediately follow a previous match (the matches ‚Äústick‚Äù¬†together).    If a regular expression has neither the flag `/g` nor the flag `/y`, matching happens once and starts at the beginning.    With either `/g` or `/y`, matching is performed relative to a ‚Äúcurrent position‚Äù inside the input string. That position is stored in the regular expression property `.lastIndex`.    There are three groups of regular-expression-related methods:    1.  The string methods `.search(regExp)` and `.split(regExp)` completely ignore `/g` and `/y` (and therefore also `.lastIndex`).           2.  The `RegExp` methods `.exec(str)` and `.test(str)` change in two ways if either `/g` or `/y` is set.                    First, we get multiple matches, by calling one method repeatedly. Each time, it returns either another result (a match object or `true`) or an ‚Äúend of results‚Äù value (`null` or `false`).                    Second, the regular expression property `.lastIndex` is used to step through the input string. On one hand, `.lastIndex` determines where matching starts:               *   `/g` means that a match must begin at `.lastIndex` or later.                       *   `/y` means that a match must begin at `.lastIndex`. That is, the beginning of the regular expression is anchored to `.lastIndex`.                                    Note that `^` and `$` continue to work as usually: They anchor matches to the beginning or end of the input string, unless `.multiline` is set. Then they anchor to the beginnings or ends of lines.                            On the other hand, `.lastIndex` is set to one plus the last index of the previous match.           3.  The remaining methods are:               *   The string methods `.match(regExp)` and `.matchAll(regExp)` (throws without `/g`)     *   The string methods `.replace(regExp, str)` and `.replaceAll(regExp, str)` (throws without `/g`)          These are all affected as follows:               *   `/g` leads to multiple matches.     *   `/y` leads to a single match that must start at `.lastIndex`.     *   `/gy` leads to multiple matches without gaps.    This was a first overview. The next sections get into more details.    #### [46.16.2‚ÄÉHow exactly are methods affected by `/g` and `/y`?](#how-exactly-are-methods-affected-by-g-and-y)    The following methods are unaffected by `/g` and `/y`:    *   `string.search(regExp)` *   `string.split(regExp)`    ##### [46.16.2.1‚ÄÉ`string.match(regExp)` ^(ES3)](#stringmatchregexp-es3)    Without `/g` and `/y`, `.match()` ignores `.lastIndex` and always returns a match object for the first match.    ```", "```    With `/y`, the match must start at exactly `.lastIndex`. `.lastIndex` is updated. If there is no match, `null` is returned.    ```", "```    With `/g`, we get all matches (group 0) in an Array. `.lastIndex` is ignored and reset to zero.    ```", "```    `/gy` works similarly to `/g`, but no gaps between matches are allowed:    ```", "```    ##### [46.16.2.2‚ÄÉ`string.matchAll(regExp)` ^(ES2020)](#stringmatchallregexp-es2020)    If `/g` is not set, `.matchAll()` throws an exception:    ```", "```    If `/g` is set, matching starts at `.lastIndex` and that property isn‚Äôt changed:    ```", "```    `/gy` works similarly to `/g`, but no gaps between matches are allowed:    ```", "```    ##### [46.16.2.3‚ÄÉ`regExp.exec(str)` ^(ES3)](#regexpexecstr-es3)    Without `/g` and `/y`, `.exec()` ignores `.lastIndex` and always returns a match object for the first match:    ```", "```    With `/g`, the match must start at `.lastIndex` or later. `.lastIndex` is updated. If there is no match, `null` is returned.    ```", "```    With `/y`, the match must start at exactly `.lastIndex`. `.lastIndex` is updated. If there is no match, `null` is returned.    ```", "```    With `/gy`, `.exec()` behaves the same as with `/y`.    ##### [46.16.2.4‚ÄÉ`string.replace(regExp, str)` ^(ES3)](#stringreplaceregexp-str-es3)    Without `/g` and `/y`, only the first occurrence is replaced:    ```", "```    With `/g`, all occurrences are replaced. `.lastIndex` is ignored but reset to zero.    ```", "```    With `/y`, only the (first) occurrence at `.lastIndex` is replaced. `.lastIndex` is updated.    ```", "```    `/gy` works like `/g`, but gaps between matches are not allowed:    ```", "```    ##### [46.16.2.5‚ÄÉ`string.replaceAll(regExp, str)` ^(ES2021)](#stringreplaceallregexp-str-es2021)    `.replaceAll()` works like `.replace()` but throws an exception if `/g` is not set:    ```", "```    ##### [46.16.2.6‚ÄÉ`regExp.test(str)` ^(ES3)](#regexpteststr-es3)    This method behaves the same same as `.exec()`, but instead of returning a match object, it returns `true`, and instead of returning `null`, it returns `false`.    For example, without either `/g` or `/y`, the result is always `true`:    ```", "```    With `/g`, there are two matches:    ```", "```    With `/y`, there is only one match:    ```", "```    With `/gy`, `.test()` behaves the same as with `/y`.    #### [46.16.3‚ÄÉFour pitfalls of `/g` and `/y` and how to deal with them](#four-pitfalls-of-g-and-y-and-how-to-deal-with-them)    We will first look at four pitfalls of `/g` and `/y` and then at ways of dealing with those pitfalls.    ##### [46.16.3.1‚ÄÉPitfall 1: We can‚Äôt inline a regular expression with `/g` or `/y`](#pitfall-1-we-cant-inline-a-regular-expression-with-g-or-y)    A regular expression with `/g` can‚Äôt be inlined. For example, in the following `while` loop, the regular expression is created fresh, every time the condition is checked. Therefore, its `.lastIndex` is always zero and the loop never terminates.    ```", "```    With `/y`, the problem is the same.    ##### [46.16.3.2‚ÄÉPitfall 2: Removing `/g` or `/y` can break code](#pitfall-2-removing-g-or-y-can-break-code)    If code expects a regular expression with `/g` and has a loop over the results of `.exec()` or `.test()`, then a regular expression without `/g` can cause an infinite loop:    ```", "```    Why is there an infinite loop? Because `.exec()` always returns the first result, a match object, and never `null`.    With `/y`, the problem is the same.    ##### [46.16.3.3‚ÄÉPitfall 3: Adding `/g` or `/y` can break code](#pitfall-3-adding-g-or-y-can-break-code)    With `.test()`, there is another caveat: It is affected by `.lastIndex`. Therefore, if we want to check exactly once if a regular expression matches a string, then the regular expression must not have `/g`. Otherwise, we generally get a different result every time we call `.test()`:    ```", "```    The first invocation produces a match and updates `.lastIndex`. The second invocation does not find a match and resets `.lastIndex` to zero.    If we create a regular expression specifically for `.test()`, then we probably won‚Äôt add `/g`. However, the likeliness of encountering `/g` increases if we use the same regular expression for replacing and for testing.    Once again, this problem also exists with `/y`:    ```", "```    ##### [46.16.3.4‚ÄÉPitfall 4: Code can produce unexpected results if `.lastIndex` isn‚Äôt zero](#pitfall-4-code-can-produce-unexpected-results-if-lastindex-isnt-zero)    If an operation uses regular expression methods that are affected by `.lastIndex`, then we must ensure that `.lastIndex` is zero at the beginning. Otherwise, we may get unexpected results:    ```", "```   ```", "```````js````` Normally, `.lastIndex` is zero in newly created regular expressions and we won‚Äôt change it explicitly like we did in the example. But `.lastIndex` can still end up not being zero if we use the regular expression multiple times.    ##### [46.16.3.5‚ÄÉHow to avoid the pitfalls of `/g` and `/y`](#how-to-avoid-the-pitfalls-of-g-and-y)    As an example of dealing with `/g` and `.lastIndex`, we revisit `countMatches()` from the previous example. How do we prevent a wrong regular expression from breaking our code? Let‚Äôs look at three approaches.    ###### [46.16.3.5.1‚ÄÉThrowing exceptions](#throwing-exceptions)    First, we can throw an exception if `/g` isn‚Äôt set or `.lastIndex` isn‚Äôt zero:    ```js function countMatches(regExp, str) {  if (!regExp.global) {  throw new Error('Flag /g of regExp must be set');  }  if (regExp.lastIndex !== 0) {  throw new Error('regExp.lastIndex must be zero');  }   let count = 0;  while (regExp.test(str)) {  count++;  }  return count; }  ```    ###### [46.16.3.5.2‚ÄÉCloning regular expressions](#cloning-regular-expressions)    Second, we can clone the parameter. That has the added benefit that `regExp` won‚Äôt be changed.    ```js function countMatches(regExp, str) {  const cloneFlags = regExp.flags + (regExp.global ? '' : 'g');  const clone = new RegExp(regExp, cloneFlags);  `let count = 0;`  `while (clone.test(str)) {`  `count++;`  `}`  `return count;` `}`  ```   ```js```````", "```` ###### [46.16.3.5.3‚ÄÉUsing an operation that isn‚Äôt affected by `.lastIndex` or flags](#using-an-operation-that-isnt-affected-by-lastindex-or-flags)    Several regular expression operations are not affected by `.lastIndex` or by flags. For example, `.match()` ignores `.lastIndex` if `/g` is present:    ```js function countMatches(regExp, str) {  if (!regExp.global) {  throw new Error('Flag /g of regExp must be set');  }  return (str.match(regExp) ?? []).length; }  `const myRegExp = /a/g;` `myRegExp.lastIndex = 4;` `assert.equal(countMatches(myRegExp, 'babaa'), 3); // OK!`  ```   ```js````", "```js```", "``` function startsWith(regExp, str, index) {  if (!regExp.sticky || regExp.global) {  throw new Error('Flag /y must be set. Flag /g must not be set.');  }  regExp.lastIndex = index;  return regExp.test(str); } assert.equal(  startsWith(/x+/y, 'aaxxx', 0), false ); assert.equal(  startsWith(/x+/y, 'aaxxx', 2), true );  ```", "``` > '#--#'.search(/#/) 0  ```", "``` function searchFrom(regExp, str, index) {  if (!regExp.global || regExp.sticky) {  throw new Error('Flag /g must be set. Flag /y must not be set.');  }  regExp.lastIndex = index;  const match = regExp.exec(str);  if (match) {  return match.index;  } else {  return -1;  } }  `assert.equal(`  `searchFrom(/#/g, '#--#', 0), 0` `);` `assert.equal(`  `searchFrom(/#/g, '#--#', 1), 3` `);`  ```", "``````js``````", "```js function replaceOnceAt(str, regExp, replacement, index) {  if (!regExp.sticky || regExp.global) {  throw new Error('Flag /y must be set. Flag /g must not be set.');  }  regExp.lastIndex = index;  return str.replace(regExp, replacement); } assert.equal(  replaceOnceAt('aa aaaa a', /a+/y, 'X', 0), 'X aaaa a') ; assert.equal(  replaceOnceAt('aa aaaa a', /a+/y, 'X', 3), 'aa X a' ); assert.equal(  replaceOnceAt('aa aaaa a', /a+/y, 'X', 8), 'aa aaaa X' );  ```", "```js > RegExp.escape('(*)') '\\\\(\\\\*\\\\)'  ```", "```js > '\\\\(\\\\*\\\\)' === String.raw`\\(\\*\\)` true  ```", "```js > RegExp.escape('_abc123') '_abc123'  ```", "```js function replacePlainText(str, searchText, replace) {  const searchRegExp = new RegExp(  RegExp.escape(searchText),  'gu'  );  return str.replace(searchRegExp, replace) } assert.equal(  replacePlainText('(a) and (a)', '(a)', '@'),  '@ and @' );  ```", "```js assert.equal(  '(a) and (a)'.replaceAll('(a)', '@'),  '@ and @' );  ```", "```js function removeUnquotedText(str, text) {  const regExp = new RegExp(  `(?<!‚Äú)${RegExp.escape(text)}(?!‚Äù)`,  'gu'  );  return str.replaceAll(regExp, '‚Ä¢'); } assert.equal(  removeUnquotedText('‚Äúyes‚Äù and yes and ‚Äúyes‚Äù', 'yes'),  '‚Äúyes‚Äù and ‚Ä¢ and ‚Äúyes‚Äù' );  ```", "```js     > /(?:)/.test('')     true     > /(?:)/.test('abc')     true          ```", "```js     > /.^/.test('')     false     > /.^/.test('abc')     false          ```", "```js > new RegExp('') /(?:)/  ```", "```js const RE_API_SIGNATURE =  /^(new |get )?([A-Za-z0-9_.\\[\\]]+)/;  ```", "```js const RE_API_SIGNATURE =  /^(new |get )?([A-Za-z0-9_.\\[\\]]+)/v;  ```", "```js /pattern/giv  ```", "```js > String(/pattern/vgi) '/pattern/giv'  ```", "```js const RE_API_SIGNATURE =  /^(?<prefix>new |get )?(?<name>[A-Za-z0-9_.\\[\\]]+)/;  ```", "```js import {regex} from 'regex';  `` const RE_API_SIGNATURE = regex` ``  `^`  `(?<prefix>`  `new \\x20  # constructor`  `|`  `get \\x20  # getter`  `)?`  `(?<name>`  `# Square brackets are needed for symbol keys`  `[`  `A-Z a-z 0-9 _`  `.`  `\\[ \\]`  `]+`  `)` `` `; ``  ```", "```js```", "````js` The feature of ignoring whitespace in regular expression patterns is called *insignificant whitespace*. Additionally, we used a feature called *inline comments* ‚Äì which are started by hash symbols (`#`).    Two observations:    *   Since all spaces are removed, we use the hex escape `\\x20` to express that there is a space after `new` and after `get`. *   Alas, line comments are not allowed inside character classes. That‚Äôs why the comment about square brackets comes before the character class.    In the future, JavaScript may get built-in support for insignificant whitespace via a flag `/x` ([ECMAScript proposal](https://github.com/tc39/proposal-regexp-x-mode)).    With the `regex` template tag, the following flags are always active:    *   Flag `/v` *   Flag `/x` (emulated) enables insignificant whitespace and line comments via `#`. *   Flag `/n` (emulated) enables *named capture only mode*, which prevents numbered groups from capturing. In other words: `(pattern)` is treated like `(?:pattern)`.    #### [46.19.5‚ÄÉTip: Write tests for your regular expression](#tip-write-tests-for-your-regular-expression)    To make sure that a regular expression works as intended, we can write tests for it. These are tests for `RE_API_SIGNATURE`:    ``` assert.deepEqual(  getCaptures(`get Map.prototype.size`),  {  prefix: 'get ',  name: 'Map.prototype.size',  } ); assert.deepEqual(  getCaptures(`new Array(len = 0)`),  {  prefix: 'new ',  name: 'Array',  } ); assert.deepEqual(  getCaptures(`Array.prototype.push(...items)`),  {  prefix: undefined,  name: 'Array.prototype.push',  } ); assert.deepEqual(  getCaptures(`Map.prototype[Symbol.iterator]()`),  {  prefix: undefined,  name: 'Map.prototype[Symbol.iterator]',  } );  `function getCaptures(apiSignature) {`  `const match = RE_API_SIGNATURE.exec(apiSignature);`  `// Spread so that the result does not have a null prototype`  `// and is easier to compare.`  `return {...match.groups};` `}`  ```js   ````", "```` #### [46.19.6‚ÄÉTip: Mention examples in your documentation](#tip-mention-examples-in-your-documentation)    Seeing strings that match, helps with understanding what a regular expression is supposed to do:    ```js /**  * Matches API signatures ‚Äì e.g.:  * ```  * `get Map.prototype.size`  * `new Array(len = 0)`  * `Array.prototype.push(...items)`  * `Map.prototype[Symbol.iterator]()`  * ```js  */ const RE_API_SIGNATURE = regex`  ¬∑¬∑¬∑ `;  ```    Some documentation tools let us refer to unit tests in doc comments and show their code in the documentation. That‚Äôs a good alternative to what we have done above.    #### [46.19.7‚ÄÉBonus tip: Use interpolation to reuse patterns](#bonus-tip-use-interpolation-to-reuse-patterns)    The Regex+ library lets us interpolate regular expression fragments (‚Äúpatterns‚Äù), which helps with reuse. The following example defines a simple markup syntax that is reminiscent of HTML:    ```js import { pattern, regex } from 'regex';  ``const LABEL = pattern`[a-z\\-]+`;`` `` const ARGS = pattern` ``  `(?<args>`  `\\x20+`  `${LABEL}`  `)*` `` `; `` `` const NAME = pattern` ``  `(?<name> ${LABEL} )` `` `; ``  ````", "```js `assert.deepEqual(`  `TAG.exec('[pre js line-numbers]').groups,`  `{`  `openingTag: '[pre js line-numbers]',`  `name: 'pre',`  `args: ' line-numbers',`  `singletonTag: undefined,`  `__proto__: null,`  `}` `);`  `` `assert.deepEqual(`  `TAG.exec('[hr /]').groups,`  `{`  `openingTag: undefined,`  `name: 'hr',`  `args: undefined,`  `singletonTag: '[hr /]',`  `__proto__: null,`  `}` `);` `` ```", "```js`  ```", "```js```", "``` ```", "````` The regular expression `TAG` uses the regular expression fragments `NAME` and `ARGS` twice ‚Äì¬†which reduces redundancy.    #### [46.19.8‚ÄÉBonus tip: insignificant whitespace without a library](#bonus-tip-insignificant-whitespace-without-a-library)    With the following trick, we don‚Äôt need a library to write a regular expression with insignificant whitespace:    ```js const RE_API_SIGNATURE = new RegExp(  String.raw`  ^  (?<prefix>  new \\x20  |  get \\x20  )?  (?<name>  [  A-Z a-z 0-9 _  .  \\[ \\]  ]+  )  `.replaceAll(/\\s+/g, ''), // (A)  'v' ); assert.equal(  String(RE_API_SIGNATURE),  String.raw`/^(?<prefix>new\\x20|get\\x20)?(?<name>[A-Za-z0-9_.\\[\\]]+)/v` );  ```    How does this code work?    *   [`String.raw`](ch_template-literals.html#raw-string-literals) enables two things:     *   We don‚Äôt have to escape regular expression backslashes for this kind of string literal.     *   The regular expression can span multiple lines. *   `.replaceAll()` removes all whitespace (spaces, tabs, line breaks, etc.) so that the end result looks almost like the initial version of the regular expression. There is one difference, though: Since literal spaces are removed, we have to find a different way to specify that there is a space after `new` and after `get`. One option is the hex escape `\\x20`: hexadecimal 20 (decimal 32) is the code point SPACE.    We can even emulate inline comments like this:    ```js // Template tag function const cmt = () => ''; const RE = new RegExp(  String.raw`  a+ ${cmt`one or more as`}  `.replaceAll(/\\s+/g, ''),  'v' ); assert.equal(  String(RE), '/a+/v' );  ```    Alas, it‚Äôs more syntactically noisy than I‚Äôd like.    #### [46.19.9‚ÄÉConclusion: This is how regular expressions are meant to be written](#conclusion-this-is-how-regular-expressions-are-meant-to-be-written)    One reason why many people don‚Äôt like regular expressions is that they find them difficult to read. However, that is much less of a problem with insignificant whitespace and comments. I‚Äôd argue that is the proper way of writing regular expressions: Think what JavaScript code would look like if we had to write it without whitespace and comments.    ### [46.20‚ÄÉQuick reference: regular expression functionality](#quickref-RegExp)    #### [46.20.1‚ÄÉSummary: `.global` (`/g`) and `.sticky` (`/y`)](#summary-flags-global-sticky)    The following two methods are completely unaffected by `/g` and `/y`:    *   `String.prototype.search()` *   `String.prototype.split()`    This table explains how the remaining regular-expression-related methods are affected by these two flags (if neither `/g` nor `/y` are there, `regExp.lastIndex` is always ignored):     |  | Flags | Honors `.lastIndex`? | Updates `.lastIndex`? | | --- | --- | --- | --- | | `s.match` | `/y` | ‚úî | ‚úî | |  | `/g /gy` | ‚úò | 0 | | `s.matchAll` | `/g /gy` | ‚úî | ‚úò | | `r.exec` | `/g /y /gy` | ‚úî | ‚úî | | `s.replace` | `/y` | ‚úî | ‚úî | |  | `/g /gy` | ‚úò | 0 | | `s.replaceAll` | `/g /gy` | ‚úò | 0 | | `r.test` | `/g /y /gy` | ‚úî | ‚úî |    ![Icon ‚Äúexternal‚Äù](../Images/38e6ff55e8d602659f3cdb8893e63f62.png)‚ÄÇ**A longer overview**    I posted [a longer table](https://gist.github.com/rauschma/5c90e6c19923611521a61e199d8cb15b) online that was created via a Node.js script.    #### [46.20.2‚ÄÉ`String.prototype.*`: matching and searching](#stringprototype-matching-and-searching)    *   `String.prototype.match(regExpOrString)`     ES3 | `/y` honors and updates `.lastIndex` | `/g /gy` ignore and reset `.lastIndex`               *   (1 of 3) `regExpOrString` is a string.                                    If `regExpOrString` is a string, it defines a pattern for a regular expression without `/g` (think parameter of `new RegExp()`). That regular expression is used as explained in the next list item.                       *   (2 of 3) `regExpOrString` is a RegExp without `/g`.                                    ```js         match(          regExpOrString: string | RegExp         ): null | RegExpMatchArray          `interface RegExpMatchArray extends Array<string> {`          `index: number;`          `input: string;`          `groups: undefined | {`          `[key: string]: string`          `};`         `}`          ```                   ```js` If `regExpOrString` is a regular expression with flag `/g` not set, then `.match()` returns the first match for `regExpOrString` within the string. Or `null` if there is no match.    *   Numbered capture groups become Array elements (which is why `RegExpMatchArray` extends `Array`). *   [Named capture groups](#named-capture-groups) ^(ES2018) become properties of `.groups`.    Examples:    ``` > 'ababb'.match(/a(b+)/) { 0: 'ab', 1: 'b', index: 0, input: 'ababb', groups: undefined } > 'ababb'.match(/a(?<bs>b+)/) { 0: 'ab', 1: 'b', index: 0, input: 'ababb', groups: { bs: 'b' } } > 'abab'.match(/x/) null  ```js ````      ```js` *   (3 of 3) `regExpOrString` is RegExp with `/g`.                    ```     match(      regExpOrString: RegExp     ): null | Array<string>          ```js                    If flag `/g` of `regExpOrString` is set, `.match()` returns either an Array with all matches or `null` if there was no match.                    ```     > 'ababb'.match(/a(b+)/g)     [ 'ab', 'abb' ]     > 'ababb'.match(/a(?<bs>b+)/g)     [ 'ab', 'abb' ]     > 'abab'.match(/x/g)     null          ```js ````  ```js` *   `String.prototype.matchAll(regExp)`     ES2020 | `/g /gy` honor and preserve `.lastIndex`                    ```     matchAll(regexp: RegExp): Iterator<RegExpExecArray>     interface RegExpMatchArray extends Array<string> {      index: number;      input: string;      groups: undefined | {      [key: string]: string      };     }          ```js               *   Throws an exception if flag `/g` is not set.     *   Returns an iterator over zero or more matches. Per match:         *   Numbered capture groups become Array elements (which is why `RegExpMatchArray` extends `Array`).         *   [Named capture groups](#named-capture-groups) ^(ES2018) become properties of `.groups`.          Example:                    ```     > 'yes'.matchAll(/(y|s)/gv).toArray()     [      { 0: 'y', 1: 'y', index: 0, input: 'yes', groups: undefined },      { 0: 's', 1: 's', index: 2, input: 'yes', groups: undefined },     ]          ```js          *   `String.prototype.search(regExpOrString)`     ES3 | Ignores `.lastIndex`                    Returns the index at which `regExpOrString` occurs within the string. If `regExpOrString` is a string, it is used to create a regular expression (think parameter of `new RegExp()`).                    ```     > 'a2b'.search(/[0-9]/)     1     > 'a2b'.search('[0-9]')     1          ```js ````    ```js```` #### [46.20.3‚ÄÉ`String.prototype.*`: splitting and replacing](#stringprototype-splitting-and-replacing)    *   `String.prototype.split(separator, limit?)`     ES3 | Ignores `.lastIndex`                    ```js     split(separator: string | RegExp, limit?: number): Array<string>          ```                    The separator can be a string (which is interpreted as plain text, not as a regular expression pattern) or a regular expression.                    Examples:                    ```js     // Splitting with a string     assert.deepEqual(      'a.b.c'.split('.'),      [ 'a', 'b', 'c' ]     );      `// Splitting with a regular expression`     `assert.deepEqual(`      `'a x:yyy b'.split(/x+:y+/),`      `[ 'a ', ' b' ]`     `);`      `` `// Group captures appear in the result` `assert.deepEqual(`  `'a x:yyy b'.split(/(x+):(y+)/),`  `[ 'a ', 'x', 'yyy', ' b' ]` `);` ``      ```           ```js`` ````If we want the separators to be part of the returned string fragments, we can use a regular expression with a [lookbehind assertion](#regexp-lookbehind-assertions) or a [lookahead assertion](#regexp-lookahead-assertions):    ```js > 'a: b: c'.split(/(?<=:) */) [ 'a:', 'b:', 'c' ] > 'a :b :c'.split(/ *(?=:)/) [ 'a', ':b', ':c' ]  ```    **Pitfall:** `.split('')` splits into JavaScript characters, but we usually want to split into grapheme clusters or at least Unicode code points. Therefore, it‚Äôs better to use `Array.from()` or `Intl.Segmenter` for splitting. For more information, see [‚ÄúAtoms of text: code points, JavaScript characters, grapheme clusters‚Äù (¬ß22.7)](ch_strings.html#atoms-of-text).```js` `````", "```js`` ```", "```js         replace(          searchValue: string | RegExp,          replaceValue: string | (...args: any[]) => string         ): string                  ```", "```js         > 'x.x.'.replace('.', '#') // interpreted literally         'x#x.'         > 'x.x.'.replace(/./, '#')         '#.x.'                  ```", "```js         replace(          searchValue: RegExp,          replaceValue: string | (...args: any[]) => string         ): string                  ```", "```js         > 'x.x.'.replace(/./g, '#')         '####'         > 'x.x.'.replace(/\\./g, '#')         'x#x#'                  ```", "```js         replaceAll(          searchValue: string | RegExp,          replaceValue: string         ): string                  ```", "```js         > 'x.x.'.replaceAll('.', '#') // interpreted literally         'x#x#'         > 'x.x.'.replaceAll(/./g, '#')         '####'         > 'x.x.'.replaceAll(/./, '#')         TypeError: String.prototype.replaceAll called with         a non-global RegExp argument                  ```", "```js         replaceAll(          searchValue: string | RegExp,          replaceValue: (...args: any[]) => string         ): string                  ```", "```js         const regexp = /([0-9]{2})\\.([0-9]{4})/g;         const replacer = (all, month, year) => `|${year}-${month}|`;         assert.equal(          'a 12.1995 b'.replaceAll(regexp, replacer),          'a |1995-12| b'         );                  ```", "```js         const regexp = /(?<month>[0-9]{2})\\.(?<year>[0-9]{4})/g;         const replacer = (...args) => {          const groups = args.at(-1);          return `|${groups.year}-${groups.month}|`;         };         assert.equal(          'a 12.1995 b'.replaceAll(regexp, replacer),          'a |1995-12| b'         );                  ```", "```js` ```", "```js```", "````` #### [46.20.4‚ÄÉ`RegExp.prototype.*`](#regexpprototype)    *   `RegExp.prototype.test(string)`     ES3 | `/g /y /gy` honor and update `.lastIndex`                    ```js     test(string: string): boolean          ```                    Returns `true` if the receiver matches `string`:                    ```js     > /^# /.test('# comment')     true     > /^# /.test('#comment')     false     > /^# /.test('abc')     false          ```                    **Pitfall:** Don‚Äôt use this method with a regular expression that has flag `/g`. Then `regExp.test()` starts matching at `regExp.lastIndex` and also updates that property.           *   `RegExp.prototype.exec(string)`     ES3 | `/g /y /gy` honor and update `.lastIndex`               *   (1 of 2) Receiver is a RegExp without `/g`.                                    Without flag `/g`, `regExp.exec(string)` works like [`string.match(regExp)`](#qref-String.prototype.match) ‚Äì it returns a single match object.                       *   (2 of 2) Receiver is a RegExp with `/g`.                                    ```js         exec(string: string): RegExpExecArray | null          `interface RegExpExecArray extends Array<string> {`          `index: number;`          `input: string;`          `groups: undefined | {`          `[key: string]: string`          `};`         `}`          ```                   ```js` If `regExp` has flag `/g` then `regExp.exec(str)` returns an object for the first match starting at `regExp.lastIndex` ‚Äì or `null` if it can‚Äôt find a match. It also updates `regExp.lastIndex` so that it points to the index after the match.    *   Numbered capture groups become Array elements (which is why `RegExpExecArray` extends `Array`). *   [Named capture groups](#named-capture-groups) ^(ES2018) become properties of `.groups`.    Examples:    ``` > const regExp = /(a+)b/g, str = 'ab aab';  `> regExp.exec(str)` `{0: 'ab', 1: 'a', index: 0, input: 'ab aab', groups: undefined}` `> regExp.lastIndex` `2`  ```js `> regExp.exec(str)` `{0: 'aab', 1: 'aa', index: 3, input: 'ab aab', groups: undefined}` `> regExp.lastIndex` `6`  `` `> regExp.exec(str)` `null` `> regExp.lastIndex` `0` `` ```  ```js ```` ```js`` `````", "``````js` ``````", "``````js``` ``````", "```` ```js````", "```js` ```", "```js```", "``` ```", "```````js``` ``````js```````", "``````js``````", "``````js``````", "``` ```", "```js```", "````js````", "```js```", "````js````", "```js` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "``````js``````", "```````js` ``````js```````", "```````js`` ``````js```````", "```````js``` ``````js```````", "```````js```` ```js```````", "```````js```````", "``````js``````", "```````js`````` ```js```````", "```````js```````", "``` ```", "```js```", "````js````", "```js```"]