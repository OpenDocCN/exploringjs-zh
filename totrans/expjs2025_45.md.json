["```js\nconst emptySet = new Set();\nassert.equal(emptySet.size, 0);\n\n```", "```js\nconst set = new Set(['red', 'green', 'blue']);\n\n```", "```js\nconst set = new Set()\n.add('red')\n.add('green')\n.add('blue');\n\n```", "```js\nconst set = new Set();\nset.add('red');\n\n```", "```js\nassert.equal(set.has('red'), true);\n\n```", "```js\nassert.equal(set.delete('red'), true); // there was a deletion\nassert.equal(set.has('red'), false);\n\n```", "```js\nconst set = new Set()\n .add('foo')\n .add('bar');\nassert.equal(set.size, 2)\n\n```", "```js\nset.clear();\nassert.equal(set.size, 0)\n\n```", "```js\nassert.deepEqual(\n new Set(['a', 'b']).union(new Set(['b', 'c'])),\n new Set(['a', 'b', 'c'])\n);\n\n```", "```js\nassert.deepEqual(\n new Set(['a', 'b']).intersection(new Set(['b', 'c'])),\n new Set(['b'])\n);\n\n```", "```js\nassert.deepEqual(\n new Set(['a', 'b']).difference(new Set(['b', 'c'])),\n new Set(['a'])\n);\n\n```", "```js\nassert.deepEqual(\n new Set(['a', 'b']).symmetricDifference(new Set(['b', 'c'])),\n new Set(['a', 'c'])\n);\nassert.deepEqual(\n new Set(['a', 'b']).symmetricDifference(new Set(['c', 'd'])),\n new Set(['a', 'b', 'c', 'd'])\n);\n\n```", "```js\nassert.deepEqual(\n new Set(['a', 'b']).isSubsetOf(new Set(['a', 'b', 'c'])),\n true\n);\n\n```", "```js\nassert.deepEqual(\n new Set(['a', 'b', 'c']).isSupersetOf(new Set(['a', 'b'])),\n true\n);\n\n```", "```js\nassert.deepEqual(\n new Set(['a', 'b', 'c']).isDisjointFrom(new Set(['x'])),\n true\n);\n\n```", "```js\ninterface SetLike<T> {\n /** Can be `Infinity` (see next section). */\n size: number;\n\n has(key: T): boolean;\n ``/** Returns an iterator for the elements in `this`. */``\n ``keys(): Iterator<T>; // only method `.next()` is required``\n`}` \n```", "```js```", "````js #### [38.4.1 Examples: finite Set-like objects](#examples-finite-setlike-objects)    Let’s implement a simple Set-like object and use it with methods whose parameters are “other Sets”:    ``` const setLike = {  size: 1,  has(x) { return x === 'b' },  * keys() { yield 'b' }, };  `assert.deepEqual(`  `new Set(['a', 'b', 'c']).difference(setLike),`  `new Set(['a', 'c']),` `);` `assert.deepEqual(`  `new Set(['a', 'b', 'c']).difference(setLike),`  `new Set(['a', 'c']),` `);` `assert.equal(`  `new Set(['a', 'b', 'c']).isSupersetOf(setLike),`  `true,` `);` `assert.equal(`  `new Set(['b']).isSubsetOf(setLike),`  `true,` `);`  ```js   ````", "``` Maps are also Set-like:    ```", "```js    #### [38.4.2 Examples: infinite Set-like data](#infinite-sets)    The `.size` of `other` can be `Infinity`. That means we can work with infinite Sets:    ```", "```js    This works because these methods only invoke `other.keys()` if `other.size` is smaller than `this.size`.    Only two methods don’t support `other` being an infinite Set:    *   `union` *   `symmetricDifference`    #### [38.4.3 FAQ: Set-like objects](#faq-setlike-objects)    *   Why use the interface `SetLike` for `other`?               *   Due to the interface, `other` can be a data structure that is not a Set. It was chosen as a compromise between accepting only Sets and all iterable objects. *   Why does JavaScript always enforce the full interface `SetLike` for `other` and throws an exception if a property is missing or has the wrong dynamic type?               *   That makes the API simpler and hides implementation details. *   Why was method `.keys()` chosen for iterating over elements?               *   That’s due to compatibility with the only Set-like data structure currently in the standard library – `Map`. Two other Set methods would have been nicer but can’t be used with Maps:         *   The Map method `.[Symbol.iterator]()` returns key-value pairs.         *   The Map method `.values()` is incompatible with the Map method `.has()` (which accepts keys, not values).    Source: [TC39 proposal](https://github.com/tc39/proposal-set-methods/blob/main/details.md)    ### [38.5 Iterating over Sets](#iterating-over-sets-1)    Sets are iterable and the `for-of` loop works as we’d expect:    ```", "```js    Output:    ```", "```js    As we can see, Sets preserve *insertion order*. That is, elements are always iterated over in the order in which they were added.    #### [38.5.1 Converting a Set to an Array](#converting-set-to-array)    Sets are iterable, which is why we can use `Array.from()` to convert a Set to an Array:    ```", "```js   ```", "```js`` We can also perform the conversion via an iterator:    ```", "```js    *   `set.values()` returns in iterator for the values of `set`. *   The iterator method `.toArray()` creates an Array with the iterated values.    #### [38.5.2 Mapping and filtering Sets via iterator methods](#applying-iterator-methods-to-sets)    Sets don’t have a method `.map()`. But we can borrow the one that iterators have:    ```", "```js    The previous code shows a common pattern for using iterator methods with Sets:    *   `set.values()` returns an iterator for `set` (line B). *   `.map()` is an iterator method that returns an iterator (line B). *   The result of the previous step is an iterable iterator. It is passed to the constructor `Set` which accepts any iterable as a parameter and uses it to fill the new Set with values.    Filtering Sets works the same way:    ```", "```js    What if we can’t use iterator methods? Then we can switch to Array methods:    *   We use `Array.from(set)` *   instead of `set.values()`.    #### [38.5.3 Example: combining Sets via iteration ^(ES2025)](#combining-sets-via-iteration)    Instead of the Set methods, we can also use iteration to combine Sets:    ```", "```js `// Intersection` `assert.deepEqual(`  `new Set(a.values().filter(x => b.has(x))),`  `new Set([2, 3])` `);`  `` `// Difference` `assert.deepEqual(`  `new Set(a.values().filter(x => !b.has(x))),`  `new Set([1])` `);` `` ```", "```js   ```", "```js` ```", "```js #### [38.5.4 Grouping Set elements ^(ES2024)](#grouping-set-elements-es2024)    Grouping via `Object.groupBy()` and `Map.groupBy()` works for any iterable object and therefore for Sets:    ```", "```js    More information: [“Grouping iterables ^(ES2024)” (§32.8)](ch_sync-iteration.html#grouping-sync-iterables)    ### [38.6 Examples of using Sets](#examples-of-using-sets)    #### [38.6.1 Removing duplicates from an Array](#removing-duplicates-from-an-array)    Converting an Array to a Set and back, removes duplicates from the Array:    ```", "```js    #### [38.6.2 Creating a set of Unicode characters (code points)](#creating-a-set-of-unicode-characters-code-points)    Strings are iterable and can therefore be used as parameters for `new Set()`:    ```", "```js    ### [38.7 Details of the Set API (advanced)](#details-of-the-set-api-advanced)    #### [38.7.1 What Set elements are considered equal?](#what-set-elements-are-considered-equal)    As with Map keys, Set elements are compared similarly to `===`, with the exception of `NaN` being equal to itself.    ```", "```js    As with `===`, two different objects are never considered equal (and there is no way to change that at the moment):    ```", "```js   ```", "```js` #### [38.7.2 FAQ: Set API](#faq-set-api)    *   Why do Sets have a `.size`, while Arrays have a `.length`?               *   The answer to this question is given in [“Why do Maps have a `.size`, while Arrays have a `.length`?” (§36.7.4)](ch_maps.html#collection-size-vs-length). *   Why are some method names verbs and others nouns? This is a rough general rule:               *   Verb methods mutate `this` – e.g.: `set.add()` and `set.clear()`     *   Noun methods return new data – e.g.: `set.values()` and `set.union()`    ### [38.8 Quick reference: `Set`](#quickref-sets)    #### [38.8.1 `new Set()`](#new-set)    *   `new Set(iterable)` ES6               *   If we don’t provide the parameter `values`, then an empty Set is created.     *   If we do, then the iterated values are added as elements to the Set.          ```", "```js              #### [38.8.2 `Set.prototype.*`: working with single Set elements](#setprototype-working-with-single-set-elements)    *   `Set.prototype.add(value)` ES6               *   Adds `value` to this Set.     *   This method returns `this`, which means that it can be chained.          ```", "```js           *   `Set.prototype.delete(value)` ES6               *   Removes `value` from this Set.     *   Returns `true` if something was deleted and `false`, otherwise.          ```", "```js           *   `Set.prototype.has(value)` ES6                    Returns `true` if `value` is in this Set and `false` otherwise.                    ```", "```js              #### [38.8.3 `Set.prototype.*`: working with all Set elements](#setprototype-working-with-all-set-elements)    *   `get Set.prototype.size` ES6                    Returns how many elements there are in this Set.                    ```", "```js           *   `Set.prototype.clear()` ES6                    Removes all elements from this Set.                    ```", "```js              #### [38.8.4 `Set.prototype.*`: iterating and looping](#setprototype-iterating-and-looping)    *   `Set.prototype.values()` ES6                    Returns an iterable over all elements of this Set.                    ```", "```js                    Output:                    ```", "```js           *   `Set.prototype[Symbol.iterator]()` ES6                    Default way of iterating over Sets. Same as `.values()`.                    ```", "```js                    Output:                    ```", "```js           *   `Set.prototype.forEach(callback, thisArg?)` ES6                    ```", "```js                    Feeds each element of this Set to `callback()`. `value` and `key` both contain the current element. This redundancy was introduced so that this `callback` has the same type signature as the `callback` of `Map.prototype.forEach()`.                    We can specify the `this` of `callback` via `thisArg`. If we omit it, `this` is `undefined`.                    ```", "```js                    Output:                    ```", "```js              ##### [38.8.4.1 Symmetry with `Map`](#symmetry-with-map)    The following methods make the interface of `Set` symmetric with the interface of `Map`.    *   `Set.prototype.entries(): Iterable<[T,T]>` ES6                    Mainly exists so that Sets and Maps have similar interfaces: Each Set element is viewed as a key-value entry whose key and value are both that element:                    ```", "```js                    `.entries()` enables us to convert a Set to a Map:                    ```", "```js           *   `Set.prototype.keys(): Iterable<T>` ES6                    Mainly exists so that Sets and Maps have similar interfaces: Each Set element is viewed as a key-value entry whose key and value are both that element. Therefore the result of `.keys()` is the same as the result of `.values()`:                    ```", "```js              #### [38.8.5 `Set.prototype.*`: combining two Sets ^(ES2025)](#setprototype-combining-two-sets-es2025)    *   `Set.prototype.union(other)` ES2025                    ```", "```js                    This method returns a Set that is the union of `this` and `other`. It contains a value if it is in `this` or `other`.                    ```", "```js                    `other` doesn’t have to be a Set, it only has to be [*Set-like*](#set-like-objects) and have the property `.size` and the methods `.has(key)` and `.keys()`. Sets and Maps both fulfill those requirements.           *   `Set.prototype.intersection(other)` ES2025                    ```", "```js                    This method returns a Set that is the intersection of `this` and `other`. It contains a value if it is in `this` or `other`.                    ```", "```js                    `other` doesn’t have to be a Set, it only has to be [*Set-like*](#set-like-objects) and have the property `.size` and the methods `.has(key)` and `.keys()`. Sets and Maps both fulfill those requirements.           *   `Set.prototype.difference(other)` ES2025                    ```", "```js                    This method returns a Set that is the difference between `this` and `other`. It contains a value if it is in `this` but not in `other`.                    ```", "```js                    `other` doesn’t have to be a Set, it only has to be [*Set-like*](#set-like-objects) and have the property `.size` and the methods `.has(key)` and `.keys()`. Sets and Maps both fulfill those requirements.           *   `Set.prototype.symmetricDifference(other)` ES2025                    ```", "```js                    This method returns a Set that is the symmetric difference between `this` and `other`. It contains a value if it is only in `this` or only in `other`.                    ```", "```js                    `other` doesn’t have to be a Set, it only has to be [*Set-like*](#set-like-objects) and have the property `.size` and the methods `.has(key)` and `.keys()`. Sets and Maps both fulfill those requirements.                    For more information on this method, see [its section in this chapter](#Set.prototype.symmetricDifference).              #### [38.8.6 `Set.prototype.*`: checking Set relationships ^(ES2025)](#setprototype-checking-set-relationships-es2025)    *   `Set.prototype.isSubsetOf(other)` ES2025                    ```", "```js                    Returns `true` if all elements of `this` are in `other`:                    ```", "```js           *   `Set.prototype.isSupersetOf(other)` ES2025                    ```", "```js                    Returns `true` if `this` contains all elements of `other`:                    ```", "```js           *   `Set.prototype.isDisjointFrom(other)` ES2025                    ```", "```js                    Returns `true` if `this` and `other` have no elements in common:                    ```", "```js ```", "```js`` ```", "```js ```", "```js` ```", "```js`` ```", "```js```", "``````js````"]