["```js\nconst emptySet = new Set();\nassert.equal(emptySet.size, 0);\n\n```", "```js\nconst set = new Set(['red', 'green', 'blue']);\n\n```", "```js\nconst set = new Set()\n.add('red')\n.add('green')\n.add('blue');\n\n```", "```js\nconst set = new Set();\nset.add('red');\n\n```", "```js\nassert.equal(set.has('red'), true);\n\n```", "```js\nassert.equal(set.delete('red'), true); // there was a deletion\nassert.equal(set.has('red'), false);\n\n```", "```js\nconst set = new Set()\n  .add('foo')\n  .add('bar');\nassert.equal(set.size, 2)\n\n```", "```js\nset.clear();\nassert.equal(set.size, 0)\n\n```", "```js\nassert.deepEqual(\n  new Set(['a', 'b']).union(new Set(['b', 'c'])),\n  new Set(['a', 'b', 'c'])\n);\n\n```", "```js\nassert.deepEqual(\n  new Set(['a', 'b']).intersection(new Set(['b', 'c'])),\n  new Set(['b'])\n);\n\n```", "```js\nassert.deepEqual(\n  new Set(['a', 'b']).difference(new Set(['b', 'c'])),\n  new Set(['a'])\n);\n\n```", "```js\nassert.deepEqual(\n  new Set(['a', 'b']).symmetricDifference(new Set(['b', 'c'])),\n  new Set(['a', 'c'])\n);\nassert.deepEqual(\n  new Set(['a', 'b']).symmetricDifference(new Set(['c', 'd'])),\n  new Set(['a', 'b', 'c', 'd'])\n);\n\n```", "```js\nassert.deepEqual(\n  new Set(['a', 'b']).isSubsetOf(new Set(['a', 'b', 'c'])),\n  true\n);\n\n```", "```js\nassert.deepEqual(\n  new Set(['a', 'b', 'c']).isSupersetOf(new Set(['a', 'b'])),\n  true\n);\n\n```", "```js\nassert.deepEqual(\n  new Set(['a', 'b', 'c']).isDisjointFrom(new Set(['x'])),\n  true\n);\n\n```", "```js\ninterface SetLike<T> {\n  /** Can be `Infinity` (see next section). */\n  size: number;\n\n  has(key: T): boolean;\n\n  /** Returns an iterator for the elements in `this`. */\n  keys(): Iterator<T>; // only method `.next()` is required\n}\n\n```", "```js\nconst setLike = {\n  size: 1,\n  has(x) { return x === 'b' },\n  * keys() { yield 'b' },\n};\n\nassert.deepEqual(\n new Set(['a', 'b', 'c']).difference(setLike),\n new Set(['a', 'c']),\n);\nassert.deepEqual(\n new Set(['a', 'b', 'c']).difference(setLike),\n new Set(['a', 'c']),\n);\nassert.equal(\n new Set(['a', 'b', 'c']).isSupersetOf(setLike),\n true,\n);\nassert.equal(\n new Set(['b']).isSubsetOf(setLike),\n true,\n);\n\n```", "```js\nconst setLike = new Map([['b', true]]);\nassert.deepEqual(\n  new Set(['a', 'b', 'c']).difference(setLike),\n  new Set(['a', 'c']),\n);\nassert.equal(\n  new Set(['a', 'b', 'c']).isSupersetOf(setLike),\n  true,\n);\n\n```", "```js\nconst evenNumbers = {\n  has(elem) {\n    return (elem % 2) === 0;\n  },\n  size: Infinity,\n  keys() {\n throw new TypeError();\n }\n};\nassert.deepEqual(\n new Set([0, 1, 2, 3]).difference(evenNumbers),\n new Set([1, 3])\n);\nassert.deepEqual(\n new Set([0, 1, 2, 3]).intersection(evenNumbers),\n new Set([0, 2])\n);\n\n```", "```js\nconst set = new Set(['red', 'green', 'blue']);\nfor (const x of set) {\n  console.log(x);\n}\n\n```", "```js\nred\ngreen\nblue\n\n```", "```js\nconst set = new Set(['red', 'green', 'blue']);\n\nassert.deepEqual(\n  Array.from(set),\n  ['red', 'green', 'blue']\n);\n\n```", "```js\nassert.deepEqual(\n  set.values().toArray(),\n  ['red', 'green', 'blue']\n);\n\n```", "```js\nconst set = new Set([1, 2, 3]);\nconst mappedSet = new Set( // (A)\n  set.values().map(x => x * 2) // (B)\n);\nassert.deepEqual(\n  mappedSet,\n  new Set([2, 4, 6])\n);\n\n```", "```js\nconst set = new Set([1, 2, 3, 4, 5]);\nconst filteredSet = new Set(\n  set.values().filter(x => (x % 2) === 0)\n);\nassert.deepEqual(\n  filteredSet,\n  new Set([2, 4])\n);\n\n```", "```js\nconst a = new Set([1, 2, 3]);\nconst b = new Set([2, 3, 4]);\n\n// Union\nassert.deepEqual(\n  new Set([...a, ...b]),\n  new Set([1, 2, 3, 4])\n);\n\n// Intersection\nassert.deepEqual(\n  new Set(a.values().filter(x => b.has(x))),\n  new Set([2, 3])\n);\n\n// Difference\nassert.deepEqual(\n  new Set(a.values().filter(x => !b.has(x))),\n  new Set([1])\n);\n\n```", "```js\nassert.deepEqual(\n  Object.groupBy(\n    new Set([0, -5, 3, -4, 8, 9]),\n    x => Math.sign(x)\n  ),\n  {\n    '0': [0],\n    '-1': [-5,-4],\n    '1': [3,8,9],\n    __proto__: null,\n  }\n);\n\n```", "```js\nconst arr = [1, 2, 1, 2, 3, 3, 3];\nconst noDuplicates = Array.from(new Set(arr));\nassert.deepEqual(\n  noDuplicates, [1, 2, 3]\n);\n\n```", "```js\nassert.deepEqual(\n  new Set('abc'),\n  new Set(['a', 'b', 'c'])\n);\n\n```", "```js\n> const set = new Set([NaN, NaN, NaN]);\n> set.size\n1\n> set.has(NaN)\ntrue\n\n```", "```js\n> const set = new Set();\n\n> set.add({});\n> set.size\n1\n\n> set.add({});\n> set.size\n2\n\n```", "```js\n    const set = new Set(['red', 'green', 'blue']);\n\n    ```", "```js\n    const set = new Set(['red']);\n    set.add('green').add('blue');\n    assert.deepEqual(\n      Array.from(set), ['red', 'green', 'blue']\n    );\n\n    ```", "```js\n    const set = new Set(['red', 'green', 'blue']);\n    assert.equal(set.delete('red'), true); // there was a deletion\n    assert.deepEqual(\n      Array.from(set), ['green', 'blue']\n    );\n\n    ```", "```js\n    const set = new Set(['red', 'green']);\n    assert.equal(set.has('red'), true);\n    assert.equal(set.has('blue'), false);\n\n    ```", "```js\n    const set = new Set(['red', 'green', 'blue']);\n    assert.equal(set.size, 3);\n\n    ```", "```js\n    const set = new Set(['red', 'green', 'blue']);\n    assert.equal(set.size, 3);\n    set.clear();\n    assert.equal(set.size, 0);\n\n    ```", "```js\n    const set = new Set(['red', 'green']);\n    for (const x of set.values()) {\n      console.log(x);\n    }\n\n    ```", "```js\n    red\n    green\n\n    ```", "```js\n    const set = new Set(['red', 'green']);\n    for (const x of set) {\n      console.log(x);\n    }\n\n    ```", "```js\n    red\n    green\n\n    ```", "```js\n    forEach(\n      callback: (value: T, key: T, theSet: Set<T>) => void,\n      thisArg?: any\n    ): void\n\n    ```", "```js\n    const set = new Set(['red', 'green']);\n    set.forEach(x => console.log(x));\n\n    ```", "```js\n    red\n    green\n\n    ```", "```js\n    > new Set(['a', 'b', 'c']).entries().toArray()\n    [ [ 'a', 'a' ], [ 'b', 'b' ], [ 'c', 'c' ] ]\n\n    ```", "```js\n    const set = new Set(['a', 'b', 'c']);\n    const map = new Map(set.entries());\n    assert.deepEqual(\n      Array.from(map.entries()),\n      [['a','a'], ['b','b'], ['c','c']]\n    );\n\n    ```", "```js\n    > new Set(['a', 'b', 'c']).keys().toArray()\n    [ 'a', 'b', 'c' ]\n\n    ```", "```js\n    Set<T>.prototype.union(other: SetLike<T>): Set<T>\n\n    ```", "```js\n    assert.deepEqual(\n      new Set(['a', 'b']).union(new Set(['b', 'c'])),\n      new Set(['a', 'b', 'c'])\n    );\n\n    ```", "```js\n    Set<T>.prototype.intersection(other: SetLike<T>): Set<T>\n\n    ```", "```js\n    assert.deepEqual(\n      new Set(['a', 'b']).intersection(new Set(['b', 'c'])),\n      new Set(['b'])\n    );\n\n    ```", "```js\n    Set<T>.prototype.difference(other: SetLike<T>): Set<T>\n\n    ```", "```js\n    assert.deepEqual(\n      new Set(['a', 'b']).difference(new Set(['b', 'c'])),\n      new Set(['a'])\n    );\n\n    ```", "```js\n    Set<T>.prototype.symmetricDifference(other: SetLike<T>): Set<T>\n\n    ```", "```js\n    assert.deepEqual(\n      new Set(['a', 'b']).symmetricDifference(new Set(['b', 'c'])),\n      new Set(['a', 'c'])\n    );\n\n    ```", "```js\n    Set<T>.prototype.isSubsetOf(other: SetLike<T>): boolean\n\n    ```", "```js\n    assert.deepEqual(\n      new Set(['a', 'b']).isSubsetOf(new Set(['a', 'b', 'c'])),\n      true\n    );\n\n    ```", "```js\n    Set<T>.prototype.isSupersetOf(other: SetLike<T>): boolean\n\n    ```", "```js\n    assert.deepEqual(\n      new Set(['a', 'b', 'c']).isSupersetOf(new Set(['a', 'b'])),\n      true\n    );\n\n    ```", "```js\n    Set<T>.prototype.isDisjointFrom(other: SetLike<T>): boolean\n\n    ```", "```js\n    assert.deepEqual(\n      new Set(['a', 'b', 'c']).isDisjointFrom(new Set(['x'])),\n      true\n    );\n\n    ```"]