["```js\n98\n123.45\n```", "```js\n> 98 === 98.0\ntrue\n```", "```js\n// Binary (base 2)\nassert.equal(0b11, 3); // ES6\n\n// Octal (base 8)\nassert.equal(0o10, 8); // ES6\n\n// Decimal (base 10)\nassert.equal(35, 35);\n\n// Hexadecimal (base 16)\nassert.equal(0xE7, 231);\n```", "```js\n> 35.0\n35\n```", "```js\n> 3e2\n300\n> 3e-2\n0.03\n> 0.3e2\n30\n```", "```js\n7.toString(); // syntax error\n```", "```js\n7.0.toString()\n(7).toString()\n7..toString()\n7 .toString()  // space before dot\n```", "```js\nconst inhabitantsOfLondon = 1_335_000;\nconst distanceEarthSunInKm = 149_600_000;\n```", "```js\nconst fileSystemPermission = 0b111_111_000;\nconst bytes = 0b1111_10101011_11110000_00001101;\nconst words = 0xFAB_F00D;\n```", "```js\nconst massOfElectronInKg = 9.109_383_56e-31;\nconst trillionInShortScale = 1e1_2;\n```", "```js\n    3_.141\n    3._141\n\n    1_e12\n    1e_12\n\n    _1464301  // valid variable name!\n    1464301_\n\n    0_b111111000\n    0b_111111000\n    ```", "```js\n    123__456 // two underscores \u2013 not allowed\n    ```", "```js\n> Number('123_456')\nNaN\n> Number.parseInt('123_456')\n123\n```", "```js\n> 5 % 3\n2\n> -5 % 3\n-2\n```", "```js\n> +'5'\n5\n> +'-12'\n-12\n> -'9'\n-9\n```", "```js\nlet foo = 3;\nassert.equal(++foo, 4);\nassert.equal(foo, 4);\n\nlet bar = 3;\nassert.equal(--bar, 2);\nassert.equal(bar, 2);\n```", "```js\nlet foo = 3;\nassert.equal(foo++, 3);\nassert.equal(foo, 4);\n\nlet bar = 3;\nassert.equal(bar--, 3);\nassert.equal(bar, 2);\n```", "```js\nconst obj = { a: 1 };\n++obj.a;\nassert.equal(obj.a, 2);\n```", "```js\nconst arr = [ 4 ];\narr[0]++;\nassert.deepEqual(arr, [5]);\n```", "```js\nassert.equal(Number(123.45), 123.45);\n\nassert.equal(Number(''), 0);\nassert.equal(Number('\\n 123.45 \\t'), 123.45);\nassert.equal(Number('xyz'), NaN);\n\nassert.equal(Number(-123n), -123);\n```", "```js\n> Number({ valueOf() { return 123 } })\n123\n```", "```js\n> typeof NaN\n'number'\n```", "```js\n> Number('$$$')\nNaN\n> Number(undefined)\nNaN\n```", "```js\n> Math.log(-1)\nNaN\n> Math.sqrt(-1)\nNaN\n```", "```js\n> NaN - 3\nNaN\n> 7 ** NaN\nNaN\n```", "```js\nconst n = NaN;\nassert.equal(n === n, false);\n```", "```js\nconst x = NaN;\n\nassert.equal(Number.isNaN(x), true); // preferred\nassert.equal(Object.is(x, NaN), true);\nassert.equal(x !== x, true);\n```", "```js\n> [NaN].indexOf(NaN)\n-1\n```", "```js\n> [NaN].includes(NaN)\ntrue\n> [NaN].findIndex(x => Number.isNaN(x))\n0\n> [NaN].find(x => Number.isNaN(x))\nNaN\n```", "```js\n> Math.pow(2, 1023)\n8.98846567431158e+307\n> Math.pow(2, 1024)\nInfinity\n```", "```js\n> 5 / 0\nInfinity\n> -5 / 0\n-Infinity\n```", "```js\nfunction findMinimum(numbers) {\n let min = Infinity;\n for (const n of numbers) {\n if (n < min) min = n;\n }\n return min;\n}\n\nassert.equal(findMinimum([5, -1, 2]), -1);\nassert.equal(findMinimum([]), Infinity);\n```", "```js\nconst x = Infinity;\n\nassert.equal(x === Infinity, true);\nassert.equal(Number.isFinite(x), false);\n```", "```js\n> 0.1 + 0.2\n0.30000000000000004\n> 1.3 * 3\n3.9000000000000004\n> 1.4 * 100000000000000\n139999999999999.98\n```", "```js\n> 0.1 + 0.2\n0.30000000000000004\n```", "```js\n    > -123 * (10 ** 0)\n    -123\n    ```", "```js\n    > 15 * (10 ** -1)\n    1.5\n    ```", "```js\n    > 25 * (10 ** -2)\n    0.25\n    ```", "```js\n> 15 * (10 ** -1) === 15 / (10 ** 1)\ntrue\n> 25 * (10 ** -2) === 25 / (10 ** 2)\ntrue\n```", "```js\n> 1 === 1.0\ntrue\n> Number.isInteger(1.0)\ntrue\n```", "```js\n    > Math.floor(2.1)\n    2\n    > Math.floor(2.9)\n    2\n    ```", "```js\n    > Math.ceil(2.1)\n    3\n    > Math.ceil(2.9)\n    3\n    ```", "```js\n    > Math.round(2.4)\n    2\n    > Math.round(2.5)\n    3\n    ```", "```js\n    > Math.trunc(2.1)\n    2\n    > Math.trunc(2.9)\n    2\n    ```", "```js\n> 18014398509481984\n18014398509481984\n> 18014398509481985\n18014398509481984\n> 18014398509481986\n18014398509481984\n> 18014398509481987\n18014398509481988\n```", "```js\nassert.equal(Number.MAX_SAFE_INTEGER, (2 ** 53) - 1);\nassert.equal(Number.MIN_SAFE_INTEGER, -Number.MAX_SAFE_INTEGER);\n\nassert.equal(Number.isSafeInteger(5), true);\nassert.equal(Number.isSafeInteger('5'), false);\nassert.equal(Number.isSafeInteger(5.1), false);\nassert.equal(Number.isSafeInteger(Number.MAX_SAFE_INTEGER), true);\nassert.equal(Number.isSafeInteger(Number.MAX_SAFE_INTEGER+1), false);\n```", "```js\n> 9007199254740990 + 3\n9007199254740992\n```", "```js\n> 9007199254740995 - 10\n9007199254740986\n```", "```js\nisSafeInteger(a) && isSafeInteger(b) && isSafeInteger(a op b)\n```", "```js\nassert.equal(\n b32(-1),\n '11111111111111111111111111111111');\nassert.equal(\n b32(1),\n '00000000000000000000000000000001');\nassert.equal(\n b32(2 ** 31),\n '10000000000000000000000000000000');\n```", "```js\n> b32(~0b100)\n'11111111111111111111111111111011'\n```", "```js\n> 4 + ~4\n-1\n> -11 + ~-11\n-1\n```", "```js\n> (0b1010 & 0b0011).toString(2).padStart(4, '0')\n'0010'\n> (0b1010 | 0b0011).toString(2).padStart(4, '0')\n'1011'\n> (0b1010 ^ 0b0011).toString(2).padStart(4, '0')\n'1001'\n```", "```js\n> (0b10 << 1).toString(2)\n'100'\n```", "```js\n> b32(0b10000000000000000000000000000010 >> 1)\n'11000000000000000000000000000001'\n> b32(0b10000000000000000000000000000010 >>> 1)\n'01000000000000000000000000000001'\n```", "```js\n/**\n * Return a string representing n as a 32-bit unsigned integer,\n * in binary notation.\n */\nfunction b32(n) {\n // >>> ensures highest bit isn\u2019t interpreted as a sign\n return (n >>> 0).toString(2).padStart(32, '0');\n}\nassert.equal(\n b32(6),\n '00000000000000000000000000000110');\n```", "```js\n> 12 >>> 0\n12\n> -12 >>> 0\n4294967284\n> (2**32 + 1) >>> 0\n1\n```", "```js\n    > Number.isFinite(Infinity)\n    false\n    > Number.isFinite(-Infinity)\n    false\n    > Number.isFinite(NaN)\n    false\n    > Number.isFinite(123)\n    true\n    ```", "```js\n    > Number.isInteger(-17)\n    true\n    > Number.isInteger(33)\n    true\n    > Number.isInteger(33.1)\n    false\n    > Number.isInteger('33')\n    false\n    > Number.isInteger(NaN)\n    false\n    > Number.isInteger(Infinity)\n    false\n    ```", "```js\n    > Number.isNaN(NaN)\n    true\n    > Number.isNaN(123)\n    false\n    > Number.isNaN('abc')\n    false\n    ```", "```js\n    > Number.parseFloat(' 123.4#')\n    123.4\n    > Number(' 123.4#')\n    NaN\n    ```", "```js\n    > Number.parseInt('  123#')\n    123\n    ```", "```js\n    > Number.parseInt('101', 2)\n    5\n    > Number.parseInt('FF', 16)\n    255\n    ```", "```js\n    > Number.parseInt(1e21, 10) // wrong\n    1\n    ```", "```js\n    > Math.trunc(1e21) // correct\n    1e+21\n    ```", "```js\n    > 1234..toString()\n    '1234'\n\n    > 1234..toExponential() // 3 fraction digits\n    '1.234e+3'\n    > 1234..toExponential(5)\n    '1.23400e+3'\n    > 1234..toExponential(1)\n    '1.2e+3'\n    ```", "```js\n    > 0.003.toString()\n    '0.003'\n    > 0.003.toExponential()\n    '3e-3'\n    ```", "```js\n    > 0.00000012.toString() // with exponent\n    '1.2e-7'\n\n    > 0.00000012.toFixed(10) // no exponent\n    '0.0000001200'\n    > 0.00000012.toFixed()\n    '0'\n    ```", "```js\n    > (10 ** 21).toFixed()\n    '1e+21'\n    ```", "```js\n    > 1234..toPrecision(3)  // requires exponential notation\n    '1.23e+3'\n\n    > 1234..toPrecision(4)\n    '1234'\n\n    > 1234..toPrecision(5)\n    '1234.0'\n\n    > 1.234.toPrecision(3)\n    '1.23'\n    ```", "```js\n    > 123.456.toString()\n    '123.456'\n    ```", "```js\n    > 4..toString(2) // binary (base 2)\n    '100'\n    > 4.5.toString(2)\n    '100.1'\n\n    > 255..toString(16) // hexadecimal (base 16)\n    'ff'\n    > 255.66796875.toString(16)\n    'ff.ab'\n\n    > 1234567890..toString(36)\n    'kf12oi'\n    ```", "```js\n    > Number.parseInt('kf12oi', 36)\n    1234567890\n    ```"]