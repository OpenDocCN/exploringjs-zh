- en: 25 Control flow statements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 25 控制流语句
- en: 原文：[https://exploringjs.com/js/book/ch_control-flow.html](https://exploringjs.com/js/book/ch_control-flow.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/js/book/ch_control-flow.html](https://exploringjs.com/js/book/ch_control-flow.html)
- en: '[25.1 Controlling loops: `break` and `continue`](#controlling-loops-break-and-continue)'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.1 控制循环：`break` 和 `continue`](#controlling-loops-break-and-continue)'
- en: '[25.1.1 `break`](#break)'
  id: totrans-3
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.1.1 `break`](#break)'
- en: '[25.1.2 `break` plus label: leaving any labeled statement](#labels)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.1.2 带有标签的 `break`：离开任何带标签的语句](#labels)'
- en: '[25.1.3 `continue`](#continue)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.1.3 `continue`](#continue)'
- en: '[25.2 Conditions of control flow statements](#control-flow-conditions)'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.2 控制流语句的条件](#control-flow-conditions)'
- en: '[25.3 `if` statements ^(ES1)](#if)'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.3 `if` 语句 (ES1)](#if)'
- en: '[25.3.1 The syntax of `if` statements](#the-syntax-of-if-statements)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.3.1 `if` 语句的语法](#the-syntax-of-if-statements)'
- en: '[25.4 `switch` statements ^(ES3)](#switch)'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.4 `switch` 语句 (ES3)](#switch)'
- en: '[25.4.1 A first example of a `switch` statement](#a-first-example-of-a-switch-statement)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.4.1 `switch` 语句的第一个示例](#a-first-example-of-a-switch-statement)'
- en: '[25.4.2 Don’t forget to `return` or `break`!](#dont-forget-to-return-or-break)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.4.2 不要忘记 `return` 或 `break`！](#dont-forget-to-return-or-break)'
- en: '[25.4.3 Empty case clauses](#empty-case-clauses)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.4.3 空的情况子句](#empty-case-clauses)'
- en: '[25.4.4 Checking for illegal values via a `default` clause](#checking-for-illegal-values-via-a-default-clause)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.4.4 通过 `default` 子句检查非法值](#checking-for-illegal-values-via-a-default-clause)'
- en: '[25.4.5 Pitfall of `switch`: all cases exist in the same variable scope](#pitfall-switch-variable-scope)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.4.5 `switch` 的陷阱：所有情况都存在于相同的变量作用域中](#pitfall-switch-variable-scope)'
- en: '[25.5 `while` loops ^(ES1)](#while)'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.5 `while` 循环 (ES1)](#while)'
- en: '[25.5.1 Examples of `while` loops](#examples-of-while-loops)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.5.1 `while` 循环的示例](#examples-of-while-loops)'
- en: '[25.6 `do-while` loops ^(ES3)](#do-while)'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.6 `do-while` 循环 (ES3)](#do-while)'
- en: '[25.7 `for` loops ^(ES1)](#for)'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.7 `for` 循环 (ES1)](#for)'
- en: '[25.7.1 Examples of `for` loops](#examples-of-for-loops)'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.7.1 `for` 循环的示例](#examples-of-for-loops)'
- en: '[25.8 `for-of` loops ^(ES6)](#for-of)'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.8 `for-of` 循环 (ES6)](#for-of)'
- en: '[25.8.1 `const`: `for-of` vs. `for`](#const-forof-vs-for)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.8.1 `const`：`for-of` 与 `for` 的比较](#const-forof-vs-for)'
- en: '[25.8.2 Iterating over iterables](#iterating-over-iterables)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.8.2 遍历可迭代对象](#iterating-over-iterables)'
- en: '[25.8.3 Iterating over [index, element] pairs of Arrays](#for-of-iterating-index-element)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.8.3 遍历数组的 [索引，元素] 对](#for-of-iterating-index-element)'
- en: '[25.9 `for-await-of` loops ^(ES2018)](#forawaitof-loops-es2018)'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.9 `for-await-of` 循环 (ES2018)](#forawaitof-loops-es2018)'
- en: '[25.10 `for-in` loops (avoid) ^(ES1)](#for-in)'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.10 `for-in` 循环（避免）(ES1)](#for-in)'
- en: '[25.11 Recommendations for looping](#recommendations-for-looping)'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[25.11 循环的建议](#recommendations-for-looping)'
- en: 'This chapter covers the following control flow statements:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下控制流语句：
- en: '`if` statement [ES1]'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` 语句 [ES1]'
- en: '`switch` statement [ES3]'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch` 语句 [ES3]'
- en: '`while` loop [ES1]'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while` 循环 [ES1]'
- en: '`do-while` loop [ES3]'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do-while` 循环 [ES3]'
- en: '`for` loop [ES1]'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环 [ES1]'
- en: '`for-of` loop [ES6]'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for-of` 循环 [ES6]'
- en: '`for-await-of` loop [ES2018]'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for-await-of` 循环 [ES2018]'
- en: '`for-in` loop [ES1]'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for-in` 循环 [ES1]'
- en: '[25.1 Controlling loops: `break` and `continue`](#controlling-loops-break-and-continue)'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[25.1 控制循环：`break` 和 `continue`](#controlling-loops-break-and-continue)'
- en: The two operators `break` and `continue` can be used to control loops and other
    statements while we are inside them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 两个运算符 `break` 和 `continue` 可以在我们处于循环或其他语句内部时控制它们。
- en: '[25.1.1 `break`](#break)'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[25.1.1 `break`](#break)'
- en: 'There are two versions of `break`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 有两种版本：'
- en: One without an operand.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有操作数的一个。
- en: One with a *label* as an operand.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有 *标签* 作为操作数的一个。
- en: 'The former version works inside the following statements: `while`, `do-while`,
    `for`, `for-of`, `for-await-of`, `for-in` and `switch`. It immediately leaves
    the current statement:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 前者版本可以在以下语句中使用：`while`、`do-while`、`for`、`for-of`、`for-await-of`、`for-in` 和 `switch`。它立即离开当前语句：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[25.1.2 `break` plus label: leaving any labeled statement](#labels)'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[25.1.2 带有标签的 `break`：离开任何带标签的语句](#labels)'
- en: '`break` with an operand works everywhere. Its operand is a *label*. Labels
    can be put in front of any statement, including blocks. `break myLabel` leaves
    the statement whose label is `myLabel`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 带有操作数的 `break` 在任何地方都有效。其操作数是一个 *标签*。标签可以放在任何语句之前，包括块。`break myLabel` 将离开标签为
    `myLabel` 的语句：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[25.1.2.1 Example: `break` plus label](#example-break-plus-label)'
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[25.1.2.1 示例：带有标签的 `break`](#example-break-plus-label)'
- en: 'In the following example, the search can either:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，搜索可以：
- en: 'Fail: The loop finishes without finding a `result`. That is handled directly
    after the loop (line B).'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败：循环结束而没有找到 `result`。这将在循环之后直接处理（行 B）。
- en: 'Succeed: While looping, we find a `result`. Then we use `break` plus label
    (line A) to skip the code that handles failure.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功：在循环过程中，我们找到了 `result`。然后我们使用带有标签的 `break`（行 A）来跳过处理失败的代码。
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[25.1.3 `continue`](#continue)'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[25.1.3 `continue`](#continue)'
- en: '`continue` only works inside `while`, `do-while`, `for`, `for-of`, `for-await-of`,
    and `for-in`. It immediately leaves the current loop iteration and continues with
    the next one – for example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`仅在`while`、`do-while`、`for`、`for-of`、`for-await-of`和`for-in`内部有效。它立即离开当前的循环迭代，并继续下一个——例如：'
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[25.2 Conditions of control flow statements](#control-flow-conditions)'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[25.2 控制流语句的条件](#control-flow-conditions)'
- en: '`if`, `while`, and `do-while` have conditions that are, in principle, boolean.
    However, a condition only has to be *truthy* (`true` if coerced to boolean) in
    order to be accepted. In other words, the following two control flow statements
    are equivalent:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`、`while`和`do-while`的条件在原则上都是布尔值。然而，条件只需是*真值*（如果转换为布尔值则为`true`）即可被接受。换句话说，以下两个控制流语句是等价的：'
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is a list of all *falsy* values:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个所有*假值*的列表：
- en: '`undefined`, `null`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`, `null`'
- en: '`false`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`'
- en: '`0`, `NaN`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`, `NaN`'
- en: '`0n`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0n`'
- en: '`''''`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''''`'
- en: All other values are truthy. For more information, see [“Falsy and truthy values”
    (§17.2)](ch_booleans.html#falsiness-truthiness).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他值都是真值。有关更多信息，请参阅[“假值和真值” (§17.2)](ch_booleans.html#falsiness-truthiness)。
- en: '[25.3 `if` statements ^(ES1)](#if)'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[25.3 `if`语句^(ES1)](#if)'
- en: 'These are two simple `if` statements: one with just a “then” branch and one
    with both a “then” branch and an “else” branch:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是两个简单的`if`语句：一个只有一个“then”分支，另一个既有“then”分支又有“else”分支：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Instead of the block, `else` can also be followed by another `if` statement:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了块之外，`else`也可以跟另一个`if`语句：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can continue this chain with more `else if`s.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用更多的`else if`继续这个链。
- en: '[25.3.1 The syntax of `if` statements](#the-syntax-of-if-statements)'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[25.3.1 `if`语句的语法](#the-syntax-of-if-statements)'
- en: 'The general syntax of `if` statements is:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句的一般语法是：'
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So far, the `then_statement` has always been a block, but we can use any statement.
    That statement must be terminated with a semicolon:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`then_statement`始终是一个块，但我们可以使用任何语句。该语句必须以分号结束：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That means that `else if` is not its own construct; it’s simply an `if` statement
    whose `else_statement` is another `if` statement.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`else if`不是它自己的构造；它只是一个`if`语句，其`else_statement`是另一个`if`语句。
- en: '[25.4 `switch` statements ^(ES3)](#switch)'
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[25.4 `switch`语句^(ES3)](#switch)'
- en: 'A `switch` statement looks as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`switch`语句看起来如下：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The body of `switch` consists of zero or more case clauses:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`的主体由零个或多个`case`子句组成：'
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And, optionally, a default clause:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，可选地，一个默认子句：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A `switch` is executed as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`的执行方式如下：'
- en: It evaluates the switch expression.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它评估`switch`表达式。
- en: It jumps to the first case clause whose expression has the same result as the
    switch expression.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它跳转到第一个表达式结果与`switch`表达式相同的`case`子句。
- en: Otherwise, if there is no such clause, it jumps to the default clause.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果没有这样的子句，则跳转到默认子句。
- en: Otherwise, if there is no default clause, it does nothing.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果没有默认子句，则不执行任何操作。
- en: '[25.4.1 A first example of a `switch` statement](#a-first-example-of-a-switch-statement)'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[25.4.1 `switch`语句的第一个例子](#a-first-example-of-a-switch-statement)'
- en: 'Let’s look at an example: The following function converts a number from 1–7
    to the name of a weekday.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：以下函数将数字1-7转换为星期几的名称。
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[25.4.2 Don’t forget to `return` or `break`!](#dont-forget-to-return-or-break)'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[25.4.2 不要忘记`return`或`break`!](#dont-forget-to-return-or-break)'
- en: 'At the end of a case clause, execution continues with the next case clause,
    unless we `return` or `break` – for example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`case`子句的末尾，执行将继续到下一个`case`子句，除非我们`return`或`break`——例如：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That is, our implementation of `dayOfTheWeek()` only worked because we used
    `return`. We can fix `englishToFrench()` by using `break`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们的`dayOfTheWeek()`实现之所以有效，仅仅是因为我们使用了`return`。我们可以通过使用`break`来修复`englishToFrench()`：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[25.4.3 Empty case clauses](#empty-case-clauses)'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[25.4.3 空`case`子句](#empty-case-clauses)'
- en: 'The statements of a case clause can be omitted, which effectively gives us
    multiple case expressions per case clause:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`case`子句的语句可以省略，这实际上为我们提供了每个`case`子句的多个`case`表达式：'
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[25.4.4 Checking for illegal values via a `default` clause](#checking-for-illegal-values-via-a-default-clause)'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[25.4.4 通过`default`子句检查非法值](#checking-for-illegal-values-via-a-default-clause)'
- en: 'A `default` clause is jumped to if the `switch` expression has no other match.
    That makes it useful for error checking:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`switch`表达式没有其他匹配项，则跳转到默认子句。这使得它对于错误检查很有用：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercises:
    `switch`**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“练习”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：`switch`**'
- en: '`exercises/control-flow/number_to_month_test.mjs`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exercises/control-flow/number_to_month_test.mjs`'
- en: 'Bonus: `exercises/control-flow/is_object_via_switch_test.mjs`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奖励：`exercises/control-flow/is_object_via_switch_test.mjs`
- en: '[25.4.5 Pitfall of `switch`: all cases exist in the same variable scope](#pitfall-switch-variable-scope)'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[25.4.5 `switch` 的陷阱：所有情况都存在于相同的变量作用域](#pitfall-switch-variable-scope)'
- en: 'Let’s say we want to implement a function `main()` that works as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要实现一个 `main()` 函数，它的工作方式如下：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We could implement `main()` like this (to reduce verbosity, error messages
    are omitted):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `main()` 实现如下（为了减少冗余，省略了错误消息）：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Alas, in line A, we get the following syntax error:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在行 A 中，我们得到以下语法错误：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Why is that? The complete body of `switch` is a single variable scope and inside
    it, there are two declarations for the variable `text`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是这样？`switch` 的完整主体是一个单独的变量作用域，并且在这个作用域内部，有两个关于变量 `text` 的声明。
- en: 'But this problem is easy to fix – we can create a variable scope for each `switch`
    case by wrapping its code in curly braces:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个问题很容易解决——我们可以通过将代码包裹在大括号中来为每个 `switch` 情况创建一个变量作用域：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[25.5 `while` loops ^(ES1)](#while)'
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[25.5 `while` 循环^(ES1)](#while)'
- en: 'A `while` loop has the following syntax:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环有以下语法：'
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Before each loop iteration, `while` evaluates `condition`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次循环迭代之前，`while` 评估 `condition`：
- en: If the result is falsy, the loop is finished.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果结果是假值，则循环结束。
- en: If the result is truthy, the `while` body is executed one more time.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果结果是真值，则 `while` 主体将再执行一次。
- en: '[25.5.1 Examples of `while` loops](#examples-of-while-loops)'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[25.5.1 `while` 循环的示例](#examples-of-while-loops)'
- en: The following code uses a `while` loop. In each loop iteration, it removes the
    first element of `arr` via `.shift()` and logs it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用 `while` 循环。在每次循环迭代中，它通过 `.shift()` 移除 `arr` 的第一个元素并记录它。
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If the condition always evaluates to `true`, then `while` is an infinite loop:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件始终评估为 `true`，则 `while` 是一个无限循环：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[25.6 `do-while` loops ^(ES3)](#do-while)'
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[25.6 `do-while` 循环^(ES3)](#do-while)'
- en: The `do-while` loop works much like `while`, but it checks its condition *after*
    each loop iteration, not before.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`do-while` 循环的工作方式与 `while` 类似，但它是在每次循环迭代之后而不是之前检查其条件。'
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`do-while` can also be viewed as a `while` loop that runs at least once.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`do-while` 也可以被视为至少运行一次的 `while` 循环。'
- en: '[`prompt()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt)
    is a global function that is available in web browsers. It prompts the user to
    input text and returns it.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[`prompt()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt)
    是一个在网页浏览器中可用的全局函数。它提示用户输入文本并返回它。'
- en: '[25.7 `for` loops ^(ES1)](#for)'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[25.7 `for` 循环^(ES1)](#for)'
- en: 'A `for` loop has the following syntax:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环有以下语法：'
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The first line is the *head* of the loop and controls how often the *body*
    (the remainder of the loop) is executed. It has three parts and each of them is
    optional:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是循环的 *头部*，它控制循环体（循环的其余部分）执行的频率。它有三个部分，每个部分都是可选的：
- en: '`initialization`: sets up variables, etc. for the loop. Variables declared
    here via `let` or `const` only exist inside the loop.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialization`：为循环设置变量等。在这里通过 `let` 或 `const` 声明的变量仅存在于循环内部。'
- en: '`condition`: This condition is checked before each loop iteration. If it is
    falsy, the loop stops.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`condition`：在每次循环迭代之前检查此条件。如果它是假值，则循环停止。'
- en: '`post_iteration`: This code is executed after each loop iteration.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post_iteration`: 此代码在每个循环迭代后执行。'
- en: 'A `for` loop is therefore roughly equivalent to the following `while` loop:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`for` 循环大致等价于以下 `while` 循环：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[25.7.1 Examples of `for` loops](#examples-of-for-loops)'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[25.7.1 `for` 循环的示例](#examples-of-for-loops)'
- en: 'As an example, this is how to count from zero to two via a `for` loop:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是如何通过 `for` 循环从零计数到二的：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is how to log the contents of an Array via a `for` loop:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何通过 `for` 循环记录数组内容的方法：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we omit all three parts of the head, we get an infinite loop:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们省略头部所有三个部分，就会得到一个无限循环：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[25.8 `for-of` loops ^(ES6)](#for-of)'
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[25.8 `for-of` 循环^(ES6)](#for-of)'
- en: 'A `for-of` loop iterates over any *iterable* – a data container that supports
    [the *iteration protocol*](ch_sync-iteration.html#ch_sync-iteration). Each iterated
    value is stored in a variable, as specified in the head:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-of` 循环遍历任何 *可迭代* 对象——一个支持 [迭代协议](ch_sync-iteration.html#ch_sync-iteration)
    的数据容器。每个迭代的值都存储在一个变量中，如头部指定：'
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The iteration variable is usually created via a variable declaration:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代变量通常通过变量声明创建：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Output:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'But we can also use a (mutable) variable that already exists:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以使用一个已经存在的（可变的）变量：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[25.8.1 `const`: `for-of` vs. `for`](#const-forof-vs-for)'
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[25.8.1 `const`：`for-of` 与 `for` 的比较](#const-forof-vs-for)'
- en: Note that in `for-of` loops we can use `const`. The iteration variable can still
    be different for each iteration (it just can’t change during the iteration). Think
    of it as a new `const` declaration being executed each time in a fresh scope.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`for-of`循环中我们可以使用`const`。迭代变量仍然可以在每次迭代中不同（但它不能在迭代过程中改变）。想象一下，每次在新的作用域中执行一个新的`const`声明。
- en: In contrast, in `for` loops we must declare variables via `let` or `var` if
    their values change.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在`for`循环中，如果变量的值会改变，我们必须通过`let`或`var`来声明变量。
- en: '[25.8.2 Iterating over iterables](#iterating-over-iterables)'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[25.8.2 遍历可迭代对象](#iterating-over-iterables)'
- en: 'As mentioned before, `for-of` works with any iterable object, not just with
    Arrays – for example, with Sets:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`for-of`与任何可迭代对象一起工作，而不仅仅是数组 - 例如，与集合一起：
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[25.8.3 Iterating over [index, element] pairs of Arrays](#for-of-iterating-index-element)'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[25.8.3 遍历数组的 [索引，元素] 对](#for-of-iterating-index-element)'
- en: 'Lastly, we can also use `for-of` to iterate over the [index, element] entries
    of Arrays:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以使用`for-of`来遍历数组的 [索引，元素] 条目：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Output:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: With `[index, element]`, we are using [*destructuring*](ch_destructuring.html#ch_destructuring)
    to access Array elements.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`[索引，元素]`，我们正在使用 [*解构赋值*](ch_destructuring.html#ch_destructuring) 来访问数组元素。
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    `for-of`**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“练习”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：`for-of`**'
- en: '`exercises/control-flow/array_to_string_test.mjs`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/control-flow/array_to_string_test.mjs`'
- en: '[25.9 `for-await-of` loops ^(ES2018)](#forawaitof-loops-es2018)'
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[25.9 `for-await-of`循环（ES2018）](#forawaitof-loops-es2018)'
- en: '`for-await-of` is like `for-of`, but it works with asynchronous iterables instead
    of synchronous ones. And it can only be used inside async functions and async
    generators.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-await-of`类似于`for-of`，但它与异步可迭代对象一起工作，而不是同步的。它只能在异步函数和异步生成器内部使用。'
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`for-await-of` is described in detail [in the chapter on asynchronous iteration](ch_async-iteration.html#for-await-of).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-await-of`在关于异步迭代的章节中有详细描述 [在异步迭代章节中描述了`for-await-of`](ch_async-iteration.html#for-await-of)。'
- en: '[25.10 `for-in` loops (avoid) ^(ES1)](#for-in)'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[25.10 `for-in`循环（避免）](#for-in)'
- en: 'The `for-in` loop visits all (own and inherited) enumerable property keys of
    an object. When looping over an Array, it is rarely a good choice:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-in`循环访问一个对象的所有（包括自身的和继承的）可枚举属性键。当遍历数组时，它很少是一个好的选择：'
- en: It visits property keys, not values.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它访问属性键，而不是值。
- en: As property keys, the indices of Array elements are strings, not numbers ([more
    information on how Array elements work](ch_arrays.html#array-indices)).
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为属性键，数组元素的索引是字符串，而不是数字 ([关于数组元素如何工作的更多信息](ch_arrays.html#array-indices))。
- en: It visits all enumerable property keys (both own and inherited ones), not just
    those of Array elements.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它访问所有可枚举属性键（包括自身的和继承的），而不仅仅是数组元素的属性键。
- en: 'The following code demonstrates these points:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了这些要点：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Output:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[25.11 Recommendations for looping](#recommendations-for-looping)'
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[25.11 循环建议](#recommendations-for-looping)'
- en: If you want to loop over an [asynchronous iterable](ch_async-iteration.html#ch_async-iteration)
    (in ES2018+), you must use `for-await-of`.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要遍历一个 [异步可迭代对象](ch_async-iteration.html#ch_async-iteration)（在ES2018+中），你必须使用`for-await-of`。
- en: For looping over any synchronous iterable (incl. Arrays), you must use `for-of`.
    Available in ES6+.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于遍历任何同步可迭代对象（包括数组），你必须使用`for-of`。在ES6+中可用。
- en: For looping over an Array in ES5+, you can use [the Array method `.forEach()`](ch_arrays.html#qref-Array.prototype.forEach).
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在ES5+中，你可以使用 [数组的`.forEach()`方法](ch_arrays.html#qref-Array.prototype.forEach)来遍历数组。
- en: Before ES5, you can use a plain `for` loop to loop over an Array.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在ES5之前，你可以使用普通的`for`循环来遍历数组。
- en: Don’t use `for-in` to loop over an Array.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用`for-in`来遍历数组。
