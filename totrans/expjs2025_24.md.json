["```js\n123n\n\n```", "```js\n> 123n * 456n\n56088n\n\n```", "```js\n> typeof 123n\n'bigint'\n\n```", "```js\n> 2**53 // can be represented but same as next number\n9007199254740992\n> 2**53 + 1 // wrong\n9007199254740992\n\n```", "```js\n> 2n**53n\n9007199254740992n\n> 2n**53n + 1n\n9007199254740993n\n\n```", "```js\n/**\n * Takes a bigint as an argument and returns a bigint\n */\nfunction nthPrime(nth) {\n if (typeof nth !== 'bigint') {\n throw new TypeError();\n }\n function isPrime(p) {\n for (let i = 2n; i < p; i++) {\n if (p % i === 0n) return false;\n }\n return true;\n }\n for (let i = 2n; ; i++) {\n if (isPrime(i)) {\n if (--nth === 0n) return i;\n }\n }\n}\n `assert.deepEqual(`\n `[1n, 2n, 3n, 4n, 5n].map(nth => nthPrime(nth)),`\n `[2n, 3n, 5n, 7n, 11n]`\n`);` \n```", "```js```", "````js ### [20.3 Bigint literals](#bigint-literals)    Like number literals, bigint literals support several bases:    *   Decimal: `123n` *   Hexadecimal: `0xFFn` *   Binary: `0b1101n` *   Octal: `0o777n`    Negative bigints are produced by prefixing the unary minus operator: `-0123n`    #### [20.3.1 Underscores (`_`) as separators in bigint literals ^(ES2021)](#numeric-separator-bigint-literals)    [Just like in number literals](ch_numbers.html#numeric-separator-number-literals), we can use underscores (`_`) as separators in bigint literals:    ``` const massOfEarthInKg = 6_000_000_000_000_000_000_000_000n;  ```js    Bigints are often used to represent money in the financial technical sector. Separators can help here, too:    ``` const priceInCents = 123_000_00n; // 123 thousand dollars  ```js    As with number literals, two restrictions apply:    *   We can only put an underscore between two digits. *   We can use at most one underscore in a row.    ### [20.4 Reusing number operators for bigints (overloading)](#reusing-number-operators-for-bigints-overloading)    With most operators, we are not allowed to mix bigints and numbers. If we do, exceptions are thrown:    ``` > 2n + 1 TypeError: Cannot mix BigInt and other types, use explicit conversions  ```js    The reason for this rule is that there is no general way of coercing a number and a bigint to a common type: numbers can’t represent bigints beyond 53 bits, bigints can’t represent fractions. Therefore, the exceptions warn us about typos that may lead to unexpected results.    Consider the following expression:    ``` 2**53 + 1n  ```js    Should the result be `9007199254740993n` or `9007199254740992`?    It is also not clear what the result of the following expression should be:    ``` 2n**53n * 3.3  ```js    #### [20.4.1 Arithmetic operators](#arithmetic-operators-1)    Binary `+`, binary `-`, `*`, `**` work as expected:    ``` > 7n * 3n 21n  ```js    It is OK to mix bigints and strings:    ``` > 6n + ' apples' '6 apples'  ```js    `/` and `%` round towards zero by removing the fraction (like `Math.trunc()`):    ``` > 1n / 2n 0n  ```js    Unary `-` works as expected:    ``` > -(-64n) 64n  ```js    Unary `+` is not supported for bigints because much code relies on it coercing its operand to number:    ``` > +23n TypeError: Cannot convert a BigInt value to a number  ```js    #### [20.4.2 Loose equality (`==`) and inequality (`!=`)](#loose-equality--and-inequality-)    Loose equality (`==`) and inequality (`!=`) coerce values:    ``` > 0n == false true > 1n == true true  `> 123n == 123` `true`  `` `> 123n == '123'` `true` ``  ```js   ````", "``` ```", "```js`` #### [20.4.3 Strict equality (`===`) and inequality (`!==`)](#strict-equality--and-inequality-)    Strict equality (`===`) and inequality (`!==`) only consider values to be equal if they have the same type:    ```", "```js    #### [20.4.4 Ordering operators](#ordering-operators-1)    Ordering operators `<`, `>`, `>=`, `<=` work as expected:    ```", "```js    Comparing bigints and numbers does not pose any risks. Therefore, we can mix bigints and numbers:    ```", "```js    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Converting numbers-based code to bigints**    `exercises/bigints/gcd-bigint_test.mjs`    #### [20.4.5 Bitwise operators (advanced)](#bitwise-operators-advanced-1)    ##### [20.4.5.1 Bitwise operators for numbers](#bitwise-operators-for-numbers)    Bitwise operators interpret numbers as 32-bit integers. These integers are either unsigned or signed. If they are signed, the negative of an integer is its *two’s complement*: If we add an integer to its two’s complement and ignore overflow (digits beyond 32 bits) then the result is zero.    ```", "```js    If we add `1` to the binary number consisting of 32 ones, we get a one followed by 32 zeros. Everything beyond 32 bits is overflow, which means that that number is zero.    We used signed right shift operator (`>>`): We shifted the left operand by zero bits, which converted it to Int32 (which is signed) and back to number.    Due to these integers having a fixed size, their highest bits indicate their signs:    ```", "```js    ##### [20.4.5.2 Bitwise operators for bigints](#bitwise-operators-for-bigints)    For bigints, bitwise operators interpret a negative sign as an infinite two’s complement – for example:    *   `-1` is `···111111` (ones extend infinitely to the left) *   `-2` is `···111110` *   `-3` is `···111101` *   `-4` is `···111100`    That is, a negative sign is more of an external flag and not represented as an actual bit.    ##### [20.4.5.3 Bitwise Not (`~`)](#bitwise-not-)    Bitwise Not (`~`) inverts all bits:    ```", "```js    ##### [20.4.5.4 Binary bitwise operators (`&`, `|`, `^`)](#binary-bitwise-operators---)    Applying binary bitwise operators to bigints works analogously to applying them to numbers:    ```", "```js   ```", "```js` ##### [20.4.5.5 Bitwise signed shift operators (`<<` and `>>`)](#bitwise-signed-shift-operators--and-)    The signed shift operators for bigints preserve the sign of a number:    ```", "```js   ```", "```js Recall that `-1n` is a sequence of ones that extends infinitely to the left. That’s why shifting it left doesn’t change it:    ```", "```js    ##### [20.4.5.6 Bitwise unsigned right shift operator (`>>>`)](#bitwise-unsigned-right-shift-operator-)    There is no unsigned right shift operator for bigints:    ```", "```js    Why? The idea behind unsigned right shifting is that a zero is shifted in “from the left”. In other words, the assumption is that there is a finite amount of binary digits.    However, with negative bigints (especially negative ones), there is no “left”; their binary digits extend infinitely.    Signed right shift works even with an infinite number of digits because the highest digit is preserved. Therefore, it can be adapted to bigints.    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Implementing a bit set via bigints**    `exercises/bigints/bit-set_test.mjs`    ### [20.5 The wrapper constructor `BigInt`](#the-wrapper-constructor-bigint)    Analogously to numbers, bigints have the associated wrapper constructor `BigInt`.    #### [20.5.1 `BigInt` as a constructor and as a function](#bigint-as-a-constructor-and-as-a-function)    *   `new BigInt()`: throws a `TypeError`.           *   `BigInt(x)` converts arbitrary values `x` to bigint. This works similarly to `Number()`, with several differences which are summarized in [table 20.1](#tbl:converting-values-to-bigints) and explained in more detail in the following subsections.               | `x` | `BigInt(x)` | | --- | --- | | `undefined` | Throws `TypeError` | | `null` | Throws `TypeError` | | boolean | `false` → `0n`, `true` → `1n` | | number | Example: `123` → `123n` | |  | Non-integer → throws `RangeError` | | bigint | `x` (no change) | | string | Example: `'123'` → `123n` | |  | Unparsable → throws `SyntaxError` | | symbol | Throws `TypeError` | | object | Configurable (e.g. via `.valueOf()`) |      Table 20.1: Converting values to bigints.      ##### [20.5.1.1 Converting `undefined` and `null`](#converting-undefined-and-null)    A `TypeError` is thrown if `x` is either `undefined` or `null`:    ```", "```js    ##### [20.5.1.2 Converting strings](#converting-strings)    If a string does not represent an integer, `BigInt()` throws a `SyntaxError` (whereas `Number()` returns the error value `NaN`):    ```", "```js    The suffix `'n'` is not allowed:    ```", "```js    All bases of bigint literals are allowed:    ```", "```js    ##### [20.5.1.3 Non-integer numbers produce exceptions](#noninteger-numbers-produce-exceptions)    ```", "```js    ##### [20.5.1.4 Converting objects](#converting-objects)    How objects are converted to bigints can be configured – for example, by overriding `.valueOf()`:    ```", "```js    #### [20.5.2 `BigInt.prototype.*` methods](#bigintprototype-methods)    `BigInt.prototype` holds the methods “inherited” by primitive bigints:    *   `BigInt.prototype.toLocaleString(locales?, options?)` *   `BigInt.prototype.toString(radix?)` *   `BigInt.prototype.valueOf()`    #### [20.5.3 `BigInt.*` methods: casting](#bigint-methods-casting)    *   `BigInt.asIntN(width, theInt)`     Casts `theInt` to `width` bits (signed). This influences how the value is represented internally.           *   `BigInt.asUintN(width, theInt)`     Casts `theInt` to `width` bits (unsigned).              ##### [20.5.3.1 Example: using 64-bit integers](#example-using-64bit-integers)    Casting allows us to create integer values with a specific number of bits – e.g., if we want to restrict ourselves to 64-bit integers, we always have to cast:    ```", "```js    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Implementing the analog of `Number.parseInt()` for bigints**    `exercises/bigints/parse-bigint_test.mjs`    ### [20.6 Coercing bigints to other primitive types](#coercing-bigints-to-other-primitive-types)    This table show what happens if we convert bigints to other primitive types:     | Convert to | Explicit conversion | Coercion (implicit conversion) | | --- | --- | --- | | boolean | `Boolean(0n)` → `false` | `!0n` → `true` | |  | `Boolean(int)` → `true` | `!int` → `false` | | number | `Number(7n)` → `7` (example) | `+int` → `TypeError` (1) | | string | `String(7n)` → `'7'` (example) | `''+7n` → `'7'` (example) |    Footnote:    *   (1) Unary `+` is not supported for bigints, because much code relies on it coercing its operand to number.    ### [20.7 Typed Array and DataView operations for 64-bit values](#typed-array-and-dataview-operations-for-64bit-values)    Thanks to bigints, Typed Arrays and DataViews can support 64-bit values:    *   Typed Array constructors:     *   `BigInt64Array`     *   `BigUint64Array` *   DataView methods:     *   `DataView.prototype.getBigInt64()`     *   `DataView.prototype.setBigInt64()`     *   `DataView.prototype.getBigUint64()`     *   `DataView.prototype.setBigUint64()`    ### [20.8 Bigints and JSON](#bigints-and-json)    The JSON standard is fixed and won’t change. The upside is that old JSON parsing code will never be outdated. The downside is that JSON can’t be extended to contain bigints.    Stringifying bigints throws exceptions:    ```", "```js    #### [20.8.1 Stringifying bigints](#stringifying-bigints)    Therefore, our best option is to store bigints in strings:    ```", "```js   ```", "```js` #### [20.8.2 Parsing bigints](#parsing-bigints)    The following code shows how to parse strings such as the one that we have produced in the previous example.    ```", "```js   ``### [20.9 FAQ: Bigints](#faq-bigints)    #### [20.9.1 How do I decide when to use numbers and when to use bigints?](#how-do-i-decide-when-to-use-numbers-and-when-to-use-bigints)    My recommendations:    *   Use numbers for up to 53 bits and for Array indices. Rationale: They already appear everywhere and are handled efficiently by most engines (especially if they fit into 31 bits). Appearances include:     *   `Array.prototype.forEach()`     *   `Array.prototype.entries()` *   Use bigints for large numeric values: If your fraction-less values don’t fit into 53 bits, you have no choice but to move to bigints.    All existing web APIs return and accept only numbers and will only upgrade to bigint on a case-by-case basis.    #### [20.9.2 Why not just increase the precision of numbers in the same manner as is done for bigints?](#why-not-just-increase-the-precision-of-numbers-in-the-same-manner-as-is-done-for-bigints)    One could conceivably split `number` into `integer` and `double`, but that would add many new complexities to the language (several integer-only operators etc.). I’ve sketched the consequences in [a Gist](https://gist.github.com/rauschma/13d48d1c49615ce2396ce7c9e45d4cd1).    * * *    **Acknowledgements:**    *   Thanks to Daniel Ehrenberg for reviewing an earlier version of this content. *   Thanks to Dan Callahan for reviewing an earlier version of this content.`` ```", "```js`` ```", "```js ```", "```js` ```", "```js`` ```", "```js```", "``````js````"]