["```js\n123n\n\n```", "```js\n> 123n * 456n\n56088n\n\n```", "```js\n> typeof 123n\n'bigint'\n\n```", "```js\n> 2**53 // can be represented but same as next number\n9007199254740992\n> 2**53 + 1 // wrong\n9007199254740992\n\n```", "```js\n> 2n**53n\n9007199254740992n\n> 2n**53n + 1n\n9007199254740993n\n\n```", "```js\n/**\n * Takes a bigint as an argument and returns a bigint\n */\nfunction nthPrime(nth) {\n  if (typeof nth !== 'bigint') {\n    throw new TypeError();\n  }\n  function isPrime(p) {\n    for (let i = 2n; i < p; i++) {\n      if (p % i === 0n) return false;\n    }\n    return true;\n  }\n  for (let i = 2n; ; i++) {\n    if (isPrime(i)) {\n      if (--nth === 0n) return i;\n    }\n  }\n}\n\nassert.deepEqual(\n  [1n, 2n, 3n, 4n, 5n].map(nth => nthPrime(nth)),\n  [2n, 3n, 5n, 7n, 11n]\n);\n\n```", "```js\nconst massOfEarthInKg = 6_000_000_000_000_000_000_000_000n;\n\n```", "```js\nconst priceInCents = 123_000_00n; // 123 thousand dollars\n\n```", "```js\n> 2n + 1\nTypeError: Cannot mix BigInt and other types, use explicit conversions\n\n```", "```js\n2**53 + 1n\n\n```", "```js\n2n**53n * 3.3\n\n```", "```js\n> 7n * 3n\n21n\n\n```", "```js\n> 6n + ' apples'\n'6 apples'\n\n```", "```js\n> 1n / 2n\n0n\n\n```", "```js\n> -(-64n)\n64n\n\n```", "```js\n> +23n\nTypeError: Cannot convert a BigInt value to a number\n\n```", "```js\n> 0n == false\ntrue\n> 1n == true\ntrue\n\n> 123n == 123\ntrue\n\n> 123n == '123'\ntrue\n\n```", "```js\n> 123n === 123\nfalse\n> 123n === 123n\ntrue\n\n```", "```js\n> 17n <= 17n\ntrue\n> 3n > -1n\ntrue\n\n```", "```js\n> 3n > -1\ntrue\n\n```", "```js\n> 2**32 - 1 >> 0 // 0b11111111111111111111111111111111\n-1\n\n```", "```js\n> 2**31 >> 0 // highest bit is 1\n-2147483648\n> 2**31 - 1 >> 0 // highest bit is 0\n2147483647\n\n```", "```js\nassert.equal(\n  ~0b10n,\n  -3n // ···111101\n);\nassert.equal(\n  ~-2n, // ···111110\n  1n\n);\n\n```", "```js\n> (0b1010n |  0b0111n).toString(2)\n'1111'\n> (0b1010n &  0b0111n).toString(2)\n'10'\n\n> (0b1010n | -1n).toString(2)\n'-1'\n> (0b1010n & -1n).toString(2)\n'1010'\n\n```", "```js\n> 2n << 1n\n4n\n> -2n << 1n\n-4n\n\n> 2n >> 1n\n1n\n> -2n >> 1n\n-1n\n\n```", "```js\n> -1n >> 20n\n-1n\n\n```", "```js\n> 2n >>> 1n\nTypeError: BigInts have no unsigned right shift, use >> instead\n\n```", "```js\n> BigInt(undefined)\nTypeError: Cannot convert undefined to a BigInt\n> BigInt(null)\nTypeError: Cannot convert null to a BigInt\n\n```", "```js\n> BigInt('abc')\nSyntaxError: Cannot convert abc to a BigInt\n\n```", "```js\n> BigInt('123n')\nSyntaxError: Cannot convert 123n to a BigInt\n\n```", "```js\n> BigInt('123')\n123n\n> BigInt('0xFF')\n255n\n> BigInt('0b1101')\n13n\n> BigInt('0o777')\n511n\n\n```", "```js\n> BigInt(123.45)\nRangeError: The number 123.45 cannot be converted to a BigInt because\nit is not an integer\n> BigInt(123)\n123n\n\n```", "```js\n> BigInt({valueOf() {return 123n}})\n123n \n```", "```js\nconst uint64a = BigInt.asUintN(64, 12345n);\nconst uint64b = BigInt.asUintN(64, 67890n);\nconst result = BigInt.asUintN(64, uint64a * uint64b);\n\n```", "```js\n> JSON.stringify(123n)\nTypeError: Do not know how to serialize a BigInt\n> JSON.stringify([123n])\nTypeError: Do not know how to serialize a BigInt\n\n```", "```js\nconst bigintPrefix = '[[bigint]]';\n\nfunction bigintReplacer(_key, value) {\n  if (typeof value === 'bigint') {\n    return bigintPrefix + value;\n  }\n  return value;\n}\n\nconst data = { value: 9007199254740993n };\nassert.equal(\n  JSON.stringify(data, bigintReplacer),\n  '{\"value\":\"[[bigint]]9007199254740993\"}'\n);\n\n```", "```js\nfunction bigintReviver(_key, value) {\n  if (typeof value === 'string' && value.startsWith(bigintPrefix)) {\n    return BigInt(value.slice(bigintPrefix.length));\n  }\n  return value;\n}\n\nconst str = '{\"value\":\"[[bigint]]9007199254740993\"}';\nassert.deepEqual(\n  JSON.parse(str, bigintReviver),\n  { value: 9007199254740993n }\n);\n\n```"]