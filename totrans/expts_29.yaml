- en: 24 Typing Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/ts/book/ch_typing-arrays.html](https://exploringjs.com/ts/book/ch_typing-arrays.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Ad, please don’t block.)
  prefs: []
  type: TYPE_NORMAL
- en: '[24.1 Ways of typing Arrays](#ways-of-typing-arrays)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[24.1.1 Array types: Array type literal `T[]` vs. generic type `Array<T>`](#array-types-array-type-literal-t-vs-generic-type-array-t)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[24.1.2 Tuple types: tuple type literals](#tuple-types-tuple-type-literals)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[24.1.3 Objects that are also Array-ish: interfaces with index signatures](#objects-that-are-also-array-ish-interfaces-with-index-signatures)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[24.2 Pitfall: type inference doesn’t always get Array types right](#pitfall-type-inference-doesn-t-always-get-array-types-right)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[24.2.1 Inferring types of Arrays is difficult](#inferring-types-of-arrays-is-difficult)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[24.2.2 Type inference for non-empty Array literals](#type-inference-for-non-empty-array-literals)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[24.2.3 Type inference for empty Array literals](#type-inference-for-empty-array-literals)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[24.3 Const assertions for Arrays and their effect on type inference](#const-assertions-for-arrays-and-their-effect-on-type-inference)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[24.3.1 `as const` pitfall: A const tuple is not assignable to a mutable type](#as-const-pitfall-a-const-tuple-is-not-assignable-to-a-mutable-type)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[24.3.2 `as const` pitfall: The inferred type is very narrow](#as-const-pitfall-the-inferred-type-is-very-narrow)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[24.3.3 More information on read-only Arrays and tuples](#more-information-on-read-only-arrays-and-tuples)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[24.4 Array pitfall: checking if an element exists](#array-pitfall-checking-if-an-element-exists)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[24.5 Why are there two notations? Why does TypeScript prefer `T[]`?](#why-are-there-two-notations-why-does-typescript-prefer-t)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[24.5.1 Why I prefer the notation `Array<T>`](#why-i-prefer-the-notation-array-t)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[24.5.2 One point in favor of `T[]`](#one-point-in-favor-of-t)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[24.5.3 Syntactic caveat: The `[]` in `T[]` binds strongly](#syntactic-caveat-the-in-t-binds-strongly)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[24.5.4 Linting Array notations](#linting-array-notations)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In this chapter, we examine how Arrays can be typed in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: '[24.1 Ways of typing Arrays](#ways-of-typing-arrays)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'TypeScript has two kinds of Array types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Array types: All elements have the same type. The length of the Array varies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tuple types: The length of the Array is fixed. The elements do not necessarily
    have the same type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[24.1.1 Array types: Array type literal `T[]` vs. generic type `Array<T>`](#array-types-array-type-literal-t-vs-generic-type-array-t)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An Array type literal consists of the element type followed by `[]`. In the
    following code, the Array type literal is `string[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An Array type literal is equivalent to using the generic type `Array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If the element type is more complicated, we need parentheses for Array type
    literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The generic type `Array` works better in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[24.1.2 Tuple types: tuple type literals](#tuple-types-tuple-type-literals)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If the Array has a fixed length and each element has a different, fixed type
    that depends on its position, then we can use tuple type literals such as `[string,
    string, boolean]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[24.1.3 Objects that are also Array-ish: interfaces with index signatures](#objects-that-are-also-array-ish-interfaces-with-index-signatures)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If an interface only has an index signature, we can use it for Arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'An interface that has both an index signature and property signatures, only
    works for objects (because indexed elements and properties need to be defined
    at the same time):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[24.2 Pitfall: type inference doesn’t always get Array types right](#pitfall-type-inference-doesn-t-always-get-array-types-right)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[24.2.1 Inferring types of Arrays is difficult](#inferring-types-of-arrays-is-difficult)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Due to the two kinds of Array types, it is impossible for TypeScript to always
    guess the right type. As an example, consider the following Array literal that
    is assigned to the variable `fields`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'What is the best type for `fields`? The following are all reasonable choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[24.2.2 Type inference for non-empty Array literals](#type-inference-for-non-empty-array-literals)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we use non-empty Array literals, TypeScript’s default is to infer Array
    types (not tuple types):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Alas, that’s not always what we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We need the keyword `readonly` in this line so that `pair3` (see below) is accepted.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fix the error in line B via a type annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option is a const assertion (`as const`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: More on const assertions soon.
  prefs: []
  type: TYPE_NORMAL
- en: '[24.2.3 Type inference for empty Array literals](#type-inference-for-empty-array-literals)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we initialize a variable with an empty Array literal, then TypeScript initially
    infers the type `any[]` and incrementally updates that type as we make changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, the error in line A goes away if we remove line B: TypeScript
    only complains about `any[]` if that type is observed in some manner.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use assignment instead of `.push()`, things work the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, if the Array literal has at least one element, then the element
    type is fixed and doesn’t change later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[24.3 Const assertions for Arrays and their effect on type inference](#const-assertions-for-arrays-and-their-effect-on-type-inference)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can suffix an Array literal with [a const assertion](ch_readonly.html#const-assertions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We are declaring that `rockCategories` won’t change. That has the following
    effects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Array becomes `readonly` – we can’t use operations that change it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'TypeScript infers a tuple. Compare:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: TypeScript infers narrow literal types (`'igneous'` etc.) instead of more general
    types. That is, the inferred tuple type is not `[string, string, string]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are more examples of Array literals with and without const assertions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[24.3.1 `as const` pitfall: A const tuple is not assignable to a mutable type](#as-const-pitfall-a-const-tuple-is-not-assignable-to-a-mutable-type)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'A mutable tuple does not have this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Lesson for us: If possible, we should use `readonly` for tuple parameters of
    functions and methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '[24.3.2 `as const` pitfall: The inferred type is very narrow](#as-const-pitfall-the-inferred-type-is-very-narrow)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The inferred type of a const-asserted Array literal is as narrow as possible.
    That causes an issue for `let`-declared variables: We cannot assign any tuple
    other than the one that we used for intialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[24.3.3 More information on read-only Arrays and tuples](#more-information-on-read-only-arrays-and-tuples)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: See [“Read-only accessibility (`readonly` etc.)” (§25)](ch_readonly.html#ch_readonly).
  prefs: []
  type: TYPE_NORMAL
- en: '[24.4 Array pitfall: checking if an element exists](#array-pitfall-checking-if-an-element-exists)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With [the compiler option `noUncheckedIndexedAccess`](ch_tsconfig-json.html#noUncheckedIndexedAccess),
    TypeScript always infers the type `undefined | T` for elements of an `Array<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Even checking `.length` in line A doesn’t change that. However, the `in` operator
    works better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can check for `undefined` after accessing the Array element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[24.5 Why are there two notations? Why does TypeScript prefer `T[]`?](#why-are-there-two-notations-why-does-typescript-prefer-t)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following two notations for an Array of strings are completely equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '`string[]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array<string>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why are there two notations?
  prefs: []
  type: TYPE_NORMAL
- en: '[TypeScript 0.9](https://devblogs.microsoft.com/typescript/announcing-typescript-0-9/)
    introduced generics to the language and enabled the notation `Array<T>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before that, `T[]` was the only notation for Arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So it looks like TypeScript simply stuck with the status quo when version 0.9
    came along: It still exclusively uses `T[]` – e.g., when inferring types or even
    when displaying a type that was written `Array<T>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though I have read once or twice that JSX is the cause of TypeScript’s
    preference, I don’t think that’s the case:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Array<T>` notation is compatible with JSX: It only exists at the type
    level and can be used without any problems in `.jsx` files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JSX does, however, make one syntax impossible to use – [type assertions via
    angle brackets](https://www.typescriptlang.org/docs/handbook/jsx.html#the-as-operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[24.5.1 Why I prefer the notation `Array<T>`](#why-i-prefer-the-notation-array-t)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I find it often looks better – especially if constructs related to element
    types get more complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'More reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array<T>` looks similar to `Set<T>` and `Map<K,V>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T[]` can be confused with `[T]` (tuples that have a single component whose
    type is `T`) – especially by people new to TypeScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we want to create an empty Array without a type annotation then that syntax
    is more consistent with the angle bracket type notation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[24.5.2 One point in favor of `T[]`](#one-point-in-favor-of-t)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because TypeScript always uses `T[]`, code that uses that notation is more consistent
    with language tooling.
  prefs: []
  type: TYPE_NORMAL
- en: '[24.5.3 Syntactic caveat: The `[]` in `T[]` binds strongly](#syntactic-caveat-the-in-t-binds-strongly)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The square brackets in `T[]` bind strongly. Therefore, we need to parenthesize
    any type `T` that consists of more than a single token – e.g. (line A, line B):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[24.5.4 Linting Array notations](#linting-array-notations)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'typescript-eslint has the rule [`array-type`](https://typescript-eslint.io/rules/array-type/)
    for enforcing a consistent Array notation style. The options are:'
  prefs: []
  type: TYPE_NORMAL
- en: Always `T[]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always `Array<T>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T[]` for single-token `T`; otherwise `Array<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
