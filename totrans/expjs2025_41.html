<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>34 Arrays (Array)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>34 Arrays (Array)</h1>
<blockquote>原文：<a href="https://exploringjs.com/js/book/ch_arrays.html">https://exploringjs.com/js/book/ch_arrays.html</a></blockquote>

        
    
    
    
<p><span id="index-entry-Array"/></p>
<nav class="local-toc">
  <ol>
    <li>
      <a href="#cheat-sheet-arrays">34.1 Cheat sheet: Arrays</a>
      <ol>
        <li>
          <a href="#using-arrays">34.1.1 Using Arrays</a>
        </li>
        <li>
          <a href="#the-most-commonly-used-array-methods">34.1.2 The most commonly used Array methods</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#arrays-fixed-layout-vs-sequence">34.2 Ways of using Arrays: fixed layout vs. sequence</a>
    </li>
    <li>
      <a href="#basic-array-operations">34.3 Basic Array operations</a>
      <ol>
        <li>
          <a href="#array-literals">34.3.1 Creating, reading, writing Arrays</a>
        </li>
        <li>
          <a href="#array-length">34.3.2 The <code>.length</code> of an Array</a>
        </li>
        <li>
          <a href="#referring-to-elements-via-negative-indices">34.3.3 Referring to elements via negative indices</a>
        </li>
        <li>
          <a href="#clearing-arrays">34.3.4 Clearing Arrays</a>
        </li>
        <li>
          <a href="#spreading-into-array-literals">34.3.5 Spreading into Array literals</a>
        </li>
        <li>
          <a href="#arrays-listing-indices-and-entries">34.3.6 Arrays: listing indices and entries</a>
        </li>
        <li>
          <a href="#checking-if-a-value-is-an-array-arrayisarray">34.3.7 Checking if a value is an Array: <code>Array.isArray()</code></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#for-of-arrays">34.4 <code>for-of</code> and Arrays</a>
      <ol>
        <li>
          <a href="#forof-iterating-over-elements">34.4.1 <code>for-of</code>: iterating over elements</a>
        </li>
        <li>
          <a href="#forof-iterating-over-indices">34.4.2 <code>for-of</code>: iterating over indices</a>
        </li>
        <li>
          <a href="#forof-iterating-over-index-element-pairs">34.4.3 <code>for-of</code>: iterating over [index, element] pairs</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#array-like-objects">34.5 Array-like objects</a>
    </li>
    <li>
      <a href="#converting-to-array">34.6 Converting iterables, iterators and Array-like values to Arrays</a>
      <ol>
        <li>
          <a href="#converting-iterables-to-arrays-via-spreading-">34.6.1 Converting iterables to Arrays via spreading (<code>...</code>)</a>
        </li>
        <li>
          <a href="#converting-iterators-to-arrays-via-toarray-es2025">34.6.2 Converting iterators to Arrays via <code>.toArray()</code><span> <sup>ES2025</sup></span></a>
        </li>
        <li>
          <a href="#Array.from">34.6.3 Converting iterables and Array-like objects to Arrays via <code>Array.from()</code></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#copying-arrays">34.7 Copying Arrays</a>
    </li>
    <li>
      <a href="#filling-arrays">34.8 Creating and filling Arrays with arbitrary lengths</a>
      <ol>
        <li>
          <a href="#creating-array-adding-elements-later">34.8.1 Creating an Array and adding elements later</a>
        </li>
        <li>
          <a href="#creating-array-with-primitives">34.8.2 Creating an Array filled with a primitive value</a>
        </li>
        <li>
          <a href="#creating-array-with-objects">34.8.3 Creating an Array filled with objects</a>
        </li>
        <li>
          <a href="#creating-array-with-range-of-integers">34.8.4 Creating an Array with a range of integers</a>
        </li>
        <li>
          <a href="#typed-arrays-work-well-if-the-elements-are-all-integers-or-all-floats">34.8.5 Typed Arrays work well if the elements are all integers or all floats</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#multidimensional-arrays">34.9 Multidimensional Arrays</a>
    </li>
    <li>
      <a href="#arrays-are-dictionaries">34.10 Arrays are actually dictionaries<span> (advanced)</span></a>
      <ol>
        <li>
          <a href="#array-indices">34.10.1 Array indices are (slightly special) property keys</a>
        </li>
        <li>
          <a href="#array-holes">34.10.2 Arrays can have holes</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#array-operations-destructive-vs-non-destructive">34.11 Destructive vs. non-destructive Array operations</a>
      <ol>
        <li>
          <a href="#how-to-make-destructive-array-methods-nondestructive">34.11.1 How to make destructive Array methods non-destructive</a>
        </li>
        <li>
          <a href="#nondestructive-versions-of-reverse-sort-splice-es2023">34.11.2 Non-destructive versions of <code>.reverse()</code>, <code>.sort()</code>, <code>.splice()</code><span> <sup>ES2023</sup></span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#adding-and-removing-elements-at-either-end-of-an-array">34.12 Adding and removing elements at either end of an Array</a>
      <ol>
        <li>
          <a href="#array-push-pop-shift-unshift">34.12.1 Destructively adding and removing elements at either end of an Array</a>
        </li>
        <li>
          <a href="#nondestructively-prepending-and-appending-elements">34.12.2 Non-destructively prepending and appending elements</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#array-element-callbacks">34.13 Array methods that accept element callbacks</a>
    </li>
    <li>
      <a href="#transforming-with-element-callbacks-map-filter-flatmap">34.14 Transforming with element callbacks: <code>.map()</code>, <code>.filter()</code>, <code>.flatMap()</code></a>
      <ol>
        <li>
          <a href="#map-each-output-element-is-derived-from-its-input-element">34.14.1 <code>.map()</code>: Each output element is derived from its input element</a>
        </li>
        <li>
          <a href="#filter-only-keep-some-of-the-elements">34.14.2 <code>.filter()</code>: Only keep some of the elements</a>
        </li>
        <li>
          <a href="#Array.prototype.flatMap">34.14.3 <code>.flatMap()</code>: Each input element produces zero or more output elements<span> <sup>ES2019</sup></span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#Array.prototype.reduce">34.15 <code>.reduce()</code>: computing a summary for an Array</a>
      <ol>
        <li>
          <a href="#an-overview-of-how-reduce-works">34.15.1 An overview of how <code>.reduce()</code> works</a>
        </li>
        <li>
          <a href="#what-happens-if-we-omit-init">34.15.2 What happens if we omit <code>init</code>?</a>
        </li>
        <li>
          <a href="#Array.prototype.reduceRight">34.15.3 <code>.reduceRight()</code>: the end-to-start version of <code>.reduce()</code></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#Array.prototype.sort">34.16 <code>.sort()</code>: sorting Arrays</a>
      <ol>
        <li>
          <a href="#customizing-array-sorting">34.16.1 Customizing the sort order</a>
        </li>
        <li>
          <a href="#sorting-arrays-with-numbers">34.16.2 Sorting numbers</a>
        </li>
        <li>
          <a href="#sorting-humanlanguage-strings">34.16.3 Sorting human-language strings</a>
        </li>
        <li>
          <a href="#sorting-objects">34.16.4 Sorting objects</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#grouping-array-elements">34.17 Grouping Array elements</a>
    </li>
    <li>
      <a href="#quickref-Array">34.18 Quick reference: <code>Array</code></a>
      <ol>
        <li>
          <a href="#new-array">34.18.1 <code>new Array()</code></a>
        </li>
        <li>
          <a href="#array">34.18.2 <code>Array.*</code></a>
        </li>
        <li>
          <a href="#arrayprototype-getting-setting-and-visiting-single-elements">34.18.3 <code>Array.prototype.*</code>: getting, setting and visiting single elements</a>
        </li>
        <li>
          <a href="#arrayprototype-keys-and-values">34.18.4 <code>Array.prototype.*</code>: keys and values</a>
        </li>
        <li>
          <a href="#arrayprototype-destructively-adding-or-removing-elements-at-either-end-of-an-array">34.18.5 <code>Array.prototype.*</code>: destructively adding or removing elements at either end of an Array</a>
        </li>
        <li>
          <a href="#arrayprototype-combining-extracting-and-changing-sequences-of-elements">34.18.6 <code>Array.prototype.*</code>: combining, extracting and changing sequences of elements</a>
        </li>
        <li>
          <a href="#arrayprototype-searching-for-elements">34.18.7 <code>Array.prototype.*</code>: searching for elements</a>
        </li>
        <li>
          <a href="#arrayprototype-filtering-and-mapping">34.18.8 <code>Array.prototype.*</code>: filtering and mapping</a>
        </li>
        <li>
          <a href="#arrayprototype-computing-summaries">34.18.9 <code>Array.prototype.*</code>: computing summaries</a>
        </li>
        <li>
          <a href="#arrayprototype-converting-to-string">34.18.10 <code>Array.prototype.*</code>: converting to string</a>
        </li>
        <li>
          <a href="#arrayprototype-sorting-and-reversing">34.18.11 <code>Array.prototype.*</code>: sorting and reversing</a>
        </li>
        <li>
          <a href="#sources-of-the-quick-reference">34.18.12 Sources of the quick reference</a>
        </li>
      </ol>
    </li>
  </ol>
</nav>
<h3 id="cheat-sheet-arrays"><a class="heading-id-link" href="#cheat-sheet-arrays">34.1 Cheat sheet: Arrays</a></h3>
<p>JavaScript Arrays are a very flexible data structure and used as lists, stacks, queues, tuples (e.g. pairs), and more.</p>
<p>Some Array-related operations destructively change Arrays. Others non-destructively produce new Arrays with the changes applied to a copy of the original content.</p>
<h4 id="using-arrays"><a class="heading-id-link" href="#using-arrays">34.1.1 Using Arrays</a></h4>
<p>Creating an Array, reading and writing elements:</p>
<pre class="language-js">
<span class="hljs-comment">// Creating an Array</span>
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]; <span class="hljs-comment">// Array literal</span>
assert.<span class="hljs-title function_">deepEqual</span>(
  arr,
  [ <span class="hljs-comment">// Array literal</span>
    <span class="hljs-string">'a'</span>,
    <span class="hljs-string">'b'</span>,
    <span class="hljs-string">'c'</span>, <span class="hljs-comment">// trailing commas are ignored</span>
  ]
);
<code/>
<span class="hljs-comment">// Reading elements</span>
assert.<span class="hljs-title function_">equal</span>(
  arr[<span class="hljs-number">0</span>], <span class="hljs-string">'a'</span> <span class="hljs-comment">// negative indices don’t work</span>
);
assert.<span class="hljs-title function_">equal</span>(
  arr.<span class="hljs-title function_">at</span>(-<span class="hljs-number">1</span>), <span class="hljs-string">'c'</span> <span class="hljs-comment">// negative indices work</span>
);
<code/>
<span class="hljs-comment">// Writing an element</span>
arr[<span class="hljs-number">0</span>] = <span class="hljs-string">'x'</span>;
assert.<span class="hljs-title function_">deepEqual</span>(
  arr, [<span class="hljs-string">'x'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]
);
</pre>
<p>The length of an Array:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
assert.<span class="hljs-title function_">equal</span>(
  arr.<span class="hljs-property">length</span>, <span class="hljs-number">3</span> <span class="hljs-comment">// number of elements</span>
);
arr.<span class="hljs-property">length</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// removing elements</span>
assert.<span class="hljs-title function_">deepEqual</span>(
  arr, [<span class="hljs-string">'a'</span>]
);
arr[arr.<span class="hljs-property">length</span>] = <span class="hljs-string">'b'</span>; <span class="hljs-comment">// adding an element</span>
assert.<span class="hljs-title function_">deepEqual</span>(
  arr, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]
);
</pre>
<p>Adding elements destructively via <code>.push()</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];
<code/>
arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">'c'</span>); <span class="hljs-comment">// adding an element</span>
assert.<span class="hljs-title function_">deepEqual</span>(
  arr, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]
);
<code/>
<span class="hljs-comment">// Pushing Arrays (used as arguments via spreading (...)):</span>
arr.<span class="hljs-title function_">push</span>(...[<span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>]);
assert.<span class="hljs-title function_">deepEqual</span>(
  arr, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>]
);
</pre>
<p>Adding elements non-destructively via spreading (<code>...</code>):</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];
<span class="hljs-keyword">const</span> arr2 = [<span class="hljs-string">'c'</span>];
assert.<span class="hljs-title function_">deepEqual</span>(
  [...arr1, ...arr2, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>],
  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>]
);
</pre>
<p>Looping over elements:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> arr) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);
}
</pre>
<p>Output:</p>
<pre>
a
b
c
</pre>
<p>Looping over index-value pairs:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [index, value] <span class="hljs-keyword">of</span> arr.<span class="hljs-title function_">entries</span>()) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index, value);
}
</pre>
<p>Output:</p>
<pre>
0 a
1 b
2 c
</pre>
<h4 id="the-most-commonly-used-array-methods"><a class="heading-id-link" href="#the-most-commonly-used-array-methods">34.1.2 The most commonly used Array methods</a></h4>
<p>This section demonstrates a few common Array methods. There is <a href="#quickref-Array">a more comprehensive quick reference</a> at the end of this chapter.</p>
<p>Destructively adding or removing an Array element at the start or the end:</p>
<pre class="language-js">
<span class="hljs-comment">// Adding and removing at the start</span>
<span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">'■'</span>, <span class="hljs-string">'●'</span>];
arr1.<span class="hljs-title function_">unshift</span>(<span class="hljs-string">'▲'</span>);
assert.<span class="hljs-title function_">deepEqual</span>(
  arr1, [<span class="hljs-string">'▲'</span>, <span class="hljs-string">'■'</span>, <span class="hljs-string">'●'</span>]
);
arr1.<span class="hljs-title function_">shift</span>();
assert.<span class="hljs-title function_">deepEqual</span>(
  arr1, [<span class="hljs-string">'■'</span>, <span class="hljs-string">'●'</span>]
);
<code/>
<span class="hljs-comment">// Adding and removing at the end</span>
<span class="hljs-keyword">const</span> arr2 = [<span class="hljs-string">'■'</span>, <span class="hljs-string">'●'</span>];
arr2.<span class="hljs-title function_">push</span>(<span class="hljs-string">'▲'</span>);
assert.<span class="hljs-title function_">deepEqual</span>(
  arr2, [<span class="hljs-string">'■'</span>, <span class="hljs-string">'●'</span>, <span class="hljs-string">'▲'</span>]
);
arr2.<span class="hljs-title function_">pop</span>();
assert.<span class="hljs-title function_">deepEqual</span>(
  arr2, [<span class="hljs-string">'■'</span>, <span class="hljs-string">'●'</span>]
);
</pre>
<p>Finding Array elements:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'■'</span>, <span class="hljs-string">'●'</span>, <span class="hljs-string">'■'</span>].<span class="hljs-title function_">includes</span>(<span class="hljs-string">'■'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'■'</span>, <span class="hljs-string">'●'</span>, <span class="hljs-string">'■'</span>].<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'■'</span>)</span>
0
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'■'</span>, <span class="hljs-string">'●'</span>, <span class="hljs-string">'■'</span>].<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">'■'</span>)</span>
2
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'●'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'▲'</span>].<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>)</span>
'●'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'●'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'▲'</span>].<span class="hljs-title function_">findLast</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>)</span>
'▲'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'●'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'▲'</span>].<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>)</span>
0
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'●'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'▲'</span>].<span class="hljs-title function_">findLastIndex</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>)</span>
2
</pre>
<p>Transforming Arrays (creating new ones without changing the originals):</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'▲'</span>, <span class="hljs-string">'●'</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x+x)</span>
['▲▲', '●●']
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'■'</span>, <span class="hljs-string">'●'</span>, <span class="hljs-string">'■'</span>].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x === <span class="hljs-string">'■'</span>) </span>
['■', '■']
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'▲'</span>, <span class="hljs-string">'●'</span>].<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> [x,x])</span>
['▲', '▲', '●', '●']
</pre>
<p>Copying parts of an Array:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'■'</span>, <span class="hljs-string">'●'</span>, <span class="hljs-string">'▲'</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)</span>
['●', '▲']
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'■'</span>, <span class="hljs-string">'●'</span>, <span class="hljs-string">'▲'</span>].<span class="hljs-title function_">slice</span>() <span class="hljs-comment">// complete copy</span></span>
['■', '●', '▲']
</pre>
<p>Concatenating the strings in an Array:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'■'</span>,<span class="hljs-string">'●'</span>,<span class="hljs-string">'▲'</span>].<span class="hljs-title function_">join</span>(<span class="hljs-string">'-'</span>)</span>
'■-●-▲'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'■'</span>,<span class="hljs-string">'●'</span>,<span class="hljs-string">'▲'</span>].<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>)</span>
'■●▲'
</pre>
<p><code>.sort()</code> sorts its receiver and returns it (if we don’t want to change the receiver, we can use <a href="#qref-Array.prototype.toSorted"><code>.toSorted()</code></a>):</p>
<pre class="language-js">
<span class="hljs-comment">// By default, string representations of the Array elements</span>
<span class="hljs-comment">// are sorted lexicographically:</span>
<span class="hljs-keyword">const</span> arr = [<span class="hljs-number">200</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>];
arr.<span class="hljs-title function_">sort</span>();
assert.<span class="hljs-title function_">deepEqual</span>(
  arr, [<span class="hljs-number">10</span>, <span class="hljs-number">200</span>, <span class="hljs-number">3</span>]
);
<code/>
<span class="hljs-comment">// Sorting can be customized via a callback:</span>
assert.<span class="hljs-title function_">deepEqual</span>(
  [<span class="hljs-number">200</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>].<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, z</span>) =&gt;</span> a - z), <span class="hljs-comment">// sort numerically</span>
  [<span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">200</span>]
);
</pre>
<h3 id="arrays-fixed-layout-vs-sequence"><a class="heading-id-link" href="#arrays-fixed-layout-vs-sequence">34.2 Ways of using Arrays: fixed layout vs. sequence</a></h3>
<p><span id="index-entry-fixed-layout-Arrays"/><span id="index-entry-Arrays--fixed-layout"/>
<span id="index-entry-sequence-Arrays"/><span id="index-entry-Arrays--sequence"/></p>
<p>These are the two most common ways of using Arrays in JavaScript:</p>
<ul>
  <li>
    Fixed-layout Arrays: Used this way, Arrays have a fixed number of indexed elements. Each of those elements can have a different type.
  </li>
  <li>
    Sequence Arrays: Used this way, Arrays have a variable number of indexed elements. Each of those elements has the same type. Sequence Arrays are very flexible; we can use them as (traditional) arrays, stacks, and queues. We’ll see how later.
  </li>
</ul>
<p>As an example of the difference between the two ways, consider the Array returned by <code>Object.entries()</code>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>({ <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> })</span>
[
  [ 'a', 1 ],
  [ 'b', 2 ],
  [ 'c', 3 ],
]
</pre>
<p>It is a sequence of <em>pairs</em> – fixed-layout Arrays with a length of two.</p>
<h3 id="basic-array-operations"><a class="heading-id-link" href="#basic-array-operations">34.3 Basic Array operations</a></h3>
<h4 id="array-literals"><a class="heading-id-link" href="#array-literals">34.3.1 Creating, reading, writing Arrays</a></h4>
<p><span id="index-entry-Array-literal"/></p>
<p>The best way to create an Array is via an <em>Array literal</em>:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
</pre>
<p>The Array literal starts and ends with square brackets <code>[]</code>. It creates an Array with three <em>elements</em>: <code>'a'</code>, <code>'b'</code>, and <code>'c'</code>.</p>
<p><span id="index-entry-trailing-commas-in-Array-literals"/></p>
<p>A comma after the last element is allowed and ignored in an Array literal:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [
  <span class="hljs-string">'a'</span>,
  <span class="hljs-string">'b'</span>,
  <span class="hljs-string">'c'</span>,
];
</pre>
<p>To read an Array element, we put an index in square brackets (indices start at zero):</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
assert.<span class="hljs-title function_">equal</span>(arr[<span class="hljs-number">0</span>], <span class="hljs-string">'a'</span>);
</pre>
<p>To change an Array element, we assign to an Array with an index:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
arr[<span class="hljs-number">0</span>] = <span class="hljs-string">'x'</span>;
assert.<span class="hljs-title function_">deepEqual</span>(arr, [<span class="hljs-string">'x'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]);
</pre>
<p>The range of Array indices is 32 bits (excluding the maximum length): [0, 2<sup>32</sup>−1)</p>
<h4 id="array-length"><a class="heading-id-link" href="#array-length">34.3.2 The <code>.length</code> of an Array</a></h4>
<p>Every Array has a property <code>.length</code> that can be used to both read and change(!) the number of elements in an Array.</p>
<p>The length of an Array is always the highest index plus one:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];
assert.<span class="hljs-title function_">equal</span>(arr.<span class="hljs-property">length</span>, <span class="hljs-number">2</span>);
</pre>
<p>If we write to the Array at the index of the length, we append an element:</p>
<pre class="language-js">
arr[arr.<span class="hljs-property">length</span>] = <span class="hljs-string">'c'</span>;
assert.<span class="hljs-title function_">deepEqual</span>(
  arr, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]
);
assert.<span class="hljs-title function_">equal</span>(arr.<span class="hljs-property">length</span>, <span class="hljs-number">3</span>)
</pre>
<p>If we set <code>.length</code>, we prune the Array and remove elements:</p>
<pre class="language-js">
arr.<span class="hljs-property">length</span> = <span class="hljs-number">1</span>;
assert.<span class="hljs-title function_">deepEqual</span>(
  arr, [<span class="hljs-string">'a'</span>]
);
</pre>
<p>To (destructively) append an element, we can also use the Array method <code>.push()</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];
arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">'c'</span>);
assert.<span class="hljs-title function_">deepEqual</span>(
  arr, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]
);
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Removing empty lines via <code>.push()</code></strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/arrays/remove_empty_lines_push_test.mjs</code></p>
</div>
<h4 id="referring-to-elements-via-negative-indices"><a class="heading-id-link" href="#referring-to-elements-via-negative-indices">34.3.3 Referring to elements via negative indices</a></h4>
<p>Most Array methods support negative indices. If an index is negative, it is added to the length of an Array to produce a usable index. Therefore, the following two invocations of <code>.slice()</code> are equivalent: They both copy <code>arr</code> starting at the last element.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">arr.<span class="hljs-title function_">slice</span>(-<span class="hljs-number">1</span>)</span>
[ 'c' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">arr.<span class="hljs-title function_">slice</span>(arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>)</span>
[ 'c' ]
</pre>
<h5 id="Array.prototype.at"><a class="heading-id-link" href="#Array.prototype.at">34.3.3.1 <code>.at()</code>: reading single elements (supports negative indices)<span> <sup>ES2022</sup></span></a></h5>
<p>The Array method <code>.at()</code> returns the element at a given index. It supports positive and negative indices (<code>-1</code> refers to the last element, <code>-2</code> refers to the second-last element, etc.):</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">at</span>(<span class="hljs-number">0</span>)</span>
'a'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">at</span>(-<span class="hljs-number">1</span>)</span>
'c'
</pre>
<p>In contrast, the bracket operator <code>[]</code> does not support negative indices (and can’t be changed because that would break existing code). It interprets them as keys of non-element properties:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
<code/>
arr[-<span class="hljs-number">1</span>] = <span class="hljs-string">'non-element property'</span>;
<span class="hljs-comment">// The Array elements didn’t change:</span>
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arr), <span class="hljs-comment">// copy just the Array elements</span>
  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]
);
<code/>
assert.<span class="hljs-title function_">equal</span>(
  arr[-<span class="hljs-number">1</span>], <span class="hljs-string">'non-element property'</span>
);
</pre>
<h4 id="clearing-arrays"><a class="heading-id-link" href="#clearing-arrays">34.3.4 Clearing Arrays</a></h4>
<p>We can clear an Array by setting its <code>.length</code> to zero:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
arr.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>;
assert.<span class="hljs-title function_">deepEqual</span>(arr, []);
</pre>
<p>We can also assign a new empty Array to the variable storing the Array:</p>
<pre class="language-js">
<span class="hljs-keyword">let</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
arr = [];
assert.<span class="hljs-title function_">deepEqual</span>(arr, []);
</pre>
<p>The latter approach has the advantage of not affecting other locations that point to the same Array. If, however, we do want to reset a shared Array for everyone, then we need the former approach.</p>
<h4 id="spreading-into-array-literals"><a class="heading-id-link" href="#spreading-into-array-literals">34.3.5 Spreading into Array literals</a></h4>
<p><span id="index-entry-spreading-into-an-Array-literal"/></p>
<p>Inside an Array literal, a <em>spread element</em> consists of three dots (<code>...</code>) followed by an expression. It results in the expression being evaluated and then iterated over. Each iterated value becomes an additional Array element – for example:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> iterable = [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, ...iterable, <span class="hljs-string">'d'</span>]</span>
[ 'a', 'b', 'c', 'd' ]
</pre>
<p>That means we can convert any iterable to an Array:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> iterable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>]);
assert.<span class="hljs-title function_">deepEqual</span>(
  [...iterable],
  [<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>]
);
</pre>
<p>Since Arrays are iterable, we can use spreading to copy them:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
<span class="hljs-keyword">const</span> copy = [...arr];
</pre>
<p>Spreading is also convenient for concatenating Arrays (and other iterables) into Arrays:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];
<span class="hljs-keyword">const</span> arr2 = [<span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>];
<code/>
<span class="hljs-keyword">const</span> concatenated = [...arr1, ...arr2, <span class="hljs-string">'e'</span>];
assert.<span class="hljs-title function_">deepEqual</span>(
  concatenated,
  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>]
);
</pre>
<p>Due to spreading using iteration, it only works if the value is iterable:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[...<span class="hljs-string">'abc'</span>] <span class="hljs-comment">// strings are iterable</span></span>
[ 'a', 'b', 'c' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[...<span class="hljs-number">123</span>]</span>
TypeError: 123 is not iterable
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[...<span class="hljs-literal">undefined</span>]</span>
TypeError: undefined is not iterable
</pre>
<h4 id="arrays-listing-indices-and-entries"><a class="heading-id-link" href="#arrays-listing-indices-and-entries">34.3.6 Arrays: listing indices and entries</a></h4>
<p>Method <code>.keys()</code> lists the indices of an Array:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];
arr.<span class="hljs-property">prop</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// needed later</span>
<code/>
assert.<span class="hljs-title function_">deepEqual</span>(
  arr.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">toArray</span>(), <span class="hljs-comment">// (A)</span>
  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]
);
</pre>
<p><code>.keys()</code> returns an iterator. In line A, we convert that iterator to an Array.</p>
<p>Listing Array indices is different from listing properties. The former produces numbers; the latter produces stringified numbers (in addition to non-index property keys):</p>
<pre class="language-js">
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(arr),
  [<span class="hljs-string">'0'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'prop'</span>]
);
</pre>
<p>Notice that the object property <code>arr.prop</code> shows up in the result.</p>
<p>Method <code>.entries()</code> lists the contents of an Array as [index, element] pairs:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">deepEqual</span>(
  arr.<span class="hljs-title function_">entries</span>().<span class="hljs-title function_">toArray</span>(),
  [
    [<span class="hljs-number">0</span>, <span class="hljs-string">'a'</span>],
    [<span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>],
  ]
);
</pre>
<p><code>Object.entries()</code> lists [property key, property value] pairs:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(arr),
  [
    [<span class="hljs-string">'0'</span>, <span class="hljs-string">'a'</span>],
    [<span class="hljs-string">'1'</span>, <span class="hljs-string">'b'</span>],
    [<span class="hljs-string">'prop'</span>, <span class="hljs-literal">true</span>],
  ]
);
</pre>
<p>Once again we see <code>arr.prop</code> in the result.</p>
<h4 id="checking-if-a-value-is-an-array-arrayisarray"><a class="heading-id-link" href="#checking-if-a-value-is-an-array-arrayisarray">34.3.7 Checking if a value is an Array: <code>Array.isArray()</code></a></h4>
<p><code>Array.isArray()</code> checks if a value is an Array:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>([])</span>
true
</pre>
<p>We can also use <code>instanceof</code>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span></span>
true
</pre>
<p>However, <code>instanceof</code> has one downside: It doesn’t work if a value comes from another <em>realm</em>. Roughly, a realm is an instance of JavaScript’s global scope. Some realms are isolated from each other (e.g., <a href="ch_async-js.html#web-workers">Web Workers</a> in browsers), but there are also realms between which we can move data – for example, same-origin iframes in browsers. <code>x instanceof Array</code> checks the prototype chain of <code>x</code> and therefore returns <code>false</code> if <code>x</code> is an Array from another realm.</p>
<p><code>typeof</code> considers Arrays to be objects:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">typeof</span> []</span>
'object'
</pre>
<h3 id="for-of-arrays"><a class="heading-id-link" href="#for-of-arrays">34.4 <code>for-of</code> and Arrays</a></h3>
<p>We have already encountered the <code>for-of</code> loop earlier in this book. This section briefly recaps how to use it for Arrays.</p>
<h4 id="forof-iterating-over-elements"><a class="heading-id-link" href="#forof-iterating-over-elements">34.4.1 <code>for-of</code>: iterating over elements</a></h4>
<p>The following <code>for-of</code> loop iterates over the elements of an Array:</p>
<pre class="language-js">
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> element <span class="hljs-keyword">of</span> [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(element);
}
</pre>
<p>Output:</p>
<pre>
a
b
</pre>
<h4 id="forof-iterating-over-indices"><a class="heading-id-link" href="#forof-iterating-over-indices">34.4.2 <code>for-of</code>: iterating over indices</a></h4>
<p>This <code>for-of</code> loop iterates over the indices of an Array:</p>
<pre class="language-js">
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> element <span class="hljs-keyword">of</span> [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>].<span class="hljs-title function_">keys</span>()) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(element);
}
</pre>
<p>Output:</p>
<pre>
0
1
</pre>
<h4 id="forof-iterating-over-index-element-pairs"><a class="heading-id-link" href="#forof-iterating-over-index-element-pairs">34.4.3 <code>for-of</code>: iterating over [index, element] pairs</a></h4>
<p>The following <code>for-of</code> loop iterates over [index, element] pairs. Destructuring (described <a href="ch_destructuring.html#ch_destructuring">later</a>), gives us convenient syntax for setting up <code>index</code> and <code>element</code> in the head of <code>for-of</code>.</p>
<pre class="language-js">
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [index, element] <span class="hljs-keyword">of</span> [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>].<span class="hljs-title function_">entries</span>()) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index, element);
}
</pre>
<p>Output:</p>
<pre>
0 a
1 b
</pre>
<h3 id="array-like-objects"><a class="heading-id-link" href="#array-like-objects">34.5 Array-like objects</a></h3>
<p><span id="index-entry-Array-like-object"/></p>
<p>Some operations that work with Arrays require only the bare minimum: values must only be <em>Array-like</em>. An Array-like value is an object with the following properties:</p>
<ul>
  <li>
    <code>.length</code>: holds the length of the Array-like object. If this property is missing, the value <code>0</code> is used.
  </li>
  <li>
    <code>[0]</code>: holds the element at index 0 (etc.). Note that if we use numbers as property names, they are always coerced to strings. Therefore, <code>[0]</code> retrieves the value of the property whose key is <code>'0'</code>.
  </li>
</ul>
<p>For example, <code>Array.from()</code> accepts Array-like objects and converts them to Arrays:</p>
<pre class="language-js">
<span class="hljs-comment">// .length is implicitly 0 in this case</span>
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({}),
  []
);
<code/>
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({<span class="hljs-attr">length</span>: <span class="hljs-number">2</span>, <span class="hljs-number">0</span>: <span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>: <span class="hljs-string">'b'</span>}),
  [ <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span> ]
);
</pre>
<p>The TypeScript interface for Array-like objects is:</p>
<pre class="language-ts">
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">ArrayLike</span>&lt;T&gt; {
  <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;
  [<span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span>]: T;
}
</pre>
<div class="boxout">
  <p><img src="../Images/38ba63de820aae6f94a019538ae0f222.png" class="boxout-icon" height="24" alt="Icon “details”" data-original-src="https://exploringjs.com/js/book/icon/details.svg"/> <strong>Array-like objects are relatively rare in modern JavaScript</strong></p>
  <div class="boxout-vspace"/>
  <p>Array-like objects used to be more common before ES6; now we don’t see them very often.</p>
</div>
<h3 id="converting-to-array"><a class="heading-id-link" href="#converting-to-array">34.6 Converting iterables, iterators and Array-like values to Arrays</a></h3>
<p>In this section we explore how we can convert various values to Array:</p>
<ul>
  <li>
    Converting iterables to Arrays via spreading (<code>...</code>)
  </li>
  <li>
    Converting iterators to Arrays via <code>.toArray()</code>
  </li>
  <li>
    Converting iterables and Array-like objects to Arrays via <code>Array.from()</code>
  </li>
</ul>
<h4 id="converting-iterables-to-arrays-via-spreading-"><a class="heading-id-link" href="#converting-iterables-to-arrays-via-spreading-">34.6.1 Converting iterables to Arrays via spreading (<code>...</code>)</a></h4>
<p>Inside an Array literal, spreading via <code>...</code> converts any iterable object into a series of Array elements. For example:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> iterable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]);
assert.<span class="hljs-title function_">deepEqual</span>(
  [...iterable],
  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]
);
</pre>
<h4 id="converting-iterators-to-arrays-via-toarray-es2025"><a class="heading-id-link" href="#converting-iterators-to-arrays-via-toarray-es2025">34.6.2 Converting iterators to Arrays via <code>.toArray()</code><span> <sup>ES2025</sup></span></a></h4>
<p>If we have an iterator, we can use method <code>.toArray()</code> to store its values in an Array:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> iterable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]);
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Iterator</span>.<span class="hljs-title function_">from</span>(iterable).<span class="hljs-title function_">toArray</span>(),
  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]
);
</pre>
<p>Instead of <code>Iterator.from()</code> we can also use a method that returns an iterator (such as <code>.keys()</code>, <code>.values()</code> and <code>.entries()</code>):</p>
<pre class="language-js">
assert.<span class="hljs-title function_">deepEqual</span>(
  iterable.<span class="hljs-title function_">values</span>().<span class="hljs-title function_">toArray</span>(),
  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]
);
</pre>
<h4 id="Array.from"><a class="heading-id-link" href="#Array.from">34.6.3 Converting iterables and Array-like objects to Arrays via <code>Array.from()</code></a></h4>
<p><code>Array.from()</code> can be used in two modes.</p>
<h5 id="mode-1-of-arrayfrom-converting"><a class="heading-id-link" href="#mode-1-of-arrayfrom-converting">34.6.3.1 Mode 1 of <code>Array.from()</code>: converting</a></h5>
<p>The first mode has the following type signature:</p>
<pre class="language-ts">
.<span class="hljs-property">from</span>&lt;T&gt;(<span class="hljs-attr">iterable</span>: <span class="hljs-title class_">Iterable</span>&lt;T&gt; | <span class="hljs-title class_">ArrayLike</span>&lt;T&gt;): <span class="hljs-title class_">Array</span>&lt;T&gt;
</pre>
<p>Interface <code>Iterable</code> is shown <a href="ch_sync-iteration.html#iterable-iterator-iteratorresult">in the chapter on synchronous iteration</a>. Interface <code>ArrayLike</code> appeared <a href="#array-like-objects">earlier in this chapter</a>.</p>
<p>With a single parameter, <code>Array.from()</code> converts anything iterable or Array-like to an Array:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>])) <span class="hljs-comment">// iterable</span></span>
[ 'a', 'b' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({<span class="hljs-attr">length</span>: <span class="hljs-number">2</span>, <span class="hljs-number">0</span>:<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>:<span class="hljs-string">'b'</span>}) <span class="hljs-comment">// Array-like</span></span>
[ 'a', 'b' ]
</pre>
<h5 id="mode-2-of-arrayfrom-converting-and-mapping"><a class="heading-id-link" href="#mode-2-of-arrayfrom-converting-and-mapping">34.6.3.2 Mode 2 of <code>Array.from()</code>: converting and mapping</a></h5>
<p>The second mode of <code>Array.from()</code> involves two parameters:</p>
<pre class="language-ts">
.<span class="hljs-property">from</span>&lt;T, U&gt;(
  <span class="hljs-attr">iterable</span>: <span class="hljs-title class_">Iterable</span>&lt;T&gt; | <span class="hljs-title class_">ArrayLike</span>&lt;T&gt;,
  <span class="hljs-attr">mapFunc</span>: <span class="hljs-function">(<span class="hljs-params">v: T, i: <span class="hljs-built_in">number</span></span>) =&gt;</span> U,
  thisArg?: <span class="hljs-built_in">any</span>
): <span class="hljs-title class_">Array</span>&lt;U&gt;
</pre>
<p>In this mode, <code>Array.from()</code> does several things:</p>
<ul>
  <li>
    It iterates over <code>iterable</code>.
  </li>
  <li>
    It calls <code>mapFunc</code> with each iterated value. The optional parameter <code>thisArg</code> specifies a <code>this</code> for <code>mapFunc</code>.
  </li>
  <li>
    It applies <code>mapFunc</code> to each iterated value.
  </li>
  <li>
    It collects the results in a new Array and returns it.
  </li>
</ul>
<p>In other words: we are going from an iterable with elements of type <code>T</code> to an Array with elements of type <code>U</code>.</p>
<p>This is an example:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]), <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + x)</span>
[ 'aa', 'bb' ]
</pre>
<h3 id="copying-arrays"><a class="heading-id-link" href="#copying-arrays">34.7 Copying Arrays</a></h3>
<p>The following code shows five ways of copying the Array <code>arr</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];
<code/>
<span class="hljs-keyword">const</span> shallowCopy1 = arr.<span class="hljs-title function_">slice</span>();
<span class="hljs-keyword">const</span> shallowCopy2 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arr);
<span class="hljs-keyword">const</span> shallowCopy3 = [...arr];
<span class="hljs-keyword">const</span> shallowCopy4 = arr.<span class="hljs-title function_">values</span>().<span class="hljs-title function_">toArray</span>();
<code/>
<span class="hljs-keyword">const</span> deepCopy = <span class="hljs-title function_">structuredClone</span>(arr);
<code/>
<span class="hljs-keyword">const</span> copies = [
  shallowCopy1, shallowCopy2, shallowCopy3, shallowCopy4, deepCopy
];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> copy <span class="hljs-keyword">of</span> copies) {
  assert.<span class="hljs-title function_">deepEqual</span>(copy, arr);
}
</pre>
<p>Only <code>structuredClone()</code> produces a <em>deep copy</em>. In each other case, the copy is <em>shallow</em>: It contains copies of the [index, element] entries but the elements themselves are shared with the original Array. For more information, including the limitations of <code>structuredClone()</code>, see <a href="ch_objects.html#copying-objects">“Copying objects: spreading vs. <code>Object.assign()</code> vs. <code>structuredClone()</code>” (§30.5)</a>.</p>
<h3 id="filling-arrays"><a class="heading-id-link" href="#filling-arrays">34.8 Creating and filling Arrays with arbitrary lengths</a></h3>
<p>The best way of creating an Array is via an Array literal. However, we can’t always use one: The Array may be too large, we may not know its length during development, or we may want to keep its length flexible. Then I recommend the following techniques for creating, and possibly filling, Arrays.</p>
<h4 id="creating-array-adding-elements-later"><a class="heading-id-link" href="#creating-array-adding-elements-later">34.8.1 Creating an Array and adding elements later</a></h4>
<p>The most common technique for creating an Array and adding elements later, is to start with an empty Array and push values into it:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; i++) {
  arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">'*'</span>.<span class="hljs-title function_">repeat</span>(i));
}
assert.<span class="hljs-title function_">deepEqual</span>(
  arr, [<span class="hljs-string">''</span>, <span class="hljs-string">'*'</span>, <span class="hljs-string">'**'</span>]
);
</pre>
<h4 id="creating-array-with-primitives"><a class="heading-id-link" href="#creating-array-with-primitives">34.8.2 Creating an Array filled with a primitive value</a></h4>
<p>The following code creates an Array that is filled with a primitive value:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>)</span>
[ 0, 0, 0 ]
</pre>
<p><code>.fill()</code> replaces each Array element or hole with a given value. We use it to fill an Array that has 3 holes:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>)</span>
[ , , ,]
</pre>
<p>Note that the result has <a href="#array-holes">three <em>holes</em> (empty slots)</a> – the last comma in an Array literal is always ignored.</p>
<h4 id="creating-array-with-objects"><a class="heading-id-link" href="#creating-array-with-objects">34.8.3 Creating an Array filled with objects</a></h4>
<p>If we use <code>.fill()</code> with an object, then each Array element will refer to this same single object:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">fill</span>({});
arr[<span class="hljs-number">0</span>].<span class="hljs-property">prop</span> = <span class="hljs-literal">true</span>;
assert.<span class="hljs-title function_">deepEqual</span>(
  arr, [
    {<span class="hljs-attr">prop</span>: <span class="hljs-literal">true</span>},
    {<span class="hljs-attr">prop</span>: <span class="hljs-literal">true</span>},
    {<span class="hljs-attr">prop</span>: <span class="hljs-literal">true</span>},
  ]);
</pre>
<p>How can we fix this? We can use <a href="#Array.from"><code>Array.from()</code></a>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>), <span class="hljs-function">() =&gt;</span> ({}))</span>
[{}, {}, {}]
</pre>
<p>Calling <code>Array.from()</code> with two arguments:</p>
<ul>
  <li>
    extracts the elements of the first argument (which must be iterable or Array-like),
  </li>
  <li>
    maps them via the callback in the second argument and
  </li>
  <li>
    returns the result in an Array.
  </li>
</ul>
<p>In contrast to <code>.fill()</code>, which reuses the same object multiple times, the previous code creates a new object for each element.</p>
<p>Could we have used <code>.map()</code> in this case? Unfortunately not because <code>.map()</code> ignores but preserves holes (whereas <code>Array.from()</code> treats them as <code>undefined</code> elements):</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> ({}))</span>
[ , , ,]
</pre>
<p>For large sizes, the temporary Array in the first argument can consume quite a bit of memory. The following approach doesn’t have this downside but is less self-descriptive:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({<span class="hljs-attr">length</span>: <span class="hljs-number">3</span>}, <span class="hljs-function">() =&gt;</span> ({}))</span>
[{}, {}, {}]
</pre>
<p>Instead of a temporary Array, we are using a temporary <a href="#array-like-objects">Array-like object</a>.</p>
<h4 id="creating-array-with-range-of-integers"><a class="heading-id-link" href="#creating-array-with-range-of-integers">34.8.4 Creating an Array with a range of integers</a></h4>
<p>To create an Array with a range of integers, we use <code>Array.from()</code> similarly to how we did in the previous subsection:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createRange</span>(<span class="hljs-params">start, end</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({<span class="hljs-attr">length</span>: end-start}, <span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> i+start);
}
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title function_">createRange</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>),
  [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);
</pre>
<p>Here is an alternative, slightly hacky technique for creating integer ranges that start at zero:</p>
<pre class="language-js">
<span class="hljs-comment">/** Returns an iterable */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createRange</span>(<span class="hljs-params">end</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(end).<span class="hljs-title function_">keys</span>();
}
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-title function_">createRange</span>(<span class="hljs-number">4</span>)),
  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
);
</pre>
<p>This works because <code>.keys()</code> treats <a href="#array-holes"><em>holes</em></a> like <code>undefined</code> elements and lists their indices.</p>
<h4 id="typed-arrays-work-well-if-the-elements-are-all-integers-or-all-floats"><a class="heading-id-link" href="#typed-arrays-work-well-if-the-elements-are-all-integers-or-all-floats">34.8.5 Typed Arrays work well if the elements are all integers or all floats</a></h4>
<p>When dealing with Arrays of integers or floats, we should consider <a href="ch_typed-arrays.html#ch_typed-arrays"><em>Typed Arrays</em></a>, which were created for this purpose.</p>
<h3 id="multidimensional-arrays"><a class="heading-id-link" href="#multidimensional-arrays">34.9 Multidimensional Arrays</a></h3>
<p><span id="index-entry-multidimensional-Array"/><span id="index-entry-Array--multidimensional"/></p>
<p>JavaScript does not have real multidimensional Arrays; we need to resort to Arrays whose elements are Arrays:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">initMultiArray</span>(<span class="hljs-params">...dimensions</span>) {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">initMultiArrayRec</span>(<span class="hljs-params">dimIndex</span>) {
    <span class="hljs-keyword">if</span> (dimIndex &gt;= dimensions.<span class="hljs-property">length</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">const</span> dim = dimensions[dimIndex];
      <span class="hljs-keyword">const</span> arr = [];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;dim; i++) {
        arr.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">initMultiArrayRec</span>(dimIndex+<span class="hljs-number">1</span>));
      }
      <span class="hljs-keyword">return</span> arr;
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">initMultiArrayRec</span>(<span class="hljs-number">0</span>);
}
<code/>
<span class="hljs-keyword">const</span> arr = <span class="hljs-title function_">initMultiArray</span>(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>);
arr[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">'X'</span>; <span class="hljs-comment">// last in each dimension</span>
assert.<span class="hljs-title function_">deepEqual</span>(arr, [
  [ [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ], [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ], [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ] ],
  [ [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ], [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ], [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ] ],
  [ [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ], [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ], [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ] ],
  [ [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ], [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ], [ <span class="hljs-number">0</span>, <span class="hljs-string">'X'</span> ] ],
]);
</pre>
<h3 id="arrays-are-dictionaries"><a class="heading-id-link" href="#arrays-are-dictionaries">34.10 Arrays are actually dictionaries<span> (advanced)</span></a></h3>
<p>In this section, we examine how exactly Arrays store their elements: in properties. We usually don’t need to know that but it helps with understanding a few rarer Array phenomena.</p>
<h4 id="array-indices"><a class="heading-id-link" href="#array-indices">34.10.1 Array indices are (slightly special) property keys</a></h4>
<p>You’d think that Array elements are special because we are accessing them via numbers. But the square brackets operator <code>[]</code> for doing so is the same operator that is used for accessing properties. It coerces any non-symbol value to a string. Therefore, Array elements are (almost) normal properties (line A) and it doesn’t matter if we use numbers or strings as indices (line B and line C):</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];
arr.<span class="hljs-property">prop</span> = <span class="hljs-number">123</span>;
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(arr),
  [<span class="hljs-string">'0'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'prop'</span>] <span class="hljs-comment">// (A)</span>
);
<code/>
assert.<span class="hljs-title function_">equal</span>(arr[<span class="hljs-number">0</span>], <span class="hljs-string">'a'</span>);  <span class="hljs-comment">// (B)</span>
assert.<span class="hljs-title function_">equal</span>(arr[<span class="hljs-string">'0'</span>], <span class="hljs-string">'a'</span>); <span class="hljs-comment">// (C)</span>
</pre>
<p><span id="index-entry-Array-index"/><span id="index-entry-index-of-an-Array"/></p>
<p>Property keys (strings!) that are used for Array elements are called <a href="https://tc39.es/ecma262/#integer-index"><em>indices</em></a>. A string <code>str</code> is an index if converting it to a 32-bit unsigned integer and back results in the original value. Written as a formula:</p>
<pre class="language-txt">
ToString(ToUint32(str)) === str
</pre>
<h5 id="internally-javascript-engines-optimize-how-arrays-are-managed"><a class="heading-id-link" href="#internally-javascript-engines-optimize-how-arrays-are-managed">34.10.1.1 Internally, JavaScript engines optimize how Arrays are managed</a></h5>
<p>When using JavaScript and in the ECMAScript specification, Array elements are properties and Array indices are string-valued property keys.</p>
<p>However, internally, virtually all JavaScript engines optimize how Arrays are managed: They store their elements sequentially and used indices as numeric offsets. Engines may switch to a more dictionary-like representation if the elements of an Array are not contiguous – if there are holes between them. More on holes in Arrays soon.</p>
<h5 id="listing-indices"><a class="heading-id-link" href="#listing-indices">34.10.1.2 Listing indices</a></h5>
<p>When listing property keys, <a href="ch_objects.html#order-of-properties">indices are treated specially</a> – they always come first and are sorted like numbers (<code>'2'</code> comes before <code>'10'</code>):</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [];
arr.<span class="hljs-property">prop</span> = <span class="hljs-literal">true</span>;
arr[<span class="hljs-number">1</span>] = <span class="hljs-string">'b'</span>;
arr[<span class="hljs-number">0</span>] = <span class="hljs-string">'a'</span>;
<code/>
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(arr),
  [<span class="hljs-string">'0'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'prop'</span>]
);
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(arr),
  [[<span class="hljs-string">'0'</span>, <span class="hljs-string">'a'</span>], [<span class="hljs-string">'1'</span>, <span class="hljs-string">'b'</span>], [<span class="hljs-string">'prop'</span>, <span class="hljs-literal">true</span>]]
);
</pre>
<p>Note that <code>.keys()</code> and <code>.entries()</code> treat Array indices as numbers and ignore non-index properties:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arr.<span class="hljs-title function_">keys</span>()),
  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]
);
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arr.<span class="hljs-title function_">entries</span>()),
  [[<span class="hljs-number">0</span>, <span class="hljs-string">'a'</span>], [<span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>]]
);
</pre>
<p>We used <a href="#Array.from"><code>Array.from()</code></a> to convert the iterables returned by <code>.keys()</code> and <code>.entries()</code> to Arrays.</p>
<h4 id="array-holes"><a class="heading-id-link" href="#array-holes">34.10.2 Arrays can have holes</a></h4>
<p><span id="index-entry-Array-hole"/><span id="index-entry-hole-in-an-Array"/>
<span id="index-entry-Array--dense"/><span id="index-entry-dense-Array"/>
<span id="index-entry-Array--sparse"/><span id="index-entry-sparse-Array"/></p>
<p>We distinguish two kinds of Arrays in JavaScript:</p>
<ul>
  <li>
    An Array <code>arr</code> is <em>dense</em> if all indices <code>i</code>, with 0 ≤ <code>i</code> &lt; <code>arr.length</code>, exist. That is, the indices form a contiguous range.
  </li>
  <li>
    An Array is <em>sparse</em> if the range of indices has <em>holes</em> in it. That is, some indices are missing.
  </li>
</ul>
<p>Arrays can be sparse in JavaScript because Arrays are actually dictionaries from indices to values.</p>
<div class="boxout">
  <p><img src="../Images/8440b17bb8219cda9f9405ac83c36db0.png" class="boxout-icon" height="24" alt="Icon “tip”" data-original-src="https://exploringjs.com/js/book/icon/tip.svg"/> <strong>Recommendation: avoid holes</strong></p>
  <div class="boxout-vspace"/>
  <p>So far, we have only seen dense Arrays and it’s indeed recommended to avoid holes: They make our code more complicated and are not handled consistently by Array methods. Additionally, JavaScript engines optimize dense Arrays, making them faster.</p>
</div>
<h5 id="creating-array-holes"><a class="heading-id-link" href="#creating-array-holes">34.10.2.1 Creating Array holes</a></h5>
<p>We can create holes by skipping indices when assigning elements:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [];
arr[<span class="hljs-number">0</span>] = <span class="hljs-string">'a'</span>;
arr[<span class="hljs-number">2</span>] = <span class="hljs-string">'c'</span>;
<code/>
assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(arr), [<span class="hljs-string">'0'</span>, <span class="hljs-string">'2'</span>]); <span class="hljs-comment">// (A)</span>
<code/>
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">0</span> <span class="hljs-keyword">in</span> arr, <span class="hljs-literal">true</span>); <span class="hljs-comment">// element</span>
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> arr, <span class="hljs-literal">false</span>); <span class="hljs-comment">// hole</span>
</pre>
<p>In line A, we are using <code>Object.keys()</code> because <code>arr.keys()</code> treats holes as if they were <code>undefined</code> elements and does not reveal them.</p>
<p>Another way of creating holes is to skip elements in Array literals:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, , <span class="hljs-string">'c'</span>];
<code/>
assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(arr), [<span class="hljs-string">'0'</span>, <span class="hljs-string">'2'</span>]);
</pre>
<p>We can also add holes at the end by increasing <code>.length</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>];
assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(arr), [<span class="hljs-string">'0'</span>]);
assert.<span class="hljs-title function_">equal</span>(arr.<span class="hljs-property">length</span>, <span class="hljs-number">1</span>);
arr.<span class="hljs-property">length</span> = <span class="hljs-number">3</span>;
arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">'x'</span>);
assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(arr), [<span class="hljs-string">'0'</span>, <span class="hljs-string">'3'</span>]);
assert.<span class="hljs-title function_">deepEqual</span>(arr, [<span class="hljs-string">'a'</span>, <span class="hljs-comment">/*hole*/</span>, <span class="hljs-comment">/*hole*/</span>, <span class="hljs-string">'x'</span>]);
</pre>
<p>Deleting Array elements creates holes, too:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(arr), [<span class="hljs-string">'0'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>]);
<span class="hljs-keyword">delete</span> arr[<span class="hljs-number">1</span>];
assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(arr), [<span class="hljs-string">'0'</span>, <span class="hljs-string">'2'</span>]);
assert.<span class="hljs-title function_">deepEqual</span>(arr, [<span class="hljs-string">'a'</span>, , <span class="hljs-string">'c'</span>]);
</pre>
<h5 id="how-do-array-operations-treat-holes"><a class="heading-id-link" href="#how-do-array-operations-treat-holes">34.10.2.2 How do Array operations treat holes?</a></h5>
<p>Alas, there are many different ways in which Array operations treat holes.</p>
<p>Some Array operations remove holes:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>,,<span class="hljs-string">'b'</span>].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-literal">true</span>)</span>
[ 'a', 'b' ]
</pre>
<p>Some Array operations ignore holes:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, ,<span class="hljs-string">'a'</span>].<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x === <span class="hljs-string">'a'</span>)</span>
true
</pre>
<p>Some Array operations ignore but preserve holes:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>,,<span class="hljs-string">'b'</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-string">'c'</span>)</span>
[ 'c', , 'c' ]
</pre>
<p>Some Array operations treat holes as <code>undefined</code> elements:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>([<span class="hljs-string">'a'</span>,,<span class="hljs-string">'b'</span>])</span>
[ 'a', undefined, 'b' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>([<span class="hljs-string">'a'</span>,,<span class="hljs-string">'b'</span>], <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + <span class="hljs-string">'!'</span>) <span class="hljs-comment">// mapping</span></span>
[ 'a!', 'undefined!', 'b!' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>,,<span class="hljs-string">'b'</span>].<span class="hljs-title function_">entries</span>().<span class="hljs-title function_">toArray</span>()</span>
[[0, 'a'], [1, undefined], [2, 'b']]
</pre>
<p><code>Object.keys()</code> works differently than <code>.keys()</code> (strings vs. numbers, holes don’t have keys):</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>,,<span class="hljs-string">'b'</span>].<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">toArray</span>()</span>
[ 0, 1, 2 ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>([<span class="hljs-string">'a'</span>,,<span class="hljs-string">'b'</span>])</span>
[ '0', '2' ]
</pre>
<p>There is no common rule to remember here. If it ever matters how an Array operation treats holes, the best approach is to do a quick test in a console.</p>
<h3 id="array-operations-destructive-vs-non-destructive"><a class="heading-id-link" href="#array-operations-destructive-vs-non-destructive">34.11 Destructive vs. non-destructive Array operations</a></h3>
<p>Some Array operations are <em>destructive</em>: They change the Array they operate on – e.g., setting an element:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
<code/>
arr[<span class="hljs-number">1</span>] = <span class="hljs-string">'x'</span>;
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-comment">// The original was modified</span>
  arr, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'x'</span>, <span class="hljs-string">'c'</span>]
);
</pre>
<p>Other Array operations are <em>non-destructive</em>: They produce new Arrays that contain the desired changes and don’t touch the originals – e.g., method <code>.with()</code> is the non-destructive version of setting elements:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
<code/>
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-comment">// Produces a copy with changes</span>
  arr.<span class="hljs-title function_">with</span>(<span class="hljs-number">1</span>, <span class="hljs-string">'x'</span>),
  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'x'</span>, <span class="hljs-string">'c'</span>]
);
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-comment">// The original is unchanged</span>
  arr, [ <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span> ]
);
</pre>
<h4 id="how-to-make-destructive-array-methods-nondestructive"><a class="heading-id-link" href="#how-to-make-destructive-array-methods-nondestructive">34.11.1 How to make destructive Array methods non-destructive</a></h4>
<p>These are three common destructive Array methods:</p>
<ul>
  <li>
    <code>.reverse()</code>
  </li>
  <li>
    <code>.sort()</code>
  </li>
  <li>
    <code>.splice()</code>
  </li>
</ul>
<p>We’ll get to <a href="#Array.prototype.sort"><code>.sort()</code></a> and <a href="#qref-Array.prototype.splice"><code>.splice()</code></a> later in this chapter. <code>.reverse()</code> rearranges an Array so that the order of its elements is reversed: The element that was previously last now comes first; the second-last element comes second; etc.:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> original = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
<span class="hljs-keyword">const</span> reversed = original.<span class="hljs-title function_">reverse</span>();
<code/>
assert.<span class="hljs-title function_">deepEqual</span>(reversed, [<span class="hljs-string">'c'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>]);
assert.<span class="hljs-title function_">ok</span>(reversed === original); <span class="hljs-comment">// .reverse() returned `this`</span>
assert.<span class="hljs-title function_">deepEqual</span>(original, [<span class="hljs-string">'c'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>]);
</pre>
<p>To prevent a destructive method from changing an Array, we can make a copy before using it – e.g.:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> original = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
<code/>
<span class="hljs-keyword">const</span> reversed1 = original.<span class="hljs-title function_">slice</span>().<span class="hljs-title function_">reverse</span>();
<span class="hljs-keyword">const</span> reversed2 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(original).<span class="hljs-title function_">reverse</span>();
<span class="hljs-keyword">const</span> reversed3 = [...original].<span class="hljs-title function_">reverse</span>();
<span class="hljs-keyword">const</span> reversed4 = original.<span class="hljs-title function_">values</span>().<span class="hljs-title function_">toArray</span>().<span class="hljs-title function_">reverse</span>();
<code/>
assert.<span class="hljs-title function_">deepEqual</span>(original, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]);
</pre>
<p>Another option is to use the non-destructive version of a destructive method. That’s what we’ll explore next.</p>
<h4 id="nondestructive-versions-of-reverse-sort-splice-es2023"><a class="heading-id-link" href="#nondestructive-versions-of-reverse-sort-splice-es2023">34.11.2 Non-destructive versions of <code>.reverse()</code>, <code>.sort()</code>, <code>.splice()</code><span> <sup>ES2023</sup></span></a></h4>
<p><span id="index-entry-destructive-operation"/>
<span id="index-entry-non-destructive-operation"/></p>
<p>These are the non-destructive versions of the destructive Array methods <code>.reverse()</code>, <code>.sort()</code> and <code>.splice()</code>:</p>
<ul>
  <li>
    <code>.toReversed(): Array</code>
  </li>
  <li>
    <code>.toSorted(compareFn): Array</code>
  </li>
  <li>
    <code>.toSpliced(start, deleteCount, ...items): Array</code>
  </li>
</ul>
<p>We have used <code>.reverse()</code> in the previous subsection. Its non-destructive version is used like this:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> original = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
<span class="hljs-keyword">const</span> reversed = original.<span class="hljs-title function_">toReversed</span>();
<code/>
assert.<span class="hljs-title function_">deepEqual</span>(reversed, [<span class="hljs-string">'c'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>]);
<span class="hljs-comment">// The original is unchanged</span>
assert.<span class="hljs-title function_">deepEqual</span>(original, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]);
</pre>
<h3 id="adding-and-removing-elements-at-either-end-of-an-array"><a class="heading-id-link" href="#adding-and-removing-elements-at-either-end-of-an-array">34.12 Adding and removing elements at either end of an Array</a></h3>
<h4 id="array-push-pop-shift-unshift"><a class="heading-id-link" href="#array-push-pop-shift-unshift">34.12.1 Destructively adding and removing elements at either end of an Array</a></h4>
<p>JavaScript’s <code>Array</code> is quite flexible and more like a combination of array, stack, and queue. Let’s explore ways of destructively adding and removing Array elements.</p>
<p><code>.push()</code> adds elements at the end of an Array:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];
arr1.<span class="hljs-title function_">push</span>(<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>); <span class="hljs-comment">// append single elements</span>
assert.<span class="hljs-title function_">deepEqual</span>(arr1, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>]);
<code/>
<span class="hljs-keyword">const</span> arr2 = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];
arr2.<span class="hljs-title function_">push</span>(...[<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>]); <span class="hljs-comment">// (A) append Array</span>
assert.<span class="hljs-title function_">deepEqual</span>(arr2, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>]);
</pre>
<p><a href="ch_callables.html#spread-arguments">Spread arguments (<code>...</code>)</a> are a feature of function calls. In line A, we used it to push an Array.</p>
<p><code>.pop()</code> is the inverse of <code>.push()</code> and removes elements at the end of an Array:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr2 = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
assert.<span class="hljs-title function_">equal</span>(arr2.<span class="hljs-title function_">pop</span>(), <span class="hljs-string">'c'</span>);
assert.<span class="hljs-title function_">deepEqual</span>(arr2, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]);
</pre>
<p><code>.shift()</code> removes elements at the beginning of an Array:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
assert.<span class="hljs-title function_">equal</span>(arr1.<span class="hljs-title function_">shift</span>(), <span class="hljs-string">'a'</span>);
assert.<span class="hljs-title function_">deepEqual</span>(arr1, [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]);
</pre>
<p><code>.unshift()</code> is the inverse of <code>.shift()</code> and adds element at the beginning of an Array:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];
arr1.<span class="hljs-title function_">unshift</span>(<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>); <span class="hljs-comment">// prepend single elements</span>
assert.<span class="hljs-title function_">deepEqual</span>(arr1, [<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]);
<code/>
<span class="hljs-keyword">const</span> arr2 = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];
arr2.<span class="hljs-title function_">unshift</span>(...[<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>]); <span class="hljs-comment">// prepend Array</span>
assert.<span class="hljs-title function_">deepEqual</span>(arr2, [<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]);
</pre>
<div class="boxout">
  <p><img src="../Images/8440b17bb8219cda9f9405ac83c36db0.png" class="boxout-icon" height="24" alt="Icon “tip”" data-original-src="https://exploringjs.com/js/book/icon/tip.svg"/> <strong>Tip: remembering the functionality of <code>push</code>, <code>pop</code>, <code>shift</code> and <code>unshift</code></strong></p>
  <div class="boxout-vspace"/>
  <p>My recommendation is to focus on remembering the following two methods:</p>
  <ul>
    <li>
      <code>.push()</code> is the most frequently used of the four methods. One common use case is to assemble an output Array: We first push the element at index 0; then the element at index 1; etc.
    </li>
    <li>
      <code>.shift()</code> can be used to consume the elements of an Array: The first time we shift, we get the element at index 0; then the element at index 1; etc.
    </li>
  </ul>
  <p>The remaining two methods, <code>pop</code> and <code>unshift</code>, are inverses of these two methods.</p>
</div>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Implementing a queue via an Array</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/arrays/queue_via_array_test.mjs</code></p>
</div>
<h4 id="nondestructively-prepending-and-appending-elements"><a class="heading-id-link" href="#nondestructively-prepending-and-appending-elements">34.12.2 Non-destructively prepending and appending elements</a></h4>
<p><a href="#spreading-into-array-literals">Spread elements (<code>...</code>)</a> are a feature of Array literals. In this section, we’ll use it to non-destructively prepend and append elements to Arrays.</p>
<p>Non-destructive prepending:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];
assert.<span class="hljs-title function_">deepEqual</span>(
  [<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, ...arr1], <span class="hljs-comment">// prepend single elements</span>
  [<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]);
assert.<span class="hljs-title function_">deepEqual</span>(arr1, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]); <span class="hljs-comment">// unchanged!</span>
<code/>
<span class="hljs-keyword">const</span> arr2 = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];
assert.<span class="hljs-title function_">deepEqual</span>(
  [...[<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>], ...arr2], <span class="hljs-comment">// prepend Array</span>
  [<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]);
assert.<span class="hljs-title function_">deepEqual</span>(arr2, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]); <span class="hljs-comment">// unchanged!</span>
</pre>
<p>Non-destructive appending:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];
assert.<span class="hljs-title function_">deepEqual</span>(
  [...arr1, <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>], <span class="hljs-comment">// append single elements</span>
  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>]);
assert.<span class="hljs-title function_">deepEqual</span>(arr1, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]); <span class="hljs-comment">// unchanged!</span>
<code/>
<span class="hljs-keyword">const</span> arr2 = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];
assert.<span class="hljs-title function_">deepEqual</span>(
  [...arr2, ...[<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>]], <span class="hljs-comment">// append Array</span>
  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>]);
assert.<span class="hljs-title function_">deepEqual</span>(arr2, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]); <span class="hljs-comment">// unchanged!</span>
</pre>
<h3 id="array-element-callbacks"><a class="heading-id-link" href="#array-element-callbacks">34.13 Array methods that accept element callbacks</a></h3>
<p>The following Array methods accept callbacks to which they feed Array elements:</p>
<ul>
  <li>
    Finding:
    <ul>
      <li>
        <code>.find</code>
      </li>
      <li>
        <code>.findLast</code>
      </li>
      <li>
        <code>.findIndex</code>
      </li>
      <li>
        <code>.findLastIndex</code>
      </li>
    </ul>
  </li>
  <li>
    Transforming:
    <ul>
      <li>
        <code>.map</code>
      </li>
      <li>
        <code>.flatMap</code>
      </li>
      <li>
        <code>.filter</code>
      </li>
    </ul>
  </li>
  <li>
    Computing summaries of Arrays:
    <ul>
      <li>
        <code>.every</code>
      </li>
      <li>
        <code>.some</code>
      </li>
      <li>
        <code>.reduce</code>
      </li>
      <li>
        <code>.reduceRight</code>
      </li>
    </ul>
  </li>
  <li>
    Looping over Arrays:
    <ul>
      <li>
        <code>.forEach</code>
      </li>
    </ul>
  </li>
</ul>
<p>Element callbacks have type signatures that look as follows:</p>
<pre class="language-ts">
<span class="hljs-attr">callback</span>: <span class="hljs-function">(<span class="hljs-params">value: T, index: <span class="hljs-built_in">number</span>, array: <span class="hljs-built_in">Array</span>&lt;T&gt;</span>) =&gt;</span> <span class="hljs-built_in">boolean</span>
</pre>
<p>That is, the callback gets three parameters (it is free to ignore any of them):</p>
<ul>
  <li>
    <code>value</code> is the most important one. This parameter holds the Array element that is currently being processed.
  </li>
  <li>
    <code>index</code> can additionally tell the callback what the index of the element is.
  </li>
  <li>
    <code>array</code> points to the current Array (the receiver of the method call). Some algorithms need to refer to the whole Array – e.g., to search elsewhere additional data. This parameter lets us write reusable callbacks for such algorithms.
  </li>
</ul>
<p>What the callback is expected to return depends on the method it is passed to. Possibilities include:</p>
<ul>
  <li>
    <p><code>.map()</code> fills its result with the values returned by its callback:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + x)</span>
[ 'aa', 'bb', 'cc' ]
</pre>
  </li>
  <li>
    <p><code>.find()</code> returns the first Array element for which its callback returns <code>true</code>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'bb'</span>, <span class="hljs-string">'ccc'</span>].<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> str.<span class="hljs-property">length</span> &gt;= <span class="hljs-number">2</span>)</span>
'bb'
</pre>
  </li>
</ul>
<h3 id="transforming-with-element-callbacks-map-filter-flatmap"><a class="heading-id-link" href="#transforming-with-element-callbacks-map-filter-flatmap">34.14 Transforming with element callbacks: <code>.map()</code>, <code>.filter()</code>, <code>.flatMap()</code></a></h3>
<p>In this section, we explore methods that accept <a href="#array-element-callbacks">element callbacks</a> which tell them how to transform an input Array into an output Array.</p>
<h4 id="map-each-output-element-is-derived-from-its-input-element"><a class="heading-id-link" href="#map-each-output-element-is-derived-from-its-input-element">34.14.1 <code>.map()</code>: Each output element is derived from its input element</a></h4>
<p>Each element of the output Array is the result of applying the callback to the corresponding input element:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">3</span>)</span>
[ 3, 6, 9 ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'how'</span>, <span class="hljs-string">'are'</span>, <span class="hljs-string">'you'</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> str.<span class="hljs-title function_">toUpperCase</span>())</span>
[ 'HOW', 'ARE', 'YOU' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">_x, index</span>) =&gt;</span> index)</span>
[ 0, 1, 2 ]
</pre>
<p><code>.map()</code> can be implemented as follows:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">map</span>(<span class="hljs-params">arr, mapFunc</span>) {
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [i, x] <span class="hljs-keyword">of</span> arr.<span class="hljs-title function_">entries</span>()) {
    result.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">mapFunc</span>(x, i, arr));
  }
  <span class="hljs-keyword">return</span> result;
}
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Numbering lines via <code>.map()</code></strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/arrays/number_lines_test.mjs</code></p>
</div>
<h4 id="filter-only-keep-some-of-the-elements"><a class="heading-id-link" href="#filter-only-keep-some-of-the-elements">34.14.2 <code>.filter()</code>: Only keep some of the elements</a></h4>
<p>The Array method <code>.filter()</code> returns an Array collecting all elements for which the callback returns a truthy value.</p>
<p>For example:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, -<span class="hljs-number">7</span>, <span class="hljs-number">6</span>].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt;= <span class="hljs-number">0</span>)</span>
[ 2, 5, 6 ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>].<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">_x,i</span>) =&gt;</span> (i%<span class="hljs-number">2</span>)===<span class="hljs-number">0</span>)</span>
[ 'a', 'c' ]
</pre>
<p><code>.filter()</code> can be implemented as follows:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">filter</span>(<span class="hljs-params">arr, filterFunc</span>) {
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [i, x] <span class="hljs-keyword">of</span> arr.<span class="hljs-title function_">entries</span>()) {
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">filterFunc</span>(x, i, arr)) {
      result.<span class="hljs-title function_">push</span>(x);
    }
  }
  <span class="hljs-keyword">return</span> result;
}
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Removing empty lines via <code>.filter()</code></strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/arrays/remove_empty_lines_filter_test.mjs</code></p>
</div>
<h4 id="Array.prototype.flatMap"><a class="heading-id-link" href="#Array.prototype.flatMap">34.14.3 <code>.flatMap()</code>: Each input element produces zero or more output elements<span> <sup>ES2019</sup></span></a></h4>
<p>The type signature of <code>Array&lt;T&gt;.prototype.flatMap()</code> is:</p>
<pre class="language-ts">
.<span class="hljs-property">flatMap</span>&lt;U&gt;(
  <span class="hljs-attr">callback</span>: <span class="hljs-function">(<span class="hljs-params">value: T, index: <span class="hljs-built_in">number</span>, array: <span class="hljs-built_in">Array</span>&lt;T&gt;</span>) =&gt;</span> U|<span class="hljs-title class_">Array</span>&lt;U&gt;,
  thisValue?: <span class="hljs-built_in">any</span>
): <span class="hljs-title class_">Array</span>&lt;U&gt;
</pre>
<p>Both <code>.map()</code> and <code>.flatMap()</code> take a function <code>callback</code> as a parameter that controls how an input Array is translated to an output Array:</p>
<ul>
  <li>
    With <code>.map()</code>, each input Array element is translated to exactly one output element. That is, <code>callback</code> returns a single value.
  </li>
  <li>
    With <code>.flatMap()</code>, each input Array element is translated to zero or more output elements. That is, <code>callback</code> returns an Array of values (it can also return non-Array values, but that is rare).
  </li>
</ul>
<p>This is <code>.flatMap()</code> in action:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> [x,x])</span>
[ 'a', 'a', 'b', 'b', 'c', 'c' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> [x])</span>
[ 'a', 'b', 'c' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> [])</span>
[]
</pre>
<p>We’ll consider use cases next, before exploring how this method could be implemented.</p>
<h5 id="use-case-filtering-and-mapping-at-the-same-time"><a class="heading-id-link" href="#use-case-filtering-and-mapping-at-the-same-time">34.14.3.1 Use case: filtering and mapping at the same time</a></h5>
<p>The result of the Array method <code>.map()</code> always has the same length as the Array it is invoked on. That is, its callback can’t skip Array elements it isn’t interested in. The ability of <code>.flatMap()</code> to do so is useful in the next example.</p>
<p>Let’s say, we got the following result from <a href="ch_promises.html#Promise.allSettled"><code>Promise.allSettled()</code></a>:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> result = [
  { <span class="hljs-attr">status</span>: <span class="hljs-string">'fulfilled'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'sunshine.jpg'</span> },
  { <span class="hljs-attr">status</span>: <span class="hljs-string">'rejected'</span>, <span class="hljs-attr">reason</span>: <span class="hljs-string">'FILE NOT FOUND'</span> },
  { <span class="hljs-attr">status</span>: <span class="hljs-string">'fulfilled'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'dog.jpg'</span> },
  { <span class="hljs-attr">status</span>: <span class="hljs-string">'rejected'</span>, <span class="hljs-attr">reason</span>: <span class="hljs-string">'NOT AUTHORIZED'</span> },
];
</pre>
<p>We can use <code>.flatMap()</code> to extract just the values or just the errors from <code>results</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> values = result.<span class="hljs-title function_">flatMap</span>(
  <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.<span class="hljs-property">status</span> === <span class="hljs-string">'fulfilled'</span> ? [r.<span class="hljs-property">value</span>] : []
);
assert.<span class="hljs-title function_">deepEqual</span>(
  values, [<span class="hljs-string">'sunshine.jpg'</span>, <span class="hljs-string">'dog.jpg'</span>]
);
  
<span class="hljs-keyword">const</span> reasons = result.<span class="hljs-title function_">flatMap</span>(
  <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.<span class="hljs-property">status</span> === <span class="hljs-string">'rejected'</span> ? [r.<span class="hljs-property">reason</span>] : []
);
assert.<span class="hljs-title function_">deepEqual</span>(
  reasons, [<span class="hljs-string">'FILE NOT FOUND'</span>, <span class="hljs-string">'NOT AUTHORIZED'</span>]
);
</pre>
<h5 id="use-case-mapping-single-input-values-to-multiple-output-values"><a class="heading-id-link" href="#use-case-mapping-single-input-values-to-multiple-output-values">34.14.3.2 Use case: mapping single input values to multiple output values</a></h5>
<p>The Array method <code>.map()</code> maps each input Array element to one output element. But what if we want to map it to multiple output elements?</p>
<p>That becomes necessary in the following example:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">stringsToCodePoints</span>([<span class="hljs-string">'many'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'moon'</span>])</span>
['m', 'a', 'n', 'y', 'a', 'm', 'o', 'o', 'n']
</pre>
<p>We want to convert an Array of strings to an Array of Unicode characters (code points). The following function achieves that via <code>.flatMap()</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">stringsToCodePoints</span>(<span class="hljs-params">strs</span>) {
  <span class="hljs-keyword">return</span> strs.<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(str));
}
</pre>
<h5 id="a-simple-implementation"><a class="heading-id-link" href="#a-simple-implementation">34.14.3.3 A simple implementation</a></h5>
<p>We can implement <code>.flatMap()</code> as follows. Note: This implementation is simpler than the built-in version, which, for example, performs more checks.</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">flatMap</span>(<span class="hljs-params">arr, mapFunc</span>) {
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [index, elem] <span class="hljs-keyword">of</span> arr.<span class="hljs-title function_">entries</span>()) {
    <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">mapFunc</span>(elem, index, arr);
    <span class="hljs-comment">// We allow mapFunc() to return non-Arrays</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(x)) {
      result.<span class="hljs-title function_">push</span>(...x);
    } <span class="hljs-keyword">else</span> {
      result.<span class="hljs-title function_">push</span>(x);
    }
  }
  <span class="hljs-keyword">return</span> result;
}
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercises: <code>.flatMap()</code></strong></p>
  <div class="boxout-vspace"/>
  <ul>
    <li>
      <code>exercises/arrays/convert_to_numbers_test.mjs</code>
    </li>
    <li>
      <code>exercises/arrays/replace_objects_test.mjs</code>
    </li>
  </ul>
</div>
<h3 id="Array.prototype.reduce"><a class="heading-id-link" href="#Array.prototype.reduce">34.15 <code>.reduce()</code>: computing a summary for an Array</a></h3>
<p>Method <code>.reduce()</code> is a powerful tool for computing a “summary” of an Array <code>arr</code>. A summary can be any kind of value:</p>
<ul>
  <li>
    A number. For example, the sum of all elements of <code>arr</code>.
  </li>
  <li>
    An Array. For example, a copy of <code>arr</code>, where each element is twice the original element.
  </li>
  <li>
    Etc.
  </li>
</ul>
<p><code>reduce</code> is also known as <code>foldl</code> (“fold left”) in functional programming and popular there. One caveat is that it can make code difficult to understand.</p>
<h4 id="an-overview-of-how-reduce-works"><a class="heading-id-link" href="#an-overview-of-how-reduce-works">34.15.1 An overview of how <code>.reduce()</code> works</a></h4>
<p>We’ll start with an overview of how <code>.reduce()</code> works. If you find the overview difficult to understand, you can skip ahead to the example and come back here later.</p>
<p><code>.reduce()</code> has the following type signature (inside an <code>Array&lt;T&gt;</code>):</p>
<pre class="language-ts">
.<span class="hljs-property">reduce</span>&lt;U&gt;(
  <span class="hljs-attr">callback</span>: <span class="hljs-function">(<span class="hljs-params">accumulator: U, elem: T, idx: <span class="hljs-built_in">number</span>, arr: <span class="hljs-built_in">Array</span>&lt;T&gt;</span>) =&gt;</span> U,
  init?: U
): U
</pre>
<p><code>T</code> is the type of the Array elements, <code>U</code> is the type of the summary. The two may or may not be different. <code>accumulator</code> is just another name for “summary”.</p>
<p>To compute the summary of an Array <code>arr</code>, <code>.reduce()</code> feeds all Array elements to its callback one at a time:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> accumulator_0 = <span class="hljs-title function_">callback</span>(init, arr[<span class="hljs-number">0</span>]);
<span class="hljs-keyword">const</span> accumulator_1 = <span class="hljs-title function_">callback</span>(accumulator_0, arr[<span class="hljs-number">1</span>]);
<span class="hljs-keyword">const</span> accumulator_2 = <span class="hljs-title function_">callback</span>(accumulator_1, arr[<span class="hljs-number">2</span>]);
<span class="hljs-comment">// Etc.</span>
</pre>
<ul>
  <li>
    <code>init</code> provides the initial value for <code>accumulator</code>.
  </li>
  <li>
    The accumulator contains the preliminary result of the reduction. When the callback is invoked, it combines the accumulator with the current Array element and returns the result. That result becomes the next accumulator.
  </li>
  <li>
    The result of <code>.reduce()</code> is the final accumulator – the last result of <code>callback</code> after it has visited all elements.
  </li>
</ul>
<p>In other words: <code>callback</code> does most of the work; <code>.reduce()</code> just invokes it in a useful manner.</p>
<p>We could say that the callback folds Array elements into the accumulator. That’s why this operation is called “fold” in functional programming.</p>
<h4 id="example-applying-a-binary-operator-to-a-whole-array" class="unnumbered unlisted"><a class="heading-id-link" href="#example-applying-a-binary-operator-to-a-whole-array">Example: applying a binary operator to a whole Array</a></h4>
<p>Let’s look at an example of <code>.reduce()</code> in action: function <code>addAll()</code> computes the sum of all numbers in an Array <code>arr</code>.</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">addAll</span>(<span class="hljs-params">arr</span>) {
  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-function">(<span class="hljs-params">sum, element</span>) =&gt;</span> sum + element,
    <span class="hljs-number">0</span> <span class="hljs-comment">// `init` value</span>
  );
}
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">addAll</span>([<span class="hljs-number">1</span>,  <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]), <span class="hljs-number">6</span>); <span class="hljs-comment">// (A)</span>
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">addAll</span>([<span class="hljs-number">7</span>, -<span class="hljs-number">4</span>, <span class="hljs-number">2</span>]), <span class="hljs-number">5</span>);
</pre>
<p>In this case, the accumulator holds the sum of all Array elements that <code>callback</code> has already visited.</p>
<p>How was the result <code>6</code> derived from the Array in line A? Via the following invocations of <code>callback</code>:</p>
<pre class="language-txt">
callback(0, 1) --&gt; 1
callback(1, 2) --&gt; 3
callback(3, 3) --&gt; 6
</pre>
<p>Notes:</p>
<ul>
  <li>
    The first parameters are the current accumulators (starting with parameter <code>init</code> of <code>.reduce()</code>).
  </li>
  <li>
    The second parameters are the current Array elements.
  </li>
  <li>
    The results are the next accumulators.
  </li>
  <li>
    The last result of <code>callback</code> is also the result of <code>.reduce()</code>.
  </li>
</ul>
<p>Alternatively, we could have implemented <code>addAll()</code> via a <code>for-of</code> loop:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">addAll</span>(<span class="hljs-params">arr</span>) {
  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> element <span class="hljs-keyword">of</span> arr) {
    sum = sum + element;
  }
  <span class="hljs-keyword">return</span> sum;
}
</pre>
<p>It’s hard to say which of the two implementations is “better”: the one based on <code>.reduce()</code> is a little more concise, while the one based on <code>for-of</code> may be a little easier to understand – especially if someone is not familiar with functional programming.</p>
<h4 id="what-happens-if-we-omit-init"><a class="heading-id-link" href="#what-happens-if-we-omit-init">34.15.2 What happens if we omit <code>init</code>?</a></h4>
<p>If we pass the parameter <code>init</code> to <code>.reduce()</code>, it is the initial value of the accumulator:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, elem</span>) =&gt;</span> acc + elem, <span class="hljs-number">100</span>)</span>
103
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">1</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, elem</span>) =&gt;</span> acc + elem, <span class="hljs-number">100</span>)</span>
101
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, elem</span>) =&gt;</span> acc + elem, <span class="hljs-number">100</span>)</span>
100
</pre>
<p>If the Array is empty, the result of <code>.reduce()</code> is <code>init</code>.</p>
<p>If we omit <code>init</code> then <code>.reduce()</code> initializes the accumulator with the first Array element:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, elem</span>) =&gt;</span> acc + elem)</span>
3
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">1</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, elem</span>) =&gt;</span> acc + elem)</span>
1
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, elem</span>) =&gt;</span> acc + elem)</span>
TypeError: Reduce of empty array with no initial value
</pre>
<p>If the Array only has one element, the result of <code>.reduce()</code> is that element. If the Array is empty, <code>.reduce()</code> doesn’t have a value to return and throws an exception.</p>
<p>The following interaction demonstrates the initial value of the <code>accumulator</code> with and without <code>init</code>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'x'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, elem</span>) =&gt;</span> acc)</span>
'x'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, elem</span>) =&gt;</span> acc, <span class="hljs-string">'x'</span>)</span>
'x'
</pre>
<h4 id="example-finding-indices-via-reduce" class="unnumbered unlisted"><a class="heading-id-link" href="#example-finding-indices-via-reduce">Example: finding indices via <code>.reduce()</code></a></h4>
<p>The following function is an implementation of the Array method <code>.indexOf()</code>. It returns the first index at which the given <code>searchValue</code> appears inside the Array <code>arr</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">NOT_FOUND</span> = -<span class="hljs-number">1</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">indexOf</span>(<span class="hljs-params">arr, searchValue</span>) {
  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-function">(<span class="hljs-params">result, elem, index</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (result !== <span class="hljs-variable constant_">NOT_FOUND</span>) {
        <span class="hljs-comment">// We have already found something: don’t change anything</span>
        <span class="hljs-keyword">return</span> result;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (elem === searchValue) {
        <span class="hljs-keyword">return</span> index;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">NOT_FOUND</span>;
      }
    },
    <span class="hljs-variable constant_">NOT_FOUND</span>);
}
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">indexOf</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>], <span class="hljs-string">'b'</span>), <span class="hljs-number">1</span>);
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">indexOf</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>], <span class="hljs-string">'x'</span>), -<span class="hljs-number">1</span>);
</pre>
<p>One limitation of <code>.reduce()</code> is that we can’t finish early. In a <code>for-of</code> loop, we can immediately return the result once we have found it.</p>
<h4 id="example-doubling-array-elements" class="unnumbered unlisted"><a class="heading-id-link" href="#example-doubling-array-elements">Example: doubling Array elements</a></h4>
<p>Function <code>double(arr)</code> returns a copy of <code>inArr</code> whose elements are all multiplied by 2:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">double</span>(<span class="hljs-params">inArr</span>) {
  <span class="hljs-keyword">return</span> inArr.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-function">(<span class="hljs-params">outArr, element</span>) =&gt;</span> {
      outArr.<span class="hljs-title function_">push</span>(element * <span class="hljs-number">2</span>);
      <span class="hljs-keyword">return</span> outArr;
    },
    []);
}
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title function_">double</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]),
  [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]);
</pre>
<p>We modify the initial value <code>[]</code> by pushing into it. A non-destructive, more functional version of <code>double()</code> looks as follows:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">double</span>(<span class="hljs-params">inArr</span>) {
  <span class="hljs-keyword">return</span> inArr.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-comment">// Don’t change `outArr`, return a fresh Array</span>
    <span class="hljs-function">(<span class="hljs-params">outArr, element</span>) =&gt;</span> [...outArr, element * <span class="hljs-number">2</span>],
    []);
}
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title function_">double</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]),
  [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]);
</pre>
<p>This version is more elegant but also slower and uses more memory.</p>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercises: <code>.reduce()</code></strong></p>
  <div class="boxout-vspace"/>
  <ul>
    <li>
      <code>map()</code> via <code>.reduce()</code>: <code>exercises/arrays/map_via_reduce_test.mjs</code>
    </li>
    <li>
      <code>filter()</code> via <code>.reduce()</code>: <code>exercises/arrays/filter_via_reduce_test.mjs</code>
    </li>
    <li>
      <code>countMatches()</code> via <code>.reduce()</code>: <code>exercises/arrays/count_matches_via_reduce_test.mjs</code>
    </li>
  </ul>
</div>
<h4 id="Array.prototype.reduceRight"><a class="heading-id-link" href="#Array.prototype.reduceRight">34.15.3 <code>.reduceRight()</code>: the end-to-start version of <code>.reduce()</code></a></h4>
<p><code>.reduce()</code> visits elements from start to end:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, x</span>) =&gt;</span> acc + x)</span>
'abc'
</pre>
<p><code>.reduceRight()</code> has the same functionality but visits elements from end to start:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">reduceRight</span>(<span class="hljs-function">(<span class="hljs-params">acc, x</span>) =&gt;</span> acc + x)</span>
'cba'
</pre>
<h3 id="Array.prototype.sort"><a class="heading-id-link" href="#Array.prototype.sort">34.16 <code>.sort()</code>: sorting Arrays</a></h3>
<p><code>.sort()</code> has the following type definition:</p>
<pre class="language-ts">
<span class="hljs-title function_">sort</span>(compareFunc?: <span class="hljs-function">(<span class="hljs-params">a: T, b: T</span>) =&gt;</span> <span class="hljs-built_in">number</span>): <span class="hljs-variable language_">this</span>
</pre>
<p>By default, <code>.sort()</code> sorts string representations of the elements. These representations are compared via <code>&lt;</code>. This operator compares code unit values (char codes) <em>lexicographically</em> (the first characters are most significant).</p>
<p><code>.sort()</code> sorts <em>in place</em>; it changes and returns its receiver:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'b'</span>];</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">arr.<span class="hljs-title function_">sort</span>() === arr</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">arr</span>
[ 'a', 'b', 'c' ]
</pre>
<div class="boxout">
  <p><img src="../Images/38ba63de820aae6f94a019538ae0f222.png" class="boxout-icon" height="24" alt="Icon “details”" data-original-src="https://exploringjs.com/js/book/icon/details.svg"/> <strong><code>.sort()</code> is stable</strong></p>
  <div class="boxout-vspace"/>
  <p>Since ECMAScript 2019, sorting is guaranteed to be <em>stable</em>: If elements are considered equal by sorting, then sorting does not change the order of those elements (relative to each other).</p>
</div>
<h4 id="customizing-array-sorting"><a class="heading-id-link" href="#customizing-array-sorting">34.16.1 Customizing the sort order</a></h4>
<p>We can customize the sort order via the parameter <code>compareFunc</code>, which must return a number that is:</p>
<ul>
  <li>
    negative if <code>a</code> is less than <code>b</code>
  </li>
  <li>
    zero if <code>a</code> is equal to <code>b</code>
  </li>
  <li>
    positive if <code>a</code> is greater than <code>b</code>
  </li>
</ul>
<p>We’ll see an example of a compare function in the next subsection.</p>
<div class="boxout">
  <p><img src="../Images/8440b17bb8219cda9f9405ac83c36db0.png" class="boxout-icon" height="24" alt="Icon “tip”" data-original-src="https://exploringjs.com/js/book/icon/tip.svg"/> <strong>Tip for remembering these rules</strong></p>
  <div class="boxout-vspace"/>
  <p>A negative number is <em>less than</em> zero (etc.).</p>
</div>
<h4 id="sorting-arrays-with-numbers"><a class="heading-id-link" href="#sorting-arrays-with-numbers">34.16.2 Sorting numbers</a></h4>
<p>Lexicographical sorting doesn’t work well for numbers:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">200</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>].<span class="hljs-title function_">sort</span>()</span>
[ 10, 200, 3 ]
</pre>
<p>We can fix this by writing a compare function:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">compareNumbers</span>(<span class="hljs-params">a, b</span>) {
  <span class="hljs-keyword">if</span> (a &lt; b) {
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// any negative number will do</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a === b) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// any positive number will do</span>
  }
}
assert.<span class="hljs-title function_">deepEqual</span>(
  [<span class="hljs-number">200</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>].<span class="hljs-title function_">sort</span>(compareNumbers),
  [<span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">200</span>]
);
</pre>
<div class="boxout">
  <p><img src="../Images/3decb3ca67c240d2bb04742c1f28af18.png" class="boxout-icon" height="24" alt="Icon “question”" data-original-src="https://exploringjs.com/js/book/icon/question.svg"/> <strong>Why doesn’t <code>.sort()</code> automatically pick the right sorting approach for numbers?</strong></p>
  <div class="boxout-vspace"/>
  <p>It would have to examine all Array elements and make sure that they are numbers before switching from lexicographical sorting to numeric sorting.</p>
</div>
<h5 id="a-trick-for-sorting-numbers"><a class="heading-id-link" href="#a-trick-for-sorting-numbers">34.16.2.1 A trick for sorting numbers</a></h5>
<p>The following trick uses the fact that (e.g.) the result for “less than” can be any negative number:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">200</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>].<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, z</span>) =&gt;</span> a - z)</span>
[ 3, 10, 200 ]
</pre>
<ul>
  <li>
    This time, we call the parameters <code>a</code> and <code>z</code> because that enables a mnemonic: The callback sorts ascendingly, “from <code>a</code> to <code>z</code>” (<code>a - z</code>).
  </li>
  <li>
    A downside of this trick is that we might get an arithmetic overflow if a large positive and a large negative number are compared.
  </li>
</ul>
<h4 id="sorting-humanlanguage-strings"><a class="heading-id-link" href="#sorting-humanlanguage-strings">34.16.3 Sorting human-language strings</a></h4>
<p>When sorting human-language strings, we need to be aware that they are compared according to their code unit values (char codes):</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'pie'</span>, <span class="hljs-string">'cookie'</span>, <span class="hljs-string">'éclair'</span>, <span class="hljs-string">'Pie'</span>, <span class="hljs-string">'Cookie'</span>, <span class="hljs-string">'Éclair'</span>].<span class="hljs-title function_">sort</span>()</span>
[ 'Cookie', 'Pie', 'cookie', 'pie', 'Éclair', 'éclair' ]
</pre>
<p>All unaccented uppercase letters come before all unaccented lowercase letters, which come before all accented letters. We can use <code>Intl</code>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl">the JavaScript internationalization API</a> if we want proper sorting for human languages:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'pie'</span>, <span class="hljs-string">'cookie'</span>, <span class="hljs-string">'éclair'</span>, <span class="hljs-string">'Pie'</span>, <span class="hljs-string">'Cookie'</span>, <span class="hljs-string">'Éclair'</span>];
assert.<span class="hljs-title function_">deepEqual</span>(
  arr.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Intl</span>.<span class="hljs-title class_">Collator</span>(<span class="hljs-string">'en'</span>).<span class="hljs-property">compare</span>),
  [<span class="hljs-string">'cookie'</span>, <span class="hljs-string">'Cookie'</span>, <span class="hljs-string">'éclair'</span>, <span class="hljs-string">'Éclair'</span>, <span class="hljs-string">'pie'</span>, <span class="hljs-string">'Pie'</span>]
);
</pre>
<h4 id="sorting-objects"><a class="heading-id-link" href="#sorting-objects">34.16.4 Sorting objects</a></h4>
<p>We also need to use a compare function if we want to sort objects. As an example, the following code shows how to sort objects by age.</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [ {<span class="hljs-attr">age</span>: <span class="hljs-number">200</span>}, {<span class="hljs-attr">age</span>: <span class="hljs-number">3</span>}, {<span class="hljs-attr">age</span>: <span class="hljs-number">10</span>} ];
assert.<span class="hljs-title function_">deepEqual</span>(
  arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">obj1, obj2</span>) =&gt;</span> obj1.<span class="hljs-property">age</span> - obj2.<span class="hljs-property">age</span>),
  [{ <span class="hljs-attr">age</span>: <span class="hljs-number">3</span> }, { <span class="hljs-attr">age</span>: <span class="hljs-number">10</span> }, { <span class="hljs-attr">age</span>: <span class="hljs-number">200</span> }]
);
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Sorting objects by name</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/arrays/sort_objects_test.mjs</code></p>
</div>
<h3 id="grouping-array-elements"><a class="heading-id-link" href="#grouping-array-elements">34.17 Grouping Array elements</a></h3>
<p>Grouping via <code>Object.groupBy()</code> and <code>Map.groupBy()</code> works for any iterable object and therefore for Arrays:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">groupBy</span>(
    [<span class="hljs-number">0</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>],
    <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sign</span>(x)
  ),
  {
    <span class="hljs-string">'0'</span>: [<span class="hljs-number">0</span>],
    <span class="hljs-string">'-1'</span>: [-<span class="hljs-number">5</span>,-<span class="hljs-number">4</span>],
    <span class="hljs-string">'1'</span>: [<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>],
    <span class="hljs-attr">__proto__</span>: <span class="hljs-literal">null</span>,
  }
);
</pre>
<p>More information: <a href="ch_sync-iteration.html#grouping-sync-iterables">“Grouping iterables<span> <sup>ES2024</sup></span>” (§32.8)</a></p>
<h3 id="quickref-Array"><a class="heading-id-link" href="#quickref-Array">34.18 Quick reference: <code>Array</code></a></h3>
<p>Legend:</p>
<ul>
  <li>
    <code>R</code>: method does not change the Array (non-destructive).
  </li>
  <li>
    <code>W</code>: method changes the Array (destructive).
  </li>
</ul>
<p><span id="negative-array-indices"><strong>Negative indices:</strong></span> If a method supports negative indices that means that such indices are added to <code>.length</code> before they are used: <code>-1</code> becomes <code>this.length-1</code>, etc. In other words: <code>-1</code> refers to the last element, <code>-2</code> to the second-last element, etc. <code>.at()</code> is one method that supports negative indices:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
assert.<span class="hljs-title function_">equal</span>(
  arr.<span class="hljs-title function_">at</span>(-<span class="hljs-number">1</span>), <span class="hljs-string">'c'</span>
);
</pre>
<h4 id="new-array"><a class="heading-id-link" href="#new-array">34.18.1 <code>new Array()</code></a></h4>
<ul>
  <li>
    <p><code id="qref-new-Array">new Array(len = 0)</code> <span class="ibox ibox-small" size="small">ES1</span></p>
    <p>Creates an Array of length <code>len</code> that only contains holes:</p>
<pre class="language-js">
<span class="hljs-comment">// Trailing commas are always ignored.</span>
<span class="hljs-comment">// Therefore: number of commas = number of holes</span>
assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>), [,,,]);
</pre>
  </li>
</ul>
<h4 id="array"><a class="heading-id-link" href="#array">34.18.2 <code>Array.*</code></a></h4>
<ul>
  <li>
    <p><code id="qref-Array.from">Array.from(iterableOrArrayLike, mapFunc?)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
<pre class="language-ts">
<span class="hljs-title class_">Array</span>.<span class="hljs-property">from</span>&lt;T&gt;(
  <span class="hljs-attr">iterableOrArrayLike</span>: <span class="hljs-title class_">Iterable</span>&lt;T&gt; | <span class="hljs-title class_">ArrayLike</span>&lt;T&gt;
): <span class="hljs-title class_">Array</span>&lt;T&gt;
<span class="hljs-title class_">Array</span>.<span class="hljs-property">from</span>&lt;T, U&gt;(
  <span class="hljs-attr">iterableOrArrayLike</span>: <span class="hljs-title class_">Iterable</span>&lt;T&gt; | <span class="hljs-title class_">ArrayLike</span>&lt;T&gt;,
  <span class="hljs-attr">mapFunc</span>: <span class="hljs-function">(<span class="hljs-params">v: T, k: <span class="hljs-built_in">number</span></span>) =&gt;</span> U, thisArg?: <span class="hljs-built_in">any</span>
): <span class="hljs-title class_">Array</span>&lt;U&gt;
</pre>
    <ul>
      <li>
        Converts an iterable or <a href="#array-like-objects">an Array-like object</a> to an Array.
      </li>
      <li>
        Optionally, the input values can be translated via <code>mapFunc</code> before they are added to the output Array.
      </li>
    </ul>
    <p>Examples:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>])) <span class="hljs-comment">// iterable</span></span>
[ 'a', 'b' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({<span class="hljs-attr">length</span>: <span class="hljs-number">2</span>, <span class="hljs-number">0</span>:<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>:<span class="hljs-string">'b'</span>}) <span class="hljs-comment">// Array-like object</span></span>
[ 'a', 'b' ]
</pre>
  </li>
  <li>
    <p><code id="qref-Array.of">Array.of(...items)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
<pre class="language-ts">
<span class="hljs-title class_">Array</span>.<span class="hljs-property">of</span>&lt;T&gt;(
  ...<span class="hljs-attr">items</span>: <span class="hljs-title class_">Array</span>&lt;T&gt;
): <span class="hljs-title class_">Array</span>&lt;T&gt;
</pre>
    <p>This static method is mainly useful for subclasses of <code>Array</code>, where it serves as a custom Array literal:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> {}
<code/>
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title class_">MyArray</span>.<span class="hljs-title function_">of</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>) <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyArray</span>, <span class="hljs-literal">true</span>
);
</pre>
  </li>
</ul>
<h4 id="arrayprototype-getting-setting-and-visiting-single-elements"><a class="heading-id-link" href="#arrayprototype-getting-setting-and-visiting-single-elements">34.18.3 <code>Array.prototype.*</code>: getting, setting and visiting single elements</a></h4>
<ul>
  <li>
    <p><code id="qref-Array.prototype.at">Array.prototype.at(index)</code><br/><span class="ibox ibox-small" size="small">ES2022 | Non-mutating</span></p>
    <ul>
      <li>
        Returns the Array element at <code>index</code>. If there is no such element, it returns <code>undefined</code>.
      </li>
    </ul>
    <p>This method is mostly equivalent to getting elements via square brackets:</p>
<pre class="language-js">
arr[index] === arr.<span class="hljs-title function_">at</span>(index)
</pre>
    <p>One reason for using <code>.at()</code> is that it supports <a href="#negative-array-indices">negative indices</a>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">at</span>(<span class="hljs-number">0</span>)</span>
'a'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">at</span>(-<span class="hljs-number">1</span>)</span>
'c'
</pre>
  </li>
  <li>
    <p><code id="qref-Array.prototype.with">Array.prototype.with(index, value)</code><br/><span class="ibox ibox-small" size="small">ES2023 | Non-mutating</span></p>
    <ul>
      <li>
        Returns the receiver of the method call, with one different element: At <code>index</code>, there is now <code>value</code>.
      </li>
    </ul>
    <p>This method is the non-destructive version of setting elements via square brackets. It supports negative indices:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">with</span>(<span class="hljs-number">2</span>, <span class="hljs-string">'x'</span>)</span>
[ 'a', 'b', 'x' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">with</span>(-<span class="hljs-number">1</span>, <span class="hljs-string">'x'</span>)</span>
[ 'a', 'b', 'x' ]
</pre>
  </li>
  <li>
    <p><code id="qref-Array.prototype.forEach">Array.prototype.forEach(callback)</code><br/><span class="ibox ibox-small" size="small">ES5 | Non-mutating</span></p>
<pre class="language-ts">
<span class="hljs-title class_">Array</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">forEach</span>(
  <span class="hljs-attr">callback</span>: <span class="hljs-function">(<span class="hljs-params">value: T, index: <span class="hljs-built_in">number</span>, array: <span class="hljs-built_in">Array</span>&lt;T&gt;</span>) =&gt;</span> <span class="hljs-built_in">void</span>,
  thisArg?: <span class="hljs-built_in">any</span>
): <span class="hljs-built_in">void</span>
</pre>
    <p>Calls <code>callback</code> for each element.</p>
<pre class="language-js">
[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>].<span class="hljs-title function_">forEach</span>(
  <span class="hljs-function">(<span class="hljs-params">elem</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(elem)
);
[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>].<span class="hljs-title function_">forEach</span>(
  <span class="hljs-function">(<span class="hljs-params">elem, index</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(elem, index)
);
</pre>
    <p>Output:</p>
<pre>
a
b
a 0
b 1
</pre>
    <p>A <code>for-of</code> loop is usually a better choice: it’s faster, supports <code>break</code> and can iterate over arbitrary iterables.</p>
  </li>
</ul>
<h4 id="arrayprototype-keys-and-values"><a class="heading-id-link" href="#arrayprototype-keys-and-values">34.18.4 <code>Array.prototype.*</code>: keys and values</a></h4>
<ul>
  <li>
    <p><code id="qref-Array.prototype.keys">Array.prototype.keys()</code><br/><span class="ibox ibox-small" size="small">ES6 | Non-mutating</span></p>
    <p>Returns an iterable over the keys of the receiver.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>].<span class="hljs-title function_">keys</span>())</span>
[ 0, 1 ]
</pre>
  </li>
  <li>
    <p><code id="qref-Array.prototype.values">Array.prototype.values()</code><br/><span class="ibox ibox-small" size="small">ES6 | Non-mutating</span></p>
    <p>Returns an iterable over the values of the receiver.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>].<span class="hljs-title function_">values</span>())</span>
[ 'a', 'b' ]
</pre>
  </li>
  <li>
    <p><code id="qref-Array.prototype.entries">Array.prototype.entries()</code><br/><span class="ibox ibox-small" size="small">ES6 | Non-mutating</span></p>
    <p>Returns an iterable over [index, element] pairs.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>].<span class="hljs-title function_">entries</span>())</span>
[ [ 0, 'a' ], [ 1, 'b' ] ]
</pre>
  </li>
</ul>
<h4 id="arrayprototype-destructively-adding-or-removing-elements-at-either-end-of-an-array"><a class="heading-id-link" href="#arrayprototype-destructively-adding-or-removing-elements-at-either-end-of-an-array">34.18.5 <code>Array.prototype.*</code>: destructively adding or removing elements at either end of an Array</a></h4>
<ul>
  <li>
    <p><code id="qref-Array.prototype.pop">Array.prototype.pop()</code><br/><span class="ibox ibox-small" size="small">ES3 | Mutating</span></p>
    <p>Removes and returns the last element of the receiver. That is, it treats the end of the receiver as a stack. The opposite of <code>.push()</code>.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">arr.<span class="hljs-title function_">pop</span>()</span>
'c'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">arr</span>
[ 'a', 'b' ]
</pre>
  </li>
  <li>
    <p><code id="qref-Array.prototype.push">Array.prototype.push(...items)</code><br/><span class="ibox ibox-small" size="small">ES3 | Mutating</span></p>
    <p>Adds zero or more <code>items</code> to the end of the receiver. That is, it treats the end of the receiver as a stack. The return value is the length of the receiver after the change. The opposite of <code>.pop()</code>.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>)</span>
4
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">arr</span>
[ 'a', 'b', 'c', 'd' ]
</pre>
    <p>We can push an Array by spreading (<code>...</code>) it into arguments:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'x'</span>];</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">arr.<span class="hljs-title function_">push</span>(...[<span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span>])</span>
3
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">arr</span>
[ 'x', 'y', 'z' ]  
</pre>
  </li>
  <li>
    <p><code id="qref-Array.prototype.shift">Array.prototype.shift()</code><br/><span class="ibox ibox-small" size="small">ES3 | Mutating</span></p>
    <p>Removes and returns the first element of the receiver. The inverse of <code>.unshift()</code>.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">arr.<span class="hljs-title function_">shift</span>()</span>
'a'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">arr</span>
[ 'b', 'c' ]
</pre>
  </li>
  <li>
    <p><code id="qref-Array.prototype.unshift">Array.prototype.unshift(...items)</code><br/><span class="ibox ibox-small" size="small">ES3 | Mutating</span></p>
    <p>Inserts the <code>items</code> at the beginning of the receiver and returns its length after this modification.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>];</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span>)</span>
4
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">arr</span>
[ 'e', 'f', 'c', 'd' ]
</pre>
    <p>We can push an Array by spreading (<code>...</code>) it into arguments:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'c'</span>];</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">arr.<span class="hljs-title function_">unshift</span>(...[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>])</span>
3
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">arr</span>
[ 'a', 'b', 'c' ]
</pre>
  </li>
</ul>
<h4 id="arrayprototype-combining-extracting-and-changing-sequences-of-elements"><a class="heading-id-link" href="#arrayprototype-combining-extracting-and-changing-sequences-of-elements">34.18.6 <code>Array.prototype.*</code>: combining, extracting and changing sequences of elements</a></h4>
<div class="boxout">
  <p><img src="../Images/8440b17bb8219cda9f9405ac83c36db0.png" class="boxout-icon" height="24" alt="Icon “tip”" data-original-src="https://exploringjs.com/js/book/icon/tip.svg"/> <strong>Tip: telling <code>.slice()</code> and <code>.splice()</code> apart</strong></p>
  <div class="boxout-vspace"/>
  <ul>
    <li>
      <code>.slice()</code> is much more commonly used. The verb “slice” is also much more common than the verb “splice”.
    </li>
    <li>
      Using <code>.splice()</code> is rare: Elements are more commonly (non-destructively) removed via <code>.filter()</code>. “Splice” has one letter more than “slice” and the method also does more.
    </li>
  </ul>
</div>
<ul>
  <li>
    <p><code id="qref-Array.prototype.concat">Array.prototype.concat(...items)</code><br/><span class="ibox ibox-small" size="small">ES3 | Non-mutating</span></p>
    <p>Returns a new Array that is the concatenation of the receiver and all <code>items</code>. Non-Array parameters (such as <code>'b'</code> in the following example) are treated as if they were Arrays with single elements.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>].<span class="hljs-title function_">concat</span>(<span class="hljs-string">'b'</span>, [<span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>])</span>
[ 'a', 'b', 'c', 'd' ]
</pre>
  </li>
  <li>
    <p><code id="qref-Array.prototype.slice">Array.prototype.slice(start?, end?)</code><br/><span class="ibox ibox-small" size="small">ES3 | Non-mutating</span></p>
    <p>Returns a new Array containing the elements of the receiver whose indices are between (including) <code>start</code> and (excluding) <code>end</code>.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)</span>
[ 'b', 'c' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>].<span class="hljs-title function_">slice</span>() <span class="hljs-comment">// shallow copy</span></span>
[ 'a', 'b' ]
</pre>
    <p><code>.slice()</code> supports <a href="#negative-array-indices">negative indices</a>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">slice</span>(-<span class="hljs-number">2</span>)</span>
[ 'b', 'c' ]
</pre>
    <p>It can be used to (shallowly) copy Arrays:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> copy = original.<span class="hljs-title function_">slice</span>();
</pre>
  </li>
  <li>
    <p><code id="qref-Array.prototype.splice">Array.prototype.splice(start?, deleteCount?, ...items)</code><br/><span class="ibox ibox-small" size="small">ES3 | Mutating</span></p>
    <ul>
      <li>
        At index <code>start</code>,
      </li>
      <li>
        removes <code>deleteCount</code> elements (default: all remaining elements) and
      </li>
      <li>
        replaces them with <code>items</code>.
      </li>
      <li>
        It returns the deleted elements.
      </li>
      <li>
        The non-destructive version of this method is <a href="#qref-Array.prototype.toSpliced"><code>.toSpliced()</code></a>.
      </li>
    </ul>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>];</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>)</span>
[ 'b', 'c' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">arr</span>
[ 'a', 'x', 'y', 'd' ]
</pre>
    <p>If <code>deleteCount</code> is missing, <code>.splice()</code> deletes until the end of the Array:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>];</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>)</span>
[ 'c', 'd' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">arr</span>
[ 'a', 'b' ]
</pre>
    <p><code>start</code> can be <a href="#negative-array-indices">negative</a>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">splice</span>(-<span class="hljs-number">2</span>)</span>
[ 'b', 'c' ]
</pre>
  </li>
  <li>
    <p><code id="qref-Array.prototype.toSpliced">Array.prototype.toSpliced(start?, deleteCount?, ...items)</code><br/><span class="ibox ibox-small" size="small">ES2023 | Non-mutating</span></p>
    <ul>
      <li>
        Creates a new Array where, starting at index <code>start</code>, <code>deleteCount</code> elements are replaced with <code>items</code>.
      </li>
      <li>
        If <code>deleteCount</code> is missing, all elements from <code>start</code> until the end are deleted.
      </li>
      <li>
        The destructive version of this method is <a href="#qref-Array.prototype.splice"><code>.splice()</code></a>.
      </li>
    </ul>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>];</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">arr.<span class="hljs-title function_">toSpliced</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>)</span>
[ 'a', 'x', 'y', 'd' ]
</pre>
    <p><code>start</code> can be <a href="#negative-array-indices">negative</a>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">toSpliced</span>(-<span class="hljs-number">2</span>)</span>
[ 'a' ]
</pre>
  </li>
  <li>
    <p><code id="qref-Array.prototype.fill">Array.prototype.fill(start=0, end=this.length)</code><br/><span class="ibox ibox-small" size="small">ES6 | Mutating</span></p>
    <ul>
      <li>
        Returns <code>this</code>.
      </li>
      <li>
        Assigns <code>value</code> to every index between (including) <code>start</code> and (excluding) <code>end</code>.
      </li>
    </ul>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">fill</span>(<span class="hljs-string">'a'</span>)</span>
[ 'a', 'a', 'a' ]
</pre>
    <p>Caveat: Don’t use this method to fill an Array with an object <code>obj</code>; then each element will refer to the same value (sharing it). In this case, it’s better to <a href="#filling-arrays">use <code>Array.from()</code></a>.</p>
  </li>
  <li>
    <p><code id="qref-Array.prototype.copyWithin">Array.prototype.copyWithin(target, start, end=this.length)</code><br/><span class="ibox ibox-small" size="small">ES6 | Mutating</span></p>
    <ul>
      <li>
        Returns <code>this</code>.
      </li>
    </ul>
    <p>Copies the elements whose indices range from (including) <code>start</code> to (excluding) <code>end</code> to indices starting with <code>target</code>. Overlapping is handled correctly.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>].<span class="hljs-title function_">copyWithin</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)</span>
[ 'c', 'd', 'c', 'd' ]
</pre>
    <p><code>start</code> or <code>end</code> can be <a href="#negative-array-indices">negative</a>.</p>
  </li>
</ul>
<h4 id="arrayprototype-searching-for-elements"><a class="heading-id-link" href="#arrayprototype-searching-for-elements">34.18.7 <code>Array.prototype.*</code>: searching for elements</a></h4>
<ul>
  <li>
    <p><code id="qref-Array.prototype.includes">Array.prototype.includes(searchElement, fromIndex)</code><br/><span class="ibox ibox-small" size="small">ES2016 | Non-mutating</span></p>
    <p>Returns <code>true</code> if the receiver has an element whose value is <code>searchElement</code> and <code>false</code>, otherwise. Searching starts at index <code>fromIndex</code>.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">includes</span>(<span class="hljs-number">1</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">includes</span>(<span class="hljs-number">5</span>)</span>
false
</pre>
  </li>
  <li>
    <p><code id="qref-Array.prototype.indexOf">Array.prototype.indexOf(searchElement, fromIndex)</code><br/><span class="ibox ibox-small" size="small">ES5 | Non-mutating</span></p>
    <p>Returns the index of the first element that is strictly equal to <code>searchElement</code>. Returns <code>-1</code> if there is no such element. Starts searching at index <code>fromIndex</code>, visiting higher indices next.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>].<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'a'</span>)</span>
0
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>].<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>)</span>
2
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>].<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'c'</span>)</span>
-1
</pre>
  </li>
  <li>
    <p><code id="qref-Array.prototype.lastIndexOf">Array.prototype.lastIndexOf(searchElement, fromIndex)</code><br/><span class="ibox ibox-small" size="small">ES5 | Non-mutating</span></p>
    <p>Returns the index of the last element that is strictly equal to <code>searchElement</code>. Returns <code>-1</code> if there is no such element. Starts searching at index <code>fromIndex</code>, visiting lower indices next.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>].<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">'a'</span>)</span>
2
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>].<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>)</span>
0
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>].<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">'c'</span>)</span>
-1
</pre>
  </li>
  <li>
    <p><code id="qref-Array.prototype.find">Array.prototype.find(predicate, thisArg?)</code><br/><span class="ibox ibox-small" size="small">ES6 | Non-mutating</span></p>
<pre class="language-ts">
<span class="hljs-title class_">Array</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">find</span>(
  <span class="hljs-attr">predicate</span>: <span class="hljs-function">(<span class="hljs-params">value: T, index: <span class="hljs-built_in">number</span>, obj: <span class="hljs-built_in">Array</span>&lt;T&gt;</span>) =&gt;</span> <span class="hljs-built_in">boolean</span>,
  thisArg?: <span class="hljs-built_in">any</span>
): T | <span class="hljs-literal">undefined</span>
</pre>
    <ul>
      <li>
        Traverses an Array from start to end.
      </li>
      <li>
        Returns the value of the first element for which <code>predicate</code> returns a truthy value.
      </li>
      <li>
        If there is no such element, it returns <code>undefined</code>.
      </li>
    </ul>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">3</span>].<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &lt; <span class="hljs-number">0</span>)</span>
-1
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &lt; <span class="hljs-number">0</span>)</span>
undefined
</pre>
  </li>
  <li>
    <p><code id="qref-Array.prototype.findLast">Array.prototype.findLast(predicate, thisArg?)</code><br/><span class="ibox ibox-small" size="small">ES2023 | Non-mutating</span></p>
<pre class="language-ts">
<span class="hljs-title class_">Array</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">findLast</span>(
  <span class="hljs-attr">predicate</span>: <span class="hljs-function">(<span class="hljs-params">value: T, index: <span class="hljs-built_in">number</span>, obj: <span class="hljs-built_in">Array</span>&lt;T&gt;</span>) =&gt;</span> <span class="hljs-built_in">boolean</span>,
  thisArg?: <span class="hljs-built_in">any</span>
): T | <span class="hljs-literal">undefined</span>
</pre>
    <ul>
      <li>
        Traverses an Array from end to start.
      </li>
      <li>
        Returns the value of the first element for which <code>predicate</code> returns a truthy value.
      </li>
      <li>
        If there is no such element, it returns <code>undefined</code>.
      </li>
    </ul>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">3</span>].<span class="hljs-title function_">findLast</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &lt; <span class="hljs-number">0</span>)</span>
-3
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">findLast</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &lt; <span class="hljs-number">0</span>)</span>
undefined
</pre>
  </li>
  <li>
    <p><code id="qref-Array.prototype.findIndex">Array.prototype.findIndex(predicate, thisArg?)</code><br/><span class="ibox ibox-small" size="small">ES6 | Non-mutating</span></p>
<pre class="language-ts">
<span class="hljs-title class_">Array</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">findIndex</span>(
  <span class="hljs-attr">predicate</span>: <span class="hljs-function">(<span class="hljs-params">value: T, index: <span class="hljs-built_in">number</span>, obj: <span class="hljs-built_in">Array</span>&lt;T&gt;</span>) =&gt;</span> <span class="hljs-built_in">boolean</span>,
  thisArg?: <span class="hljs-built_in">any</span>
): <span class="hljs-built_in">number</span>
</pre>
    <ul>
      <li>
        Traverses an Array from start to end.
      </li>
      <li>
        Returns the index of the first element for which <code>predicate</code> returns a truthy value.
      </li>
      <li>
        If there is no such element, it returns <code>-1</code>.
      </li>
    </ul>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">3</span>].<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &lt; <span class="hljs-number">0</span>)</span>
0
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &lt; <span class="hljs-number">0</span>)</span>
-1
</pre>
  </li>
  <li>
    <p><code id="qref-Array.prototype.findLastIndex">Array.prototype.findLastIndex(predicate, thisArg?)</code><br/><span class="ibox ibox-small" size="small">ES2023 | Non-mutating</span></p>
<pre class="language-ts">
<span class="hljs-title class_">Array</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">findLastIndex</span>(
  <span class="hljs-attr">predicate</span>: <span class="hljs-function">(<span class="hljs-params">value: T, index: <span class="hljs-built_in">number</span>, obj: <span class="hljs-built_in">Array</span>&lt;T&gt;</span>) =&gt;</span> <span class="hljs-built_in">boolean</span>,
  thisArg?: <span class="hljs-built_in">any</span>
): <span class="hljs-built_in">number</span>
</pre>
    <ul>
      <li>
        Traverses an Array from end to start.
      </li>
      <li>
        Returns the index of the first element for which <code>predicate</code> returns a truthy value.
      </li>
      <li>
        If there is no such element, it returns <code>-1</code>.
      </li>
    </ul>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">3</span>].<span class="hljs-title function_">findLastIndex</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &lt; <span class="hljs-number">0</span>)</span>
2
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">findLastIndex</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &lt; <span class="hljs-number">0</span>)</span>
-1
</pre>
  </li>
</ul>
<h4 id="arrayprototype-filtering-and-mapping"><a class="heading-id-link" href="#arrayprototype-filtering-and-mapping">34.18.8 <code>Array.prototype.*</code>: filtering and mapping</a></h4>
<ul>
  <li>
    <p><code id="qref-Array.prototype.filter">Array.prototype.filter(predicate, thisArg?)</code><br/><span class="ibox ibox-small" size="small">ES5 | Non-mutating</span></p>
<pre class="language-ts">
<span class="hljs-title class_">Array</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">filter</span>(
  <span class="hljs-attr">predicate</span>: <span class="hljs-function">(<span class="hljs-params">value: T, index: <span class="hljs-built_in">number</span>, array: <span class="hljs-built_in">Array</span>&lt;T&gt;</span>) =&gt;</span> <span class="hljs-built_in">boolean</span>,
  thisArg?: <span class="hljs-built_in">any</span>
): <span class="hljs-title class_">Array</span>&lt;T&gt;
</pre>
    <p>Returns an Array with only those elements for which <code>predicate</code> returns a truthy value.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">0</span>)</span>
[ 1, 3 ]
</pre>
  </li>
  <li>
    <p><code id="qref-Array.prototype.map">Array.prototype.map(callback, thisArg?)</code><br/><span class="ibox ibox-small" size="small">ES5 | Non-mutating</span></p>
<pre class="language-ts">
<span class="hljs-title class_">Array</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">map</span>&lt;U&gt;(
  <span class="hljs-attr">mapFunc</span>: <span class="hljs-function">(<span class="hljs-params">value: T, index: <span class="hljs-built_in">number</span>, array: <span class="hljs-built_in">Array</span>&lt;T&gt;</span>) =&gt;</span> U,
  thisArg?: <span class="hljs-built_in">any</span>
): <span class="hljs-title class_">Array</span>&lt;U&gt;
</pre>
    <p>Returns a new Array, in which every element is the result of <code>mapFunc</code> being applied to the corresponding element of the receiver.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">2</span>)</span>
[ 2, 4, 6 ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">x, i</span>) =&gt;</span> i)</span>
[ 0, 1, 2 ]
</pre>
  </li>
  <li>
    <p><code id="qref-Array.prototype.flatMap">Array.prototype.flatMap(callback, thisArg?)</code><br/><span class="ibox ibox-small" size="small">ES2019 | Non-mutating</span></p>
<pre class="language-ts">
<span class="hljs-title class_">Array</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">flatMap</span>&lt;U&gt;(
  <span class="hljs-attr">callback</span>: <span class="hljs-function">(<span class="hljs-params">value: T, index: <span class="hljs-built_in">number</span>, array: <span class="hljs-built_in">Array</span>&lt;T&gt;</span>) =&gt;</span> U|<span class="hljs-title class_">Array</span>&lt;U&gt;,
  thisValue?: <span class="hljs-built_in">any</span>
): <span class="hljs-title class_">Array</span>&lt;U&gt;
</pre>
    <p>The result is produced by invoking <code>callback()</code> for each element of the original Array and concatenating the Arrays it returns.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> [x,x])</span>
[ 'a', 'a', 'b', 'b', 'c', 'c' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> [x])</span>
[ 'a', 'b', 'c' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> [])</span>
[]
</pre>
  </li>
  <li>
    <p><code id="qref-Array.prototype.flat">Array.prototype.flat(depth = 1)</code><br/><span class="ibox ibox-small" size="small">ES2019 | Non-mutating</span></p>
    <p>“Flattens” an Array: It descends into the Arrays that are nested inside the input Array and creates a copy where all values it finds at level <code>depth</code> or lower are moved to the top level.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[ <span class="hljs-number">1</span>,<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], [[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]] ].<span class="hljs-title function_">flat</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">// no change</span></span>
[ 1, 2, [3,4], [[5,6]] ]
<code/>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[ <span class="hljs-number">1</span>,<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], [[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]] ].<span class="hljs-title function_">flat</span>(<span class="hljs-number">1</span>)</span>
[1, 2, 3, 4, [5,6]]
<code/>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[ <span class="hljs-number">1</span>,<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], [[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]] ].<span class="hljs-title function_">flat</span>(<span class="hljs-number">2</span>)</span>
[1, 2, 3, 4, 5, 6]
</pre>
  </li>
</ul>
<h4 id="arrayprototype-computing-summaries"><a class="heading-id-link" href="#arrayprototype-computing-summaries">34.18.9 <code>Array.prototype.*</code>: computing summaries</a></h4>
<ul>
  <li>
    <p><code id="qref-Array.prototype.every">Array.prototype.every(predicate, thisArg?)</code><br/><span class="ibox ibox-small" size="small">ES5 | Non-mutating</span></p>
<pre class="language-ts">
<span class="hljs-title class_">Array</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">every</span>(
  <span class="hljs-attr">predicate</span>: <span class="hljs-function">(<span class="hljs-params">value: T, index: <span class="hljs-built_in">number</span>, array: <span class="hljs-built_in">Array</span>&lt;T&gt;</span>) =&gt;</span> <span class="hljs-built_in">boolean</span>,
  thisArg?: <span class="hljs-built_in">any</span>
): <span class="hljs-built_in">boolean</span>
</pre>
    <p>Returns <code>true</code> if <code>predicate</code> returns a truthy value for every element. Otherwise, it returns <code>false</code>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">0</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">0</span>)</span>
false
</pre>
    <ul>
      <li>
        Stops traversing an Array if the predicate returns a falsy value (because then the result is guaranteed to be <code>false</code>).
      </li>
      <li>
        Corresponds to universal quantification (“for all”, ∀) in mathematics.
      </li>
      <li>
        Related method: <a href="#qref-Array.prototype.some"><code>.some()</code></a> (“exists”).
      </li>
    </ul>
  </li>
  <li>
    <p><code id="qref-Array.prototype.some">Array.prototype.some(predicate, thisArg?)</code><br/><span class="ibox ibox-small" size="small">ES5 | Non-mutating</span></p>
<pre class="language-ts">
<span class="hljs-title class_">Array</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">some</span>(
  <span class="hljs-attr">predicate</span>: <span class="hljs-function">(<span class="hljs-params">value: T, index: <span class="hljs-built_in">number</span>, array: <span class="hljs-built_in">Array</span>&lt;T&gt;</span>) =&gt;</span> <span class="hljs-built_in">boolean</span>,
  thisArg?: <span class="hljs-built_in">any</span>
): <span class="hljs-built_in">boolean</span>
</pre>
    <p>Returns <code>true</code> if <code>predicate</code> returns a truthy value for at least one element. Otherwise, it returns <code>false</code>.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &lt; <span class="hljs-number">0</span>)</span>
false
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &lt; <span class="hljs-number">0</span>)</span>
true
</pre>
    <ul>
      <li>
        Stops traversing an Array if the predicate returns a truthy value (because then the result is guaranteed to be <code>true</code>).
      </li>
      <li>
        Corresponds to existential quantification (“exists”, ∃) in mathematics.
      </li>
      <li>
        Related method: <a href="#qref-Array.prototype.every"><code>.every()</code></a> (“for all”).
      </li>
    </ul>
  </li>
  <li>
    <p><code id="qref-Array.prototype.reduce">Array.prototype.reduce(callback, initialValue?)</code><br/><span class="ibox ibox-small" size="small">ES5 | Non-mutating</span></p>
<pre class="language-ts">
<span class="hljs-title class_">Array</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">reduce</span>&lt;U&gt;(
  <span class="hljs-attr">callback</span>: <span class="hljs-function">(<span class="hljs-params">accumulator: U, elem: T, idx: <span class="hljs-built_in">number</span>, arr: <span class="hljs-built_in">Array</span>&lt;T&gt;</span>) =&gt;</span> U,
  initialValue?: U
): U
</pre>
    <p>This method produces a summary of the receiver: it feeds all Array elements to <code>callback</code>, which combines a current summary (in parameter <code>accumulator</code>) with the current Array element and returns the next <code>accumulator</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> accumulator_0 = <span class="hljs-title function_">callback</span>(initialValue, arr[<span class="hljs-number">0</span>]);
<span class="hljs-keyword">const</span> accumulator_1 = <span class="hljs-title function_">callback</span>(accumulator_0, arr[<span class="hljs-number">1</span>]);
<span class="hljs-keyword">const</span> accumulator_2 = <span class="hljs-title function_">callback</span>(accumulator_1, arr[<span class="hljs-number">2</span>]);
<span class="hljs-comment">// Etc.</span>
</pre>
    <p>The result of <code>.reduce()</code> is the last result of <code>callback</code> after it has visited all Array elements.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accu, x</span>) =&gt;</span> accu + x, <span class="hljs-number">0</span>)</span>
6
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accu, x</span>) =&gt;</span> accu + <span class="hljs-title class_">String</span>(x), <span class="hljs-string">''</span>)</span>
'123'
</pre>
    <p>If no <code>initialValue</code> is provided, the Array element at index 0 is used and the element at index 1 is visited first. Therefore, the Array must have at least length 1.</p>
  </li>
  <li>
    <p><code id="qref-Array.prototype.reduceRight">Array.prototype.reduceRight(callback, initialValue?)</code><br/><span class="ibox ibox-small" size="small">ES5 | Non-mutating</span></p>
<pre class="language-ts">
<span class="hljs-title class_">Array</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">reduceRight</span>&lt;U&gt;(
  <span class="hljs-attr">callback</span>: <span class="hljs-function">(<span class="hljs-params">accumulator: U, elem: T, idx: <span class="hljs-built_in">number</span>, arr: <span class="hljs-built_in">Array</span>&lt;T&gt;</span>) =&gt;</span> U,
  initialValue?: U
): U
</pre>
    <p>Works like <code>.reduce()</code>, but visits the Array elements backward, starting with the last element.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">reduceRight</span>(<span class="hljs-function">(<span class="hljs-params">accu, x</span>) =&gt;</span> accu + <span class="hljs-title class_">String</span>(x), <span class="hljs-string">''</span>)</span>
'321'
</pre>
  </li>
</ul>
<h4 id="arrayprototype-converting-to-string"><a class="heading-id-link" href="#arrayprototype-converting-to-string">34.18.10 <code>Array.prototype.*</code>: converting to string</a></h4>
<ul>
  <li>
    <p><code id="qref-Array.prototype.join">Array.prototype.join(separator = ',')</code><br/><span class="ibox ibox-small" size="small">ES1 | Non-mutating</span></p>
    <p>Creates a string by concatenating string representations of all elements, separating them with <code>separator</code>.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">join</span>(<span class="hljs-string">'##'</span>)</span>
'a##b##c'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">join</span>()</span>
'a,b,c'
</pre>
  </li>
  <li>
    <p><code id="qref-Array.prototype.toString">Array.prototype.toString()</code><br/><span class="ibox ibox-small" size="small">ES1 | Non-mutating</span></p>
    <p>Converts all elements to strings via <code>String()</code>, concatenates them while separating them with commas, and returns the result.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">toString</span>()</span>
'1,2,3'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>].<span class="hljs-title function_">toString</span>()</span>
'1,2,3'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[].<span class="hljs-title function_">toString</span>()</span>
''
</pre>
  </li>
  <li>
    <p><code id="qref-Array.prototype.toLocaleString">Array.prototype.toLocaleString()</code><br/><span class="ibox ibox-small" size="small">ES3 | Non-mutating</span></p>
    <p>Works like <a href="#qref-Array.prototype.toString"><code>.toString()</code></a> but converts its elements to strings via <code>.toLocaleString()</code> (not via <code>.toString()</code>) before separating them via commas and concatenating them to a single string – that it returns.</p>
  </li>
</ul>
<h4 id="arrayprototype-sorting-and-reversing"><a class="heading-id-link" href="#arrayprototype-sorting-and-reversing">34.18.11 <code>Array.prototype.*</code>: sorting and reversing</a></h4>
<ul>
  <li>
    <p><code id="qref-Array.prototype.sort">Array.prototype.sort(compareFunc?)</code><br/><span class="ibox ibox-small" size="small">ES1 | Mutating</span></p>
<pre class="language-ts">
<span class="hljs-title class_">Array</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">sort</span>(
  compareFunc?: <span class="hljs-function">(<span class="hljs-params">a: T, b: T</span>) =&gt;</span> <span class="hljs-built_in">number</span>
): <span class="hljs-variable language_">this</span>
</pre>
    <ul>
      <li>
        Sorts the receiver and returns it.
      </li>
      <li>
        The non-destructive version of this method is <a href="#qref-Array.prototype.toSorted"><code>.toSorted()</code></a>.
      </li>
      <li>
        Sorts string representations of the elements lexicographically.
      </li>
    </ul>
    <p>Sorting numbers:</p>
<pre class="language-js">
<span class="hljs-comment">// Default: lexicographical sorting</span>
assert.<span class="hljs-title function_">deepEqual</span>(
  [<span class="hljs-number">200</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>].<span class="hljs-title function_">sort</span>(),
  [<span class="hljs-number">10</span>, <span class="hljs-number">200</span>, <span class="hljs-number">3</span>]
);
<code/>
<span class="hljs-comment">// Ascending numerical sorting (“from a to z”)</span>
assert.<span class="hljs-title function_">deepEqual</span>(
  [<span class="hljs-number">200</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>].<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, z</span>) =&gt;</span> a - z),
  [<span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">200</span>]
);
</pre>
    <p>Sorting strings: By default, strings are sorted by code unit values (char codes), where, e.g., all unaccented uppercase letters come before all unaccented lowercase letters:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'pie'</span>, <span class="hljs-string">'cookie'</span>, <span class="hljs-string">'éclair'</span>, <span class="hljs-string">'Pie'</span>, <span class="hljs-string">'Cookie'</span>, <span class="hljs-string">'Éclair'</span>].<span class="hljs-title function_">sort</span>()</span>
[ 'Cookie', 'Pie', 'cookie', 'pie', 'Éclair', 'éclair' ]
</pre>
    <p>For human languages, we can use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Collator"><code>Intl.Collator</code></a>:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'pie'</span>, <span class="hljs-string">'cookie'</span>, <span class="hljs-string">'éclair'</span>, <span class="hljs-string">'Pie'</span>, <span class="hljs-string">'Cookie'</span>, <span class="hljs-string">'Éclair'</span>];
assert.<span class="hljs-title function_">deepEqual</span>(
  arr.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Intl</span>.<span class="hljs-title class_">Collator</span>(<span class="hljs-string">'en'</span>).<span class="hljs-property">compare</span>),
  [<span class="hljs-string">'cookie'</span>, <span class="hljs-string">'Cookie'</span>, <span class="hljs-string">'éclair'</span>, <span class="hljs-string">'Éclair'</span>, <span class="hljs-string">'pie'</span>, <span class="hljs-string">'Pie'</span>]
);
</pre>
  </li>
  <li>
    <p><code id="qref-Array.prototype.toSorted">Array.prototype.toSorted(compareFunc?)</code><br/><span class="ibox ibox-small" size="small">ES2023 | Non-mutating</span></p>
<pre class="language-ts">
<span class="hljs-title class_">Array</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toSorted</span>.<span class="hljs-title function_">toSorted</span>(
  compareFunc?: <span class="hljs-function">(<span class="hljs-params">a: T, b: T</span>) =&gt;</span> <span class="hljs-built_in">number</span>
): <span class="hljs-title class_">Array</span>&lt;T&gt;
</pre>
    <ul>
      <li>
        Returns a sorted copy of the current Array.
      </li>
      <li>
        The destructive version of this method is <a href="#qref-Array.prototype.sort"><code>.sort()</code></a>.
      </li>
    </ul>
<pre class="language-js">
<span class="hljs-keyword">const</span> original = [<span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span>, <span class="hljs-string">'x'</span>];
<span class="hljs-keyword">const</span> sorted = original.<span class="hljs-title function_">toSorted</span>();
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-comment">// The original is unchanged</span>
  original, [<span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span>, <span class="hljs-string">'x'</span>]
);
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-comment">// The copy is sorted</span>
  sorted, [<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span>]
);
</pre>
    <p>See the description of <a href="#qref-Array.prototype.sort"><code>.sort()</code></a> for more information on how to use this method.</p>
  </li>
  <li>
    <p><code id="qref-Array.prototype.reverse">Array.prototype.reverse()</code><br/><span class="ibox ibox-small" size="small">ES1 | Mutating</span></p>
    <p>Rearranges the elements of the receiver so that they are in reverse order and then returns the receiver.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">arr.<span class="hljs-title function_">reverse</span>()</span>
[ 'c', 'b', 'a' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">arr</span>
[ 'c', 'b', 'a' ]
</pre>
    <p>The non-destructive version of this method is <a href="#qref-Array.prototype.toReversed"><code>.toReversed()</code></a>.</p>
  </li>
  <li>
    <p><code id="qref-Array.prototype.toReversed">Array.prototype.toReversed()</code><br/><span class="ibox ibox-small" size="small">ES2023 | Non-mutating</span></p>
    <ul>
      <li>
        Returns a reversed copy of the current Array.
      </li>
      <li>
        The destructive version of this method is <a href="#qref-Array.prototype.reverse"><code>.reverse()</code></a>.
      </li>
    </ul>
<pre class="language-js">
<span class="hljs-keyword">const</span> original = [<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span>];
<span class="hljs-keyword">const</span> reversed = original.<span class="hljs-title function_">toReversed</span>();
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-comment">// The original is unchanged</span>
  original, [<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span>]
);
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-comment">// The copy is reversed</span>
  reversed, [<span class="hljs-string">'z'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'x'</span>]
);
</pre>
  </li>
</ul>
<h4 id="sources-of-the-quick-reference"><a class="heading-id-link" href="#sources-of-the-quick-reference">34.18.12 Sources of the quick reference</a></h4>
<ul>
  <li>
    <a href="https://tc39.es/ecma262/">ECMAScript language specification</a>
  </li>
  <li>
    <a href="https://github.com/microsoft/TypeScript/tree/main/src/lib/">TypeScript’s built-in typings</a>
  </li>
  <li>
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">MDN web docs for JavaScript</a>
  </li>
</ul>

    
      
</body>
</html>