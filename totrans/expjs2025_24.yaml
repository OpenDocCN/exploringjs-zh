- en: 20 Bigints – arbitrary-precision integers ES2020 (advanced)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_bigints.html](https://exploringjs.com/js/book/ch_bigints.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[20.1 Why bigints?](#why-bigints)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.2 Bigints](#bigints-overview)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.2.1 Going beyond 53 bits for integers](#going-beyond-53-bits-for-integers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.2.2 Example: using bigints](#example-using-bigints)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.3 Bigint literals](#bigint-literals)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.3.1 Underscores (`_`) as separators in bigint literals ^(ES2021)](#numeric-separator-bigint-literals)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.4 Reusing number operators for bigints (overloading)](#reusing-number-operators-for-bigints-overloading)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.4.1 Arithmetic operators](#arithmetic-operators-1)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.4.2 Loose equality (`==`) and inequality (`!=`)](#loose-equality--and-inequality-)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.4.3 Strict equality (`===`) and inequality (`!==`)](#strict-equality--and-inequality-)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.4.4 Ordering operators](#ordering-operators-1)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.4.5 Bitwise operators (advanced)](#bitwise-operators-advanced-1)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.5 The wrapper constructor `BigInt`](#the-wrapper-constructor-bigint)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.5.1 `BigInt` as a constructor and as a function](#bigint-as-a-constructor-and-as-a-function)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.5.2 `BigInt.prototype.*` methods](#bigintprototype-methods)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.5.3 `BigInt.*` methods: casting](#bigint-methods-casting)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.6 Coercing bigints to other primitive types](#coercing-bigints-to-other-primitive-types)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.7 Typed Array and DataView operations for 64-bit values](#typed-array-and-dataview-operations-for-64bit-values)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.8 Bigints and JSON](#bigints-and-json)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.8.1 Stringifying bigints](#stringifying-bigints)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.8.2 Parsing bigints](#parsing-bigints)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.9 FAQ: Bigints](#faq-bigints)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.9.1 How do I decide when to use numbers and when to use bigints?](#how-do-i-decide-when-to-use-numbers-and-when-to-use-bigints)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.9.2 Why not just increase the precision of numbers in the same manner as
    is done for bigints?](#why-not-just-increase-the-precision-of-numbers-in-the-same-manner-as-is-done-for-bigints)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In this chapter, we take a look at *bigints*, JavaScript’s integers whose storage
    space grows and shrinks as needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[20.1 Why bigints?](#why-bigints)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before ECMAScript 2020, JavaScript handled integers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There only was a single type for floating point numbers and integers: 64-bit
    floating point numbers (IEEE 754 double precision).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Under the hood, most JavaScript engines transparently supported integers: If
    a number has no decimal digits and is within a certain range, it can internally
    be stored as a genuine integer. This representation is called *small integer*
    and usually fits into 32 bits. For example, the range of small integers on the
    64-bit version of the V8 engine is from −2^(31) to 2^(31)−1 ([source](https://medium.com/fhinkel/v8-internals-how-small-is-a-small-integer-e0badc18b6da)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript numbers could also represent integers beyond the small integer range,
    as floating point numbers. Here, the safe range is plus/minus 53 bits. For more
    information on this topic, see [“Safe integers” (§18.9.4)](ch_numbers.html#safe-integers).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sometimes, we need more than signed 53 bits – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: X (formerly Twitter) uses 64-bit integers as IDs for posts ([source](https://developer.x.com/en/docs/twitter-ids)).
    In JavaScript, these IDs had to be stored in strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Financial technology uses so-called *big integers* (integers with arbitrary
    precision) to represent amounts of money. Internally, the amounts are multiplied
    so that the decimal numbers disappear. For example, USD amounts are multiplied
    by 100 so that the cents disappear.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[20.2 Bigints](#bigints-overview)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Bigint* is a primitive data type for integers. Bigints don’t have a fixed
    storage size in bits; their sizes adapt to the integers they represent:'
  prefs: []
  type: TYPE_NORMAL
- en: Small integers are represented with fewer bits than large integers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no negative lower limit or positive upper limit for the integers that
    can be represented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A bigint literal is a sequence of one or more digits, suffixed with an `n`
    – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Operators such as `-` and `*` are overloaded and work with bigints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Bigints are primitive values. `typeof` returns a distinct result for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[20.2.1 Going beyond 53 bits for integers](#going-beyond-53-bits-for-integers)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'JavaScript numbers are internally represented as a fraction multiplied by an
    exponent (see [“Background: floating point precision” (§18.8)](ch_numbers.html#floating-point-precision)
    for details). As a consequence, if we go beyond the highest [*safe integer*](ch_numbers.html#safe-integers)
    2^(53)−1, there are still *some* integers that can be represented, but with gaps
    between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Bigints enable us to go beyond 53 bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[20.2.2 Example: using bigints](#example-using-bigints)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is what using bigints looks like (code based on an example in the proposal):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6][PRE7]``js[PRE8][PRE9] > 123n === 123 false > 123n === 123n true  [PRE10]
    > 17n <= 17n true > 3n > -1n true  [PRE11] > 3n > -1 true  [PRE12] > 2**32 - 1
    >> 0 // 0b11111111111111111111111111111111 -1  [PRE13] > 2**31 >> 0 // highest
    bit is 1 -2147483648 > 2**31 - 1 >> 0 // highest bit is 0 2147483647  [PRE14]
    assert.equal(  ~0b10n,  -3n // ···111101 ); assert.equal(  ~-2n, // ···111110  1n
    );  [PRE15] > (0b1010n |  0b0111n).toString(2) ''1111'' > (0b1010n &  0b0111n).toString(2)
    ''10''  `> (0b1010n | -1n).toString(2)` `''-1''` `> (0b1010n & -1n).toString(2)`
    `''1010''`  [PRE16][PRE17] > 2n << 1n 4n > -2n << 1n -4n  `> 2n >> 1n` `1n` `>
    -2n >> 1n` `-1n`  [PRE18][PRE19] > -1n >> 20n -1n  [PRE20] > 2n >>> 1n TypeError:
    BigInts have no unsigned right shift, use >> instead  [PRE21] > BigInt(undefined)
    TypeError: Cannot convert undefined to a BigInt > BigInt(null) TypeError: Cannot
    convert null to a BigInt  [PRE22] > BigInt(''abc'') SyntaxError: Cannot convert
    abc to a BigInt  [PRE23] > BigInt(''123n'') SyntaxError: Cannot convert 123n to
    a BigInt  [PRE24] > BigInt(''123'') 123n > BigInt(''0xFF'') 255n > BigInt(''0b1101'')
    13n > BigInt(''0o777'') 511n  [PRE25] > BigInt(123.45) RangeError: The number
    123.45 cannot be converted to a BigInt because it is not an integer > BigInt(123)
    123n  [PRE26] > BigInt({valueOf() {return 123n}}) 123n  [PRE27] const uint64a
    = BigInt.asUintN(64, 12345n); const uint64b = BigInt.asUintN(64, 67890n); const
    result = BigInt.asUintN(64, uint64a * uint64b);  [PRE28] > JSON.stringify(123n)
    TypeError: Do not know how to serialize a BigInt > JSON.stringify([123n]) TypeError:
    Do not know how to serialize a BigInt  [PRE29] const bigintPrefix = ''[[bigint]]'';  `function
    bigintReplacer(_key, value) {`  `if (typeof value === ''bigint'') {`  `return
    bigintPrefix + value;`  `}`  `return value;` `}`  `` `const data = { value: 9007199254740993n
    };` `assert.equal(`  `JSON.stringify(data, bigintReplacer),`  `''{"value":"[[bigint]]9007199254740993"}''`
    `);` ``  [PRE30]`` [PRE31] function bigintReviver(_key, value) {  if (typeof value
    === ''string'' && value.startsWith(bigintPrefix)) {  return BigInt(value.slice(bigintPrefix.length));  }  return
    value; }  `const str = ''{"value":"[[bigint]]9007199254740993"}'';` `assert.deepEqual(`  `JSON.parse(str,
    bigintReviver),`  `{ value: 9007199254740993n }` `);`  [PRE32]` [PRE33][PRE34][PRE35][PRE36][PRE37]
    [PRE38]'
  prefs: []
  type: TYPE_NORMAL
