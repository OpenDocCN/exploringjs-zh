- en: 20 Bigints – arbitrary-precision integers ES2020 (advanced)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_bigints.html](https://exploringjs.com/js/book/ch_bigints.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[20.1 Why bigints?](#why-bigints)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.2 Bigints](#bigints-overview)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.2.1 Going beyond 53 bits for integers](#going-beyond-53-bits-for-integers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.2.2 Example: using bigints](#example-using-bigints)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.3 Bigint literals](#bigint-literals)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.3.1 Underscores (`_`) as separators in bigint literals ^(ES2021)](#numeric-separator-bigint-literals)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.4 Reusing number operators for bigints (overloading)](#reusing-number-operators-for-bigints-overloading)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.4.1 Arithmetic operators](#arithmetic-operators-1)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.4.2 Loose equality (`==`) and inequality (`!=`)](#loose-equality--and-inequality-)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.4.3 Strict equality (`===`) and inequality (`!==`)](#strict-equality--and-inequality-)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.4.4 Ordering operators](#ordering-operators-1)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.4.5 Bitwise operators (advanced)](#bitwise-operators-advanced-1)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.5 The wrapper constructor `BigInt`](#the-wrapper-constructor-bigint)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.5.1 `BigInt` as a constructor and as a function](#bigint-as-a-constructor-and-as-a-function)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.5.2 `BigInt.prototype.*` methods](#bigintprototype-methods)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.5.3 `BigInt.*` methods: casting](#bigint-methods-casting)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.6 Coercing bigints to other primitive types](#coercing-bigints-to-other-primitive-types)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.7 Typed Array and DataView operations for 64-bit values](#typed-array-and-dataview-operations-for-64bit-values)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.8 Bigints and JSON](#bigints-and-json)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.8.1 Stringifying bigints](#stringifying-bigints)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.8.2 Parsing bigints](#parsing-bigints)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.9 FAQ: Bigints](#faq-bigints)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.9.1 How do I decide when to use numbers and when to use bigints?](#how-do-i-decide-when-to-use-numbers-and-when-to-use-bigints)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20.9.2 Why not just increase the precision of numbers in the same manner as
    is done for bigints?](#why-not-just-increase-the-precision-of-numbers-in-the-same-manner-as-is-done-for-bigints)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In this chapter, we take a look at *bigints*, JavaScript’s integers whose storage
    space grows and shrinks as needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[20.1 Why bigints?](#why-bigints)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before ECMAScript 2020, JavaScript handled integers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There only was a single type for floating point numbers and integers: 64-bit
    floating point numbers (IEEE 754 double precision).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Under the hood, most JavaScript engines transparently supported integers: If
    a number has no decimal digits and is within a certain range, it can internally
    be stored as a genuine integer. This representation is called *small integer*
    and usually fits into 32 bits. For example, the range of small integers on the
    64-bit version of the V8 engine is from −2^(31) to 2^(31)−1 ([source](https://medium.com/fhinkel/v8-internals-how-small-is-a-small-integer-e0badc18b6da)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript numbers could also represent integers beyond the small integer range,
    as floating point numbers. Here, the safe range is plus/minus 53 bits. For more
    information on this topic, see [“Safe integers” (§18.9.4)](ch_numbers.html#safe-integers).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sometimes, we need more than signed 53 bits – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: X (formerly Twitter) uses 64-bit integers as IDs for posts ([source](https://developer.x.com/en/docs/twitter-ids)).
    In JavaScript, these IDs had to be stored in strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Financial technology uses so-called *big integers* (integers with arbitrary
    precision) to represent amounts of money. Internally, the amounts are multiplied
    so that the decimal numbers disappear. For example, USD amounts are multiplied
    by 100 so that the cents disappear.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[20.2 Bigints](#bigints-overview)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Bigint* is a primitive data type for integers. Bigints don’t have a fixed
    storage size in bits; their sizes adapt to the integers they represent:'
  prefs: []
  type: TYPE_NORMAL
- en: Small integers are represented with fewer bits than large integers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no negative lower limit or positive upper limit for the integers that
    can be represented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A bigint literal is a sequence of one or more digits, suffixed with an `n`
    – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Operators such as `-` and `*` are overloaded and work with bigints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Bigints are primitive values. `typeof` returns a distinct result for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[20.2.1 Going beyond 53 bits for integers](#going-beyond-53-bits-for-integers)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'JavaScript numbers are internally represented as a fraction multiplied by an
    exponent (see [“Background: floating point precision” (§18.8)](ch_numbers.html#floating-point-precision)
    for details). As a consequence, if we go beyond the highest [*safe integer*](ch_numbers.html#safe-integers)
    2^(53)−1, there are still *some* integers that can be represented, but with gaps
    between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Bigints enable us to go beyond 53 bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[20.2.2 Example: using bigints](#example-using-bigints)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is what using bigints looks like (code based on an example in the proposal):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[20.3 Bigint literals](#bigint-literals)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like number literals, bigint literals support several bases:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Decimal: `123n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hexadecimal: `0xFFn`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Binary: `0b1101n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Octal: `0o777n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Negative bigints are produced by prefixing the unary minus operator: `-0123n`'
  prefs: []
  type: TYPE_NORMAL
- en: '[20.3.1 Underscores (`_`) as separators in bigint literals ^(ES2021)](#numeric-separator-bigint-literals)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Just like in number literals](ch_numbers.html#numeric-separator-number-literals),
    we can use underscores (`_`) as separators in bigint literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Bigints are often used to represent money in the financial technical sector.
    Separators can help here, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As with number literals, two restrictions apply:'
  prefs: []
  type: TYPE_NORMAL
- en: We can only put an underscore between two digits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use at most one underscore in a row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[20.4 Reusing number operators for bigints (overloading)](#reusing-number-operators-for-bigints-overloading)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With most operators, we are not allowed to mix bigints and numbers. If we do,
    exceptions are thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for this rule is that there is no general way of coercing a number
    and a bigint to a common type: numbers can’t represent bigints beyond 53 bits,
    bigints can’t represent fractions. Therefore, the exceptions warn us about typos
    that may lead to unexpected results.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Should the result be `9007199254740993n` or `9007199254740992`?
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also not clear what the result of the following expression should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[20.4.1 Arithmetic operators](#arithmetic-operators-1)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Binary `+`, binary `-`, `*`, `**` work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It is OK to mix bigints and strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`/` and `%` round towards zero by removing the fraction (like `Math.trunc()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Unary `-` works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Unary `+` is not supported for bigints because much code relies on it coercing
    its operand to number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[20.4.2 Loose equality (`==`) and inequality (`!=`)](#loose-equality--and-inequality-)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Loose equality (`==`) and inequality (`!=`) coerce values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[20.4.3 Strict equality (`===`) and inequality (`!==`)](#strict-equality--and-inequality-)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Strict equality (`===`) and inequality (`!==`) only consider values to be equal
    if they have the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[20.4.4 Ordering operators](#ordering-operators-1)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Ordering operators `<`, `>`, `>=`, `<=` work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Comparing bigints and numbers does not pose any risks. Therefore, we can mix
    bigints and numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Converting numbers-based code to bigints**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/bigints/gcd-bigint_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[20.4.5 Bitwise operators (advanced)](#bitwise-operators-advanced-1)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[20.4.5.1 Bitwise operators for numbers](#bitwise-operators-for-numbers)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Bitwise operators interpret numbers as 32-bit integers. These integers are
    either unsigned or signed. If they are signed, the negative of an integer is its
    *two’s complement*: If we add an integer to its two’s complement and ignore overflow
    (digits beyond 32 bits) then the result is zero.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If we add `1` to the binary number consisting of 32 ones, we get a one followed
    by 32 zeros. Everything beyond 32 bits is overflow, which means that that number
    is zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used signed right shift operator (`>>`): We shifted the left operand by
    zero bits, which converted it to Int32 (which is signed) and back to number.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to these integers having a fixed size, their highest bits indicate their
    signs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[20.4.5.2 Bitwise operators for bigints](#bitwise-operators-for-bigints)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For bigints, bitwise operators interpret a negative sign as an infinite two’s
    complement – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-1` is `···111111` (ones extend infinitely to the left)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-2` is `···111110`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-3` is `···111101`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-4` is `···111100`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is, a negative sign is more of an external flag and not represented as
    an actual bit.
  prefs: []
  type: TYPE_NORMAL
- en: '[20.4.5.3 Bitwise Not (`~`)](#bitwise-not-)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Bitwise Not (`~`) inverts all bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[20.4.5.4 Binary bitwise operators (`&`, `|`, `^`)](#binary-bitwise-operators---)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Applying binary bitwise operators to bigints works analogously to applying
    them to numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[20.4.5.5 Bitwise signed shift operators (`<<` and `>>`)](#bitwise-signed-shift-operators--and-)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The signed shift operators for bigints preserve the sign of a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that `-1n` is a sequence of ones that extends infinitely to the left.
    That’s why shifting it left doesn’t change it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[20.4.5.6 Bitwise unsigned right shift operator (`>>>`)](#bitwise-unsigned-right-shift-operator-)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There is no unsigned right shift operator for bigints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Why? The idea behind unsigned right shifting is that a zero is shifted in “from
    the left”. In other words, the assumption is that there is a finite amount of
    binary digits.
  prefs: []
  type: TYPE_NORMAL
- en: However, with negative bigints (especially negative ones), there is no “left”;
    their binary digits extend infinitely.
  prefs: []
  type: TYPE_NORMAL
- en: Signed right shift works even with an infinite number of digits because the
    highest digit is preserved. Therefore, it can be adapted to bigints.
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Implementing a bit set via bigints**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/bigints/bit-set_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[20.5 The wrapper constructor `BigInt`](#the-wrapper-constructor-bigint)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Analogously to numbers, bigints have the associated wrapper constructor `BigInt`.
  prefs: []
  type: TYPE_NORMAL
- en: '[20.5.1 `BigInt` as a constructor and as a function](#bigint-as-a-constructor-and-as-a-function)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`new BigInt()`: throws a `TypeError`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BigInt(x)` converts arbitrary values `x` to bigint. This works similarly to
    `Number()`, with several differences which are summarized in [table 20.1](#tbl:converting-values-to-bigints)
    and explained in more detail in the following subsections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| `x` | `BigInt(x)` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `undefined` | Throws `TypeError` |'
  prefs: []
  type: TYPE_TB
- en: '| `null` | Throws `TypeError` |'
  prefs: []
  type: TYPE_TB
- en: '| boolean | `false` → `0n`, `true` → `1n` |'
  prefs: []
  type: TYPE_TB
- en: '| number | Example: `123` → `123n` |'
  prefs: []
  type: TYPE_TB
- en: '|  | Non-integer → throws `RangeError` |'
  prefs: []
  type: TYPE_TB
- en: '| bigint | `x` (no change) |'
  prefs: []
  type: TYPE_TB
- en: '| string | Example: `''123''` → `123n` |'
  prefs: []
  type: TYPE_TB
- en: '|  | Unparsable → throws `SyntaxError` |'
  prefs: []
  type: TYPE_TB
- en: '| symbol | Throws `TypeError` |'
  prefs: []
  type: TYPE_TB
- en: '| object | Configurable (e.g. via `.valueOf()`) |'
  prefs: []
  type: TYPE_TB
- en: 'Table 20.1: Converting values to bigints.'
  prefs: []
  type: TYPE_NORMAL
- en: '[20.5.1.1 Converting `undefined` and `null`](#converting-undefined-and-null)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A `TypeError` is thrown if `x` is either `undefined` or `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[20.5.1.2 Converting strings](#converting-strings)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If a string does not represent an integer, `BigInt()` throws a `SyntaxError`
    (whereas `Number()` returns the error value `NaN`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The suffix `''n''` is not allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'All bases of bigint literals are allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[20.5.1.3 Non-integer numbers produce exceptions](#noninteger-numbers-produce-exceptions)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[20.5.1.4 Converting objects](#converting-objects)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'How objects are converted to bigints can be configured – for example, by overriding
    `.valueOf()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[20.5.2 `BigInt.prototype.*` methods](#bigintprototype-methods)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`BigInt.prototype` holds the methods “inherited” by primitive bigints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BigInt.prototype.toLocaleString(locales?, options?)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BigInt.prototype.toString(radix?)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BigInt.prototype.valueOf()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[20.5.3 `BigInt.*` methods: casting](#bigint-methods-casting)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`BigInt.asIntN(width, theInt)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casts `theInt` to `width` bits (signed). This influences how the value is represented
    internally.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`BigInt.asUintN(width, theInt)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casts `theInt` to `width` bits (unsigned).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[20.5.3.1 Example: using 64-bit integers](#example-using-64bit-integers)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Casting allows us to create integer values with a specific number of bits –
    e.g., if we want to restrict ourselves to 64-bit integers, we always have to cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Implementing the analog of `Number.parseInt()` for bigints**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/bigints/parse-bigint_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[20.6 Coercing bigints to other primitive types](#coercing-bigints-to-other-primitive-types)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This table show what happens if we convert bigints to other primitive types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Convert to | Explicit conversion | Coercion (implicit conversion) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| boolean | `Boolean(0n)` → `false` | `!0n` → `true` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `Boolean(int)` → `true` | `!int` → `false` |'
  prefs: []
  type: TYPE_TB
- en: '| number | `Number(7n)` → `7` (example) | `+int` → `TypeError` (1) |'
  prefs: []
  type: TYPE_TB
- en: '| string | `String(7n)` → `''7''` (example) | `''''+7n` → `''7''` (example)
    |'
  prefs: []
  type: TYPE_TB
- en: 'Footnote:'
  prefs: []
  type: TYPE_NORMAL
- en: (1) Unary `+` is not supported for bigints, because much code relies on it coercing
    its operand to number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[20.7 Typed Array and DataView operations for 64-bit values](#typed-array-and-dataview-operations-for-64bit-values)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Thanks to bigints, Typed Arrays and DataViews can support 64-bit values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Typed Array constructors:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BigInt64Array`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BigUint64Array`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DataView methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DataView.prototype.getBigInt64()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DataView.prototype.setBigInt64()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DataView.prototype.getBigUint64()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DataView.prototype.setBigUint64()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[20.8 Bigints and JSON](#bigints-and-json)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The JSON standard is fixed and won’t change. The upside is that old JSON parsing
    code will never be outdated. The downside is that JSON can’t be extended to contain
    bigints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stringifying bigints throws exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[20.8.1 Stringifying bigints](#stringifying-bigints)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Therefore, our best option is to store bigints in strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[20.8.2 Parsing bigints](#parsing-bigints)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following code shows how to parse strings such as the one that we have produced
    in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[20.9 FAQ: Bigints](#faq-bigints)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[20.9.1 How do I decide when to use numbers and when to use bigints?](#how-do-i-decide-when-to-use-numbers-and-when-to-use-bigints)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'My recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use numbers for up to 53 bits and for Array indices. Rationale: They already
    appear everywhere and are handled efficiently by most engines (especially if they
    fit into 31 bits). Appearances include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.forEach()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.entries()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use bigints for large numeric values: If your fraction-less values don’t fit
    into 53 bits, you have no choice but to move to bigints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All existing web APIs return and accept only numbers and will only upgrade to
    bigint on a case-by-case basis.
  prefs: []
  type: TYPE_NORMAL
- en: '[20.9.2 Why not just increase the precision of numbers in the same manner as
    is done for bigints?](#why-not-just-increase-the-precision-of-numbers-in-the-same-manner-as-is-done-for-bigints)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One could conceivably split `number` into `integer` and `double`, but that would
    add many new complexities to the language (several integer-only operators etc.).
    I’ve sketched the consequences in [a Gist](https://gist.github.com/rauschma/13d48d1c49615ce2396ce7c9e45d4cd1).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**Acknowledgements:**'
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to Daniel Ehrenberg for reviewing an earlier version of this content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to Dan Callahan for reviewing an earlier version of this content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
