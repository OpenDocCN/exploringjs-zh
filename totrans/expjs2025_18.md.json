["```js\n> '7' * '3'\n21\n\n```", "```js\nconst obj = {};\nobj['true'] = 123;\n\n// Coerce true to the string 'true'\nassert.equal(obj[true], 123);\n\n```", "```js\n> [1,2,3] + [4,5,6]\n'1,2,34,5,6'\n\n```", "```js\n> String([1,2,3])\n'1,2,3'\n> String([4,5,6])\n'4,5,6'\n\n```", "```js\n> '1,2,3' + '4,5,6'\n'1,2,34,5,6'\n\n```", "```js\nimport assert from 'node:assert/strict';\n\n/**\n * @param {any} input \n * @param {'STRING'|'NUMBER'} [preferredType] optional\n * @returns {primitive}\n * @see https://tc39.es/ecma262/#sec-toprimitive\n */\nfunction ToPrimitive(input, preferredType) {\n  if (isObject(input)) {\n    // `input` is an object\n    const exoticToPrim = input[Symbol.toPrimitive]; // (A)\n    if (exoticToPrim !== undefined) {\n      let hint;\n      if (preferredType === undefined) {\n        hint = 'default';\n      } else if (preferredType === 'STRING') {\n        hint = 'string';\n      } else {\n        assert(preferredType === 'NUMBER');\n        hint = 'number';\n      }\n      const result = exoticToPrim.apply(input, [hint]);\n      if (!isObject(result)) return result;\n      throw new TypeError();\n    }\n    if (preferredType === undefined) {\n      preferredType = 'NUMBER';\n    }\n    return OrdinaryToPrimitive(input, preferredType);\n  }\n  // `input` is primitive\n  return input;\n}\n\n/**\n * @param {object} O \n * @param {'STRING'|'NUMBER'} hint \n * @returns {primitive}\n */\nfunction OrdinaryToPrimitive(O, hint) {\n  let methodNames;\n  if (hint === 'STRING') {\n    methodNames = ['toString', 'valueOf'];\n  } else {\n    methodNames = ['valueOf', 'toString'];\n  }\n  for (const name of methodNames) {\n    const method = O[name];\n    if (isCallable(method)) {\n      const result = method.apply(O);\n      if (!isObject(result)) return result;\n    }\n  }\n  throw new TypeError();\n}\n\nfunction isObject(value) {\n  return typeof value === 'object' && value !== null;\n}\n\nfunction isCallable(value) {\n  return typeof value === 'function';\n}\n\n```", "```js\nconst obj = {\n  toString() {\n return '1';\n },\n valueOf() {\n return 2;\n },\n};\nassert.equal(\n String(obj), '1'\n);\nassert.equal(\n Number(obj), 2\n); \n```", "```js\n> 'There are ' + 3 + ' items'\n'There are 3 items'\n\n```", "```js\n> 4 + true\n5\n\n```", "```js\nx = value; // assign to a previously declared variable\nobj.propKey = value; // assign to a property\narr[index] = value; // assign to an Array element\n\n```", "```js\nconst x = value;\nlet y = value;\n\n```", "```js\nmyvar op= value\nmyvar = myvar op value\n\n```", "```js\nlet str = '';\nstr += '<b>';\nstr += 'Hello!';\nstr += '</b>';\n\nassert.equal(str, '<b>Hello!</b>');\n\n```", "```js\n> undefined === null\nfalse\n> null === null\ntrue\n\n> true === false\nfalse\n> true === true\ntrue\n\n> 1 === 2\nfalse\n> 3 === 3\ntrue\n\n> 'a' === 'b'\nfalse\n> 'c' === 'c'\ntrue\n\n```", "```js\n> {} === {} // two different empty objects\nfalse\n\n> const obj = {};\n> obj === obj\ntrue\n\n```", "```js\n> Symbol() === Symbol() // two different symbols\nfalse\n> const sym = Symbol();\n> sym === sym\ntrue\n\n```", "```js\n> typeof NaN\n'number'\n> NaN === NaN\nfalse\n\n```", "```js\n> 1 == 2\nfalse\n> 3 == 3\ntrue\n> 'a' == 'b'\nfalse\n> 'c' == 'c'\ntrue\n\n```", "```js\n> [1, 2, 3] == [1, 2, 3] // two different objects\nfalse\n\n> const arr = [1, 2, 3];\n> arr == arr\ntrue\n\n```", "```js\n> '123' == 123\ntrue\n> false == 0\ntrue\n\n```", "```js\n> 0 == '\\r\\n\\t ' // only whitespace\ntrue\n\n```", "```js\n> [1, 2, 3] == '1,2,3'\ntrue\n> ['17'] == 17\ntrue\n\n```", "```js\n> Boolean(0)\nfalse\n> Boolean(2)\ntrue\n\n> 0 == false\ntrue\n> 2 == true\nfalse\n> 2 == false\nfalse\n\n> Boolean('')\nfalse\n> Boolean('abc')\ntrue\n\n> '' == false\ntrue\n> 'abc' == true\nfalse\n> 'abc' == false\nfalse\n\n```", "```js\n> undefined == null\ntrue\n\n```", "```js\nif (x == 123) {\n  // x is either 123 or '123'\n}\n\n```", "```js\nif (x === 123 || x === '123') ···\nif (Number(x) === 123) ···\n\n```", "```js\nif (x == null) {\n  // x is either null or undefined\n}\n\n```", "```js\nif (x === undefined || x === null) ···\n\n```", "```js\n> Object.is(3, 3)\ntrue\n> Object.is(3, 4)\nfalse\n> Object.is(3, '3')\nfalse\n\n```", "```js\n    > Object.is(NaN, NaN)\n    true\n    > NaN === NaN\n    false\n\n    ```", "```js\n    > Object.is(0, -0)\n    false\n    > 0 === -0\n    true\n\n    ```", "```js\nconst myIndexOf = (arr, elem) => {\n  return arr.findIndex(x => Object.is(x, elem));\n};\n\n```", "```js\n> myIndexOf([0,NaN,2], NaN)\n1\n> [0,NaN,2].indexOf(NaN)\n-1\n\n```", "```js\n> 5 >= 2\ntrue\n> 'bar' < 'foo'\ntrue\n\n```", "```js\nconst result = (console.log('evaluated'), 'YES');\nassert.equal(\n  result, 'YES'\n);\n\n```", "```js\nevaluated\n\n```", "```js\nconst result = void console.log('evaluated');\nassert.equal(\n  result, undefined\n);\n\n```", "```js\nevaluated\n\n```"]