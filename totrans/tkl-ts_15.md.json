["```ts\nenum NoYes {\n No = 0,\n Yes = 1, // trailing comma\n}\n\nassert.equal(NoYes.No, 0);\nassert.equal(NoYes.Yes, 1);\n```", "```ts\nfunction toGerman(value: NoYes) {\n switch (value) {\n case NoYes.No:\n return 'Nein';\n case NoYes.Yes:\n return 'Ja';\n }\n}\nassert.equal(toGerman(NoYes.No), 'Nein');\nassert.equal(toGerman(NoYes.Yes), 'Ja');\n```", "```ts\nenum NoYes {\n No = 'No',\n Yes = 'Yes',\n}\n\nassert.equal(NoYes.No, 'No');\nassert.equal(NoYes.Yes, 'Yes');\n```", "```ts\nenum Enum {\n One = 'One',\n Two = 'Two',\n Three = 3,\n Four = 4,\n}\nassert.deepEqual(\n [Enum.One, Enum.Two, Enum.Three, Enum.Four],\n ['One', 'Two', 3, 4]\n);\n```", "```ts\nenum NoYes {\n No,\n Yes,\n}\nassert.equal(NoYes.No, 0);\nassert.equal(NoYes.Yes, 1);\n```", "```ts\nenum Enum {\n A,\n B,\n C = 'C',\n D = 'D',\n E = 8, // (A)\n F,\n}\nassert.deepEqual(\n [Enum.A, Enum.B, Enum.C, Enum.D, Enum.E, Enum.F],\n [0, 1, 'C', 'D', 8, 9]\n);\n```", "```ts\nenum HttpRequestField {\n 'Accept',\n 'Accept-Charset',\n 'Accept-Datetime',\n 'Accept-Encoding',\n 'Accept-Language',\n}\nassert.equal(HttpRequestField['Accept-Charset'], 1);\n```", "```ts\nenum NoYes {\n No = 'No',\n Yes = 'Yes',\n}\nfunction func(x: NoYes.No) { // (A)\n return x;\n}\n\nfunc(NoYes.No); // OK\n\n// @ts-expect-error: Argument of type '\"No\"' is not assignable to\n// parameter of type 'NoYes.No'.\nfunc('No');\n\n// @ts-expect-error: Argument of type 'NoYes.Yes' is not assignable to\n// parameter of type 'NoYes.No'.\nfunc(NoYes.Yes);\n```", "```ts\nenum Perm {\n UserRead     = 1 << 8, // bit 8\n UserWrite    = 1 << 7,\n UserExecute  = 1 << 6,\n GroupRead    = 1 << 5,\n GroupWrite   = 1 << 4,\n GroupExecute = 1 << 3,\n AllRead      = 1 << 2,\n AllWrite     = 1 << 1,\n AllExecute   = 1 << 0,\n}\n```", "```ts\nenum NoYesNum {\n No = 123,\n Yes = Math.random(), // OK\n}\n```", "```ts\nenum NoYesStr {\n No = 'No',\n // @ts-expect-error: Computed values are not permitted in\n // an enum with string valued members.\n Yes = ['Y', 'e', 's'].join(''),\n}\n```", "```ts\nenum NoYes { No, Yes }\n\nconsole.log(NoYes.No);\nconsole.log(NoYes.Yes);\n\n// Output:\n// 0\n// 1\n```", "```ts\nenum NoYes { No, Yes }\nfunction func(noYes: NoYes) {}\nfunc(33); // no error!\n```", "```ts\nenum NoYes { No='No', Yes='Yes' }\n```", "```ts\nconsole.log(NoYes.No);\nconsole.log(NoYes.Yes);\n\n// Output:\n// 'No'\n// 'Yes'\n```", "```ts\nfunction func(noYes: NoYes) {}\n\n// @ts-expect-error: Argument of type '\"abc\"' is not assignable\n// to parameter of type 'NoYes'.\nfunc('abc');\n\n// @ts-expect-error: Argument of type '\"Yes\"' is not assignable\n// to parameter of type 'NoYes'.\nfunc('Yes'); // (A)\n```", "```ts\nenum Perm {\n UserRead     = 1 << 8, // bit 8\n UserWrite    = 1 << 7,\n UserExecute  = 1 << 6,\n GroupRead    = 1 << 5,\n GroupWrite   = 1 << 4,\n GroupExecute = 1 << 3,\n AllRead      = 1 << 2,\n AllWrite     = 1 << 1,\n AllExecute   = 1 << 0,\n}\n```", "```ts\n// User can change, read and execute.\n// Everyone else can only read and execute.\nassert.equal(\n Perm.UserRead | Perm.UserWrite | Perm.UserExecute |\n Perm.GroupRead | Perm.GroupExecute |\n Perm.AllRead | Perm.AllExecute,\n 0o755);\n\n// User can read and write.\n// Group members can read.\n// Everyone can\u2019t access at all.\nassert.equal(\n Perm.UserRead | Perm.UserWrite | Perm.GroupRead,\n 0o640);\n```", "```ts\nenum Perm {\n UserRead = 'UserRead',\n UserWrite = 'UserWrite',\n UserExecute = 'UserExecute',\n GroupRead = 'GroupRead',\n GroupWrite = 'GroupWrite',\n GroupExecute = 'GroupExecute',\n AllRead = 'AllRead',\n AllWrite = 'AllWrite',\n AllExecute = 'AllExecute',\n}\nfunction writeFileSync(\n thePath: string, permissions: Set<Perm>, content: string) {\n // \u00b7\u00b7\u00b7\n}\nwriteFileSync(\n '/tmp/hello.txt',\n new Set([Perm.UserRead, Perm.UserWrite, Perm.GroupRead]),\n 'Hello!');\n```", "```ts\nconst off = Symbol('off');\nconst info = Symbol('info');\nconst warn = Symbol('warn');\nconst error = Symbol('error');\n```", "```ts\nenum LogLevel {\n off = 'off',\n info = 'info',\n warn = 'warn',\n error = 'error',\n}\n```", "```ts\ntype LogLevel =\n | typeof off\n | typeof info\n | typeof warn\n | typeof error\n;\n```", "```ts\nclass List1 {\n isOrdered: boolean;\n // \u00b7\u00b7\u00b7\n}\n```", "```ts\nenum ListKind { ordered, unordered }\nclass List2 {\n listKind: ListKind;\n // \u00b7\u00b7\u00b7\n}\n```", "```ts\nfunction convertToHtml1(markdown: string, throwOnError: boolean) {\n // \u00b7\u00b7\u00b7\n}\n```", "```ts\nenum ErrorHandling {\n throwOnError = 'throwOnError',\n showErrorsInContent = 'showErrorsInContent',\n}\nfunction convertToHtml2(markdown: string, errorHandling: ErrorHandling) {\n // \u00b7\u00b7\u00b7\n}\n```", "```ts\nconst GLOBAL = 'g';\nconst NOT_GLOBAL = '';\ntype Globalness = typeof GLOBAL | typeof NOT_GLOBAL;\n\nfunction createRegExp(source: string,\n globalness: Globalness = NOT_GLOBAL) {\n return new RegExp(source, 'u' + globalness);\n }\n\nassert.deepEqual(\n createRegExp('abc', GLOBAL),\n /abc/ug);\n\nassert.deepEqual(\n createRegExp('abc', 'g'), // OK\n /abc/ug);\n```", "```ts\nenum Globalness {\n Global = 'g',\n notGlobal = '',\n}\n\nfunction createRegExp(source: string, globalness = Globalness.notGlobal) {\n return new RegExp(source, 'u' + globalness);\n}\n\nassert.deepEqual(\n createRegExp('abc', Globalness.Global),\n /abc/ug);\n\nassert.deepEqual(\n // @ts-expect-error: Argument of type '\"g\"' is not assignable to parameter of type 'Globalness | undefined'. (2345)\n createRegExp('abc', 'g'), // error\n /abc/ug);\n```", "```ts\nenum NoYes {\n No,\n Yes,\n}\n```", "```ts\nvar NoYes;\n(function (NoYes) {\n NoYes[NoYes[\"No\"] = 0] = \"No\";\n NoYes[NoYes[\"Yes\"] = 1] = \"Yes\";\n})(NoYes || (NoYes = {}));\n```", "```ts\nNoYes[\"No\"] = 0;\nNoYes[\"Yes\"] = 1;\n\nNoYes[0] = \"No\";\nNoYes[1] = \"Yes\";\n```", "```ts\nenum NoYes {\n No,\n Yes,\n}\n```", "```ts\n// Static (= fixed) lookup:\nassert.equal(NoYes.Yes, 1);\n\n// Dynamic lookup:\nassert.equal(NoYes['Yes'], 1);\n```", "```ts\nassert.equal(NoYes[1], 'Yes');\n```", "```ts\nfunction getQualifiedName(value: NoYes) {\n return 'NoYes.' + NoYes[value];\n}\nassert.equal(\n getQualifiedName(NoYes.Yes), 'NoYes.Yes');\n```", "```ts\nenum NoYes {\n No = 'NO!',\n Yes = 'YES!',\n}\n```", "```ts\nvar NoYes;\n(function (NoYes) {\n NoYes[\"No\"] = \"NO!\";\n NoYes[\"Yes\"] = \"YES!\";\n})(NoYes || (NoYes = {}));\n```", "```ts\nenum NoYes {\n No = 'No',\n Yes = 'Yes',\n}\n\nfunction toGerman(value: NoYes) {\n switch (value) {\n case NoYes.No:\n return 'Nein';\n case NoYes.Yes:\n return 'Ja';\n }\n}\n```", "```ts\n\"use strict\";\nvar NoYes;\n(function (NoYes) {\n NoYes[\"No\"] = \"No\";\n NoYes[\"Yes\"] = \"Yes\";\n})(NoYes || (NoYes = {}));\n\nfunction toGerman(value) {\n switch (value) {\n case NoYes.No:\n return 'Nein';\n case NoYes.Yes:\n return 'Ja';\n }\n}\n```", "```ts\nconst enum NoYes {\n No,\n Yes,\n}\nfunction toGerman(value: NoYes) {\n switch (value) {\n case NoYes.No:\n return 'Nein';\n case NoYes.Yes:\n return 'Ja';\n }\n}\n```", "```ts\nfunction toGerman(value) {\n switch (value) {\n case \"No\" /* No */:\n return 'Nein';\n case \"Yes\" /* Yes */:\n return 'Ja';\n }\n}\n```", "```ts\nenum NoYes {\n No = 'No',\n Yes = 'Yes',\n}\nfunction func(obj: { No: string }) {\n return obj.No;\n}\nassert.equal(\n func(NoYes), // allowed statically!\n 'No');\n```", "```ts\nenum NoYes {\n No = 'No',\n Yes = 'Yes',\n}\n```", "```ts\nfunction toGerman1(value: NoYes) {\n switch (value) {\n case NoYes.No:\n return 'Nein';\n case NoYes.Yes:\n return 'Ja';\n default:\n throw new TypeError('Unsupported value: ' + JSON.stringify(value));\n }\n}\n\nassert.throws(\n // @ts-expect-error: Argument of type '\"Maybe\"' is not assignable to\n // parameter of type 'NoYes'.\n () => toGerman1('Maybe'),\n /^TypeError: Unsupported value: \"Maybe\"$/);\n```", "```ts\nclass UnsupportedValueError extends Error {\n constructor(value: never) {\n super('Unsupported value: ' + value);\n }\n}\n\nfunction toGerman2(value: NoYes) {\n switch (value) {\n case NoYes.No:\n return 'Nein';\n case NoYes.Yes:\n return 'Ja';\n default:\n throw new UnsupportedValueError(value);\n }\n}\n```", "```ts\nfunction toGerman2b(value: NoYes) {\n switch (value) {\n case NoYes.No:\n // %inferred-type: NoYes.No\n value;\n return 'Nein';\n case NoYes.Yes:\n // %inferred-type: NoYes.Yes\n value;\n return 'Ja';\n default:\n // %inferred-type: never\n value;\n throw new UnsupportedValueError(value);\n }\n}\n```", "```ts\nArgument of type 'NoYes.Maybe' is not assignable to parameter of type 'never'.\n```", "```ts\nfunction toGerman3(value: NoYes) {\n if (value === NoYes.No) {\n return 'Nein';\n } else if (value === NoYes.Yes) {\n return 'Ja';\n } else {\n throw new UnsupportedValueError(value);\n }\n}\n```", "```ts\nfunction toGerman4(value: NoYes): string {\n switch (value) {\n case NoYes.No:\n const x: NoYes.No = value;\n return 'Nein';\n case NoYes.Yes:\n const y: NoYes.Yes = value;\n return 'Ja';\n }\n}\n```", "```ts\nenum HttpRequestKeyEnum {\n 'Accept',\n 'Accept-Charset',\n 'Accept-Datetime',\n 'Accept-Encoding',\n 'Accept-Language',\n}\n// %inferred-type: \"Accept\" | \"Accept-Charset\" | \"Accept-Datetime\" |\n// \"Accept-Encoding\" | \"Accept-Language\"\ntype HttpRequestKey = keyof typeof HttpRequestKeyEnum;\n\nfunction getRequestHeaderValue(request: Request, key: HttpRequestKey) {\n // \u00b7\u00b7\u00b7\n}\n```", "```ts\n// %inferred-type: \"toString\" | \"toFixed\" | \"toExponential\" |\n// \"toPrecision\" | \"valueOf\" | \"toLocaleString\"\ntype Keys = keyof HttpRequestKeyEnum;\n```"]