- en: 13 Techniques for instantiating classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/deep-js/ch_creating-class-instances.html](https://exploringjs.com/deep-js/ch_creating-class-instances.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '13.1 [The problem: initializing a property asynchronously](ch_creating-class-instances.html#the-problem-initializing-a-property-asynchronously)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '13.2 [Solution: Promise-based constructor](ch_creating-class-instances.html#solution-promise-based-constructor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.2.1 [Using an immediately-invoked asynchronous arrow function](ch_creating-class-instances.html#using-an-immediately-invoked-asynchronous-arrow-function)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '13.3 [Solution: static factory method](ch_creating-class-instances.html#solution-static-factory-method)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '13.3.1 [Improvement: private constructor via secret token](ch_creating-class-instances.html#improvement-private-constructor-via-secret-token)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '13.3.2 [Improvement: constructor throws, factory method borrows the class prototype](ch_creating-class-instances.html#improvement-constructor-throws-factory-method-borrows-the-class-prototype)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '13.3.3 [Improvement: instances are inactive by default, activated by factory
    method](ch_creating-class-instances.html#improvement-instances-are-inactive-by-default-activated-by-factory-method)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '13.3.4 [Variant: separate factory function](ch_creating-class-instances.html#variant-separate-factory-function)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.4 [Subclassing a Promise-based constructor (optional)](ch_creating-class-instances.html#subclassing-a-promise-based-constructor-optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.5 [Conclusion](ch_creating-class-instances.html#conclusion-1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.6 [Further reading](ch_creating-class-instances.html#further-reading-3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we examine several approaches for creating instances of classes:
    Constructors, factory functions, etc. We do so by solving one concrete problem
    several times. The focus of this chapter is on classes, which is why alternatives
    to classes are ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: '13.1 The problem: initializing a property asynchronously'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following container class is supposed to receive the contents of its property
    `.data` asynchronously. This is our first attempt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Key issue of this code: Property `.data` is initially `undefined`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In line A, we declare the [private field](https://2ality.com/2019/07/private-class-fields.html)
    `.#data` that we use in line B and line C.
  prefs: []
  type: TYPE_NORMAL
- en: The Promise inside the constructor of `DataContainer` is settled asynchronously,
    which is why we can only see the final value of `.data` if we finish the current
    task and start a new one, via `setTimeout()`. In other words, the instance of
    `DataContainer` is not completely initialized, yet, when we first see it.
  prefs: []
  type: TYPE_NORMAL
- en: '13.2 Solution: Promise-based constructor'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What if we delay access to the instance of `DataContainer` until it is fully
    initialized? We can achieve that by returning a Promise from the constructor.
    By default, a constructor returns a new instance of the class that it is part
    of. We can override that if we explicitly return an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have to wait until we can access our instance (line B). It is passed
    on to us after the data is “downloaded” (line A). There are two possible sources
    of errors in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: The download may fail and produce a rejection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An exception may be thrown in the body of the first `.then()` callback.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In either case, the errors become rejections of the Promise that is returned
    from the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros and cons:'
  prefs: []
  type: TYPE_NORMAL
- en: A benefit of this approach is that we can only access the instance once it is
    fully initialized. And there is no other way of creating instances of `DataContainer`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A disadvantage is that it may be surprising to have a constructor return a Promise
    instead of an instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.2.1 Using an immediately-invoked asynchronous arrow function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Instead of using the Promise API directly to create the Promise that is returned
    from the constructor, we can also use an asynchronous arrow function that [we
    invoke immediately](https://exploringjs.com/impatient-js/ch_async-functions.html#immediately-invoked-async-arrow-functions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '13.3 Solution: static factory method'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *static factory method* of a class `C` creates instances of `C` and is an
    alternative to using `new C()`. Common names for static factory methods in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.create()`: Creates a new instance. Example: `Object.create()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.from()`: Creates a new instance based on a different object, by copying and/or
    converting it. Example: `Array.from()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.of()`: Creates a new instance by assembling values specified via arguments.
    Example: `Array.of()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, `DataContainer.create()` is a static factory method.
    It returns Promises for instances of `DataContainer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This time, all asynchronous functionality is contained in `.create()`, which
    enables the rest of the class to be completely synchronous and therefore simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros and cons:'
  prefs: []
  type: TYPE_NORMAL
- en: A benefit of this approach is that the constructor becomes simple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A disadvantage of this approach is that it’s now possible to create instances
    that are incorrectly set up, via `new DataContainer()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '13.3.1 Improvement: private constructor via secret token'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we want to ensure that instances are always correctly set up, we must ensure
    that only `DataContainer.create()` can invoke the constructor of `DataContainer`.
    We can achieve that via a secret token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If `secretToken` and `DataContainer` reside in the same module and only the
    latter is exported, then outside parties don’t have access to `secretToken` and
    therefore can’t create instances of `DataContainer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros and cons:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefit: safe and straightforward.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Disadvantage: slightly verbose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '13.3.2 Improvement: constructor throws, factory method borrows the class prototype'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following variant of our solution disables the constructor of `DataContainer`
    and uses a trick to create instances of it another way (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Internally, an instance of `DataContainer` is any object whose prototype is
    `DataContainer.prototype`. That’s why we can create instances via `Object.create()`
    (line A) and that’s why `instanceof` works in line B.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros and cons:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefit: elegant; `instanceof` works.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Disadvantages:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating instances is not completely prevented. To be fair, though, the work-around
    via `Object.create()` can also be used for our previous solutions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We can’t use [private fields](https://2ality.com/2019/07/private-class-fields.html)
    and [private methods](https://2ality.com/2019/07/private-methods-accessors-in-classes.html)
    in `DataContainer`, because those are only set up correctly for instances that
    were created via the constructor.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '13.3.3 Improvement: instances are inactive by default, activated by factory
    method'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another, more verbose variant is that, by default, instances are switched off
    via the flag `.#active`. The initialization method `.#init()` that switches them
    on cannot be accessed externally, but `Data.container()` can invoke it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The flag `.#active` is enforced via the private method `.#check()` which must
    be invoked at the beginning of every method.
  prefs: []
  type: TYPE_NORMAL
- en: The major downside of this solution is its verbosity. There is also a risk of
    forgetting to invoke `.#check()` in each method.
  prefs: []
  type: TYPE_NORMAL
- en: '13.3.4 Variant: separate factory function'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For completeness sake, I’ll show another variant: Instead of using a static
    method as a factory you can also use a separate stand-alone function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Stand-alone functions as factories are occasionally useful, but in this case,
    I prefer a static method:'
  prefs: []
  type: TYPE_NORMAL
- en: The stand-alone function can’t access private members of `DataContainer`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I prefer the way `DataContainer.create()` looks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.4 Subclassing a Promise-based constructor (optional)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In general, subclassing is something to use sparingly.
  prefs: []
  type: TYPE_NORMAL
- en: With a separate factory function, it is relatively easy to extend `DataContainer`.
  prefs: []
  type: TYPE_NORMAL
- en: Alas, extending the class with the Promise-based constructor leads to severe
    limitations. In the following example, we subclass `DataContainer`. The subclass
    `SubDataContainer` has its own private field `.#moreData` that it initializes
    asynchronously by hooking into the Promise returned by the constructor of its
    superclass.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Alas, we can’t instantiate this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Why the failure? A constructor always adds its private fields to its `this`.
    However, here, `this` in the subconstructor is the Promise returned by the superconstructor
    (and not the instance of `SubDataContainer` delivered via the Promise).
  prefs: []
  type: TYPE_NORMAL
- en: However, this approach still works if `SubDataContainer` does not have any private
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: 13.5 Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the scenario examined in this chapter, I prefer either a Promise-based constructor
    or a static factory method plus a private constructor via a secret token.
  prefs: []
  type: TYPE_NORMAL
- en: However, the other techniques presented here can still be useful in other scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 13.6 Further reading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Asynchronous programming:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter “Promises for asynchronous programming”](https://exploringjs.com/impatient-js/ch_promises.html)
    in “JavaScript for impatient programmers”'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter “Async functions”](https://exploringjs.com/impatient-js/ch_async-functions.html)
    in “JavaScript for impatient programmers”'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Section “Immediately invoked async arrow functions”](https://exploringjs.com/impatient-js/ch_async-functions.html#immediately-invoked-async-arrow-functions)
    in “JavaScript for impatient programmers”'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OOP:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter “Prototype chains and classes”](https://exploringjs.com/impatient-js/ch_proto-chains-classes.html)
    in “JavaScript for impatient programmers”'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blog post “ES proposal: private class fields”](https://2ality.com/2019/07/private-class-fields.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blog post “ES proposal: private methods and accessors in JavaScript classes”](https://2ality.com/2019/07/private-methods-accessors-in-classes.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/deep-js/issues/13)'
  prefs: []
  type: TYPE_NORMAL
