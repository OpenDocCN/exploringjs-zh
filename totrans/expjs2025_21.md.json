["```js\n> typeof false\n'boolean'\n> typeof true\n'boolean'\n\n```", "```js\nif (value) {}\n\n```", "```js\nif (value === true) {}\n\n```", "```js\nif (Boolean(value) === true) {}\n\n```", "```js\n> Boolean('abc')\ntrue\n> Boolean([])\ntrue\n> Boolean({})\ntrue\n\n```", "```js\nif (x) {\n // x is truthy\n}\n `if (!x) {`\n `// x is falsy`\n`}`\n ```", "```js \n```", "```js```", "``` ```", "````` The conditional operator that is used in the last line, is explained [later in this chapter](#conditional-operator).    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Truthiness**    `exercises/booleans/truthiness_exrc.mjs`    ### [17.3 Truthiness-based existence checks](#truthiness-existence-checks)    In JavaScript, if we read something that doesn’t exist (e.g., a missing parameter or a missing property), we usually get `undefined` as a result. In these cases, an existence check amounts to comparing a value with `undefined`. For example, the following code checks if object `obj` has the property `.prop`:    ```js if (obj.prop !== undefined) {  // obj has property .prop }  ```    Due to `undefined` being falsy, we can shorten this check to:    ```js if (obj.prop) {  // obj has property .prop }  ```    #### [17.3.1 Pitfall: truthiness-based existence checks are imprecise](#pitfall-truthinessbased-existence-checks-are-imprecise)    Truthiness-based existence checks have one pitfall: they are not very precise. Consider this previous example:    ```js if (obj.prop) {  // obj has property .prop }  ```    The body of the `if` statement is skipped if:    *   `obj.prop` is missing (in which case, JavaScript returns `undefined`).    However, it is also skipped if:    *   `obj.prop` is `undefined`. *   `obj.prop` is any other falsy value (`null`, `0`, `''`, etc.).    In practice, this rarely causes problems, but we have to be aware of this pitfall.    #### [17.3.2 Use case: was a parameter provided?](#use-case-was-a-parameter-provided)    A truthiness check is often used to determine if the caller of a function provided a parameter:    ```js function func(x) {  if (!x) {  throw new Error('Missing parameter x');  }  // ··· }  ```    On the plus side, this pattern is established and short. It correctly throws errors for `undefined` and `null`.    On the minus side, there is the previously mentioned pitfall: the code also throws errors for all other falsy values.    An alternative is to check for `undefined`:    ```js if (x === undefined) {  throw new Error('Missing parameter x'); }  ```    #### [17.3.3 Use case: does a property exist?](#use-case-does-a-property-exist)    Truthiness checks are also often used to determine if a property exists:    ```js function readFile(fileDesc) {  if (!fileDesc.path) {  throw new Error('Missing property: .path');  }  // ··· } readFile({ path: 'foo.txt' }); // no error  ```    This pattern is also established and has the usual caveat: it not only throws if the property is missing, but also if it exists and has any of the falsy values.    If we truly want to check if the property exists, we have to use [the `in` operator](ch_objects.html#in-operator):    ```js if (! ('path' in fileDesc)) {  throw new Error('Missing property: .path'); }  ```    ### [17.4 Conditional operator (`? :`)](#conditional-operator)    The conditional operator is the expression version of the `if` statement. Its syntax is:    ```js «condition» ? «thenExpression» : «elseExpression»  ```    It is evaluated as follows:    *   If `condition` is truthy, evaluate and return `thenExpression`. *   Otherwise, evaluate and return `elseExpression`.    The conditional operator is also called *ternary operator* because it has three operands.    Examples:    ```js > true ? 'yes' : 'no' 'yes' > false ? 'yes' : 'no' 'no' > '' ? 'yes' : 'no' 'no'  ```    The following code demonstrates that whichever of the two branches “then” and “else” is chosen via the condition, only that branch is evaluated. The other branch isn’t.    ```js const x = (true ? console.log('then') : console.log('else'));  ```    Output:    ```js then  ```    ### [17.5 Binary logical operators: And (`x && y`), Or (`x || y`)](#binary-logical-operators)    JavaScript has two binary logical operators:    *   Logical And (`x && y`) *   Logical Or (`x || y`)    They are *value-preserving* and *short-circuiting*.    #### [17.5.1 Value-preservation](#value-preservation)    *Value-preservation* means that operands are interpreted as booleans but returned unchanged:    ```js > 12 || 'hello' 12 > 0 || 'hello' 'hello'  ```    #### [17.5.2 Short-circuiting](#short-circuiting)    *Short-circuiting* means if the first operand already determines the result, then the second operand is not evaluated. The only other operator that delays evaluating its operands is the conditional operator. Usually, all operands are evaluated before performing an operation.    For example, logical And (`&&`) does not evaluate its second operand if the first one is falsy:    ```js const x = false && console.log('hello'); // No output  ```    If the first operand is truthy, `console.log()` is executed:    ```js const x = true && console.log('hello');  ```    Output:    ```js hello  ```    #### [17.5.3 Logical And (`x && y`)](#logical-and-x--y)    The expression `a && b` (“`a` And `b`”) is evaluated as follows:    1.  Evaluate `a`. 2.  Is the result falsy? Return it. 3.  Otherwise, evaluate `b` and return the result.    In other words, the following two expressions are roughly equivalent:    ```js a && b !a ? a : b  ```    Examples:    ```js > false && true false > false && 'abc' false  `> true && false` `false` `> true && 'abc'` `'abc'`  `` `> '' && 'abc'` `''` ``  ```   ```js```` ```js``` #### [17.5.4 Logical Or (`||`)](#logical-or-)    The expression `a || b` (“`a` Or `b`”) is evaluated as follows:    1.  Evaluate `a`. 2.  Is the result truthy? Return it. 3.  Otherwise, evaluate `b` and return the result.    In other words, the following two expressions are roughly equivalent:    ``` a || b a ? a : b  ```js    Examples:    ``` > true || false true > true || 'abc' true  `> false || true` `true` `> false || 'abc'` `'abc'`  `` `> 'abc' || 'def'` `'abc'` ``  ```js   `````", "```js` ##### [17.5.4.1 Legacy use case for logical Or (`||`): providing default values](#legacy-use-case-for-logical-or--providing-default-values)    ECMAScript 2020 introduced the nullish coalescing operator (`??`) for default values. Before that, logical Or was used for this purpose:    ```", "```js    See [“The nullish coalescing operator (`??`) for default values ^(ES2020)” (§16.4)](ch_undefined-null.html#nullish-coalescing-operator) for more information on `??` and the downsides of `||` in this case.    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Legacy exercise: Default values via the Or operator (`||`)**    `exercises/booleans/default_via_or_exrc.mjs`    ### [17.6 Logical Not (`!`)](#logical-not)    The expression `!x` (“Not `x`”) is evaluated as follows:    1.  Evaluate `x`. 2.  Coerce the result to boolean. 3.  Is that result `true`? Return `false`. 4.  Return `true`.    Examples:    ```", "```js ```", "```js`` ```", "```js ```", "```js` ```", "```js`` ```"]