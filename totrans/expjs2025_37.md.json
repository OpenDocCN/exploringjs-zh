["```js\nclass Person {\n constructor(firstName) { // (A)\n this.firstName = firstName; // (B)\n }\n describe() { // (C)\n return 'Person named ' + this.firstName;\n }\n}\nconst tarzan = new Person('Tarzan');\nassert.equal(\n tarzan.firstName, 'Tarzan'\n);\nassert.equal(\n tarzan.describe(),\n 'Person named Tarzan'\n);\n// One property (public slot)\nassert.deepEqual(\n Reflect.ownKeys(tarzan), ['firstName']\n);\n\n```", "```js\nclass Person {\n #firstName; // (A)\n constructor(firstName) {\n this.#firstName = firstName; // (B)\n }\n describe() {\n return 'Person named ' + this.#firstName;\n }\n}\nconst tarzan = new Person('Tarzan');\nassert.equal(\n tarzan.describe(),\n 'Person named Tarzan'\n);\n// No properties, only a private field\nassert.deepEqual(\n Reflect.ownKeys(tarzan), []\n);\n\n```", "```js\nclass Employee extends Person {\n #title;\n `constructor(firstName, title) {`\n `super(firstName); // (A)`\n `this.#title = title;`\n `}`\n `describe() {`\n ``return `${super.describe()} (${this.#title})`; // (B)``\n `}`\n`}`\n `` `const jane = new Employee('Jane', 'CTO');` `assert.equal(`  `jane.describe(),`  `'Person named Jane (CTO)'` `);` `` \n```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js`` ````", "```````js```````", "```````js```````", "```````js```````", "````` *   Line A: In subclasses, we can omit the constructor. If we don’t, we have to call `super()`. *   Line B: We can refer to overridden methods via `super`.    The next class demonstrates how to create properties via *public fields* (line A):    ```js class StringBuilderClass {  string = ''; // (A)  add(str) {  this.string += str;  return this;  } }  `const sb = new StringBuilderClass();` `sb.add('Hello').add(' everyone').add('!');` `assert.equal(`  `sb.string, 'Hello everyone!'` `);`  ```   ```js`````", "```````js```````", "```````js```````", "```````js```````", "``` class Person {  #firstName; // (A)  constructor(firstName) {  this.#firstName = firstName; // (B)  }  describe() {  return `Person named ${this.#firstName}`;  }  static extractNames(persons) {  return persons.map(person => person.#firstName);  } }  ```", "``` const jane = new Person('Jane'); const tarzan = new Person('Tarzan');  ```", "```     assert.deepEqual(      Reflect.ownKeys(jane),      []     );          ```", "```     assert.equal(      jane.describe(), 'Person named Jane'     );     assert.equal(      tarzan.describe(), 'Person named Tarzan'     );          ```", "```     assert.deepEqual(      Person.extractNames([jane, tarzan]),      ['Jane', 'Tarzan']     );          ```", "``` class Container {  constructor(value) {  this.value = value;  } } const abcContainer = new Container('abc'); assert.equal(  abcContainer.value, 'abc' );  ```", "``` // Anonymous class expression const Person = class { ··· };  `// Named class expression` `const Person = class MyClass { ··· };`  ```", "``````js``````", "```````js```````", "```````js```````", "```````js``` The name of a named class expression works similarly to [the name of a named function expression](ch_callables.html#named-function-expressions): It can only be accessed inside the body of a class and stays the same, regardless of what the class is assigned to.    #### [31.2.3 The `instanceof` operator](#the-instanceof-operator)    The `instanceof` operator tells us if a value is an instance of a given class:    ``` > new Person('Jane') instanceof Person true > {} instanceof Person false > {} instanceof Object true > [] instanceof Array true  ```js    We’ll explore the `instanceof` operator in more detail [later](#instanceof-operator-details), after we have looked at subclassing.    #### [31.2.4 Public slots (properties) vs. private slots](#private-slots)    In the JavaScript language, objects can have two kinds of “slots”.    *   *Public slots* (which are are also called *properties*). For example, methods are public slots. *   *Private slots* ^(ES2022). For example, private fields are private slots.    These are the most important rules we need to know about properties and private slots:    *   In classes, we can use public and private versions of fields, methods, getters and setters. All of them are slots in objects. Which objects they are placed in depends on whether the keyword `static` is used and other factors. *   A getter and a setter that have the same key create a single *accessor* slot. An Accessor can also have only a getter or only a setter. *   Properties and private slots are very different – for example:     *   They are stored separately.     *   Their keys are different. The keys of private slots can’t even be accessed directly (see [“Each private slot has a unique key (a *private name*)” (§31.2.5.2)](#private-names) later in this chapter).     *   Properties are inherited from prototypes, private slots aren’t.     *   Private slots can only be created via classes.    The following class demonstrates the two kinds of slots. Each of its instances has one private field and one property:    ``` class MyClass {  #instancePrivateField = 1;  instanceProperty = 2;  getInstanceValues() {  return [  this.#instancePrivateField,  this.instanceProperty,  ];  } } const inst = new MyClass(); assert.deepEqual(  inst.getInstanceValues(), [1, 2] );  ```js    As expected, outside `MyClass`, we can only see the property:    ``` assert.deepEqual(  Reflect.ownKeys(inst),  ['instanceProperty'] );  ```js    ![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **More information on properties**    This chapter doesn’t cover all details of properties (just the essentials). If you want to dig deeper, you can do so in [“Property attributes and property descriptors ^(ES5) (advanced)” (§30.10)](ch_objects.html#property-attributes-property-descriptors)    Next, we’ll look at some of the details of private slots.    #### [31.2.5 Private slots in more detail ^(ES2022) (advanced)](#private-slots-in-more-detail-es2022-advanced)    ##### [31.2.5.1 Private slots can’t be accessed in subclasses](#private-slots-cant-be-accessed-in-subclasses)    A private slot really can only be accessed inside the class that declares it. We can’t even access it from a subclass:    ``` class SuperClass {  #superProp = 'superProp'; } class SubClass extends SuperClass {  getSuperProp() {  return this.#superProp;  } } // SyntaxError: Private field '#superProp' // must be declared in an enclosing class  ```js    [Subclassing via `extends`](#subclassing) is explained later in this chapter. How to work around this limitation is explained in [“Simulating protected visibility and friend visibility via WeakMaps (advanced)” (§31.5.4)](#instance-protected-fields).    ##### [31.2.5.2 Each private slot has a unique key (a *private name*)](#private-names)    Private slots have unique keys that are similar to [symbols](ch_symbols.html#ch_symbols). Consider the following class from earlier:    ``` class MyClass {  #instancePrivateField = 1;  instanceProperty = 2;  getInstanceValues() {  return [  this.#instancePrivateField,  this.instanceProperty,  ];  } }  ```js    Internally, the private field of `MyClass` is handled roughly like this:    ``` let MyClass; { // Scope of the body of the class  const instancePrivateFieldKey = Symbol();  MyClass = class {  __PrivateElements__ = new Map([  [instancePrivateFieldKey, 1],  ]);  instanceProperty = 2;  getInstanceValues() {  return [  this.__PrivateElements__.get(instancePrivateFieldKey),  this.instanceProperty,  ];  }  } }  ```js    The value of `instancePrivateFieldKey` is called a *private name*. We can’t use private names directly in JavaScript, we can only use them indirectly, via the fixed identifiers of private fields, private methods, and private accessors. Where the fixed identifiers of public slots (such as `getInstanceValues`) are interpreted as string keys, the fixed identifiers of private slots (such as `#instancePrivateField`) refer to private names (similarly to how variable names refer to values).    ![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **Private slots in the ECMAScript language specification**    Section [“Object Internal Methods and Internal Slots”](https://tc39.es/ecma262/#sec-object-internal-methods-and-internal-slots) in the ECMAScript language specification explains how private slots work. Search for “`[[PrivateElements]]`”.    ##### [31.2.5.3 Private names are statically scoped (like variables)](#private-names-are-statically-scoped-like-variables)    A callable entity can only access the name of a private slot if it was born inside the scope where the name was declared. However, it doesn’t lose this ability if it moves somewhere else later on:    ``` class MyClass {  #privateData = 'hello';  static createGetter() {  return (obj) => obj.#privateData; // (A)  } }  `const myInstance = new MyClass();` `const getter = MyClass.createGetter();` `assert.equal(`  `getter(myInstance), 'hello' // (B)` `);`  ```js   ``````js```````", "```````js```````", "```````js```````", "```````js`` The arrow function `getter` was born inside `MyClass` (line A), but it can still access the private name `#privateData` after it left its birth scope (line B).    ##### [31.2.5.4 The same private identifier refers to different private names in different classes](#the-same-private-identifier-refers-to-different-private-names-in-different-classes)    Because the identifiers of private slots aren’t used as keys, using the same identifier in different classes produces different slots (line A and line C):    ``` class Color {  #name; // (A)  constructor(name) {  this.#name = name; // (B)  }  static getName(obj) {  return obj.#name;  } } class Person {  #name; // (C)  constructor(name) {  this.#name = name;  } }  `assert.equal(`  `Color.getName(new Color('green')), 'green'` `);`  `` `// We can’t access the private slot #name of a Person in line B:` `assert.throws(`  `() => Color.getName(new Person('Jane')),`  `{`  `name: 'TypeError',`  `message: 'Cannot read private member #name from'`  `+ ' an object whose class did not declare it',`  `}` `);` ``  ```js   ``````js```````", "```````js```````", "```````js```````", "```````js` ``````js```````", "```````js```````", "```````js```````", "```````js ##### [31.2.5.5 The names of private fields never clash](#the-names-of-private-fields-never-clash)    Even if a subclass uses the same name for a private field, the two names never clash because they refer to private names (which are always unique). In the following example, `.#privateField` in `SuperClass` does not clash with `.#privateField` in `SubClass`, even though both slots are stored directly in `inst`:    ``` class SuperClass {  #privateField = 'super';  getSuperPrivateField() {  return this.#privateField;  } } class SubClass extends SuperClass {  #privateField = 'sub';  getSubPrivateField() {  return this.#privateField;  } } const inst = new SubClass(); assert.equal(  inst.getSuperPrivateField(), 'super' ); assert.equal(  inst.getSubPrivateField(), 'sub' );  ```js    [Subclassing via `extends`](#subclassing) is explained later in this chapter.    ##### [31.2.5.6 Using `in` to check if an object has a given private slot](#private-slot-checks)    The `in` operator can be used to check if a private slot exists (line A):    ``` class Color {  #name;  constructor(name) {  this.#name = name;  }  static check(obj) {  return #name in obj; // (A)  } }  ```js    Let’s look at more examples of `in` applied to private slots.    **Private methods.** The following code shows that private methods create private slots in instances:    ``` class C1 {  #priv() {}  static check(obj) {  return #priv in obj;  } } assert.equal(C1.check(new C1()), true);  ```js    **Static private fields.** We can also use `in` for a static private field:    ``` class C2 {  static #priv = 1;  static check(obj) {  return #priv in obj;  } } assert.equal(C2.check(C2), true); assert.equal(C2.check(new C2()), false);  ```js    **Static private methods.** And we can check for the slot of a static private method:    ``` class C3 {  static #priv() {}  static check(obj) {  return #priv in obj;  } } assert.equal(C3.check(C3), true);  ```js    **Using the same private identifier in different classes.** In the next example, the two classes `Color` and `Person` both have a slot whose identifier is `#name`. The `in` operator distinguishes them correctly:    ``` class Color {  #name;  constructor(name) {  this.#name = name;  }  static check(obj) {  return #name in obj;  } } class Person {  #name;  constructor(name) {  this.#name = name;  }  static check(obj) {  return #name in obj;  } }  `// Detecting Color’s #name` `assert.equal(`  `Color.check(new Color()), true` `);` `assert.equal(`  `Color.check(new Person()), false` `);`  `` `// Detecting Person’s #name` `assert.equal(`  `Person.check(new Person()), true` `);` `assert.equal(`  `Person.check(new Color()), false` `);` ``  ```js   ``````js```````", "```````js```````", "```````js```````", "`````` ```js``````", "```````js```````", "```````js```````", "```````js` #### [31.2.6 The pros and cons of classes in JavaScript](#the-pros-and-cons-of-classes-in-javascript)    I recommend using classes for the following reasons:    *   Classes are a common standard for object creation and inheritance that is now widely supported across libraries and frameworks. This is an improvement compared to how things were before, when almost every framework had its own inheritance library.           *   They help tools such as IDEs and type checkers with their work and enable new features there.           *   If you come from another language to JavaScript and are used to classes, then you can get started more quickly.           *   JavaScript engines optimize them. That is, code that uses classes is almost always faster than code that uses a custom inheritance library.           *   We can subclass built-in constructor functions such as `Error`.              That doesn’t mean that classes are perfect:    *   There is a risk of overdoing inheritance.           *   There is a risk of putting too much functionality in classes (when some of it is often better put in functions).           *   Classes look familiar to programmers coming from other languages, but they work differently and are used differently (see next subsection). Therefore, there is a risk of those programmers writing code that doesn’t feel like JavaScript.           *   How classes seem to work superficially is quite different from how they actually work. In other words, there is a disconnect between syntax and semantics. Two examples are:               *   A method definition inside a class `C` creates a method in the object `C.prototype`.     *   Classes are functions.          The motivation for the disconnect is backward compatibility. Thankfully, the disconnect causes few problems in practice; we are usually OK if we go along with what classes pretend to be.              This was a first look at classes. We’ll explore more features soon.    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Writing a class**    `exercises/classes/point_class_test.mjs`    #### [31.2.7 Tips for using classes](#tips-for-using-classes)    *   Use inheritance sparingly – it tends to make code more complicated and spread out related functionality across multiple locations. *   Instead of static members, it is often better to use external functions and variables. We can even make those private to a module, simply by not exporting them. Two important exceptions to this rule are:     *   Operations that need access to private slots     *   [Static factory methods](#static-factory-methods) *   Only put core functionality in prototype methods. Other functionality is better implemented via functions – especially algorithms that involve instances of multiple classes.    ### [31.3 The internals of classes](#internals-of-classes)    #### [31.3.1 A class is actually two connected objects](#a-class-is-actually-two-connected-objects)    Under the hood, a class becomes two connected objects. Let’s revisit class `Person` to see how that works:    ``` class Person {  #firstName;  constructor(firstName) {  this.#firstName = firstName;  }  describe() {  return `Person named ${this.#firstName}`;  }  static extractNames(persons) {  return persons.map(person => person.#firstName);  } }  ```js    The first object created by the class is stored in `Person`. It has four properties:    ``` assert.deepEqual(  Reflect.ownKeys(Person),  ['length', 'name', 'prototype', 'extractNames'] );  `// The number of parameters of the constructor` `assert.equal(`  `Person.length, 1` `);`  `` `// The name of the class` `assert.equal(`  `Person.name, 'Person'` `);` ``  ```js   ``````js```````", "```````js```````", "```````js```````", "```` ```js````", "```js```", "````js````", "```js```", "````js````", "```js```", "``` The two remaining properties are:    *   `Person.extractNames` is the static method that we have already seen in action. *   `Person.prototype` points to the second object that is created by a class definition.    These are the contents of `Person.prototype`:    ```", "```    There are two properties:    *   `Person.prototype.constructor` points to the constructor. *   `Person.prototype.describe` is the method that we have already used.    #### [31.3.2 Classes set up the prototype chains of their instances](#classes-set-up-the-prototype-chains-of-their-instances)    The object `Person.prototype` is the prototype of all instances:    ```", "```   ```", "```````js```````", "```````js```````", "```````js````` That explains how the instances get their methods: They inherit them from the object `Person.prototype`.    [Figure 31.2](#fig:oo_person_class) visualizes how everything is connected.    ![](../Images/96be80cce4461d811881a458537b27cb.png)      Figure 31.2: The class `Person` has the property `.prototype` that points to an object that is the prototype of all instances of `Person`. The objects `jane` and `tarzan` are two such instances.      #### [31.3.3 `.__proto__` vs. `.prototype`](#proto-vs-prototype)    It is easy to confuse `.__proto__` and `.prototype`. Hopefully, [figure 31.2](#fig:oo_person_class) makes it clear how they differ:    *   [`Object.prototype.__proto__`](#Object.prototype.__proto__) is an accessor that most objects inherit that gets and sets the prototype of the receiver. Therefore the following two expressions are equivalent:                    ```js     someObj.__proto__     Object.getPrototypeOf(someObj)          ```                    As are the following two expressions:                    ```js     someObj.__proto__ = anotherObj     Object.setPrototypeOf(someObj, anotherObj)          ```           *   `SomeClass.prototype` holds the object that becomes the prototype of all instances of `SomeClass`. A better name for `.prototype` would be `.instancePrototype`. This property is only special because the `new` operator uses it to set up instances of `SomeClass`.                    ```js     class SomeClass {}     const inst = new SomeClass();     assert.equal(      Object.getPrototypeOf(inst), SomeClass.prototype     );          ```              #### [31.3.4 `Person.prototype.constructor` (advanced)](#personprototypeconstructor-advanced)    There is one detail in [figure 31.2](#fig:oo_person_class) that we haven’t looked at, yet: `Person.prototype.constructor` points back to `Person`:    ```js > Person.prototype.constructor === Person true  ```    This setup exists due to backward compatibility. But it has two additional benefits.    First, each instance of a class inherits property `.constructor`. Therefore, given an instance, we can make “similar” objects via it:    ```js const jane = new Person('Jane');  `const cheeta = new jane.constructor('Cheeta');` `// cheeta is also an instance of Person` `assert.equal(cheeta instanceof Person, true);`  ```   ```js```````", "```````js```````", "```````js```````", "```` Second, we can get the name of the class that created a given instance:    ```js const tarzan = new Person('Tarzan'); assert.equal(tarzan.constructor.name, 'Person');  ```    #### [31.3.5 Dispatched vs. direct method calls (advanced)](#method-calls-dispatched-direct)    In this subsection, we learn about two different ways of invoking methods:    *   Dispatched method calls *   Direct method calls    Understanding both of them will give us important insights into how methods work.    We’ll also need the second way [later](#using-object-methods-safely) in this chapter: It will allow us to borrow useful methods from `Object.prototype`.    ##### [31.3.5.1 Dispatched method calls](#dispatched-method-calls)    Let’s examine how method calls work with classes. We are revisiting `jane` from earlier:    ```js class Person {  #firstName;  constructor(firstName) {  this.#firstName = firstName;  }  describe() {  return 'Person named '+this.#firstName;  } } const jane = new Person('Jane');  ```    [Figure 31.3](#fig:jane_proto_chain) has a diagram with `jane`’s prototype chain.    ![](../Images/75efdfc55284976c46d9812c0dd3353b.png)      Figure 31.3: The prototype chain of `jane` starts with `jane` and continues with `Person.prototype`.      Normal method calls are *dispatched* – the method call    ```js jane.describe()  ```    happens in two steps:    *   Dispatch: JavaScript traverses the prototype chain starting with `jane` to find the first object that has an own property with the key `'describe'`: It first looks at `jane` and doesn’t find an own property `.describe`. It continues with `jane`’s prototype, `Person.prototype` and finds an own property `describe` whose value it returns.                    ```js     const func = jane.describe;          ```           *   Invocation: Method-invoking a value is different from function-invoking a value in that it not only calls what comes before the parentheses with the arguments inside the parentheses but also sets `this` to the receiver of the method call (in this case, `jane`):                    ```js     func.call(jane);          ```              This way of dynamically looking for a method and invoking it is called *dynamic dispatch*.    ##### [31.3.5.2 Direct method calls](#direct-method-calls)    We can also make method calls *directly*, without dispatching:    ```js Person.prototype.describe.call(jane)  ```    This time, we directly point to the method via `Person.prototype.describe` and don’t search for it in the prototype chain. We also specify `this` differently – via `.call()`.    ![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **`this` always points to the instance**    No matter where in the prototype chain of an instance a method is located, `this` always points to the instance (the beginning of the prototype chain). That enables `.describe()` to access `.#firstName` in the example.    When are direct method calls useful? Whenever we want to borrow a method from elsewhere that a given object doesn’t have – for example:    ```js const obj = Object.create(null);  ``// `obj` is not an instance of Object and doesn’t inherit`` `// its prototype method .toString()` `assert.throws(`  `() => obj.toString(),`  `/^TypeError: obj.toString is not a function$/` `);` `assert.equal(`  `Object.prototype.toString.call(obj),`  `'[object Object]'` `);`  ```   ```js````", "```js```", "````js````", "```js```", "````js````", "```js```", "``` function StringBuilderConstr(initialString) {  this.string = initialString; } StringBuilderConstr.prototype.add = function (str) {  this.string += str;  return this; };  `const sb = new StringBuilderConstr('¡');` `sb.add('Hola').add('!');` `assert.equal(`  `sb.string, '¡Hola!'` `);`  ```", "``````js``````", "```````js```````", "```````js`````` Classes provide better syntax for this approach:    ```js class StringBuilderClass {  constructor(initialString) {  this.string = initialString;  }  add(str) {  this.string += str;  return this;  } } const sb = new StringBuilderClass('¡'); sb.add('Hola').add('!'); assert.equal(  sb.string, '¡Hola!' );  ```    Subclassing is especially tricky with constructor functions. Classes also offer benefits that go beyond more convenient syntax:    *   Built-in constructor functions such as `Error` can be subclassed. *   We can access overridden properties via `super`. *   Classes can’t be function-called. *   Methods can’t be `new`-called and don’t have the property `.prototype`. *   Support for private instance data. *   And more.    Classes are so compatible with constructor functions that they can even extend them:    ```js function SuperConstructor() {} class SubClass extends SuperConstructor {}  `assert.equal(`  `new SubClass() instanceof SuperConstructor, true` `);`  ```   ```js```````", "```````js```````", "```````js```````", "``` > StringBuilderClass.prototype.constructor === StringBuilderClass true > typeof StringBuilderClass 'function'  ```", "``` class PublicProtoClass {  constructor(args) {  // (Do something with `args` here.)  }  publicProtoMethod() {  return 'publicProtoMethod';  }  get publicProtoAccessor() {  return 'publicProtoGetter';  }  set publicProtoAccessor(value) {  assert.equal(value, 'publicProtoSetter');  } }  `assert.deepEqual(`  `Reflect.ownKeys(PublicProtoClass.prototype),`  `['constructor', 'publicProtoMethod', 'publicProtoAccessor']` `);`  `` `const inst = new PublicProtoClass('arg1', 'arg2');` `assert.equal(`  `inst.publicProtoMethod(), 'publicProtoMethod'` `);` `assert.equal(`  `inst.publicProtoAccessor, 'publicProtoGetter'` `);` `inst.publicProtoAccessor = 'publicProtoSetter';` ``  ```", "``````js``````", "```````js```````", "```````js```` ```js```````", "```````js```````", "```````js`````` ##### [31.4.1.1 All kinds of public prototype methods and accessors (advanced)](#all-kinds-of-public-prototype-methods-and-accessors-advanced)    ```js const accessorKey = Symbol('accessorKey'); const syncMethodKey = Symbol('syncMethodKey'); const syncGenMethodKey = Symbol('syncGenMethodKey'); const asyncMethodKey = Symbol('asyncMethodKey'); const asyncGenMethodKey = Symbol('asyncGenMethodKey');  `class PublicProtoClass2 {`  `// Identifier keys`  `get accessor() {}`  `set accessor(value) {}`  `syncMethod() {}`  `* syncGeneratorMethod() {}`  `async asyncMethod() {}`  `async * asyncGeneratorMethod() {}`  ```` `// Quoted keys`  `get 'an accessor'() {}`  `set 'an accessor'(value) {}`  `'sync method'() {}`  `* 'sync generator method'() {}`  `async 'async method'() {}`  `async * 'async generator method'() {}`  ```js `// Computed keys`  `get [accessorKey]() {}`  `set [accessorKey](value) {}`  `[syncMethodKey]() {}`  `* [syncGenMethodKey]() {}`  `async [asyncMethodKey]() {}`  `async * [asyncGenMethodKey]() {}` `}`  `` `// Quoted and computed keys are accessed via square brackets:` `const inst = new PublicProtoClass2();` `inst['sync method']();` `inst[syncMethodKey]();` `` ``` ```js`  ```   ```js```````", "```````js```````", "```````js````` ```js```````", "```````js```````", "```````js```` Quoted and computed keys can also be used in object literals:    *   [“Quoted keys in object literals” (§30.9.1)](ch_objects.html#object-literals-quoted-keys) *   [“Computed keys in object literals” (§30.9.2)](ch_objects.html#object-literals-computed-keys)    More information on accessors (defined via getters and/or setters), generators, async methods, and async generator methods:    *   [“Object literals: accessors” (§30.3.6)](ch_objects.html#object-literal-accessors) *   [“Synchronous generators ^(ES6) (advanced)” (§33)](ch_sync-generators.html#ch_sync-generators) *   [“Async functions ^(ES2017)” (§44)](ch_async-functions.html#ch_async-functions) *   [“Asynchronous generators” (§45.2)](ch_async-iteration.html#async-generators)    #### [31.4.2 Private methods and accessors ^(ES2022)](#private-methods-accessors)    Private methods (and accessors) are an interesting mix of prototype members and instance members.    On one hand, private methods are stored in slots in instances (line A):    ```js class MyClass {  #privateMethod() {}  static check() {  const inst = new MyClass();  assert.equal(  #privateMethod in inst, true // (A)  );  assert.equal(  #privateMethod in MyClass.prototype, false  );  assert.equal(  #privateMethod in MyClass, false  );  } } MyClass.check();  ```    Why are they not stored in `.prototype` objects? Private slots are not inherited, only properties are.    On the other hand, private methods are shared between instances – like prototype public methods:    ```js class MyClass {  #privateMethod() {}  static check() {  const inst1 = new MyClass();  const inst2 = new MyClass();  assert.equal(  inst1.#privateMethod,  inst2.#privateMethod  );  } }  ```    Due to that and due to their syntax being similar to prototype public methods, they are covered here.    The following code demonstrates how private methods and accessors work:    ```js class PrivateMethodClass {  #privateMethod() {  return 'privateMethod';  }  get #privateAccessor() {  return 'privateGetter';  }  set #privateAccessor(value) {  assert.equal(value, 'privateSetter');  }  callPrivateMembers() {  assert.equal(this.#privateMethod(), 'privateMethod');  assert.equal(this.#privateAccessor, 'privateGetter');  this.#privateAccessor = 'privateSetter';  } } assert.deepEqual(  Reflect.ownKeys(new PrivateMethodClass()), [] );  ```    ##### [31.4.2.1 All kinds of private methods and accessors (advanced)](#all-kinds-of-private-methods-and-accessors-advanced)    With private slots, the keys are always identifiers:    ```js class PrivateMethodClass2 {  get #accessor() {}  set #accessor(value) {}  #syncMethod() {}  * #syncGeneratorMethod() {}  async #asyncMethod() {}  async * #asyncGeneratorMethod() {} }  ```    More information on accessors (defined via getters and/or setters), generators, async methods, and async generator methods:    *   [“Object literals: accessors” (§30.3.6)](ch_objects.html#object-literal-accessors) *   [“Synchronous generators ^(ES6) (advanced)” (§33)](ch_sync-generators.html#ch_sync-generators) *   [“Async functions ^(ES2017)” (§44)](ch_async-functions.html#ch_async-functions) *   [“Asynchronous generators” (§45.2)](ch_async-iteration.html#async-generators)    ### [31.5 Instance members of classes ^(ES2022)](#instance-members-of-classes-es2022)    #### [31.5.1 Instance public fields](#instance-public-fields)    Instances of the following class have two instance properties (created in line A and line B):    ```js class InstPublicClass {  // Instance public field  instancePublicField = 0; // (A)  `constructor(value) {`  `// We don’t need to mention .property elsewhere!`  `this.property = value; // (B)`  `}` `}`  `` `const inst = new InstPublicClass('constrArg');` `assert.deepEqual(`  `Reflect.ownKeys(inst),`  `['instancePublicField', 'property']` `);` `assert.equal(`  `inst.instancePublicField, 0` `);` `assert.equal(`  `inst.property, 'constrArg'` `);` ``  ```   ```js```````", "```````js```````", "```````js``` ``````js```````", "```````js```````", "`````` If we create an instance property inside the constructor (line B), we don’t need to “declare” it elsewhere. As we have already seen, that is different for instance private fields.    Note that instance properties are relatively common in JavaScript; much more so than in, e.g., Java, where most instance state is private.    ##### [31.5.1.1 Instance public fields with quoted and computed keys (advanced)](#instance-public-fields-quoted-keys-computed-keys)    ```js const computedFieldKey = Symbol('computedFieldKey'); class InstPublicClass2 {  'quoted field key' = 1;  [computedFieldKey] = 2; } const inst = new InstPublicClass2(); assert.equal(inst['quoted field key'], 1); assert.equal(inst[computedFieldKey], 2);  ```    ##### [31.5.1.2 What is the value of `this` in instance public fields? (advanced)](#what-is-the-value-of-this-in-instance-public-fields-advanced)    In the initializer of a instance public field, `this` refers to the newly created instance:    ```js class MyClass {  instancePublicField = this; } const inst = new MyClass(); assert.equal(  inst.instancePublicField, inst );  ```    ##### [31.5.1.3 When are instance public fields executed? (advanced)](#when-are-instance-public-fields-executed-advanced)    The execution of instance public fields roughly follows these two rules:    *   In base classes (classes without superclasses), instance public fields are executed immediately before the constructor. *   In derived classes (classes with superclasses):     *   The superclass sets up its instance slots when `super()` is called.     *   Instance public fields are executed immediately after `super()`.    The following example demonstrates these rules:    ```js class SuperClass {  superProp = console.log('superProp');  constructor() {  console.log('super-constructor');  } } class SubClass extends SuperClass {  subProp = console.log('subProp');  constructor() {  console.log('BEFORE super()');  super();  console.log('AFTER super()');  } } new SubClass();  ```    Output:    ```js BEFORE super() superProp super-constructor subProp AFTER super()  ```    `extends` and subclassing are explained [later in this chapter](#subclassing).    #### [31.5.2 Instance private fields](#instance-private-fields)    The following class contains two instance private fields (line A and line B):    ```js class InstPrivateClass {  #privateField1 = 'private field 1'; // (A)  #privateField2; // (B) required!  constructor(value) {  this.#privateField2 = value; // (C)  }  /**  * Private fields are not accessible outside the class body.  */  checkPrivateValues() {  assert.equal(  this.#privateField1, 'private field 1'  );  assert.equal(  this.#privateField2, 'constructor argument'  );  } }  `const inst = new InstPrivateClass('constructor argument');`  `inst.checkPrivateValues();`  `` `// No instance properties were created` `assert.deepEqual(`  `Reflect.ownKeys(inst),`  `[]` `);` ``  ```   ```js``````", "```````js```````", "```````js` ``````js```````", "```````js```````", "```` Note that we can only use `.#privateField2` in line C if we declare it in the class body.    #### [31.5.3 Private instance data before ES2022 (advanced)](#private-instance-data-before-es2022-advanced)    In this section, we look at two techniques for keeping instance data private. Because they don’t rely on classes, we can also use them for objects that were created in other ways – e.g., via object literals.    ##### [31.5.3.1 Before ES6: private members via naming conventions](#before-es6-private-members-via-naming-conventions)    The first technique makes a property private by prefixing its name with an underscore. This doesn’t protect the property in any way; it merely signals to the outside: “You don’t need to know about this property.”    In the following code, the properties `._counter` and `._action` are private.    ```js class Countdown {  constructor(counter, action) {  this._counter = counter;  this._action = action;  }  dec() {  this._counter--;  if (this._counter === 0) {  this._action();  }  } }  `// The two properties aren’t really private:` `assert.deepEqual(`  `Object.keys(new Countdown()),`  `['_counter', '_action']);`  ```   ```js````", "```js```", "````js````", "```js```", "``` With this technique, we don’t get any protection and private names can clash. On the plus side, it is easy to use.    Private methods work similarly: They are normal methods whose names start with underscores.    ##### [31.5.3.2 ES6 and later: private instance data via WeakMaps](#es6-and-later-private-instance-data-via-weakmaps)    We can also manage private instance data via WeakMaps:    ```", "```   ```", "```````js```````", "```````js````` ```js```````", "```````js```````", "```` How exactly that works is explained [in the chapter on WeakMaps](ch_weakmaps.html#private-data-in-weakmaps).    This technique offers us considerable protection from outside access and there can’t be any name clashes. But it is also more complicated to use.    We control the visibility of the pseudo-property `_superProp` by controlling who has access to it – for example: If the variable exists inside a module and isn’t exported, everyone inside the module and no one outside the module can access it. In other words: The scope of privacy isn’t the class in this case, it’s the module. We could narrow the scope, though:    ```js let Countdown; { // class scope  const _counter = new WeakMap();  const _action = new WeakMap();  `Countdown = class {`  `// ···`  `}` `}`  ```   ```js````", "```js```", "````js````", "```js```", "``` const _counter = new WeakMap(); const _action = new WeakMap();  `class Countdown {`  `constructor(counter, action) {`  `_counter.set(this, counter);`  `_action.set(this, action);`  `}`  `dec() {`  `privateDec(this);`  `}` `}`  `` `function privateDec(_this) { // (A)`  `let counter = _counter.get(_this);`  `counter--;`  `_counter.set(_this, counter);`  `if (counter === 0) {`  `_action.get(_this)();`  `}` `}` ``  ```", "``````js``````", "```````js`````` ```js```````", "```````js```````", "``` const _superProp = new WeakMap(); class SuperClass {  constructor() {  _superProp.set(this, 'superProp');  } } class SubClass extends SuperClass {  getSuperProp() {  return _superProp.get(this);  } } assert.equal(  new SubClass().getSuperProp(),  'superProp' );  ```", "``` class StaticPublicMethodsClass {  static staticMethod() {  return 'staticMethod';  }  static get staticAccessor() {  return 'staticGetter';  }  static set staticAccessor(value) {  assert.equal(value, 'staticSetter');  } } assert.equal(  StaticPublicMethodsClass.staticMethod(), 'staticMethod' ); assert.equal(  StaticPublicMethodsClass.staticAccessor, 'staticGetter' ); StaticPublicMethodsClass.staticAccessor = 'staticSetter';  ```", "``` const accessorKey = Symbol('accessorKey'); const syncMethodKey = Symbol('syncMethodKey'); const syncGenMethodKey = Symbol('syncGenMethodKey'); const asyncMethodKey = Symbol('asyncMethodKey'); const asyncGenMethodKey = Symbol('asyncGenMethodKey');  `class StaticPublicMethodsClass2 {`  `// Identifier keys`  `static get accessor() {}`  `static set accessor(value) {}`  `static syncMethod() {}`  `static * syncGeneratorMethod() {}`  `static async asyncMethod() {}`  `static async * asyncGeneratorMethod() {}`  ```", "``` `// Computed keys`  `static get [accessorKey]() {}`  `static set [accessorKey](value) {}`  `static [syncMethodKey]() {}`  `static * [syncGenMethodKey]() {}`  `static async [asyncMethodKey]() {}`  `static async * [asyncGenMethodKey]() {}` `}`  `` `// Quoted and computed keys are accessed via square brackets:` `StaticPublicMethodsClass2['sync method']();` `StaticPublicMethodsClass2[syncMethodKey]();` `` ```", "````  ```js   ````", "```````js```````", "```` ```js````", "```js```", "````js````", "```js const computedFieldKey = Symbol('computedFieldKey'); class StaticPublicFieldClass {  static identifierFieldKey = 1;  static 'quoted field key' = 2;  static [computedFieldKey] = 3; }  `assert.deepEqual(`  `Reflect.ownKeys(StaticPublicFieldClass),`  `[`  `'length', // number of constructor parameters`  `'name', // 'StaticPublicFieldClass'`  `'prototype',`  `'identifierFieldKey',`  `'quoted field key',`  `computedFieldKey,`  `],` `);`  `` `assert.equal(StaticPublicFieldClass.identifierFieldKey, 1);` `assert.equal(StaticPublicFieldClass['quoted field key'], 2);` `assert.equal(StaticPublicFieldClass[computedFieldKey], 3);` ``  ```", "```js```", "````js````", "```js```", "```js```", "````js````", "```js```", "```js class StaticPrivateClass {  // Declare and initialize  static #staticPrivateField = 'hello'; // (A)  static #twice() { // (B)  const str = StaticPrivateClass.#staticPrivateField;  return str + ' ' + str;  }  static getResultOfTwice() {  return StaticPrivateClass.#twice();  } }  `assert.deepEqual(`  `Reflect.ownKeys(StaticPrivateClass),`  `[`  `'length', // number of constructor parameters`  `'name', // 'StaticPublicFieldClass'`  `'prototype',`  `'getResultOfTwice',`  `],` `);`  `` `assert.equal(`  `StaticPrivateClass.getResultOfTwice(),`  `'hello hello'` `);` ``  ```", "```js```", "````js````", "```js```", "``````js``````", "`````` This is a complete list of all kinds of static private slots:    ```js class MyClass {  static #staticPrivateMethod() {}  static * #staticPrivateGeneratorMethod() {}  `static async #staticPrivateAsyncMethod() {}`  `static async * #staticPrivateAsyncGeneratorMethod() {}`   `static get #staticPrivateAccessor() {}`  `static set #staticPrivateAccessor(value) {}` `}`  ```   ```js``````", "```````js` #### [31.6.4 Static initialization blocks in classes ^(ES2022)](#class-static-initialization-blocks)    To set up instance data via classes, we have two constructs:    *   *Fields*, to create and optionally initialize instance data *   *Constructors*, blocks of code that are executed every time a new instance is created    For static data, we have:    *   *Static fields* *   *Static blocks* that are executed when a class is created    The following code demonstrates static blocks (line A):    ``` class Translator {  static translations = {  yes: 'ja',  no: 'nein',  maybe: 'vielleicht',  };  static englishWords = [];  static germanWords = [];  static { // (A)  for (const [english, german] of Object.entries(this.translations)) {  this.englishWords.push(english);  this.germanWords.push(german);  }  } }  ```js    We could also execute the code inside the static block after the class (at the top level). However, using a static block has two benefits:    *   All class-related code is inside the class. *   The code in a static block has access to private slots.    ##### [31.6.4.1 Rules for static initialization blocks](#rules-for-static-initialization-blocks)    The rules for how static initialization blocks work, are relatively simple:    *   There can be more than one static block per class. *   The execution of static blocks is interleaved with the execution of static field initializers. *   The static members of a superclass are executed before the static members of a subclass.    The following code demonstrates these rules:    ``` class SuperClass {  static superField1 = console.log('superField1');  static {  assert.equal(this, SuperClass);  console.log('static block 1 SuperClass');  }  static superField2 = console.log('superField2');  static {  console.log('static block 2 SuperClass');  } }  `class SubClass extends SuperClass {`  `static subField1 = console.log('subField1');`  `static {`  `assert.equal(this, SubClass);`  `console.log('static block 1 SubClass');`  `}`  `static subField2 = console.log('subField2');`  `static {`  `console.log('static block 2 SubClass');`  `}` `}`  ```js   ``````js```````", "```` Output:    ```js superField1 static block 1 SuperClass superField2 static block 2 SuperClass subField1 static block 1 SubClass subField2 static block 2 SubClass  ```    [Subclassing via `extends`](#subclassing) is explained later in this chapter.    #### [31.6.5 Pitfall: Using `this` to access static private fields](#this-and-static-private-fields)    In static public members, we can access static public slots via `this`. Alas, we should not use it to access static private slots.    ##### [31.6.5.1 `this` and static public fields](#this-and-static-public-fields)    Consider the following code:    ```js class SuperClass {  static publicData = 1;   static getPublicViaThis() {  return this.publicData;  } } class SubClass extends SuperClass { }  ```    [Subclassing via `extends`](#subclassing) is explained later in this chapter.    Static public fields are properties. If we make the method call    ```js assert.equal(SuperClass.getPublicViaThis(), 1);  ```    then `this` points to `SuperClass` and everything works as expected. We can also invoke `.getPublicViaThis()` via the subclass:    ```js assert.equal(SubClass.getPublicViaThis(), 1);  ```    `SubClass` inherits `.getPublicViaThis()` from its prototype `SuperClass`. `this` points to `SubClass` and things continue to work, because `SubClass` also inherits the property `.publicData`.    As an aside, if we assigned to `this.publicData` in `getPublicViaThis()` and invoked it via `SubClass.getPublicViaThis()`, then we would create a new own poperty of `SubClass` that (non-destructively) overrides the property inherited from `SuperClass`.    ##### [31.6.5.2 `this` and static private fields](#this-and-static-private-fields-1)    Consider the following code:    ```js class SuperClass {  static #privateData = 2;  static getPrivateDataViaThis() {  return this.#privateData;  }  static getPrivateDataViaClassName() {  return SuperClass.#privateData;  } } class SubClass extends SuperClass { }  ```    Invoking `.getPrivateDataViaThis()` via `SuperClass` works, because `this` points to `SuperClass`:    ```js assert.equal(SuperClass.getPrivateDataViaThis(), 2);  ```    However, invoking `.getPrivateDataViaThis()` via `SubClass` does not work, because `this` now points to `SubClass` and `SubClass` has no static private field `.#privateData` (private slots in prototype chains are not inherited):    ```js assert.throws(  () => SubClass.getPrivateDataViaThis(),  {  name: 'TypeError',  message: 'Cannot read private member #privateData from'  + ' an object whose class did not declare it',  } );  ```    The workaround is to accesss `.#privateData` directly, via `SuperClass`:    ```js assert.equal(SubClass.getPrivateDataViaClassName(), 2);  ```    With static private methods, we are facing the same issue.    #### [31.6.6 All members (static, prototype, instance) can access all private members](#all-members-static-prototype-instance-can-access-all-private-members)    Every member inside a class can access all other members inside that class – both public and private ones:    ```js class DemoClass {  static #staticPrivateField = 1;  #instPrivField = 2;  `static staticMethod(inst) {`  `// A static method can access static private fields`  `// and instance private fields`  `assert.equal(DemoClass.#staticPrivateField, 1);`  `assert.equal(inst.#instPrivField, 2);`  `}`  `` `protoMethod() {`  `// A prototype method can access instance private fields`  `// and static private fields`  `assert.equal(this.#instPrivField, 2);`  `assert.equal(DemoClass.#staticPrivateField, 1);`  `}` `}` ``  ```   ```js````", "```js```", "``` ```", "```````js````` In contrast, no one outside can access the private members:    ```js // Accessing private fields outside their classes triggers // syntax errors (before the code is even executed). assert.throws(  () => eval('DemoClass.#staticPrivateField'),  {  name: 'SyntaxError',  message: \"Private field '#staticPrivateField' must\"  + \" be declared in an enclosing class\",  } ); // Accessing private fields outside their classes triggers // syntax errors (before the code is even executed). assert.throws(  () => eval('new DemoClass().#instPrivField'),  {  name: 'SyntaxError',  message: \"Private field '#instPrivField' must\"  + \" be declared in an enclosing class\",  } );  ```    #### [31.6.7 Static private methods and data before ES2022](#static-private-methods-and-data-before-es2022)    The following code only works in ES2022 – due to every line that has a hash symbol (`#`) in it:    ```js export class StaticClass {  static #secret = 'Rumpelstiltskin';  static #getSecretInParens() {  return `(${StaticClass.#secret})`;  }  static callStaticPrivateMethod() {  return StaticClass.#getSecretInParens();  } }  ```    Since private slots only exist once per class, we can move `.#secret` and `.#getSecretInParens` to the scope surrounding the class and use a module to hide them from the world outside the module:    *   `.#secret` becomes a top-level variable in the module. *   `.getSecretInParens()` becomes a top-level function in the module.    The result looks as follows:    ```js const secret = 'Rumpelstiltskin'; function getSecretInParens() {  return `(${secret})`; }  `// Only the class is accessible outside the module` `export class StaticClass {`  `static callStaticPrivateMethod() {`  `return getSecretInParens();`  `}` `}`  ```   ```js```````", "```` #### [31.6.8 Static factory methods](#static-factory-methods)    Sometimes there are multiple ways in which a class can be instantiated. Then we can implement *static factory methods* such as `Point.fromPolar()`:    ```js class Point {  static fromPolar(radius, angle) {  const x = radius * Math.cos(angle);  const y = radius * Math.sin(angle);  return new Point(x, y);  }  constructor(x=0, y=0) {  this.x = x;  this.y = y;  } }  `assert.deepEqual(`  `Point.fromPolar(13, 0.39479111969976155),`  `new Point(12, 5)` `);`  ```   ```js````", "```js```", "``` // Only accessible inside the current module const secretToken = Symbol('secretToken'); // (A)  `export class Point {`  `static create(x=0, y=0) {`  `return new Point(secretToken, x, y);`  `}`  `static fromPolar(radius, angle) {`  `const x = radius * Math.cos(angle);`  `const y = radius * Math.sin(angle);`  `return new Point(secretToken, x, y);`  `}`  `constructor(token, x, y) {`  `if (token !== secretToken) {`  `throw new TypeError('Must use static factory method');`  `}`  `this.x = x;`  `this.y = y;`  `}` `}` `Point.create(3, 4); // OK` `assert.throws(`  `() => new Point(3, 4),`  `TypeError` `);`  ```", "``````js``````", "```js class Person {  #firstName;  constructor(firstName) {  this.#firstName = firstName;  }  describe() {  return `Person named ${this.#firstName}`;  }  static extractNames(persons) {  return persons.map(person => person.#firstName);  } }  `class Employee extends Person {`  `constructor(firstName, title) {`  `super(firstName);`  `this.title = title;`  `}`  `describe() {`  `return super.describe() +`  `` ` (${this.title})`; ``  `}` `}`  `` `const jane = new Employee('Jane', 'CTO');` `assert.equal(`  `jane.title,`  `'CTO'` `);` `assert.equal(`  `jane.describe(),`  `'Person named Jane (CTO)'` `);` ``  ```", "```js```", "````js` ````", "```` Terminology related to extending:    *   Another word for *extending* is *subclassing*. *   `Person` is the superclass of `Employee`. *   `Employee` is the subclass of `Person`. *   A *base class* is a class that has no superclasses. *   A *derived class* is a class that has a superclass.    Inside the `.constructor()` of a derived class, we must call the super-constructor via `super()` before we can access `this`. Why is that?    Let’s consider a chain of classes:    *   Base class `A` *   Class `B` extends `A`. *   Class `C` extends `B`.    If we invoke `new C()`, `C`’s constructor super-calls `B`’s constructor which super-calls `A`’s constructor. Instances are always created in base classes, before the constructors of subclasses add their slots. Therefore, the instance doesn’t exist before we call `super()` and we can’t access it via `this`, yet.    Note that static public slots are inherited. For example, `Employee` inherits the static method `.extractNames()`:    ```js > 'extractNames' in Employee true  ```    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Subclassing**    `exercises/classes/color_point_class_test.mjs`    #### [31.7.2 The internals of subclassing (advanced)](#internals-of-subclassing)    ![](../Images/9e9cfd8d183a6ecd074a55a7eb578773.png)      Figure 31.4: These are the objects that make up class `Person` and its subclass, `Employee`. The left column is about classes. The right column is about the `Employee` instance `jane` and its prototype chain.      The classes `Person` and `Employee` from the previous section are made up of several objects ([figure 31.4](#fig:oo_subclassing)). One key insight for understanding how these objects are related is that there are two prototype chains:    *   The instance prototype chain, on the right. *   The class prototype chain, on the left.    Each class contributes a prototype to the instance prototype chain but is also in its own chain of prototypes.    ##### [31.7.2.1 The instance prototype chain (right column)](#the-instance-prototype-chain-right-column)    The instance prototype chain starts with `jane` and continues with `Employee.prototype` and `Person.prototype`. In principle, the prototype chain ends at this point, but we get one more object:    ```js > Object.getPrototypeOf(Person.prototype) === Object.prototype true  ```    `Object.prototype` provides services to virtually all objects, which is why it is included here, too. The prototype of `Object.prototype` is `null`:    ```js > Object.getPrototypeOf(Object.prototype) null  ```    ##### [31.7.2.2 The class prototype chain (left column)](#the-class-prototype-chain-left-column)    In the class prototype chain, `Employee` comes first, `Person` next. In principle, the prototype chain ends at this point, but `Person` does have a prototype:    ```js > Object.getPrototypeOf(Person) === Function.prototype true  ```    `Person` only has this prototype because it’s a function and `Function.prototype` is the prototype of all functions. (As an aside, the prototype of `Function.prototype` is `Object.prototype`.)    #### [31.7.3 The `instanceof` operator in detail (advanced)](#instanceof-operator-details)    We have not yet learned how `instanceof` really works: How does `instanceof` determine if a value `x` is an instance of a class `C`? Note that “instance of `C`” means direct instance of `C` or direct instance of a subclass of `C`.    `instanceof` checks if `C.prototype` is in the prototype chain of `x`. That is, the following two expressions are equivalent:    ```js x instanceof C C.prototype.isPrototypeOf(x)  ```    If we go back to [figure 31.4](#fig:oo_subclassing), we can confirm that the prototype chain does lead us to the following correct answers:    ```js > jane instanceof Employee true > jane instanceof Person true > jane instanceof Object true  ```    Note that `instanceof` always returns `false` if its self-hand side is a primitive value:    ```js > 'abc' instanceof String false > 123 instanceof Number false  ```    #### [31.7.4 Not all objects are instances of `Object` (advanced)](#non-instances-of-object)    An object (a non-primitive value) is only an instance of `Object` if `Object.prototype` is in its prototype chain [(see previous subsection)](#instanceof-operator-details). Virtually all objects are instances of `Object` – for example:    ```js assert.equal(  {a: 1} instanceof Object, true ); assert.equal(  ['a'] instanceof Object, true ); assert.equal(  /abc/g instanceof Object, true ); assert.equal(  new Map() instanceof Object, true );  `class C {}` `assert.equal(`  `new C() instanceof Object, true` `);`  ```   ```js````", "```js const obj1 = {__proto__: null}; assert.equal(  typeof obj1, 'object' // (A) ); assert.equal(  obj1 instanceof Object, false // (B) );  `const obj2 = Object.create(null);` `assert.equal(`  `typeof obj2, 'object' // (C)` `);` `assert.equal(`  `obj2 instanceof Object, false // (D)` `);`  ```", "```js```", "```js > typeof Object.prototype 'object' > Object.getPrototypeOf(Object.prototype) null > Object.prototype instanceof Object false  ```", "```js class DerivedClass extends Object {} const derivedInstance = new DerivedClass();  ```", "```js class BaseClass {} const baseInstance = new BaseClass();  ```", "```js const p = Object.getPrototypeOf.bind(Object);  ```", "```js > const p = Object.getPrototypeOf.bind(Object); > p({}) === Object.prototype true > p(p({})) null  ```", "```js > const p = Object.getPrototypeOf.bind(Object); > p([]) === Array.prototype true > p(p([])) === Object.prototype true > p(p(p([]))) === null true  ```", "```js > Object.getPrototypeOf(Array) === Function.prototype true  ```", "```js > Object.getPrototypeOf(() => {}) === Function.prototype true  ```", "```js > const p = Object.getPrototypeOf.bind(Object); > p(() => {}) === Function.prototype true > p(p(() => {})) === Object.prototype true > p(p(p(() => {}))) null  ```", "```js const S1 = (Sup) => class extends Sup { /*···*/ }; const S2 = (Sup) => class extends Sup { /*···*/ };  ```", "```js class C extends S2(S1(Object)) {  /*···*/ }  ```", "```js const Named = (Sup) => class extends Sup {  name = '(Unnamed)';  toString() {  const className = this.constructor.name;  return `${className} named ${this.name}`;  } };  ```", "```js class City extends Named(Object) {  constructor(name) {  super();  this.name = name;  } }  ```", "```js const paris = new City('Paris'); assert.equal(  paris.name, 'Paris' ); assert.equal(  paris.toString(), 'City named Paris' );  ```", "```js > {ownProp: true}.hasOwnProperty('ownProp') true > {ownProp: true}.hasOwnProperty('abc') false  ```", "```js const obj = Object.create(null); assert.equal(obj instanceof Object, false); assert.throws(  () => obj.hasOwnProperty('prop'),  {  name: 'TypeError',  message: 'obj.hasOwnProperty is not a function',  } );  ```", "```js const obj = {  hasOwnProperty: 'yes' // (A) }; assert.throws(  () => obj.hasOwnProperty('prop'),  {  name: 'TypeError',  message: 'obj.hasOwnProperty is not a function',  } );  ```", "```js function hasOwnProp(obj, propName) {  return Object.prototype.hasOwnProperty.call(obj, propName); // (A) } assert.equal(  hasOwnProp(Object.create(null), 'prop'), false ); assert.equal(  hasOwnProp({hasOwnProperty: 'yes'}, 'prop'), false ); assert.equal(  hasOwnProp({hasOwnProperty: 'yes'}, 'hasOwnProperty'), true );  ```", "```js const hasOwnProp = Function.prototype.call  .bind(Object.prototype.hasOwnProperty);  ```", "```js > String({toString() { return 'Hello!' }}) 'Hello!' > String({}) '[object Object]'  ```", "```js > undefined.toString() TypeError: Cannot read properties of undefined (reading 'toString') > null.toString() TypeError: Cannot read properties of null (reading 'toString') > String(undefined) 'undefined' > String(null) 'null'  ```", "```js     > 123.45.toLocaleString('en') // English     '123.45'     > 123.45.toLocaleString('fr') // French     '123,45'          ```", "```js     > [1.25, 3].toLocaleString('en') // English     '1.25,3'     > [1.25, 3].toLocaleString('fr') // French     '1,25,3'          ```", "```js assert.equal(  17.50.toLocaleString('en', {  style: 'currency',  currency: 'USD',  }),  '$17.50' ); assert.equal(  17.50.toLocaleString('fr', {  style: 'currency',  currency: 'USD',  }),  '17,50 $US' ); assert.equal(  17.50.toLocaleString('de', {  style: 'currency',  currency: 'USD',  }),  '17,50 $' );  `assert.equal(`  `17.50.toLocaleString('en', {`  `style: 'currency',`  `currency: 'EUR',`  `}),`  `'€17.50'` `);`  ```", "```js```", "```js > Number({valueOf() { return 123 }}) 123 > Number({}) NaN  ```", "```js const a = {}; const b = {__proto__: a}; const c = {__proto__: b};  `assert.equal(a.isPrototypeOf(b), true);` `assert.equal(a.isPrototypeOf(c), true);`  `` `assert.equal(a.isPrototypeOf(a), false);` `assert.equal(c.isPrototypeOf(a), false);` ``  ```", "```js```", "````` This is how to use this method safely (for details see [“Using `Object.prototype` methods safely” (§31.9.1)](#using-object-methods-safely)):    ```js const obj = {  // Overrides Object.prototype.isPrototypeOf  isPrototypeOf: true, }; // Doesn’t work in this case: assert.throws(  () => obj.isPrototypeOf(Object.prototype),  {  name: 'TypeError',  message: 'obj.isPrototypeOf is not a function',  } ); // Safe way of using .isPrototypeOf(): assert.equal(  Object.prototype.isPrototypeOf.call(obj, Object.prototype), false );  ```    An object is an instance of a class `C` if `C.prototype` is in its chain of prototypes:    ```js function isInstanceOf(obj, aClass) {  return {}.isPrototypeOf.call(aClass.prototype, obj); } assert.equal(  isInstanceOf([], Object), true ); assert.equal(  isInstanceOf([], Array), true ); assert.equal(  isInstanceOf(/x/, Array), false );  ```    #### [31.9.6 `Object.prototype.propertyIsEnumerable()` ^(ES3)](#Object.prototype.propertyIsEnumerable)    `obj.propertyIsEnumerable(propKey)` returns `true` if `obj` has an own enumerable property whose key is `propKey` and `false` otherwise.    ```js const proto = {  enumerableProtoProp: true, }; const obj = {  __proto__: proto,  enumerableObjProp: true,  nonEnumObjProp: true, }; Object.defineProperty(  obj, 'nonEnumObjProp',  {  enumerable: false,  } );  `assert.equal(`  `obj.propertyIsEnumerable('enumerableProtoProp'),`  `false // not an own property` `);` `assert.equal(`  `obj.propertyIsEnumerable('enumerableObjProp'),`  `true` `);` `assert.equal(`  `obj.propertyIsEnumerable('nonEnumObjProp'),`  `false // not enumerable` `);` `assert.equal(`  `obj.propertyIsEnumerable('unknownProp'),`  `false // not a property` `);`  ```   ```js`This is how to use this method safely (for details see [“Using `Object.prototype` methods safely” (§31.9.1)](#using-object-methods-safely)):    ``` const obj = {  // Overrides Object.prototype.propertyIsEnumerable  propertyIsEnumerable: true,  enumerableProp: 'yes', }; // Doesn’t work in this case: assert.throws(  () => obj.propertyIsEnumerable('enumerableProp'),  {  name: 'TypeError',  message: 'obj.propertyIsEnumerable is not a function',  } ); // Safe way of using .propertyIsEnumerable(): assert.equal(  Object.prototype.propertyIsEnumerable.call(obj, 'enumerableProp'),  true );  ```js    Another safe alternative is to use [property descriptors](ch_objects.html#property-attributes-property-descriptors):    ``` assert.deepEqual(  Object.getOwnPropertyDescriptor(obj, 'enumerableProp'),  {  value: 'yes',  writable: true,  enumerable: true,  configurable: true,  } );  ```js    #### [31.9.7 `Object.prototype.__proto__` (accessor) ^(ES6)](#Object.prototype.__proto__)    Property `__proto__` exists in two versions:    *   An accessor that all instances of `Object` have. *   A property of object literals that sets the prototypes of the objects created by them.    I recommend to avoid the former feature:    *   As explained in [“Using `Object.prototype` methods safely” (§31.9.1)](#using-object-methods-safely), it doesn’t work with all objects. *   The ECMAScript specification has deprecated it and calls it [“optional” and “legacy”](https://tc39.es/ecma262/#sec-object.prototype.__proto__).    In contrast, `__proto__` in object literals always works and is not deprecated.    Read on if you are interested in how the accessor `__proto__` works.    `__proto__` is an accessor of `Object.prototype` that is inherited by all instances of `Object`. Implementing it via a class would look like this:    ``` class Object {  get __proto__() {  return Object.getPrototypeOf(this);  }  set __proto__(other) {  Object.setPrototypeOf(this, other);  }  // ··· }  ```js    Since `__proto__` is inherited from `Object.prototype`, we can remove this feature by creating an object that doesn’t have `Object.prototype` in its prototype chain (see [“Not all objects are instances of `Object` (advanced)” (§31.7.4)](#non-instances-of-object)):    ``` > '__proto__' in {} true > '__proto__' in Object.create(null) false  ```js    #### [31.9.8 `Object.prototype.hasOwnProperty()` ^(ES3)](#Object.prototype.hasOwnProperty)    ![Icon “warning”](../Images/5aa4bf88dc66ecb2bac6be4022a1fed4.png) **Better alternative to `.hasOwnProperty()`: `Object.hasOwn()` ^(ES2022)**    See [“`Object.hasOwn()`: Is a given property own (non-inherited)? ^(ES2022)” (§30.8.4)](ch_objects.html#Object.hasOwn).    `obj.hasOwnProperty(propKey)` returns `true` if `obj` has an own (non-inherited) property whose key is `propKey` and `false` otherwise.    ``` const obj = { ownProp: true }; assert.equal(  obj.hasOwnProperty('ownProp'), true // own ); assert.equal(  'toString' in obj, true // inherited ); assert.equal(  obj.hasOwnProperty('toString'), false );  ```js    This is how to use this method safely (for details see [“Using `Object.prototype` methods safely” (§31.9.1)](#using-object-methods-safely)):    ``` const obj = {  // Overrides Object.prototype.hasOwnProperty  hasOwnProperty: true, }; // Doesn’t work in this case: assert.throws(  () => obj.hasOwnProperty('anyPropKey'),  {  name: 'TypeError',  message: 'obj.hasOwnProperty is not a function',  } ); // Safe way of using .hasOwnProperty(): assert.equal(  Object.prototype.hasOwnProperty.call(obj, 'anyPropKey'), false );  ```js    ### [31.10 Quick reference: `Object.prototype.*`](#quickref-object-prototype)    #### [31.10.1 `Object.prototype.*`: configuring how objects are converted to primitive values](#objectprototype-configuring-how-objects-are-converted-to-primitive-values)    The following methods have default implementations but are often overridden in subclasses or instances. They determine how objects are converted to primitive values (e.g. by the `+` operator).    *   `Object.prototype.toString()` ES1                    Configures how an object is converted to a string.                    ```     > 'Object: ' + {toString() {return 'Hello!'}}     'Object: Hello!'          ```js                    [More information](#Object.prototype.toString).           *   `Object.prototype.toLocaleString()` ES3                    A version of `.toString()` that can be configured in various ways via arguments (language, region, etc.). [More information](#Object.prototype.toLocaleString).           *   `Object.prototype.valueOf()` ES1                    Configures how an object is converted to a non-string primitive value (often a number).                    ```     > 1 + {valueOf() {return 123}}     124          ```js                    [More information](#Object.prototype.valueOf).              #### [31.10.2 `Object.prototype.*`: useful methods with pitfalls](#objectprototype-useful-methods-with-pitfalls)    The following methods are useful but can’t be invoked on an object if:    *   `Object.prototype` isn’t a prototype of that object. *   The `Object.prototype` method is overridden somewhere in the prototype chain.    How to work around that limitation is explained in [“Using `Object.prototype` methods safely” (§31.9.1)](#using-object-methods-safely).    These are the methods:    *   `Object.prototype.isPrototypeOf()` ES3                    Is the receiver in the prototype chain of a given object?                    You’ll usually be fine if you invoke this method on an object. If you want to be safe, you can use the following pattern (line A):                    ```     function isInstanceOf(obj, aClass) {      return {}.isPrototypeOf.call(aClass.prototype, obj); // (A)     }     assert.equal(      isInstanceOf([], Object), true     );     assert.equal(      isInstanceOf([], Array), true     );     assert.equal(      isInstanceOf(/x/, Array), false     );          ```js                    [More information](#Object.prototype.isPrototypeOf).           *   `Object.prototype.propertyIsEnumerable()` ES3                    Does the receiver have an enumerable own property with the given key?                    You’ll usually be fine if you invoke this method on an object. If you want to be safe, you can use the following pattern:                    ```     > {}.propertyIsEnumerable.call(['a'], 'length')     false     > {}.propertyIsEnumerable.call(['a'], '0')     true          ```js                    [More information](#Object.prototype.propertyIsEnumerable).              #### [31.10.3 `Object.prototype.*`: methods to avoid](#objectprototype-methods-to-avoid)    Avoid the following features (there are better alternatives):    *   `get Object.prototype.__proto__` ES6                    Avoid:               *   Instead, use `Object.getPrototypeOf()`.     *   [More information](#Object.prototype.__proto__). *   `set Object.prototype.__proto__` ES6                    Avoid:               *   Instead, use `Object.setPrototypeOf()`.     *   [More information](#Object.prototype.__proto__). *   `Object.prototype.hasOwnProperty` ES3                    Avoid:               *   Instead, use `Object.hasOwn()` ^(ES2022)     *   [More information](#Object.prototype.hasOwnProperty).    ### [31.11 FAQ: classes](#faq-classes)    #### [31.11.1 Why are they called “instance private fields” in this book and not “private instance fields”?](#why-are-they-called-instance-private-fields-in-this-book-and-not-private-instance-fields)    That is done to highlight how different properties (public slots) and private slots are: By changing the order of the adjectives, the words “public” and “field” and the words “private” and “field” are always mentioned together.    #### [31.11.2 Why the identifier prefix `#`? Why not declare private fields via `private`?](#why-the-identifier-prefix--why-not-declare-private-fields-via-private)    Could private fields be declared via `private` and use normal identifiers? Let’s examine what would happen if that were possible:    ``` class MyClass {  private value; // (A)  compare(other) {  return this.value === other.value;  } }  ```js    Whenever an expression such as `other.value` appears in the body of `MyClass`, JavaScript has to decide:    *   Is `.value` a property? *   Is `.value` a private field?    At compile time, JavaScript doesn’t know if the declaration in line A applies to `other` (due to it being an instance of `MyClass`) or not. That leaves two options for making the decision:    1.  `.value` is always interpreted as a private field. 2.  JavaScript decides at runtime:     *   If `other` is an instance of `MyClass`, then `.value` is interpreted as a private field.     *   Otherwise `.value` is interpreted as a property.    Both options have downsides:    *   With option (1), we can’t use `.value` as a property, anymore – for any object. *   With option (2), performance is affected negatively.    That’s why the name prefix `#` was introduced. The decision is now easy: If we use `#`, we want to access a private field. If we don’t, we want to access a property.    `private` works for statically typed languages (such as TypeScript) because they know at compile time if `other` is an instance of `MyClass` and can then treat `.value` as private or public.```` ```js`` `````", "``````js` ``````", "``````js``` ``````", "```` ```js````", "```js` ```", "```js```", "``` ```", "```````js``` ``````js```````", "``````js``````", "``````js``````", "``` ```", "```js```", "````js````", "```js```", "````js````", "```js` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "``````js``````", "```````js` ``````js```````", "```````js`` ``````js```````", "```````js``` ``````js```````", "```````js```` ```js```````", "```````js```````", "``````js``````", "```````js`````` ```js```````", "```````js```````", "``` ```", "```js```", "````js````", "```js```", "````js` ````", "```````js```````", "```````js`` ``````js```````", "```````js```````", "``` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "``````js``````", "```````js```````", "```````js` ``````js```````", "```````js```````", "```````js`` ``````js```````", "```````js```````", "```````js``` ``````js```````", "```````js```````", "```````js```` ```js```````", "```````js```````", "```````js```````", "``````js``````", "```````js```````", "```````js`````` ```js```````", "```````js```````", "```````js```````", "``` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js` ````", "```````js```````", "```````js```````", "```````js`` ``````js```````", "```````js```````", "```````js```````", "``` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "``````js``````", "```````js```````", "```````js```````", "```````js` ``````js```````", "```````js```````", "```````js```````", "```````js`` ``````js```````", "```````js```````", "```````js```````", "```````js``` ``````js```````", "```````js```````", "```````js```````", "```````js```` ```js```````", "```````js```````", "```````js```````", "```````js```````", "``````js``````", "```````js```````", "```````js```````", "```````js``````"]