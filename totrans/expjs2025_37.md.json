["```js\nclass Person {\n  constructor(firstName) { // (A)\n    this.firstName = firstName; // (B)\n  }\n  describe() { // (C)\n return 'Person named ' + this.firstName;\n }\n}\nconst tarzan = new Person('Tarzan');\nassert.equal(\n tarzan.firstName, 'Tarzan'\n);\nassert.equal(\n tarzan.describe(),\n 'Person named Tarzan'\n);\n// One property (public slot)\nassert.deepEqual(\n Reflect.ownKeys(tarzan), ['firstName']\n);\n\n```", "```js\nclass Person {\n  #firstName; // (A)\n  constructor(firstName) {\n    this.#firstName = firstName; // (B)\n  }\n  describe() {\n return 'Person named ' + this.#firstName;\n }\n}\nconst tarzan = new Person('Tarzan');\nassert.equal(\n tarzan.describe(),\n 'Person named Tarzan'\n);\n// No properties, only a private field\nassert.deepEqual(\n Reflect.ownKeys(tarzan), []\n);\n\n```", "```js\nclass Employee extends Person {\n  #title;\n\n  constructor(firstName, title) {\n    super(firstName); // (A)\n    this.#title = title;\n  }\n  describe() {\n return `${super.describe()} (${this.#title})`; // (B)\n }\n}\n\nconst jane = new Employee('Jane', 'CTO');\nassert.equal(\n jane.describe(),\n 'Person named Jane (CTO)'\n);\n\n```", "```js\nclass StringBuilderClass {\n  string = ''; // (A)\n  add(str) {\n    this.string += str;\n    return this;\n  }\n}\n\nconst sb = new StringBuilderClass();\nsb.add('Hello').add(' everyone').add('!');\nassert.equal(\n  sb.string, 'Hello everyone!'\n);\n\n```", "```js\nclass Person {\n  #firstName; // (A)\n  constructor(firstName) {\n    this.#firstName = firstName; // (B)\n  }\n  describe() {\n return `Person named ${this.#firstName}`;\n }\n static extractNames(persons) {\n return persons.map(person => person.#firstName);\n }\n}\n\n```", "```js\nconst jane = new Person('Jane');\nconst tarzan = new Person('Tarzan');\n\n```", "```js\n    assert.deepEqual(\n      Reflect.ownKeys(jane),\n      []\n    );\n\n    ```", "```js\n    assert.equal(\n      jane.describe(), 'Person named Jane'\n    );\n    assert.equal(\n      tarzan.describe(), 'Person named Tarzan'\n    );\n\n    ```", "```js\n    assert.deepEqual(\n      Person.extractNames([jane, tarzan]),\n      ['Jane', 'Tarzan']\n    );\n\n    ```", "```js\nclass Container {\n  constructor(value) {\n    this.value = value;\n  }\n}\nconst abcContainer = new Container('abc');\nassert.equal(\n  abcContainer.value, 'abc'\n);\n\n```", "```js\n// Anonymous class expression\nconst Person = class { ··· };\n\n// Named class expression\nconst Person = class MyClass { ··· };\n\n```", "```js\n> new Person('Jane') instanceof Person\ntrue\n> {} instanceof Person\nfalse\n> {} instanceof Object\ntrue\n> [] instanceof Array\ntrue\n\n```", "```js\nclass MyClass {\n  #instancePrivateField = 1;\n  instanceProperty = 2;\n  getInstanceValues() {\n return [\n this.#instancePrivateField,\n this.instanceProperty,\n ];\n }\n}\nconst inst = new MyClass();\nassert.deepEqual(\n inst.getInstanceValues(), [1, 2]\n);\n\n```", "```js\nassert.deepEqual(\n  Reflect.ownKeys(inst),\n  ['instanceProperty']\n);\n\n```", "```js\nclass SuperClass {\n  #superProp = 'superProp';\n}\nclass SubClass extends SuperClass {\n  getSuperProp() {\n return this.#superProp;\n }\n}\n// SyntaxError: Private field '#superProp'\n// must be declared in an enclosing class\n\n```", "```js\nclass MyClass {\n  #instancePrivateField = 1;\n  instanceProperty = 2;\n  getInstanceValues() {\n return [\n this.#instancePrivateField,\n this.instanceProperty,\n ];\n }\n}\n\n```", "```js\nlet MyClass;\n{ // Scope of the body of the class\n  const instancePrivateFieldKey = Symbol();\n  MyClass = class {\n    __PrivateElements__ = new Map([\n      [instancePrivateFieldKey, 1],\n    ]);\n    instanceProperty = 2;\n    getInstanceValues() {\n return [\n this.__PrivateElements__.get(instancePrivateFieldKey),\n this.instanceProperty,\n ];\n }\n }\n}\n\n```", "```js\nclass MyClass {\n  #privateData = 'hello';\n  static createGetter() {\n return (obj) => obj.#privateData; // (A)\n }\n}\n\nconst myInstance = new MyClass();\nconst getter = MyClass.createGetter();\nassert.equal(\n getter(myInstance), 'hello' // (B)\n);\n\n```", "```js\nclass Color {\n  #name; // (A)\n  constructor(name) {\n    this.#name = name; // (B)\n  }\n  static getName(obj) {\n    return obj.#name;\n  }\n}\nclass Person {\n  #name; // (C)\n  constructor(name) {\n    this.#name = name;\n  }\n}\n\nassert.equal(\n  Color.getName(new Color('green')), 'green'\n);\n\n// We can’t access the private slot #name of a Person in line B:\nassert.throws(\n  () => Color.getName(new Person('Jane')),\n  {\n    name: 'TypeError',\n    message: 'Cannot read private member #name from'\n      + ' an object whose class did not declare it',\n  }\n);\n\n```", "```js\nclass SuperClass {\n  #privateField = 'super';\n  getSuperPrivateField() {\n return this.#privateField;\n }\n}\nclass SubClass extends SuperClass {\n #privateField = 'sub';\n getSubPrivateField() {\n return this.#privateField;\n }\n}\nconst inst = new SubClass();\nassert.equal(\n inst.getSuperPrivateField(), 'super'\n);\nassert.equal(\n inst.getSubPrivateField(), 'sub'\n); \n```", "```js\nclass Color {\n  #name;\n  constructor(name) {\n    this.#name = name;\n  }\n  static check(obj) {\n    return #name in obj; // (A)\n  }\n}\n\n```", "```js\nclass C1 {\n  #priv() {}\n static check(obj) {\n return #priv in obj;\n }\n}\nassert.equal(C1.check(new C1()), true);\n\n```", "```js\nclass C2 {\n  static #priv = 1;\n  static check(obj) {\n    return #priv in obj;\n  }\n}\nassert.equal(C2.check(C2), true);\nassert.equal(C2.check(new C2()), false);\n\n```", "```js\nclass C3 {\n  static #priv() {}\n static check(obj) {\n return #priv in obj;\n }\n}\nassert.equal(C3.check(C3), true);\n\n```", "```js\nclass Color {\n  #name;\n  constructor(name) {\n    this.#name = name;\n  }\n  static check(obj) {\n    return #name in obj;\n  }\n}\nclass Person {\n  #name;\n  constructor(name) {\n    this.#name = name;\n  }\n  static check(obj) {\n    return #name in obj;\n  }\n}\n\n// Detecting Color’s #name\nassert.equal(\n  Color.check(new Color()), true\n);\nassert.equal(\n  Color.check(new Person()), false\n);\n\n// Detecting Person’s #name\nassert.equal(\n  Person.check(new Person()), true\n);\nassert.equal(\n  Person.check(new Color()), false\n);\n\n```", "```js\nclass Person {\n  #firstName;\n  constructor(firstName) {\n    this.#firstName = firstName;\n  }\n  describe() {\n return `Person named ${this.#firstName}`;\n }\n static extractNames(persons) {\n return persons.map(person => person.#firstName);\n }\n}\n\n```", "```js\nassert.deepEqual(\n  Reflect.ownKeys(Person),\n  ['length', 'name', 'prototype', 'extractNames']\n);\n\n// The number of parameters of the constructor\nassert.equal(\n  Person.length, 1\n);\n\n// The name of the class\nassert.equal(\n  Person.name, 'Person'\n);\n\n```", "```js\nassert.deepEqual(\n  Reflect.ownKeys(Person.prototype),\n  ['constructor', 'describe']\n);\n\n```", "```js\nconst jane = new Person('Jane');\nassert.equal(\n  Object.getPrototypeOf(jane), Person.prototype\n);\n\nconst tarzan = new Person('Tarzan');\nassert.equal(\n  Object.getPrototypeOf(tarzan), Person.prototype\n);\n\n```", "```js\n    someObj.__proto__\n    Object.getPrototypeOf(someObj)\n\n    ```", "```js\n    someObj.__proto__ = anotherObj\n    Object.setPrototypeOf(someObj, anotherObj)\n\n    ```", "```js\n    class SomeClass {}\n    const inst = new SomeClass();\n    assert.equal(\n      Object.getPrototypeOf(inst), SomeClass.prototype\n    );\n\n    ```", "```js\n> Person.prototype.constructor === Person\ntrue\n\n```", "```js\nconst jane = new Person('Jane');\n\nconst cheeta = new jane.constructor('Cheeta');\n// cheeta is also an instance of Person\nassert.equal(cheeta instanceof Person, true);\n\n```", "```js\nconst tarzan = new Person('Tarzan');\nassert.equal(tarzan.constructor.name, 'Person');\n\n```", "```js\nclass Person {\n  #firstName;\n  constructor(firstName) {\n    this.#firstName = firstName;\n  }\n  describe() {\n return 'Person named '+this.#firstName;\n }\n}\nconst jane = new Person('Jane');\n\n```", "```js\njane.describe()\n\n```", "```js\n    const func = jane.describe;\n\n    ```", "```js\n    func.call(jane);\n\n    ```", "```js\nPerson.prototype.describe.call(jane)\n\n```", "```js\nconst obj = Object.create(null);\n\n// `obj` is not an instance of Object and doesn’t inherit\n// its prototype method .toString()\nassert.throws(\n  () => obj.toString(),\n  /^TypeError: obj.toString is not a function$/\n);\nassert.equal(\n  Object.prototype.toString.call(obj),\n  '[object Object]'\n);\n\n```", "```js\nfunction StringBuilderConstr(initialString) {\n  this.string = initialString;\n}\nStringBuilderConstr.prototype.add = function (str) {\n  this.string += str;\n  return this;\n};\n\nconst sb = new StringBuilderConstr('¡');\nsb.add('Hola').add('!');\nassert.equal(\n  sb.string, '¡Hola!'\n);\n\n```", "```js\nclass StringBuilderClass {\n  constructor(initialString) {\n    this.string = initialString;\n  }\n  add(str) {\n    this.string += str;\n    return this;\n  }\n}\nconst sb = new StringBuilderClass('¡');\nsb.add('Hola').add('!');\nassert.equal(\n  sb.string, '¡Hola!'\n);\n\n```", "```js\nfunction SuperConstructor() {}\nclass SubClass extends SuperConstructor {}\n\nassert.equal(\n new SubClass() instanceof SuperConstructor, true\n);\n\n```", "```js\n> StringBuilderClass.prototype.constructor === StringBuilderClass\ntrue\n> typeof StringBuilderClass\n'function'\n\n```", "```js\nclass PublicProtoClass {\n  constructor(args) {\n    // (Do something with `args` here.)\n  }\n  publicProtoMethod() {\n return 'publicProtoMethod';\n }\n get publicProtoAccessor() {\n return 'publicProtoGetter';\n }\n set publicProtoAccessor(value) {\n assert.equal(value, 'publicProtoSetter');\n }\n}\n\nassert.deepEqual(\n Reflect.ownKeys(PublicProtoClass.prototype),\n ['constructor', 'publicProtoMethod', 'publicProtoAccessor']\n);\n\nconst inst = new PublicProtoClass('arg1', 'arg2');\nassert.equal(\n inst.publicProtoMethod(), 'publicProtoMethod'\n);\nassert.equal(\n inst.publicProtoAccessor, 'publicProtoGetter'\n);\ninst.publicProtoAccessor = 'publicProtoSetter';\n\n```", "```js\nconst accessorKey = Symbol('accessorKey');\nconst syncMethodKey = Symbol('syncMethodKey');\nconst syncGenMethodKey = Symbol('syncGenMethodKey');\nconst asyncMethodKey = Symbol('asyncMethodKey');\nconst asyncGenMethodKey = Symbol('asyncGenMethodKey');\n\nclass PublicProtoClass2 {\n  // Identifier keys\n  get accessor() {}\n  set accessor(value) {}\n  syncMethod() {}\n * syncGeneratorMethod() {}\n async asyncMethod() {}\n async * asyncGeneratorMethod() {}\n\n // Quoted keys\n get 'an accessor'() {}\n set 'an accessor'(value) {}\n 'sync method'() {}\n * 'sync generator method'() {}\n async 'async method'() {}\n async * 'async generator method'() {}\n\n // Computed keys\n get [accessorKey]() {}\n set [accessorKey](value) {}\n [syncMethodKey]() {}\n * [syncGenMethodKey]() {}\n async [asyncMethodKey]() {}\n async * [asyncGenMethodKey]() {}\n}\n\n// Quoted and computed keys are accessed via square brackets:\nconst inst = new PublicProtoClass2();\ninst['sync method']();\ninst[syncMethodKey](); \n```", "```js\nclass MyClass {\n  #privateMethod() {}\n static check() {\n const inst = new MyClass();\n assert.equal(\n #privateMethod in inst, true // (A)\n );\n assert.equal(\n #privateMethod in MyClass.prototype, false\n );\n assert.equal(\n #privateMethod in MyClass, false\n );\n }\n}\nMyClass.check(); \n```", "```js\nclass MyClass {\n  #privateMethod() {}\n static check() {\n const inst1 = new MyClass();\n const inst2 = new MyClass();\n assert.equal(\n inst1.#privateMethod,\n inst2.#privateMethod\n );\n }\n} \n```", "```js\nclass PrivateMethodClass {\n  #privateMethod() {\n return 'privateMethod';\n }\n get #privateAccessor() {\n return 'privateGetter';\n }\n set #privateAccessor(value) {\n assert.equal(value, 'privateSetter');\n }\n callPrivateMembers() {\n assert.equal(this.#privateMethod(), 'privateMethod');\n assert.equal(this.#privateAccessor, 'privateGetter');\n this.#privateAccessor = 'privateSetter';\n }\n}\nassert.deepEqual(\n Reflect.ownKeys(new PrivateMethodClass()), []\n); \n```", "```js\nclass PrivateMethodClass2 {\n  get #accessor() {}\n set #accessor(value) {}\n #syncMethod() {}\n * #syncGeneratorMethod() {}\n async #asyncMethod() {}\n async * #asyncGeneratorMethod() {}\n} \n```", "```js\nclass InstPublicClass {\n  // Instance public field\n  instancePublicField = 0; // (A)\n\n  constructor(value) {\n    // We don’t need to mention .property elsewhere!\n    this.property = value; // (B)\n  }\n}\n\nconst inst = new InstPublicClass('constrArg');\nassert.deepEqual(\n  Reflect.ownKeys(inst),\n  ['instancePublicField', 'property']\n);\nassert.equal(\n  inst.instancePublicField, 0\n);\nassert.equal(\n  inst.property, 'constrArg'\n);\n\n```", "```js\nconst computedFieldKey = Symbol('computedFieldKey');\nclass InstPublicClass2 {\n  'quoted field key' = 1;\n  [computedFieldKey] = 2;\n}\nconst inst = new InstPublicClass2();\nassert.equal(inst['quoted field key'], 1);\nassert.equal(inst[computedFieldKey], 2);\n\n```", "```js\nclass MyClass {\n  instancePublicField = this;\n}\nconst inst = new MyClass();\nassert.equal(\n  inst.instancePublicField, inst\n);\n\n```", "```js\nclass SuperClass {\n  superProp = console.log('superProp');\n  constructor() {\n console.log('super-constructor');\n }\n}\nclass SubClass extends SuperClass {\n subProp = console.log('subProp');\n constructor() {\n console.log('BEFORE super()');\n super();\n console.log('AFTER super()');\n }\n}\nnew SubClass(); \n```", "```js\nBEFORE super()\nsuperProp\nsuper-constructor\nsubProp\nAFTER super()\n\n```", "```js\nclass InstPrivateClass {\n  #privateField1 = 'private field 1'; // (A)\n  #privateField2; // (B) required!\n  constructor(value) {\n    this.#privateField2 = value; // (C)\n  }\n  /**\n * Private fields are not accessible outside the class body.\n */\n  checkPrivateValues() {\n assert.equal(\n this.#privateField1, 'private field 1'\n );\n assert.equal(\n this.#privateField2, 'constructor argument'\n );\n }\n}\n\nconst inst = new InstPrivateClass('constructor argument');\n inst.checkPrivateValues();\n\n// No instance properties were created\nassert.deepEqual(\n Reflect.ownKeys(inst),\n []\n);\n\n```", "```js\nclass Countdown {\n  constructor(counter, action) {\n    this._counter = counter;\n    this._action = action;\n  }\n  dec() {\n this._counter--;\n if (this._counter === 0) {\n this._action();\n }\n }\n}\n\n// The two properties aren’t really private:\nassert.deepEqual(\n Object.keys(new Countdown()),\n ['_counter', '_action']);\n\n```", "```js\nconst _counter = new WeakMap();\nconst _action = new WeakMap();\n\nclass Countdown {\n  constructor(counter, action) {\n    _counter.set(this, counter);\n    _action.set(this, action);\n  }\n  dec() {\n let counter = _counter.get(this);\n counter--;\n _counter.set(this, counter);\n if (counter === 0) {\n _action.get(this)();\n }\n }\n}\n\n// The two pseudo-properties are truly private:\nassert.deepEqual(\n Object.keys(new Countdown()),\n []);\n\n```", "```js\nlet Countdown;\n{ // class scope\n  const _counter = new WeakMap();\n  const _action = new WeakMap();\n\n  Countdown = class {\n    // ···\n  }\n}\n\n```", "```js\nconst _counter = new WeakMap();\nconst _action = new WeakMap();\n\nclass Countdown {\n  constructor(counter, action) {\n    _counter.set(this, counter);\n    _action.set(this, action);\n  }\n  dec() {\n privateDec(this);\n }\n}\n\nfunction privateDec(_this) { // (A)\n let counter = _counter.get(_this);\n counter--;\n _counter.set(_this, counter);\n if (counter === 0) {\n _action.get(_this)();\n }\n}\n\n```", "```js\nconst _superProp = new WeakMap();\nclass SuperClass {\n  constructor() {\n _superProp.set(this, 'superProp');\n }\n}\nclass SubClass extends SuperClass {\n getSuperProp() {\n return _superProp.get(this);\n }\n}\nassert.equal(\n new SubClass().getSuperProp(),\n 'superProp'\n); \n```", "```js\nclass StaticPublicMethodsClass {\n  static staticMethod() {\n return 'staticMethod';\n }\n static get staticAccessor() {\n return 'staticGetter';\n }\n static set staticAccessor(value) {\n assert.equal(value, 'staticSetter');\n }\n}\nassert.equal(\n StaticPublicMethodsClass.staticMethod(), 'staticMethod'\n);\nassert.equal(\n StaticPublicMethodsClass.staticAccessor, 'staticGetter'\n);\nStaticPublicMethodsClass.staticAccessor = 'staticSetter';\n\n```", "```js\nconst accessorKey = Symbol('accessorKey');\nconst syncMethodKey = Symbol('syncMethodKey');\nconst syncGenMethodKey = Symbol('syncGenMethodKey');\nconst asyncMethodKey = Symbol('asyncMethodKey');\nconst asyncGenMethodKey = Symbol('asyncGenMethodKey');\n\nclass StaticPublicMethodsClass2 {\n  // Identifier keys\n  static get accessor() {}\n  static set accessor(value) {}\n  static syncMethod() {}\n static * syncGeneratorMethod() {}\n static async asyncMethod() {}\n static async * asyncGeneratorMethod() {}\n\n // Quoted keys\n static get 'an accessor'() {}\n static set 'an accessor'(value) {}\n static 'sync method'() {}\n static * 'sync generator method'() {}\n static async 'async method'() {}\n static async * 'async generator method'() {}\n\n // Computed keys\n static get [accessorKey]() {}\n static set [accessorKey](value) {}\n static [syncMethodKey]() {}\n static * [syncGenMethodKey]() {}\n static async [asyncMethodKey]() {}\n static async * [asyncGenMethodKey]() {}\n}\n\n// Quoted and computed keys are accessed via square brackets:\nStaticPublicMethodsClass2['sync method']();\nStaticPublicMethodsClass2[syncMethodKey](); \n```", "```js\nconst computedFieldKey = Symbol('computedFieldKey');\nclass StaticPublicFieldClass {\n  static identifierFieldKey = 1;\n  static 'quoted field key' = 2;\n  static [computedFieldKey] = 3;\n}\n\nassert.deepEqual(\n  Reflect.ownKeys(StaticPublicFieldClass),\n  [\n    'length', // number of constructor parameters\n    'name', // 'StaticPublicFieldClass'\n    'prototype',\n    'identifierFieldKey',\n    'quoted field key',\n    computedFieldKey,\n  ],\n);\n\nassert.equal(StaticPublicFieldClass.identifierFieldKey, 1);\nassert.equal(StaticPublicFieldClass['quoted field key'], 2);\nassert.equal(StaticPublicFieldClass[computedFieldKey], 3);\n\n```", "```js\nclass StaticPrivateClass {\n  // Declare and initialize\n  static #staticPrivateField = 'hello'; // (A)\n  static #twice() { // (B)\n const str = StaticPrivateClass.#staticPrivateField;\n return str + ' ' + str;\n }\n static getResultOfTwice() {\n return StaticPrivateClass.#twice();\n }\n}\n\nassert.deepEqual(\n Reflect.ownKeys(StaticPrivateClass),\n [\n 'length', // number of constructor parameters\n 'name', // 'StaticPublicFieldClass'\n 'prototype',\n 'getResultOfTwice',\n ],\n);\n\nassert.equal(\n StaticPrivateClass.getResultOfTwice(),\n 'hello hello'\n); \n```", "```js\nclass MyClass {\n  static #staticPrivateMethod() {}\n static * #staticPrivateGeneratorMethod() {}\n\n static async #staticPrivateAsyncMethod() {}\n static async * #staticPrivateAsyncGeneratorMethod() {}\n\n static get #staticPrivateAccessor() {}\n static set #staticPrivateAccessor(value) {}\n} \n```", "```js\nclass Translator {\n  static translations = {\n    yes: 'ja',\n    no: 'nein',\n    maybe: 'vielleicht',\n  };\n  static englishWords = [];\n  static germanWords = [];\n  static { // (A)\n    for (const [english, german] of Object.entries(this.translations)) {\n      this.englishWords.push(english);\n      this.germanWords.push(german);\n    }\n  }\n}\n\n```", "```js\nclass SuperClass {\n  static superField1 = console.log('superField1');\n  static {\n    assert.equal(this, SuperClass);\n    console.log('static block 1 SuperClass');\n  }\n  static superField2 = console.log('superField2');\n  static {\n    console.log('static block 2 SuperClass');\n  }\n}\n\nclass SubClass extends SuperClass {\n  static subField1 = console.log('subField1');\n  static {\n    assert.equal(this, SubClass);\n    console.log('static block 1 SubClass');\n  }\n  static subField2 = console.log('subField2');\n  static {\n    console.log('static block 2 SubClass');\n  }\n}\n\n```", "```js\nsuperField1\nstatic block 1 SuperClass\nsuperField2\nstatic block 2 SuperClass\nsubField1\nstatic block 1 SubClass\nsubField2\nstatic block 2 SubClass\n\n```", "```js\nclass SuperClass {\n  static publicData = 1;\n\n  static getPublicViaThis() {\n return this.publicData;\n }\n}\nclass SubClass extends SuperClass {\n}\n\n```", "```js\nassert.equal(SuperClass.getPublicViaThis(), 1);\n\n```", "```js\nassert.equal(SubClass.getPublicViaThis(), 1);\n\n```", "```js\nclass SuperClass {\n  static #privateData = 2;\n  static getPrivateDataViaThis() {\n return this.#privateData;\n }\n static getPrivateDataViaClassName() {\n return SuperClass.#privateData;\n }\n}\nclass SubClass extends SuperClass {\n} \n```", "```js\nassert.equal(SuperClass.getPrivateDataViaThis(), 2);\n\n```", "```js\nassert.throws(\n  () => SubClass.getPrivateDataViaThis(),\n  {\n    name: 'TypeError',\n    message: 'Cannot read private member #privateData from'\n      + ' an object whose class did not declare it',\n  }\n);\n\n```", "```js\nassert.equal(SubClass.getPrivateDataViaClassName(), 2);\n\n```", "```js\nclass DemoClass {\n  static #staticPrivateField = 1;\n  #instPrivField = 2;\n\n  static staticMethod(inst) {\n    // A static method can access static private fields\n    // and instance private fields\n    assert.equal(DemoClass.#staticPrivateField, 1);\n    assert.equal(inst.#instPrivField, 2);\n  }\n\n  protoMethod() {\n // A prototype method can access instance private fields\n // and static private fields\n assert.equal(this.#instPrivField, 2);\n assert.equal(DemoClass.#staticPrivateField, 1);\n }\n}\n\n```", "```js\n// Accessing private fields outside their classes triggers\n// syntax errors (before the code is even executed).\nassert.throws(\n  () => eval('DemoClass.#staticPrivateField'),\n  {\n    name: 'SyntaxError',\n    message: \"Private field '#staticPrivateField' must\"\n      + \" be declared in an enclosing class\",\n  }\n);\n// Accessing private fields outside their classes triggers\n// syntax errors (before the code is even executed).\nassert.throws(\n  () => eval('new DemoClass().#instPrivField'),\n  {\n    name: 'SyntaxError',\n    message: \"Private field '#instPrivField' must\"\n      + \" be declared in an enclosing class\",\n  }\n);\n\n```", "```js\nexport class StaticClass {\n  static #secret = 'Rumpelstiltskin';\n  static #getSecretInParens() {\n return `(${StaticClass.#secret})`;\n }\n static callStaticPrivateMethod() {\n return StaticClass.#getSecretInParens();\n }\n} \n```", "```js\nconst secret = 'Rumpelstiltskin';\nfunction getSecretInParens() {\n return `(${secret})`;\n}\n\n// Only the class is accessible outside the module\nexport class StaticClass {\n static callStaticPrivateMethod() {\n return getSecretInParens();\n }\n} \n```", "```js\nclass Point {\n  static fromPolar(radius, angle) {\n    const x = radius * Math.cos(angle);\n    const y = radius * Math.sin(angle);\n    return new Point(x, y);\n  }\n  constructor(x=0, y=0) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nassert.deepEqual(\n  Point.fromPolar(13, 0.39479111969976155),\n  new Point(12, 5)\n);\n\n```", "```js\n// Only accessible inside the current module\nconst secretToken = Symbol('secretToken'); // (A)\n\nexport class Point {\n  static create(x=0, y=0) {\n    return new Point(secretToken, x, y);\n  }\n  static fromPolar(radius, angle) {\n    const x = radius * Math.cos(angle);\n    const y = radius * Math.sin(angle);\n    return new Point(secretToken, x, y);\n  }\n  constructor(token, x, y) {\n    if (token !== secretToken) {\n      throw new TypeError('Must use static factory method');\n    }\n    this.x = x;\n    this.y = y;\n  }\n}\nPoint.create(3, 4); // OK\nassert.throws(\n  () => new Point(3, 4),\n  TypeError\n);\n\n```", "```js\nclass Person {\n  #firstName;\n  constructor(firstName) {\n    this.#firstName = firstName;\n  }\n  describe() {\n return `Person named ${this.#firstName}`;\n }\n static extractNames(persons) {\n return persons.map(person => person.#firstName);\n }\n}\n\nclass Employee extends Person {\n constructor(firstName, title) {\n super(firstName);\n this.title = title;\n }\n describe() {\n return super.describe() +\n ` (${this.title})`;\n }\n}\n\nconst jane = new Employee('Jane', 'CTO');\nassert.equal(\n jane.title,\n 'CTO'\n);\nassert.equal(\n jane.describe(),\n 'Person named Jane (CTO)'\n); \n```", "```js\n> 'extractNames' in Employee\ntrue\n\n```", "```js\n> Object.getPrototypeOf(Person.prototype) === Object.prototype\ntrue\n\n```", "```js\n> Object.getPrototypeOf(Object.prototype)\nnull\n\n```", "```js\n> Object.getPrototypeOf(Person) === Function.prototype\ntrue\n\n```", "```js\nx instanceof C\nC.prototype.isPrototypeOf(x)\n\n```", "```js\n> jane instanceof Employee\ntrue\n> jane instanceof Person\ntrue\n> jane instanceof Object\ntrue\n\n```", "```js\n> 'abc' instanceof String\nfalse\n> 123 instanceof Number\nfalse\n\n```", "```js\nassert.equal(\n  {a: 1} instanceof Object, true\n);\nassert.equal(\n  ['a'] instanceof Object, true\n);\nassert.equal(\n  /abc/g instanceof Object, true\n);\nassert.equal(\n  new Map() instanceof Object, true\n);\n\nclass C {}\nassert.equal(\n  new C() instanceof Object, true\n);\n\n```", "```js\nconst obj1 = {__proto__: null};\nassert.equal(\n  typeof obj1, 'object' // (A)\n);\nassert.equal(\n  obj1 instanceof Object, false // (B)\n);\n\nconst obj2 = Object.create(null);\nassert.equal(\n  typeof obj2, 'object' // (C)\n);\nassert.equal(\n  obj2 instanceof Object, false // (D)\n);\n\n```", "```js\n> typeof Object.prototype\n'object'\n> Object.getPrototypeOf(Object.prototype)\nnull\n> Object.prototype instanceof Object\nfalse\n\n```", "```js\nclass DerivedClass extends Object {}\nconst derivedInstance = new DerivedClass();\n\n```", "```js\nclass BaseClass {}\nconst baseInstance = new BaseClass();\n\n```", "```js\nconst p = Object.getPrototypeOf.bind(Object);\n\n```", "```js\n> const p = Object.getPrototypeOf.bind(Object);\n> p({}) === Object.prototype\ntrue\n> p(p({}))\nnull\n\n```", "```js\n> const p = Object.getPrototypeOf.bind(Object);\n> p([]) === Array.prototype\ntrue\n> p(p([])) === Object.prototype\ntrue\n> p(p(p([]))) === null\ntrue\n\n```", "```js\n> Object.getPrototypeOf(Array) === Function.prototype\ntrue\n\n```", "```js\n> Object.getPrototypeOf(() => {}) === Function.prototype\ntrue\n\n```", "```js\n> const p = Object.getPrototypeOf.bind(Object);\n> p(() => {}) === Function.prototype\ntrue\n> p(p(() => {})) === Object.prototype\ntrue\n> p(p(p(() => {})))\nnull\n\n```", "```js\nconst S1 = (Sup) => class extends Sup { /*···*/ };\nconst S2 = (Sup) => class extends Sup { /*···*/ };\n\n```", "```js\nclass C extends S2(S1(Object)) {\n  /*···*/\n}\n\n```", "```js\nconst Named = (Sup) => class extends Sup {\n  name = '(Unnamed)';\n  toString() {\n const className = this.constructor.name;\n return `${className} named ${this.name}`;\n }\n};\n\n```", "```js\nclass City extends Named(Object) {\n  constructor(name) {\n    super();\n    this.name = name;\n  }\n}\n\n```", "```js\nconst paris = new City('Paris');\nassert.equal(\n  paris.name, 'Paris'\n);\nassert.equal(\n  paris.toString(), 'City named Paris'\n);\n\n```", "```js\n> {ownProp: true}.hasOwnProperty('ownProp')\ntrue\n> {ownProp: true}.hasOwnProperty('abc')\nfalse\n\n```", "```js\nconst obj = Object.create(null);\nassert.equal(obj instanceof Object, false);\nassert.throws(\n  () => obj.hasOwnProperty('prop'),\n  {\n    name: 'TypeError',\n    message: 'obj.hasOwnProperty is not a function',\n  }\n);\n\n```", "```js\nconst obj = {\n  hasOwnProperty: 'yes' // (A)\n};\nassert.throws(\n  () => obj.hasOwnProperty('prop'),\n  {\n    name: 'TypeError',\n    message: 'obj.hasOwnProperty is not a function',\n  }\n);\n\n```", "```js\nfunction hasOwnProp(obj, propName) {\n  return Object.prototype.hasOwnProperty.call(obj, propName); // (A)\n}\nassert.equal(\n  hasOwnProp(Object.create(null), 'prop'), false\n);\nassert.equal(\n  hasOwnProp({hasOwnProperty: 'yes'}, 'prop'), false\n);\nassert.equal(\n  hasOwnProp({hasOwnProperty: 'yes'}, 'hasOwnProperty'), true\n);\n\n```", "```js\nconst hasOwnProp = Function.prototype.call\n  .bind(Object.prototype.hasOwnProperty);\n\n```", "```js\n> String({toString() { return 'Hello!' }})\n'Hello!'\n> String({})\n'[object Object]' \n```", "```js\n> undefined.toString()\nTypeError: Cannot read properties of undefined (reading 'toString')\n> null.toString()\nTypeError: Cannot read properties of null (reading 'toString')\n> String(undefined)\n'undefined'\n> String(null)\n'null'\n\n```", "```js\n    > 123.45.toLocaleString('en') // English\n    '123.45'\n    > 123.45.toLocaleString('fr') // French\n    '123,45'\n\n    ```", "```js\n    > [1.25, 3].toLocaleString('en') // English\n    '1.25,3'\n    > [1.25, 3].toLocaleString('fr') // French\n    '1,25,3'\n\n    ```", "```js\nassert.equal(\n  17.50.toLocaleString('en', {\n    style: 'currency',\n    currency: 'USD',\n  }),\n  '$17.50'\n);\nassert.equal(\n  17.50.toLocaleString('fr', {\n    style: 'currency',\n    currency: 'USD',\n  }),\n  '17,50 $US'\n);\nassert.equal(\n  17.50.toLocaleString('de', {\n    style: 'currency',\n    currency: 'USD',\n  }),\n  '17,50 $'\n);\n\nassert.equal(\n  17.50.toLocaleString('en', {\n    style: 'currency',\n    currency: 'EUR',\n  }),\n  '€17.50'\n);\n\n```", "```js\n> Number({valueOf() { return 123 }})\n123\n> Number({})\nNaN \n```", "```js\nconst a = {};\nconst b = {__proto__: a};\nconst c = {__proto__: b};\n\nassert.equal(a.isPrototypeOf(b), true);\nassert.equal(a.isPrototypeOf(c), true);\n\nassert.equal(a.isPrototypeOf(a), false);\nassert.equal(c.isPrototypeOf(a), false);\n\n```", "```js\nconst obj = {\n  // Overrides Object.prototype.isPrototypeOf\n  isPrototypeOf: true,\n};\n// Doesn’t work in this case:\nassert.throws(\n  () => obj.isPrototypeOf(Object.prototype),\n  {\n    name: 'TypeError',\n    message: 'obj.isPrototypeOf is not a function',\n  }\n);\n// Safe way of using .isPrototypeOf():\nassert.equal(\n  Object.prototype.isPrototypeOf.call(obj, Object.prototype), false\n);\n\n```", "```js\nfunction isInstanceOf(obj, aClass) {\n  return {}.isPrototypeOf.call(aClass.prototype, obj);\n}\nassert.equal(\n  isInstanceOf([], Object), true\n);\nassert.equal(\n  isInstanceOf([], Array), true\n);\nassert.equal(\n  isInstanceOf(/x/, Array), false\n);\n\n```", "```js\nconst proto = {\n  enumerableProtoProp: true,\n};\nconst obj = {\n  __proto__: proto,\n  enumerableObjProp: true,\n  nonEnumObjProp: true,\n};\nObject.defineProperty(\n  obj, 'nonEnumObjProp',\n  {\n    enumerable: false,\n  }\n);\n\nassert.equal(\n  obj.propertyIsEnumerable('enumerableProtoProp'),\n  false // not an own property\n);\nassert.equal(\n  obj.propertyIsEnumerable('enumerableObjProp'),\n  true\n);\nassert.equal(\n  obj.propertyIsEnumerable('nonEnumObjProp'),\n  false // not enumerable\n);\nassert.equal(\n  obj.propertyIsEnumerable('unknownProp'),\n  false // not a property\n);\n\n```", "```js\nconst obj = {\n  // Overrides Object.prototype.propertyIsEnumerable\n  propertyIsEnumerable: true,\n  enumerableProp: 'yes',\n};\n// Doesn’t work in this case:\nassert.throws(\n  () => obj.propertyIsEnumerable('enumerableProp'),\n  {\n    name: 'TypeError',\n    message: 'obj.propertyIsEnumerable is not a function',\n  }\n);\n// Safe way of using .propertyIsEnumerable():\nassert.equal(\n  Object.prototype.propertyIsEnumerable.call(obj, 'enumerableProp'),\n  true\n);\n\n```", "```js\nassert.deepEqual(\n  Object.getOwnPropertyDescriptor(obj, 'enumerableProp'),\n  {\n    value: 'yes',\n    writable: true,\n    enumerable: true,\n    configurable: true,\n  }\n);\n\n```", "```js\nclass Object {\n  get __proto__() {\n    return Object.getPrototypeOf(this);\n  }\n  set __proto__(other) {\n    Object.setPrototypeOf(this, other);\n  }\n  // ···\n}\n\n```", "```js\n> '__proto__' in {}\ntrue\n> '__proto__' in Object.create(null)\nfalse\n\n```", "```js\nconst obj = { ownProp: true };\nassert.equal(\n  obj.hasOwnProperty('ownProp'), true // own\n);\nassert.equal(\n  'toString' in obj, true // inherited\n);\nassert.equal(\n  obj.hasOwnProperty('toString'), false\n);\n\n```", "```js\nconst obj = {\n  // Overrides Object.prototype.hasOwnProperty\n  hasOwnProperty: true,\n};\n// Doesn’t work in this case:\nassert.throws(\n  () => obj.hasOwnProperty('anyPropKey'),\n  {\n    name: 'TypeError',\n    message: 'obj.hasOwnProperty is not a function',\n  }\n);\n// Safe way of using .hasOwnProperty():\nassert.equal(\n  Object.prototype.hasOwnProperty.call(obj, 'anyPropKey'), false\n);\n\n```", "```js\n    > 'Object: ' + {toString() {return 'Hello!'}}\n    'Object: Hello!' \n    ```", "```js\n    > 1 + {valueOf() {return 123}}\n    124 \n    ```", "```js\n    function isInstanceOf(obj, aClass) {\n      return {}.isPrototypeOf.call(aClass.prototype, obj); // (A)\n    }\n    assert.equal(\n      isInstanceOf([], Object), true\n    );\n    assert.equal(\n      isInstanceOf([], Array), true\n    );\n    assert.equal(\n      isInstanceOf(/x/, Array), false\n    );\n\n    ```", "```js\n    > {}.propertyIsEnumerable.call(['a'], 'length')\n    false\n    > {}.propertyIsEnumerable.call(['a'], '0')\n    true\n\n    ```", "```js\nclass MyClass {\n  private value; // (A)\n  compare(other) {\n    return this.value === other.value;\n  }\n}\n\n```"]