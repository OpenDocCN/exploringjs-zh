<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>13 Variables and assignment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>13 Variables and assignment</h1>
<blockquote>原文：<a href="https://exploringjs.com/js/book/ch_variables-assignment.html">https://exploringjs.com/js/book/ch_variables-assignment.html</a></blockquote>

        
    
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#let">13.1 <code>let</code></a>
    </li>
    <li>
      <a href="#const">13.2 <code>const</code></a>
      <ol>
        <li>
          <a href="#const-creates-immutable-bindings">13.2.1 <code>const</code> and immutability</a>
        </li>
        <li>
          <a href="#const-and-loops">13.2.2 <code>const</code> and loops</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#deciding-between-const-and-let">13.3 Deciding between <code>const</code> and <code>let</code></a>
    </li>
    <li>
      <a href="#variable-scope">13.4 The scope of a variable</a>
      <ol>
        <li>
          <a href="#shadowing-variables">13.4.1 Shadowing variables</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#advanced-1">13.5 (Advanced)</a>
    </li>
    <li>
      <a href="#programming-languages-static-vs-dynamic">13.6 Terminology: static vs. dynamic</a>
      <ol>
        <li>
          <a href="#static-phenomenon-scopes-of-variables">13.6.1 Static phenomenon: scopes of variables</a>
        </li>
        <li>
          <a href="#dynamic-phenomenon-function-calls">13.6.2 Dynamic phenomenon: function calls</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#global-variable-scopes">13.7 The scopes of JavaScript’s global variables</a>
      <ol>
        <li>
          <a href="#globalThis">13.7.1 <code>globalThis</code><span> <sup>ES2020</sup></span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#declarations-scope-activation">13.8 Declarations: scope and activation</a>
      <ol>
        <li>
          <a href="#temporal-dead-zone">13.8.1 <code>const</code> and <code>let</code>: temporal dead zone</a>
        </li>
        <li>
          <a href="#early-activation">13.8.2 Function declarations and early activation</a>
        </li>
        <li>
          <a href="#class-declarations-are-not-activated-early">13.8.3 Class declarations are not activated early</a>
        </li>
        <li>
          <a href="#hoisting">13.8.4 <code>var</code>: hoisting (partial early activation)</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#closures">13.9 Closures</a>
      <ol>
        <li>
          <a href="#bound-variables-vs-free-variables">13.9.1 Bound variables vs. free variables</a>
        </li>
        <li>
          <a href="#what-is-a-closure">13.9.2 What is a closure?</a>
        </li>
        <li>
          <a href="#example-a-factory-for-incrementors">13.9.3 Example: A factory for incrementors</a>
        </li>
        <li>
          <a href="#use-cases-for-closures">13.9.4 Use cases for closures</a>
        </li>
      </ol>
    </li>
  </ol>
</nav>
<p>These are JavaScript’s main ways of declaring variables:</p>
<ul>
  <li>
    <code>let</code> declares mutable variables.
  </li>
  <li>
    <code>const</code> declares <em>constants</em> (immutable variables). <span id="index-entry-constant"/>
  </li>
</ul>
<p>Before ES6, there was also <code>var</code>. But it has several quirks, so it’s best to avoid it in modern JavaScript. You can read more about it in <a href="http://exploringjs.com/es5/ch16.html"><em>Speaking JavaScript</em></a>.</p>
<h3 id="let"><a class="heading-id-link" href="#let">13.1 <code>let</code></a></h3>
<p><span id="index-entry-let"/></p>
<p>Variables declared via <code>let</code> are mutable:</p>
<pre class="language-js">
<code><span class="hljs-keyword">let</span> i;</code>
<code>i = <span class="hljs-number">0</span>;</code>
<code>i = i + <span class="hljs-number">1</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(i, <span class="hljs-number">1</span>);</code>
</pre>
<p>We can also declare and assign at the same time:</p>
<pre class="language-js">
<code><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;</code>
</pre>
<h3 id="const"><a class="heading-id-link" href="#const">13.2 <code>const</code></a></h3>
<p><span id="index-entry-const"/></p>
<p>Variables declared via <code>const</code> are immutable. We must always initialize immediately:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// must initialize</span></code>
<code/>
<code>assert.<span class="hljs-title function_">throws</span>(</code>
<code>  <span class="hljs-function">() =&gt;</span> { i = i + <span class="hljs-number">1</span> },</code>
<code>  {</code>
<code>    <span class="hljs-attr">name</span>: <span class="hljs-string">'TypeError'</span>,</code>
<code>    <span class="hljs-attr">message</span>: <span class="hljs-string">'Assignment to constant variable.'</span>,</code>
<code>  }</code>
<code>);</code>
</pre>
<h4 id="const-creates-immutable-bindings"><a class="heading-id-link" href="#const-creates-immutable-bindings">13.2.1 <code>const</code> and immutability</a></h4>
<p><span id="index-entry-binding--variable-"/></p>
<p>In JavaScript, <code>const</code> only means that the <em>binding</em> (the association between variable name and variable value) is immutable. The value itself may be mutable, like <code>obj</code> in the following example.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">prop</span>: <span class="hljs-number">0</span> };</code>
<code/>
<code><span class="hljs-comment">// Allowed: changing properties of `obj`</span></code>
<code>obj.<span class="hljs-property">prop</span> = obj.<span class="hljs-property">prop</span> + <span class="hljs-number">1</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(obj.<span class="hljs-property">prop</span>, <span class="hljs-number">1</span>);</code>
<code/>
<code><span class="hljs-comment">// Not allowed: assigning to `obj`</span></code>
<code>assert.<span class="hljs-title function_">throws</span>(</code>
<code>  <span class="hljs-function">() =&gt;</span> { obj = {} },</code>
<code>  {</code>
<code>    <span class="hljs-attr">name</span>: <span class="hljs-string">'TypeError'</span>,</code>
<code>    <span class="hljs-attr">message</span>: <span class="hljs-string">'Assignment to constant variable.'</span>,</code>
<code>  }</code>
<code>);</code>
</pre>
<h4 id="const-and-loops"><a class="heading-id-link" href="#const-and-loops">13.2.2 <code>const</code> and loops</a></h4>
<p>We can use <code>const</code> with <code>for-of</code> loops, where a fresh binding is created for each iteration:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>];</code>
<code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> elem <span class="hljs-keyword">of</span> arr) {</code>
<code>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(elem);</code>
<code>}</code>
</pre>
<p>Output:</p>
<pre>
<code>hello</code>
<code>world</code>
</pre>
<p>In plain <code>for</code> loops, we must use <code>let</code>, however:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>];</code>
<code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;arr.<span class="hljs-property">length</span>; i++) {</code>
<code>  <span class="hljs-keyword">const</span> elem = arr[i];</code>
<code>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(elem);</code>
<code>}</code>
</pre>
<h3 id="deciding-between-const-and-let"><a class="heading-id-link" href="#deciding-between-const-and-let">13.3 Deciding between <code>const</code> and <code>let</code></a></h3>
<p>I recommend the following rules to decide between <code>const</code> and <code>let</code>:</p>
<ul>
  <li>
    <code>const</code> indicates an immutable binding and that a variable never changes its value. Prefer it.
  </li>
  <li>
    <code>let</code> indicates that the value of a variable changes. Use it only when you can’t use <code>const</code>.
  </li>
</ul>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: <code>const</code></strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/variables-assignment/const_exrc.mjs</code></p>
</div>
<h3 id="variable-scope"><a class="heading-id-link" href="#variable-scope">13.4 The scope of a variable</a></h3>
<p><span id="index-entry-scope-of-a-variable"/><span id="index-entry-variable--scope-of-a"/></p>
<p>The <em>scope</em> of a variable is the region of a program where it can be accessed. Consider the following code.</p>
<pre class="language-js">
<code>{ <span class="hljs-comment">// // Scope A. Accessible: x</span></code>
<code>  <span class="hljs-keyword">const</span> x = <span class="hljs-number">0</span>;</code>
<code>  assert.<span class="hljs-title function_">equal</span>(x, <span class="hljs-number">0</span>);</code>
<code>  { <span class="hljs-comment">// Scope B. Accessible: x, y</span></code>
<code>    <span class="hljs-keyword">const</span> y = <span class="hljs-number">1</span>;</code>
<code>    assert.<span class="hljs-title function_">equal</span>(x, <span class="hljs-number">0</span>);</code>
<code>    assert.<span class="hljs-title function_">equal</span>(y, <span class="hljs-number">1</span>);</code>
<code>    { <span class="hljs-comment">// Scope C. Accessible: x, y, z</span></code>
<code>      <span class="hljs-keyword">const</span> z = <span class="hljs-number">2</span>;</code>
<code>      assert.<span class="hljs-title function_">equal</span>(x, <span class="hljs-number">0</span>);</code>
<code>      assert.<span class="hljs-title function_">equal</span>(y, <span class="hljs-number">1</span>);</code>
<code>      assert.<span class="hljs-title function_">equal</span>(z, <span class="hljs-number">2</span>);</code>
<code>    }</code>
<code>  }</code>
<code>}</code>
<code><span class="hljs-comment">// Outside. Not accessible: x, y, z</span></code>
<code>assert.<span class="hljs-title function_">throws</span>(</code>
<code>  <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x),</code>
<code>  {</code>
<code>    <span class="hljs-attr">name</span>: <span class="hljs-string">'ReferenceError'</span>,</code>
<code>    <span class="hljs-attr">message</span>: <span class="hljs-string">'x is not defined'</span>,</code>
<code>  }</code>
<code>);</code>
</pre>
<ul>
  <li>
    Scope A is the <em>(direct) scope</em> of <code>x</code>.
  </li>
  <li>
    Scopes B and C are <em>inner scopes</em> of scope A.
  </li>
  <li>
    Scope A is an <em>outer scope</em> of scope B and scope C.
  </li>
</ul>
<p>Each variable is accessible in its direct scope and all scopes nested within that scope.</p>
<p>The variables declared via <code>const</code> and <code>let</code> are called <em>block-scoped</em> because their scopes are always the innermost surrounding blocks.</p>
<h4 id="shadowing-variables"><a class="heading-id-link" href="#shadowing-variables">13.4.1 Shadowing variables</a></h4>
<p><span id="index-entry-shadowing"/></p>
<p>We can’t declare the same variable twice at the same level:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">throws</span>(</code>
<code>  <span class="hljs-function">() =&gt;</span> {</code>
<code>    <span class="hljs-built_in">eval</span>(<span class="hljs-string">'let x = 1; let x = 2;'</span>);</code>
<code>  },</code>
<code>  {</code>
<code>    <span class="hljs-attr">name</span>: <span class="hljs-string">'SyntaxError'</span>,</code>
<code>    <span class="hljs-attr">message</span>: <span class="hljs-string">"Identifier 'x' has already been declared"</span>,</code>
<code>  }</code>
<code>);</code>
</pre>
<div class="boxout">
  <p><img src="../Images/38ba63de820aae6f94a019538ae0f222.png" class="boxout-icon" height="24" alt="Icon “details”" data-original-src="https://exploringjs.com/js/book/icon/details.svg"/> <strong>Why <code>eval()</code>?</strong></p>
  <div class="boxout-vspace"/>
  <p><a href="ch_dynamic-code-evaluation.html#eval"><code>eval()</code></a> delays parsing (and therefore the <code>SyntaxError</code>), until the callback of <code>assert.throws()</code> is executed. If we didn’t use it, we’d already get an error when this code is parsed and <code>assert.throws()</code> wouldn’t even be executed.</p>
</div>
<p>We can, however, nest a block and use the same variable name <code>x</code> that we used outside the block:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> x = <span class="hljs-number">1</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(x, <span class="hljs-number">1</span>);</code>
<code>{</code>
<code>  <span class="hljs-keyword">const</span> x = <span class="hljs-number">2</span>;</code>
<code>  assert.<span class="hljs-title function_">equal</span>(x, <span class="hljs-number">2</span>);</code>
<code>}</code>
<code>assert.<span class="hljs-title function_">equal</span>(x, <span class="hljs-number">1</span>);</code>
</pre>
<p>Inside the block, the inner <code>x</code> is the only accessible variable with that name. The inner <code>x</code> is said to <em>shadow</em> the outer <code>x</code>. Once we leave the block, we can access the old value again.</p>
<h3 id="advanced-1"><a class="heading-id-link" href="#advanced-1">13.5 (Advanced)</a></h3>
<p>All remaining sections are advanced.</p>
<h3 id="programming-languages-static-vs-dynamic"><a class="heading-id-link" href="#programming-languages-static-vs-dynamic">13.6 Terminology: static vs. dynamic</a></h3>
<p><span id="index-entry-static-vs.-dynamic"/><span id="index-entry-dynamic-vs.-static"/></p>
<p>These two adjectives describe phenomena in programming languages:</p>
<ul>
  <li>
    <em>Static</em> means that something is related to source code and can be determined without executing code.
  </li>
  <li>
    <em>Dynamic</em> means at runtime.
  </li>
</ul>
<p>Let’s look at examples of these two terms.</p>
<h4 id="static-phenomenon-scopes-of-variables"><a class="heading-id-link" href="#static-phenomenon-scopes-of-variables">13.6.1 Static phenomenon: scopes of variables</a></h4>
<p>Variable scopes are a static phenomenon. Consider the following code:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">const</span> x = <span class="hljs-number">3</span>;</span></code>
<code><span class="hljs-params">  <span class="hljs-comment">// ···</span></span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p><code>x</code> is <em>statically</em> (or <em>lexically</em>) <em>scoped</em>. That is, its scope is fixed and doesn’t change at runtime.</p>
<p>Variable scopes form a static tree (via static nesting).</p>
<h4 id="dynamic-phenomenon-function-calls"><a class="heading-id-link" href="#dynamic-phenomenon-function-calls">13.6.2 Dynamic phenomenon: function calls</a></h4>
<p>Function calls are a dynamic phenomenon. Consider the following code:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span>(<span class="hljs-params">x</span>) {}</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">y</span>) {</code>
<code>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()) <span class="hljs-title function_">g</span>(y); <span class="hljs-comment">// (A)</span></code>
<code>}</code>
</pre>
<p>Whether or not the function call in line A happens, can only be decided at runtime.</p>
<p>Function calls form a dynamic tree (via dynamic calls).</p>
<h3 id="global-variable-scopes"><a class="heading-id-link" href="#global-variable-scopes">13.7 The scopes of JavaScript’s global variables</a></h3>
<p><span id="index-entry-global-variable"/>
<span id="index-entry-global-scope"/>
<span id="index-entry-global-object"/></p>
<p>JavaScript’s variable scopes are nested. They form a tree:</p>
<ul>
  <li>
    The outermost scope is the root of the tree.
  </li>
  <li>
    The scopes directly contained in that scope are the children of the root.
  </li>
  <li>
    And so on.
  </li>
</ul>
<p>The root is also called the <em>global scope</em>. In web browsers, the only location where one is directly in that scope is at the top level of a script. The variables of the global scope are called <em>global variables</em> and accessible everywhere. There are two kinds of global variables:</p>
<ul>
  <li>
    <p><em>Global declarative variables</em> are normal variables:</p>
    <ul>
      <li>
        They can only be created while at the top level of a script, via <code>const</code>, <code>let</code>, and class declarations.
      </li>
    </ul>
  </li>
  <li>
    <p><em>Global object variables</em> are stored in properties of the so-called <em>global object</em>:</p>
    <ul>
      <li>
        They are created in the top level of a script, via <code>var</code> and function declarations.
      </li>
      <li>
        The global object can be accessed via the global variable <code>globalThis</code>. It can be used to create, read, and delete global object variables.
      </li>
      <li>
        Other than that, global object variables work like normal variables.
      </li>
    </ul>
  </li>
</ul>
<p>The following HTML fragment demonstrates <code>globalThis</code> and the two kinds of global variables.</p>
<pre class="language-html">
<code><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></code>
<code><span class="language-javascript">  <span class="hljs-keyword">const</span> declarativeVariable = <span class="hljs-string">'d'</span>;</span></code>
<code><span class="language-javascript">  <span class="hljs-keyword">var</span> objectVariable = <span class="hljs-string">'o'</span>;</span></code>
<code><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code>
<code><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></code>
<code><span class="language-javascript">  <span class="hljs-comment">// All scripts share the same top-level scope:</span></span></code>
<code><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(declarativeVariable); <span class="hljs-comment">// 'd'</span></span></code>
<code><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objectVariable); <span class="hljs-comment">// 'o'</span></span></code>
<code><span class="language-javascript">  </span></code>
<code><span class="language-javascript">  <span class="hljs-comment">// Not all declarations create properties of the global object:</span></span></code>
<code><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalThis.<span class="hljs-property">declarativeVariable</span>); <span class="hljs-comment">// undefined</span></span></code>
<code><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalThis.<span class="hljs-property">objectVariable</span>); <span class="hljs-comment">// 'o'</span></span></code>
<code><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code>
</pre>
<p>Each module has its own variable scope that is a direct child of the global scope. Therefore, variables that exist at the top level of a module are not global. <a href="#fig:global-scope">Figure 13.1</a> illustrates how the various scopes are related.</p>
<figure id="fig:global-scope" class="float">
  <p><img src="../Images/52eed01843eedb709d2fd13429ec233c.png" height="223" alt="" style="width:397.5703px" data-original-src="https://exploringjs.com/js/book/img/variables-assignment/global-scope.svg"/></p>
  <figcaption>
    <p><span class="float-label">Figure 13.1:</span> The global scope is JavaScript’s outermost scope. It has two kinds of variables: <em>object variables</em> (managed via the <em>global object</em>) and normal <em>declarative variables</em>. Each ECMAScript module has its own scope which is contained in the global scope.</p>
  </figcaption>
</figure>
<h4 id="globalThis"><a class="heading-id-link" href="#globalThis">13.7.1 <code>globalThis</code><span> <sup>ES2020</sup></span></a></h4>
<p><span id="index-entry-globalThis"/></p>
<p>The global variable <code>globalThis</code> is the standard way of accessing the global object. It got its name from the fact that it has the same value as <code>this</code> in global scope (script scope, not module scope).</p>
<div class="boxout">
  <p><img src="../Images/38ba63de820aae6f94a019538ae0f222.png" class="boxout-icon" height="24" alt="Icon “details”" data-original-src="https://exploringjs.com/js/book/icon/details.svg"/> <strong><code>globalThis</code> does not always directly point to the global object</strong></p>
  <div class="boxout-vspace"/>
  <p>For example, in browsers, <a href="https://exploringjs.com/deep-js/ch_global-scope.html#window-proxy">there is an indirection</a>. That indirection is normally not noticable, but it is there and can be observed.</p>
</div>
<h5 id="alternatives-to-globalthis"><a class="heading-id-link" href="#alternatives-to-globalthis">13.7.1.1 Alternatives to <code>globalThis</code></a></h5>
<p><span id="index-entry-window"/>
<span id="index-entry-self"/>
<span id="index-entry-global"/></p>
<p>The following global variables let us access the global object on <em>some</em> platforms:</p>
<ul>
  <li>
    <code>window</code>: The classic way of referring to the global object. But it doesn’t work in Node.js and in Web Workers.
  </li>
  <li>
    <code>self</code>: Available in Web Workers and browsers in general. But it isn’t supported by Node.js.
  </li>
  <li>
    <code>global</code>: Only available in Node.js.
  </li>
</ul>
<table class="framed">
  <style>
    th:nth-child(1), td:nth-child(1) {
      text-align: left;
    }
    th:nth-child(2), td:nth-child(2) {
      text-align: left;
    }
    th:nth-child(3), td:nth-child(3) {
      text-align: left;
    }
    th:nth-child(4), td:nth-child(4) {
      text-align: left;
    }
  </style>
  <thead>
    <tr>
      <th/><th>Main browser thread</th><th>Web Workers</th><th>Node.js</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>globalThis</code></td><td>✔</td><td>✔</td><td>✔</td>
    </tr>
    <tr>
      <td><code>window</code></td><td>✔</td><td/><td/>
    </tr>
    <tr>
      <td><code>self</code></td><td>✔</td><td>✔</td><td/>
    </tr>
    <tr>
      <td><code>global</code></td><td/><td/><td>✔</td>
    </tr>
  </tbody>
</table>
<h5 id="use-cases-for-globalthis"><a class="heading-id-link" href="#use-cases-for-globalthis">13.7.1.2 Use cases for <code>globalThis</code></a></h5>
<p>The global object is now considered a mistake that JavaScript can’t get rid of, due to backward compatibility. It affects performance negatively and is generally confusing.</p>
<p>ECMAScript 6 introduced several features that make it easier to avoid the global object – for example:</p>
<ul>
  <li>
    <code>const</code>, <code>let</code>, and class declarations don’t create global object properties when used in global scope.
  </li>
  <li>
    Each ECMAScript module has its own local scope.
  </li>
</ul>
<p>It is usually better to access global object variables via variables and not via properties of <code>globalThis</code>. The former has always worked the same on all JavaScript platforms.</p>
<p>Tutorials on the web occasionally access global variables <code>globVar</code> via <code>window.globVar</code>. But the prefix “<code>window.</code>” is not necessary and I recommend to omit it:</p>
<pre class="language-js">
<code><span class="hljs-variable language_">window</span>.<span class="hljs-built_in">encodeURIComponent</span>(str); <span class="hljs-comment">// no</span></code>
<code><span class="hljs-built_in">encodeURIComponent</span>(str); <span class="hljs-comment">// yes</span></code>
</pre>
<p>Therefore, there are relatively few use cases for <code>globalThis</code> – for example:</p>
<ul>
  <li>
    <a href="ch_modules.html#polyfills"><em>Polyfills</em></a> that add new features to old JavaScript engines.
  </li>
  <li>
    Feature detection, to find out what features a JavaScript engine supports.
  </li>
</ul>
<h3 id="declarations-scope-activation"><a class="heading-id-link" href="#declarations-scope-activation">13.8 Declarations: scope and activation</a></h3>
<p>These are two key aspects of declarations:</p>
<ul>
  <li>
    Scope: Where can a declared entity be seen? This is a static trait.
  </li>
  <li>
    Activation: When can I access an entity? This is a dynamic trait. Some entities can be accessed as soon as we enter their scopes. For others, we have to wait until execution reaches their declarations.
  </li>
</ul>
<p>The following table summarizes how various declarations handle these aspects:</p>
<table class="framed">
  <style>
    th:nth-child(1), td:nth-child(1) {
      text-align: left;
    }
    th:nth-child(2), td:nth-child(2) {
      text-align: left;
    }
    th:nth-child(3), td:nth-child(3) {
      text-align: left;
    }
    th:nth-child(4), td:nth-child(4) {
      text-align: left;
    }
    th:nth-child(5), td:nth-child(5) {
      text-align: left;
    }
  </style>
  <thead>
    <tr>
      <th/><th>Scope</th><th>Activation</th><th>Duplicates</th><th>Global prop.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>const</code></td><td>Block</td><td>decl. (TDZ)</td><td>✘</td><td>✘</td>
    </tr>
    <tr>
      <td><code>let</code></td><td>Block</td><td>decl. (TDZ)</td><td>✘</td><td>✘</td>
    </tr>
    <tr>
      <td><code>function</code></td><td>Block (*)</td><td>start</td><td>✔</td><td>✔</td>
    </tr>
    <tr>
      <td><code>class</code></td><td>Block</td><td>decl. (TDZ)</td><td>✘</td><td>✘</td>
    </tr>
    <tr>
      <td><code>import</code></td><td>Module</td><td>start</td><td>✘</td><td>✘</td>
    </tr>
    <tr>
      <td><code>var</code></td><td>Function</td><td>start (partially)</td><td>✔</td><td>✔</td>
    </tr>
  </tbody>
</table>
<p>(*) Function declarations are normally block-scoped, but function-scoped in <a href="ch_syntax.html#strict-mode">non-strict mode</a>.</p>
<p>Aspects of declarations:</p>
<ul>
  <li>
    For most constructs, their scope is the innermost surrounding block. There are two exceptions:
    <ul>
      <li>
        <code>import</code> can only be used at the top level of a module.
      </li>
      <li>
        The scope of a variable declared via <code>var</code> is its innermost surrounding function (not block).
      </li>
    </ul>
  </li>
  <li>
    The activation of the constructs (when we can access them) varies and is described in more detail later – e.g., <em>TDZ</em> means <em>temporal dead zone</em>.
  </li>
  <li>
    “Duplicates” describes if a declaration can be used twice with the same name (per scope).
  </li>
  <li>
    “Global prop.” describes if a declaration adds a property to the global object, when it is executed in the global scope of a script.
  </li>
</ul>
<p><code>import</code> is described in <a href="ch_modules.html#ecmascript-modules">“ECMAScript modules” (§29.5)</a>. The following subsections describe the other constructs and phenomena in more detail.</p>
<h4 id="temporal-dead-zone"><a class="heading-id-link" href="#temporal-dead-zone">13.8.1 <code>const</code> and <code>let</code>: temporal dead zone</a></h4>
<p><span id="index-entry-temporal-dead-zone"/><span id="index-entry-TDZ--temporal-dead-zone-"/></p>
<h5 id="what-to-do-when-a-variable-is-accessed-before-its-declaration"><a class="heading-id-link" href="#what-to-do-when-a-variable-is-accessed-before-its-declaration">13.8.1.1 What to do when a variable is accessed before its declaration?</a></h5>
<p>For JavaScript, TC39 needed to decide what happens if we access a constant in its direct scope, before its declaration:</p>
<pre class="language-js">
<code>{</code>
<code>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// What happens here?</span></code>
<code>  <span class="hljs-keyword">const</span> x = <span class="hljs-number">123</span>;</code>
<code>}</code>
</pre>
<p>Some possible approaches are:</p>
<ol>
  <li>
    The name is resolved in the scope surrounding the current scope.
  </li>
  <li>
    We get <code>undefined</code>.
  </li>
  <li>
    There is an error.
  </li>
</ol>
<p>Approach 1 was rejected because there is no precedent in the language for this approach. It would therefore not be intuitive to JavaScript programmers.</p>
<p>Approach 2 was rejected because then <code>x</code> wouldn’t be a constant – it would have different values before and after its declaration.</p>
<p><code>let</code> uses the same approach 3 as <code>const</code>, so that both work similarly and it’s easy to switch between them.</p>
<h5 id="the-temporal-dead-zone"><a class="heading-id-link" href="#the-temporal-dead-zone">13.8.1.2 The temporal dead zone</a></h5>
<p>The time between entering the scope of a variable and executing its declaration is called the <em>temporal dead zone</em> (TDZ) of that variable:</p>
<ul>
  <li>
    During this time, the variable is considered to be uninitialized (as if that were a special value it has).
  </li>
  <li>
    If we access an uninitialized variable, we get a <code>ReferenceError</code>.
  </li>
  <li>
    Once we reach a variable declaration, the variable is set to either the value of the initializer (specified via the assignment symbol) or <code>undefined</code> – if there is no initializer.
  </li>
</ul>
<p>The following code illustrates the temporal dead zone:</p>
<pre class="language-js">
<code><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) { <span class="hljs-comment">// entering scope of `tmp`, TDZ starts</span></code>
<code>  <span class="hljs-comment">// `tmp` is uninitialized:</span></code>
<code>  assert.<span class="hljs-title function_">throws</span>(<span class="hljs-function">() =&gt;</span> (tmp = <span class="hljs-string">'abc'</span>), <span class="hljs-title class_">ReferenceError</span>);</code>
<code>  assert.<span class="hljs-title function_">throws</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tmp), <span class="hljs-title class_">ReferenceError</span>);</code>
<code/>
<code>  <span class="hljs-keyword">let</span> tmp; <span class="hljs-comment">// TDZ ends</span></code>
<code>  assert.<span class="hljs-title function_">equal</span>(tmp, <span class="hljs-literal">undefined</span>);</code>
<code>}</code>
</pre>
<p>The next example shows that the temporal dead zone is truly <em>temporal</em> (related to time):</p>
<pre class="language-js">
<code><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) { <span class="hljs-comment">// entering scope of `myVar`, TDZ starts</span></code>
<code>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params">) =&gt; {</span></code>
<code><span class="hljs-params">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myVar); <span class="hljs-comment">// executed later</span></span></code>
<code><span class="hljs-params">  };</span></code>
<code/>
<code><span class="hljs-params">  <span class="hljs-comment">// We are within the TDZ:</span></span></code>
<code><span class="hljs-params">  <span class="hljs-comment">// Accessing `myVar` causes `ReferenceError`</span></span></code>
<code/>
<code><span class="hljs-params">  <span class="hljs-keyword">let</span> myVar = <span class="hljs-number">3</span>; <span class="hljs-comment">// TDZ ends</span></span></code>
<code><span class="hljs-params">  <span class="hljs-title function_">func</span>(); <span class="hljs-comment">// OK, called outside TDZ</span></span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p>Even though <code>func()</code> is located before the declaration of <code>myVar</code> and uses that variable, we can call <code>func()</code>. But we have to wait until the temporal dead zone of <code>myVar</code> is over.</p>
<h4 id="early-activation"><a class="heading-id-link" href="#early-activation">13.8.2 Function declarations and early activation</a></h4>
<p><span id="index-entry-early-activation"/></p>
<div class="boxout">
  <p><img src="../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png" class="boxout-icon" height="24" alt="Icon “reading”" data-original-src="https://exploringjs.com/js/book/icon/reading.svg"/> <strong>More information on functions</strong></p>
  <div class="boxout-vspace"/>
  <p>In this section, we are using functions – before we had a chance to learn them properly. Hopefully, everything still makes sense. Whenever it doesn’t, please see <a href="ch_callables.html#ch_callables">“Callable values” (§27)</a>.</p>
</div>
<p>A function declaration is always executed when entering its scope, regardless of where it is located within that scope. That enables us to call a function <code>funcDecl()</code> before it is declared.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">funcDecl</span>(), <span class="hljs-number">123</span>); <span class="hljs-comment">// OK</span></code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">funcDecl</span>(<span class="hljs-params">) { <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>; }</span></code>
</pre>
<p>The early activation of <code>funcDecl()</code> means that the previous code is equivalent to:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">funcDecl</span>(<span class="hljs-params">) { <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>; }</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">funcDecl</span>(), <span class="hljs-number">123</span>);</span></code>
</pre>
<p>If we declare a function via <code>const</code> or <code>let</code>, then it is not activated early. In the following example, we can only use <code>arrowFunc()</code> after its declaration.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">throws</span>(</code>
<code>  <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">arrowFunc</span>(), <span class="hljs-comment">// before declaration</span></code>
<code>  <span class="hljs-title class_">ReferenceError</span></code>
<code>);</code>
<code/>
<code><span class="hljs-keyword">const</span> <span class="hljs-title function_">arrowFunc</span> = (<span class="hljs-params">) =&gt; { <span class="hljs-keyword">return</span> <span class="hljs-number">123</span> };</span></code>
<code/>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">arrowFunc</span>(), <span class="hljs-number">123</span>); <span class="hljs-comment">// after declaration </span></span></code>
</pre>
<h5 id="calling-ahead-without-early-activation"><a class="heading-id-link" href="#calling-ahead-without-early-activation">13.8.2.1 Calling ahead without early activation</a></h5>
<p>A function <code>f()</code> can call a function <code>g()</code> that is declared later and not activated early – as long as we invoke <code>f()</code> after the declaration of <code>g()</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params">) =&gt; <span class="hljs-title function_">g</span>();</span></code>
<code><span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-title function_">g</span> = (<span class="hljs-params"/>) =&gt; <span class="hljs-number">123</span>;</span></code>
<code/>
<code><span class="hljs-params"><span class="hljs-comment">// We call f() after g() was declared:</span></span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">f</span>(), <span class="hljs-number">123</span>); <span class="hljs-comment">// OK</span></span></code>
</pre>
<p>The functions of a module are usually invoked after its complete body is executed. Therefore, in modules, we rarely need to worry about the order of functions (even if they are not function declarations).</p>
<h5 id="a-pitfall-of-early-activation"><a class="heading-id-link" href="#a-pitfall-of-early-activation">13.8.2.2 A pitfall of early activation</a></h5>
<p>If we rely on early activation to call a function before its declaration, then we need to be careful that it doesn’t access data that isn’t activated early.</p>
<pre class="language-js">
<code><span class="hljs-title function_">funcDecl</span>();</code>
<code/>
<code><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MY_STR</span> = <span class="hljs-string">'abc'</span>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">funcDecl</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  assert.<span class="hljs-title function_">throws</span>(</span></code>
<code><span class="hljs-params">    <span class="hljs-function">() =&gt;</span> <span class="hljs-variable constant_">MY_STR</span>,</span></code>
<code><span class="hljs-params">    <span class="hljs-title class_">ReferenceError</span></span></code>
<code><span class="hljs-params">  );</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p>The problem goes away if we make the call to <code>funcDecl()</code> after the declaration of <code>MY_STR</code>.</p>
<h5 id="the-pros-and-cons-of-early-activation"><a class="heading-id-link" href="#the-pros-and-cons-of-early-activation">13.8.2.3 The pros and cons of early activation</a></h5>
<p>We have seen that early activation has a pitfall and that we can get most of its benefits without using it. Therefore, it is better to avoid early activation. But I don’t feel strongly about this and, as mentioned before, often use function declarations because I like their syntax.</p>
<h4 id="class-declarations-are-not-activated-early"><a class="heading-id-link" href="#class-declarations-are-not-activated-early">13.8.3 Class declarations are not activated early</a></h4>
<p>Even though they are similar to function declarations in some ways, <a href="ch_classes.html#classes">class declarations</a> are not activated early:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">throws</span>(</code>
<code>  <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>(),</code>
<code>  <span class="hljs-title class_">ReferenceError</span></code>
<code>);</code>
<code/>
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {}</code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>() <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyClass</span>, <span class="hljs-literal">true</span>);</code>
</pre>
<p>Why is that? Consider the following class declaration:</p>
<pre class="language-js">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Object</span> {}</code>
</pre>
<p>The operand of <code>extends</code> is an expression. Therefore, we can do things like this:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> <span class="hljs-title function_">identity</span> = x =&gt; x;</code>
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">identity</span>(<span class="hljs-title class_">Object</span>) {}</code>
</pre>
<p>Evaluating such an expression must be done at the location where it is mentioned. Anything else would be confusing. That explains why class declarations are not activated early.</p>
<h4 id="hoisting"><a class="heading-id-link" href="#hoisting">13.8.4 <code>var</code>: hoisting (partial early activation)</a></h4>
<p><span id="index-entry-hoisting"/></p>
<p><code>var</code> is an older way of declaring variables that predates <code>const</code> and <code>let</code> (which are preferred now). Consider the following <code>var</code> declaration.</p>
<pre class="language-js">
<code><span class="hljs-keyword">var</span> x = <span class="hljs-number">123</span>;</code>
</pre>
<p>This declaration has two parts:</p>
<ul>
  <li>
    Declaration <code>var x</code>: The scope of a <code>var</code>-declared variable is the innermost surrounding function and not the innermost surrounding block, as for most other declarations. Such a variable is already active at the beginning of its scope and initialized with <code>undefined</code>.
  </li>
  <li>
    Assignment <code>x = 123</code>: The assignment is always executed in place.
  </li>
</ul>
<p>The following code demonstrates the effects of <code>var</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-comment">// Partial early activation:</span></span></code>
<code><span class="hljs-params">  assert.<span class="hljs-title function_">equal</span>(x, <span class="hljs-literal">undefined</span>);</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">var</span> x = <span class="hljs-number">123</span>;</span></code>
<code><span class="hljs-params">    <span class="hljs-comment">// The assignment is executed in place:</span></span></code>
<code><span class="hljs-params">    assert.<span class="hljs-title function_">equal</span>(x, <span class="hljs-number">123</span>);</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">  <span class="hljs-comment">// Scope is function, not block:</span></span></code>
<code><span class="hljs-params">  assert.<span class="hljs-title function_">equal</span>(x, <span class="hljs-number">123</span>);</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<h3 id="closures"><a class="heading-id-link" href="#closures">13.9 Closures</a></h3>
<p><span id="index-entry-closure"/></p>
<p>Before we can explore closures, we need to learn about bound variables and free variables.</p>
<h4 id="bound-variables-vs-free-variables"><a class="heading-id-link" href="#bound-variables-vs-free-variables">13.9.1 Bound variables vs. free variables</a></h4>
<p><span id="index-entry-bound-variable"/><span id="index-entry-variable--bound"/>
<span id="index-entry-free-variable"/><span id="index-entry-variable--free"/></p>
<p>Per scope, there is a set of variables that are mentioned. Among these variables we distinguish:</p>
<ul>
  <li>
    <em>Bound variables</em> are declared within the scope. They are parameters and local variables.
  </li>
  <li>
    <em>Free variables</em> are declared externally. They are also called <em>non-local variables</em>.
  </li>
</ul>
<p>Consider the following code:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x</span>) {</code>
<code>  <span class="hljs-keyword">const</span> y = <span class="hljs-number">123</span>;</code>
<code>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(z);</code>
<code>}</code>
</pre>
<p>In the body of <code>func()</code>, <code>x</code> and <code>y</code> are bound variables. <code>z</code> is a free variable.</p>
<h4 id="what-is-a-closure"><a class="heading-id-link" href="#what-is-a-closure">13.9.2 What is a closure?</a></h4>
<p>What is a closure then? A <em>closure</em> is a function plus a connection to the variables that exist at its “birth place”.</p>
<p>What is the point of keeping this connection? It provides the values for the free variables of the function – for example:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">funcFactory</span>(<span class="hljs-params">value</span>) {</code>
<code>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {</code>
<code>    <span class="hljs-keyword">return</span> value;</code>
<code>  };</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">const</span> func = <span class="hljs-title function_">funcFactory</span>(<span class="hljs-string">'abc'</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">func</span>(), <span class="hljs-string">'abc'</span>); <span class="hljs-comment">// (A)</span></code>
</pre>
<p><code>funcFactory</code> returns a closure that is assigned to <code>func</code>. Because <code>func</code> has the connection to the variables at its birth place, it can still access the free variable <code>value</code> when it is called in line A (even though it “escaped” its scope).</p>
<div class="boxout">
  <p><img src="../Images/8440b17bb8219cda9f9405ac83c36db0.png" class="boxout-icon" height="24" alt="Icon “tip”" data-original-src="https://exploringjs.com/js/book/icon/tip.svg"/> <strong>All functions in JavaScript are closures</strong></p>
  <div class="boxout-vspace"/>
  <p>Static scoping is supported via closures in JavaScript. Therefore, every function is a closure.</p>
</div>
<h4 id="example-a-factory-for-incrementors"><a class="heading-id-link" href="#example-a-factory-for-incrementors">13.9.3 Example: A factory for incrementors</a></h4>
<p>The following function returns <em>incrementors</em> (a name that I just made up). An incrementor is a function that internally stores a number. When it is called, it updates that number by adding the argument to it and returns the new value.</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">createInc</span>(<span class="hljs-params">startValue</span>) {</code>
<code>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">step</span>) =&gt;</span> { <span class="hljs-comment">// (A)</span></code>
<code>    startValue += step;</code>
<code>    <span class="hljs-keyword">return</span> startValue;</code>
<code>  };</code>
<code>}</code>
<code><span class="hljs-keyword">const</span> inc = <span class="hljs-title function_">createInc</span>(<span class="hljs-number">5</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">inc</span>(<span class="hljs-number">2</span>), <span class="hljs-number">7</span>);</code>
</pre>
<p>We can see that the function created in line A keeps its internal number in the free variable <code>startValue</code>. This time, we don’t just read from the birth scope, we use it to store data that we change and that persists across function calls.</p>
<p>We can create more storage slots in the birth scope, via local variables:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">createInc</span>(<span class="hljs-params">startValue</span>) {</code>
<code>  <span class="hljs-keyword">let</span> index = -<span class="hljs-number">1</span>;</code>
<code>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">step</span>) =&gt;</span> {</code>
<code>    startValue += step;</code>
<code>    index++;</code>
<code>    <span class="hljs-keyword">return</span> [index, startValue];</code>
<code>  };</code>
<code>}</code>
<code><span class="hljs-keyword">const</span> inc = <span class="hljs-title function_">createInc</span>(<span class="hljs-number">5</span>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-title function_">inc</span>(<span class="hljs-number">2</span>), [<span class="hljs-number">0</span>, <span class="hljs-number">7</span>]);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-title function_">inc</span>(<span class="hljs-number">2</span>), [<span class="hljs-number">1</span>, <span class="hljs-number">9</span>]);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-title function_">inc</span>(<span class="hljs-number">2</span>), [<span class="hljs-number">2</span>, <span class="hljs-number">11</span>]);</code>
</pre>
<h4 id="use-cases-for-closures"><a class="heading-id-link" href="#use-cases-for-closures">13.9.4 Use cases for closures</a></h4>
<p>What are closures good for?</p>
<ul>
  <li>
    <p>For starters, they are simply an implementation of static scoping. As such, they provide context data for callbacks.</p>
  </li>
  <li>
    <p>They can also be used by functions to store state that persists across function calls. <code>createInc()</code> is an example of that.</p>
  </li>
  <li>
    <p>And they can provide private data for objects (produced via literals or classes). The details of how that works are explained in <a href="https://exploringjs.com/es6/ch_classes.html#_private-data-via-constructor-environments"><em>Exploring ES6</em></a>.</p>
  </li>
</ul>

    
      
</body>
</html>