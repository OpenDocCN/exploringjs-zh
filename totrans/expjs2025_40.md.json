["```js\n// Generator function declaration\nfunction* genFunc1() { /*···*/ }\n\n// Generator function expression\nconst genFunc2 = function* () { /*···*/ };\n\n// Generator method definition in an object literal\nconst obj = {\n * generatorMethod() {\n // ···\n }\n};\n\n// Generator method definition in a class definition\n// (class declaration or class expression)\nclass MyClass {\n * generatorMethod() {\n // ···\n }\n} \n```", "```js\nfunction* createIterator() {\n yield 'a';\n yield 'b';\n}\n\n// Converting the result to an Array\nassert.deepEqual(\n // Using an Iterator method\n createIterator().toArray(),\n ['a', 'b']\n);\nassert.deepEqual(\n // The iterator is iterable, so Array.from() works\n Array.from(createIterator()),\n ['a', 'b']\n);\n\n// We can use for-of because the iterator is iterable\nfor (const x of createIterator()) {\n console.log(x);\n}\n\n```", "```js\na\nb\n\n```", "```js\nlet location = 0;\nfunction* genFunc2() {\n location = 1;\n yield 'a';\n location = 2;\n yield 'b';\n location = 3;\n}\n\n```", "```js\nconst iter = genFunc2();\n// genFunc2() is now paused “before” its body:\nassert.equal(location, 0);\n\n```", "```js\nassert.deepEqual(\n  iter.next(), {value: 'a', done: false});\n// genFunc2() is now paused directly after the first `yield`:\nassert.equal(location, 1);\n\n```", "```js\nassert.deepEqual(\n  iter.next(), {value: 'b', done: false});\n// genFunc2() is now paused directly after the second `yield`:\nassert.equal(location, 2);\n\n```", "```js\nassert.deepEqual(\n  iter.next(), {value: undefined, done: true});\n// We have reached the end of genFunc2():\nassert.equal(location, 3);\n\n```", "```js\n/**\n * Returns an iterator over lines\n */\nfunction* genLines() {\n yield 'A line';\n yield 'Another line';\n yield 'Last line';\n}\n\n/**\n * Input: iterable over lines\n * Output: iterator over numbered lines\n */\nfunction* numberLines(lineIterable) {\n let lineNumber = 1;\n for (const line of lineIterable) { // input\n yield lineNumber + ': ' + line; // output\n lineNumber++;\n }\n}\n\n```", "```js\nconst numberedLines = numberLines(genLines());\nassert.deepEqual(\n  numberedLines.next(),\n  {value: '1: A line', done: false}\n);\nassert.deepEqual(\n  numberedLines.next(),\n  {value: '2: Another line', done: false}\n);\n\n```", "```js\nfunction* mapIter(iterable, func) {\n  let index = 0;\n  for (const x of iterable) {\n    yield func(x, index);\n    index++;\n  }\n}\n\nconst iterator = mapIter(['a', 'b'], x => x + x);\nassert.deepEqual(\n  Array.from(iterator), ['aa', 'bb']\n);\n\n```", "```js\nfunction* helper() {\n yield 'a';\n yield 'b';\n}\nfunction* compute() {\n // Nothing happens if we call `helper()`:\n helper();\n}\nassert.deepEqual(\n Array.from(compute()), []\n); \n```", "```js\nfunction* helper() {\n yield 'a';\n yield 'b';\n}\nfunction* compute() {\n yield* helper();\n}\nassert.deepEqual(\n Array.from(compute()), ['a', 'b']\n); \n```", "```js\nfunction* compute() {\n for (const x of helper()) {\n yield x;\n }\n}\n\n```", "```js\nfunction* gen() {\n yield* [1, 2];\n}\nassert.deepEqual(\n Array.from(gen()), [1, 2]\n);\n\n```", "```js\nclass BinaryTree {\n  constructor(value, left=null, right=null) {\n    this.value = value;\n    this.left = left;\n    this.right = right;\n  }\n\n  /** Prefix iteration: parent before children */\n  * [Symbol.iterator]() {\n    yield this.value;\n    if (this.left) {\n      // Same as yield* this.left[Symbol.iterator]()\n      yield* this.left;\n    }\n    if (this.right) {\n      yield* this.right;\n    }\n  }\n}\n\n```", "```js\nconst tree = new BinaryTree('a',\n  new BinaryTree('b',\n    new BinaryTree('c'),\n    new BinaryTree('d')),\n  new BinaryTree('e'));\n\nfor (const x of tree) {\n  console.log(x);\n}\n\n```", "```js\na\nb\nc\nd\ne\n\n```", "```js\n    for (const x of ['a', 'b']) {\n      console.log(x);\n    }\n\n    ```", "```js\n    a\n    b\n\n    ```", "```js\n    ['a', 'b'].forEach((x) => {\n      console.log(x);\n    });\n\n    ```", "```js\n    a\n    b\n\n    ```", "```js\nfunction logPaths(dir) {\n  for (const fileName of fs.readdirSync(dir)) {\n    const filePath = path.join(dir, fileName);\n    console.log(filePath);\n    const stats = fs.statSync(filePath);\n    if (stats.isDirectory()) {\n      logPaths(filePath); // recursive call\n    }\n  }\n}\n\n```", "```js\nmydir/\n  a.txt\n  b.txt\n  subdir/\n    c.txt\n\n```", "```js\nlogPaths('mydir');\n\n```", "```js\nmydir/a.txt\nmydir/b.txt\nmydir/subdir\nmydir/subdir/c.txt\n\n```", "```js\nfunction visitPaths(dir, callback) {\n  for (const fileName of fs.readdirSync(dir)) {\n    const filePath = path.join(dir, fileName);\n    callback(filePath); // (A)\n    const stats = fs.statSync(filePath);\n    if (stats.isDirectory()) {\n      visitPaths(filePath, callback);\n    }\n  }\n}\nconst paths = [];\nvisitPaths('mydir', p => paths.push(p));\nassert.deepEqual(\n  paths,\n  [\n    'mydir/a.txt',\n    'mydir/b.txt',\n    'mydir/subdir',\n    'mydir/subdir/c.txt',\n  ]);\n\n```", "```js\nfunction* iterPaths(dir) {\n  for (const fileName of fs.readdirSync(dir)) {\n    const filePath = path.join(dir, fileName);\n    yield filePath; // (A)\n    const stats = fs.statSync(filePath);\n    if (stats.isDirectory()) {\n      yield* iterPaths(filePath);\n    }\n  }\n}\nconst paths = Array.from(iterPaths('mydir'));\n\n```"]