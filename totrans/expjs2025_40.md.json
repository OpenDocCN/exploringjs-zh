["```js\n// Generator function declaration\nfunction* genFunc1() { /*···*/ }\n `// Generator function expression`\n`const genFunc2 = function* () { /*···*/ };`\n ```", "```js \n```", "```js```", "````js` ````", "```` Asterisks (`*`) mark functions and methods as generators:    *   Functions: The pseudo-keyword `function*` is a combination of the keyword `function` and an asterisk. *   Methods: The `*` is a modifier (similar to `static` and `get`).    #### [33.1.1 Generator functions return iterators and fill them via `yield`](#generators-return-iterators)    If we call a generator function, it returns an iterator (which is also iterable – as all built-in iterators are). The generator fills that iterator via the `yield` operator:    ```js function* createIterator() {  yield 'a';  yield 'b'; }  `// Converting the result to an Array` `assert.deepEqual(`  `// Using an Iterator method`  `createIterator().toArray(),`  `['a', 'b']` `);` `assert.deepEqual(`  `// The iterator is iterable, so Array.from() works`  `Array.from(createIterator()),`  `['a', 'b']` `);`  `` `// We can use for-of because the iterator is iterable` `for (const x of createIterator()) {`  `console.log(x);` `}` ``  ```   ```js````", "```js```", "```js a b  ```", "```js let location = 0; function* genFunc2() {  location = 1;  yield 'a';  location = 2;  yield 'b';  location = 3; }  ```", "```js const iter = genFunc2(); // genFunc2() is now paused “before” its body: assert.equal(location, 0);  ```", "```js assert.deepEqual(  iter.next(), {value: 'a', done: false}); // genFunc2() is now paused directly after the first `yield`: assert.equal(location, 1);  ```", "```js assert.deepEqual(  iter.next(), {value: 'b', done: false}); // genFunc2() is now paused directly after the second `yield`: assert.equal(location, 2);  ```", "```js assert.deepEqual(  iter.next(), {value: undefined, done: true}); // We have reached the end of genFunc2(): assert.equal(location, 3);  ```", "```js /**  * Returns an iterator over lines  */ function* genLines() {  yield 'A line';  yield 'Another line';  yield 'Last line'; }  `/**`  `* Input: iterable over lines`  `* Output: iterator over numbered lines`  `*/` `function* numberLines(lineIterable) {`  `let lineNumber = 1;`  `for (const line of lineIterable) { // input`  `yield lineNumber + ': ' + line; // output`  `lineNumber++;`  `}` `}`  ```", "```js```", "```js const numberedLines = numberLines(genLines()); assert.deepEqual(  numberedLines.next(),  {value: '1: A line', done: false} ); assert.deepEqual(  numberedLines.next(),  {value: '2: Another line', done: false} );  ```", "```js function* mapIter(iterable, func) {  let index = 0;  for (const x of iterable) {  yield func(x, index);  index++;  } }  `const iterator = mapIter(['a', 'b'], x => x + x);` `assert.deepEqual(`  `Array.from(iterator), ['aa', 'bb']` `);`  ```", "```js```", "``` function* helper() {  yield 'a';  yield 'b'; } function* compute() {  // Nothing happens if we call `helper()`:  helper(); } assert.deepEqual(  Array.from(compute()), [] );  ```", "``` function* helper() {  yield 'a';  yield 'b'; } function* compute() {  yield* helper(); } assert.deepEqual(  Array.from(compute()), ['a', 'b'] );  ```", "``` function* compute() {  for (const x of helper()) {  yield x;  } }  ```", "``` function* gen() {  yield* [1, 2]; } assert.deepEqual(  Array.from(gen()), [1, 2] );  ```", "``` class BinaryTree {  constructor(value, left=null, right=null) {  this.value = value;  this.left = left;  this.right = right;  }  `/** Prefix iteration: parent before children */`  `* [Symbol.iterator]() {`  `yield this.value;`  `if (this.left) {`  `// Same as yield* this.left[Symbol.iterator]()`  `yield* this.left;`  `}`  `if (this.right) {`  `yield* this.right;`  `}`  `}` `}`  ```", "````` Method `[Symbol.iterator]()` adds support for the iteration protocol, which means that we can use a `for-of` loop to iterate over an instance of `BinaryTree`:    ```js const tree = new BinaryTree('a',  new BinaryTree('b',  new BinaryTree('c'),  new BinaryTree('d')),  new BinaryTree('e'));  `for (const x of tree) {`  `console.log(x);` `}`  ```   ```js`Output:    ``` a b c d e  ```js    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Iterating over a nested Array**    `exercises/sync-generators/iter_nested_arrays_test.mjs`    ### [33.3 Use case for generators: reusing traversals](#reusing-traversals)    One important use case for generators is extracting and reusing traversals.    #### [33.3.1 Background: external iteration vs. internal iteration](#external-iteration-internal-iteration)    In preparation for the next subsections, we need to learn about two different styles of iterating over the values “inside” an object:    *   External iteration (pull): Our code asks the object for the values via an iteration protocol. For example, the `for-of` loop is based on JavaScript’s iteration protocol:                    ```     for (const x of ['a', 'b']) {      console.log(x);     }          ```js                    Output:                    ```     a     b          ```js           *   Internal iteration (push): We pass a callback function to a method of the object and the method feeds the values to the callback. For example, Arrays have the method `.forEach()`:                    ```     ['a', 'b'].forEach((x) => {      console.log(x);     });          ```js                    Output:                    ```     a     b          ```js              The next subsections have examples of both styles of iteration.    #### [33.3.2 The traversal to reuse](#the-traversal-to-reuse)    As an example, consider the following function that traverses a tree of files and logs their paths (it uses [the Node.js API](https://nodejs.org/docs/latest/api/) for doing so):    ``` function logPaths(dir) {  for (const fileName of fs.readdirSync(dir)) {  const filePath = path.join(dir, fileName);  console.log(filePath);  const stats = fs.statSync(filePath);  if (stats.isDirectory()) {  logPaths(filePath); // recursive call  }  } }  ```js    Consider the following directory:    ``` mydir/  a.txt  b.txt  subdir/  c.txt  ```js    Let’s log the paths inside `mydir/`:    ``` logPaths('mydir');  ```js    Output:    ``` mydir/a.txt mydir/b.txt mydir/subdir mydir/subdir/c.txt  ```js    How can we reuse this traversal and do something other than logging the paths?    #### [33.3.3 Example: internal iteration (push)](#internal-iteration-example)    One way of reusing traversal code is via *internal iteration*: Each traversed value is passed to a callback (line A).    ``` function visitPaths(dir, callback) {  for (const fileName of fs.readdirSync(dir)) {  const filePath = path.join(dir, fileName);  callback(filePath); // (A)  const stats = fs.statSync(filePath);  if (stats.isDirectory()) {  visitPaths(filePath, callback);  }  } } const paths = []; visitPaths('mydir', p => paths.push(p)); assert.deepEqual(  paths,  [  'mydir/a.txt',  'mydir/b.txt',  'mydir/subdir',  'mydir/subdir/c.txt',  ]);  ```js    #### [33.3.4 External iteration (pull)](#external-iteration-example)    Another way of reusing traversal code is via *external iteration*: We can write a generator that yields all traversed values (line A).    ``` function* iterPaths(dir) {  for (const fileName of fs.readdirSync(dir)) {  const filePath = path.join(dir, fileName);  yield filePath; // (A)  const stats = fs.statSync(filePath);  if (stats.isDirectory()) {  yield* iterPaths(filePath);  }  } } const paths = Array.from(iterPaths('mydir'));  ```js    ### [33.4 Advanced features of generators](#advanced-features-of-generators)    [The chapter on generators](https://exploringjs.com/es6/ch_generators.html) in *Exploring ES6* covers two features that are beyond the scope of this book:    *   `yield` can also *receive* data, via an argument of `.next()`. *   Generators can also `return` values (not just `yield` them). Such values do not become iteration values, but can be retrieved via `yield*`.```` ```js`` `````", "``````js` ``````", "``````js``` ``````", "```` ```js````"]