<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>12 Strategies for migrating to TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>12 Strategies for migrating to TypeScript</h1>
<blockquote>原文：<a href="https://exploringjs.com/ts/book/ch_migrating-to-typescript.html">https://exploringjs.com/ts/book/ch_migrating-to-typescript.html</a></blockquote>

    
        <div id="adbox">
      <div id="adbox-explain">(Ad, please don’t block.)</div>
              
          </div>
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#strategy-mixed-javascript-typescript-code-bases">12.1 Strategy: mixed JavaScript/TypeScript code bases</a>
    </li>
    <li>
      <a href="#strategy-adding-type-information-to-plain-javascript-files">12.2 Strategy: adding type information to plain JavaScript files</a>
    </li>
    <li>
      <a href="#strategy-linting-before-activating-a-compiler-option">12.3 Strategy: linting before activating a compiler option</a>
    </li>
    <li>
      <a href="#strategy-too-many-errors-use-snapshot-testing">12.4 Strategy: Too many errors? Use snapshot testing</a>
    </li>
    <li>
      <a href="#tools-that-help-with-migrating-to-typescript">12.5 Tools that help with migrating to TypeScript</a>
    </li>
    <li>
      <a href="#conclusion-and-further-reading">12.6 Conclusion and further reading</a>
    </li>
  </ol>
</nav>
<p>This chapter gives an overview of strategies for migrating code bases from JavaScript to TypeScript. It also mentions material for further reading.</p>
<h3 id="strategy-mixed-javascript-typescript-code-bases"><a class="heading-id-link" href="#strategy-mixed-javascript-typescript-code-bases">12.1 Strategy: mixed JavaScript/TypeScript code bases</a></h3>
<p>The TypeScript compiler supports a mix of JavaScript and TypeScript files if we use the compiler option <code>--allowJs</code>:</p>
<ul>
  <li>
    TypeScript files are compiled.
  </li>
  <li>
    JavaScript files are simply copied over to the output directory (after a few simple type checks).
  </li>
</ul>
<p>At first, there are only JavaScript files. Then, one by one, we switch files to TypeScript. While we do so, our code base keeps being compiled.</p>
<p>This is what <code>tsconfig.json</code> looks like:</p>
<pre class="language-json">
<code><span class="hljs-punctuation">{</span></code>
<code>  <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>    ···</code>
<code>    <span class="hljs-attr">"allowJs"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span></code>
<code>  <span class="hljs-punctuation">}</span></code>
<code><span class="hljs-punctuation">}</span></code>
</pre>
<p><strong>More information:</strong></p>
<ul>
  <li>
    <a href="https://medium.com/@clayallsopp/incrementally-migrating-javascript-to-typescript-565020e49c88">“Incrementally Migrating JavaScript to TypeScript”</a> by <a href="https://twitter.com/clayallsopp">Clay Allsopp</a>.
  </li>
</ul>
<h3 id="strategy-adding-type-information-to-plain-javascript-files"><a class="heading-id-link" href="#strategy-adding-type-information-to-plain-javascript-files">12.2 Strategy: adding type information to plain JavaScript files</a></h3>
<p>This approach works as follows:</p>
<ul>
  <li>
    We continue to use our current build infrastructure.
  </li>
  <li>
    We run the TypeScript compiler, but only as a type checker (compiler option <code>--noEmit</code>). In addition to the compiler option <code>--allowJs</code> (for allowing and copying JavaScript files), we also have to use the compiler option <code>--checkJs</code> (for type-checking JavaScript files).
  </li>
  <li>
    We add type information via JSDoc comments (see example below) and declaration files.
  </li>
  <li>
    Once TypeScript’s type checker doesn’t complain anymore, we use the compiler to build the code base. Switching from <code>.js</code> files to <code>.ts</code> files is not urgent now because the whole code base is already fully statically typed. We can even produce type files (filename extension <code>.d.ts</code>) now.
  </li>
</ul>
<p>This is how we specify static types for plain JavaScript via JSDoc comments:</p>
<pre class="language-js">
<code><span class="hljs-comment">/**</span></code>
<code><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">x</span> - The first operand</span></code>
<code><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">y</span> - The second operand</span></code>
<code><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number</span>} The sum of both operands</span></code>
<code><span class="hljs-comment"> */</span></code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) {</code>
<code>  <span class="hljs-keyword">return</span> x + y;</code>
<code>}</code>
</pre>
<pre class="language-ts">
<code><span class="hljs-comment">/** <span class="hljs-doctag">@typedef</span> {<span class="hljs-type">{ prop1: string, prop2: string, prop3?: number </span>}} SpecialType */</span></code>
<code><span class="hljs-comment">/** <span class="hljs-doctag">@typedef</span> {<span class="hljs-type">(data: string, index?: number) =&gt; boolean</span>} Predicate */</span></code>
</pre>
<p><strong>More information:</strong></p>
<ul>
  <li>
    <a href="ch_typescript-workflows.html#check-js">“Type-checking JavaScript files” (§6.8)</a>
  </li>
  <li>
    <a href="https://medium.com/unsplash/how-we-gradually-migrated-to-typescript-at-unsplash-7a34caa24ef1">“How we gradually migrated to TypeScript at Unsplash”</a> by <a href="https://twitter.com/OliverJAsh">Oliver Joseph Ash</a>
  </li>
</ul>
<h3 id="strategy-linting-before-activating-a-compiler-option"><a class="heading-id-link" href="#strategy-linting-before-activating-a-compiler-option">12.3 Strategy: linting before activating a compiler option</a></h3>
<p>Projects that migrate to TypeScript often start with the default type checking and then add more checks, in stages – e.g.:</p>
<ol>
  <li>
    Initially: default checks
  </li>
  <li>
    Activate <code>strictNullChecks</code> (prevents <code>undefined</code> and <code>null</code> from being used unless the type is <code>T | undefined</code> or <code>T | null</code>, respectively)
  </li>
  <li>
    Activate <code>noImplicitAny</code> (prevents omitting types for parameters and more)
  </li>
  <li>
    Activate <code>strict</code> (includes the previous two compiler options – which can be removed – and adds <a href="https://www.typescriptlang.org/tsconfig/#strict">additional ones</a>)
  </li>
</ol>
<p>In contrast to compiler options, we can activate linting options on a per-file basis. This helps when switching from less strict type checking to stricter type checking: We can lint before making the switch. These are examples of useful rules that the TypeScript linter <a href="https://typescript-eslint.io">typescript-eslint</a> provides:</p>
<ul>
  <li>
    Preparing for <code>noImplicitAny</code>:
    <ul>
      <li>
        <a href="https://typescript-eslint.io/rules/no-unsafe-call/"><code>no-unsafe-call</code></a>
      </li>
      <li>
        <a href="https://typescript-eslint.io/rules/no-unsafe-member-access/"><code>no-unsafe-member-access</code></a>
      </li>
      <li>
        <a href="https://typescript-eslint.io/rules/no-unsafe-argument/"><code>no-unsafe-argument</code></a>
      </li>
      <li>
        <a href="https://typescript-eslint.io/rules/no-unsafe-assignment/"><code>no-unsafe-assignment</code></a>
      </li>
      <li>
        <a href="https://typescript-eslint.io/rules/no-explicit-any/"><code>no-explicit-any</code></a>
      </li>
    </ul>
  </li>
  <li>
    Preparing for <code>erasableSyntaxOnly</code>:
    <ul>
      <li>
        <a href="https://github.com/JoshuaKGoldberg/eslint-plugin-erasable-syntax-only"><code>eslint-plugin-erasable-syntax-only</code></a>
      </li>
    </ul>
  </li>
</ul>
<h3 id="strategy-too-many-errors-use-snapshot-testing"><a class="heading-id-link" href="#strategy-too-many-errors-use-snapshot-testing">12.4 Strategy: Too many errors? Use snapshot testing</a></h3>
<p>In large JavaScript projects, switching to TypeScript may produce too many errors – no matter which approach we choose. Then snapshot-testing the TypeScript errors may be an option:</p>
<ul>
  <li>
    We run the TypeScript compiler on the whole code base for the first time.
  </li>
  <li>
    The errors produced by the compiler become our initial snapshot.
  </li>
  <li>
    As we work on the code base, we compare new error output with the previous snapshot:
    <ul>
      <li>
        Sometimes existing errors disappear. Then we can create a new snapshot.
      </li>
      <li>
        Sometimes new errors appear. Then we either have to fix these errors or create a new snapshot.
      </li>
    </ul>
  </li>
</ul>
<p><strong>More information:</strong></p>
<ul>
  <li>
    <a href="https://dylanvann.com/incrementally-migrating-to-typescript/">“How to Incrementally Migrate 100k Lines of Code to Typescript”</a> by <a href="https://twitter.com/atomarranger">Dylan Vann</a>
  </li>
</ul>
<h3 id="tools-that-help-with-migrating-to-typescript"><a class="heading-id-link" href="#tools-that-help-with-migrating-to-typescript">12.5 Tools that help with migrating to TypeScript</a></h3>
<ul>
  <li>
    <p><a href="https://github.com/airbnb/ts-migrate">ts-migrate</a> helps with the first step of moving from JavaScript to TypeScript: “The resulting code will pass the build, but a followup is required to improve type safety. There will be lots of <code>//@ts-expect-error</code>, and <code>any</code> that will need to be fixed over time. In general, it is a lot nicer than starting from scratch.”</p>
  </li>
  <li>
    <p><a href="https://github.com/plantain-00/type-coverage">type-coverage</a> shows which percentage of identifiers have the type <code>any</code>.</p>
  </li>
</ul>
<h3 id="conclusion-and-further-reading"><a class="heading-id-link" href="#conclusion-and-further-reading">12.6 Conclusion and further reading</a></h3>
<p>We have taken a quick look at strategies for migrating to TypeScript. Two more tips:</p>
<ul>
  <li>
    Start your migration with experiments: Play with your code base and try out various strategies before committing to one of them.
  </li>
  <li>
    Then lay out a clear plan for going forward. Discuss prioritization with your team:
    <ul>
      <li>
        Sometimes finishing the migration quickly may take priority.
      </li>
      <li>
        Sometimes the code remaining fully functional during the migration may be more important.
      </li>
      <li>
        And so on…
      </li>
    </ul>
  </li>
</ul>
<p><strong>Further reading:</strong></p>
<ul>
  <li>
    <a href="https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html">“Migrating from JavaScript”</a> in the TypeScript Handbook
  </li>
</ul>

    
      
</body>
</html>