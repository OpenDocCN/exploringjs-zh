["```ts\nclass Point {\n x: number;\n y: number;\n constructor(x: number, y: number) {\n this.x = x;\n this.y = y;\n }\n}\n\n```", "```ts\nfunction createPoint(PointClass: C, x: number, y: number): Point {\n return new PointClass(x, y);\n}\n\n```", "```ts\nfunction createPoint(PointClass: typeof Point, x: number, y: number) {\n return new PointClass(x, y);\n}\n\nconst point = createPoint(Point, 3, 6);\nassertType<Point>(point); // (A)\nassert.ok(point instanceof Point);\n\n```", "```ts\nfunction createPoint(\n PointClass: new (x: number, y: number) => Point, // (A)\n x: number, y: number\n) {\n return new PointClass(x, y);\n}\n\n```", "```ts\nfunction f(\n ClassThatImplementsInterf: new () => Interf\n) {}\n\n```", "```ts\nfunction createPoint(\n PointClass: {new (x: number, y: number): Point},\n x: number, y: number\n) {\n return new PointClass(x, y);\n}\n\n```", "```ts\ntype Class<T> = new (...args: any[]) => T;\n\n```", "```ts\ninterface Class<T> {\n new(...args: any[]): T;\n}\n\n```", "```ts\nfunction createInstance<T>(TheClass: Class<T>, ...args: unknown[]): T {\n return new TheClass(...args);\n}\n\n```", "```ts\nclass Person {\n constructor(public name: string) {}\n}\n\nconst jane = createInstance(Person, 'Jane');\nassertType<Person>(jane);\n\n```", "```ts\nfunction isInstance<T>(TheClass: Class<T>, arg: unknown): boolean {\n type _ = Assert<Equal<\n typeof arg, unknown\n >>;\n if (arg instanceof TheClass) { // (A)\n type _ = Assert<Equal<\n typeof arg, T\n >>;\n return true;\n }\n return false;\n}\n\n```", "```ts\nfunction cast<T>(TheClass: Class<T>, value: unknown): T {\n if (!(value instanceof TheClass)) {\n throw new Error(`Not an instance of ${TheClass.name}: ${value}`)\n }\n return value;\n}\n\n```", "```ts\nfunction parseObject(jsonObjectStr: string): Object {\n const parsed = JSON.parse(jsonObjectStr);\n type _ = Assert<Equal<\n typeof parsed, any\n >>;\n return cast(Object, parsed);\n}\n\n```", "```ts\n/**\n * After invoking this function, the inferred type of `value` is `T`.\n */\nexport function throwIfNotInstance<T>(\n TheClass: Class<T>, value: unknown\n): asserts value is T { // (A)\n if (!(value instanceof TheClass)) {\n throw new Error(`Not an instance of ${TheClass}: ${value}`);\n }\n}\n\n```", "```ts\nconst parsed = JSON.parse('[1, 2]');\ntype _1 = Assert<Equal<\n typeof parsed, any\n>>;\nthrowIfNotInstance(Array, parsed);\ntype _2 = Assert<Equal<\n typeof parsed, Array<unknown>\n>>;\n\n```", "```ts\nclass TypeSafeMap {\n #data = new Map<unknown, unknown>();\n get<T>(key: Class<T>) {\n const value = this.#data.get(key);\n return cast(key, value);\n }\n set<T>(key: Class<T>, value: T): this {\n cast(key, value); // runtime check\n this.#data.set(key, value);\n return this;\n }\n has(key: unknown) {\n return this.#data.has(key);\n }\n}\n\n```", "```ts\nconst map = new TypeSafeMap();\n\nmap.set(RegExp, /abc/);\n\nconst re = map.get(RegExp);\nassertType<RegExp>(re);\n\n// Static and dynamic error!\nassert.throws(\n // @ts-expect-error: Argument of type 'string' is not assignable\n // to parameter of type 'Date'.\n () => map.set(Date, 'abc')\n);\n\n```", "```ts\nabstract class Shape {\n}\nclass Circle extends Shape {\n // ···\n}\n\n```", "```ts\ntype Class<T> = new (...args: any[]) => T;\n\n// @ts-expect-error: Type 'typeof Shape' is not assignable to\n// type 'Class<Shape>'. Cannot assign an abstract constructor type\n// to a non-abstract constructor type.\nconst shapeClasses1: Array<Class<Shape>> = [Circle, Shape];\n\n```", "```ts\ntype Class<T> = abstract new (...args: any[]) => T;\nconst shapeClasses: Array<Class<Shape>> = [Circle, Shape];\n\n```", "```ts\nfunction createInstance<T>(TheClass: Class<T>, ...args: unknown[]): T {\n // @ts-expect-error: Cannot create an instance of an abstract class.\n return new TheClass(...args);\n}\n\n```", "```ts\nfunction isInstance<T>(TheClass: Class<T>, arg: unknown): boolean {\n type _ = Assert<Equal<\n typeof arg, unknown\n >>;\n if (arg instanceof TheClass) {\n type _ = Assert<Equal<\n typeof arg, T\n >>;\n return true;\n }\n return false;\n}\n\n```", "```ts\ntype NewableClass<T> = new (...args: any[]) => T;\nfunction createInstance<T>(TheClass: NewableClass<T>, ...args: unknown[]): T {\n return new TheClass(...args);\n}\n\n```"]