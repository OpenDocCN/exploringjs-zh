- en: 18 Typing objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18 对象类型化
- en: 原文：[https://exploringjs.com/ts/book/ch_typing-objects.html](https://exploringjs.com/ts/book/ch_typing-objects.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/ts/book/ch_typing-objects.html](https://exploringjs.com/ts/book/ch_typing-objects.html)
- en: (Ad, please don’t block.)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: (广告，请勿屏蔽。)
- en: '[18.1 Object types](#object-types)'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.1 对象类型](#object-types)'
- en: '[18.1.1 The two ways of using objects](#ways-of-using-objects)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.1.1 使用对象的方式](#ways-of-using-objects)'
- en: '[18.1.2 Object types work structurally in TypeScript](#object-types-work-structurally-in-typescript)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.1.2 对象类型在TypeScript中以结构化方式工作](#object-types-work-structurally-in-typescript)'
- en: '[18.2 Members of object literal types](#members-of-object-literal-types)'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.2 对象字面量类型的成员](#members-of-object-literal-types)'
- en: '[18.2.1 Method signatures](#method-signatures)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.2.1 方法签名](#method-signatures)'
- en: '[18.2.2 Keys of object type members](#keys-of-object-type-members)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.2.2 对象类型成员的键](#keys-of-object-type-members)'
- en: '[18.2.3 Modifiers of object type members](#modifiers-of-object-type-members)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.2.3 对象类型成员的修饰符](#modifiers-of-object-type-members)'
- en: '[18.3 Excess property checks: When are extra properties allowed?](#excess-property-checks-when-are-extra-properties-allowed)'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.3 额外的属性检查：何时允许额外的属性？](#excess-property-checks-when-are-extra-properties-allowed)'
- en: '[18.3.1 Why are excess properties forbidden in object literals?](#why-are-excess-properties-forbidden-in-object-literals)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.3.1 为什么对象字面量中禁止额外的属性？](#why-are-excess-properties-forbidden-in-object-literals)'
- en: '[18.3.2 Why are excess properties allowed if an object comes from somewhere
    else?](#why-are-excess-properties-allowed-if-an-object-comes-from-somewhere-else)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.3.2 如果物体来自其他地方，为什么允许额外的属性？](#why-are-excess-properties-allowed-if-an-object-comes-from-somewhere-else)'
- en: '[18.3.3 Empty object literal types allow excess properties](#empty-object-literal-types-allow-excess-properties)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.3.3 空对象字面量类型允许额外的属性](#empty-object-literal-types-allow-excess-properties)'
- en: '[18.3.4 Matching only objects without properties](#matching-only-objects-without-properties)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.3.4 仅匹配没有属性的物体](#matching-only-objects-without-properties)'
- en: '[18.3.5 Allowing excess properties in object literals](#allowing-excess-properties-in-object-literals)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.3.5 在对象字面量中允许额外的属性](#allowing-excess-properties-in-object-literals)'
- en: '[18.4 Object types and inherited properties](#object-types-and-inherited-properties)'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.4 对象类型和继承属性](#object-types-and-inherited-properties)'
- en: '[18.4.1 TypeScript doesn’t distinguish own and inherited properties](#typescript-doesn-t-distinguish-own-and-inherited-properties)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.4.1 TypeScript不区分自有属性和继承属性](#typescript-doesn-t-distinguish-own-and-inherited-properties)'
- en: '[18.4.2 Object literal types describe instances of `Object`](#object-literal-types-describe-instances-of-object)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.4.2 对象字面量类型描述`Object`的实例](#object-literal-types-describe-instances-of-object)'
- en: '[18.5 Interfaces vs. object literal types](#interfaces-vs-object-literal-types)'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.5 接口与对象字面量类型](#interfaces-vs-object-literal-types)'
- en: '[18.5.1 Object literal types can be inlined](#object-literal-types-can-be-inlined)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.5.1 对象字面量类型可以内联](#object-literal-types-can-be-inlined)'
- en: '[18.5.2 Interfaces with the same name are merged](#interfaces-with-the-same-name-are-merged)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.5.2 同名接口合并](#interfaces-with-the-same-name-are-merged)'
- en: '[18.5.3 Mapped types look like object literal types](#mapped-types-look-like-object-literal-types)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.5.3 映射类型看起来像对象字面量类型](#mapped-types-look-like-object-literal-types)'
- en: '[18.5.4 Only interfaces support polymorphic `this` types](#only-interfaces-support-polymorphic-this-types)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.5.4 只有接口支持多态的`this`类型](#only-interfaces-support-polymorphic-this-types)'
- en: '[18.5.5 Only interfaces support `extends` – but type intersection (`&`) is
    similar](#extending-interfaces)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.5.5 只有接口支持`extends` – 但类型交集（`&`）类似](#extending-interfaces)'
- en: '[18.6 Forbidding properties via `never`](#forbidding-properties-via-never)'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.6 通过`never`禁止属性](#forbidding-properties-via-never)'
- en: '[18.6.1 Forbidding properties with string keys](#forbidding-properties-with-string-keys)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.6.1 禁止带字符串键的属性](#forbidding-properties-with-string-keys)'
- en: '[18.6.2 Forbidding index properties (with number keys)](#forbidding-index-properties-with-number-keys)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.6.2 禁止索引属性（带数字键）](#forbidding-index-properties-with-number-keys)'
- en: '[18.7 Index signatures: objects as dictionaries](#index-signatures)'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.7 索引签名：对象作为字典](#index-signatures)'
- en: '[18.7.1 Typing index signature keys](#typing-index-signature-keys)'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.7.1 类型化索引签名键](#typing-index-signature-keys)'
- en: '[18.7.2 String keys vs. number keys](#string-keys-vs-number-keys)'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.7.2 字符串键与数字键](#string-keys-vs-number-keys)'
- en: '[18.7.3 Index signatures vs. property signatures and method signatures](#index-signatures-vs-property-signatures-and-method-signatures)'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.7.3 索引签名与属性签名和方法签名](#index-signatures-vs-property-signatures-and-method-signatures)'
- en: '[18.8 `Record<K, V>` for dictionary objects](#record-for-dictionary-objects)'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.8 `Record<K, V>`用于字典对象](#record-for-dictionary-objects)'
- en: '[18.8.1 Index signatures don’t allow key unions](#index-signatures-don-t-allow-key-unions)'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.8.1 索引签名不允许键联合](#index-signatures-don-t-allow-key-unions)'
- en: '[18.8.2 `Record` enforces exhaustiveness for key unions](#record-enforces-exhaustiveness-for-key-unions)'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.8.2 `Record` 强制键联合的完备性](#record-enforces-exhaustiveness-for-key-unions)'
- en: '[18.8.3 `Record`: preventing exhaustiveness checks for key unions](#record-preventing-exhaustiveness-checks-for-key-unions)'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.8.3 `Record`：防止键联合的完备性检查](#record-preventing-exhaustiveness-checks-for-key-unions)'
- en: '[18.9 `object` vs `Object` vs. `{}`](#general-types-for-objects)'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.9 `object` vs `Object` vs. `{}`](#general-types-for-objects)'
- en: '[18.9.1 Plain JavaScript: objects vs. instances of `Object`](#plain-javascript-objects-vs-instances-of-object)'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.9.1 纯JavaScript：对象与 `Object` 实例](#plain-javascript-objects-vs-instances-of-object)'
- en: '[18.9.2 `Object` (uppercase “O”) in TypeScript: instances of class `Object`](#object-uppercase-o-in-typescript-instances-of-class-object)'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.9.2 TypeScript中的 `Object`（大写“O”）：`Object` 类的实例](#object-uppercase-o-in-typescript-instances-of-class-object)'
- en: '[18.9.3 Type `{}` basically means: not nullish](#type-basically-means-not-nullish)'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.9.3 类型 `{}` 基本上意味着：非空值](#type-basically-means-not-nullish)'
- en: '[18.9.4 Inferred types for various objects](#inferred-types-for-various-objects)'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.9.4 各种对象的推断类型](#inferred-types-for-various-objects)'
- en: '[18.10 Summary: `object` vs `Object` vs. `{}` vs. `Record`](#summary-object-vs-object-vs-vs-record)'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.10 总结：`object` vs `Object` vs. `{}` vs. `Record`](#summary-object-vs-object-vs-vs-record)'
- en: '[18.11 Sources of this chapter](#sources-of-this-chapter-2)'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.11 本章的来源](#sources-of-this-chapter-2)'
- en: In this chapter, we will explore how objects and properties are typed statically
    in TypeScript.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨在TypeScript中如何静态地对对象和属性进行类型化。
- en: '[18.1 Object types](#object-types)'
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[18.1 对象类型](#object-types)'
- en: '[18.1.1 The two ways of using objects](#ways-of-using-objects)'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.1.1 使用对象的方式](#ways-of-using-objects)'
- en: 'There are two ways of using objects in JavaScript:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，使用对象有两种方式：
- en: 'Fixed-layout object: Used this way, an object works like a record in a database.
    It has a fixed number of properties, whose keys are known at development time.
    Their values generally have different types.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定布局对象：以这种方式使用，对象就像数据库中的记录。它具有固定数量的属性，其键在开发时已知。它们的值通常具有不同的类型。
- en: '[PRE0]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Dictionary object: Used this way, an object works like a lookup table or a
    map. It has a variable number of properties, whose keys are not known at development
    time. All of their values have the same type.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典对象：以这种方式使用，对象就像一个查找表或映射。它具有可变数量的属性，其键在开发时未知。所有这些值都具有相同的类型。
- en: '[PRE1]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that the two ways can also be mixed: Some objects are both fixed-layout
    objects and dictionary objects.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两种方式也可以混合使用：一些对象既是固定布局对象也是字典对象。
- en: 'The most common ways of typing these two kinds of objects are:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种对象类型最常见的类型化方式是：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`FixedLayoutObjectType` is an object literal type. The separators between properties
    can be either commas (`,`) or semicolons (`;`). I prefer the former because that’s
    what JavaScript object literals use.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FixedLayoutObjectType` 是一个对象字面量类型。属性之间的分隔符可以是逗号（`,`）或分号（`;`）。我更喜欢前者，因为这是JavaScript对象字面量所使用的。'
- en: '`DictionaryObjectType` uses the utility type `Record` to define a type for
    dictionary objects whose keys are strings and whose values are numbers.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DictionaryObjectType` 使用实用类型 `Record` 定义字典对象的类型，其键为字符串，值为数字。'
- en: Next, we’ll look at fixed-layout object types in more detail before coming back
    to dictionary object types.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在回到字典对象类型之前，我们将更详细地查看固定布局对象类型。
- en: '[18.1.2 Object types work structurally in TypeScript](#object-types-work-structurally-in-typescript)'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.1.2 对象类型在TypeScript中的结构工作方式](#object-types-work-structurally-in-typescript)'
- en: 'Object types work structurally in TypeScript: They match all values that have
    their structure. Therefore, a type can be defined after a given value and still
    match it – e.g.:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，对象类型以结构方式工作：它们匹配具有其结构的所有值。因此，可以在给定值之后定义一个类型，并且仍然匹配它 - 例如：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For more information on this topic, see [“Nominal type systems vs. structural
    type systems” (§13.4)](ch_what-is-a-type.html#nominal-vs-structural-type-systems).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此主题的更多信息，请参阅“命名类型系统与结构类型系统”（§13.4）。
- en: '[18.2 Members of object literal types](#members-of-object-literal-types)'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[18.2 对象字面量类型的成员](#members-of-object-literal-types)'
- en: 'The constructs inside the bodies of object literal types are called their *members*.
    These are the most common members:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量类型体内的结构称为它们的 *成员*。这些是最常见的成员：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s look at these members in more detail:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些成员：
- en: 'Property signatures define properties and should be self-explanatory:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性签名定义属性，应该是自解释的：
- en: '[PRE5]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Method signatures define methods and are described in the next subsection.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法签名定义方法，将在下一小节中描述。
- en: '[PRE6]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note: The names of parameters (in this case: `str`) help with documenting how
    things work but have no other purpose.'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：参数的名称（在这种情况下：`str`）有助于说明事物的工作方式，但没有其他目的。
- en: Index signatures are needed to describe Arrays or objects that are used as dictionaries.
    They are described [later in this chapter](#index-signatures).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引签名用于描述用作字典的数组或对象。它们将在本章[后面](#index-signatures)描述。
- en: '[PRE7]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note: The name `key` is only there for documentation purposes.'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：名称 `key` 仅用于文档目的。
- en: Call signatures enable object literal types to describe functions. See [“Interfaces
    with call signatures” (§27.2.2)](ch_typing-functions.html#call-signatures).
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用签名使对象字面量类型能够描述函数。参见[“具有调用签名的接口”（§27.2.2）](ch_typing-functions.html#call-signatures)。
- en: '[PRE8]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Construct signatures enable object literal types to describe classes and constructor
    functions. See [“Object type literals with construct signatures” (§23.2.3)](ch_classes-as-values.html#construct-signatures).
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造签名使对象字面量类型能够描述类和构造函数。参见[“具有构造签名的对象类型字面量”（§23.2.3）](ch_classes-as-values.html#construct-signatures)。
- en: '[PRE9]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[18.2.1 Method signatures](#method-signatures)'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.2.1 方法签名](#method-signatures)'
- en: 'As far as TypeScript’s type system is concerned, method definitions and properties
    whose values are functions, are equivalent:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 就TypeScript的类型系统而言，方法定义和值是函数的属性是等效的：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: My recommendation is to use whichever syntax best expresses how a property should
    be set up.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是使用最能表达属性设置方式的语法。
- en: '[18.2.2 Keys of object type members](#keys-of-object-type-members)'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.2.2 对象类型成员的键](#keys-of-object-type-members)'
- en: '[18.2.2.1 Quoted keys](#quoted-keys)'
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[18.2.2.1 引号键](#quoted-keys)'
- en: 'Just like in JavaScript, property keys can be quoted:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在JavaScript中一样，属性键可以是引号的：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[18.2.2.2 Unquoted numbers as keys](#unquoted-numbers-as-keys)'
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[18.2.2.2 未引用的数字作为键](#unquoted-numbers-as-keys)'
- en: 'This rarely matters in practice, but as an aside: Just like in JavaScript,
    we can use unquoted numbers as keys. Unlike JavaScript, those keys are considered
    to be number literal types:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这很少很重要，但作为旁白：就像在JavaScript中一样，我们可以使用未引用的数字作为键。与JavaScript不同，这些键被认为是数字字面量类型：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For comparison, this is how JavaScript works:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较，这是JavaScript的工作方式：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For more information see [$type](ch_computing-with-types-overview.html#number-keys-javascript-vs-typescript).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请参阅 [$type](ch_computing-with-types-overview.html#number-keys-javascript-vs-typescript)。
- en: '[18.2.2.3 Computed property keys](#computed-property-keys)'
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[18.2.2.3 计算属性键](#computed-property-keys)'
- en: '[Computed property keys](https://exploringjs.com/js/book/ch_objects.html#object-literals-computed-keys)
    are a JavaScript feature. There is a similar feature at the type level:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[计算属性键](https://exploringjs.com/js/book/ch_objects.html#object-literals-computed-keys)是JavaScript的一个特性。在类型级别上也有类似的功能：'
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Unexpectedly, computed property keys are values, not types. TypeScript internally
    applies `typeof` to create the type:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 意想不到的是，计算属性键是值，而不是类型。TypeScript内部应用 `typeof` 来创建类型：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'What kind of value is allowed as a computed property key? Its type must be:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性键允许什么样的值？它的类型必须是：
- en: A string literal type such as `'abc'`
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字符串字面量类型，例如 `'abc'`
- en: A number literal type such as `123`
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数字字面量类型，例如 `123`
- en: A unique symbol type
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个独特的符号类型
- en: '`any`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any`'
- en: '[18.2.3 Modifiers of object type members](#modifiers-of-object-type-members)'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.2.3 对象类型成员的修饰符](#modifiers-of-object-type-members)'
- en: '[18.2.3.1 Optional properties](#optional-properties-1)'
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[18.2.3.1 可选属性](#optional-properties-1)'
- en: 'If we put a question mark (`?`) after the name of a property, that property
    is optional. The same syntax is used to mark parameters of functions, methods,
    and constructors as optional. In the following example, property `.middle` is
    optional:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在属性名称后加上问号 (`?`)，则该属性是可选的。相同的语法也用于标记函数、方法和构造函数的参数为可选。在以下示例中，属性 `.middle`
    是可选的：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Therefore, it’s OK to omit that property (line A):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，省略该属性（行A）是可以的：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[18.2.3.1.1 Optional vs. `undefined | string` with `exactOptionalPropertyTypes`](#optional-vs-undefined-string-with-ex-act-op-tion-al-prop-er-ty-types)'
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '[18.2.3.1.1 可选与 `undefined | string` 使用 `exactOptionalPropertyTypes`](#optional-vs-undefined-string-with-ex-act-op-tion-al-prop-er-ty-types)'
- en: 'In this book, all code uses the compiler setting [`exactOptionalPropertyTypes`](ch_tsconfig-json.html#exactOptionalPropertyTypes).
    With that setting, the difference an optional property and a property with type
    `undefined | string` is intuitive:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，所有代码都使用编译器设置 `exactOptionalPropertyTypes`。使用此设置，可选属性与类型为 `undefined |
    string` 的属性之间的区别是直观的：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Types such as `undefined | string` and `null | string` are useful if we want
    to make omissions explicit. When people see such an explicitly omitted property,
    they know that it exists but was switched off.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要明确省略时，类型如 `undefined | string` 和 `null | string` 是有用的。当人们看到这样的明确省略的属性时，他们会知道它存在，但已被关闭。
- en: '[18.2.3.1.2 Optional vs. `undefined | string` without `exactOptionalPropertyTypes`](#optional-vs-undefined-string-without-ex-act-op-tion-al-prop-er-ty-types)'
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '[18.2.3.1.2 可选与 `undefined | string` 无 `exactOptionalPropertyTypes`](#optional-vs-undefined-string-without-ex-act-op-tion-al-prop-er-ty-types)'
- en: 'If `exactOptionalPropertyTypes` is `false` then one thing changes: `.prop1`
    can also be `undefined`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `exactOptionalPropertyTypes` 为 `false`，则有一件事会改变：`.prop1` 也可以是 `undefined`：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[18.2.3.2 Read-only properties](#read-only-properties)'
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[18.2.3.2 只读属性](#read-only-properties)'
- en: 'In the following example, property `.prop` is read-only:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，属性 `.prop` 是只读的：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As a consequence, we can read it, but we can’t change it:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 作为结果，我们可以读取它，但不能更改它：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[18.3 Excess property checks: When are extra properties allowed?](#excess-property-checks-when-are-extra-properties-allowed)'
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[18.3 多余的属性检查：何时允许额外的属性？](#excess-property-checks-when-are-extra-properties-allowed)'
- en: 'As an example, consider the following object literal type:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下对象字面量类型：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There are two ways (among others) in which this object literal type could be
    interpreted:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式（以及其他方式）可以解释这种对象字面量类型：
- en: 'Closed interpretation: It could describe all objects that have *exactly* the
    properties `.x` and `.y` with the specified types. On other words: Those objects
    must not have *excess properties* (more than the required properties).'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格解释：它可以描述所有具有**恰好**指定类型的 `.x` 和 `.y` 属性的对象。换句话说：这些对象不得有**多余的属性**（超过所需属性）。
- en: 'Open interpretation: It could describe all objects that have *at least* the
    properties `.x` and `.y`. In other words: Excess properties are allowed.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宽泛解释：它可以描述所有至少具有 `.x` 和 `.y` 属性的对象。换句话说：允许有多余的属性。
- en: 'TypeScript uses both interpretations. To explore how that works, we will use
    the following function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 使用两种解释。为了探索它是如何工作的，我们将使用以下函数：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The default is that the excess property `.z` is allowed:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，允许有多余的属性 `.z`：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'However, if we use object literals directly, then excess properties are forbidden:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们直接使用对象字面量，则不允许有多余的属性：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[18.3.1 Why are excess properties forbidden in object literals?](#why-are-excess-properties-forbidden-in-object-literals)'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.3.1 为什么对象字面量中禁止多余的属性？](#why-are-excess-properties-forbidden-in-object-literals)'
- en: Why the stricter rules for object literals? They provide protection against
    typos in property keys. We will use the following object literal type to demonstrate
    what that means.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么对象字面量有更严格的规则？它们可以提供对属性键中错误的保护。我们将使用以下对象字面量类型来演示这意味着什么。
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Property `.middle` is optional and can be omitted. To TypeScript, mistyping
    its name looks like omitting it and providing an excess property. However, it
    still catches the typo because excess properties are not allowed in this case:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 属性 `.middle` 是可选的，可以省略。对于 TypeScript 来说，名称的拼写错误看起来就像省略了它并提供了一个多余的属性。然而，它仍然会捕捉到这个错误，因为在这种情况下不允许有多余的属性：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[18.3.2 Why are excess properties allowed if an object comes from somewhere
    else?](#why-are-excess-properties-allowed-if-an-object-comes-from-somewhere-else)'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.3.2 为什么如果对象来自其他地方，则允许多余的属性？](#why-are-excess-properties-allowed-if-an-object-comes-from-somewhere-else)'
- en: The idea is that if an object comes from somewhere else, we can assume that
    it has already been vetted and will not have any typos. Then we can afford to
    be less careful.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是，如果一个对象来自其他地方，我们可以假设它已经被审查过，并且不会有任何错误。然后我们可以不那么小心。
- en: 'If typos are not an issue, our goal should be maximizing flexibility. Consider
    the following function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果拼写错误不是问题，我们的目标应该是最大化灵活性。考虑以下函数：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Without allowing excess properties for values that are passed to `getAge()`,
    the usefulness of this function would be quite limited.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不允许传递给 `getAge()` 的值有多余属性，这个函数的实用性将非常有限。
- en: '[18.3.3 Empty object literal types allow excess properties](#empty-object-literal-types-allow-excess-properties)'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.3.3 空对象字面量类型允许多余的属性](#empty-object-literal-types-allow-excess-properties)'
- en: 'If an object literal type is empty, excess properties are always allowed:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象字面量类型为空，则始终允许有多余的属性：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[18.3.4 Matching only objects without properties](#matching-only-objects-without-properties)'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.3.4 仅匹配没有属性的对象](#matching-only-objects-without-properties)'
- en: 'If we want to enforce that an object has no properties, we can use the following
    trick (credit: [Geoff Goodman](https://twitter.com/filearts/status/1222502898552180737)):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想强制一个对象没有任何属性，可以使用以下技巧（来源：[Geoff Goodman](https://twitter.com/filearts/status/1222502898552180737)）：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[18.3.5 Allowing excess properties in object literals](#allowing-excess-properties-in-object-literals)'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.3.5 对象字面量中允许多余的属性](#allowing-excess-properties-in-object-literals)'
- en: 'What if we want to allow excess properties in object literals? As an example,
    consider type `Point` and function `computeDistance1()`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在对象字面量中允许多余的属性，可以考虑以下示例，类型 `Point` 和函数 `computeDistance1()`：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'One option is to assign the object literal to an intermediate variable:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是将对象字面量赋值给一个中间变量：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'A second option is to use a type assertion:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用类型断言：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A third option is to rewrite `computeDistance1()` so that it uses a type parameter:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种选择是将 `computeDistance1()` 重写为使用类型参数：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A fourth option is to extend `Point` so that it allows excess properties:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第四种选择是扩展 `Point` 以允许多余的属性：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We used an intersection type (`&` operator) to define `PointEtc`. For more information,
    see [“Intersections of object types” (§20.1)](ch_intersections-object-types.html#intersections-of-object-types).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用交集类型（`&` 操作符）来定义 `PointEtc`。更多信息，请参阅[“对象类型的交集”（§20.1）](ch_intersections-object-types.html#intersections-of-object-types)。
- en: We’ll continue with two examples where TypeScript not allowing excess properties,
    is a problem.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续讨论两个示例，其中 TypeScript 不允许多余的属性是一个问题。
- en: '[18.3.5.1 Allowing excess properties: example `Incrementor` factory](#allowing-excess-properties-example-incrementor-factory)'
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[18.3.5.1 允许多余的属性：示例 `Incrementor` 工厂](#allowing-excess-properties-example-incrementor-factory)'
- en: 'In this example, we implement a factory for objects of type `Incrementor` and
    would like to return a subtype, but TypeScript doesn’t allow the extra property
    `.counter`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们实现了一个类型为 `Incrementor` 的对象工厂，并希望返回一个子类型，但 TypeScript 不允许额外的属性 `.counter`：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Alas, even with a type assertion, there is still one type error:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，即使使用类型断言，仍然存在一个类型错误：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: What does work is `as any` but then the type of the returned object is `any`
    and, e.g. inside `.inc()`, TypeScript doesn’t check if properties of `this` really
    exist.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `as any` 可以解决问题，但返回的对象类型将是 `any`，例如在 `.inc()` 中，TypeScript 不会检查 `this` 的属性是否真的存在。
- en: 'A proper solution is to add an index signature to `Incrementor`. Or – especially
    if that is not possible – to introduce an intermediate variable:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一个合适的解决方案是为 `Incrementor` 添加索引签名。或者——特别是如果不可能的话——引入一个中间变量：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[18.3.5.2 Allowing excess properties: example `.dateStr`](#allowing-excess-properties-example-datestr)'
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[18.3.5.2 允许多余的属性：示例 `.dateStr`](#allowing-excess-properties-example-datestr)'
- en: 'The following comparison function can be used to sort objects that have the
    property `.dateStr`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下比较函数可以用于对具有属性 `.dateStr` 的对象进行排序：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: For example in unit tests, we may want to invoke this function directly with
    object literals. TypeScript doesn’t let us do this and we need to use one of the
    workarounds.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在单元测试中，我们可能希望直接使用对象字面量调用此函数。TypeScript 不允许这样做，我们需要使用一种解决方案。
- en: '[18.4 Object types and inherited properties](#object-types-and-inherited-properties)'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[18.4 对象类型和继承属性](#object-types-and-inherited-properties)'
- en: '[18.4.1 TypeScript doesn’t distinguish own and inherited properties](#typescript-doesn-t-distinguish-own-and-inherited-properties)'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.4.1 TypeScript 不区分自有属性和继承属性](#typescript-doesn-t-distinguish-own-and-inherited-properties)'
- en: TypeScript doesn’t distinguish own and inherited properties. They are all simply
    considered to be properties.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 不区分自有属性和继承属性。它们都被简单地视为属性。
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`obj` inherits `.toString()` from `Object.prototype`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj` 从 `Object.prototype` 继承了 `.toString()` 方法。'
- en: The downside of this approach is that some phenomena in JavaScript can’t be
    described via TypeScript’s type system. The upside is that the type system is
    simpler.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，JavaScript 中的一些现象无法通过 TypeScript 的类型系统来描述。优点是类型系统更简单。
- en: '[18.4.2 Object literal types describe instances of `Object`](#object-literal-types-describe-instances-of-object)'
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.4.2 对象字面量类型描述 `Object` 的实例](#object-literal-types-describe-instances-of-object)'
- en: 'All object literal types describe objects that are instances of `Object` and
    inherit the properties of `Object.prototype`. In the following example, the parameter
    `x` of type `{}` is compatible with the return type `Object`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对象字面量类型都描述了 `Object` 的实例，并继承了 `Object.prototype` 的属性。在以下示例中，类型为 `{}` 的参数 `x`
    与返回类型 `Object` 兼容：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Similarly, `{}` has a method `.toString()`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`{}` 有一个 `.toString()` 方法：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[18.5 Interfaces vs. object literal types](#interfaces-vs-object-literal-types)'
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[18.5 接口与对象字面量类型](#interfaces-vs-object-literal-types)'
- en: 'For historical reasons, object types can be defined in two ways:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因，对象类型可以以两种方式定义：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In both cases, either semicolons or commas can be used as separators. I prefer
    commas for object literal types and semicolons for interfaces because that reflects
    what JavaScript looks like (object literals and classes).
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这两种情况下，都可以使用分号或逗号作为分隔符。我更喜欢逗号用于对象字面量类型，分号用于接口，因为这反映了JavaScript的样子（对象字面量和类）。
- en: Trailing separators are allowed and optional.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许并可选地使用尾随分隔符。
- en: Both ways of defining an object type are more or less equivalent now. We’ll
    dive into the (minor) differences next.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在定义对象类型的方式在某种程度上是等价的。我们将深入了解（轻微的）差异。
- en: '[18.5.1 Object literal types can be inlined](#object-literal-types-can-be-inlined)'
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.5.1 对象字面量类型可以被内联](#object-literal-types-can-be-inlined)'
- en: 'Object literal types can be inlined, while interfaces can’t be:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量类型可以被内联，而接口不能：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[18.5.2 Interfaces with the same name are merged](#interfaces-with-the-same-name-are-merged)'
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.5.2 同名接口将被合并](#interfaces-with-the-same-name-are-merged)'
- en: 'Type aliases with duplicate names are illegal:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 具有重复名称的类型别名是非法的：
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Conversely, interfaces with duplicate names are merged:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，具有重复名称的接口将被合并：
- en: '[PRE46]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is called [declaration merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html)
    and can be used to combine types from multiple sources – e.g., as long as `Array.fromAsync()`
    is a new method, it is not part of the core library declaration file, but provided
    via `lib.esnext.array.d.ts` – which adds it as an increment to `ArrayConstructor`
    (the type of `Array` as a class value):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为[声明合并](https://www.typescriptlang.org/docs/handbook/declaration-merging.html)，可以用来组合来自多个源的类型
    - 例如，只要`Array.fromAsync()`是一个新方法，它就不是核心库声明文件的一部分，而是通过`lib.esnext.array.d.ts`提供的
    - 它将其作为增量添加到`ArrayConstructor`（`Array`作为类值的类型）：
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[18.5.3 Mapped types look like object literal types](#mapped-types-look-like-object-literal-types)'
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.5.3 映射类型看起来像对象字面量类型](#mapped-types-look-like-object-literal-types)'
- en: 'A mapped type (line A) looks like an object literal type:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 映射类型（行A）看起来像对象字面量类型：
- en: '[PRE48]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As an option, we can end line A with a semicolon. Alas, a comma is not allowed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 作为选项，我们可以用分号结束行A。然而，逗号是不允许的。
- en: 'For more information on this topic, see [“Mapped types `{[K in U]: X}`” (§36)](ch_mapped-types.html#ch_mapped-types).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '更多关于这个主题的信息，请参阅“映射类型`{[K in U]: X}`”（§36）[“Mapped types `{[K in U]: X}`” (§36)](ch_mapped-types.html#ch_mapped-types)。'
- en: '[18.5.4 Only interfaces support polymorphic `this` types](#only-interfaces-support-polymorphic-this-types)'
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.5.4 只有接口支持多态`this`类型](#only-interfaces-support-polymorphic-this-types)'
- en: 'Polymorphic `this` types can only be used in interfaces:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 多态`this`类型只能用于接口：
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[18.5.5 Only interfaces support `extends` – but type intersection (`&`) is
    similar](#extending-interfaces)'
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.5.5 只有接口支持`extends` - 但类型交集（`&`）类似](#extending-interfaces)'
- en: 'An interface `B` can extend another interface `A` and is then interpreted as
    an increment of `A`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接口`B`可以扩展另一个接口`A`，然后被解释为`A`的增量：
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Object literal types don’t support `extend` but an intersection type `&` has
    a similar effect:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量类型不支持`extend`，但交集类型`&`有类似的效果：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Intersections of object types are described in more detail in [another chapter](ch_intersections-object-types.html#intersections-of-object-types).
    Here, we’ll explore how exactly they differ from `extends`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对象类型的交集在另一章中描述得更详细[another chapter](ch_intersections-object-types.html#intersections-of-object-types)。在这里，我们将探讨它们如何与`extends`精确地不同。
- en: '[18.5.5.1 Conflicts](#conflicts)'
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[18.5.5.1 冲突](#conflicts)'
- en: 'If there is a conflict between an extending interface and an extended interface
    then that’s an error:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果扩展接口和扩展接口之间存在冲突，那么这就是一个错误：
- en: '[PRE52]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In contrast, intersection types don’t complain about conflicts, but they may
    result in `never` in some locations:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，交集类型不会对冲突提出异议，但它们可能在某些位置导致`never`：
- en: '[PRE53]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[18.5.5.2 Only interfaces support overriding](#only-interfaces-support-overriding)'
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[18.5.5.2 只有接口支持覆盖](#only-interfaces-support-overriding)'
- en: 'Overriding a method means replacing a method in a supertype with a *compatible*
    method – roughly:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖一个方法意味着用一个*兼容*的方法替换超类中的方法 - 大概：
- en: The overriding method can return more specific values – e.g. invokers of the
    overridden method that expect an `Object` won’t mind if the overriding method
    returns a `RegExp`.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖方法可以返回更具体的价值 - 例如，期望`Object`的覆盖方法调用者不会介意覆盖方法返回一个`RegExp`。
- en: The overriding method can expect less specific parameters – e.g. invokers of
    the overridden method that pass an argument of type `string` won’t mind if the
    overriding method accepts `string | number`.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写方法可以期望更不具体的参数 – 例如，重写方法的调用者传递一个类型为`string`的参数时，如果重写方法接受`string | number`，则不会介意。
- en: '[PRE54]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can see that the overriding method “wins” and completely replaces the overridden
    method in `B`. In contrast, both methods exist in parallel in an intersection
    type:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，重写方法“获胜”并完全替换了`B`中的被重写方法。相比之下，交集类型中同时存在这两种方法：
- en: '[PRE55]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'When it comes to the return type (line A and line B), the earlier member of
    the intersection wins. That’s why `B & A` (`B1`) is more similar to `B extends
    A`, even though `A & B` (`B2`) looks nicer:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到返回类型（行A和行B）时，交集中的较早成员获胜。这就是为什么`B & A`（`B1`）更类似于`B extends A`，尽管`A & B`（`B2`）看起来更漂亮：
- en: '[PRE56]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[18.5.5.3 `extends` or `&` – which one to use?](#extends-or-which-one-to-use)'
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[18.5.5.3　`extends`或`&` – 哪个类型使用？](#extends-or-which-one-to-use)'
- en: Which one to use depends on the context. If inheritance is involved then an
    interface and `extends` is usually the better choice due to their support of overriding.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个类型取决于上下文。如果涉及继承，则接口和`extends`通常是更好的选择，因为它们支持重写。
- en: '![Icon “external”](../Images/c1f1e62c75044317fd354db81eaefed3.png) **Source
    of this section**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“外部”](../Images/c1f1e62c75044317fd354db81eaefed3.png) **本节来源**'
- en: '[GitHub issue “TypeScript: types vs. interfaces”](https://github.com/peerigon/eslint-config-peerigon/issues/64)
    by [Johannes Ewald](https://github.com/jhnns)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GitHub问题“TypeScript：类型与接口”](https://github.com/peerigon/eslint-config-peerigon/issues/64)
    由 [Johannes Ewald](https://github.com/jhnns) 提出'
- en: '[18.6 Forbidding properties via `never`](#forbidding-properties-via-never)'
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[18.6　通过`never`禁止属性](#forbidding-properties-via-never)'
- en: Given that no other type is assignable to `never`, we can use it to forbid properties.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有其他类型可以赋值给`never`，我们可以用它来禁止属性。
- en: '[18.6.1 Forbidding properties with string keys](#forbidding-properties-with-string-keys)'
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.6.1　禁止带有字符串键的属性](#forbidding-properties-with-string-keys)'
- en: 'The type `EmptyObject` forbids string keys:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 类型`EmptyObject`禁止字符串键：
- en: '[PRE57]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In contrast, the type `{}` is assignable from all objects and not a type for
    empty objects:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，类型`{}`可以从所有对象赋值，并且不是空对象类型：
- en: '[PRE58]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[18.6.2 Forbidding index properties (with number keys)](#forbidding-index-properties-with-number-keys)'
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.6.2　禁止索引属性（带数字键）](#forbidding-index-properties-with-number-keys)'
- en: 'The type `NoIndices` forbids number keys but allows the string key `''prop''`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 类型`NoIndices`禁止数字键但允许字符串键`'prop'`：
- en: '[PRE59]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[18.7 Index signatures: objects as dictionaries](#index-signatures)'
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[18.7　索引签名：对象作为字典](#index-signatures)'
- en: 'So far, we have only used types for fixed-layout objects. How do we express
    the fact that an object is to be used as a dictionary? For example: What should
    `TranslationDict` be in the following code fragment?'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用了固定布局对象的类型。我们如何表达一个对象将被用作字典的事实？例如：在以下代码片段中`TranslationDict`应该是什么？
- en: '[PRE60]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'One option is to use an index signature (line A) to express that `TranslationDict`
    is for objects that map string keys to string values (another option is `Record`
    – which we’ll get to [later](#record-for-dictionary-objects)):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是使用索引签名（行A）来表示`TranslationDict`是为将字符串键映射到字符串值的对象而设计的（另一种选择是`Record` – 我们将在[稍后](#record-for-dictionary-objects)讨论）：
- en: '[PRE61]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The name `key` doesn’t matter – it can be any identifier and is ignored (but
    can’t be omitted).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 名称`key`不重要 – 它可以是任何标识符，并且被忽略（但不能省略）。
- en: '[18.7.1 Typing index signature keys](#typing-index-signature-keys)'
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.7.1　类型索引签名键](#typing-index-signature-keys)'
- en: 'An index signature represents an infinite set of properties; only the following
    types are allowed:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 索引签名表示一个无限集合的属性；只允许以下类型：
- en: '`string`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`'
- en: '`number`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number`'
- en: '`symbol`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symbol`'
- en: 'A template string literal with an infinite primitive type – e.g.: `` `${bigint}`
    ``'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板字符串字面量与无限原语类型 – 例如：`` `${bigint}` ``
- en: A union of any of the previous types
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前任何类型的联合
- en: 'Specifically *not* allowed are:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 特别不允许的是：
- en: 'A single string literal type – e.g.: `''a''`, `1`, `false`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个字符串字面量类型 – 例如：`'a'`、`1`、`false`
- en: 'A union of string literal types – e.g.:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串字面量类型的联合 – 例如：
- en: '`''a'' | ''b''`'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''a'' | ''b''`'
- en: '`1 | 2`'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1 | 2`'
- en: '`boolean` (which is `false | true`)'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean`（它是`false | true`）'
- en: 'A template string literal with one of the previous types – e.g.: `` `${boolean}`
    ``'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板字符串字面量与之前类型之一 – 例如：`` `${boolean}` ``
- en: 'The types: `never`, `any`, `unknown`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型：`never`、`any`、`unknown`
- en: If you need more power then consider using [a mapped types](ch_mapped-types.html#ch_mapped-types).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更多功能，请考虑使用[映射类型](ch_mapped-types.html#ch_mapped-types)。
- en: 'These are examples of index signatures:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是索引签名的示例：
- en: '[PRE62]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[18.7.2 String keys vs. number keys](#string-keys-vs-number-keys)'
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.7.2 字符串键与数字键](#string-keys-vs-number-keys)'
- en: 'Just like in plain JavaScript, TypeScript’s number property keys are a subset
    of the string property keys ([see “Exploring JavaScript”](https://exploringjs.com/js/book/ch_arrays.html#array-indices)).
    Accordingly, if we have both a string index signature and a number index signature,
    the property type of the former must be a supertype of the latter. The following
    example works because `Object` is a supertype of `RegExp` (`RegExp` is assignable
    to `Object`):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在纯 JavaScript 中一样，TypeScript 的数字属性键是字符串属性键的子集 ([参见“探索 JavaScript”](https://exploringjs.com/js/book/ch_arrays.html#array-indices))。因此，如果我们同时有一个字符串索引签名和一个数字索引签名，前者的属性类型必须是后者的超类型。以下示例之所以有效，是因为
    `Object` 是 `RegExp` 的超类型（`RegExp` 可以赋值给 `Object`）：
- en: '[PRE63]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The following code demonstrates the effects of using strings and numbers as
    property keys:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了使用字符串和数字作为属性键的效果：
- en: '[PRE64]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[18.7.3 Index signatures vs. property signatures and method signatures](#index-signatures-vs-property-signatures-and-method-signatures)'
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.7.3 索引签名与属性签名和方法签名](#index-signatures-vs-property-signatures-and-method-signatures)'
- en: If there are both an index signature and property and/or method signatures in
    an object literal type, then the type of the index property value must also be
    a supertype of the type of the property value and/or method.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象字面量类型中既有索引签名又有属性和/或方法签名，那么索引属性值的类型也必须是属性值和/或方法类型的超类型。
- en: '[PRE65]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In contrast, the following two object literal types produce no errors:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，以下两个对象字面量类型不会产生错误：
- en: '[PRE66]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[18.8 `Record<K, V>` for dictionary objects](#record-for-dictionary-objects)'
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[18.8 `Record<K, V>` 用于字典对象](#record-for-dictionary-objects)'
- en: 'The built-in generic utility type `Record<K, V>` is for dictionary objects
    whose keys are of type `K` and whose values are of type `V`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的泛型实用工具类型 `Record<K, V>` 是用于键类型为 `K` 且值类型为 `V` 的字典对象：
- en: '[PRE67]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If you are curious how `Record` is defined: [“`Record` is a mapped type” (§36.6)](ch_mapped-types.html#utility-type-record).
    This knowledge can help with remembering how it handles finite and infinite key
    types.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇 `Record` 是如何定义的：[“`Record` 是一个映射类型” (§36.6)](ch_mapped-types.html#utility-type-record)。这种知识可以帮助你记住它如何处理有限和无限键类型。
- en: '`Record` supports unions of literal types as key types; index signatures don’t.
    More on that next.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`Record` 支持字面类型联合作为键类型；索引签名不支持。更多内容将在下文中介绍。'
- en: '[18.8.1 Index signatures don’t allow key unions](#index-signatures-don-t-allow-key-unions)'
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.8.1 索引签名不允许键联合](#index-signatures-don-t-allow-key-unions)'
- en: 'The key type of an index signature must be infinite:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 索引签名的键类型必须是无限的：
- en: '[PRE68]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[18.8.2 `Record` enforces exhaustiveness for key unions](#record-enforces-exhaustiveness-for-key-unions)'
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.8.2 `Record` 强制执行键联合的详尽性](#record-enforces-exhaustiveness-for-key-unions)'
- en: '`Record` enforces exhaustiveness if its key type is a union of literal types:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Record` 的键类型是字面类型联合时，它强制执行详尽性：
- en: '[PRE69]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Wrong keys also produce errors:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的键也会产生错误：
- en: '[PRE70]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[18.8.3 `Record`: preventing exhaustiveness checks for key unions](#record-preventing-exhaustiveness-checks-for-key-unions)'
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.8.3 `Record`：防止对键联合进行详尽性检查](#record-preventing-exhaustiveness-checks-for-key-unions)'
- en: 'If we want to prevent exhaustiveness checks for keys whose type is a union
    then we can use the utility type `Partial` (which makes all properties optional).
    Then we can omit some properties, but wrong keys still produce errors:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想防止对类型为联合的键进行详尽性检查，则可以使用实用工具类型 `Partial`（它使所有属性都成为可选的）。然后我们可以省略一些属性，但错误的键仍然会产生错误：
- en: '[PRE71]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[18.9 `object` vs `Object` vs. `{}`](#general-types-for-objects)'
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[18.9 `object` 与 `Object` 与 `{}`](#general-types-for-objects)'
- en: 'These are three similar general types for objects:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是三种类似的对象通用类型：
- en: '`object` with a lowercase “o” is the type of all non-primitive values. It’s
    loosely related to the value `''object''` returned by the JavaScript operator
    `typeof`.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小写“o”的 `object` 是所有非原始值的类型。它与 JavaScript 操作符 `typeof` 返回的值 `'object'` 稍有相关。
- en: '[PRE72]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`Object` with an uppercase “O” is the type of the instances of class `Object`:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大写“O”的 `Object` 是类 `Object` 实例的类型：
- en: '[PRE73]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'But it also accepts primitive values (except for `undefined` and `null`):'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但它也接受原始值（除了 `undefined` 和 `null`）：
- en: '[PRE74]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Note that non-nullish primitive values inherit the methods of `Object.prototype`
    via their wrapper types.
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，非空原始值通过其包装类型继承 `Object.prototype` 的方法。
- en: '`{}` accepts all non-nullish values. Its only difference with `Object` is that
    it doesn’t mind if a property conflicts with `Object.prototype` properties:'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{}` 接受所有非空值。它与 `Object` 的唯一区别在于它不介意属性与 `Object.prototype` 属性冲突：'
- en: '[PRE75]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'So the type `{}` basically means: “Value must not be null”.'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，类型 `{}` 基本上意味着：“值不能为 null”。
- en: '![Icon “tip”](../Images/0873709827ba4924e4afbb757e47a4df.png) **These types
    are not used that often**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“提示”](../Images/0873709827ba4924e4afbb757e47a4df.png) **这些类型并不常用**'
- en: Given that we can’t access any properties if we use these types, they are not
    used that often. If a value does have that type, we usually narrow its type via
    a [type guard](ch_type-guards.html#ch_type-guards) before doing anything with
    it.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用这些类型时无法访问任何属性，因此它们并不常用。如果一个值确实有那种类型，我们通常在对其进行任何操作之前通过 [类型守卫](ch_type-guards.html#ch_type-guards)
    来缩小其类型。
- en: '[18.9.1 Plain JavaScript: objects vs. instances of `Object`](#plain-javascript-objects-vs-instances-of-object)'
  id: totrans-305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.9.1 纯 JavaScript：对象与 `Object` 类的实例](#plain-javascript-objects-vs-instances-of-object)'
- en: In plain JavaScript, there is an important distinction.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯 JavaScript 中，有一个重要的区别。
- en: On one hand, most objects are *instances* of `Object`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，大多数对象都是 `Object` 的实例。
- en: '[PRE76]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'That means:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着：
- en: '`Object.prototype` is in their prototype chains (that’s what `instanceof` checks):'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.prototype` 在它们的原型链中（这就是 `instanceof` 检查的内容）：'
- en: '[PRE77]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: They inherit its properties.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们继承其属性。
- en: '[PRE78]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'On the other hand, we can also create objects that don’t have `Object.prototype`
    in their prototype chains. For example, the following object does not have any
    prototype at all:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们也可以创建没有 `Object.prototype` 在其原型链中的对象。例如，以下对象没有任何原型：
- en: '[PRE79]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '`obj2` is an object that is not an instance of class `Object`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj2` 是一个不是 `Object` 类实例的对象：'
- en: '[PRE80]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[18.9.2 `Object` (uppercase “O”) in TypeScript: instances of class `Object`](#object-uppercase-o-in-typescript-instances-of-class-object)'
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.9.2 TypeScript 中的 `Object`（大写“O”）：`Object` 类的实例](#object-uppercase-o-in-typescript-instances-of-class-object)'
- en: 'Recall that each class `C` creates two entities:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，每个类 `C` 创建两个实体：
- en: A constructor function `C`.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个构造函数 `C`。
- en: An object type `C` that describes instances of the constructor function.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个描述构造函数实例的对象类型 `C`。
- en: 'Similarly, there are two object types for class `Object`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于 `Object` 类也有两种对象类型：
- en: Type `Object` specifies the properties of instances of `Object`, including the
    properties inherited from `Object.prototype`.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型 `Object` 指定了 `Object` 类实例的属性，包括从 `Object.prototype` 继承的属性。
- en: Type `ObjectConstructor` specifies the properties of class `Object` (an object
    with properties).
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型 `ObjectConstructor` 指定了 `Object` 类（具有属性的对象）的属性。
- en: 'These are the types:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是类型：
- en: '[PRE81]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Observations:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 观察：
- en: We have both a variable whose name is `Object` (line D) and a type whose name
    is `Object` (line A).
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个名为 `Object` 的变量（行 D）和一个名为 `Object` 的类型（行 A）。
- en: '`Object.prototype` also has the type `Object` (line C). Given that any instance
    of `Object` inherits all of its properties, that makes sense.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.prototype` 也有类型 `Object`（行 C）。鉴于任何 `Object` 的实例都继承其所有属性，这是有道理的。'
- en: It’s interesting that, in line B, `.valueOf()` has the return type `Object`
    and is supposed to return primitive values.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很有趣的是，在行 B 中，`.valueOf()` 的返回类型是 `Object`，并且应该返回原始值。
- en: '[18.9.3 Type `{}` basically means: not nullish](#type-basically-means-not-nullish)'
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.9.3 类型 `{}` 基本上意味着：非空值](#type-basically-means-not-nullish)'
- en: '`{}` accepts all values other than `undefined` and `null`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`{}` 接受所有除了 `undefined` 和 `null` 以外的值：'
- en: '[PRE82]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The helper type `NonNullable` uses `{}`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '辅助类型 `NonNullable` 使用 `{}`:'
- en: '[PRE83]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The result of `NonNullable<T>` is a type that is the intersection of `T` and
    all non-nullish values.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`NonNullable<T>` 的结果是 `T` 和所有非空值交集的类型。'
- en: '[18.9.4 Inferred types for various objects](#inferred-types-for-various-objects)'
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.9.4 各种对象的推断类型](#inferred-types-for-various-objects)'
- en: 'These are the types that TypeScript infers for objects that are created via
    various means:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 TypeScript 为通过各种方式创建的对象推断的类型：
- en: '[PRE84]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: In principle, the return type of `Object.create()` could (and probably should)
    be `object` or a computed type. However, for historic reasons, it is `any`. That
    allows us to add and change properties of the result.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，`Object.create()` 的返回类型可以是 `object` 或计算出的类型。然而，出于历史原因，它是 `any`。这允许我们添加和更改结果的属性。
- en: '[18.10 Summary: `object` vs `Object` vs. `{}` vs. `Record`](#summary-object-vs-object-vs-vs-record)'
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[18.10 总结：`object` vs `Object` vs. `{}` vs. `Record`](#summary-object-vs-object-vs-vs-record)'
- en: 'The following table compares four types for objects:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 下表比较了对象的四种类型：
- en: '|  | `object` | `Object` | `{}` | `Record` |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '|  | `object` | `Object` | `{}` | `Record` |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Accepts `undefined` or `null` | ✘ | ✘ | ✘ | ✘ |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 接受 `undefined` 或 `null` | ✘ | ✘ | ✘ | ✘ |'
- en: '| Accepts primitive values | ✘ | ✔ | ✔ | ✘ |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 接受原始值 | ✘ | ✔ | ✔ | ✘ |'
- en: '| Has `.toString()` | ✔ | ✔ | ✔ | N/A |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 有 `.toString()` | ✔ | ✔ | ✔ | N/A |'
- en: '| Values can conflict with `Object` | ✔ | ✘ | ✔ | N/A |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| 值可能与 `Object` 冲突 | ✔ | ✘ | ✔ | N/A |'
- en: The last two table rows don’t really make sense for `Record` – which is why
    there is an “N/A” in its cells.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行表格对于 `Record` 来说实际上没有太多意义——这就是为什么它的单元格中有一个“N/A”。
- en: '**Accepts `undefined` or `null`:**'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**接受 `undefined` 或 `null`：**'
- en: '[PRE85]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '**Accepts primitive values:**'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**接受原始值：**'
- en: '[PRE86]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '**Has `.toString()`:**'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**具有 `.toString()` 方法：**'
- en: '[PRE87]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '**Values can conflict with `Object`:**'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**值可能与 `Object` 冲突：**'
- en: '[PRE88]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[18.11 Sources of this chapter](#sources-of-this-chapter-2)'
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[18.11 本章来源](#sources-of-this-chapter-2)'
- en: '[TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/basic-types.html)'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[TypeScript 手册](https://www.typescriptlang.org/docs/handbook/basic-types.html)'
