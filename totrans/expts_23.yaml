- en: 18 Typing objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/ts/book/ch_typing-objects.html](https://exploringjs.com/ts/book/ch_typing-objects.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Ad, please don’t block.)
  prefs: []
  type: TYPE_NORMAL
- en: '[18.1 Object types](#object-types)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.1.1 The two ways of using objects](#ways-of-using-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.1.2 Object types work structurally in TypeScript](#object-types-work-structurally-in-typescript)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.2 Members of object literal types](#members-of-object-literal-types)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.2.1 Method signatures](#method-signatures)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.2.2 Keys of object type members](#keys-of-object-type-members)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.2.3 Modifiers of object type members](#modifiers-of-object-type-members)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.3 Excess property checks: When are extra properties allowed?](#excess-property-checks-when-are-extra-properties-allowed)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.3.1 Why are excess properties forbidden in object literals?](#why-are-excess-properties-forbidden-in-object-literals)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.3.2 Why are excess properties allowed if an object comes from somewhere
    else?](#why-are-excess-properties-allowed-if-an-object-comes-from-somewhere-else)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.3.3 Empty object literal types allow excess properties](#empty-object-literal-types-allow-excess-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.3.4 Matching only objects without properties](#matching-only-objects-without-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.3.5 Allowing excess properties in object literals](#allowing-excess-properties-in-object-literals)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.4 Object types and inherited properties](#object-types-and-inherited-properties)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.4.1 TypeScript doesn’t distinguish own and inherited properties](#typescript-doesn-t-distinguish-own-and-inherited-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.4.2 Object literal types describe instances of `Object`](#object-literal-types-describe-instances-of-object)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.5 Interfaces vs. object literal types](#interfaces-vs-object-literal-types)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.5.1 Object literal types can be inlined](#object-literal-types-can-be-inlined)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.5.2 Interfaces with the same name are merged](#interfaces-with-the-same-name-are-merged)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.5.3 Mapped types look like object literal types](#mapped-types-look-like-object-literal-types)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.5.4 Only interfaces support polymorphic `this` types](#only-interfaces-support-polymorphic-this-types)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.5.5 Only interfaces support `extends` – but type intersection (`&`) is
    similar](#extending-interfaces)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.6 Forbidding properties via `never`](#forbidding-properties-via-never)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.6.1 Forbidding properties with string keys](#forbidding-properties-with-string-keys)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.6.2 Forbidding index properties (with number keys)](#forbidding-index-properties-with-number-keys)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.7 Index signatures: objects as dictionaries](#index-signatures)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.7.1 Typing index signature keys](#typing-index-signature-keys)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.7.2 String keys vs. number keys](#string-keys-vs-number-keys)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.7.3 Index signatures vs. property signatures and method signatures](#index-signatures-vs-property-signatures-and-method-signatures)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.8 `Record<K, V>` for dictionary objects](#record-for-dictionary-objects)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.8.1 Index signatures don’t allow key unions](#index-signatures-don-t-allow-key-unions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.8.2 `Record` enforces exhaustiveness for key unions](#record-enforces-exhaustiveness-for-key-unions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.8.3 `Record`: preventing exhaustiveness checks for key unions](#record-preventing-exhaustiveness-checks-for-key-unions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.9 `object` vs `Object` vs. `{}`](#general-types-for-objects)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.9.1 Plain JavaScript: objects vs. instances of `Object`](#plain-javascript-objects-vs-instances-of-object)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.9.2 `Object` (uppercase “O”) in TypeScript: instances of class `Object`](#object-uppercase-o-in-typescript-instances-of-class-object)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.9.3 Type `{}` basically means: not nullish](#type-basically-means-not-nullish)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.9.4 Inferred types for various objects](#inferred-types-for-various-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.10 Summary: `object` vs `Object` vs. `{}` vs. `Record`](#summary-object-vs-object-vs-vs-record)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18.11 Sources of this chapter](#sources-of-this-chapter-2)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this chapter, we will explore how objects and properties are typed statically
    in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.1 Object types](#object-types)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[18.1.1 The two ways of using objects](#ways-of-using-objects)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two ways of using objects in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixed-layout object: Used this way, an object works like a record in a database.
    It has a fixed number of properties, whose keys are known at development time.
    Their values generally have different types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Dictionary object: Used this way, an object works like a lookup table or a
    map. It has a variable number of properties, whose keys are not known at development
    time. All of their values have the same type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that the two ways can also be mixed: Some objects are both fixed-layout
    objects and dictionary objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common ways of typing these two kinds of objects are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`FixedLayoutObjectType` is an object literal type. The separators between properties
    can be either commas (`,`) or semicolons (`;`). I prefer the former because that’s
    what JavaScript object literals use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DictionaryObjectType` uses the utility type `Record` to define a type for
    dictionary objects whose keys are strings and whose values are numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we’ll look at fixed-layout object types in more detail before coming back
    to dictionary object types.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.1.2 Object types work structurally in TypeScript](#object-types-work-structurally-in-typescript)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Object types work structurally in TypeScript: They match all values that have
    their structure. Therefore, a type can be defined after a given value and still
    match it – e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For more information on this topic, see [“Nominal type systems vs. structural
    type systems” (§13.4)](ch_what-is-a-type.html#nominal-vs-structural-type-systems).
  prefs: []
  type: TYPE_NORMAL
- en: '[18.2 Members of object literal types](#members-of-object-literal-types)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The constructs inside the bodies of object literal types are called their *members*.
    These are the most common members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at these members in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Property signatures define properties and should be self-explanatory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Method signatures define methods and are described in the next subsection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note: The names of parameters (in this case: `str`) help with documenting how
    things work but have no other purpose.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Index signatures are needed to describe Arrays or objects that are used as dictionaries.
    They are described [later in this chapter](#index-signatures).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note: The name `key` is only there for documentation purposes.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Call signatures enable object literal types to describe functions. See [“Interfaces
    with call signatures” (§27.2.2)](ch_typing-functions.html#call-signatures).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Construct signatures enable object literal types to describe classes and constructor
    functions. See [“Object type literals with construct signatures” (§23.2.3)](ch_classes-as-values.html#construct-signatures).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[18.2.1 Method signatures](#method-signatures)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As far as TypeScript’s type system is concerned, method definitions and properties
    whose values are functions, are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: My recommendation is to use whichever syntax best expresses how a property should
    be set up.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.2.2 Keys of object type members](#keys-of-object-type-members)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[18.2.2.1 Quoted keys](#quoted-keys)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Just like in JavaScript, property keys can be quoted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[18.2.2.2 Unquoted numbers as keys](#unquoted-numbers-as-keys)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This rarely matters in practice, but as an aside: Just like in JavaScript,
    we can use unquoted numbers as keys. Unlike JavaScript, those keys are considered
    to be number literal types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For comparison, this is how JavaScript works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For more information see [$type](ch_computing-with-types-overview.html#number-keys-javascript-vs-typescript).
  prefs: []
  type: TYPE_NORMAL
- en: '[18.2.2.3 Computed property keys](#computed-property-keys)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Computed property keys](https://exploringjs.com/js/book/ch_objects.html#object-literals-computed-keys)
    are a JavaScript feature. There is a similar feature at the type level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Unexpectedly, computed property keys are values, not types. TypeScript internally
    applies `typeof` to create the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'What kind of value is allowed as a computed property key? Its type must be:'
  prefs: []
  type: TYPE_NORMAL
- en: A string literal type such as `'abc'`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number literal type such as `123`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unique symbol type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`any`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[18.2.3 Modifiers of object type members](#modifiers-of-object-type-members)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[18.2.3.1 Optional properties](#optional-properties-1)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If we put a question mark (`?`) after the name of a property, that property
    is optional. The same syntax is used to mark parameters of functions, methods,
    and constructors as optional. In the following example, property `.middle` is
    optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, it’s OK to omit that property (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[18.2.3.1.1 Optional vs. `undefined | string` with `exactOptionalPropertyTypes`](#optional-vs-undefined-string-with-ex-act-op-tion-al-prop-er-ty-types)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In this book, all code uses the compiler setting [`exactOptionalPropertyTypes`](ch_tsconfig-json.html#exactOptionalPropertyTypes).
    With that setting, the difference an optional property and a property with type
    `undefined | string` is intuitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Types such as `undefined | string` and `null | string` are useful if we want
    to make omissions explicit. When people see such an explicitly omitted property,
    they know that it exists but was switched off.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.2.3.1.2 Optional vs. `undefined | string` without `exactOptionalPropertyTypes`](#optional-vs-undefined-string-without-ex-act-op-tion-al-prop-er-ty-types)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If `exactOptionalPropertyTypes` is `false` then one thing changes: `.prop1`
    can also be `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[18.2.3.2 Read-only properties](#read-only-properties)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the following example, property `.prop` is read-only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As a consequence, we can read it, but we can’t change it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[18.3 Excess property checks: When are extra properties allowed?](#excess-property-checks-when-are-extra-properties-allowed)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As an example, consider the following object literal type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two ways (among others) in which this object literal type could be
    interpreted:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Closed interpretation: It could describe all objects that have *exactly* the
    properties `.x` and `.y` with the specified types. On other words: Those objects
    must not have *excess properties* (more than the required properties).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open interpretation: It could describe all objects that have *at least* the
    properties `.x` and `.y`. In other words: Excess properties are allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TypeScript uses both interpretations. To explore how that works, we will use
    the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The default is that the excess property `.z` is allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we use object literals directly, then excess properties are forbidden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[18.3.1 Why are excess properties forbidden in object literals?](#why-are-excess-properties-forbidden-in-object-literals)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Why the stricter rules for object literals? They provide protection against
    typos in property keys. We will use the following object literal type to demonstrate
    what that means.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Property `.middle` is optional and can be omitted. To TypeScript, mistyping
    its name looks like omitting it and providing an excess property. However, it
    still catches the typo because excess properties are not allowed in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[18.3.2 Why are excess properties allowed if an object comes from somewhere
    else?](#why-are-excess-properties-allowed-if-an-object-comes-from-somewhere-else)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The idea is that if an object comes from somewhere else, we can assume that
    it has already been vetted and will not have any typos. Then we can afford to
    be less careful.
  prefs: []
  type: TYPE_NORMAL
- en: 'If typos are not an issue, our goal should be maximizing flexibility. Consider
    the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Without allowing excess properties for values that are passed to `getAge()`,
    the usefulness of this function would be quite limited.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.3.3 Empty object literal types allow excess properties](#empty-object-literal-types-allow-excess-properties)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If an object literal type is empty, excess properties are always allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[18.3.4 Matching only objects without properties](#matching-only-objects-without-properties)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we want to enforce that an object has no properties, we can use the following
    trick (credit: [Geoff Goodman](https://twitter.com/filearts/status/1222502898552180737)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[18.3.5 Allowing excess properties in object literals](#allowing-excess-properties-in-object-literals)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What if we want to allow excess properties in object literals? As an example,
    consider type `Point` and function `computeDistance1()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'One option is to assign the object literal to an intermediate variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'A second option is to use a type assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'A third option is to rewrite `computeDistance1()` so that it uses a type parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'A fourth option is to extend `Point` so that it allows excess properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We used an intersection type (`&` operator) to define `PointEtc`. For more information,
    see [“Intersections of object types” (§20.1)](ch_intersections-object-types.html#intersections-of-object-types).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll continue with two examples where TypeScript not allowing excess properties,
    is a problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.3.5.1 Allowing excess properties: example `Incrementor` factory](#allowing-excess-properties-example-incrementor-factory)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In this example, we implement a factory for objects of type `Incrementor` and
    would like to return a subtype, but TypeScript doesn’t allow the extra property
    `.counter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Alas, even with a type assertion, there is still one type error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: What does work is `as any` but then the type of the returned object is `any`
    and, e.g. inside `.inc()`, TypeScript doesn’t check if properties of `this` really
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'A proper solution is to add an index signature to `Incrementor`. Or – especially
    if that is not possible – to introduce an intermediate variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[18.3.5.2 Allowing excess properties: example `.dateStr`](#allowing-excess-properties-example-datestr)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following comparison function can be used to sort objects that have the
    property `.dateStr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: For example in unit tests, we may want to invoke this function directly with
    object literals. TypeScript doesn’t let us do this and we need to use one of the
    workarounds.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.4 Object types and inherited properties](#object-types-and-inherited-properties)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[18.4.1 TypeScript doesn’t distinguish own and inherited properties](#typescript-doesn-t-distinguish-own-and-inherited-properties)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TypeScript doesn’t distinguish own and inherited properties. They are all simply
    considered to be properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`obj` inherits `.toString()` from `Object.prototype`.'
  prefs: []
  type: TYPE_NORMAL
- en: The downside of this approach is that some phenomena in JavaScript can’t be
    described via TypeScript’s type system. The upside is that the type system is
    simpler.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.4.2 Object literal types describe instances of `Object`](#object-literal-types-describe-instances-of-object)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'All object literal types describe objects that are instances of `Object` and
    inherit the properties of `Object.prototype`. In the following example, the parameter
    `x` of type `{}` is compatible with the return type `Object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, `{}` has a method `.toString()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[18.5 Interfaces vs. object literal types](#interfaces-vs-object-literal-types)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For historical reasons, object types can be defined in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, either semicolons or commas can be used as separators. I prefer
    commas for object literal types and semicolons for interfaces because that reflects
    what JavaScript looks like (object literals and classes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trailing separators are allowed and optional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both ways of defining an object type are more or less equivalent now. We’ll
    dive into the (minor) differences next.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.5.1 Object literal types can be inlined](#object-literal-types-can-be-inlined)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Object literal types can be inlined, while interfaces can’t be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[18.5.2 Interfaces with the same name are merged](#interfaces-with-the-same-name-are-merged)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Type aliases with duplicate names are illegal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Conversely, interfaces with duplicate names are merged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is called [declaration merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html)
    and can be used to combine types from multiple sources – e.g., as long as `Array.fromAsync()`
    is a new method, it is not part of the core library declaration file, but provided
    via `lib.esnext.array.d.ts` – which adds it as an increment to `ArrayConstructor`
    (the type of `Array` as a class value):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[18.5.3 Mapped types look like object literal types](#mapped-types-look-like-object-literal-types)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A mapped type (line A) looks like an object literal type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As an option, we can end line A with a semicolon. Alas, a comma is not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on this topic, see [“Mapped types `{[K in U]: X}`” (§36)](ch_mapped-types.html#ch_mapped-types).'
  prefs: []
  type: TYPE_NORMAL
- en: '[18.5.4 Only interfaces support polymorphic `this` types](#only-interfaces-support-polymorphic-this-types)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Polymorphic `this` types can only be used in interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[18.5.5 Only interfaces support `extends` – but type intersection (`&`) is
    similar](#extending-interfaces)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An interface `B` can extend another interface `A` and is then interpreted as
    an increment of `A`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Object literal types don’t support `extend` but an intersection type `&` has
    a similar effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Intersections of object types are described in more detail in [another chapter](ch_intersections-object-types.html#intersections-of-object-types).
    Here, we’ll explore how exactly they differ from `extends`.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.5.5.1 Conflicts](#conflicts)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If there is a conflict between an extending interface and an extended interface
    then that’s an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, intersection types don’t complain about conflicts, but they may
    result in `never` in some locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[18.5.5.2 Only interfaces support overriding](#only-interfaces-support-overriding)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Overriding a method means replacing a method in a supertype with a *compatible*
    method – roughly:'
  prefs: []
  type: TYPE_NORMAL
- en: The overriding method can return more specific values – e.g. invokers of the
    overridden method that expect an `Object` won’t mind if the overriding method
    returns a `RegExp`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overriding method can expect less specific parameters – e.g. invokers of
    the overridden method that pass an argument of type `string` won’t mind if the
    overriding method accepts `string | number`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the overriding method “wins” and completely replaces the overridden
    method in `B`. In contrast, both methods exist in parallel in an intersection
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'When it comes to the return type (line A and line B), the earlier member of
    the intersection wins. That’s why `B & A` (`B1`) is more similar to `B extends
    A`, even though `A & B` (`B2`) looks nicer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[18.5.5.3 `extends` or `&` – which one to use?](#extends-or-which-one-to-use)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Which one to use depends on the context. If inheritance is involved then an
    interface and `extends` is usually the better choice due to their support of overriding.
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “external”](../Images/c1f1e62c75044317fd354db81eaefed3.png) **Source
    of this section**'
  prefs: []
  type: TYPE_NORMAL
- en: '[GitHub issue “TypeScript: types vs. interfaces”](https://github.com/peerigon/eslint-config-peerigon/issues/64)
    by [Johannes Ewald](https://github.com/jhnns)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[18.6 Forbidding properties via `never`](#forbidding-properties-via-never)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given that no other type is assignable to `never`, we can use it to forbid properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.6.1 Forbidding properties with string keys](#forbidding-properties-with-string-keys)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The type `EmptyObject` forbids string keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, the type `{}` is assignable from all objects and not a type for
    empty objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[18.6.2 Forbidding index properties (with number keys)](#forbidding-index-properties-with-number-keys)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The type `NoIndices` forbids number keys but allows the string key `''prop''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[18.7 Index signatures: objects as dictionaries](#index-signatures)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we have only used types for fixed-layout objects. How do we express
    the fact that an object is to be used as a dictionary? For example: What should
    `TranslationDict` be in the following code fragment?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'One option is to use an index signature (line A) to express that `TranslationDict`
    is for objects that map string keys to string values (another option is `Record`
    – which we’ll get to [later](#record-for-dictionary-objects)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The name `key` doesn’t matter – it can be any identifier and is ignored (but
    can’t be omitted).
  prefs: []
  type: TYPE_NORMAL
- en: '[18.7.1 Typing index signature keys](#typing-index-signature-keys)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An index signature represents an infinite set of properties; only the following
    types are allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symbol`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A template string literal with an infinite primitive type – e.g.: `` `${bigint}`
    ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A union of any of the previous types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Specifically *not* allowed are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A single string literal type – e.g.: `''a''`, `1`, `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A union of string literal types – e.g.:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''a'' | ''b''`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1 | 2`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean` (which is `false | true`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A template string literal with one of the previous types – e.g.: `` `${boolean}`
    ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The types: `never`, `any`, `unknown`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need more power then consider using [a mapped types](ch_mapped-types.html#ch_mapped-types).
  prefs: []
  type: TYPE_NORMAL
- en: 'These are examples of index signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[18.7.2 String keys vs. number keys](#string-keys-vs-number-keys)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Just like in plain JavaScript, TypeScript’s number property keys are a subset
    of the string property keys ([see “Exploring JavaScript”](https://exploringjs.com/js/book/ch_arrays.html#array-indices)).
    Accordingly, if we have both a string index signature and a number index signature,
    the property type of the former must be a supertype of the latter. The following
    example works because `Object` is a supertype of `RegExp` (`RegExp` is assignable
    to `Object`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code demonstrates the effects of using strings and numbers as
    property keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[18.7.3 Index signatures vs. property signatures and method signatures](#index-signatures-vs-property-signatures-and-method-signatures)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If there are both an index signature and property and/or method signatures in
    an object literal type, then the type of the index property value must also be
    a supertype of the type of the property value and/or method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, the following two object literal types produce no errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[18.8 `Record<K, V>` for dictionary objects](#record-for-dictionary-objects)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The built-in generic utility type `Record<K, V>` is for dictionary objects
    whose keys are of type `K` and whose values are of type `V`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are curious how `Record` is defined: [“`Record` is a mapped type” (§36.6)](ch_mapped-types.html#utility-type-record).
    This knowledge can help with remembering how it handles finite and infinite key
    types.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Record` supports unions of literal types as key types; index signatures don’t.
    More on that next.'
  prefs: []
  type: TYPE_NORMAL
- en: '[18.8.1 Index signatures don’t allow key unions](#index-signatures-don-t-allow-key-unions)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The key type of an index signature must be infinite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[18.8.2 `Record` enforces exhaustiveness for key unions](#record-enforces-exhaustiveness-for-key-unions)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Record` enforces exhaustiveness if its key type is a union of literal types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Wrong keys also produce errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[18.8.3 `Record`: preventing exhaustiveness checks for key unions](#record-preventing-exhaustiveness-checks-for-key-unions)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we want to prevent exhaustiveness checks for keys whose type is a union
    then we can use the utility type `Partial` (which makes all properties optional).
    Then we can omit some properties, but wrong keys still produce errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[18.9 `object` vs `Object` vs. `{}`](#general-types-for-objects)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These are three similar general types for objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`object` with a lowercase “o” is the type of all non-primitive values. It’s
    loosely related to the value `''object''` returned by the JavaScript operator
    `typeof`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Object` with an uppercase “O” is the type of the instances of class `Object`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'But it also accepts primitive values (except for `undefined` and `null`):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that non-nullish primitive values inherit the methods of `Object.prototype`
    via their wrapper types.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`{}` accepts all non-nullish values. Its only difference with `Object` is that
    it doesn’t mind if a property conflicts with `Object.prototype` properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So the type `{}` basically means: “Value must not be null”.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Icon “tip”](../Images/0873709827ba4924e4afbb757e47a4df.png) **These types
    are not used that often**'
  prefs: []
  type: TYPE_NORMAL
- en: Given that we can’t access any properties if we use these types, they are not
    used that often. If a value does have that type, we usually narrow its type via
    a [type guard](ch_type-guards.html#ch_type-guards) before doing anything with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.9.1 Plain JavaScript: objects vs. instances of `Object`](#plain-javascript-objects-vs-instances-of-object)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In plain JavaScript, there is an important distinction.
  prefs: []
  type: TYPE_NORMAL
- en: On one hand, most objects are *instances* of `Object`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'That means:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.prototype` is in their prototype chains (that’s what `instanceof` checks):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: They inherit its properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the other hand, we can also create objects that don’t have `Object.prototype`
    in their prototype chains. For example, the following object does not have any
    prototype at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '`obj2` is an object that is not an instance of class `Object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[18.9.2 `Object` (uppercase “O”) in TypeScript: instances of class `Object`](#object-uppercase-o-in-typescript-instances-of-class-object)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Recall that each class `C` creates two entities:'
  prefs: []
  type: TYPE_NORMAL
- en: A constructor function `C`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object type `C` that describes instances of the constructor function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly, there are two object types for class `Object`:'
  prefs: []
  type: TYPE_NORMAL
- en: Type `Object` specifies the properties of instances of `Object`, including the
    properties inherited from `Object.prototype`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type `ObjectConstructor` specifies the properties of class `Object` (an object
    with properties).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Observations:'
  prefs: []
  type: TYPE_NORMAL
- en: We have both a variable whose name is `Object` (line D) and a type whose name
    is `Object` (line A).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.prototype` also has the type `Object` (line C). Given that any instance
    of `Object` inherits all of its properties, that makes sense.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s interesting that, in line B, `.valueOf()` has the return type `Object`
    and is supposed to return primitive values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[18.9.3 Type `{}` basically means: not nullish](#type-basically-means-not-nullish)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`{}` accepts all values other than `undefined` and `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The helper type `NonNullable` uses `{}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The result of `NonNullable<T>` is a type that is the intersection of `T` and
    all non-nullish values.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.9.4 Inferred types for various objects](#inferred-types-for-various-objects)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These are the types that TypeScript infers for objects that are created via
    various means:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: In principle, the return type of `Object.create()` could (and probably should)
    be `object` or a computed type. However, for historic reasons, it is `any`. That
    allows us to add and change properties of the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[18.10 Summary: `object` vs `Object` vs. `{}` vs. `Record`](#summary-object-vs-object-vs-vs-record)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following table compares four types for objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | `object` | `Object` | `{}` | `Record` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Accepts `undefined` or `null` | ✘ | ✘ | ✘ | ✘ |'
  prefs: []
  type: TYPE_TB
- en: '| Accepts primitive values | ✘ | ✔ | ✔ | ✘ |'
  prefs: []
  type: TYPE_TB
- en: '| Has `.toString()` | ✔ | ✔ | ✔ | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| Values can conflict with `Object` | ✔ | ✘ | ✔ | N/A |'
  prefs: []
  type: TYPE_TB
- en: The last two table rows don’t really make sense for `Record` – which is why
    there is an “N/A” in its cells.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accepts `undefined` or `null`:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '**Accepts primitive values:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '**Has `.toString()`:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '**Values can conflict with `Object`:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[18.11 Sources of this chapter](#sources-of-this-chapter-2)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/basic-types.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
