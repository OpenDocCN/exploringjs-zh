["```ts\nimport * as path from 'node:path';\nimport assert from 'node:assert/strict';\nexport function replaceExt(filePath: string, ext: string): string {\n assert(ext.startsWith('.')); // (A)\n const parsed = path.parse(filePath);\n return path.join(parsed.dir, parsed.name + ext);\n}\n\n```", "```ts\nimport assert from 'node:assert/strict';\nconst add = (x: number, y: number) => x + y;\nassert.equal(\n add(3, 4), 7\n);\n\n```", "```ts\nfunction assertCondition(condition: boolean): asserts condition {\n // ...\n}\n\n```", "```ts\nfunction assertArgIsMyType(arg: unknown): asserts arg is MyType {\n // ...\n}\n\n```", "```ts\nfunction assertTrue(\n condition: boolean, message?: string | Error\n): asserts condition { // (A)\n if (!condition) {\n if (message instanceof Error) {\n throw message;\n }\n message ??= 'Assertion failed';\n throw new Error(message); // (B)\n }\n}\n\n```", "```ts\nif («typeGuard») {\n // One or more types are narrowed\n}\n\n```", "```ts\nassertTrue(«typeGuard»);\n// One or more types are narrowed\n\n```", "```ts\nfunction func(value: unknown) {\n assertTrue(value instanceof Set); // (A)\n assertType<Set<any>>(value);\n}\n\n```", "```ts\nfunction assertIsNumber(value: unknown): asserts value is number {\n if (typeof value !== 'number') {\n throw new TypeError();\n }\n}\n\n```", "```ts\nfunction func(value: unknown) {\n assertIsNumber(value); // (A)\n assertType<number>(value);\n}\n\n```", "```ts\nfunction func(str: string) {\n assertIsNumber(str);\n // string & number is `never`\n assertType<string & number>(str);\n}\n\n```", "```ts\nfunction assertEqual<T>(\n actual: unknown, expected: T, message?: string | Error\n): asserts actual is T {\n if (actual !== expected) {\n if (message instanceof Error) {\n throw message;\n }\n message ??= `Assertion failed: ${actual} === ${expected}`;\n throw new Error(message);\n }\n}\n\n```", "```ts\nexport function assertNonNullable<T>(\n value: T, message?: string\n): asserts value is NonNullable<T> {\n if (value === undefined || value === null) {\n message ??= 'Value must not be undefined or null';\n throw new TypeError(message);\n }\n}\n\n```", "```ts\nfunction getValue(map: Map<string, number>, key: string): number {\n const value = map.get(key);\n assertType<undefined | number>(value);\n assertNonNullable(value);\n assertType<number>(value);\n return value;\n}\n\n```", "```ts\nfunction addName<T extends object>(obj: T, name: string)\n: asserts obj is (T & HasName) { // (A)\n (obj as HasName).name = name;\n}\ntype HasName = {\n name: string,\n};\n\nconst point = { x: 0, y: 0 };\naddName(point, 'zero');\nassertType<{ x: number, y: number, name: string }>(point);\n\n```", "```ts\nfunction forceNumber(value: unknown): number {\n if (typeof value !== 'number') {\n throw new TypeError();\n }\n return value;\n}\n\nconst value1a: unknown = 123;\nconst value1b = forceNumber(value1a);\nassertType<number>(value1b);\n\nconst value2: unknown = 'abc';\nassert.throws(() => forceNumber(value2));\n\n```", "```ts\nfunction assertIsNumber(value: unknown): asserts value is number {\n if (typeof value !== 'number') {\n throw new TypeError();\n }\n}\n\nconst value1: unknown = 123;\nassertIsNumber(value1);\nassertType<number>(value1);\n\nconst value2: unknown = 'abc';\nassert.throws(() => assertIsNumber(value2));\n\n```", "```ts\nfunction getLengthOfValue(strMap: Map<string, string>, key: string)\n: number {\n if (strMap.has(key)) {\n const value = strMap.get(key);\n\n assertType<string | undefined>(value); // before type check\n // We know that value can’t be `undefined`\n if (value === undefined) { // (A)\n throw new Error();\n }\n assertType<string>(value); // after type check\n\n return value.length;\n }\n return -1;\n}\n\n```", "```ts\nassertNonNullable(value);\n\n```", "```ts\nfunction assertTrue(condition: boolean): asserts condition {\n if (!condition) {\n throw new Error(); // assertion error\n }\n}\n\n```", "```ts\nfunction assertIsString(value: unknown): asserts value is string {\n if (typeof value !== 'string') {\n throw new Error(); // assertion error\n }\n}\n\n```"]