["```js\n    <div class=\"entry\">\n     <h1>{{title}}</h1>\n     <div class=\"body\">\n     {{body}}\n     </div>\n    </div>\n\n    ```", "```js\n    // First step: retrieve the template text, e.g. from a text file.\n    const tmplFunc = Handlebars.compile(TMPL_TEXT); // compile string\n    const data = {title: 'My page', body: 'Welcome to my page!'};\n    const html = tmplFunc(data);\n\n    ```", "```js\n    const num = 5;\n    assert.equal(`Count: ${num}!`, 'Count: 5!');\n\n    ```", "```js\n    const getArgs = (...args) => args;\n    assert.deepEqual(\n     getArgs`Count: ${5}!`,\n     [['Count: ', '!'], 5] );\n\n    ```", "```js\nconst MAX = 100;\nfunction doSomeWork(x) {\n if (x > MAX) {\n throw new Error(`At most ${MAX} allowed: ${x}!`);\n }\n // ···\n}\nassert.throws(\n () => doSomeWork(101),\n {message: 'At most 100 allowed: 101!'});\n\n```", "```js\nconst str = `this is\na text with\nmultiple lines`;\n\n```", "```js\nfunction tagFunc(templateStrings, ...substitutions) {\n return {templateStrings, substitutions};\n}\n `const setting = 'dark mode';`\n`const value = true;`\n ```", "```js \n```", "```js```", "````js ````", "``` The function `tagFunc` before the first backtick is called a *tag function*. Its arguments are:    *   *Template strings* (first argument): an Array with the text fragments surrounding the interpolations `${}`.               *   In the example: `['Setting ', ' is ', '!']` *   *Substitutions* (remaining arguments): the interpolated values.               *   In the example: `'dark mode'` and `true`    The static (fixed) parts of the literal (the template strings) are kept separate from the dynamic parts (the substitutions).    A tag function can return arbitrary values.    #### [23.3.1 Cooked vs. raw template strings (advanced)](#template-strings-cooked-vs-raw)    So far, we have only seen the *cooked interpretation* of template strings. But tag functions actually get two interpretations:    *   A *cooked interpretation* where backslashes have special meaning. For example, `\\t` produces a tab character. This interpretation of the template strings is stored as an Array in the first argument.           *   A *raw interpretation* where backslashes do not have special meaning. For example, `\\t` produces two characters – a backslash and a `t`. This interpretation of the template strings is stored in property `.raw` of the first argument (an Array).              The raw interpretation enables raw string literals via `String.raw` [(described later)](#raw-string-literals) and similar applications.    The following tag function `cookedRaw` uses both interpretations:    ```", "```js    We can also use Unicode code point escapes (`\\u{1F642}`), Unicode code unit escapes (`\\u03A9`), and ASCII escapes (`\\x52`) in tagged templates:    ```", "```js    If the syntax of one of these escapes isn’t correct, the corresponding cooked template string is `undefined`, while the raw version is still verbatim:    ```", "```js    Incorrect escapes produce syntax errors in template literals and string literals. Before ES2018, they even produced errors in tagged templates. Why was that changed? We can now use tagged templates for text that was previously illegal – for example:    ```", "```js    ### [23.4 Examples of tagged templates (as provided via libraries)](#examples-of-tagged-templates-as-provided-via-libraries)    Tagged templates are great for supporting small embedded languages (so-called *domain-specific languages*). We’ll continue with a few examples.    #### [23.4.1 Tag function library: lit-html](#tag-function-library-lithtml)    [Lit](https://lit.dev) is a library for building web components that uses tagged templates for HTML templating:    ```", "```js `render() {`  `` return html` ``  `<ul>`  `${repeat(`  `this.items,`  `(item) => item.id,`  `` (item, index) => html`<li>${index}: ${item.name}</li>` ``  `)}`  `</ul>`  `` `; ``  `}` `}` ```", "```js   ```", "```js`` ```", "```js` `repeat()` is a custom function for looping. Its second parameter produces unique keys for the values returned by the third parameter. Note the nested tagged template used by that parameter.    #### [23.4.2 Tag function library: regex](#regex-library)    [The library “regex”](https://github.com/slevithan/regex) by Steven Levithan provides template tags that help with creating regular expressions and enable advanced features. The following example demonstrates how it works:    ```", "```js   ```", "```js ```", "```js import gql from 'graphql-tag';  `` const query = gql` ``  `{`  `user(id: 5) {`  `firstName`  `lastName`  `}`  `}`  `` `; ``  ```", "```js` Additionally, there are plugins for pre-compiling such queries in Babel, TypeScript, etc.    ### [23.5 Raw string literals via the template tag `String.raw`](#raw-string-literals)    Raw string literals are implemented via the tag function `String.raw`. They are string literals where backslashes don’t do anything special (such as escaping characters, etc.):    ```", "```js    This helps whenever data contains backslashes – for example, strings with regular expressions:    ```", "```js    All three regular expressions are equivalent. With a normal string literal, we have to write the backslash twice, to escape it for that literal. With a raw string literal, we don’t have to do that.    Raw string literals are also useful for specifying Windows filename paths:    ```", "```js    ### [23.6 Multiline template literals and indentation](#multiline-template-literals)    If we put multiline text in template literals, two goals are in conflict: On one hand, the template literal should be indented to fit inside the source code. On the other hand, the lines of its content should start in the leftmost column.    For example:    ```", "```js    Due to the indentation, the template literal fits well into the source code. Alas, the output is also indented. And we don’t want the return at the beginning and the return plus two spaces at the end.    ```", "```js    There are two ways to fix this: via a tagged template or by trimming the result of the template literal.    #### [23.6.1 Fix: indenting the text and removing the indentation via a template tag](#fix-indenting-the-text-and-removing-the-indentation-via-a-template-tag)    The first fix is to use a custom template tag that removes the unwanted whitespace. It uses the first line after the initial line break to determine in which column the text starts and shortens the indentation everywhere. It also removes the line break at the very beginning and the indentation at the very end. One such template tag is [`dedent` by Desmond Brand](https://github.com/dmnd/dedent):    ```", "```js    The output is not indented:    ```", "```js    #### [23.6.2 Fix: not indenting the text and removing leading and trailing whitespace via `.trim()`](#fix-not-indenting-the-text-and-removing-leading-and-trailing-whitespace-via-trim)    The second fix is quicker, but also dirtier:    ```", "```js    The string method `.trim()` removes the superfluous whitespace at the beginning and at the end, but the content itself can’t be indented – it must start in the leftmost column. The advantage of this solution is that we don’t need a custom tag function. The downside is that the unindented text doesn’t fit well into its surroundings.    The output is the same as with `dedent`:    ```", "```js    ### [23.7 Simple templating via template literals (advanced)](#simple-templating-via-template-literals-advanced)    While template literals look like text templates, it is not immediately obvious how to use them for (text) templating: A text template gets its data from an object, while a template literal gets its data from variables. The solution is to use a template literal in the body of a function whose parameter receives the templating data – for example:    ```", "```js    #### [23.7.1 A more complex example](#a-more-complex-example)    As a more complex example, we’d like to take an Array of addresses and produce an HTML table. This is the Array:    ```", "```js    The function `tmpl()` that produces the HTML table looks as follows:    ```", "```js    This code contains two templating functions:    *   The first one (line 1) takes `addrs`, an Array with addresses, and returns a string with a table. *   The second one (line 4) takes `addr`, an object containing an address, and returns a string with a table row. Note the `.trim()` at the end, which removes unnecessary whitespace.    The first templating function produces its result by wrapping a table element around an Array that it joins into a string (line 10). That Array is produced by mapping the second templating function to each element of `addrs` (line 3). It therefore contains strings with table rows.    The helper function `escapeHtml()` is used to escape special HTML characters (line 6 and line 7). Its implementation is shown in the next subsection.    Let us call `tmpl()` with the addresses and log the result:    ```", "```js    The output is:    ```", "```js    #### [23.7.2 Simple HTML-escaping](#simple-html-escaping)    The following function escapes plain text so that it is displayed verbatim in HTML:    ```", "```js    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: HTML templating**    Exercise with bonus challenge: `exercises/template-literals/templating_test.mjs` ```", "```js`` ```", "```js ```", "```js` ```", "```js`` ```", "```js```", "``````js````"]