["```ts\nassert.equal(\n getScore('*****'), 5);\nassert.equal(\n getScore(3), 3);\n```", "```ts\nfunction getScore(value: number|string): number {\n // \u00b7\u00b7\u00b7\n}\n```", "```ts\nfunction getScore(value: number|string): number {\n if (typeof value === 'number') { // (A)\n // %inferred-type: number\n value;\n return value;\n }\n if (typeof value === 'string') { // (B)\n // %inferred-type: string\n value;\n return value.length;\n }\n throw new Error('Unsupported value: ' + value);\n}\n```", "```ts\nfunction getScore(value: number|string): number {\n switch (typeof value) {\n case 'number':\n // %inferred-type: number\n value;\n return value;\n case 'string':\n // %inferred-type: string\n value;\n return value.length;\n default:\n throw new Error('Unsupported value: ' + value);\n }\n}\n```", "```ts\n    function func1(arg: null|string) {}\n    function func2(arg: undefined|string) {}\n    ```", "```ts\n    type Teacher = { kind: 'Teacher', teacherId: string };\n    type Student = { kind: 'Student', studentId: string };\n    type Attendee = Teacher | Student;\n\n    function func3(attendee: Attendee) {}\n    ```", "```ts\n    function func4(arg?: string) {\n     // %inferred-type: string | undefined\n     arg;\n    }\n    ```", "```ts\nfunction parseStringLiteral(stringLiteral: string): string {\n const result: unknown = JSON.parse(stringLiteral);\n if (typeof result === 'string') { // (A)\n return result;\n }\n throw new Error('Not a string literal: ' + stringLiteral);\n}\n```", "```ts\nfunction func(value: unknown) {\n if (value === 'abc') {\n // %inferred-type: \"abc\"\n value;\n }\n}\n```", "```ts\ninterface Book {\n title: null | string;\n isbn: string;\n}\n\nfunction getTitle(book: Book) {\n if (book.title === null) {\n // %inferred-type: null\n book.title;\n return '(Untitled)';\n } else {\n // %inferred-type: string\n book.title;\n return book.title;\n }\n}\n```", "```ts\nfunction func(value: Function|Date|number[]) {\n if (typeof value === 'function') {\n // %inferred-type: Function\n value;\n }\n\n if (value instanceof Date) {\n // %inferred-type: Date\n value;\n }\n\n if (Array.isArray(value)) {\n // %inferred-type: number[]\n value;\n }\n}\n```", "```ts\ntype FirstOrSecond =\n | {first: string}\n | {second: string};\n\nfunction func(firstOrSecond: FirstOrSecond) {\n if ('second' in firstOrSecond) {\n // %inferred-type: { second: string; }\n firstOrSecond;\n }\n}\n```", "```ts\nfunction func(firstOrSecond: FirstOrSecond) {\n // @ts-expect-error: Property 'second' does not exist on\n // type 'FirstOrSecond'. [...]\n if (firstOrSecond.second !== undefined) {\n // \u00b7\u00b7\u00b7\n }\n}\n```", "```ts\nfunction func(obj: object) {\n if ('name' in obj) {\n // %inferred-type: object\n obj;\n\n // @ts-expect-error: Property 'name' does not exist on type 'object'.\n obj.name;\n }\n}\n```", "```ts\ntype Teacher = { kind: 'Teacher', teacherId: string };\ntype Student = { kind: 'Student', studentId: string };\ntype Attendee = Teacher | Student;\n\nfunction getId(attendee: Attendee) {\n switch (attendee.kind) {\n case 'Teacher':\n // %inferred-type: { kind: \"Teacher\"; teacherId: string; }\n attendee;\n return attendee.teacherId;\n case 'Student':\n // %inferred-type: { kind: \"Student\"; studentId: string; }\n attendee;\n return attendee.studentId;\n default:\n throw new Error();\n }\n}\n```", "```ts\nfunction getId(attendee: Attendee) {\n if (attendee.kind === 'Teacher') {\n // %inferred-type: { kind: \"Teacher\"; teacherId: string; }\n attendee;\n return attendee.teacherId;\n } else if (attendee.kind === 'Student') {\n // %inferred-type: { kind: \"Student\"; studentId: string; }\n attendee;\n return attendee.studentId;\n } else {\n throw new Error();\n }\n}\n```", "```ts\ntype MyType = {\n prop?: number | string,\n};\nfunction func(arg: MyType) {\n if (typeof arg.prop === 'string') {\n // %inferred-type: string\n arg.prop; // (A)\n\n [].forEach((x) => {\n // %inferred-type: string | number | undefined\n arg.prop; // (B)\n });\n\n // %inferred-type: string\n arg.prop;\n\n arg = {};\n\n // %inferred-type: string | number | undefined\n arg.prop; // (C)\n }\n}\n```", "```ts\nconst mixedValues: ReadonlyArray<undefined|null|number> =\n [1, undefined, 2, null];\n\nif (mixedValues.every(isNotNullish)) {\n // %inferred-type: readonly (number | null | undefined)[]\n mixedValues; // (A)\n}\n```", "```ts\nfunction isNotNullish<T>(value: T): value is NonNullable<T> { // (A)\n return value !== undefined && value !== null;\n}\n```", "```ts\n// %inferred-type: (number | null | undefined)[]\nconst mixedValues = [1, undefined, 2, null];\n\n// %inferred-type: number[]\nconst numbers = mixedValues.filter(isNotNullish);\n\nfunction isNotNullish<T>(value: T): value is NonNullable<T> { // (A)\n return value !== undefined && value !== null;\n}\n```", "```ts\n// %inferred-type: (number | null | undefined)[]\nconst stillMixed1 = mixedValues.filter(\n x => x !== undefined && x !== null);\n\n// %inferred-type: (number | null | undefined)[]\nconst stillMixed2 = mixedValues.filter(\n x => typeof x === 'number');\n```", "```ts\nfunction isFunction(value: unknown): value is Function {\n return typeof value === 'function';\n}\n```", "```ts\n// %inferred-type: (value: unknown) => value is Function\nisFunction;\n```", "```ts\nfunction func(arg: unknown) {\n if (isFunction(arg)) {\n // %inferred-type: Function\n arg; // type is narrowed\n }\n}\n```", "```ts\nfunction isFunction(value: any): value is Function {\n try {\n value(); // (A)\n return true;\n } catch {\n return false;\n }\n}\n```", "```ts\n/**\n * This type guard for Arrays works similarly to `Array.isArray()`,\n * but also checks if all Array elements are instances of `T`.\n * As a consequence, the type of `arr` is narrowed to `Array<T>`\n * if this function returns `true`.\n * \n * Warning: This type guard can make code unsafe \u2013 for example:\n * We could use another reference to `arr` to add an element whose\n * type is not `T`. Then `arr` doesn\u2019t have the type `Array<T>`\n * anymore.\n */\nfunction isArrayWithInstancesOf<T>(\n arr: any, Class: new (...args: any[])=>T)\n : arr is Array<T>\n{\n if (!Array.isArray(arr)) {\n return false;\n }\n if (!arr.every(elem => elem instanceof Class)) {\n return false;\n }\n\n // %inferred-type: any[]\n arr; // (A)\n\n return true;\n}\n```", "```ts\nconst value: unknown = {};\nif (isArrayWithInstancesOf(value, RegExp)) {\n // %inferred-type: RegExp[]\n value;\n}\n```", "```ts\n/**\n * An implementation of the `typeof` operator.\n */\nfunction isTypeof<T>(value: unknown, prim: T): value is T {\n if (prim === null) {\n return value === null;\n }\n return value !== null && (typeof prim) === (typeof value);\n}\n```", "```ts\nconst value: unknown = {};\nif (isTypeof(value, 123)) {\n // %inferred-type: number\n value;\n}\n```", "```ts\n/**\n * A partial implementation of the `typeof` operator.\n */\nfunction isTypeof(value: any, typeString: 'boolean'): value is boolean;\nfunction isTypeof(value: any, typeString: 'number'): value is number;\nfunction isTypeof(value: any, typeString: 'string'): value is string;\nfunction isTypeof(value: any, typeString: string): boolean {\n return typeof value === typeString;\n}\n\nconst value: unknown = {};\nif (isTypeof(value, 'boolean')) {\n // %inferred-type: boolean\n value;\n}\n```", "```ts\ninterface TypeMap {\n boolean: boolean;\n number: number;\n string: string;\n}\n\n/**\n * A partial implementation of the `typeof` operator.\n */\nfunction isTypeof<T extends keyof TypeMap>(value: any, typeString: T)\n: value is TypeMap[T] {\n return typeof value === typeString;\n}\n\nconst value: unknown = {};\nif (isTypeof(value, 'string')) {\n // %inferred-type: string\n value;\n}\n```", "```ts\nimport assert from 'assert';\nfunction removeFilenameExtension(filename: string) {\n const dotIndex = filename.lastIndexOf('.');\n assert(dotIndex >= 0); // (A)\n return filename.slice(0, dotIndex);\n}\n```", "```ts\nfunction assertTrue(condition: boolean): asserts condition {\n if (!condition) {\n throw new Error();\n }\n}\n```", "```ts\nfunction func(value: unknown) {\n assertTrue(value instanceof Set);\n\n // %inferred-type: Set<any>\n value;\n}\n```", "```ts\nfunction assertIsNumber(value: any): asserts value is number {\n if (typeof value !== 'number') {\n throw new TypeError();\n }\n}\n```", "```ts\nfunction func(value: unknown) {\n assertIsNumber(value);\n\n // %inferred-type: number\n value;\n}\n```", "```ts\nfunction addXY<T>(obj: T, x: number, y: number)\n: asserts obj is (T & { x: number, y: number }) {\n // Adding properties via = would be more complicated...\n Object.assign(obj, {x, y});\n}\n\nconst obj = { color: 'green' };\naddXY(obj, 9, 4);\n\n// %inferred-type: { color: string; } & { x: number; y: number; }\nobj;\n```", "```ts\nfunction isString(value: unknown): value is string {\n return typeof value === 'string';\n}\n```", "```ts\nfunction assertTrue(condition: boolean): asserts condition {\n if (!condition) {\n throw new Error(); // assertion error\n }\n}\n```", "```ts\nfunction assertIsString(value: unknown): asserts value is string {\n if (typeof value !== 'string') {\n throw new Error(); // assertion error\n }\n}\n```", "```ts\nfunction forceNumber(value: unknown): number {\n if (typeof value !== 'number') {\n throw new TypeError();\n }\n return value;\n}\n\nconst value1a: unknown = 123;\n// %inferred-type: number\nconst value1b = forceNumber(value1a);\n\nconst value2: unknown = 'abc';\nassert.throws(() => forceNumber(value2));\n```", "```ts\nfunction assertIsNumber(value: unknown): asserts value is number {\n if (typeof value !== 'number') {\n throw new TypeError();\n }\n}\n\nconst value1: unknown = 123;\nassertIsNumber(value1);\n// %inferred-type: number\nvalue1;\n\nconst value2: unknown = 'abc';\nassert.throws(() => assertIsNumber(value2));\n```", "```ts\nfunction getLengthOfValue(strMap: Map<string, string>, key: string)\n: number {\n if (strMap.has(key)) {\n const value = strMap.get(key);\n\n // %inferred-type: string | undefined\n value; // before type check\n\n // We know that value can\u2019t be `undefined`\n if (value === undefined) { // (A)\n throw new Error();\n }\n\n // %inferred-type: string\n value; // after type check\n\n return value.length;\n }\n return -1;\n}\n```", "```ts\nassertNotUndefined(value);\n```"]