- en: '16 Regular expressions: lookaround assertions by example'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/deep-js/ch_regexp-lookaround-assertions.html](https://exploringjs.com/deep-js/ch_regexp-lookaround-assertions.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '16.1 [Cheat sheet: lookaround assertions](ch_regexp-lookaround-assertions.html#cheat-sheet-lookaround-assertions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.2 [Warnings for this chapter](ch_regexp-lookaround-assertions.html#warnings-for-this-chapter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.3 [Example: Specifying what comes before or after a match (positive lookaround)](ch_regexp-lookaround-assertions.html#example-specifying-what-comes-before-or-after-a-match-positive-lookaround)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.4 [Example: Specifying what does not come before or after a match (negative
    lookaround)](ch_regexp-lookaround-assertions.html#example-specifying-what-does-not-come-before-or-after-a-match-negative-lookaround)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.4.1 [There are no simple alternatives to negative lookaround assertions](ch_regexp-lookaround-assertions.html#there-are-no-simple-alternatives-to-negative-lookaround-assertions)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.5 [Interlude: pointing lookaround assertions inward](ch_regexp-lookaround-assertions.html#interlude-pointing-lookaround-assertions-inward)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.6 [Example: match strings not starting with `''abc''`](ch_regexp-lookaround-assertions.html#example-match-strings-not-starting-with-abc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.7 [Example: match substrings that do not contain `''.mjs''`](ch_regexp-lookaround-assertions.html#example-match-substrings-that-do-not-contain-.mjs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.8 [Example: skipping lines with comments](ch_regexp-lookaround-assertions.html#example-skipping-lines-with-comments)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.9 [Example: smart quotes](ch_regexp-lookaround-assertions.html#example-smart-quotes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.9.1 [Supporting escaping via backslashes](ch_regexp-lookaround-assertions.html#supporting-escaping-via-backslashes)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.10 [Acknowledgements](ch_regexp-lookaround-assertions.html#acknowledgements-2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.11 [Further reading](ch_regexp-lookaround-assertions.html#further-reading-4)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we use examples to explore lookaround assertions in regular
    expressions. A lookaround assertion is non-capturing and must match (or not match)
    what comes before (or after) the current location in the input string.
  prefs: []
  type: TYPE_NORMAL
- en: '16.1 Cheat sheet: lookaround assertions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Table 4: Overview of available lookaround assertions.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern | Name |  |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `(?=«pattern»)` | Positive lookahead | ES3 |'
  prefs: []
  type: TYPE_TB
- en: '| `(?!«pattern»)` | Negative lookahead | ES3 |'
  prefs: []
  type: TYPE_TB
- en: '| `(?<=«pattern»)` | Positive lookbehind | ES2018 |'
  prefs: []
  type: TYPE_TB
- en: '| `(?<!«pattern»)` | Negative lookbehind | ES2018 |'
  prefs: []
  type: TYPE_TB
- en: There are four lookaround assertions (tbl. [4](#tbl:lookaround-assertions-overview))
  prefs: []
  type: TYPE_NORMAL
- en: 'Lookahead assertions (ECMAScript 3):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Positive lookahead: `(?=«pattern»)` matches if `pattern` matches what comes
    after the current location in the input string.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Negative lookahead: `(?!«pattern»)` matches if `pattern` does not match what
    comes after the current location in the input string.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lookbehind assertions (ECMAScript 2018):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Positive lookbehind: `(?<=«pattern»)` matches if `pattern` matches what comes
    before the current location in the input string.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Negative lookbehind: `(?<!«pattern»)` matches if `pattern` does not match what
    comes before the current location in the input string.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.2 Warnings for this chapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The examples show what can be achieved via lookaround assertions. However, regular
    expression aren’t always the best solution. Another technique, such as proper
    parsing, may be a better choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lookbehind assertions are a relatively new feature that may not be supported
    by all JavaScript engines you are targeting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lookaround assertions may affect performance negatively, especially if their
    patterns match long strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.3 Example: Specifying what comes before or after a match (positive lookaround)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following interaction, we extract quoted words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Two lookaround assertions help us here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(?<=")` “must be preceded by a quote”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(?=")` “must be followed by a quote”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lookaround assertions are especially convenient for `.match()` in `/g` mode,
    which returns whole matches (capture group 0). Whatever the pattern of a lookaround
    assertion matches is not captured. Without lookaround assertions, the quotes show
    up in the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '16.4 Example: Specifying what does not come before or after a match (negative
    lookaround)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How can we achieve the opposite of what we did in the previous section and extract
    all unquoted words from a string?
  prefs: []
  type: TYPE_NORMAL
- en: 'Input: `''how "are" "you" doing''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Output: `[''how'', ''doing'']`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our first attempt is to simply convert positive lookaround assertions to negative
    lookaround assertions. Alas, that fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that we extract sequences of characters that are not bracketed
    by quotes. That means that in the string `'"are"'`, the “r” in the middle is considered
    unquoted, because it is preceded by an “a” and followed by an “e”.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fix this by stating that prefix and suffix must be neither quote nor
    letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Another solution is to demand via `\b` that the sequence of characters `[a-z]+`
    start and end at word boundaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: One thing that is nice about negative lookbehind and negative lookahead is that
    they also work at the beginning or end, respectively, of a string – as demonstrated
    in the example.
  prefs: []
  type: TYPE_NORMAL
- en: 16.4.1 There are no simple alternatives to negative lookaround assertions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Negative lookaround assertions are a powerful tool and usually impossible to
    emulate via other regular expression means.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we don’t want to use them, we normally have to take a completely different
    approach. For example, in this case, we could split the string into (quoted and
    unquoted) words and then filter those:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Benefits of this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: It works on older engines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy to understand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.5 Interlude: pointing lookaround assertions inward'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of the examples we have seen so far have in common that the lookaround assertions
    dictate what must come before or after the match but without including those characters
    in the match.
  prefs: []
  type: TYPE_NORMAL
- en: 'The regular expressions shown in the remainder of this chapter are different:
    Their lookaround assertions point inward and restrict what’s inside the match.'
  prefs: []
  type: TYPE_NORMAL
- en: '16.6 Example: match strings not starting with `''abc''`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let‘s assume we want to match all strings that do not start with `'abc'`. Our
    first attempt could be the regular expression `/^(?!abc)/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'That works well for `.test()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `.exec()` gives us an empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that assertions such as lookaround assertions don’t expand the
    matched text. That is, they don’t capture input characters, they only make demands
    about the current location in the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the solution is to add a pattern that does capture input characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As desired, this new regular expression rejects strings that are prefixed with
    `''abc''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And it accepts strings that don’t have the full prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '16.7 Example: match substrings that do not contain `''.mjs''`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following example, we want to find
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: where `module-specifier` does not end with `'.mjs'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, the lookbehind assertion `(?<!\.mjs)` acts as a *guard* and prevents that
    the regular expression matches strings that contain `'.mjs`’ at this location.
  prefs: []
  type: TYPE_NORMAL
- en: '16.8 Example: skipping lines with comments'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Scenario: We want to parse lines with settings, while skipping comments. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How did we arrive at the regular expression `RE_SETTING`?
  prefs: []
  type: TYPE_NORMAL
- en: 'We started with the following regular expression for settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Intuitively, it is a sequence of the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Start of the line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-colons (zero or more)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single colon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any characters (zero or more)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The end of line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This regular expression does reject *some* comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'But it accepts others (that have colons in them):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can fix that by prefixing `(?!#)` as a guard. Intuitively, it means: ”The
    current location in the input string must not be followed by the character `#`.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'The new regular expression works as desired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '16.9 Example: smart quotes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s assume we want to convert pairs of straight double quotes to curly quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input: ``"yes" and "no"``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Output: ``“yes” and “no”``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is our first attempt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Only the first quote and the last quote is curly. The problem here is that the
    `*` quantifier matches [*greedily*](https://exploringjs.com/impatient-js/ch_regexps.html#quantifiers)
    (as much as possible).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we put a question mark after the `*`, it matches *reluctantly*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 16.9.1 Supporting escaping via backslashes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What if we want to allow the escaping of quotes via backslashes? We can do
    that by using the guard `(?<!\\)` before the quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As a post-processing step, we would still need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this regular expression can fail when there is a backslash-escaped
    backslash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The second backslash prevented the quotes from becoming curly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fix that if we make our guard more sophisticated (`?:` makes the group
    non-capturing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The new guard allows pairs of backslashes before quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'One issue remains. This guard prevents the first quote from being matched if
    it appears at the beginning of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can fix that by changing the first guard to: `(?<=[^\\](?:\\\\)*|^)`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 16.10 Acknowledgements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first regular expression that handles escaped backslashes in front of quotes
    [was proposed by `@jonasraoni` on Twitter](https://twitter.com/jonasraoni/status/992506010454683650).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.11 Further reading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Chapter “Regular expressions (`RegExp`)”](https://exploringjs.com/impatient-js/ch_regexps.html)
    in “JavaScript for impatient programmers”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/deep-js/issues/16)'
  prefs: []
  type: TYPE_NORMAL
