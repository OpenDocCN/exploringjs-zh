- en: 38 Sets (Set) ES6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_sets.html](https://exploringjs.com/js/book/ch_sets.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[38.1 Basic Set operations](#basic-set-operations)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.1.1 Creating Sets](#creating-sets)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.1.2 Adding, removing, checking membership](#adding-removing-checking-membership)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.1.3 Determining the size of a Set and clearing it](#determining-the-size-of-a-set-and-clearing-it)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.2 Combining Sets: union, intersection, difference, symmetric difference
    ^(ES2025)](#combining-sets)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.2.1 Union: `set.union(other)` ^(ES2025)](#Set.prototype.union)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.2.2 Intersection: `set.intersection(other)` ^(ES2025)](#Set.prototype.intersection)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.2.3 Difference: `set.difference(other)` ^(ES2025)](#Set.prototype.difference)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.2.4 Symmetric difference: `set.symmetricDifference(other)` ^(ES2025)](#Set.prototype.symmetricDifference)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.3 Checking Set relationships: subset of, superset of, disjoint from ^(ES2025)](#checking-set-relationships)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.3.1 Subset: `set.isSubsetOf(other)` ^(ES2025)](#Set.prototype.isSubsetOf)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.3.2 Superset: `set.isSupersetOf(other)` ^(ES2025)](#Set.prototype.isSupersetOf)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.3.3 Disjoint: `set.isDisjointFrom(other)` ^(ES2025)](#Set.prototype.isDisjointFrom)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.4 Set-like objects (advanced)](#set-like-objects)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.4.1 Examples: finite Set-like objects](#examples-finite-setlike-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.4.2 Examples: infinite Set-like data](#infinite-sets)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.4.3 FAQ: Set-like objects](#faq-setlike-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.5 Iterating over Sets](#iterating-over-sets-1)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.5.1 Converting a Set to an Array](#converting-set-to-array)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.5.2 Mapping and filtering Sets via iterator methods](#applying-iterator-methods-to-sets)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.5.3 Example: combining Sets via iteration ^(ES2025)](#combining-sets-via-iteration)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.5.4 Grouping Set elements ^(ES2024)](#grouping-set-elements-es2024)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.6 Examples of using Sets](#examples-of-using-sets)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.6.1 Removing duplicates from an Array](#removing-duplicates-from-an-array)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.6.2 Creating a set of Unicode characters (code points)](#creating-a-set-of-unicode-characters-code-points)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.7 Details of the Set API (advanced)](#details-of-the-set-api-advanced)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.7.1 What Set elements are considered equal?](#what-set-elements-are-considered-equal)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.7.2 FAQ: Set API](#faq-set-api)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.8 Quick reference: `Set`](#quickref-sets)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.8.1 `new Set()`](#new-set)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.8.2 `Set.prototype.*`: working with single Set elements](#setprototype-working-with-single-set-elements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.8.3 `Set.prototype.*`: working with all Set elements](#setprototype-working-with-all-set-elements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.8.4 `Set.prototype.*`: iterating and looping](#setprototype-iterating-and-looping)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.8.5 `Set.prototype.*`: combining two Sets ^(ES2025)](#setprototype-combining-two-sets-es2025)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[38.8.6 `Set.prototype.*`: checking Set relationships ^(ES2025)](#setprototype-checking-set-relationships-es2025)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The data structure `Set` manages a duplicate-free collection of values and provides
    fast membership checks and more.
  prefs: []
  type: TYPE_NORMAL
- en: '[38.1 Basic Set operations](#basic-set-operations)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[38.1.1 Creating Sets](#creating-sets)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are three common ways of creating Sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can use the constructor without any parameters to create an empty
    Set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we can pass an iterable (e.g., an Array) to the constructor. The iterated
    values become elements of the new Set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Third, the `.add()` method adds elements to a Set and is chainable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[38.1.2 Adding, removing, checking membership](#adding-removing-checking-membership)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`.add()` adds an element to a Set.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`.has()` checks if an element is a member of a Set.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`.delete()` removes an element from a Set.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[38.1.3 Determining the size of a Set and clearing it](#determining-the-size-of-a-set-and-clearing-it)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`.size` contains the number of elements in a Set.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`.clear()` removes all elements of a Set.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[38.2 Combining Sets: union, intersection, difference, symmetric difference
    ^(ES2025)](#combining-sets)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are four methods for combining two Sets.
  prefs: []
  type: TYPE_NORMAL
- en: '[38.2.1 Union: `set.union(other)` ^(ES2025)](#Set.prototype.union)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '![](../Images/466ab17df8ce9bada54b76b314e6dec4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The result of `set.union(other)` is a Set that has the values of both `set`
    and `other`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[38.2.2 Intersection: `set.intersection(other)` ^(ES2025)](#Set.prototype.intersection)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '![](../Images/177acd08f608df8b69590d67b803378a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The result of `set.intersection(other)` is a Set that has the values that `set`
    and `other` have in common:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[38.2.3 Difference: `set.difference(other)` ^(ES2025)](#Set.prototype.difference)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '![](../Images/f64428582010ac4f391a4145f2014ec6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The result of `set.difference(other)` is a Set that has the values that are
    only in `set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Implementing `set.union()`, `set.intersection()` and `set.difference()`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/sets/set-union-intersection-difference_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[38.2.4 Symmetric difference: `set.symmetricDifference(other)` ^(ES2025)](#Set.prototype.symmetricDifference)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '![](../Images/752ee7e59a3e2b58f55fc196e668112f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The result of `set.symmetricDifference(other)` is a Set that has the values
    that are only in `set` or only in `other`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'What does *symmetric difference* mean? These are equivalent definitions of
    the symmetric difference:'
  prefs: []
  type: TYPE_NORMAL
- en: (`set` − `other`) ∪ (`other` − `set`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elements that are only in `set` or only in `other`. The formula makes it clear
    why the symmetric difference is both symmetric and a difference.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: (`set` ∪ `other`) − (`set` ∩ `other`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The elements of `set` and `other` – except for the elements that are in both
    Sets.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set` xor `other`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exclusive Or – visually: Everything that is inside the area of `set` is inverted.
    Everything that is outside `set` is not changed.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Implementing `set.symmetricDifference()`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/sets/set-symmetric-difference_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[38.3 Checking Set relationships: subset of, superset of, disjoint from ^(ES2025)](#checking-set-relationships)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are three methods for checking the relationships between two sets.
  prefs: []
  type: TYPE_NORMAL
- en: '[38.3.1 Subset: `set.isSubsetOf(other)` ^(ES2025)](#Set.prototype.isSubsetOf)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`set.isSubsetOf(other)` returns `true` if all elements of `set` are in `other`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[38.3.2 Superset: `set.isSupersetOf(other)` ^(ES2025)](#Set.prototype.isSupersetOf)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`set.isSupersetOf(other)` returns `true` if `set` contains all elements of
    `other`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[38.3.3 Disjoint: `set.isDisjointFrom(other)` ^(ES2025)](#Set.prototype.isDisjointFrom)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`set.isDisjointFrom(other)` returns `true` if `set` and `other` have no elements
    in common:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercises
    for Set relationship methods**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing Set equality: `exercises/sets/set-is-equal-to_test.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implementing `set.isSubsetOf()`: `exercises/sets/is-subset-of_test.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implementing `set.isDisjointFrom()`: `exercises/sets/is-disjoint-from_test.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[38.4 Set-like objects (advanced)](#set-like-objects)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A Set method whose parameter is another Set `other` does not require `other`
    to be an actual Set; it only has to be Set-like and have the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[38.4.1 Examples: finite Set-like objects](#examples-finite-setlike-objects)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s implement a simple Set-like object and use it with methods whose parameters
    are “other Sets”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Maps are also Set-like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[38.4.2 Examples: infinite Set-like data](#infinite-sets)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `.size` of `other` can be `Infinity`. That means we can work with infinite
    Sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This works because these methods only invoke `other.keys()` if `other.size`
    is smaller than `this.size`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Only two methods don’t support `other` being an infinite Set:'
  prefs: []
  type: TYPE_NORMAL
- en: '`union`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symmetricDifference`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[38.4.3 FAQ: Set-like objects](#faq-setlike-objects)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Why use the interface `SetLike` for `other`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to the interface, `other` can be a data structure that is not a Set. It
    was chosen as a compromise between accepting only Sets and all iterable objects.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Why does JavaScript always enforce the full interface `SetLike` for `other`
    and throws an exception if a property is missing or has the wrong dynamic type?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That makes the API simpler and hides implementation details.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Why was method `.keys()` chosen for iterating over elements?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That’s due to compatibility with the only Set-like data structure currently
    in the standard library – `Map`. Two other Set methods would have been nicer but
    can’t be used with Maps:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Map method `.[Symbol.iterator]()` returns key-value pairs.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Map method `.values()` is incompatible with the Map method `.has()` (which
    accepts keys, not values).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Source: [TC39 proposal](https://github.com/tc39/proposal-set-methods/blob/main/details.md)'
  prefs: []
  type: TYPE_NORMAL
- en: '[38.5 Iterating over Sets](#iterating-over-sets-1)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sets are iterable and the `for-of` loop works as we’d expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, Sets preserve *insertion order*. That is, elements are always
    iterated over in the order in which they were added.
  prefs: []
  type: TYPE_NORMAL
- en: '[38.5.1 Converting a Set to an Array](#converting-set-to-array)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sets are iterable, which is why we can use `Array.from()` to convert a Set
    to an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also perform the conversion via an iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`set.values()` returns in iterator for the values of `set`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The iterator method `.toArray()` creates an Array with the iterated values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[38.5.2 Mapping and filtering Sets via iterator methods](#applying-iterator-methods-to-sets)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sets don’t have a method `.map()`. But we can borrow the one that iterators
    have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code shows a common pattern for using iterator methods with Sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '`set.values()` returns an iterator for `set` (line B).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.map()` is an iterator method that returns an iterator (line B).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result of the previous step is an iterable iterator. It is passed to the
    constructor `Set` which accepts any iterable as a parameter and uses it to fill
    the new Set with values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Filtering Sets works the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we can’t use iterator methods? Then we can switch to Array methods:'
  prefs: []
  type: TYPE_NORMAL
- en: We use `Array.from(set)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: instead of `set.values()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[38.5.3 Example: combining Sets via iteration ^(ES2025)](#combining-sets-via-iteration)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Instead of the Set methods, we can also use iteration to combine Sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[38.5.4 Grouping Set elements ^(ES2024)](#grouping-set-elements-es2024)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Grouping via `Object.groupBy()` and `Map.groupBy()` works for any iterable
    object and therefore for Sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'More information: [“Grouping iterables ^(ES2024)” (§32.8)](ch_sync-iteration.html#grouping-sync-iterables)'
  prefs: []
  type: TYPE_NORMAL
- en: '[38.6 Examples of using Sets](#examples-of-using-sets)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[38.6.1 Removing duplicates from an Array](#removing-duplicates-from-an-array)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Converting an Array to a Set and back, removes duplicates from the Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[38.6.2 Creating a set of Unicode characters (code points)](#creating-a-set-of-unicode-characters-code-points)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Strings are iterable and can therefore be used as parameters for `new Set()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[38.7 Details of the Set API (advanced)](#details-of-the-set-api-advanced)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[38.7.1 What Set elements are considered equal?](#what-set-elements-are-considered-equal)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As with Map keys, Set elements are compared similarly to `===`, with the exception
    of `NaN` being equal to itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As with `===`, two different objects are never considered equal (and there
    is no way to change that at the moment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[38.7.2 FAQ: Set API](#faq-set-api)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Why do Sets have a `.size`, while Arrays have a `.length`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The answer to this question is given in [“Why do Maps have a `.size`, while
    Arrays have a `.length`?” (§36.7.4)](ch_maps.html#collection-size-vs-length).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Why are some method names verbs and others nouns? This is a rough general rule:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Verb methods mutate `this` – e.g.: `set.add()` and `set.clear()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Noun methods return new data – e.g.: `set.values()` and `set.union()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[38.8 Quick reference: `Set`](#quickref-sets)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[38.8.1 `new Set()`](#new-set)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`new Set(iterable)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we don’t provide the parameter `values`, then an empty Set is created.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If we do, then the iterated values are added as elements to the Set.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[38.8.2 `Set.prototype.*`: working with single Set elements](#setprototype-working-with-single-set-elements)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Set.prototype.add(value)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds `value` to this Set.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This method returns `this`, which means that it can be chained.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Set.prototype.delete(value)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removes `value` from this Set.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if something was deleted and `false`, otherwise.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Set.prototype.has(value)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if `value` is in this Set and `false` otherwise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[38.8.3 `Set.prototype.*`: working with all Set elements](#setprototype-working-with-all-set-elements)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`get Set.prototype.size` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns how many elements there are in this Set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Set.prototype.clear()` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removes all elements from this Set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[38.8.4 `Set.prototype.*`: iterating and looping](#setprototype-iterating-and-looping)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Set.prototype.values()` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns an iterable over all elements of this Set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Set.prototype[Symbol.iterator]()` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default way of iterating over Sets. Same as `.values()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Set.prototype.forEach(callback, thisArg?)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Feeds each element of this Set to `callback()`. `value` and `key` both contain
    the current element. This redundancy was introduced so that this `callback` has
    the same type signature as the `callback` of `Map.prototype.forEach()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can specify the `this` of `callback` via `thisArg`. If we omit it, `this`
    is `undefined`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[38.8.4.1 Symmetry with `Map`](#symmetry-with-map)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The following methods make the interface of `Set` symmetric with the interface
    of `Map`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Set.prototype.entries(): Iterable<[T,T]>` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mainly exists so that Sets and Maps have similar interfaces: Each Set element
    is viewed as a key-value entry whose key and value are both that element:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.entries()` enables us to convert a Set to a Map:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Set.prototype.keys(): Iterable<T>` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mainly exists so that Sets and Maps have similar interfaces: Each Set element
    is viewed as a key-value entry whose key and value are both that element. Therefore
    the result of `.keys()` is the same as the result of `.values()`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[38.8.5 `Set.prototype.*`: combining two Sets ^(ES2025)](#setprototype-combining-two-sets-es2025)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Set.prototype.union(other)` ES2025'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method returns a Set that is the union of `this` and `other`. It contains
    a value if it is in `this` or `other`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`other` doesn’t have to be a Set, it only has to be [*Set-like*](#set-like-objects)
    and have the property `.size` and the methods `.has(key)` and `.keys()`. Sets
    and Maps both fulfill those requirements.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Set.prototype.intersection(other)` ES2025'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method returns a Set that is the intersection of `this` and `other`. It
    contains a value if it is in `this` or `other`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`other` doesn’t have to be a Set, it only has to be [*Set-like*](#set-like-objects)
    and have the property `.size` and the methods `.has(key)` and `.keys()`. Sets
    and Maps both fulfill those requirements.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Set.prototype.difference(other)` ES2025'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method returns a Set that is the difference between `this` and `other`.
    It contains a value if it is in `this` but not in `other`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`other` doesn’t have to be a Set, it only has to be [*Set-like*](#set-like-objects)
    and have the property `.size` and the methods `.has(key)` and `.keys()`. Sets
    and Maps both fulfill those requirements.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Set.prototype.symmetricDifference(other)` ES2025'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method returns a Set that is the symmetric difference between `this` and
    `other`. It contains a value if it is only in `this` or only in `other`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`other` doesn’t have to be a Set, it only has to be [*Set-like*](#set-like-objects)
    and have the property `.size` and the methods `.has(key)` and `.keys()`. Sets
    and Maps both fulfill those requirements.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For more information on this method, see [its section in this chapter](#Set.prototype.symmetricDifference).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[38.8.6 `Set.prototype.*`: checking Set relationships ^(ES2025)](#setprototype-checking-set-relationships-es2025)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Set.prototype.isSubsetOf(other)` ES2025'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Returns `true` if all elements of `this` are in `other`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Set.prototype.isSupersetOf(other)` ES2025'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Returns `true` if `this` contains all elements of `other`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Set.prototype.isDisjointFrom(other)` ES2025'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Returns `true` if `this` and `other` have no elements in common:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
