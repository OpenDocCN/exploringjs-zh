- en: 38 Sets (Set) ES6
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 38 集合（Set）ES6
- en: 原文：[https://exploringjs.com/js/book/ch_sets.html](https://exploringjs.com/js/book/ch_sets.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/js/book/ch_sets.html](https://exploringjs.com/js/book/ch_sets.html)
- en: '[38.1 Basic Set operations](#basic-set-operations)'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.1 基本集合操作](#basic-set-operations)'
- en: '[38.1.1 Creating Sets](#creating-sets)'
  id: totrans-3
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.1.1 创建集合](#creating-sets)'
- en: '[38.1.2 Adding, removing, checking membership](#adding-removing-checking-membership)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.1.2 添加、删除、检查成员资格](#adding-removing-checking-membership)'
- en: '[38.1.3 Determining the size of a Set and clearing it](#determining-the-size-of-a-set-and-clearing-it)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.1.3 确定集合的大小并清空它](#determining-the-size-of-a-set-and-clearing-it)'
- en: '[38.2 Combining Sets: union, intersection, difference, symmetric difference
    ^(ES2025)](#combining-sets)'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.2 组合集合：并集、交集、差集、对称差集 (ES2025)](#combining-sets)'
- en: '[38.2.1 Union: `set.union(other)` ^(ES2025)](#Set.prototype.union)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.2.1 并集：`set.union(other)` (ES2025)](#Set.prototype.union)'
- en: '[38.2.2 Intersection: `set.intersection(other)` ^(ES2025)](#Set.prototype.intersection)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.2.2 交集：`set.intersection(other)` (ES2025)](#Set.prototype.intersection)'
- en: '[38.2.3 Difference: `set.difference(other)` ^(ES2025)](#Set.prototype.difference)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.2.3 差集：`set.difference(other)` (ES2025)](#Set.prototype.difference)'
- en: '[38.2.4 Symmetric difference: `set.symmetricDifference(other)` ^(ES2025)](#Set.prototype.symmetricDifference)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.2.4 对称差集：`set.symmetricDifference(other)` (ES2025)](#Set.prototype.symmetricDifference)'
- en: '[38.3 Checking Set relationships: subset of, superset of, disjoint from ^(ES2025)](#checking-set-relationships)'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.3 检查集合关系：子集、超集、不相交 (ES2025)](#checking-set-relationships)'
- en: '[38.3.1 Subset: `set.isSubsetOf(other)` ^(ES2025)](#Set.prototype.isSubsetOf)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.3.1 子集：`set.isSubsetOf(other)` (ES2025)](#Set.prototype.isSubsetOf)'
- en: '[38.3.2 Superset: `set.isSupersetOf(other)` ^(ES2025)](#Set.prototype.isSupersetOf)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.3.2 超集：`set.isSupersetOf(other)` (ES2025)](#Set.prototype.isSupersetOf)'
- en: '[38.3.3 Disjoint: `set.isDisjointFrom(other)` ^(ES2025)](#Set.prototype.isDisjointFrom)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.3.3 不相交：`set.isDisjointFrom(other)` (ES2025)](#Set.prototype.isDisjointFrom)'
- en: '[38.4 Set-like objects (advanced)](#set-like-objects)'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.4 类似集合的对象（高级）](#set-like-objects)'
- en: '[38.4.1 Examples: finite Set-like objects](#examples-finite-setlike-objects)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.4.1 示例：有限类似集合对象](#examples-finite-setlike-objects)'
- en: '[38.4.2 Examples: infinite Set-like data](#infinite-sets)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.4.2 示例：无限类似集合数据](#infinite-sets)'
- en: '[38.4.3 FAQ: Set-like objects](#faq-setlike-objects)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.4.3 常见问题解答：类似集合对象](#faq-setlike-objects)'
- en: '[38.5 Iterating over Sets](#iterating-over-sets-1)'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.5 遍历集合](#iterating-over-sets-1)'
- en: '[38.5.1 Converting a Set to an Array](#converting-set-to-array)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.5.1 将集合转换为数组](#converting-set-to-array)'
- en: '[38.5.2 Mapping and filtering Sets via iterator methods](#applying-iterator-methods-to-sets)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.5.2 通过迭代方法映射和过滤集合](#applying-iterator-methods-to-sets)'
- en: '[38.5.3 Example: combining Sets via iteration ^(ES2025)](#combining-sets-via-iteration)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.5.3 示例：通过迭代组合集合 (ES2025)](#combining-sets-via-iteration)'
- en: '[38.5.4 Grouping Set elements ^(ES2024)](#grouping-set-elements-es2024)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.5.4 对集合元素进行分组 (ES2024)](#grouping-set-elements-es2024)'
- en: '[38.6 Examples of using Sets](#examples-of-using-sets)'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.6 使用集合的示例](#examples-of-using-sets)'
- en: '[38.6.1 Removing duplicates from an Array](#removing-duplicates-from-an-array)'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.6.1 从数组中删除重复项](#removing-duplicates-from-an-array)'
- en: '[38.6.2 Creating a set of Unicode characters (code points)](#creating-a-set-of-unicode-characters-code-points)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.6.2 创建一个包含 Unicode 字符（代码点）的集合](#creating-a-set-of-unicode-characters-code-points)'
- en: '[38.7 Details of the Set API (advanced)](#details-of-the-set-api-advanced)'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.7 集合 API 的详细信息（高级）](#details-of-the-set-api-advanced)'
- en: '[38.7.1 What Set elements are considered equal?](#what-set-elements-are-considered-equal)'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.7.1 哪些集合元素被认为是相等的？](#what-set-elements-are-considered-equal)'
- en: '[38.7.2 FAQ: Set API](#faq-set-api)'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.7.2 常见问题解答：集合 API](#faq-set-api)'
- en: '[38.8 Quick reference: `Set`](#quickref-sets)'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.8 快速参考：`Set`](#quickref-sets)'
- en: '[38.8.1 `new Set()`](#new-set)'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.8.1 `new Set()`](#new-set)'
- en: '[38.8.2 `Set.prototype.*`: working with single Set elements](#setprototype-working-with-single-set-elements)'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.8.2 `Set.prototype.*`: 与单个集合元素一起工作](#setprototype-working-with-single-set-elements)'
- en: '[38.8.3 `Set.prototype.*`: working with all Set elements](#setprototype-working-with-all-set-elements)'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.8.3 `Set.prototype.*`: 与所有集合元素一起工作](#setprototype-working-with-all-set-elements)'
- en: '[38.8.4 `Set.prototype.*`: iterating and looping](#setprototype-iterating-and-looping)'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.8.4 `Set.prototype.*`: 迭代和循环](#setprototype-iterating-and-looping)'
- en: '[38.8.5 `Set.prototype.*`: combining two Sets ^(ES2025)](#setprototype-combining-two-sets-es2025)'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.8.5 `Set.prototype.*`: 合并两个集合 (ES2025)](#setprototype-combining-two-sets-es2025)'
- en: '[38.8.6 `Set.prototype.*`: checking Set relationships ^(ES2025)](#setprototype-checking-set-relationships-es2025)'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[38.8.6 `Set.prototype.*`: 检查集合关系 (ES2025)](#setprototype-checking-set-relationships-es2025)'
- en: The data structure `Set` manages a duplicate-free collection of values and provides
    fast membership checks and more.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构 `Set` 管理一个无重复值的集合，并提供快速的成员资格检查等功能。
- en: '[38.1 Basic Set operations](#basic-set-operations)'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[38.1 基本集合操作](#basic-set-operations)'
- en: '[38.1.1 Creating Sets](#creating-sets)'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.1.1 创建集合](#creating-sets)'
- en: There are three common ways of creating Sets.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种常见的方法来创建集合。
- en: 'First, we can use the constructor without any parameters to create an empty
    Set:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以使用无参数的构造函数来创建一个空集合：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Second, we can pass an iterable (e.g., an Array) to the constructor. The iterated
    values become elements of the new Set:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们可以将可迭代对象（例如，一个数组）传递给构造函数。迭代的值成为新集合的元素：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Third, the `.add()` method adds elements to a Set and is chainable:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，`.add()` 方法向集合中添加元素，并且是可链式的：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[38.1.2 Adding, removing, checking membership](#adding-removing-checking-membership)'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.1.2 添加、删除、检查成员资格](#adding-removing-checking-membership)'
- en: '`.add()` adds an element to a Set.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`.add()` 向集合中添加一个元素。'
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`.has()` checks if an element is a member of a Set.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`.has()` 检查一个元素是否是集合的成员。'
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`.delete()` removes an element from a Set.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`.delete()` 从集合中删除一个元素。'
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[38.1.3 Determining the size of a Set and clearing it](#determining-the-size-of-a-set-and-clearing-it)'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.1.3 确定集合的大小和清除集合](#determining-the-size-of-a-set-and-clearing-it)'
- en: '`.size` contains the number of elements in a Set.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`.size` 包含集合中的元素数量。'
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`.clear()` removes all elements of a Set.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`.clear()` 移除集合中的所有元素。'
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[38.2 Combining Sets: union, intersection, difference, symmetric difference
    ^(ES2025)](#combining-sets)'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[38.2 组合集合：并集、交集、差集、对称差 (ES2025)](#combining-sets)'
- en: There are four methods for combining two Sets.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种方法可以组合两个集合。
- en: '[38.2.1 Union: `set.union(other)` ^(ES2025)](#Set.prototype.union)'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.2.1 并集：`set.union(other)` (ES2025)](#Set.prototype.union)'
- en: '![](../Images/466ab17df8ce9bada54b76b314e6dec4.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/466ab17df8ce9bada54b76b314e6dec4.png)'
- en: 'The result of `set.union(other)` is a Set that has the values of both `set`
    and `other`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`set.union(other)` 的结果是包含 `set` 和 `other` 的值的集合：'
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[38.2.2 Intersection: `set.intersection(other)` ^(ES2025)](#Set.prototype.intersection)'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.2.2 交集：`set.intersection(other)` (ES2025)](#Set.prototype.intersection)'
- en: '![](../Images/177acd08f608df8b69590d67b803378a.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/177acd08f608df8b69590d67b803378a.png)'
- en: 'The result of `set.intersection(other)` is a Set that has the values that `set`
    and `other` have in common:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`set.intersection(other)` 的结果是包含 `set` 和 `other` 共同拥有的值的集合：'
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[38.2.3 Difference: `set.difference(other)` ^(ES2025)](#Set.prototype.difference)'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.2.3 差集：`set.difference(other)` (ES2025)](#Set.prototype.difference)'
- en: '![](../Images/f64428582010ac4f391a4145f2014ec6.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f64428582010ac4f391a4145f2014ec6.png)'
- en: 'The result of `set.difference(other)` is a Set that has the values that are
    only in `set`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`set.difference(other)` 的结果是包含只存在于 `set` 的值的集合：'
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Implementing `set.union()`, `set.intersection()` and `set.difference()`**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![练习图标](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：实现 `set.union()`、`set.intersection()`
    和 `set.difference()`**'
- en: '`exercises/sets/set-union-intersection-difference_test.mjs`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/sets/set-union-intersection-difference_test.mjs`'
- en: '[38.2.4 Symmetric difference: `set.symmetricDifference(other)` ^(ES2025)](#Set.prototype.symmetricDifference)'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.2.4 对称差：`set.symmetricDifference(other)` (ES2025)](#Set.prototype.symmetricDifference)'
- en: '![](../Images/752ee7e59a3e2b58f55fc196e668112f.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/752ee7e59a3e2b58f55fc196e668112f.png)'
- en: 'The result of `set.symmetricDifference(other)` is a Set that has the values
    that are only in `set` or only in `other`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`set.symmetricDifference(other)` 的结果是包含只存在于 `set` 或只存在于 `other` 的值的集合：'
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'What does *symmetric difference* mean? These are equivalent definitions of
    the symmetric difference:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*对称差*是什么意思？以下是对称差的等效定义：'
- en: (`set` − `other`) ∪ (`other` − `set`)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (`set` − `other`) ∪ (`other` − `set`)
- en: Elements that are only in `set` or only in `other`. The formula makes it clear
    why the symmetric difference is both symmetric and a difference.
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只存在于 `set` 或只存在于 `other` 的元素。该公式清楚地说明了对称差既是对称的，又是差异。
- en: (`set` ∪ `other`) − (`set` ∩ `other`)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (`set` ∪ `other`) − (`set` ∩ `other`)
- en: The elements of `set` and `other` – except for the elements that are in both
    Sets.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set` 和 `other` 的元素——除了同时存在于两个集合中的元素。'
- en: '`set` xor `other`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set` 与 `other`'
- en: 'Exclusive Or – visually: Everything that is inside the area of `set` is inverted.
    Everything that is outside `set` is not changed.'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排他或——直观上：`set` 区域内的所有内容都被反转。`set` 区域外的所有内容保持不变。
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Implementing `set.symmetricDifference()`**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![练习图标](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：实现 `set.symmetricDifference()`**'
- en: '`exercises/sets/set-symmetric-difference_test.mjs`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/sets/set-symmetric-difference_test.mjs`'
- en: '[38.3 Checking Set relationships: subset of, superset of, disjoint from ^(ES2025)](#checking-set-relationships)'
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[38.3 检查集合关系：子集、超集、不相交 (ES2025)](#checking-set-relationships)'
- en: There are three methods for checking the relationships between two sets.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法用于检查两个集合之间的关系。
- en: '[38.3.1 Subset: `set.isSubsetOf(other)` ^(ES2025)](#Set.prototype.isSubsetOf)'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.3.1 子集：`set.isSubsetOf(other)` (ES2025)](#Set.prototype.isSubsetOf)'
- en: '`set.isSubsetOf(other)` returns `true` if all elements of `set` are in `other`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`set.isSubsetOf(other)` 返回 `true` 如果 `set` 的所有元素都在 `other` 中：'
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[38.3.2 Superset: `set.isSupersetOf(other)` ^(ES2025)](#Set.prototype.isSupersetOf)'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.3.2 超集：`set.isSupersetOf(other)` (ES2025)](#Set.prototype.isSupersetOf)'
- en: '`set.isSupersetOf(other)` returns `true` if `set` contains all elements of
    `other`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`set.isSupersetOf(other)` 返回 `true` 如果 `set` 包含 `other` 的所有元素：'
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[38.3.3 Disjoint: `set.isDisjointFrom(other)` ^(ES2025)](#Set.prototype.isDisjointFrom)'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.3.3 不相交：`set.isDisjointFrom(other)` (ES2025)](#Set.prototype.isDisjointFrom)'
- en: '`set.isDisjointFrom(other)` returns `true` if `set` and `other` have no elements
    in common:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`set.isDisjointFrom(other)` 返回 `true` 如果 `set` 和 `other` 没有共同元素：'
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercises
    for Set relationship methods**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![练习图标](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Set 关系方法练习**'
- en: 'Implementing Set equality: `exercises/sets/set-is-equal-to_test.mjs`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 Set 相等性：`exercises/sets/set-is-equal-to_test.mjs`
- en: 'Implementing `set.isSubsetOf()`: `exercises/sets/is-subset-of_test.mjs`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `set.isSubsetOf()`：`exercises/sets/is-subset-of_test.mjs`
- en: 'Implementing `set.isDisjointFrom()`: `exercises/sets/is-disjoint-from_test.mjs`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `set.isDisjointFrom()`：`exercises/sets/is-disjoint-from_test.mjs`
- en: '[38.4 Set-like objects (advanced)](#set-like-objects)'
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[38.4 Set-like 对象（高级）](#set-like-objects)'
- en: 'A Set method whose parameter is another Set `other` does not require `other`
    to be an actual Set; it only has to be Set-like and have the following methods:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一个参数为另一个 Set `other` 的 Set 方法不需要 `other` 真的是 Set；它只需要是 Set-like 并具有以下方法：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[38.4.1 Examples: finite Set-like objects](#examples-finite-setlike-objects)'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.4.1 示例：有限 Set-like 对象](#examples-finite-setlike-objects)'
- en: 'Let’s implement a simple Set-like object and use it with methods whose parameters
    are “other Sets”:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个简单的 Set-like 对象，并使用具有“其他 Set”参数的方法：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Maps are also Set-like:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Maps 也是 Set-like：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[38.4.2 Examples: infinite Set-like data](#infinite-sets)'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.4.2 示例：无限 Set-like 数据](#infinite-sets)'
- en: 'The `.size` of `other` can be `Infinity`. That means we can work with infinite
    Sets:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`other` 的 `.size` 可以是 `Infinity`。这意味着我们可以处理无限 Set：'
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This works because these methods only invoke `other.keys()` if `other.size`
    is smaller than `this.size`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为这些方法仅在 `other.size` 小于 `this.size` 时调用 `other.keys()`。
- en: 'Only two methods don’t support `other` being an infinite Set:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 只有两种方法不支持 `other` 是无限 Set：
- en: '`union`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`union`'
- en: '`symmetricDifference`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symmetricDifference`'
- en: '[38.4.3 FAQ: Set-like objects](#faq-setlike-objects)'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.4.3 常见问题解答：Set-like 对象](#faq-setlike-objects)'
- en: Why use the interface `SetLike` for `other`?
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么使用 `SetLike` 接口来处理 `other`？
- en: Due to the interface, `other` can be a data structure that is not a Set. It
    was chosen as a compromise between accepting only Sets and all iterable objects.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于接口，`other` 可以是一个不是 Set 的数据结构。它被选为只接受 Set 和所有可迭代对象的折衷方案。
- en: Why does JavaScript always enforce the full interface `SetLike` for `other`
    and throws an exception if a property is missing or has the wrong dynamic type?
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么 JavaScript 总是强制执行 `other` 的完整接口 `SetLike` 并在属性缺失或动态类型错误时抛出异常？
- en: That makes the API simpler and hides implementation details.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使得 API 更简单，并隐藏了实现细节。
- en: Why was method `.keys()` chosen for iterating over elements?
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择 `.keys()` 方法来遍历元素？
- en: 'That’s due to compatibility with the only Set-like data structure currently
    in the standard library – `Map`. Two other Set methods would have been nicer but
    can’t be used with Maps:'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是因为与标准库中当前唯一的 Set-like 数据结构 `Map` 兼容。另外两种 Set 方法会更好，但不能与 Maps 一起使用：
- en: The Map method `.[Symbol.iterator]()` returns key-value pairs.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Map 方法 `.[Symbol.iterator]()` 返回键值对。
- en: The Map method `.values()` is incompatible with the Map method `.has()` (which
    accepts keys, not values).
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Map 方法 `.values()` 与 Map 方法 `.has()`（接受键而不是值）不兼容。
- en: 'Source: [TC39 proposal](https://github.com/tc39/proposal-set-methods/blob/main/details.md)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[TC39 提案](https://github.com/tc39/proposal-set-methods/blob/main/details.md)
- en: '[38.5 Iterating over Sets](#iterating-over-sets-1)'
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[38.5 遍历 Set](#iterating-over-sets-1)'
- en: 'Sets are iterable and the `for-of` loop works as we’d expect:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Set 是可迭代的，`for-of` 循环按预期工作：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we can see, Sets preserve *insertion order*. That is, elements are always
    iterated over in the order in which they were added.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Sets 保留 *插入顺序*。也就是说，元素总是按它们被添加的顺序迭代。
- en: '[38.5.1 Converting a Set to an Array](#converting-set-to-array)'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.5.1 将 Set 转换为数组](#converting-set-to-array)'
- en: 'Sets are iterable, which is why we can use `Array.from()` to convert a Set
    to an Array:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是可迭代的，这就是为什么我们可以使用 `Array.from()` 将集合转换为数组：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can also perform the conversion via an iterator:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过迭代器执行转换：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`set.values()` returns in iterator for the values of `set`.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set.values()` 返回 `set` 的值的迭代器。'
- en: The iterator method `.toArray()` creates an Array with the iterated values.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器方法 `.toArray()` 创建一个包含迭代值的数组。
- en: '[38.5.2 Mapping and filtering Sets via iterator methods](#applying-iterator-methods-to-sets)'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.5.2 通过迭代器方法映射和过滤集合](#applying-iterator-methods-to-sets)'
- en: 'Sets don’t have a method `.map()`. But we can borrow the one that iterators
    have:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 集合没有 `.map()` 方法。但我们可以借用迭代器拥有的那个方法：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The previous code shows a common pattern for using iterator methods with Sets:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码展示了使用集合的迭代器方法的常见模式：
- en: '`set.values()` returns an iterator for `set` (line B).'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set.values()` 返回 `set` 的迭代器（行B）。'
- en: '`.map()` is an iterator method that returns an iterator (line B).'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.map()` 是一个迭代器方法，它返回一个迭代器（行B）。'
- en: The result of the previous step is an iterable iterator. It is passed to the
    constructor `Set` which accepts any iterable as a parameter and uses it to fill
    the new Set with values.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一步的结果是一个可迭代的迭代器。它被传递给接受任何可迭代对象作为参数的构造函数 `Set`，并使用它填充新的集合。
- en: 'Filtering Sets works the same way:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤集合的工作方式相同：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'What if we can’t use iterator methods? Then we can switch to Array methods:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不能使用迭代器方法怎么办？那么我们可以切换到数组方法：
- en: We use `Array.from(set)`
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `Array.from(set)`
- en: instead of `set.values()`.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是 `set.values()`。
- en: '[38.5.3 Example: combining Sets via iteration ^(ES2025)](#combining-sets-via-iteration)'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.5.3 示例：通过迭代组合集合（ES2025）](#combining-sets-via-iteration)'
- en: 'Instead of the Set methods, we can also use iteration to combine Sets:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用迭代来代替集合方法结合集合：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[38.5.4 Grouping Set elements ^(ES2024)](#grouping-set-elements-es2024)'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.5.4 分组集合元素（ES2024）](#grouping-set-elements-es2024)'
- en: 'Grouping via `Object.groupBy()` and `Map.groupBy()` works for any iterable
    object and therefore for Sets:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `Object.groupBy()` 和 `Map.groupBy()` 进行分组适用于任何可迭代对象，因此也适用于集合：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'More information: [“Grouping iterables ^(ES2024)” (§32.8)](ch_sync-iteration.html#grouping-sync-iterables)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息：[“分组可迭代对象（ES2024）” (§32.8)](ch_sync-iteration.html#grouping-sync-iterables)
- en: '[38.6 Examples of using Sets](#examples-of-using-sets)'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[38.6 使用集合的示例](#examples-of-using-sets)'
- en: '[38.6.1 Removing duplicates from an Array](#removing-duplicates-from-an-array)'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.6.1 从数组中删除重复项](#removing-duplicates-from-an-array)'
- en: 'Converting an Array to a Set and back, removes duplicates from the Array:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组转换为集合再转换回来，会从数组中删除重复项：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[38.6.2 Creating a set of Unicode characters (code points)](#creating-a-set-of-unicode-characters-code-points)'
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.6.2 创建Unicode字符集（代码点）](#creating-a-set-of-unicode-characters-code-points)'
- en: 'Strings are iterable and can therefore be used as parameters for `new Set()`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是可迭代的，因此可以用作 `new Set()` 的参数：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[38.7 Details of the Set API (advanced)](#details-of-the-set-api-advanced)'
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[38.7 集合API的详细信息（高级）](#details-of-the-set-api-advanced)'
- en: '[38.7.1 What Set elements are considered equal?](#what-set-elements-are-considered-equal)'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.7.1 哪些集合元素被认为是相等的？](#what-set-elements-are-considered-equal)'
- en: As with Map keys, Set elements are compared similarly to `===`, with the exception
    of `NaN` being equal to itself.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与Map键类似，集合元素与 `===` 进行类似比较，除了 `NaN` 等于自身。
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As with `===`, two different objects are never considered equal (and there
    is no way to change that at the moment):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `===` 类似，两个不同的对象永远不会被认为是相等的（目前也没有办法改变这一点）：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[38.7.2 FAQ: Set API](#faq-set-api)'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.7.2 常见问题解答：集合API](#faq-set-api)'
- en: Why do Sets have a `.size`, while Arrays have a `.length`?
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么集合有 `.size`，而数组有 `.length`？
- en: The answer to this question is given in [“Why do Maps have a `.size`, while
    Arrays have a `.length`?” (§36.7.4)](ch_maps.html#collection-size-vs-length).
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个问题的答案在“为什么Map有`.size`，而数组有`.length`？”（§36.7.4）中给出。
- en: 'Why are some method names verbs and others nouns? This is a rough general rule:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么有些方法名是动词，而有些是名词？这是一个粗略的一般规则：
- en: 'Verb methods mutate `this` – e.g.: `set.add()` and `set.clear()`'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动词方法会修改 `this` – 例如：`set.add()` 和 `set.clear()`
- en: 'Noun methods return new data – e.g.: `set.values()` and `set.union()`'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名词方法返回新数据 – 例如：`set.values()` 和 `set.union()`
- en: '[38.8 Quick reference: `Set`](#quickref-sets)'
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[38.8 快速参考：`Set`](#quickref-sets)'
- en: '[38.8.1 `new Set()`](#new-set)'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.8.1 `new Set()`](#new-set)'
- en: '`new Set(iterable)` ES6'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new Set(iterable)` ES6'
- en: If we don’t provide the parameter `values`, then an empty Set is created.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们不提供参数 `values`，则创建一个空集合。
- en: If we do, then the iterated values are added as elements to the Set.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们这样做，那么迭代的值将被添加为集合的元素。
- en: '[PRE31]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[38.8.2 `Set.prototype.*`: working with single Set elements](#setprototype-working-with-single-set-elements)'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.8.2 `Set.prototype.*`: 处理单个集合元素](#setprototype-working-with-single-set-elements)'
- en: '`Set.prototype.add(value)` ES6'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype.add(value)` ES6'
- en: Adds `value` to this Set.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向这个集合添加 `value`。
- en: This method returns `this`, which means that it can be chained.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法返回 `this`，这意味着它可以被链式调用。
- en: '[PRE32]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`Set.prototype.delete(value)` ES6'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype.delete(value)` ES6'
- en: Removes `value` from this Set.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从这个集合中移除 `value`。
- en: Returns `true` if something was deleted and `false`, otherwise.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有东西被删除，则返回 `true`，否则返回 `false`。
- en: '[PRE33]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`Set.prototype.has(value)` ES6'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype.has(value)` ES6'
- en: Returns `true` if `value` is in this Set and `false` otherwise.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 `value` 在这个集合中，则返回 `true`，否则返回 `false`。
- en: '[PRE34]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[38.8.3 `Set.prototype.*`: working with all Set elements](#setprototype-working-with-all-set-elements)'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.8.3 `Set.prototype.*`: 处理所有集合元素](#setprototype-working-with-all-set-elements)'
- en: '`get Set.prototype.size` ES6'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get Set.prototype.size` ES6'
- en: Returns how many elements there are in this Set.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回这个集合中有多少个元素。
- en: '[PRE35]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`Set.prototype.clear()` ES6'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype.clear()` ES6'
- en: Removes all elements from this Set.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从这个集合中移除所有元素。
- en: '[PRE36]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[38.8.4 `Set.prototype.*`: iterating and looping](#setprototype-iterating-and-looping)'
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.8.4 `Set.prototype.*`: 遍历和循环](#setprototype-iterating-and-looping)'
- en: '`Set.prototype.values()` ES6'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype.values()` ES6'
- en: Returns an iterable over all elements of this Set.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回一个遍历这个集合所有元素的迭代器。
- en: '[PRE37]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Output:'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE38]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`Set.prototype[Symbol.iterator]()` ES6'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype[Symbol.iterator]()` ES6'
- en: Default way of iterating over Sets. Same as `.values()`.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 遍历集合的默认方式。与 `.values()` 相同。
- en: '[PRE39]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Output:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE40]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`Set.prototype.forEach(callback, thisArg?)` ES6'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype.forEach(callback, thisArg?)` ES6'
- en: '[PRE41]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Feeds each element of this Set to `callback()`. `value` and `key` both contain
    the current element. This redundancy was introduced so that this `callback` has
    the same type signature as the `callback` of `Map.prototype.forEach()`.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将这个集合的每个元素传递给 `callback()`。`value` 和 `key` 都包含当前元素。这种冗余是为了使这个 `callback` 与 `Map.prototype.forEach()`
    的 `callback` 具有相同的类型签名。
- en: We can specify the `this` of `callback` via `thisArg`. If we omit it, `this`
    is `undefined`.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过 `thisArg` 指定 `callback` 的 `this`。如果我们省略它，则 `this` 是 `undefined`。
- en: '[PRE42]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Output:'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE43]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[38.8.4.1 Symmetry with `Map`](#symmetry-with-map)'
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[38.8.4.1 与 `Map` 的对称性](#symmetry-with-map)'
- en: The following methods make the interface of `Set` symmetric with the interface
    of `Map`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法使 `Set` 的接口与 `Map` 的接口对称。
- en: '`Set.prototype.entries(): Iterable<[T,T]>` ES6'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype.entries(): Iterable<[T,T]>` ES6'
- en: 'Mainly exists so that Sets and Maps have similar interfaces: Each Set element
    is viewed as a key-value entry whose key and value are both that element:'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 主要存在是为了使集合和映射具有相似的接口：每个集合元素被视为一个键值对，其键和值都是该元素：
- en: '[PRE44]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`.entries()` enables us to convert a Set to a Map:'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`.entries()` 允许我们将集合转换为映射：'
- en: '[PRE45]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`Set.prototype.keys(): Iterable<T>` ES6'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype.keys(): Iterable<T>` ES6'
- en: 'Mainly exists so that Sets and Maps have similar interfaces: Each Set element
    is viewed as a key-value entry whose key and value are both that element. Therefore
    the result of `.keys()` is the same as the result of `.values()`:'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 主要存在是为了使集合和映射具有相似的接口：每个集合元素被视为一个键值对，其键和值都是该元素。因此 `.keys()` 的结果与 `.values()`
    的结果相同：
- en: '[PRE46]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[38.8.5 `Set.prototype.*`: combining two Sets ^(ES2025)](#setprototype-combining-two-sets-es2025)'
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.8.5 `Set.prototype.*`: 合并两个集合 (ES2025)](#setprototype-combining-two-sets-es2025)'
- en: '`Set.prototype.union(other)` ES2025'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype.union(other)` ES2025'
- en: '[PRE47]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This method returns a Set that is the union of `this` and `other`. It contains
    a value if it is in `this` or `other`.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法返回一个集合，它是 `this` 和 `other` 的并集。如果它在 `this` 或 `other` 中，则包含该值。
- en: '[PRE48]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`other` doesn’t have to be a Set, it only has to be [*Set-like*](#set-like-objects)
    and have the property `.size` and the methods `.has(key)` and `.keys()`. Sets
    and Maps both fulfill those requirements.'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`other` 不必是集合，它只需要是 [*类似集合*](#set-like-objects) 并具有属性 `.size` 和方法 `.has(key)`
    以及 `.keys()`。集合和映射都满足这些要求。'
- en: '`Set.prototype.intersection(other)` ES2025'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype.intersection(other)` ES2025'
- en: '[PRE49]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This method returns a Set that is the intersection of `this` and `other`. It
    contains a value if it is in `this` or `other`.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法返回一个集合，它是 `this` 和 `other` 的交集。如果它在 `this` 或 `other` 中，则包含该值。
- en: '[PRE50]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`other` doesn’t have to be a Set, it only has to be [*Set-like*](#set-like-objects)
    and have the property `.size` and the methods `.has(key)` and `.keys()`. Sets
    and Maps both fulfill those requirements.'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`other` 不必是集合，它只需要是 [*类似集合*](#set-like-objects) 并具有属性 `.size` 和方法 `.has(key)`
    以及 `.keys()`。集合和映射都满足这些要求。'
- en: '`Set.prototype.difference(other)` ES2025'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype.difference(other)` ES2025'
- en: '[PRE51]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This method returns a Set that is the difference between `this` and `other`.
    It contains a value if it is in `this` but not in `other`.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法返回一个集合，它是`this`和`other`的差集。如果该值在`this`中但不在`other`中，则包含该值。
- en: '[PRE52]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`other` doesn’t have to be a Set, it only has to be [*Set-like*](#set-like-objects)
    and have the property `.size` and the methods `.has(key)` and `.keys()`. Sets
    and Maps both fulfill those requirements.'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`other`不必是集合，它只需要是[*类似集合的*](#set-like-objects)对象，并具有`.size`属性以及`.has(key)`和`.keys()`方法。集合和映射都满足这些要求。'
- en: '`Set.prototype.symmetricDifference(other)` ES2025'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype.symmetricDifference(other)` ES2025'
- en: '[PRE53]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This method returns a Set that is the symmetric difference between `this` and
    `other`. It contains a value if it is only in `this` or only in `other`.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法返回一个集合，它是`this`和`other`的对称差集。如果该值仅在`this`或仅在`other`中，则包含该值。
- en: '[PRE54]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`other` doesn’t have to be a Set, it only has to be [*Set-like*](#set-like-objects)
    and have the property `.size` and the methods `.has(key)` and `.keys()`. Sets
    and Maps both fulfill those requirements.'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`other`不必是集合，它只需要是[*类似集合的*](#set-like-objects)对象，并具有`.size`属性以及`.has(key)`和`.keys()`方法。集合和映射都满足这些要求。'
- en: For more information on this method, see [its section in this chapter](#Set.prototype.symmetricDifference).
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于此方法的更多信息，请参阅[本章中的相关部分](#Set.prototype.symmetricDifference)。
- en: '[38.8.6 `Set.prototype.*`: checking Set relationships ^(ES2025)](#setprototype-checking-set-relationships-es2025)'
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[38.8.6 `Set.prototype.*`: 检查集合关系^(ES2025)](#setprototype-checking-set-relationships-es2025)'
- en: '`Set.prototype.isSubsetOf(other)` ES2025'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype.isSubsetOf(other)` ES2025'
- en: '[PRE55]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Returns `true` if all elements of `this` are in `other`:'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`this`的所有元素都在`other`中，则返回`true`：
- en: '[PRE56]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`Set.prototype.isSupersetOf(other)` ES2025'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype.isSupersetOf(other)` ES2025'
- en: '[PRE57]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Returns `true` if `this` contains all elements of `other`:'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`this`包含`other`的所有元素，则返回`true`：
- en: '[PRE58]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '`Set.prototype.isDisjointFrom(other)` ES2025'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set.prototype.isDisjointFrom(other)` ES2025'
- en: '[PRE59]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Returns `true` if `this` and `other` have no elements in common:'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`this`和`other`没有共同元素，则返回`true`：
- en: '[PRE60]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
