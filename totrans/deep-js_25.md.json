["```js\nconst logged = [];\n\nconst target = {size: 0};\nconst handler = {\n get(target, propKey, receiver) {\n logged.push('GET ' + propKey);\n return 123;\n }\n};\nconst proxy = new Proxy(target, handler);\n```", "```js\nassert.equal(\n proxy.size, 123);\n\nassert.deepEqual(\n logged, ['GET size']);\n```", "```js\nconst str = 'Hello' + '!'.repeat(3);\nconsole.log('System.out.println(\"'+str+'\")');\n```", "```js\n> eval('5 + 2')\n7\n```", "```js\n// Base level\nconst obj = {\n hello() {\n console.log('Hello!');\n },\n};\n\n// Meta level\nfor (const key of Object.keys(obj)) {\n console.log(key);\n}\n```", "```js\nfunction moveProperty(source, propertyName, target) {\n target[propertyName] = source[propertyName];\n delete source[propertyName];\n}\n```", "```js\nconst obj1 = { color: 'blue' };\nconst obj2 = {};\n\nmoveProperty(obj1, 'color', obj2);\n\nassert.deepEqual(\n obj1, {});\n\nassert.deepEqual(\n obj2, { color: 'blue' });\n```", "```js\nconst logged = [];\n\nconst target = {};\nconst handler = {\n /** Intercepts: getting properties */\n get(target, propKey, receiver) {\n logged.push(`GET ${propKey}`);\n return 123;\n },\n\n /** Intercepts: checking whether properties exist */\n has(target, propKey) {\n logged.push(`HAS ${propKey}`);\n return true;\n }\n};\nconst proxy = new Proxy(target, handler);\n```", "```js\nassert.equal(proxy.age, 123); // (A)\nassert.equal('hello' in proxy, true); // (B)\n\nassert.deepEqual(\n logged, [\n 'GET age',\n 'HAS hello',\n ]);\n```", "```js\nproxy.age = 99;\nassert.equal(target.age, 99);\n```", "```js\nconst traced = [];\n\nfunction traceMethodCalls(obj) {\n const handler = {\n get(target, propKey, receiver) {\n const origMethod = target[propKey];\n return function (...args) { // implicit parameter `this`!\n const result = origMethod.apply(this, args);\n traced.push(propKey + JSON.stringify(args)\n + ' -> ' + JSON.stringify(result));\n return result;\n };\n }\n };\n return new Proxy(obj, handler);\n}\n```", "```js\nconst obj = {\n multiply(x, y) {\n return x * y;\n },\n squared(x) {\n return this.multiply(x, x);\n },\n};\n\nconst tracedObj = traceMethodCalls(obj);\nassert.equal(\n tracedObj.squared(9), 81);\n\nassert.deepEqual(\n traced, [\n 'multiply[9,9] -> 81',\n 'squared[9] -> 81',\n ]);\n```", "```js\nconst {proxy, revoke} = Proxy.revocable(target, handler);\n```", "```js\nconst target = {}; // Start with an empty object\nconst handler = {}; // Don\u2019t intercept anything\nconst {proxy, revoke} = Proxy.revocable(target, handler);\n\n// `proxy` works as if it were the object `target`:\nproxy.city = 'Paris';\nassert.equal(proxy.city, 'Paris');\n\nrevoke();\n\nassert.throws(\n () => proxy.prop,\n /^TypeError: Cannot perform 'get' on a proxy that has been revoked$/\n);\n```", "```js\nconst proto = new Proxy({}, {\n get(target, propertyKey, receiver) {\n console.log('GET '+propertyKey);\n return target[propertyKey];\n }\n});\n\nconst obj = Object.create(proto);\nobj.weight;\n\n// Output:\n// 'GET weight'\n```", "```js\nconst handler = {\n deleteProperty(target, propKey) {\n console.log('DELETE ' + propKey);\n return delete target[propKey];\n },\n has(target, propKey) {\n console.log('HAS ' + propKey);\n return propKey in target;\n },\n // Other traps: similar\n}\n```", "```js\nhandler.trap(target, arg_1, \u00b7\u00b7\u00b7, arg_n)\n```", "```js\nReflect.trap(target, arg_1, \u00b7\u00b7\u00b7, arg_n)\n```", "```js\nconst handler = {\n deleteProperty(target, propKey) {\n console.log('DELETE ' + propKey);\n return Reflect.deleteProperty(target, propKey);\n },\n has(target, propKey) {\n console.log('HAS ' + propKey);\n return Reflect.has(target, propKey);\n },\n // Other traps: similar\n}\n```", "```js\nconst handler = new Proxy({}, {\n get(target, trapName, receiver) {\n // Return the handler method named trapName\n return (...args) => {\n console.log(trapName.toUpperCase() + ' ' + args[1]);\n // Forward the operation\n return Reflect[trapName](...args);\n };\n },\n});\n```", "```js\nconst target = {};\nconst proxy = new Proxy(target, handler);\n\nproxy.distance = 450; // set\nassert.equal(proxy.distance, 450); // get\n\n// Was `set` operation correctly forwarded to `target`?\nassert.equal(\n target.distance, 450);\n\n// Output:\n// 'SET distance'\n// 'GETOWNPROPERTYDESCRIPTOR distance'\n// 'DEFINEPROPERTY distance'\n// 'GET distance'\n```", "```js\nconst target = {\n myMethod() {\n return {\n thisIsTarget: this === target,\n thisIsProxy: this === proxy,\n };\n }\n};\nconst handler = {};\nconst proxy = new Proxy(target, handler);\n```", "```js\nassert.deepEqual(\n target.myMethod(), {\n thisIsTarget: true,\n thisIsProxy: false,\n });\n```", "```js\nassert.deepEqual(\n proxy.myMethod(), {\n thisIsTarget: false,\n thisIsProxy: true,\n });\n```", "```js\nconst _name = new WeakMap();\nclass Person {\n constructor(name) {\n _name.set(this, name);\n }\n get name() {\n return _name.get(this);\n }\n}\n```", "```js\nconst jane = new Person('Jane');\nassert.equal(jane.name, 'Jane');\n\nconst proxy = new Proxy(jane, {});\nassert.equal(proxy.name, undefined);\n```", "```js\nclass Person2 {\n constructor(name) {\n this._name = name;\n }\n get name() {\n return this._name;\n }\n}\n\nconst jane = new Person2('Jane');\nassert.equal(jane.name, 'Jane');\n\nconst proxy = new Proxy(jane, {});\nassert.equal(proxy.name, 'Jane');\n```", "```js\nconst target = new Date();\nconst handler = {};\nconst proxy = new Proxy(target, handler);\n\nassert.throws(\n () => proxy.getFullYear(),\n /^TypeError: this is not a Date object\\.$/\n);\n```", "```js\nO.[[GetPrototypeOf]]()\n```", "```js\nconst handler = {\n get(target, propKey, receiver) {\n if (propKey === 'getFullYear') {\n return target.getFullYear.bind(target);\n }\n return Reflect.get(target, propKey, receiver);\n },\n};\nconst proxy = new Proxy(new Date('2030-12-24'), handler);\nassert.equal(proxy.getFullYear(), 2030);\n```", "```js\nconst p = new Proxy(new Array(), {});\n\np.push('a');\nassert.equal(p.length, 1);\n\np.length = 0;\nassert.equal(p.length, 0);\n```", "```js\nclass Point {\n constructor(x, y) {\n this.x = x;\n this.y = y;\n }\n toString() {\n return `Point(${this.x}, ${this.y})`;\n }\n}\n\n// Trace accesses to properties `x` and `y`\nconst point = new Point(5, 7);\nconst tracedPoint = tracePropertyAccesses(point, ['x', 'y']);\n```", "```js\nassert.equal(tracedPoint.x, 5);\ntracedPoint.x = 21;\n\n// Output:\n// 'GET x'\n// 'SET x=21'\n```", "```js\nassert.equal(\n tracedPoint.toString(),\n 'Point(21, 7)');\n\n// Output:\n// 'GET x'\n// 'GET y'\n```", "```js\nfunction tracePropertyAccesses(obj, propKeys, log=console.log) {\n // Store the property data here\n const propData = Object.create(null);\n\n // Replace each property with a getter and a setter\n propKeys.forEach(function (propKey) {\n propData[propKey] = obj[propKey];\n Object.defineProperty(obj, propKey, {\n get: function () {\n log('GET '+propKey);\n return propData[propKey];\n },\n set: function (value) {\n log('SET '+propKey+'='+value);\n propData[propKey] = value;\n },\n });\n });\n return obj;\n}\n```", "```js\nconst obj = {};\nconst logged = [];\ntracePropertyAccesses(obj, ['a', 'b'], x => logged.push(x));\n\nobj.a = 1;\nassert.equal(obj.a, 1);\n\nobj.c = 3;\nassert.equal(obj.c, 3);\n\nassert.deepEqual(\n logged, [\n 'SET a=1',\n 'GET a',\n ]);\n```", "```js\nfunction tracePropertyAccesses(obj, propKeys, log=console.log) {\n const propKeySet = new Set(propKeys);\n return new Proxy(obj, {\n get(target, propKey, receiver) {\n if (propKeySet.has(propKey)) {\n log('GET '+propKey);\n }\n return Reflect.get(target, propKey, receiver);\n },\n set(target, propKey, value, receiver) {\n if (propKeySet.has(propKey)) {\n log('SET '+propKey+'='+value);\n }\n return Reflect.set(target, propKey, value, receiver);\n },\n });\n}\n```", "```js\nconst propertyCheckerHandler = {\n get(target, propKey, receiver) {\n // Only check string property keys\n if (typeof propKey === 'string' && !(propKey in target)) {\n throw new ReferenceError('Unknown property: ' + propKey);\n }\n return Reflect.get(target, propKey, receiver);\n }\n};\nconst PropertyChecker = new Proxy({}, propertyCheckerHandler);\n```", "```js\nconst jane = {\n __proto__: PropertyChecker,\n name: 'Jane',\n};\n\n// Own property:\nassert.equal(\n jane.name,\n 'Jane');\n\n// Typo:\nassert.throws(\n () => jane.nmae,\n /^ReferenceError: Unknown property: nmae$/);\n\n// Inherited property:\nassert.equal(\n jane.toString(),\n '[object Object]');\n```", "```js\n// We can\u2019t change .prototype of classes, so we are using a function\nfunction PropertyChecker2() {}\nPropertyChecker2.prototype = new Proxy({}, propertyCheckerHandler);\n\nclass Point extends PropertyChecker2 {\n constructor(x, y) {\n super();\n this.x = x;\n this.y = y;\n }\n}\n\nconst point = new Point(5, 7);\nassert.equal(point.x, 5);\nassert.throws(\n () => point.z,\n /^ReferenceError: Unknown property: z/);\n```", "```js\nconst p = Object.getPrototypeOf.bind(Object);\nassert.equal(p(point), Point.prototype);\nassert.equal(p(p(point)), PropertyChecker2.prototype);\nassert.equal(p(p(p(point))), Object.prototype);\n```", "```js\n> ['a', 'b', 'c'].slice(-1)\n[ 'c' ]\n```", "```js\nfunction createArray(...elements) {\n const handler = {\n get(target, propKey, receiver) {\n if (typeof propKey === 'string') {\n const index = Number(propKey);\n if (index < 0) {\n propKey = String(target.length + index);\n }\n }\n return Reflect.get(target, propKey, receiver);\n }\n };\n // Wrap a proxy around the Array\n return new Proxy(elements, handler);\n}\nconst arr = createArray('a', 'b', 'c');\nassert.equal(\n arr[-1], 'c');\nassert.equal(\n arr[0], 'a');\nassert.equal(\n arr.length, 3);\n```", "```js\nfunction createObservedArray(callback) {\n const array = [];\n return new Proxy(array, {\n set(target, propertyKey, value, receiver) {\n callback(propertyKey, value);\n return Reflect.set(target, propertyKey, value, receiver);\n }\n });\n}\nconst observedArray = createObservedArray(\n (key, value) => console.log(\n `${JSON.stringify(key)} = ${JSON.stringify(value)}`));\nobservedArray.push('a');\n\n// Output:\n// '\"0\" = \"a\"'\n// '\"length\" = 1'\n```", "```js\nconst service = createWebService('http://example.com/data');\n// Read JSON data in http://example.com/data/employees\nservice.employees().then((jsonStr) => {\n const employees = JSON.parse(jsonStr);\n // \u00b7\u00b7\u00b7\n});\n```", "```js\nfunction createWebService(baseUrl, propKeys) {\n const service = {};\n for (const propKey of propKeys) {\n service[propKey] = () => {\n return httpGet(baseUrl + '/' + propKey);\n };\n }\n return service;\n}\n```", "```js\nfunction createWebService(baseUrl) {\n return new Proxy({}, {\n get(target, propKey, receiver) {\n // Return the method to be called\n return () => httpGet(baseUrl + '/' + propKey);\n }\n });\n}\n```", "```js\nfunction httpGet(url) {\n return new Promise(\n (resolve, reject) => {\n const xhr = new XMLHttpRequest();\n xhr.onload = () => {\n if (xhr.status === 200) {\n resolve(xhr.responseText); // (A)\n } else {\n // Something went wrong (404, etc.)\n reject(new Error(xhr.statusText)); // (B)\n }\n }\n xhr.onerror = () => {\n reject(new Error('Network error')); // (C)\n };\n xhr.open('GET', url);\n xhr.send();\n });\n}\n```", "```js\nconst resource = { x: 11, y: 8 };\nconst {reference, revoke} = createRevocableReference(resource);\n\n// Access granted\nassert.equal(reference.x, 11);\n\nrevoke();\n\n// Access denied\nassert.throws(\n () => reference.x,\n /^TypeError: Cannot perform 'get' on a proxy that has been revoked/\n);\n```", "```js\nfunction createRevocableReference(target) {\n let enabled = true;\n return {\n reference: new Proxy(target, {\n get(target, propKey, receiver) {\n if (!enabled) {\n throw new TypeError(\n `Cannot perform 'get' on a proxy that has been revoked`);\n }\n return Reflect.get(target, propKey, receiver);\n },\n has(target, propKey) {\n if (!enabled) {\n throw new TypeError(\n `Cannot perform 'has' on a proxy that has been revoked`);\n }\n return Reflect.has(target, propKey);\n },\n // (Remaining methods omitted)\n }),\n revoke: () => {\n enabled = false;\n },\n };\n}\n```", "```js\nfunction createRevocableReference(target) {\n let enabled = true;\n const handler = new Proxy({}, {\n get(_handlerTarget, trapName, receiver) {\n if (!enabled) {\n throw new TypeError(\n `Cannot perform '${trapName}' on a proxy`\n + ` that has been revoked`);\n }\n return Reflect[trapName];\n }\n });\n return {\n reference: new Proxy(target, handler),\n revoke: () => {\n enabled = false;\n },\n };\n}\n```", "```js\nfunction createRevocableReference(target) {\n const handler = {}; // forward everything\n const { proxy, revoke } = Proxy.revocable(target, handler);\n return { reference: proxy, revoke };\n}\n```", "```js\nconst calc = {\n __noSuchMethod__: function (methodName, args) {\n switch (methodName) {\n case 'plus':\n return args.reduce((a, b) => a + b);\n case 'times':\n return args.reduce((a, b) => a * b);\n default:\n throw new TypeError('Unsupported: ' + methodName);\n }\n }\n};\n\n// All of the following method calls are implemented via\n// .__noSuchMethod__().\nassert.equal(\n calc.plus(3, 5, 2), 10);\nassert.equal(\n calc.times(2, 3, 4), 24);\n\nassert.equal(\n calc.plus('Parts', ' of ', 'a', ' string'),\n 'Parts of a string');\n```", "```js\n    const obj = { hasOwnProperty: null };\n    assert.throws(\n     () => obj.hasOwnProperty('width'),\n     /^TypeError: obj.hasOwnProperty is not a function/\n    );\n    ```", "```js\n    assert.equal(\n     Object.prototype.hasOwnProperty.call(obj, 'width'), false);\n\n    // Abbreviated version:\n    assert.equal(\n     {}.hasOwnProperty.call(obj, 'width'), false);\n    ```", "```js\n// lib.mjs\nconst proxies = new WeakSet();\n\nexport function createProxy(obj) {\n const handler = {};\n const proxy = new Proxy(obj, handler);\n proxies.add(proxy);\n return proxy;\n}\n\nexport function isProxy(obj) {\n return proxies.has(obj);\n}\n```", "```js\n// main.mjs\nimport { createProxy, isProxy } from './lib.mjs';\n\nconst proxy = createProxy({});\nassert.equal(isProxy(proxy), true);\nassert.equal(isProxy({}), false);\n```", "```js\n// Method definition\n__Get__(propKey, receiver) {\n const desc = this.__GetOwnProperty__(propKey);\n if (desc === undefined) {\n const parent = this.__GetPrototypeOf__();\n if (parent === null) return undefined;\n return parent.__Get__(propKey, receiver); // (A)\n }\n if ('value' in desc) {\n return desc.value;\n }\n const getter = desc.get;\n if (getter === undefined) return undefined;\n return getter.__Call__(receiver, []);\n}\n```", "```js\n// Variant 1: call via dynamic dispatch\nconst result1 = obj.m();\n\n// Variant 2: extract and call directly\nconst m = obj.m;\nconst result2 = m.call(obj);\n```", "```js\nconst boundMethod = obj.m;\nconst result = boundMethod();\n```", "```js\nconst fakeProto = {};\nconst handler = {\n getPrototypeOf(t) {\n return fakeProto;\n }\n};\n```", "```js\nconst extensibleTarget = {};\nconst extProxy = new Proxy(extensibleTarget, handler);\n\nassert.equal(\n Object.getPrototypeOf(extProxy), fakeProto);\n```", "```js\nconst nonExtensibleTarget = {};\nObject.preventExtensions(nonExtensibleTarget);\nconst nonExtProxy = new Proxy(nonExtensibleTarget, handler);\n\nassert.throws(\n () => Object.getPrototypeOf(nonExtProxy),\n {\n name: 'TypeError',\n message: \"'getPrototypeOf' on proxy: proxy target is\"\n + \" non-extensible but the trap did not return its\"\n + \" actual prototype\",\n });\n```", "```js\nconst handler = {\n get(target, propKey) {\n return 'abc';\n }\n};\nconst target = Object.defineProperties(\n {}, {\n manufacturer: {\n value: 'Iso Autoveicoli',\n writable: true,\n configurable: true\n },\n model: {\n value: 'Isetta',\n writable: false,\n configurable: false\n },\n });\nconst proxy = new Proxy(target, handler);\n```", "```js\nassert.equal(\n proxy.manufacturer, 'abc');\n```", "```js\nassert.throws(\n () => proxy.model,\n {\n name: 'TypeError',\n message: \"'get' on proxy: property 'model' is a read-only and\"\n + \" non-configurable data property on the proxy target but\"\n + \" the proxy did not return its actual value (expected\"\n + \" 'Isetta' but got 'abc')\",\n });\n```", "```js\ntype PropertyKey = string | symbol;\n```", "```js\n    func.apply(thisArg, argArray) // not safe\n    Function.prototype.apply.call(func, thisArg, argArray) // safe\n    ```", "```js\n    Reflect.apply(func, thisArg, argArray)\n    ```"]