- en: 44 Async functions ES2017
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_async-functions.html](https://exploringjs.com/js/book/ch_async-functions.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[44.1 Async functions: the basics](#async-functions-the-basics)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44.1.1 The `await` operator makes Promises synchronous](#await-operator)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44.1.2 Returning a value from an async function resolves the function’s result](#async-function-return)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44.1.3 Asynchronous callable entities](#async-callables)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44.2 What values can be used with `await`?](#what-values-can-be-used-with-await)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44.2.1 Awaiting fulfilled Promises](#awaiting-fulfilled-promises)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44.2.2 Awaiting rejected Promises](#awaiting-rejected-promises)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44.2.3 Awaiting non-Promise values](#awaiting-nonpromise-values)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44.3 Where can `await` be used?](#where-can-await-be-used)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44.3.1 Using `await` at the top levels of modules ^(ES2022)](#using-await-at-the-top-levels-of-modules-es2022)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44.3.2 Awaiting is shallow](#awaiting-is-shallow)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44.3.3 Example: `.map()` with an async function as a callback](#map-with-async-callback)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44.4 `return` in async functions](#return-in-async-functions)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44.4.1 The result of an async function is always a Promise](#the-result-of-an-async-function-is-always-a-promise)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44.4.2 Returning a Promise resolves the result Promise](#returning-a-promise-resolves-the-result-promise)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44.5 Async functions start synchronously, settle asynchronously](#async-funcs-start-sync-settle-async)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44.6 Tips for using async functions](#tips-for-using-async-functions)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44.6.1 We don’t need `await` if we “fire and forget”](#fire-and-forget-await)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44.6.2 It can make sense to `await` and ignore the result](#it-can-make-sense-to-await-and-ignore-the-result)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44.6.3 The pros and cons of `return await`](#return-await)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44.7 Concurrency and `await` (advanced)](#concurrency-and-await)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44.7.1 `await`: running Promise-based functions sequentially](#await-sequentially)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[44.7.2 `await`: running Promise-based functions concurrently](#await-concurrently)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Async functions* provide better syntax for code that uses Promises. Promises
    are therefore required knowledge for understanding async functions. They are explained
    in [the previous chapter](ch_promises.html#ch_promises).'
  prefs: []
  type: TYPE_NORMAL
- en: '[44.1 Async functions: the basics](#async-functions-the-basics)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following async function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Two keywords are important:'
  prefs: []
  type: TYPE_NORMAL
- en: The keyword `async` before `function` means that this is an async function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `await` operator is applied to Promises and either extracts fulfillment
    values or throws rejection values. More on it soon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The previous, rather synchronous-looking code is equivalent to the following
    code that uses Promises directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `fetchJsonAsync()` and `fetchJsonViaPromises()` are called in exactly
    the same way – e.g., like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **Async functions
    are as Promise-based as functions that use Promises directly**'
  prefs: []
  type: TYPE_NORMAL
- en: From the outside, it is virtually impossible to tell the difference between
    an async function and a function that returns a Promise.
  prefs: []
  type: TYPE_NORMAL
- en: '[44.1.1 The `await` operator makes Promises synchronous](#await-operator)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the body of an async function, we write Promise-based code as if it
    were synchronous. We only need to apply the `await` operator whenever a value
    is a Promise. That operator pauses the async function and resumes it once the
    Promise is settled:'
  prefs: []
  type: TYPE_NORMAL
- en: If the Promise is fulfilled, `await` returns the fulfillment value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the Promise is rejected, `await` throws the rejection value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[44.1.2 Returning a value from an async function resolves the function’s result](#async-function-return)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The result of an async function is always a Promise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any value that is returned (explicitly or implicitly) is used to resolve that
    Promise:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Any exception that is thrown is used to reject the Promise:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[44.1.3 Asynchronous callable entities](#async-callables)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: JavaScript has the following async versions of synchronous callable entities.
    Their roles are always either real function or method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **Asynchronous
    functions vs. async functions**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference between the terms *asynchronous function* and *async function*
    is subtle, but important:'
  prefs: []
  type: TYPE_NORMAL
- en: An *asynchronous function* is any function that delivers its result asynchronously
    – for example, a callback-based function or a Promise-based function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An *async function* is defined via special syntax, involving the keywords `async`
    and `await`. It is also called async/await due to these two keywords. Async functions
    are based on Promises and therefore also asynchronous functions (which is somewhat
    confusing).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That being said: These two terms are also often used interchangeably.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Fetch API via async functions**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/async-functions/fetch_json2_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[44.2 What values can be used with `await`?](#what-values-can-be-used-with-await)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `await` operator can only be used inside async functions and async generators
    (which are explained in [“Asynchronous generators” (§45.2)](ch_async-iteration.html#async-generators)).
    Its operand is usually a Promise and leads to the following steps being performed:'
  prefs: []
  type: TYPE_NORMAL
- en: The current async function is paused.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When and if the Promise is settled, the async function is resumed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the Promise is fulfilled, `await` returns the fulfillment value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the Promise is rejected, `await` throws the rejection value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on what exactly pausing and resuming means, see [“Async
    functions start synchronously, settle asynchronously” (§44.5)](#async-funcs-start-sync-settle-async).
  prefs: []
  type: TYPE_NORMAL
- en: Read on to find out how `await` handles various values.
  prefs: []
  type: TYPE_NORMAL
- en: '[44.2.1 Awaiting fulfilled Promises](#awaiting-fulfilled-promises)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If its operand is a fulfilled Promise, `await` returns its fulfillment value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of `await` is delivered asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In line A, we can’t use `setTimeout()`. We have to use `queueMicrotask()` because
    Promise-related tasks are so-called *microtasks* which are different from normal
    tasks and always handled before them (via a *microtask queue*). For more information,
    see the MDN article [“In depth: Microtasks and the JavaScript runtime environment”](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth).'
  prefs: []
  type: TYPE_NORMAL
- en: '[44.2.2 Awaiting rejected Promises](#awaiting-rejected-promises)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If its operand is a rejected Promise, then `await` throws the rejection value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[44.2.3 Awaiting non-Promise values](#awaiting-nonpromise-values)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Non-Promise values can also be awaited and are simply passed on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Even in this case, the result of `await` is delivered asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[44.3 Where can `await` be used?](#where-can-await-be-used)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[44.3.1 Using `await` at the top levels of modules ^(ES2022)](#using-await-at-the-top-levels-of-modules-es2022)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can use `await` at the top levels of modules – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For more information on this feature, see [“Top-level `await` in modules ^(ES2022)
    (advanced)” (§29.15)](ch_modules.html#top-level-await).
  prefs: []
  type: TYPE_NORMAL
- en: '[44.3.2 Awaiting is shallow](#awaiting-is-shallow)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we are inside an async function and want to pause it via `await`, we must
    do so directly within that function; we can’t use it inside a nested function,
    such as a callback. That is, pausing is *shallow*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine what that means. In the following code, we try to await inside
    a nested function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: However, that isn’t even valid syntax because `await` is not allowed inside
    synchronous functions such as `nestedFunc()`. What happens if we make `nestedFunc()`
    an async function?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This time, the `await` in line A pauses `nestedFunc()`, not `f()`. `nestedFunc()`
    returns a Promise, which is wrapped in an Array in line B. Note [the top-level
    `await`](ch_modules.html#top-level-await) in line C.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this code work, we must await the result of `nestedFunc()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To summarize: `await` only affects the immediately surrounding function (which
    must be an async function).'
  prefs: []
  type: TYPE_NORMAL
- en: '[44.3.3 Example: `.map()` with an async function as a callback](#map-with-async-callback)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What happens if we use an async function as a callback for `.map()`? Then the
    result is an Array of Promises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use [`Promise.all()`](ch_promises.html#Promise.all) to convert that
    Array of Promises to a Promise for an Array and await that Promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We use that technique in the following code, which downloads files via [`fetch()`](ch_promises.html#fetch-api).
    The content of each file is its filename.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Mapping and filtering asynchronously**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/async-functions/map_async_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[44.4 `return` in async functions](#return-in-async-functions)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[44.4.1 The result of an async function is always a Promise](#the-result-of-an-async-function-is-always-a-promise)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we call an async function, the result is always a Promise – even if the
    async function throws an exception. Inside the async function, we can fulfill
    the result Promise by returning non-Promise values (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, if we don’t explicitly return anything, `undefined` is returned for
    us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We reject the result Promise via `throw` (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[44.4.2 Returning a Promise resolves the result Promise](#returning-a-promise-resolves-the-result-promise)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we return a Promise `q` then it resolves the result Promise `p` of the async
    function: `p` adopts the state of `q` (`q` basically replaces `p`). Resolving
    never nests Promises.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning a fulfilled Promise fulfills the result Promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Returning a rejected Promise has the same effect as throwing an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The behavior of `return` is similar to how a Promise `q` is treated in the
    following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`return q` inside `promise.then((result) => { ··· })`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return q` inside `promise.catch((err) => { ··· })`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resolve(q)` inside `new Promise((resolve, reject) => { ··· })`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[44.5 Async functions start synchronously, settle asynchronously](#async-funcs-start-sync-settle-async)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Async functions are executed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The Promise `resultPromise` for the result is created when the async function
    is started.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then the body is executed. There are two ways in which execution can leave
    the body:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A permanent exit** happens when `resultPromise` is settled:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return` resolves `resultPromise`.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`throw` rejects `resultPromise`.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A temporary exit** happens when there is an `await` whose operand is a Promise
    `p`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The async function is paused and execution leaves it (similarly to how `yield`
    works in [sync generators](ch_sync-generators.html#ch_sync-generators)).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is resumed asynchronously (in a new task) once `p` is settled.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Promise `resultPromise` is returned after the first (permanent or temporary)
    exit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the notification of the settlement of `resultPromise` happens asynchronously,
    as is always the case with Promises.
  prefs: []
  type: TYPE_NORMAL
- en: The following code demonstrates that an async function is started synchronously
    (line A), then the current task finishes (line C), then the result Promise is
    settled – asynchronously (line B).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[44.6 Tips for using async functions](#tips-for-using-async-functions)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[44.6.1 We don’t need `await` if we “fire and forget”](#fire-and-forget-await)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`await` is not required when working with a Promise-based function; we only
    need it if we want to pause and wait until the returned Promise is settled. If
    we only want to start an asynchronous operation, then we don’t need it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we don’t await `.write()` because we don’t care when it is finished.
    We do, however, want to wait until `.close()` is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: Each invocation of `.write()` starts synchronously. That prevents race
    conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[44.6.2 It can make sense to `await` and ignore the result](#it-can-make-sense-to-await-and-ignore-the-result)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It can occasionally make sense to use `await`, even if we ignore its result
    – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using `await` to join a long-running asynchronous operation. That
    ensures that the logging really happens *after* that operation is done.
  prefs: []
  type: TYPE_NORMAL
- en: '[44.6.3 The pros and cons of `return await`](#return-await)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we await a Promise before returning it, we unwrap it before immediately
    wrapping it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `return` resolves the result Promise of `f()`, the following code is
    simpler and equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'There are, however, three reasons to stick with `return await`:'
  prefs: []
  type: TYPE_NORMAL
- en: The code fragment is easier to move around.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We don’t depend on a feature of Promises that is slightly obscure: resolving
    unwraps Promises.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It behaves better inside a `try-catch` statement (see below).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s explore the last reason. If we await the rejected Promise in line A before
    returning it, it causes an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If, on the other hand, we return without `await`, no exception is thrown and
    the result Promise of `f()` adopts the state of the rejected Promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[44.7 Concurrency and `await` (advanced)](#concurrency-and-await)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the next two subsections, we’ll use the helper function `returnAfterPause()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[44.7.1 `await`: running Promise-based functions sequentially](#await-sequentially)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we prefix the invocations of multiple Promise-based functions with `await`,
    then those functions are executed sequentially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: That is, `returnAfterPause('second')` is only started after `returnAfterPause('first')`
    is completely finished.
  prefs: []
  type: TYPE_NORMAL
- en: '[44.7.2 `await`: running Promise-based functions concurrently](#await-concurrently)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we want to run multiple Promise-based functions concurrently, we can use
    the utility method `Promise.all()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, both asynchronous functions are started at the same time. Once both are
    settled, `await` gives us either an Array of fulfillment values or – if at least
    one Promise is rejected – an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall from [earlier](ch_promises.html#focus-on-async-start) that what counts
    is when we start a Promise-based computation; not how we process its result. Therefore,
    the following code is as “concurrent” as the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
