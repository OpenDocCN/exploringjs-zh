- en: 40 Destructuring ES6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_destructuring.html](https://exploringjs.com/js/book/ch_destructuring.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[40.1 A first taste of destructuring](#a-first-taste-of-destructuring)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.2 Constructing vs. extracting](#constructing-vs-extracting)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.3 Where can we destructure?](#destructuring-locations)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.4 Object-destructuring](#object-destructuring)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.4.1 Property value shorthands](#property-value-shorthands)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.4.2 Rest properties](#rest-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.4.3 Syntax pitfall: assigning via object destructuring](#assigning-via-object-destructuring)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.5 Array-destructuring](#array-destructuring)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.5.1 Array-destructuring works with any iterable](#arraydestructuring-works-with-any-iterable)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.5.2 Rest elements](#rest-elements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.6 Examples of destructuring](#examples-of-destructuring)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.6.1 Array-destructuring: swapping variable values](#arraydestructuring-swapping-variable-values)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.6.2 Array-destructuring: operations that return Arrays](#arraydestructuring-operations-that-return-arrays)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.6.3 Object-destructuring: multiple return values](#objectdestructuring-multiple-return-values)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.7 What happens if a pattern part does not match anything?](#what-happens-if-a-pattern-part-does-not-match-anything)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.7.1 Object-destructuring and missing properties](#objectdestructuring-and-missing-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.7.2 Array-destructuring and missing elements](#arraydestructuring-and-missing-elements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.8 What values can’t be destructured?](#what-values-cant-be-destructured)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.8.1 We can’t object-destructure `undefined` and `null`](#values-that-cannot-be-object-destructured)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.8.2 We can’t Array-destructure non-iterable values](#values-that-cannot-be-array-destructured)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.9 (Advanced)](#advanced-3)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.10 Default values](#default-values)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.10.1 Default values in Array-destructuring](#default-values-in-arraydestructuring)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.10.2 Default values in object-destructuring](#default-values-in-objectdestructuring)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.11 Parameter definitions are similar to destructuring](#parameter-definitions-are-similar-to-destructuring)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.12 Nested destructuring](#nested-destructuring)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.1 A first taste of destructuring](#a-first-taste-of-destructuring)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With normal assignment, we extract one piece of data at a time – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With destructuring, we can extract multiple pieces of data at the same time
    via patterns in locations that receive data. The left-hand side of `=` in the
    previous code is one such location. In the following code, the square brackets
    in line A are a destructuring pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code does the same as the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the pattern is “smaller” than the data: we are only extracting what
    we need.'
  prefs: []
  type: TYPE_NORMAL
- en: '[40.2 Constructing vs. extracting](#constructing-vs-extracting)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to understand what destructuring is, consider that JavaScript has
    two kinds of operations that are opposites:'
  prefs: []
  type: TYPE_NORMAL
- en: We can *construct* compound data, for example, by setting properties and via
    object literals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can *extract* data out of compound data, for example, by getting properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Constructing data looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Extracting data looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The operation in line A is new: we declare two variables `f2` and `l2` and
    initialize them via *destructuring* (multivalue extraction).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following part of line A is a *destructuring pattern*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Destructuring patterns are syntactically similar to the literals that are used
    for multivalue construction. But they appear where data is received (e.g., at
    the left-hand sides of assignments), not where data is created (e.g., at the right-hand
    sides of assignments).
  prefs: []
  type: TYPE_NORMAL
- en: '[40.3 Where can we destructure?](#destructuring-locations)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Destructuring patterns can be used at “data sink locations” such as:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Variable declarations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assignments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Parameter definitions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that variable declarations include `const` and `let` declarations in `for-of`
    loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next two sections, we’ll look deeper into the two kinds of destructuring:
    object-destructuring and Array-destructuring.'
  prefs: []
  type: TYPE_NORMAL
- en: '[40.4 Object-destructuring](#object-destructuring)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Object-destructuring* lets us batch-extract values of properties via patterns
    that look like object literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can think of the pattern as a transparent sheet that we place over the data:
    the pattern key `''street''` has a match in the data. Therefore, the data value
    `''Evergreen Terrace''` is assigned to the pattern variable `s`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also object-destructure primitive values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can object-destructure Arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Why does that work? [Array indices are also properties](ch_arrays.html#array-indices).
  prefs: []
  type: TYPE_NORMAL
- en: '[40.4.1 Property value shorthands](#property-value-shorthands)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Object literals support property value shorthands and so do object patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Object-destructuring**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/destructuring/object_destructuring_exrc.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[40.4.2 Rest properties](#rest-properties)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In object literals, we can have spread properties. In object patterns, we can
    have rest properties (which must come last):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: A rest property variable, such as `remaining` (line A), is assigned an object
    with all data properties whose keys are not mentioned in the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '`remaining` can also be viewed as the result of non-destructively removing
    property `a` from `obj`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[40.4.3 Syntax pitfall: assigning via object destructuring](#assigning-via-object-destructuring)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we object-destructure in an assignment, we are facing a pitfall caused by
    [syntactic ambiguity](ch_syntax.html#ambiguous-syntax) – we can’t start a statement
    with a curly brace because then JavaScript thinks we are starting a block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **Why `eval()`?**'
  prefs: []
  type: TYPE_NORMAL
- en: '[`eval()`](ch_dynamic-code-evaluation.html#eval) delays parsing (and therefore
    the `SyntaxError`) until the callback of `assert.throws()` is executed. If we
    didn’t use it, we’d already get an error when this code is parsed and `assert.throws()`
    wouldn’t even be executed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The workaround is to put the whole assignment in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[40.5 Array-destructuring](#array-destructuring)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Array-destructuring* lets us batch-extract values of Array elements via patterns
    that look like Array literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can skip elements by putting holes in Array patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The Array pattern in line A starts with a hole, which is why the Array element
    at index 0 is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: '[40.5.1 Array-destructuring works with any iterable](#arraydestructuring-works-with-any-iterable)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Array-destructuring can be applied to any value that is iterable, not just
    to Arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[40.5.2 Rest elements](#rest-elements)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In Array literals, we can have spread elements. In Array patterns, we can have
    rest elements (which must come last):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: A rest element variable, such as `remaining` (line A), is assigned an Array
    with all elements of the destructured value that were not mentioned yet.
  prefs: []
  type: TYPE_NORMAL
- en: '[40.6 Examples of destructuring](#examples-of-destructuring)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[40.6.1 Array-destructuring: swapping variable values](#arraydestructuring-swapping-variable-values)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can use Array-destructuring to swap the values of two variables without
    needing a temporary variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[40.6.2 Array-destructuring: operations that return Arrays](#arraydestructuring-operations-that-return-arrays)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Array-destructuring is useful when operations return Arrays, as does, for example,
    the regular expression method `.exec()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[40.6.3 Object-destructuring: multiple return values](#objectdestructuring-multiple-return-values)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Destructuring is very useful if a function returns multiple values – either
    packaged as an Array or packaged as an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a function `findElement()` that finds elements in an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Its second parameter is a function that receives the value and index of an element
    and returns a boolean indicating if this is the element the caller is looking
    for.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now faced with a dilemma: Should `findElement()` return the value of
    the element it found or the index? One solution would be to create two separate
    functions, but that would result in duplicated code because both functions would
    be very similar.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following implementation avoids duplication by returning an object that
    contains both index and value of the element that is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Destructuring helps us with processing the result of `findElement()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are working with property keys, the order in which we mention `value`
    and `index` doesn’t matter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The kicker is that destructuring also serves us well if we are only interested
    in one of the two results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: All of these conveniences combined make this way of handling multiple return
    values quite versatile.
  prefs: []
  type: TYPE_NORMAL
- en: '[40.7 What happens if a pattern part does not match anything?](#what-happens-if-a-pattern-part-does-not-match-anything)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What happens if there is no match for part of a pattern? The same thing that
    happens if we use non-batch operators: We get `undefined`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[40.7.1 Object-destructuring and missing properties](#objectdestructuring-and-missing-properties)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a property in an object pattern has no match on the right-hand side, we
    get `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[40.7.2 Array-destructuring and missing elements](#arraydestructuring-and-missing-elements)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If an element in an Array pattern has no match on the right-hand side, we get
    `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[40.8 What values can’t be destructured?](#what-values-cant-be-destructured)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[40.8.1 We can’t object-destructure `undefined` and `null`](#values-that-cannot-be-object-destructured)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Object-destructuring only fails if the value to be destructured is either `undefined`
    or `null`. That is, it fails whenever accessing a property via the dot operator
    would fail too.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, destructuring a value with an empty object pattern means “throw
    an exception if the value is `undefined` or `null`”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[40.8.2 We can’t Array-destructure non-iterable values](#values-that-cannot-be-array-destructured)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Array-destructuring demands that the destructured value be iterable. Therefore,
    we can’t Array-destructure `undefined` and `null`. But we can’t Array-destructure
    non-iterable primitives and objects either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, destructuring a value with an empty Array pattern means “throw an
    exception if the value is not iterable”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[40.9 (Advanced)](#advanced-3)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of the remaining sections are advanced.
  prefs: []
  type: TYPE_NORMAL
- en: '[40.10 Default values](#default-values)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Normally, if a pattern has no match, the corresponding variable is set to `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want a different value to be used, we need to specify a *default value*
    (via `=`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In line A, we specify the default value for `p` to be `123`. That default is
    used because the data that we are destructuring has no property named `prop`.
  prefs: []
  type: TYPE_NORMAL
- en: '[40.10.1 Default values in Array-destructuring](#default-values-in-arraydestructuring)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here, we have two default values that are assigned to the variables `x` and
    `y` because the corresponding elements don’t exist in the Array that is destructured.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The default value for the first element of the Array pattern is `1`; the default
    value for the second element is `2`.
  prefs: []
  type: TYPE_NORMAL
- en: '[40.10.2 Default values in object-destructuring](#default-values-in-objectdestructuring)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can also specify default values for object-destructuring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Neither property key `first` nor property key `last` exist in the object that
    is destructured. Therefore, the default values are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'With property value shorthands, this code becomes simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[40.11 Parameter definitions are similar to destructuring](#parameter-definitions-are-similar-to-destructuring)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Considering what we have learned in this chapter, parameter definitions have
    much in common with an Array pattern (rest elements, default values, etc.). In
    fact, the following two function declarations are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[40.12 Nested destructuring](#nested-destructuring)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Until now, we have only used variables as *assignment targets* (data sinks)
    inside destructuring patterns. But we can also use patterns as assignment targets,
    which enables us to nest patterns to arbitrary depths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Inside the Array pattern in line A, there is a nested object pattern at index
    1.
  prefs: []
  type: TYPE_NORMAL
- en: Nested patterns can become difficult to understand, so they are best used in
    moderation.
  prefs: []
  type: TYPE_NORMAL
