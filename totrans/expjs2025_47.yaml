- en: 40 Destructuring ES6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_destructuring.html](https://exploringjs.com/js/book/ch_destructuring.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[40.1 A first taste of destructuring](#a-first-taste-of-destructuring)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.2 Constructing vs. extracting](#constructing-vs-extracting)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.3 Where can we destructure?](#destructuring-locations)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.4 Object-destructuring](#object-destructuring)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.4.1 Property value shorthands](#property-value-shorthands)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.4.2 Rest properties](#rest-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.4.3 Syntax pitfall: assigning via object destructuring](#assigning-via-object-destructuring)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.5 Array-destructuring](#array-destructuring)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.5.1 Array-destructuring works with any iterable](#arraydestructuring-works-with-any-iterable)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.5.2 Rest elements](#rest-elements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.6 Examples of destructuring](#examples-of-destructuring)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.6.1 Array-destructuring: swapping variable values](#arraydestructuring-swapping-variable-values)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.6.2 Array-destructuring: operations that return Arrays](#arraydestructuring-operations-that-return-arrays)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.6.3 Object-destructuring: multiple return values](#objectdestructuring-multiple-return-values)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.7 What happens if a pattern part does not match anything?](#what-happens-if-a-pattern-part-does-not-match-anything)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.7.1 Object-destructuring and missing properties](#objectdestructuring-and-missing-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.7.2 Array-destructuring and missing elements](#arraydestructuring-and-missing-elements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.8 What values can’t be destructured?](#what-values-cant-be-destructured)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.8.1 We can’t object-destructure `undefined` and `null`](#values-that-cannot-be-object-destructured)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.8.2 We can’t Array-destructure non-iterable values](#values-that-cannot-be-array-destructured)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.9 (Advanced)](#advanced-3)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.10 Default values](#default-values)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.10.1 Default values in Array-destructuring](#default-values-in-arraydestructuring)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.10.2 Default values in object-destructuring](#default-values-in-objectdestructuring)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.11 Parameter definitions are similar to destructuring](#parameter-definitions-are-similar-to-destructuring)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.12 Nested destructuring](#nested-destructuring)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[40.1 A first taste of destructuring](#a-first-taste-of-destructuring)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With normal assignment, we extract one piece of data at a time – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With destructuring, we can extract multiple pieces of data at the same time
    via patterns in locations that receive data. The left-hand side of `=` in the
    previous code is one such location. In the following code, the square brackets
    in line A are a destructuring pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code does the same as the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the pattern is “smaller” than the data: we are only extracting what
    we need.'
  prefs: []
  type: TYPE_NORMAL
- en: '[40.2 Constructing vs. extracting](#constructing-vs-extracting)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to understand what destructuring is, consider that JavaScript has
    two kinds of operations that are opposites:'
  prefs: []
  type: TYPE_NORMAL
- en: We can *construct* compound data, for example, by setting properties and via
    object literals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can *extract* data out of compound data, for example, by getting properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Constructing data looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3][PRE4][PRE5]`` [PRE6][PRE7][PRE8]` Extracting data looks as follows:    [PRE9]   [PRE10][PRE11][PRE12]
    [PRE13]`js[PRE14]`js[PRE15]js[PRE16][PRE17][PRE18]js let prop; assert.throws(  ()
    => eval("{prop} = { prop: ''hello'' };"),  {  name: ''SyntaxError'',  message:
    "Unexpected token ''=''",  });  [PRE19]js let prop; ({prop} = { prop: ''hello''
    }); assert.equal(prop, ''hello'');  [PRE20]js const [x, y] = [''a'', ''b'']; assert.equal(x,
    ''a''); assert.equal(y, ''b'');  [PRE21]js const [, x, y] = [''a'', ''b'', ''c''];
    // (A) assert.equal(x, ''b''); assert.equal(y, ''c'');  [PRE22]js { // Sets are
    iterable  const [a, b] = new Set().add(''fee'').add(''fi'').add(''fo'');  assert.equal(a,
    ''fee'');  assert.equal(b, ''fi''); }  `{ // Maps are iterable`  `const [a, b]
    = new Map().set(''one'', 1).set(''two'', 2);`  `assert.deepEqual(`  `a, [''one'',1]`  `);`  `assert.deepEqual(`  `b,
    [''two'',2]`  `);` `}`  `` `{ // Strings are iterable`  `const [a, b] = ''hello'';`  `assert.equal(a,
    ''h'');`  `assert.equal(b, ''e'');` `}` ``  [PRE23]js[PRE24]js[PRE25][PRE26] A
    rest element variable, such as `remaining` (line A), is assigned an Array with
    all elements of the destructured value that were not mentioned yet.    ### [40.6 Examples
    of destructuring](#examples-of-destructuring)    #### [40.6.1 Array-destructuring:
    swapping variable values](#arraydestructuring-swapping-variable-values)    We
    can use Array-destructuring to swap the values of two variables without needing
    a temporary variable:    [PRE27]js   [PRE28] [PRE29][PRE30]``js[PRE31]`` As we
    are working with property keys, the order in which we mention `value` and `index`
    doesn’t matter:    [PRE32]    The kicker is that destructuring also serves us
    well if we are only interested in one of the two results:    [PRE33]   [PRE34]``
    [PRE35]` All of these conveniences combined make this way of handling multiple
    return values quite versatile.    ### [40.7 What happens if a pattern part does
    not match anything?](#what-happens-if-a-pattern-part-does-not-match-anything)    What
    happens if there is no match for part of a pattern? The same thing that happens
    if we use non-batch operators: We get `undefined`.    #### [40.7.1 Object-destructuring
    and missing properties](#objectdestructuring-and-missing-properties)    If a property
    in an object pattern has no match on the right-hand side, we get `undefined`:    [PRE36]    ####
    [40.7.2 Array-destructuring and missing elements](#arraydestructuring-and-missing-elements)    If
    an element in an Array pattern has no match on the right-hand side, we get `undefined`:    [PRE37]    ###
    [40.8 What values can’t be destructured?](#what-values-cant-be-destructured)    ####
    [40.8.1 We can’t object-destructure `undefined` and `null`](#values-that-cannot-be-object-destructured)    Object-destructuring
    only fails if the value to be destructured is either `undefined` or `null`. That
    is, it fails whenever accessing a property via the dot operator would fail too.    [PRE38]   [PRE39]
    Therefore, destructuring a value with an empty object pattern means “throw an
    exception if the value is `undefined` or `null`”:    [PRE40]js    #### [40.8.2 We
    can’t Array-destructure non-iterable values](#values-that-cannot-be-array-destructured)    Array-destructuring
    demands that the destructured value be iterable. Therefore, we can’t Array-destructure
    `undefined` and `null`. But we can’t Array-destructure non-iterable primitives
    and objects either:    [PRE41]js    Therefore, destructuring a value with an empty
    Array pattern means “throw an exception if the value is not iterable”:    [PRE42]js    ###
    [40.9 (Advanced)](#advanced-3)    All of the remaining sections are advanced.    ###
    [40.10 Default values](#default-values)    Normally, if a pattern has no match,
    the corresponding variable is set to `undefined`:    [PRE43]js    If we want a
    different value to be used, we need to specify a *default value* (via `=`):    [PRE44]js    In
    line A, we specify the default value for `p` to be `123`. That default is used
    because the data that we are destructuring has no property named `prop`.    ####
    [40.10.1 Default values in Array-destructuring](#default-values-in-arraydestructuring)    Here,
    we have two default values that are assigned to the variables `x` and `y` because
    the corresponding elements don’t exist in the Array that is destructured.    [PRE45]js   [PRE46]`js
    [PRE47]js`` [PRE48]js[PRE49][PRE50][PRE51][PRE52]js[PRE53]js` [PRE54]`js`` [PRE55]`js[PRE56][PRE57][PRE58]
    [PRE59][PRE60][PRE61][PRE62][PRE63]`` [PRE64][PRE65][PRE66] [PRE67]`js[PRE68]js[PRE69]'
  prefs: []
  type: TYPE_NORMAL
