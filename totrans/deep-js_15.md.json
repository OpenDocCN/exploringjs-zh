["```js\nobj.prop = value\n```", "```js\nObject.defineProperty(obj, propKey, propDesc)\n```", "```js\nOrdinarySetWithOwnDescriptor(O, P, V, Receiver, ownDesc)\n```", "```js\n        {\n          [[Value]]: undefined, [[Writable]]: true,\n          [[Enumerable]]: true, [[Configurable]]: true\n        }\n        ```", "```js\nValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current)\n```", "```js\nconst obj = {};\nobj.dataProp = 'abc';\nassert.deepEqual(\n Object.getOwnPropertyDescriptor(obj, 'dataProp'),\n {\n value: 'abc',\n writable: true,\n enumerable: true,\n configurable: true,\n });\n```", "```js\nconst proto = { prop: 'a' };\nconst obj = Object.create(proto);\n```", "```js\nassert.deepEqual(\n Object.keys(obj), []);\n\nobj.prop = 'b';\n\n// The assignment worked:\nassert.equal(obj.prop, 'b');\n\n// But we created an own property and overrode proto.prop,\n// we did not change it:\nassert.deepEqual(\n Object.keys(obj), ['prop']);\nassert.equal(proto.prop, 'a');\n```", "```js\nlet setterWasCalled = false;\nconst proto = {\n get prop() {\n return 'protoGetter';\n },\n set prop(x) {\n setterWasCalled = true;\n },\n};\nconst obj = Object.create(proto);\n\nassert.equal(obj.prop, 'protoGetter');\n\n// Defining obj.prop:\nObject.defineProperty(\n obj, 'prop', { value: 'objData' });\nassert.equal(setterWasCalled, false);\n\n// We have overridden the getter:\nassert.equal(obj.prop, 'objData');\n```", "```js\nlet setterWasCalled = false;\nconst proto = {\n get prop() {\n return 'protoGetter';\n },\n set prop(x) {\n setterWasCalled = true;\n },\n};\nconst obj = Object.create(proto);\n\nassert.equal(obj.prop, 'protoGetter');\n\n// Assigning to obj.prop:\nobj.prop = 'objData';\nassert.equal(setterWasCalled, true);\n\n// The getter still active:\nassert.equal(obj.prop, 'protoGetter');\n```", "```js\nconst proto = Object.defineProperty(\n {}, 'prop', {\n value: 'protoValue',\n writable: false,\n });\n```", "```js\nconst obj = Object.create(proto);\nassert.throws(\n () => obj.prop = 'objValue',\n /^TypeError: Cannot assign to read only property 'prop'/);\n```", "```js\nObject.defineProperty(\n obj, 'prop', { value: 'objValue' });\nassert.equal(obj.prop, 'objValue');\n```", "```js\nconst proto = {\n get prop() {\n return 'protoValue';\n }\n};\nconst obj = Object.create(proto);\nassert.throws(\n () => obj.prop = 'objValue',\n /^TypeError: Cannot set property prop of #<Object> which has only a getter$/);\n```", "```js\nlet lastSetterArgument;\nconst proto = {\n set prop(x) {\n lastSetterArgument = x;\n },\n};\nconst obj = {\n __proto__: proto,\n prop: 'abc',\n};\nassert.equal(lastSetterArgument, undefined);\n```", "```js\nlet lastSetterArgument;\nconst proto = {\n set prop(x) {\n lastSetterArgument = x;\n },\n};\nconst obj = Object.create(proto);\n\n// Normal assignment:\nobj.prop = 'abc';\nassert.equal(lastSetterArgument, 'abc');\n\n// Assigning via destructuring:\n[obj.prop] = ['def'];\nassert.equal(lastSetterArgument, 'def');\n```", "```js\nlet lastSetterArgument1;\nlet lastSetterArgument2;\nclass A {\n set prop1(x) {\n lastSetterArgument1 = x;\n }\n set prop2(x) {\n lastSetterArgument2 = x;\n }\n}\nclass B extends A {\n prop1 = 'one';\n constructor() {\n super();\n this.prop2 = 'two';\n }\n}\nnew B();\n\n// The public class field uses definition:\nassert.equal(lastSetterArgument1, undefined);\n// Inside the constructor, we trigger assignment:\nassert.equal(lastSetterArgument2, 'two');\n```"]