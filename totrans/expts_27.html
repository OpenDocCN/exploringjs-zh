<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>22 Class-related types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>22 Class-related types</h1>
<blockquote>原文：<a href="https://exploringjs.com/ts/book/ch_class-related-types.html">https://exploringjs.com/ts/book/ch_class-related-types.html</a></blockquote>

    
        <div id="adbox">
      <div id="adbox-explain">(Ad, please don’t block.)</div>
              
          </div>
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#the-two-prototype-chains-of-classes">22.1 The two prototype chains of classes</a>
    </li>
    <li>
      <a href="#interfaces-for-instances-of-classes">22.2 Interfaces for instances of classes</a>
    </li>
    <li>
      <a href="#interfaces-for-classes">22.3 Interfaces for classes</a>
      <ol>
        <li>
          <a href="#example-converting-from-and-to-json">22.3.1 Example: converting from and to JSON</a>
        </li>
        <li>
          <a href="#example-typescript-s-built-in-interfaces-for-the-class-object-and-for-its-instances">22.3.2 Example: TypeScript’s built-in interfaces for the class <code>Object</code> and for its instances</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#classes-as-types">22.4 Classes as types</a>
      <ol>
        <li>
          <a href="#pitfall-classes-work-structurally-not-nominally">22.4.1 Pitfall: classes work structurally, not nominally</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#further-reading-7">22.5 Further reading</a>
    </li>
  </ol>
</nav>
<p>In this chapter, we examine types related to classes and their instances.</p>
<h3 id="the-two-prototype-chains-of-classes"><a class="heading-id-link" href="#the-two-prototype-chains-of-classes">22.1 The two prototype chains of classes</a></h3>
<p>Consider this class:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Object</span> {</code>
<code>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">createZero</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>(<span class="hljs-number">0</span>);</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">  <span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>;</span></code>
<code><span class="hljs-params">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value: <span class="hljs-built_in">number</span></span>) {</span></code>
<code><span class="hljs-params">    <span class="hljs-variable language_">super</span>();</span></code>
<code><span class="hljs-params">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">  <span class="hljs-title function_">increment</span>(<span class="hljs-params"/>) {</span></code>
<code><span class="hljs-params">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">}</span></code>
<code><span class="hljs-params"><span class="hljs-comment">// Static method</span></span></code>
<code><span class="hljs-params"><span class="hljs-keyword">const</span> myCounter = <span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">createZero</span>();</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">ok</span>(myCounter <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Counter</span>);</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(myCounter.<span class="hljs-property">value</span>, <span class="hljs-number">0</span>);</span></code>
<code/>
<code><span class="hljs-params"><span class="hljs-comment">// Instance method</span></span></code>
<code><span class="hljs-params">myCounter.<span class="hljs-title function_">increment</span>();</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(myCounter.<span class="hljs-property">value</span>, <span class="hljs-number">1</span>);</span></code>
</pre>
<figure id="fig:diagram-class-counter" class="float">
  <p><img src="../Images/f0091b5ecd0cda2b8e4df5b426d81e52.png" width="355" height="259" alt="" data-original-src="https://exploringjs.com/ts/book/img/class-related-types/diagram-class-counter.svg"/></p>
  <figcaption>
    <p><span class="float-label">Figure 22.1:</span> Objects created by class <code>Counter</code>. Left-hand side: the class and its superclass <code>Object</code>. Right-hand side: The instance <code>myCounter</code>, the prototype properties of <code>Counter</code>, and the prototype methods of the superclass <code>Object</code>.</p>
  </figcaption>
</figure>
<p>The diagram in <a href="#fig:diagram-class-counter">figure 22.1</a> shows the runtime structure of class <code>Counter</code>. There are two prototype chains of objects in this diagram:</p>
<ul>
  <li>
    Class (left-hand side): The static prototype chain consists of the objects that make up class <code>Counter</code>. The prototype object of class <code>Counter</code> is its superclass, <code>Object</code>.
  </li>
  <li>
    Instance (right-hand side): The instance prototype chain consists of the objects that make up the instance <code>myCounter</code>. The chain starts with the instance <code>myCounter</code> and continues with <code>Counter.prototype</code> (which holds the prototype methods of class <code>Counter</code>) and <code>Object.prototype</code> (which holds the prototype methods of class <code>Object</code>).
  </li>
</ul>
<p>In this chapter, we’ll first explore instance objects and then classes as objects.</p>
<h3 id="interfaces-for-instances-of-classes"><a class="heading-id-link" href="#interfaces-for-instances-of-classes">22.2 Interfaces for instances of classes</a></h3>
<p>Interfaces specify services that objects provide. For example:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CountingService</span> {</code>
<code>  <span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>;</code>
<code>  <span class="hljs-title function_">increment</span>(): <span class="hljs-built_in">void</span>;</code>
<code>}</code>
</pre>
<p>TypeScript’s interfaces work <a href="ch_what-is-a-type.html#nominal-vs-structural-type-systems">structurally</a>: In order for an object to implement an interface, it only needs to have the right properties with the right types. We can see that in the following example:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">myCounter2</span>: <span class="hljs-title class_">CountingService</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>(<span class="hljs-number">3</span>);</code>
</pre>
<p>Structural interfaces are convenient because we can create interfaces even for objects that already exist (i.e., we can introduce them after the fact).</p>
<p>If we know ahead of time that an object must implement a given interface, it often makes sense to check early if it does, in order to avoid surprises later. We can do that for instances of classes via <code>implements</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CountingService</span> {</code>
<code>  <span class="hljs-comment">// ···</span></code>
<code>};</code>
</pre>
<p>Comments:</p>
<ul>
  <li>
    <p>We can <code>implement</code> any object type (not just interfaces).</p>
  </li>
  <li>
    <p>TypeScript does not distinguish between inherited properties (such as <code>.increment</code>) and own properties (such as <code>.value</code>).</p>
  </li>
</ul>
<ul>
  <li>
    As an aside, private properties are ignored by interfaces and can’t be specified via them. This is expected given that private data is for internal purposes only.
  </li>
</ul>
<h3 id="interfaces-for-classes"><a class="heading-id-link" href="#interfaces-for-classes">22.3 Interfaces for classes</a></h3>
<p>Classes themselves are also objects (functions). Therefore, we can use interfaces to specify their properties. The main use case here is describing factories for objects. The next section gives an example.</p>
<h4 id="example-converting-from-and-to-json"><a class="heading-id-link" href="#example-converting-from-and-to-json">22.3.1 Example: converting from and to JSON</a></h4>
<p>The following two interfaces can be used for classes that support their instances being converted from and to JSON:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// Converting JSON to instances</span></code>
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">JsonStatic</span> {</code>
<code>  <span class="hljs-title function_">fromJson</span>(<span class="hljs-attr">json</span>: <span class="hljs-built_in">unknown</span>): <span class="hljs-title class_">JsonInstance</span>;</code>
<code>}</code>
<code/>
<code><span class="hljs-comment">// Converting instances to JSON</span></code>
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">JsonInstance</span> {</code>
<code>  <span class="hljs-title function_">toJson</span>(): <span class="hljs-built_in">unknown</span>;</code>
<code>}</code>
</pre>
<p>We use these interfaces in the following code:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">JsonInstance</span> {</code>
<code>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">fromJson</span>(<span class="hljs-attr">json</span>: <span class="hljs-built_in">unknown</span>): <span class="hljs-title class_">Person</span> {</code>
<code>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> json !== <span class="hljs-string">'string'</span>) {</code>
<code>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>();</code>
<code>    }</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(json);</code>
<code>  }</code>
<code>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;</code>
<code>  }</code>
<code>  <span class="hljs-title function_">toJson</span>(): <span class="hljs-built_in">unknown</span> {</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;</code>
<code>  }</code>
<code>}</code>
</pre>
<p>This is how we can check right away if class <code>Person</code> (as an object) implements the interface <code>JsonStatic</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Assignable</span>&lt;<span class="hljs-title class_">JsonStatic</span>, <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Person</span>&gt;&gt;;</code>
</pre>
<p>If you don’t want to use a library (with the utility types <code>Assert</code> and <code>Assignable</code>) for this purpose, you can use the following pattern:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// Assign the class to a type-annotated variable</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">personImplementsJsonStatic</span>: <span class="hljs-title class_">JsonStatic</span> = <span class="hljs-title class_">Person</span>;</code>
</pre>
<p>The downside of this pattern is that it produces extra JavaScript code.</p>
<h5 id="can-we-do-better"><a class="heading-id-link" href="#can-we-do-better">22.3.1.1 Can we do better?</a></h5>
<p>It would be nice to avoid an external check – e.g., like this:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">implements</span> <span class="hljs-title class_">JsonInstance</span> {</code>
<code>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">fromJson</span>(<span class="hljs-attr">json</span>: <span class="hljs-built_in">unknown</span>): <span class="hljs-title class_">Person</span> { <span class="hljs-comment">// (A)</span></code>
<code>    <span class="hljs-comment">// ···</span></code>
<code>  }</code>
<code>  <span class="hljs-comment">// ···</span></code>
<code>} satisfies <span class="hljs-title class_">JsonStatic</span>; <span class="hljs-comment">// (B)</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// (C)</span></code>
</pre>
<p>In line B, we use <a href="ch_satisfies.html#ch_satisfies">the <code>satisfies</code> operator</a>, which enforces that the value <code>Person</code> is assignable to <code>JsonStatic</code> while preserving the type of that value. That is important because <code>Person</code> should not be limited to what’s defined in <code>JsonStatic</code>.</p>
<p>Alas, this alternative approach is even more verbose and doesn’t compile. One of the compiler errors is in line C:</p>
<blockquote>
  <p>Type alias 'Person' circularly references itself.</p>
</blockquote>
<p>Why? Type <code>Person</code> is mentioned in line A. Even if we rename the type <code>Person</code> to <code>TPerson</code>, that error doesn’t go away.</p>
<h4 id="example-typescript-s-built-in-interfaces-for-the-class-object-and-for-its-instances"><a class="heading-id-link" href="#example-typescript-s-built-in-interfaces-for-the-class-object-and-for-its-instances">22.3.2 Example: TypeScript’s built-in interfaces for the class <code>Object</code> and for its instances</a></h4>
<p>It is instructive to take a look at TypeScript’s built-in types:</p>
<p>On one hand, interface <code>ObjectConstructor</code> is for the class pointed to by the global variable <code>Object</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">declare</span> <span class="hljs-keyword">var</span> <span class="hljs-title class_">Object</span>: <span class="hljs-title class_">ObjectConstructor</span>;</code>
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ObjectConstructor</span> {</code>
<code>  <span class="hljs-comment">/** Invocation via `new` */</span></code>
<code>  <span class="hljs-title function_">new</span>(value?: <span class="hljs-built_in">any</span>): <span class="hljs-title class_">Object</span>; <span class="hljs-comment">// (A)</span></code>
<code>  <span class="hljs-comment">/** Invocation via function calls */</span></code>
<code>  (value?: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">any</span>;</code>
<code/>
<code>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">prototype</span>: <span class="hljs-title class_">Object</span>; <span class="hljs-comment">// (B)</span></code>
<code/>
<code>  <span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-attr">o</span>: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">any</span>;</code>
<code>  <span class="hljs-comment">// ···</span></code>
<code>}</code>
</pre>
<p>On the other hand, interface <code>Object</code> (which is mentioned in line A and line B) is for instances of <code>Object</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Object</span> {</code>
<code>  <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Function</span>;</code>
<code>  <span class="hljs-title function_">toString</span>(): <span class="hljs-built_in">string</span>;</code>
<code>  <span class="hljs-title function_">toLocaleString</span>(): <span class="hljs-built_in">string</span>;</code>
<code>  <span class="hljs-title function_">valueOf</span>(): <span class="hljs-title class_">Object</span>;</code>
<code>  <span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-attr">v</span>: <span class="hljs-title class_">PropertyKey</span>): <span class="hljs-built_in">boolean</span>;</code>
<code>  <span class="hljs-title function_">isPrototypeOf</span>(<span class="hljs-attr">v</span>: <span class="hljs-title class_">Object</span>): <span class="hljs-built_in">boolean</span>;</code>
<code>  <span class="hljs-title function_">propertyIsEnumerable</span>(<span class="hljs-attr">v</span>: <span class="hljs-title class_">PropertyKey</span>): <span class="hljs-built_in">boolean</span>;</code>
<code>}</code>
</pre>
<p>In other words – the name <code>Object</code> is used twice, at two different <a href="ch_typescript-essentials.html#language-levels">language levels</a>:</p>
<ul>
  <li>
    At the dynamic level, for a global variable.
  </li>
  <li>
    At the static level, for a type.
  </li>
</ul>
<h3 id="classes-as-types"><a class="heading-id-link" href="#classes-as-types">22.4 Classes as types</a></h3>
<p>Consider the following class:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> {</code>
<code>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;</code>
<code>  }</code>
<code>}</code>
</pre>
<p>This class definition creates two things.</p>
<p>First, a constructor function named <code>Color</code> (that can be invoked via <code>new</code>):</p>
<pre class="language-ts">
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Color</span>, <span class="hljs-string">'function'</span></code>
<code>);</code>
</pre>
<p>Second, an interface named <code>Color</code> that matches instances of <code>Color</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">green</span>: <span class="hljs-title class_">Color</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-string">'green'</span>);</code>
</pre>
<p>Here is proof that <code>Color</code> really is an interface:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">RgbColor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Color</span> {</code>
<code>  <span class="hljs-attr">rgbValue</span>: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>];</code>
<code>}</code>
</pre>
<h4 id="pitfall-classes-work-structurally-not-nominally"><a class="heading-id-link" href="#pitfall-classes-work-structurally-not-nominally">22.4.1 Pitfall: classes work structurally, not nominally</a></h4>
<p>There is one pitfall, though: Using <code>Color</code> as a static type is not a very strict check:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> {</code>
<code>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;</code>
<code>  }</code>
<code>}</code>
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {</code>
<code>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;</code>
<code>  }</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">person</span>: <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'Jane'</span>);</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">color</span>: <span class="hljs-title class_">Color</span> = person; <span class="hljs-comment">// (A)</span></code>
</pre>
<p>Why doesn’t TypeScript complain in line A? That’s due to <a href="ch_what-is-a-type.html#nominal-vs-structural-type-systems">structural typing</a>: Instances of <code>Person</code> and of <code>Color</code> have the same structure and are therefore statically compatible.</p>
<h5 id="switching-off-structural-typing"><a class="heading-id-link" href="#switching-off-structural-typing">22.4.1.1 Switching off structural typing</a></h5>
<p>We can turn <code>Color</code> into <a href="ch_what-is-a-type.html#nominal-vs-structural-type-systems">a nominal type</a> by adding a private field (or a <code>private</code> property):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> {</code>
<code>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;</code>
<code>  #isBranded = <span class="hljs-literal">true</span>;</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;</code>
<code>  }</code>
<code>}</code>
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {</code>
<code>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;</code>
<code>  #isBranded = <span class="hljs-literal">true</span>;</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;</code>
<code>  }</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">robin</span>: <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'Robin'</span>);</code>
<code><span class="hljs-comment">// @ts-expect-error: Type 'Person' is not assignable to type 'Color'.</span></code>
<code><span class="hljs-comment">// Property '#isBranded' in type 'Person' refers to a different member that</span></code>
<code><span class="hljs-comment">// cannot be accessed from within type 'Color'.</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">color</span>: <span class="hljs-title class_">Color</span> = robin;</code>
</pre>
<p>This way of switching off structural typing is called <em>branding</em>. Note that the private fields of <code>Color</code> and <code>Person</code> are incompatible even though they have the same name and the same type. That reflects how JavaScript works: We cannot access the private field of <code>Color</code> from <code>Person</code> and vice versa.</p>
<h5 id="use-case-for-branding-migrating-from-an-object-type-to-a-class"><a class="heading-id-link" href="#use-case-for-branding-migrating-from-an-object-type-to-a-class">22.4.1.2 Use case for branding: migrating from an object type to a class</a></h5>
<p>Let’s say we want to migrate the following code from the object type in line A to a class:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Person</span> = { <span class="hljs-comment">// (A)</span></code>
<code>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,</code>
<code>};</code>
<code/>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">storePerson</span>(<span class="hljs-params">person: Person</span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-comment">// ...</span></code>
<code>}</code>
<code/>
<code><span class="hljs-title function_">storePerson</span>({</code>
<code>  <span class="hljs-attr">name</span>: <span class="hljs-string">'Robin'</span>,</code>
<code>});</code>
</pre>
<p>In our first attempt, invoking <code>storePerson()</code> with an object literal still works:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {</code>
<code>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;</code>
<code>  }</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">storePerson</span>(<span class="hljs-params">person: Person</span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-comment">// ...</span></code>
<code>}</code>
<code/>
<code><span class="hljs-title function_">storePerson</span>({</code>
<code>  <span class="hljs-attr">name</span>: <span class="hljs-string">'Robin'</span>,</code>
<code>});</code>
</pre>
<p>Once we brand <code>Person</code>, we get a compiler error:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {</code>
<code>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;</code>
<code>  #isBranded = <span class="hljs-literal">true</span>;</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;</code>
<code>  }</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">storePerson</span>(<span class="hljs-params">person: Person</span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-comment">// ...</span></code>
<code>}</code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Argument of type '{ name: string; }' is not assignable</span></code>
<code><span class="hljs-comment">// to parameter of type 'Person'. Property '#isBranded' is missing in type</span></code>
<code><span class="hljs-comment">// '{ name: string; }' but required in type 'Person'.</span></code>
<code><span class="hljs-title function_">storePerson</span>({</code>
<code>  <span class="hljs-attr">name</span>: <span class="hljs-string">'Robin'</span>,</code>
<code>});</code>
</pre>
<p>This is how we fix the error:</p>
<pre class="language-ts">
<code><span class="hljs-title function_">storePerson</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'Robin'</span>)</code>
<code>);</code>
</pre>
<h3 id="further-reading-7"><a class="heading-id-link" href="#further-reading-7">22.5 Further reading</a></h3>
<ul>
  <li>
    <a href="https://exploringjs.com/js/book/ch_classes.html">Chapter “Classes”</a> in “Exploring JavaScript”
  </li>
</ul>

    
      
</body>
</html>