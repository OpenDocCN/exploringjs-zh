["```ts\nfunction greet(nameOpt: null | string): string {\n if (nameOpt === null) { // (A)\n assertType<null>(nameOpt); // (B)\n nameOpt = 'anonymous'; // (C)\n assertType<string>(nameOpt);\n } else {\n assertType<string>(nameOpt);\n }\n assertType<string>(nameOpt); // (D)\n return `Hello ${nameOpt}!`;\n}\n\n```", "```ts\nfunction getScore(value: number | string): number {\n if (typeof value === 'number') { // (A)\n assertType<number>(value);\n return value;\n }\n if (typeof value === 'string') { // (B)\n assertType<string>(value);\n return value.length;\n }\n throw new Error('Unexpected value: ' + value);\n}\n\nassert.equal(\n getScore('*****'), 5\n);\nassert.equal(\n getScore(3), 3\n);\n\n```", "```ts\n    function func1(arg: null | string) {}\n    function func2(arg: undefined | string) {}\n\n    ```", "```ts\n    type Teacher = { kind: 'Teacher', teacherId: string };\n    type Student = { kind: 'Student', studentId: string };\n    type Attendee = Teacher | Student;\n\n    function func3(attendee: Attendee) {}\n\n    ```", "```ts\n    function func4(arg?: string) {\n     assertType<string | undefined>(arg);\n    }\n\n    ```", "```ts\nfunction parseStringLiteral(stringLiteral: string): string {\n // We use `unknown` instead of the less-safe `any`\n const result: unknown = JSON.parse(stringLiteral);\n if (typeof result === 'string') { // (A)\n return result;\n }\n throw new Error('Not a string literal: ' + stringLiteral);\n}\n\n```", "```ts\nfunction f(value: null | string): void {\n if (value === null) {\n assertType<null>(value);\n } else {\n assertType<string>(value);\n }\n}\n\n```", "```ts\nfunction f(value: null | string): void {\n const result = value === null\n ? assertType<null>(value)\n : assertType<string>(value)\n ;\n}\n\n```", "```ts\nfunction f(value: null | string): void {\n switch (typeof value) {\n case 'object':\n assertType<null>(value);\n break;\n case 'string':\n assertType<string>(value);\n break;\n }\n}\n\n```", "```ts\nfunction f(value: null | string): void {\n if (value !== null && value.length > 0) {\n // ...\n }\n}\n\n```", "```ts\nfunction f(value: null | string): void {\n if (value === null || value.length > 0) {\n // ...\n }\n}\n\n```", "```ts\nfunction func(value: Function | Date | Array<number>): void {\n if (typeof value === 'function') {\n assertType<Function>(value);\n }\n\n if (value instanceof Date) {\n assertType<Date>(value);\n }\n\n if (Array.isArray(value)) {\n assertType<Array<number>>(value);\n }\n}\n\n```", "```ts\nfunction func(value: unknown): void {\n if (value === 'abc') {\n assertType<\"abc\">(value);\n }\n}\n\n```", "```ts\ninterface Book {\n title: null | string;\n isbn: string;\n}\n\nfunction getTitle(book: Book): string {\n if (book.title !== null) {\n assertType<string>(book.title);\n return book.title;\n }\n if (book.title === null) {\n assertType<null>(book.title);\n return '(Untitled)';\n }\n throw new Error();\n}\n\n```", "```ts\nfunction f(value: null | string): void {\n if (value) {\n assertType<string>(value);\n } else {\n assertType<null | string>(value); // (A)\n }\n}\n\n```", "```ts\nfunction f(value: null | string): void {\n if (value !== null) {\n assertType<string>(value);\n } else {\n assertType<null>(value);\n }\n}\n\n```", "```ts\nfunction f1(value: null | string): void {\n if (value && value.length > 0) {\n // ...\n }\n}\nfunction f2(value: null | string): void {\n if (!value || value.length > 0) {\n // ...\n }\n}\n\n```", "```ts\nfunction f(value: null | string): void {\n if (Boolean(value)) {\n assertType<null | string>(value); // (A)\n }\n}\n\n```", "```ts\nfunction f(value: null | string): void {\n if (!!value) {\n assertType<string>(value);\n }\n}\n\n```", "```ts\ntype FirstOrSecond =\n | {first: string}\n | {second: string}\n;\nfunction func(firstOrSecond: FirstOrSecond): void {\n if ('first' in firstOrSecond) {\n assertType<{ first: string }>(firstOrSecond);\n }\n}\n\n```", "```ts\nfunction func2(firstOrSecond: FirstOrSecond): void {\n // @ts-expect-error: Property 'first' does not exist on\n // type 'FirstOrSecond'. [...]\n if (firstOrSecond.first !== undefined) {\n // ···\n }\n}\n\n```", "```ts\nfunction func(obj: object): void {\n if ('name' in obj) {\n assertType<object & Record<'name', unknown>>(obj);\n const value = obj.name;\n assertType<unknown>(value);\n }\n}\n\n```", "```ts\ntype Teacher = { kind: 'Teacher', teacherId: string };\ntype Student = { kind: 'Student', studentId: string };\ntype Attendee = Teacher | Student;\n\nfunction getId(attendee: Attendee) {\n switch (attendee.kind) {\n case 'Teacher':\n assertType<{ kind: 'Teacher', teacherId: string }>(attendee);\n return attendee.teacherId;\n case 'Student':\n assertType<{ kind: 'Student', studentId: string }>(attendee);\n return attendee.studentId;\n default:\n throw new Error();\n }\n}\n\n```", "```ts\nfunction getId(attendee: Attendee) {\n if (attendee.kind === 'Teacher') {\n assertType<{ kind: 'Teacher', teacherId: string }>(attendee);\n return attendee.teacherId;\n } else if (attendee.kind === 'Student') {\n assertType<{ kind: 'Student', studentId: string }>(attendee);\n return attendee.studentId;\n } else {\n throw new Error();\n }\n}\n\n```", "```ts\nlet x: null | string;\ntype _1 = Assert<Equal<\n typeof x,\n null | string\n>>;\n\nx = 'a';\ntype _2 = Assert<Equal<\n typeof x,\n string\n>>;\n\nx = null;\ntype _3 = Assert<Equal<\n typeof x,\n null\n>>;\n\n// @ts-expect-error: Type 'number' is not assignable to type 'string'.\nx = 1;\n\n```", "```ts\nlet x; // implicitly has type `any`\ntype _1 = Assert<Equal<\n typeof x, // (A)\n undefined\n>>;\nx = 1;\ntype _2 = Assert<Equal<\n typeof x,\n number\n>>;\nx = 'a';\ntype _3 = Assert<Equal<\n typeof x,\n string\n>>;\nx = true;\ntype _4 = Assert<Equal<\n typeof x,\n boolean\n>>;\n\n```", "```ts\nlet x = 1;\ntype _ = Assert<Equal<\n typeof x,\n number\n>>;\n// @ts-expect-error: Type 'string' is not assignable to type 'number'.\nx = 'a';\n\n```", "```ts\ntype MyType = {\n prop?: number | string,\n};\nfunction func(arg: MyType): void {\n if (typeof arg.prop === 'string') {\n assertType<string>(arg.prop); // (A)\n\n [].forEach((x) => {\n assertType<string | number | undefined>(arg.prop); // (B)\n });\n\n assertType<string>(arg.prop);\n\n arg = {};\n assertType<string | number | undefined>(arg.prop); // (C)\n }\n}\n\n```", "```ts\nfunction f(mixedValues: Array<undefined | null | number>): void {\n if (mixedValues.every(x => x !== undefined && x !== null)) {\n assertType<Array<number>>(mixedValues);\n\n // @ts-expect-error: Argument of type 'null' is not assignable to\n // parameter of type 'number'.\n mixedValues.push(null); // (A)\n }\n}\n\n```", "```ts\nconst mixedValues = [1, undefined, 2, null];\nassertType<(number | null | undefined)[]>(mixedValues);\n\nconst numbers = mixedValues.filter(\n x => x !== undefined && x !== null\n);\nassertType<number[]>(numbers);\nassert.deepEqual(\n numbers,\n [1, 2]\n);\n\n```", "```ts\nfunction isFunction(value: unknown): value is Function {\n return typeof value === 'function';\n}\n\n```", "```ts\nassertType<(value: unknown) => value is Function>(isFunction);\n\n```", "```ts\nfunction func(arg: unknown): void {\n if (isFunction(arg)) {\n assertType<Function>(arg); // type is narrowed\n }\n}\n\n```", "```ts\nfunction isFunction(value: any): value is Function {\n try {\n value(); // (A)\n return true;\n } catch {\n return false;\n }\n}\n\n```", "```ts\nfunction isNonNullable<T>(value: T): value is NonNullable<T> {\n return value !== undefined && value !== null;\n}\nfunction f1(arg: null | string) {\n if (isNonNullable(arg)) {\n assertType<string>(arg);\n }\n}\nfunction f2(arg: undefined | string) {\n if (isNonNullable(arg)) {\n assertType<string>(arg);\n }\n}\n\n```", "```ts\ntype Class<T> = abstract new (...args: Array<any>) => T;\n\n```", "```ts\nfunction f1<T>(arr: Array<unknown>, theClass: Class<T>): void {\n if (arr.every(x => x instanceof theClass)) { // (A)\n assertType<Array<unknown>>(arr)\n }\n}\n\n```", "```ts\nfunction f2<T>(arr: Array<unknown>, theClass: Class<T>): void {\n if (arr.every(x => isInstanceOf(x, theClass))) {\n assertType<Array<T>>(arr)\n }\n}\nfunction isInstanceOf<T>(value: unknown, theClass: Class<T>): value is T  {\n return value instanceof theClass;\n}\n\n```", "```ts\nabstract class Shape {\n isCircle(): this is Circle { // (A)\n return this instanceof Circle;\n }\n isRectangle(): this is Rectangle { // (B)\n return this instanceof Rectangle;\n }\n}\nclass Circle extends Shape {\n center = new Point();\n radius = 0;\n}\nclass Rectangle extends Shape {\n corner1 = new Point();\n corner2 = new Point();\n}\nclass Point {\n x = 0;\n y = 0;\n}\n\n```", "```ts\nfunction f(shape: Shape): void {\n if (shape.isCircle()) {\n assertType<Circle>(shape);\n }\n}\n\n```", "```ts\nclass ValueContainer<T> {\n value: null | T = null;\n hasValue(): this is { value: T } & this {\n return this.value !== null;\n }\n}\n\nfunction f(stringContainer: ValueContainer<string>): void {\n assertType<null | string>(stringContainer.value);\n if (stringContainer.hasValue()) {\n assertType<string>(stringContainer.value);\n }\n}\n\n```", "```ts\nconst isNumber = (x: unknown) => typeof x === 'number';\nassertType<\n (x: unknown) => x is number\n>(isNumber);\n\nconst isNonNullable = <T>(x: T) => x != null;\nassertType<\n <T>(x: T) => x is NonNullable<T>\n>(isNonNullable);\n\n```", "```ts\nconst isTruthy = (x: unknown) => !!x;\nassertType<\n (x: unknown) => boolean\n>(isTruthy);\n\n```", "```ts\n> typeof null\n'object'\n> typeof {}\n'object'\n\n```", "```ts\n//===== Using isTypeOf() at the JavaScript level =====\nassert.equal(\n isTypeOf('abc', 'string'), true\n);\nassert.equal(\n isTypeOf(123, 'string'), false\n);\n// Fix `typeof` bug:\nassert.equal(\n isTypeOf(null, 'null'), true\n);\nassert.equal(\n isTypeOf({}, 'null'), false\n);\nassert.equal(\n isTypeOf({}, 'object'), true\n);\nassert.equal(\n isTypeOf(null, 'object'), false\n);\n\n//===== Using isTypeOf() at the type level =====\nfunction fn(value: unknown) {\n if (isTypeOf(value, 'string')) {\n assertType<string>(value);\n }\n\n // Fix `typeof` bug:\n if (isTypeOf(value, 'object')) {\n assertType<object>(value);\n }\n if (isTypeOf(value, 'null')) {\n assertType<null>(value);\n }\n}\n\n```", "```ts\nfunction isTypeOf<\n T extends string\n>(\n value: unknown, typeString: T\n): value is TypeStringToType<T> {\n switch (typeString) {\n case 'null':\n return value === null;\n case 'object':\n return typeof value === 'object' && value !== null;\n default:\n return typeof value === typeString;\n }\n}\n\ntype TypeStringToType<S extends string> =\n S extends 'undefined' ? undefined :\n S extends 'null' ? null :\n S extends 'boolean' ? boolean :\n S extends 'number' ? number :\n S extends 'bigint' ? bigint :\n S extends 'string' ? string :\n S extends 'symbol' ? symbol :\n S extends 'object' ? object :\n S extends 'function' ? Function :\n never\n ;\n\n```", "```ts\nfunction isTypeOf<\n T extends keyof TypeofLookupTable // (A)\n>(\n value: unknown, typeString: T\n): value is TypeofLookupTable[T] {\n switch (typeString) {\n case 'null':\n return value === null;\n case 'object':\n return typeof value === 'object' && value !== null;\n default:\n return typeof value === typeString;\n }\n}\n\ntype TypeofLookupTable = {\n 'undefined': undefined,\n 'null': null,\n 'boolean': boolean,\n 'number': number,\n 'bigint': bigint,\n 'string': string,\n 'symbol': symbol,\n 'object': object,\n 'function': Function,\n};\n\n```", "```ts\n// @ts-expect-error: Argument of type '\"nmbr\"' is not assignable to\n// parameter of type 'keyof TypeofLookupTable'.\nisTypeOf(123, 'nmbr')\n\n```", "```ts\nfunction isTypeOf(value: unknown, typeString: 'undefined'): value is undefined;\nfunction isTypeOf(value: unknown, typeString: 'null'): value is null;\nfunction isTypeOf(value: unknown, typeString: 'boolean'): value is boolean;\nfunction isTypeOf(value: unknown, typeString: 'number'): value is number;\nfunction isTypeOf(value: unknown, typeString: 'bigint'): value is bigint;\nfunction isTypeOf(value: unknown, typeString: 'string'): value is string;\nfunction isTypeOf(value: unknown, typeString: 'symbol'): value is symbol;\nfunction isTypeOf(value: unknown, typeString: 'object'): value is object;\nfunction isTypeOf(value: unknown, typeString: 'function'): value is Function;\nfunction isTypeOf(value: unknown, typeString: string): boolean {\n switch (typeString) {\n case 'null':\n return value === null;\n case 'object':\n return typeof value === 'object' && value !== null;\n default:\n return typeof value === typeString;\n }\n}\n\n```"]