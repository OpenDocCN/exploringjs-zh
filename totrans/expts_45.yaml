- en: 37 Computing with tuple types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/ts/book/ch_computing-with-tuple-types.html](https://exploringjs.com/ts/book/ch_computing-with-tuple-types.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Ad, please don’t block.)
  prefs: []
  type: TYPE_NORMAL
- en: '[37.1 The syntax of tuple types](#the-syntax-of-tuple-types)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.1.1 Basic syntax](#basic-syntax)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.1.2 Variadic tuple elements](#variadic-tuple-elements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.1.3 Labeled tuple elements](#labeled-tuple-elements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.2 Types for tuples](#types-for-tuples)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.2.1 Tuples and `--noUncheckedIndexedAccess`](#tuples-and-nouncheckedindexedaccess)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.2.2 Forcing Array literals to be inferred as tuples](#forcing-array-literals-to-be-inferred-as-tuples)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.2.3 Using `readonly` to accept const tuples](#using-readonly-to-accept-const-tuples)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.2.4 Enforcing a fixed Array length](#enforcing-a-fixed-array-length)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.3 The keys of tuple types](#keyof-tuple-type)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.3.1 Extracting the index keys (strings) of a tuple](#TupleIndexKeys)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.3.2 Extracting the indices (numbers) of a tuple](#TupleIndices)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.4 Mapping tuples via mapped types](#mapped-types-over-tuples)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.4.1 How a mapped type handles the keys of a tuple type](#how-a-mapped-type-handles-the-keys-of-a-tuple-type)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.4.2 Mapping preserves the labels of tuple elements](#mapping-preserves-the-labels-of-tuple-elements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.4.3 Tuples and mapped types with key remapping (`as`)](#tuples-and-mapped-types-with-key-remapping-as)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.4.4 Example: typing `Promise.all()`](#typing-Promise.all)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.5 Extracting union types from tuples](#extracting-union-types-from-tuples)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.5.1 Applying the indexed access operator `T[K]` to a tuple](#from-tuple-to-union)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.5.2 Extracting a union from a tuple of tuples](#from-tuple-of-tuples-to-union)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.5.3 Extracting a union from a tuple of objects](#from-tuple-of-objects-to-union)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.6 Computing with tuple types](#computing-with-tuple-types-1)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.6.1 Extracting parts of tuples](#extracting-parts-of-tuples)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.6.2 Using a tuple of pairs as a lookup table](#tuple-lookup-table)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.6.3 Concatenating tuples](#concatenating-tuples)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.6.4 Recursion over tuples](#recursion-over-tuples)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.7 Real-world examples](#real-world-examples)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.7.1 Partial application that preserves parameter names](#applyPartial)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.7.2 Typing a function `zip()`](#typing-zip)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.7.3 Typing a function `zipObj()`](#typing-a-function-zipobj)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.7.4 `util.promisify()`: converting a callback-based function to a Promise-based
    one](#util-promisify-converting-a-callback-based-function-to-a-promise-based-one)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.8 Limitations of computing with tuples](#limitations-of-computing-with-tuples)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[37.9 Sources of this chapter](#sources-of-this-chapter-6)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'JavaScript’s Arrays are so flexible that TypeScript provides two different
    kinds of types for handling them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Array types for arbitrary-length sequences of values that all have the same
    type – e.g.: `Array<string>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tuple types for fixed-length sequences of values where each one may have a
    different type – e.g.: `[number, string, boolean]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we look at the latter – especially how to compute with tuples
    at the type level.
  prefs: []
  type: TYPE_NORMAL
- en: '[37.1 The syntax of tuple types](#the-syntax-of-tuple-types)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[37.1.1 Basic syntax](#basic-syntax)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Tuple types have this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: First, zero or more required elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, zero or more optional elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end, optionally, a single rest element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**There is one additional rule:** required elements can appear after a rest
    element – but only if there is no optional element before them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[37.1.1.1 Optional elements can only be omitted at the end](#optional-elements-can-only-be-omitted-at-the-end)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If the compiler option [`exactOptionalPropertyTypes`](ch_tsconfig-json.html#exactOptionalPropertyTypes)
    is active, we can’t even do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this is similar to how JavaScript handles parameters and destructuring
    – e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to enable omitting elements in the middle, we can use a union:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If there is a second parameter, it is assigned to `y` and does not become an
    element of `z`.
  prefs: []
  type: TYPE_NORMAL
- en: '[37.1.2 Variadic tuple elements](#variadic-tuple-elements)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Variadic* means “has variable (not fixed) arity”. The arity of a tuple is
    its length.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Variadic elements* (or *spread elements*) enable spreading into tuples at
    the type level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare that to spreading in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The type that is spread is usually a type variable and must be assignable to
    `readonly any[]` – i.e., it must be an Array or a tuple. It can have any length
    – hence the term “variadic”. The pull request [“Variadic tuple types”](https://github.com/microsoft/TypeScript/pull/39094)
    describes spreading like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Intuitively, a variadic element `...T` is a placeholder that is replaced with
    one or more elements through generic type instantiation.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[37.1.2.1 Normalization of instantiated generic tuple types](#normalization-of-instantiated-generic-tuple-types)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The result of spreading is adjusted so that it always fits the shape described
    at the beginning of this section. To explore how that works, we’ll use the utility
    types `Spread1` and `Spread2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we can only spread a type `T` if it is constrained via `extends`
    to an Array type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[37.1.3 Labeled tuple elements](#labeled-tuple-elements)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can also specify labels for tuple elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If one element is labeled, all elements must be labeled. For optional elements,
    the syntax changes with labels – the question mark (`?`) is added to the label,
    not the type (TypeScript will tell you during editing if you do it wrong):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'What do labels do? Not much: They help with autocompletion and are preserved
    by some type operations but have no other effect in the type system:'
  prefs: []
  type: TYPE_NORMAL
- en: We can’t derive anything from them (e.g. to derive an options object from normal
    parameters).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They don’t affect type compatibility etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore: If names matter, you should use an object type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[37.1.3.1 Extracted function parameters are labeled](#extracted-function-parameters-are-labeled)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If we extract function parameters, we get labeled tuple elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there is no way to check what the actual tuple element labels are
    – these checks succeed too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[37.1.3.2 Use case: overloading](#overloading)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'TypeScript uses labels as function parameters if a rest parameter has a tuple
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to labels, tuples become better as an alternative to overloading because
    autocompletion can show parameter names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The caveat is that the tuples can’t influence the return type.
  prefs: []
  type: TYPE_NORMAL
- en: '[37.1.3.3 Use case: preserving argument names when transforming functions](#use-case-preserving-argument-names-when-transforming-functions)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: How that works is demonstrated when we handle partial application [later in
    this chapter](#applyPartial).
  prefs: []
  type: TYPE_NORMAL
- en: '[37.2 Types for tuples](#types-for-tuples)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[37.2.1 Tuples and `--noUncheckedIndexedAccess`](#tuples-and-nouncheckedindexedaccess)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we switch on the `tsconfig.json` option [`noUncheckedIndexedAccess`](ch_tsconfig-json.html#noUncheckedIndexedAccess)
    then TypeScript is more honest about what it knows about an indexable type.
  prefs: []
  type: TYPE_NORMAL
- en: 'With an Array, TypeScript never knows at compile time at which indices there
    are elements – which is why `undefined` is always a possible result with indexed
    reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With a tuple, TypeScript knows the whole shape and can provide better types
    for indexed reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[37.2.2 Forcing Array literals to be inferred as tuples](#forcing-array-literals-to-be-inferred-as-tuples)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'By default, a JavaScript Array literal has an Array type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The most common way of changing that is via an `as const` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'But we can also use `satisfies`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `as const` also narrows the element types to `''a''` and `1`. With
    `satisfies`, they are `string` and `number` – unless we use `as const` for the
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If we omit the tuple element before the rest element (at the end), we are back
    to an Array type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one other type we can use for tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[37.2.3 Using `readonly` to accept const tuples](#using-readonly-to-accept-const-tuples)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a type `T` is constrained to a normal array type then it doesn’t match the
    type of an `as const` literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can change that by switching to a `ReadonlyArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following two notations are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this chapter, I don’t always make array types readonly because it adds visual
    clutter.
  prefs: []
  type: TYPE_NORMAL
- en: '[37.2.4 Enforcing a fixed Array length](#enforcing-a-fixed-array-length)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can use the following trick to enforce a fixed length for Array literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The caveat is that this technique does not work if the `strs` come from a variable
    whose type is an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, a tuple works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[37.3 The keys of tuple types](#keyof-tuple-type)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The keys of an Array type look like this (note the `Includes` in the first
    line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We can see keys for Array indices (`number`), `.length` and Array methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The keys of a tuple type are similar, but, in addition to the broad type `number`
    for indices, they also have one stringified number for each index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Why are string literal types used and not number literal types? The latter
    disappear in a union with `number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the ECMAScript specification also uses string keys for Array elements
    ([more information](https://exploringjs.com/js/book/ch_arrays.html#arrays-are-actually-dictionaries)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[37.3.1 Extracting the index keys (strings) of a tuple](#TupleIndexKeys)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This utility type returns all string keys of a tuple `T` that are indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We use `&` to create the intersection type between the keys of `T` and the template
    literal type `` `${number}` `` – which is the type of all strings that are stringified
    numbers (see [“Interpolating primitive types into template literals” (§38.2.5)](ch_template-literal-types.html#interpolating-primitive-types-into-template-literals)).
  prefs: []
  type: TYPE_NORMAL
- en: '[37.3.2 Extracting the indices (numbers) of a tuple](#TupleIndices)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Getting a tuple’s numeric indices (numbers, not stringified numbers) is more
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`TupleIndices` uses the following helper type, which extracts string literal
    types with numbers and converts them to numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In line A, `StrToNum` uses a template literal type plus `infer` to parse a number
    inside a string literal type. If there is no number, it returns `never`. Since
    the conditional type in line A is distributive, we can use it to filter a union
    type (as shown at the end).
  prefs: []
  type: TYPE_NORMAL
- en: '[37.4 Mapping tuples via mapped types](#mapped-types-over-tuples)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A mapped type has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[37.4.1 How a mapped type handles the keys of a tuple type](#how-a-mapped-type-handles-the-keys-of-a-tuple-type)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Recall that `keyof`, applied to a tuple, produces [a variety of values](#keyof-tuple-type):
    method names, stringified indices, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In its basic form, a mapped type helps us with tuples in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it filters the keys and only loops over string index keys (`'0'`, `'1'`,
    etc.).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, it returns a tuple (not an object literal type).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example demonstrates both phenomena. `KeyToKey<T>` returns a
    tuple whose elements are the string index keys of the tuple `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[37.4.2 Mapping preserves the labels of tuple elements](#mapping-preserves-the-labels-of-tuple-elements)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Mapping preserves the labels of tuple elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[37.4.3 Tuples and mapped types with key remapping (`as`)](#tuples-and-mapped-types-with-key-remapping-as)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we use key remapping (`as`) in a mapped type over a tuple then the result
    won’t be a tuple anymore and all keys of a tuple will be considered (vs. only
    its indices):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to stick with tuple indices, we have to filter the result of `keyof`.
    To do that, we can use the utility types `TupleIndexKeys` that we have defined
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `TupleIndices` returns string literal types – which explains the
    property values. If we prefer number literal types, we can use the previously
    defined utility type `TupleIndices`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[37.4.4 Example: typing `Promise.all()`](#typing-Promise.all)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is what the type for `Promise.all()` looks like (I edited [the actual
    code](https://github.com/microsoft/TypeScript/blob/main/src/lib/es2015.promise.d.ts)
    slightly):'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the following helper type which unwraps the Promises in a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Notes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `-readonly` in line A removes that modifier from each tuple element and
    therefore from the whole tuple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The built-in utility type `Awaited` (used in line A) works like `await` and
    (roughly) unwraps Promises.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With that helper type, our version of `Promise.all()` is easy to type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The constraint after `extends` in line A achieves two things:'
  prefs: []
  type: TYPE_NORMAL
- en: '`readonly` means that read-only `values` are also accepted, not just mutable
    `values`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unknown[] | []` means that Array literals are interpreted as tuples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[37.5 Extracting union types from tuples](#extracting-union-types-from-tuples)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[37.5.1 Applying the indexed access operator `T[K]` to a tuple](#from-tuple-to-union)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we apply [the indexed access operator `T[K]`](ch_computing-with-types-overview.html#indexed-access-types)
    to a tuple, we get the tuple elements as a union:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[37.5.2 Extracting a union from a tuple of tuples](#from-tuple-of-tuples-to-union)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes, it makes sense to encode data as a collection of tuples – e.g. when
    we want to look up a tuple by any of its elements and performance is not as important.
    In contrast, Maps only support lookup by key well.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Maps, it’s easy to compute the keys and the values – which we can use to
    constrain values when looking up data. Can we do the same for a tuple of tuples?
    We can, if we use the indexed access operator `T[K]` twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[37.5.3 Extracting a union from a tuple of objects](#from-tuple-of-objects-to-union)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The same approach works for a tuple of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[37.6 Computing with tuple types](#computing-with-tuple-types-1)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll explore computing with tuple types via small examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we’ll look at real-world use cases for this kind of computation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[37.6.1 Extracting parts of tuples](#extracting-parts-of-tuples)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To extract parts of tuples, we use `infer`.
  prefs: []
  type: TYPE_NORMAL
- en: '[37.6.1.1 Extracting the first element of a tuple](#extracting-the-first-element-of-a-tuple)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We infer the first element and ignore all other elements by using `unknown`
    as a wildcard type that matches anything.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[37.6.1.2 Extracting the last element of a tuple](#extracting-the-last-element-of-a-tuple)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The approach we used to extract the first element (in the previous example)
    also works for extracting the last element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[37.6.1.3 Extracting the *rest* of a tuple (elements after the first one)](#extracting-the-rest-of-a-tuple-elements-after-the-first-one)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To extract the *rest* of a tuple (the elements after the first one), we make
    use the wildcard type `unknown` for the first element and infer what is spread
    after it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[37.6.2 Using a tuple of pairs as a lookup table](#tuple-lookup-table)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For many purposes, object literal types are very convenient as lookup tables:
    At the type level, lookup only works if keys are strings, numbers or symbols.
    Additionally, TypeScript doesn’t distinguish between strings and numbers. That
    mirrors how JavaScript works and prevents us from distinguishing between the number
    `1` and the string `''1''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'As an alternative, we can use a tuple of pairs (tuples with two elements) as
    a lookup table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the types that implement the lookup functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'How does that work? Step 1: Go from a tuple of pairs to a union of pairs via
    [an indexed access type (`T[K]`)](ch_computing-with-types-overview.html#indexed-access-types).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 2: Apply `LookupOne` to each of the pairs. That happens automatically
    if we apply that generic type to the union because its conditional type is [distributive](ch_conditional-types.html#distributivity-of-conditional-types):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 3: Since [`never` is the empty set](ch_never.html#never-is-the-empty-set),
    we get the final result `''string''` after the intermediate result of the distributed
    application of `LookupOne` is evaluated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[37.6.3 Concatenating tuples](#concatenating-tuples)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To concatenate two tuples `T1` and `T2`, we spread them both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[37.6.4 Recursion over tuples](#recursion-over-tuples)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To explore recursion over tuples, let’s implement wrapping tuple elements with
    recursion (where we previously used a mapped type):'
  prefs: []
  type: TYPE_NORMAL
- en: Recursing over tuples in TypeScript
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a technique that is inspired by how functional programming languages
    recurse over lists:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Line A: We check whether we can split `Tup` into the first element `First`
    and the remaining elements `Rest`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line B: If yes then `Tup` has at least one element. We return a tuple whose
    first element is the wrapped `First` and whose remaining elements are computed
    by a self-recursive call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line C: If no then `Tup` is empty. We return an empty tuple.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In functional programming, `First` is often called `Head` and `Rest` is often
    called `Tail`.
  prefs: []
  type: TYPE_NORMAL
- en: '[37.6.4.1 Flattening a tuple of tuples](#flattening-a-tuple-of-tuples)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s use recursion to flatten a tuple of tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the inferred types `Tup` and `Rest` are more complex – which is
    why TypeScript complains if we don’t use `extends` (line A, line B) to constrain
    them.
  prefs: []
  type: TYPE_NORMAL
- en: '[37.6.4.2 Filtering a tuple](#filtering-tuples)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following code uses recursion to filter out empty strings in a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have to use recursion for filtering. There are two reasons why
    using a mapped type and key remapping via `as` won’t work:'
  prefs: []
  type: TYPE_NORMAL
- en: Due to `as`, such a type constructs an object type, not a tuple type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping preserves the indices, so removing properties leaves gaps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[37.6.4.3 Creating a tuple with a given length](#utility-type-Repeat)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If we want to create a tuple that has a given length `Len`, we are faced with
    a challenge: How do we know when to stop? We can’t decrement `Len`, we can only
    check if it is equal to a given value (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'How does this code work? We use another functional programming technique and
    introduce an internal *accumulator* parameter `Acc`:'
  prefs: []
  type: TYPE_NORMAL
- en: While recursion is still ongoing, we assemble the eventual result in `Acc` (line
    C).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One the length of `Acc` is equal to `Len` (line A), we are done and can return
    `Acc` (line B).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[37.6.4.4 Computing a range of numbers](#computing-a-range-of-numbers)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can use the same technique to compute a range of numbers. Only this time,
    we append the current length of the accumulator to the accumulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[37.6.4.5 Dropping initial elements](#dropping-initial-elements)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This is one way of implementing a utility type that removes the first `Num`
    elements of a `Tuple`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This time, we use the accumulator variable `Counter` to count up – until Counter['length']
    is equal to `Num`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use inference ([idea](https://mastodon.social/@hcschuetz/113906317654567023)
    by Heribert Schütz):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We use [the utility type `Repeat`](#utility-type-Repeat) to compute a tuple
    where each element is the wildcard type `unknown` that matches any type. Then
    we match `Tuple` against a tuple pattern that begins with those elements. The
    remaining elements are the result we are looking for and we extract it via `infer`.
  prefs: []
  type: TYPE_NORMAL
- en: '[37.7 Real-world examples](#real-world-examples)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[37.7.1 Partial application that preserves parameter names](#applyPartial)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s implement the function `applyPartial(func, args)` for partially applying
    a function `func`. It works similarly to the function method `.bind()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We return a partially applied `func`. To compute the type for the parameter
    `remainingArgs`, we remove the `InitialArgs` from the arguments of `Func` – via
    the following utility type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[37.7.2 Typing a function `zip()`](#typing-zip)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider a `zip()` function that converts a tuple of iterables to an iterable
    of tuples ([source code of an implementation](https://github.com/rauschma/iterable/blob/main/ts/src/sync.ts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The following utility type `Zip` computes a return type for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[37.7.3 Typing a function `zipObj()`](#typing-a-function-zipobj)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Function `zipObj()` is similar to `zip()`: It converts an object of iterables
    to an iterable of objects ([source code of an implementation](https://github.com/rauschma/iterable/blob/main/ts/src/sync.ts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The following utility type `ZipObj` computes a return type for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[37.7.4 `util.promisify()`: converting a callback-based function to a Promise-based
    one](#util-promisify-converting-a-callback-based-function-to-a-promise-based-one)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Node.js function [`util.promisify(cb)`](https://nodejs.org/api/util.html#utilpromisifyoriginal)
    converts a function that returns its result via a callback to a function that
    returns it via a Promise. [Its official type](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/node/util.d.ts)
    is long:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try to simplify it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code uses the following utility type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[37.8 Limitations of computing with tuples](#limitations-of-computing-with-tuples)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are constraints we can’t express via TypeScript’s type system. The following
    code is one example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We’d like to express:'
  prefs: []
  type: TYPE_NORMAL
- en: Function `many()` receives an Array of objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The types of the two properties should be the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can’t loop and introduce one variable per loop iteration. Therefore, we list
    the most common cases manually.
  prefs: []
  type: TYPE_NORMAL
- en: '[37.9 Sources of this chapter](#sources-of-this-chapter-6)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pull request [“Variadic tuple types”](https://github.com/microsoft/TypeScript/pull/39094)
    by Anders Hejlsberg
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Section [“Variadic Tuple Types”](https://devblogs.microsoft.com/typescript/announcing-typescript-4-0/#variadic-tuple-types)
    in the TypeScript 4.0 blog post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Section [“Labeled Tuple Elements”](https://devblogs.microsoft.com/typescript/announcing-typescript-4-0/#labeled-tuple-elements)
    in the TypeScript 4.0 blog post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
