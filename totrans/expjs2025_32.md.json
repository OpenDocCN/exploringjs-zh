["```js\n// Function declaration (a statement)\nfunction ordinary1(a, b, c) {\n // ···\n}\n `// const plus anonymous (nameless) function expression`\n`const ordinary2 = function (a, b, c) {`\n `// ···`\n`};` \n```", "```js```", "````js````", "```js const anonFuncExpr = function (a, b, c) {  // ··· };  ```", "```js const namedFuncExpr = function myName(a, b, c) {  // `myName` is only accessible in here };  ```", "```js const func = function funcExpr() { return funcExpr }; assert.equal(func(), func);  ``// The name `funcExpr` only exists inside the function body:`` `assert.throws(() => funcExpr(), ReferenceError);`  ```", "```js```", "````js````", "```js function getNameOfCallback(callback) {  return callback.name; }  `assert.equal(`  `getNameOfCallback(function () {}), '' // anonymous` `);`  `` `assert.equal(`  `getNameOfCallback(function named() {}), 'named' // (A)` `);` ``  ```", "```js```", "````js````", "```js```", "````js``` Note that functions created via function declarations or variable declarations always have names:    ``` function funcDecl() {} assert.equal(  getNameOfCallback(funcDecl), 'funcDecl' );  `const funcExpr = function () {};` `assert.equal(`  `getNameOfCallback(funcExpr), 'funcExpr'` `);`  ```js   ````", "`````` One benefit of functions having names is that those names show up in [error stack traces](ch_exception-handling.html#error-stack).    #### [27.2.2 Terminology: function definitions and function expressions](#terminology-function-definitions-and-function-expressions)    A *function definition* is syntax that creates functions:    *   A function declaration (a statement) *   A function expression    Function declarations always produce ordinary functions. Function expressions produce either ordinary functions or specialized functions:    *   Ordinary function expressions (which we have already encountered):     *   Anonymous function expressions     *   Named function expressions *   Specialized function expressions (which we’ll look at later):     *   Arrow functions (which are always expressions)    While function declarations are still popular in JavaScript, function expressions are almost always arrow functions in modern code.    #### [27.2.3 Parts of a function declaration](#parts-of-a-function-declaration)    Let’s examine the parts of a function declaration via the following example. Most of the terms also apply to function expressions.    ```js function add(x, y) {  return x + y; }  ```    *   `add` is the *name* of the function declaration. *   `add(x, y)` is the *head* of the function declaration. *   `x` and `y` are the *parameters*. *   The curly braces (`{` and `}`) and everything between them are the *body* of the function declaration. *   The `return` statement explicitly returns a value from the function.    ##### [27.2.3.1 Trailing commas in parameter lists ^(ES2017)](#trailing-commas-parameters)    JavaScript has always allowed and ignored trailing commas in Array literals. Since ES5, they are also allowed in object literals. Since ES2017, we can add trailing commas to parameter lists (declarations and invocations):    ```js // Declaration function retrieveData(  contentText,  keyword,  {unique, ignoreCase, pageSize}, // trailing comma ) {  // ··· }  `// Invocation` `retrieveData(`  `'',`  `null,`  `{ignoreCase: true, pageSize: 10}, // trailing comma` `);`  ```   ```js``````", "``` function add(x, y) {  return x + y; }  ```", "```     assert.equal(add(2, 1), 3);          ```", "```     const obj = { addAsMethod: add };     assert.equal(obj.addAsMethod(2, 4), 6); // (A)          ```", "```     const inst = new add();     assert.equal(inst instanceof add, true);          ```", "```     const arrow = () => {      return 123;     };     assert.equal(arrow(), 123);          ```", "```     const obj = {      myMethod() {      return 'abc';      }     };     assert.equal(obj.myMethod(), 'abc');          ```", "```     class MyClass {      /* ··· */     }     const inst = new MyClass();          ```", "``` > (() => {}) instanceof Function true > ({ method() {} }.method) instanceof Function true > (class SomeClass {}) instanceof Function true  ```", "``` const f = function (x, y, z) { return 123 };  ```", "``` const f = (x, y, z) => { return 123 };  ```", "``` const f = (x, y, z) => 123;  ```", "``` const id = x => x;  ```", "``` > [1,2,3].map(x => x+1) [ 2, 3, 4 ]  ```", "``` [1,2,3].map(function (x) { return x+1 });  ```", "``` const func1 = () => ({a: 1}); assert.deepEqual(func1(), { a: 1 });  ```", "``` const func2 = () => {a: 1}; assert.deepEqual(func2(), undefined);  ```", "``` const obj = {  myMethod() {  assert.equal(this, obj);  } }; obj.myMethod();  ```", "``` const obj = {  myMethod: function () {  assert.equal(this, obj);  } }; obj.myMethod();  ```", "``` function ordinaryFunc() {  assert.equal(this, undefined); } ordinaryFunc();  ```", "``` const jill = {  name: 'Jill',  someMethod() {  function ordinaryFunc() {  assert.throws(  () => this.name, // (A)  /^TypeError: Cannot read properties of undefined \\(reading 'name'\\)$/  );  }  ordinaryFunc();  `const arrowFunc = () => {`  `assert.equal(this.name, 'Jill'); // (B)`  `};`  `arrowFunc();`  `},` `};` `jill.someMethod();`  ```", "``````js```` In this code, we can observe two ways of handling `this`:    *   Dynamic `this`: In line A, we try to access the `this` of `.someMethod()` from an ordinary function. There, it is *shadowed* by the function’s own `this`, which is `undefined` (as filled in by the function call). Given that ordinary functions receive their `this` via (dynamic) function or method calls, their `this` is called *dynamic*.           *   Lexical `this`: In line B, we again try to access the `this` of `.someMethod()`. This time, we succeed because the arrow function does not have its own `this`. `this` is resolved *lexically*, just like any other variable. That’s why the `this` of arrow functions is called *lexical*.              #### [27.3.4 Recommendation: prefer specialized functions over ordinary functions](#prefer-specialized-functions)    Normally, we should prefer specialized functions over ordinary functions, especially classes and methods.    When it comes to real functions, the choice between an arrow function and an ordinary function is less clear-cut, though:    *   For anonymous inline function expressions, arrow functions are clear winners, due to their compact syntax and them not having `this` as an implicit parameter:                    ```js     const twiceOrdinary = [1, 2, 3].map(function (x) {return x * 2});     const twiceArrow = [1, 2, 3].map(x => x * 2);          ```           *   For stand-alone named function declarations, arrow functions still benefit from lexical `this`. But function declarations (which produce ordinary functions) have nice syntax and early activation is also occasionally useful (see [“Declarations: scope and activation” (§13.8)](ch_variables-assignment.html#declarations-scope-activation)). If `this` doesn’t appear in the body of an ordinary function, there is no downside to using it as a real function. The static checking tool ESLint can warn us during development when we do this wrong via [a built-in rule](https://eslint.org/docs/rules/no-invalid-this).                    ```js     function timesOrdinary(x, y) {      return x * y;     }     const timesArrow = (x, y) => {      return x * y;     };          ```              ### [27.4 Summary: kinds of callable values](#summary-kinds-of-callable-values)    ![Icon “reading”](../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png) **This section refers to upcoming content**    This section mainly serves as a reference for the current and upcoming chapters. Don’t worry if you don’t understand everything.    So far, all (real) functions and methods, that we have seen, were:    *   Single-result *   Synchronous    Later chapters will cover other modes of programming:    *   *Iteration* treats objects as containers of data (so-called *iterables*) and provides a standardized way for retrieving what is inside them. If a function or a method returns an iterable, it returns multiple values. *   *Asynchronous programming* deals with handling a long-running computation. We are notified when the computation is finished and can do something else in between. The standard pattern for asynchronously delivering single results is called *Promise*.    These modes can be combined – for example, there are synchronous iterables and asynchronous iterables.    Several new kinds of functions and methods help with some of the mode combinations:    *   *Async functions* help implement functions that return Promises. There are also *async methods*. *   *Synchronous generator functions* help implement functions that return synchronous iterables. There are also *synchronous generator methods*. *   *Asynchronous generator functions* help implement functions that return asynchronous iterables. There are also *asynchronous generator methods*.    That leaves us with 4 kinds (2 × 2) of functions and methods:    *   Synchronous vs. asynchronous *   Generator vs. single-result    [Table 27.2](#tbl:syntax-functions-methods) gives an overview of the syntax for creating these 4 kinds of functions and methods.     |  |  | **Result** | **#** | | --- | --- | --- | --- | | **Sync function** | **Sync method** |  |  | | `function f() {}` | `{ m() {} }` | value | 1 | | `f = function () {}` |  |  |  | | `f = () => {}` |  |  |  | | **Sync generator function** | **Sync gen. method** |  |  | | `function* f() {}` | `{ * m() {} }` | iterable | 0+ | | `f = function* () {}` |  |  |  | | **Async function** | **Async method** |  |  | | `async function f() {}` | `{ async m() {} }` | Promise | 1 | | `f = async function () {}` |  |  |  | | `f = async () => {}` |  |  |  | | **Async generator function** | **Async gen. method** |  |  | | `async function* f() {}` | `{ async * m() {} }` | async iterable | 0+ | | `f = async function* () {}` |  |  |  |      Table 27.2: Syntax for creating functions and methods. The last column specifies how many values are produced by an entity.      ### [27.5 Returning values from functions and methods](#returning-values-from-functions-and-methods)    (Everything mentioned in this section applies to both functions and methods.)    The `return` statement explicitly returns a value from a function:    ```js function func() {  return 123; } assert.equal(func(), 123);  ```    Another example:    ```js function boolToYesNo(bool) {  if (bool) {  return 'Yes';  } else {  return 'No';  } } assert.equal(boolToYesNo(true), 'Yes'); assert.equal(boolToYesNo(false), 'No');  ```    If, at the end of a function, we haven’t returned anything explicitly, JavaScript returns `undefined` for us:    ```js function noReturn() {  // No explicit return } assert.equal(noReturn(), undefined);  ```    ### [27.6 Parameter handling](#parameter-handling)    Once again, I am only mentioning functions in this section, but everything also applies to methods.    #### [27.6.1 Terminology: parameters vs. arguments](#terminology-parameters-vs-arguments)    The term *parameter* and the term *argument* basically mean the same thing. If we want to, we can make the following distinction:    *   *Parameters* are part of a function definition. They are also called *formal parameters* and *formal arguments*.           *   *Arguments* are part of a function call. They are also called *actual parameters* and *actual arguments*.              #### [27.6.2 Terminology: callback](#callback-function)    A *callback* or *callback function* is a function that is an argument of a function or method call.    The following is an example of a callback:    ```js const myArray = ['a', 'b']; const callback = (x) => console.log(x); myArray.forEach(callback);  ```    Output:    ```js a b  ```    #### [27.6.3 Too many or not enough arguments](#too-many-or-not-enough-arguments)    JavaScript does not complain if a function call provides a different number of arguments than expected by the function definition:    *   Extra arguments are ignored. *   Missing parameters are set to `undefined`.    For example:    ```js function foo(x, y) {  return [x, y]; }  `// Too many arguments:` `assert.deepEqual(foo('a', 'b', 'c'), ['a', 'b']);`  ``` `// The expected number of arguments:` `assert.deepEqual(foo('a', 'b'), ['a', 'b']);`  `` `// Not enough arguments:` `assert.deepEqual(foo('a'), ['a', undefined]);` `` ```js  ```   ```js``````", "```js```", "```js function f(x, y=0) {  return [x, y]; }  `assert.deepEqual(f(1), [1, 0]);` `assert.deepEqual(f(), [undefined, 0]);`  ```", "```js```", "```js assert.deepEqual(  f(undefined, undefined),  [undefined, 0] );  ```", "```js function f(x, ...y) {  return [x, y]; } assert.deepEqual(  f('a', 'b', 'c'), ['a', ['b', 'c']] ); assert.deepEqual(  f(), [undefined, []] );  ```", "```js     assert.throws(      () => eval('function f(...x, ...y) {}'),      /^SyntaxError: Rest parameter must be last formal parameter$/     );          ```", "```js     assert.throws(      () => eval('function f(...restParams, lastParam) {}'),      /^SyntaxError: Rest parameter must be last formal parameter$/     );          ```", "```js function createPoint(x, y) {  return {x, y};  // same as {x: x, y: y} }  ```", "```js function createPoint(...args) {  if (args.length !== 2) {  throw new Error('Please provide exactly 2 arguments!');  }  const [x, y] = args; // (A)  return {x, y}; }  ```", "```js     selectEntries(3, 20, 2)          ```", "```js     selectEntries({start: 3, end: 20, step: 2})          ```", "```js function selectEntries({start=0, end=-1, step=1}) {  return {start, end, step}; }  ```", "```js {start: start=0, end: end=-1, step: step=1}  ```", "```js > selectEntries({}) { start: 0, end: -1, step: 1 }  ```", "```js > selectEntries() TypeError: Cannot read properties of undefined (reading 'start')  ```", "```js function selectEntries({start=0, end=-1, step=1} = {}) {  return {start, end, step}; } assert.deepEqual(  selectEntries(),  { start: 0, end: -1, step: 1 } );  ```", "```js function func(x, y) {  console.log(x);  console.log(y); } const someIterable = ['a', 'b']; func(...someIterable);  // same as func('a', 'b')  ```", "```js a b  ```", "```js > Math.max(-1, 5, 11, 3) 11 > Math.max(...[-1, 5, 11, 3]) 11 > Math.max(-1, ...[-5, 11], 3) 11  ```", "```js const arr1 = ['a', 'b']; const arr2 = ['c', 'd'];  `arr1.push(...arr2);` `assert.deepEqual(arr1, ['a', 'b', 'c', 'd']);`  ```", "```js```", "``` someFunc.call(thisValue, arg1, arg2, arg3);  ```", "``` someFunc(arg1, arg2, arg3);  ```", "``` function func(x, y) {  return [this, x, y]; }  `assert.deepEqual(`  `func.call('hello', 'a', 'b'),`  `['hello', 'a', 'b']` `);`  ```", "````` As we have seen before, if we function-call an ordinary function, its `this` is `undefined`:    ```js assert.deepEqual(  func('a', 'b'),  [undefined, 'a', 'b'] );  ```    Therefore, the previous function call is equivalent to:    ```js assert.deepEqual(  func.call(undefined, 'a', 'b'),  [undefined, 'a', 'b'] );  ```    In arrow functions, the value for `this` provided via `.call()` (or other means) is ignored.    #### [27.7.2 The function method `.apply()`](#Function.prototype.apply)    Each function `someFunc` has the following method:    ```js someFunc.apply(thisValue, [arg1, arg2, arg3]);  ```    This method invocation is loosely equivalent to the following function call (which uses [spreading](#spread-arguments)):    ```js someFunc(...[arg1, arg2, arg3]);  ```    However, with `.apply()`, we can also specify a value for [the implicit parameter `this`](#this-in-callables).    The following code demonstrates the use of `.apply()`:    ```js function func(x, y) {  return [this, x, y]; }  `const args = ['a', 'b'];` `assert.deepEqual(`  `func.apply('hello', args),`  `['hello', 'a', 'b']` `);`  ```   ```js` #### [27.7.3 The function method `.bind()`](#Function.prototype.bind)    `.bind()` is another method of function objects. This method is invoked as follows:    ``` const boundFunc = someFunc.bind(thisValue, arg1, arg2);  ```js    `.bind()` returns a new function `boundFunc()`. Calling that function invokes `someFunc()` with `this` set to `thisValue` and these parameters: `arg1`, `arg2`, followed by the parameters of `boundFunc()`.    That is, the following two function calls are equivalent:    ``` boundFunc('a', 'b') someFunc.call(thisValue, arg1, arg2, 'a', 'b')  ```js    ##### [27.7.3.1 An alternative to `.bind()`](#an-alternative-to-bind)    Another way of pre-filling `this` and parameters is via an arrow function:    ``` const boundFunc2 = (...args) =>  someFunc.call(thisValue, arg1, arg2, ...args);  ```js    ##### [27.7.3.2 An implementation of `.bind()`](#an-implementation-of-bind)    Considering the previous section, `.bind()` can be implemented as a real function as follows:    ``` function bind(func, thisValue, ...boundArgs) {  return (...args) =>  func.call(thisValue, ...boundArgs, ...args); }  ```js    ##### [27.7.3.3 Example: binding a real function](#example-binding-a-real-function)    Using `.bind()` for real functions is somewhat unintuitive because we have to provide a value for `this`. Given that it is `undefined` during function calls, it is usually set to `undefined` or `null`.    In the following example, we create `add8()`, a function that has one parameter, by binding the first parameter of `add()` to `8`.    ``` function add(x, y) {  return x + y; }  `const add8 = add.bind(undefined, 8);` `assert.equal(add8(1), 9);`  ```js ```` ```js`` `````", "``````js` ``````", "``````js``` ``````", "```` ```js````", "```js` ```", "```js```", "``` ```", "```````js``` ``````js```````", "``````js``````", "``````js``````"]