["```js\nfunction readProfiles(filePaths) {\n const profiles = [];\n for (const filePath of filePaths) {\n try {\n const profile = readOneProfile(filePath);\n profiles.push(profile);\n } catch (err) { // (A)\n console.log('Error in: '+filePath, err);\n }\n }\n}\nfunction readOneProfile(filePath) {\n const profile = new Profile();\n const file = openFile(filePath);\n // \u00b7\u00b7\u00b7 (Read the data in `file` into `profile`)\n return profile;\n}\nfunction openFile(filePath) {\n if (!fs.existsSync(filePath)) {\n throw new Error('Could not find file '+filePath); // (B)\n }\n // \u00b7\u00b7\u00b7 (Open the file whose path is `filePath`)\n}\n```", "```js\nreadProfiles(\u00b7\u00b7\u00b7)\n  for (const filePath of filePaths)\n    try\n      readOneProfile(\u00b7\u00b7\u00b7)\n        openFile(\u00b7\u00b7\u00b7)\n          if (!fs.existsSync(filePath))\n            throw\n```", "```js\nthrow \u00abvalue\u00bb;\n```", "```js\n    const err = new Error('Could not find the file');\n    err.filePath = filePath;\n    throw err;\n    ```", "```js\n    class MyError extends Error {\n    }\n    function func() {\n     throw new MyError('Problem!');\n    }\n    assert.throws(\n     () => func(),\n     MyError);\n    ```", "```js\ntry {\n \u00abtry_statements\u00bb\n} catch (error) {\n \u00abcatch_statements\u00bb\n} finally {\n \u00abfinally_statements\u00bb\n}\n```", "```js\nconst errorObject = new Error();\nfunction func() {\n throw errorObject; // (A)\n}\n\ntry {\n func();\n} catch (err) { // (B)\n assert.equal(err, errorObject);\n}\n```", "```js\ntry {\n // \u00b7\u00b7\u00b7\n} catch {\n // \u00b7\u00b7\u00b7\n}\n```", "```js\nfunction throws(func) {\n try {\n func();\n } catch {\n return; // everything OK\n }\n throw new Error('Function didn\u2019t throw an exception!');\n}\n```", "```js\nconst resource = createResource();\ntry {\n // Work with `resource`. Errors may be thrown.\n} finally {\n resource.destroy();\n}\n```", "```js\nlet finallyWasExecuted = false;\nassert.throws(\n () => {\n try {\n throw new Error(); // (A)\n } finally {\n finallyWasExecuted = true;\n }\n },\n Error\n);\nassert.equal(finallyWasExecuted, true);\n```", "```js\nlet finallyWasExecuted = false;\nfunction func() {\n try {\n return; // (A)\n } finally {\n finallyWasExecuted = true;\n }\n}\nfunc();\nassert.equal(finallyWasExecuted, true);\n```", "```js\nclass Error {\n // Instance properties\n message: string;\n cause?: any; // ES2022\n stack: string; // non-standard but widely supported\n\n constructor(\n message: string = '',\n options?: ErrorOptions // ES2022\n );\n}\ninterface ErrorOptions {\n cause?: any; // ES2022\n}\n```", "```js\n> Error.prototype.name\n'Error'\n> RangeError.prototype.name\n'RangeError'\n```", "```js\n> new RangeError().name\n'RangeError'\n> new RangeError().constructor.name\n'RangeError'\n```", "```js\nconst err = new Error('Hello!');\nassert.equal(String(err), 'Error: Hello!');\nassert.equal(err.message, 'Hello!');\n```", "```js\nassert.equal(new Error().message, '');\n```", "```js\nconst err = new Error('Hello!');\nassert.equal(\nerr.stack,\n`\nError: Hello!\n at file://ch_exception-handling.mjs:1:13\n`.trim());\n```", "```js\nconst err = new Error('msg', {cause: 'the cause'});\nassert.equal(err.cause, 'the cause');\n```", "```js\nclass MyCustomError extends Error {\n constructor(message, options) {\n super(message, options);\n // \u00b7\u00b7\u00b7\n }\n}\n```", "```js\nfunction readFiles(filePaths) {\n return filePaths.map(\n (filePath) => {\n try {\n const text = readText(filePath);\n const json = JSON.parse(text);\n return processJson(json);\n } catch (error) {\n // (A)\n }\n });\n}\n```", "```js\nfunction readFiles(filePaths) {\n return filePaths.map(\n (filePath) => {\n try {\n // \u00b7\u00b7\u00b7\n } catch (error) {\n throw new Error(\n `While processing ${filePath}`,\n {cause: error}\n );\n }\n });\n}\n```", "```js\n/**\n * An error class that supports error chaining.\n * If there is built-in support for .cause, it uses it.\n * Otherwise, it creates this property itself.\n *\n * @see https://github.com/tc39/proposal-error-cause\n */\nclass CausedError extends Error {\n constructor(message, options) {\n super(message, options);\n if (\n (isObject(options) && 'cause' in options)\n && !('cause' in this)\n ) {\n // .cause was specified but the superconstructor\n // did not create an instance property.\n const cause = options.cause;\n this.cause = cause;\n if ('stack' in cause) {\n this.stack = this.stack + '\\nCAUSE: ' + cause.stack;\n }\n }\n }\n}\n\nfunction isObject(value) {\n return value !== null && typeof value === 'object';\n}\n```"]