- en: 43 Promises for asynchronous programming ES6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_promises.html](https://exploringjs.com/js/book/ch_promises.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[43.1 The basics of using Promises](#the-basics-of-using-promises)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.1.1 Using a Promise-based function](#using-promise-based-functions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.1.2 Promises vs. events](#promises-vs-events)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.1.3 Implementing a Promise-based function](#implementing-promise-based-functions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.1.4 The three basic states of Promises](#basic-states-of-promises)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.1.5 Creating resolved and rejected Promises via `Promise.resolve()` and
    `Promise.reject()`](#Promise.resolve-Promise.reject)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.1.6 Returning and throwing in `.then()` callbacks](#returning-and-throwing-in-then-callbacks)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.1.7 `.catch()` and its callback](#catch-and-its-callback)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.1.8 Chaining method calls](#chaining-method-calls)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.1.9 `Promise.try()`: starting a Promise chain ^(ES2025)](#Promise.try)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.1.10 `Promise.prototype.finally()` ^(ES2018)](#Promise.prototype.finally)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.1.11 `Promise.withResolvers()` ^(ES2024)](#Promise.withResolvers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.1.12 Advantages of promises over plain callbacks](#promises-vs-callbacks)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.2 Examples](#examples)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.2.1 Node.js: Reading a file asynchronously](#nodejs-reading-a-file-asynchronously)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.2.2 Browsers: Promisifying `XMLHttpRequest`](#promisifying-xmlhttprequest)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.2.3 Fetch API](#fetch-api)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.3 Tip for error handling: don’t mix rejections and exceptions](#tip-for-error-handling-dont-mix-rejections-and-exceptions)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.4 Promise-based functions start synchronously, settle asynchronously](#promise-based-functions-start-sync-settle-async)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.5 Promise combinator functions: working with Arrays of Promises](#promise-combinators)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.5.1 What is a Promise combinator function?](#what-is-a-promise-combinator-function)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.5.2 `Promise.all()`](#Promise.all)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.5.3 `Promise.race()`](#Promise.race)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.5.4 `Promise.any()` ^(ES2021)](#Promise.any)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.5.5 `Promise.allSettled()` ^(ES2020)](#Promise.allSettled)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.5.6 Short-circuiting (advanced)](#shortcircuiting-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.6 Concurrency and `Promise.all()` (advanced)](#concurrency-and-promiseall-advanced)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.6.1 Sequential execution vs. concurrent execution](#sequential-execution-vs-concurrent-execution)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.6.2 Concurrency tip: focus on when operations start](#focus-on-async-start)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.6.3 `Promise.all()` is fork-join](#promise-all-is-fork-join)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.7 Tips for chaining Promises](#tips-for-chaining-promises)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.7.1 Chaining mistake: losing the tail](#chaining-mistake-losing-thetail)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.7.2 Chaining mistake: nesting](#chaining-mistake-nesting)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.7.3 Chaining mistake: more nesting than necessary](#chaining-mistake-more-nesting-than-necessary)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.7.4 Not all nesting is bad](#not-all-nesting-is-bad)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.7.5 Chaining mistake: creating Promises instead of chaining](#chaining-mistake-creating-promises-instead-of-chaining)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.8 Thenables (Promise-like objects) (advanced)](#thenables-promiselike-objects-advanced)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.8.1 Example: a fulfilled thenable](#example-a-fulfilled-thenable)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.8.2 Example: a rejected thenable](#example-a-rejected-thenable)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.9 Quick reference: `Promise`](#quickref-Promise)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.9.1 `new Promise()`](#new-promise)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.9.2 `Promise.*`: creating Promises](#promise-creating-promises)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.9.3 `Promise.*`: miscellaneous functionality](#promise-miscellaneous-functionality)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.9.4 `Promise.*`: Promise combinators](#promise-promise-combinators)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[43.9.5 `Promise.prototype.*`](#promiseprototype)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Icon “reading”](../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png) **Recommended
    reading**'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter builds on [the previous chapter](ch_async-js.html#ch_async-js)
    with background on asynchronous programming in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '[43.1 The basics of using Promises](#the-basics-of-using-promises)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[43.1.1 Using a Promise-based function](#using-promise-based-functions)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Promises are a technique for delivering results asynchronously. Instead of
    directly returning a result, a Promise-based function returns a *Promise*: a container
    object that is initially empty. If and when the function is eventually done, it
    puts either a result or an error into the Promise.'
  prefs: []
  type: TYPE_NORMAL
- en: The following code shows how the Promise-based function `addAsync()` is used.
    We’ll see how that function is implemented soon.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To access what’s inside the Promise (if and when there is something inside
    it), we register callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Method `.then()` registers callbacks that are called with the result (if and
    when there is one).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method `.catch()` registers callbacks that are called with the error (if and
    when there is one).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This aspect of Promises is similar to [the event pattern](ch_async-js.html#event-pattern).
  prefs: []
  type: TYPE_NORMAL
- en: '[43.1.2 Promises vs. events](#promises-vs-events)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Promises differ from events in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'They deliver at most one result and are optimized for that use case:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we register a `.then()` callback when a Promise is still empty, it is notified
    if and when the Promise receives a result. If we register a `.catch()` callback
    when a Promise is still empty, it is notified if and when the Promise receives
    an error.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a Promise receives a result or an error, that value is cached. Thus, if
    we register a callback after that happens, it gets the cached value (depending
    on whether it is eligible to receive it). That means there is no risk of registering
    a callback too late.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first value received by a Promise permanently *settles* that Promise: Values
    it receives later are ignored.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We can chain the Promise methods `.then()` and `.catch()` because they both
    return Promises. That helps with sequentially invoking multiple asynchronous functions.
    More on that later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[43.1.3 Implementing a Promise-based function](#implementing-promise-based-functions)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is an implementation of a Promise-based function that adds two numbers
    `x` and `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`addAsync()` immediately creates and returns a Promise by new-invoking the
    `Promise` constructor (line A). It can only change the state of the new Promise
    from inside the callback (line B) that it passes to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: The callback parameter `resolve` is a function that puts a result into the Promise
    (in case of success).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The callback parameter `reject` is a function that puts an error into the Promise
    (in case of failure).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One we have invoked either these functions, subsequent invocations of them have
    no effect.
  prefs: []
  type: TYPE_NORMAL
- en: '[43.1.3.1 The revealing constructor pattern (advanced)](#revealing-constructor-pattern)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The Promise constructor uses *the revealing constructor pattern*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[Quoting Domenic Denicola](https://blog.domenic.me/the-revealing-constructor-pattern/),
    one of the people behind JavaScript’s Promise API:'
  prefs: []
  type: TYPE_NORMAL
- en: I call this *the revealing constructor pattern* because the `Promise` constructor
    is *revealing* its internal capabilities, but only to the code that constructs
    the promise in question. The ability to resolve or reject the promise is only
    revealed to the constructing code, and is crucially *not* revealed to anyone *using*
    the promise. So if we hand off `p` to another consumer, say
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: then we can be sure that this consumer cannot mess with any of the internals
    that were revealed to us by the constructor. This is as opposed to, for example,
    putting `resolve` and `reject` methods on `p`, which anyone could call.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[43.1.4 The three basic states of Promises](#basic-states-of-promises)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 43.1](#fig:promise_states_simple) depicts the three states a Promise
    can be in.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/06c68bd8e345f2ccc6d4e27fffb6f694.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 43.1: A Promise is initially in the state “pending”. It can later transition
    to either the state “fulfilled” or the state “rejected” (but it may never do so).
    If a Promise is in a final (non-pending) state, it is called *settled*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[43.1.4.1 Some Promises are never settled](#promises-that-are-never-settled)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This is an example of a Promise that is never settled and forever pending:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[43.1.4.2 What is the difference between resolving and fulfilling a Promise?](#resolving-vs-fulfilling-promises)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A Promise can only be fulfilled with a non-Promise value. In contrast, we can
    resolve a Promise with either a non-Promise value or a Promise. If the callback
    of `new Promise()` calls `resolve(x)` then it depends on `x` what happens to the
    newly created Promise `p`:'
  prefs: []
  type: TYPE_NORMAL
- en: If `x` is a non-Promise value then `p` is fulfilled with `x`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If `x` is a Promise, then `p` adopts the state of `x` (which basically results
    in `x` replacing `p`). In other words:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While `x` is pending, `p` is pending.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If and when `x` is fulfilled, `p` is fulfilled.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If and when `x` is rejected, `p` is rejected.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In other words: Resolving only determines the fate of a Promise; it may or
    may not fulfill it. This behavior helps with chaining Promise methods. More on
    that later.'
  prefs: []
  type: TYPE_NORMAL
- en: '[43.1.5 Creating resolved and rejected Promises via `Promise.resolve()` and
    `Promise.reject()`](#Promise.resolve-Promise.reject)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If `x` is a non-Promise value then `Promise.resolve(x)` creates a Promise that
    is fulfilled with that value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If the argument is already a Promise, it is returned unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`Promise.reject(err)` accepts a value `err` (that is normally not a Promise)
    and returns a Promise that is rejected with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Why is that useful?
  prefs: []
  type: TYPE_NORMAL
- en: On one hand, we can use `Promise.resolve()` to convert a value that may or may
    not be a Promise to a value that is guaranteed to be a Promise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, we may want to create a Promise that is fulfilled or rejected
    with a given non-Promise value. Then we can use `Promise.resolve()` and `Promise.reject()`
    – as demonstrated by the example below.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[43.1.6 Returning and throwing in `.then()` callbacks](#returning-and-throwing-in-then-callbacks)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`.then()` registers callbacks for Promise fulfillments. It also returns a new
    Promise. Doing so enables method chaining: We can invoke `.then()` and `.catch()`
    on the result and keep the asynchronous computation going.'
  prefs: []
  type: TYPE_NORMAL
- en: How the Promise returned by `.then()` is resolved, depends on what happens inside
    its callback. Let’s look at three common cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[43.1.6.1 Returning a non-Promise value from the `.then()` callback](#then-callback-returns-non-promise-value)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, the callback can return a non-Promise value (line A). Consequently,
    the Promise returned by `.then()` is fulfilled with that value (as checked in
    line B):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[43.1.6.2 Returning a Promise from the `.then()` callback](#then-callback-returns-promise)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Second, the callback can return a Promise `q` (line A). Consequently, the Promise
    `p` returned by `.then()` is resolved with `q`. In other words: `p` is effectively
    replaced by `q`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Why is that useful? We can return the result of a Promise-based operation and
    process its fulfillment value via a “flat” (non-nested) `.then()`. Compare:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12][PRE13][PRE14][PRE15] ##### [43.1.6.3 Throwing an exception inside the
    `.then()` callback](#then-callback-throws-exception)    Third, the callback can
    throw an exception. Consequently, the Promise returned by `.then()` is rejected
    with that exception. That is, a synchronous error is converted into an asynchronous
    error.    [PRE16]    #### [43.1.7 `.catch()` and its callback](#catch-and-its-callback)    The
    difference between `.then()` and `.catch()` is that the latter is triggered by
    rejections, not fulfillments. However, both methods turn the actions of their
    callbacks into Promises in the same manner. For example, in the following code,
    the value returned by the `.catch()` callback in line A becomes a fulfillment
    value:    [PRE17]   [PRE18][PRE19][PRE20][PRE21]``js[PRE22]js[PRE23]`js[PRE24]js`
    ##### [43.1.10.1 Use case for `.finally()`: cleaning up](#use-case-for-finally-cleaning-up)    One
    common use case for `.finally()` is similar to a common use case of the synchronous
    `finally` clause: cleaning up after you are done with a resource. That should
    always happen, regardless of whether everything went smoothly or there was an
    error – for example:    [PRE25]js    ##### [43.1.10.2 Use case for `.finally()`:
    doing something first after any kind of settlement](#use-case-for-finally-doing-something-first-after-any-kind-of-settlement)    We
    can also use `.finally()` before both `.then()` and `.catch()`. Then what we do
    in the `.finally()` callback is always executed before the other two callbacks.
    As an example, consider the following function `handleAsyncResult()`:    [PRE26]js    This
    is what happens with a fulfilled Promise:    [PRE27]js    Output:    [PRE28]js    This
    is what happens with a rejected Promise:    [PRE29]js    Output:    [PRE30]js    ####
    [43.1.11 `Promise.withResolvers()` ^(ES2024)](#Promise.withResolvers)    The most
    common way of creating and resolving a Promise is via the `Promise` constructor:    [PRE31]js    One
    limitation of creating Promises like that is that the settlement functions `resolve`
    and `reject` are meant to only be used inside the callback. Sometimes we want
    to use them outside of it. That’s when the following static factory method is
    useful:    [PRE32]js    This is what using that factory method looks like:    [PRE33]js    ![Icon
    “question”](../Images/3decb3ca67c240d2bb04742c1f28af18.png) **Why the name `withResolvers`?
    Why not, e.g., `withSettlers`?**    *   `resolve()` may not settle `promise` –
    it only resolves it. *   The ECMAScript specification uses [the name “resolving
    functions”](https://tc39.es/ecma262/#sec-createresolvingfunctions) for `resolve`
    and `reject`.    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Implementing an asynchronous queue via a linked list whose elements are Promises**    `exercises/promises/promise-queue_test.mjs`    #####
    [43.1.11.1 An implementation](#an-implementation)    We can implement `Promise.withResolvers()`
    as follows:    [PRE34]js    ##### [43.1.11.2 Example: one-element queue](#example-oneelement-queue)    [PRE35]js   [PRE36]`js[PRE37]js[PRE38]js[PRE39]js[PRE40]js[PRE41]js[PRE42]`js[PRE43]js[PRE44][PRE45][PRE46]js[PRE47]js[PRE48][PRE49]
    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercises:
    Promise combinator methods**    *   Getting the highest fulfillment value of an
    iterable over Promises: `exercises/promises/get-highest-fulfillment_test.mjs`           *   Implementing
    `Promise.anySettled()`: `exercises/promises/promise-any-settled_test.mjs`              ####
    [43.5.6 Short-circuiting (advanced)](#shortcircuiting-advanced)    For a Promise
    combinator, *short-circuiting* means that the output Promise is settled early
    – before all input Promises are settled. The following combinators short-circuit:    *   `Promise.all()`:
    The output Promise is rejected as soon as one input Promise is rejected. *   `Promise.race()`:
    The output Promise is settled as soon as one input Promise is settled. *   `Promise.any()`:
    The output Promise is fulfilled as soon as one input Promise is fulfilled.    Once
    again, settling early does not mean that the operations behind the ignored Promises
    are stopped. It just means that their settlements are ignored.    ### [43.6 Concurrency
    and `Promise.all()` (advanced)](#concurrency-and-promiseall-advanced)    ####
    [43.6.1 Sequential execution vs. concurrent execution](#sequential-execution-vs-concurrent-execution)    Consider
    the following code:    [PRE50]js   [PRE51] Using `.then()` in this manner executes
    Promise-based functions *sequentially*: only after the result of `asyncFunc1()`
    is settled will `asyncFunc2()` be executed.    `Promise.all()` helps execute Promise-based
    functions more concurrently:    [PRE52]    #### [43.6.2 Concurrency tip: focus
    on when operations start](#focus-on-async-start)    Tip for determining how “concurrent”
    asynchronous code is: Focus on when asynchronous operations start, not on how
    their Promises are handled.    For example, each of the following functions executes
    `asyncFunc1()` and `asyncFunc2()` concurrently because they are started at nearly
    the same time.    [PRE53]   [PRE54][PRE55]``js[PRE56]`` Computation starts with
    the Promise returned by `asyncFunc()`. But afterward, computation continues and
    another Promise is created via `.then()`. `foo()` returns the former Promise,
    but should return the latter. This is how to fix it:    [PRE57]    #### [43.7.2 Chaining
    mistake: nesting](#chaining-mistake-nesting)    Problem:    [PRE58]    The `.then()`
    in line A is nested. A flat structure would be better:    [PRE59]    #### [43.7.3 Chaining
    mistake: more nesting than necessary](#chaining-mistake-more-nesting-than-necessary)    This
    is another example of avoidable nesting:    [PRE60]    We can once again get a
    flat structure:    [PRE61]    #### [43.7.4 Not all nesting is bad](#not-all-nesting-is-bad)    In
    the following code, we actually benefit from nesting:    [PRE62]    We are receiving
    an asynchronous result in line A. In line B, we are nesting so that we have access
    to variable `connection` inside the callback and in line C.    #### [43.7.5 Chaining
    mistake: creating Promises instead of chaining](#chaining-mistake-creating-promises-instead-of-chaining)    Problem:    [PRE63]    In
    line A, we are creating a Promise to deliver the result of `db.insert()`. That
    is unnecessarily verbose and can be simplified:    [PRE64]    The key idea is
    that we don’t need to create a Promise; we can return the result of the `.then()`
    call. An additional benefit is that we don’t need to catch and re-reject the failure
    of `db.insert()`. We simply pass its rejection on to the caller of `.insertInto()`.    ###
    [43.8 Thenables (Promise-like objects) (advanced)](#thenables-promiselike-objects-advanced)    When
    Promises were added to JavaScript’s standard library in ES6 (in 2015), several
    Promise libraries were popular and widely used. To make those libraries interoperable
    with the built-in API, TC39 defined a minimal interface for Promise-like objects
    that is compatible with most of those libraries. As often as possible, the API
    does not require objects to be Promises – it’s enough if they are Promise-like.
    If necessary, the API transparently converts Promise-like objects to API Promises.    So
    what minimal interface describes the essence of Promises? It only needs a method
    `.then()` that lets us register callbacks:    [PRE65]    This is a simplified
    version of TypeScript’s type for Promise-like objects:    [PRE66]    This interface
    is sufficient because `.catch()` is actually just a convenient way of invoking
    `.then()` (whose second parameter we have ignored previously) – the following
    two invocations are equivalent:    [PRE67]    Because Promise-like objects only
    have a method `.then()`, they are also called *thenables*.    #### [43.8.1 Example:
    a fulfilled thenable](#example-a-fulfilled-thenable)    The following object is
    a fulfilled thenable:    [PRE68]    If we pass the thenable to `Promise.resolve()`,
    it converts it to a Promise:    [PRE69]    Returning the thenable from a callback
    is equivalent to returning a Promise:    [PRE70]    We can also resolve a new
    Promise with a thenable:    [PRE71]    #### [43.8.2 Example: a rejected thenable](#example-a-rejected-thenable)    The
    following code demonstrates a rejected thenable:    [PRE72] `Promise.resolve()`  `.then(()
    => rejectedThenable)`  `.catch((reason) => {`  `assert.equal(reason, ''Error!'');`  `});`  ``
    `new Promise((resolve) => {`  `resolve(rejectedThenable);` `}).catch((reason)
    => {`  `assert.equal(reason, ''Error!'');` `});` `` [PRE73]   [PRE74]`` [PRE75]`
    ### [43.9 Quick reference: `Promise`](#quickref-Promise)    #### [43.9.1 `new
    Promise()`](#new-promise)    *   `new Promise(executor)` ES6                    [PRE76]                    This
    constructor creates a new Promise. It passes functions to its callback with which
    that Promise can be resolved or rejected:                    [PRE77]              [PRE78]
    #### [43.9.2 `Promise.*`: creating Promises](#promise-creating-promises)    *   `Promise.withResolvers()`
    ES2024                    [PRE79]js                    This method creates a Promise
    and returns an object that contains that Promise plus functions for resolving
    or rejecting it.           *   `Promise.resolve(value?)` ES6                    Creates
    a Promise, resolves it with `value` and returns it:                    [PRE80]js           *   `Promise.reject(reason?)`
    ES6                    Creates a Promise, rejects it with `value` and returns
    it:                    [PRE81]js              #### [43.9.3 `Promise.*`: miscellaneous
    functionality](#promise-miscellaneous-functionality)    *   `Promise.try(callback,
    ...args)` ES2025                    Creates a Promise by treating `callback` as
    if it were a `.then()` callback:               *   It invokes `callback` with
    zero or more arguments.     *   If `callback` throws an exception, `Promise.try()`
    turns it into a rejected Promise and returns it.     *   If `callback` returns
    a value, `Promise.try()` resolves it to a Promise and returns it.          The
    use case for this method is starting a Promise chain with code that is not purely
    asynchronous – e.g.:                    [PRE82]js              #### [43.9.4 `Promise.*`:
    Promise combinators](#promise-promise-combinators)    Glossary:    *   *Short-circuiting*:
    In some cases, the output Promise can be settled early (before every input Promise
    is settled). That is called short-circuiting.    These are the Promise combinators:    *   `Promise.all(promises)`
    ES6                    [PRE83]js               *   **Fulfillment** of `P`: if
    all input Promises are fulfilled.         *   Value: Array with the fulfillment
    values of the input Promises     *   **Rejection** of `P`: if one input Promise
    is rejected.         *   Value: rejection value of the input Promise     *   Short-circuits:
    yes     *   Use case: processing Arrays with Promises (rejections terminate processing)
    *   `Promise.race(promises)` ES6                    [PRE84]js               *   **Settlement**
    of `P`: if the first input Promise is settled.         *   Value: settlement value
    of the input Promise     *   Short-circuits: yes     *   Use case: reacting to
    the first settlement among multiple Promises *   `Promise.any(promises)` ES2021                    [PRE85]js               *   **Fulfillment**
    of `P`: if one input Promise is fulfilled.         *   Value: fulfillment value
    of the input Promise     *   **Rejection** of `P`: if all input Promises are rejected.         *   Value:
    `AggregateError` that contains the rejection values of the input Promises.     *   Short-circuits:
    yes     *   Use case: Among several asynchronous computations, we are only interested
    in the first successful one. That is, we are trying several approaches and the
    fastest one should win.          This is the type signature of `AggregateError`
    (a few members were omitted):                    [PRE86]js           *   `Promise.allSettled(promises)`
    ES2020                    [PRE87]js               *   **Fulfillment** of `P`:
    if all input Promise are settled.         *   Value: Array with one *settlement
    object* for each input Promise. A settlement object contains the kind of settlement
    and the settlement value.     *   **Rejection** of `P`: if there is an error when
    iterating over the input Promises.     *   Short-circuits: no     *   Use case:
    processing Arrays with Promises (rejections don’t terminate processing)          This
    is the type signature of `SettlementObject`:                    [PRE88]js              [PRE89]`js
    [PRE90]js`` [PRE91]js[PRE92][PRE93][PRE94][PRE95]js[PRE96]js` [PRE97]`js`` [PRE98]`js[PRE99][PRE100][PRE101]
    [PRE102][PRE103][PRE104][PRE105][PRE106]`` [PRE107][PRE108][PRE109] [PRE110]`js[PRE111]js[PRE112]js[PRE113]js[PRE114]js[PRE115]js`
    [PRE116]`js[PRE117]js[PRE118]js[PRE119][PRE120][PRE121][PRE122]`````'
  prefs: []
  type: TYPE_NORMAL
