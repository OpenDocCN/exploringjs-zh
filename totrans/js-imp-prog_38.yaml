- en: 31 Arrays (Array)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 31 数组 (Array)
- en: 原文：[https://exploringjs.com/impatient-js/ch_arrays.html](https://exploringjs.com/impatient-js/ch_arrays.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/impatient-js/ch_arrays.html](https://exploringjs.com/impatient-js/ch_arrays.html)
- en: '* * *'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '31.1 [Cheat sheet: Arrays](ch_arrays.html#cheat-sheet-arrays)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.1 [速查表：数组](ch_arrays.html#cheat-sheet-arrays)
- en: 31.1.1 [Using Arrays](ch_arrays.html#using-arrays)
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.1.1 [使用数组](ch_arrays.html#using-arrays)
- en: 31.1.2 [Array methods](ch_arrays.html#array-methods)
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.1.2 [数组方法](ch_arrays.html#array-methods)
- en: 31.2 [The two ways of using Arrays in JavaScript](ch_arrays.html#ways-of-using-arrays)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.2 [JavaScript中使用数组的两种方式](ch_arrays.html#ways-of-using-arrays)
- en: 31.3 [Basic Array operations](ch_arrays.html#basic-array-operations)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.3 [基本数组操作](ch_arrays.html#basic-array-operations)
- en: 31.3.1 [Creating, reading, writing Arrays](ch_arrays.html#array-literals)
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.3.1 [创建、读取、写入数组](ch_arrays.html#array-literals)
- en: 31.3.2 [The `.length` of an Array](ch_arrays.html#the-.length-of-an-array)
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.3.2 [数组的`.length`](ch_arrays.html#the-.length-of-an-array)
- en: 31.3.3 [Referring to elements via negative indices](ch_arrays.html#referring-to-elements-via-negative-indices)
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.3.3 [通过负索引引用元素](ch_arrays.html#referring-to-elements-via-negative-indices)
- en: 31.3.4 [Clearing Arrays](ch_arrays.html#clearing-arrays)
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.3.4 [清除数组](ch_arrays.html#clearing-arrays)
- en: 31.3.5 [Spreading into Array literals [ES6]](ch_arrays.html#spreading-into-array-literals)
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.3.5 [扩展到数组文字[ES6]](ch_arrays.html#spreading-into-array-literals)
- en: '31.3.6 [Arrays: listing indices and entries [ES6]](ch_arrays.html#arrays-listing-indices-and-entries-es6)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.3.6 [数组：列出索引和条目[ES6]](ch_arrays.html#arrays-listing-indices-and-entries-es6)
- en: 31.3.7 [Is a value an Array?](ch_arrays.html#is-a-value-an-array)
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.3.7 [一个值是数组吗？](ch_arrays.html#is-a-value-an-array)
- en: 31.4 [`for-of` and Arrays [ES6]](ch_arrays.html#for-of-and-arrays-es6)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.4 [`for-of`和数组[ES6]](ch_arrays.html#for-of-and-arrays-es6)
- en: '31.4.1 [`for-of`: iterating over elements](ch_arrays.html#for-of-iterating-over-elements)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.4.1 [`for-of`：遍历元素](ch_arrays.html#for-of-iterating-over-elements)
- en: '31.4.2 [`for-of`: iterating over indices](ch_arrays.html#for-of-iterating-over-indices)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.4.2 [`for-of`：遍历索引](ch_arrays.html#for-of-iterating-over-indices)
- en: '31.4.3 [`for-of`: iterating over [index, element] pairs](ch_arrays.html#for-of-iterating-over-index-element-pairs)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.4.3 [`for-of`：遍历[index, element]对](ch_arrays.html#for-of-iterating-over-index-element-pairs)
- en: 31.5 [Array-like objects](ch_arrays.html#array-like-objects)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.5 [类数组对象](ch_arrays.html#array-like-objects)
- en: 31.6 [Converting iterables and Array-like values to Arrays](ch_arrays.html#converting-to-array)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.6 [将可迭代对象和类数组值转换为数组](ch_arrays.html#converting-to-array)
- en: 31.6.1 [Converting iterables to Arrays via spreading (`...`)](ch_arrays.html#converting-iterables-to-arrays-via-spreading-...)
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.6.1 [通过扩展(`...`)将可迭代对象转换为数组](ch_arrays.html#converting-iterables-to-arrays-via-spreading-...)
- en: 31.6.2 [Converting iterables and Array-like objects to Arrays via `Array.from()`](ch_arrays.html#Array.from)
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.6.2 [通过`Array.from()`将可迭代对象和类数组对象转换为数组](ch_arrays.html#Array.from)
- en: 31.7 [Creating and filling Arrays with arbitrary lengths](ch_arrays.html#filling-arrays)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.7 [创建和填充任意长度的数组](ch_arrays.html#filling-arrays)
- en: 31.7.1 [Do we need to create an empty Array that we’ll fill completely later
    on?](ch_arrays.html#do-we-need-to-create-an-empty-array-that-well-fill-completely-later-on)
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.7.1 [我们需要创建一个空数组，然后稍后完全填充吗？](ch_arrays.html#do-we-need-to-create-an-empty-array-that-well-fill-completely-later-on)
- en: 31.7.2 [Do we need to create an Array filled with a primitive value?](ch_arrays.html#do-we-need-to-create-an-array-filled-with-a-primitive-value)
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.7.2 [我们需要创建一个填充有原始值的数组吗？](ch_arrays.html#do-we-need-to-create-an-array-filled-with-a-primitive-value)
- en: 31.7.3 [Do we need to create an Array filled with objects?](ch_arrays.html#creating-arrays-filled-with-objects)
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.7.3 [我们需要创建一个填充有对象的数组吗？](ch_arrays.html#creating-arrays-filled-with-objects)
- en: 31.7.4 [Do we need to create a range of integers?](ch_arrays.html#create-range-of-integers)
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.7.4 [我们需要创建一个整数范围吗？](ch_arrays.html#create-range-of-integers)
- en: 31.7.5 [Use a Typed Array if the elements are all integers or all floats](ch_arrays.html#use-a-typed-array-if-the-elements-are-all-integers-or-all-floats)
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.7.5 [如果元素都是整数或浮点数，则使用Typed Array](ch_arrays.html#use-a-typed-array-if-the-elements-are-all-integers-or-all-floats)
- en: 31.8 [Multidimensional Arrays](ch_arrays.html#multidimensional-arrays)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.8 [多维数组](ch_arrays.html#multidimensional-arrays)
- en: 31.9 [More Array features (advanced)](ch_arrays.html#more-array-features-advanced)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.9 [更多数组特性（高级）](ch_arrays.html#more-array-features-advanced)
- en: 31.9.1 [Array indices are (slightly special) property keys](ch_arrays.html#array-indices)
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.9.1 [数组索引是（稍微特殊的）属性键](ch_arrays.html#array-indices)
- en: 31.9.2 [Arrays are dictionaries and can have holes](ch_arrays.html#array-holes)
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.9.2 [数组是字典，可以有空隙](ch_arrays.html#array-holes)
- en: 31.10 [Adding and removing elements (destructively and non-destructively)](ch_arrays.html#adding-and-removing-elements-destructively-and-non-destructively)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.10 [添加和移除元素（破坏性和非破坏性）](ch_arrays.html#adding-and-removing-elements-destructively-and-non-destructively)
- en: 31.10.1 [Prepending elements and Arrays](ch_arrays.html#prepending-elements-and-arrays)
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.10.1 [在元素和数组之前添加元素](ch_arrays.html#prepending-elements-and-arrays)
- en: 31.10.2 [Appending elements and Arrays](ch_arrays.html#appending-elements-and-arrays)
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.10.2 [追加元素和数组](ch_arrays.html#appending-elements-and-arrays)
- en: 31.10.3 [Removing elements](ch_arrays.html#removing-elements)
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.10.3 [移除元素](ch_arrays.html#removing-elements)
- en: '31.11 [Methods: iteration and transformation (`.find()`, `.map()`, `.filter()`,
    etc.)](ch_arrays.html#methods-iteration-and-transformation-.find-.map-.filter-etc.)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.11 [方法：迭代和转换（`.find()`, `.map()`, `.filter()`等）](ch_arrays.html#methods-iteration-and-transformation-.find-.map-.filter-etc.)
- en: 31.11.1 [Callbacks for iteration and transformation methods](ch_arrays.html#callbacks-for-iteration-and-transformation-methods)
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.11.1 [迭代和转换方法的回调](ch_arrays.html#callbacks-for-iteration-and-transformation-methods)
- en: '31.11.2 [Searching elements: `.find()`, `.findIndex()`](ch_arrays.html#searching-elements-.find-.findindex)'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.11.2 [搜索元素：`.find()`, `.findIndex()`](ch_arrays.html#searching-elements-.find-.findindex)
- en: '31.11.3 [`.map()`: copy while giving elements new values](ch_arrays.html#map-copy-while-giving-elements-new-values)'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '31.11.3 [`.map()`: 复制并给元素赋予新值](ch_arrays.html#map-copy-while-giving-elements-new-values)'
- en: '31.11.4 [`.flatMap()`: mapping to zero or more values](ch_arrays.html#Array.prototype.flatMap)'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '31.11.4 [`.flatMap()`: 映射到零个或多个值](ch_arrays.html#Array.prototype.flatMap)'
- en: '31.11.5 [`.filter()`: only keep some of the elements](ch_arrays.html#filter-only-keep-some-of-the-elements)'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '31.11.5 [`.filter()`: 仅保留一些元素](ch_arrays.html#filter-only-keep-some-of-the-elements)'
- en: '31.11.6 [`.reduce()`: deriving a value from an Array (advanced)](ch_arrays.html#Array.prototype.reduce)'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '31.11.6 [`.reduce()`: 从数组中派生值（高级）](ch_arrays.html#Array.prototype.reduce)'
- en: '31.12 [`.sort()`: sorting Arrays](ch_arrays.html#Array.prototype.sort)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '31.12 [`.sort()`: 排序数组](ch_arrays.html#Array.prototype.sort)'
- en: 31.12.1 [Customizing the sort order](ch_arrays.html#customizing-array-sorting)
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.12.1 [自定义排序顺序](ch_arrays.html#customizing-array-sorting)
- en: 31.12.2 [Sorting numbers](ch_arrays.html#sorting-numbers)
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.12.2 [排序数字](ch_arrays.html#sorting-numbers)
- en: 31.12.3 [Sorting objects](ch_arrays.html#sorting-objects)
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.12.3 [排序对象](ch_arrays.html#sorting-objects)
- en: '31.13 [Quick reference: `Array`](ch_arrays.html#quickref-array-api)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.13 [快速参考：`Array`](ch_arrays.html#quickref-array-api)
- en: 31.13.1 [`new Array()`](ch_arrays.html#new-array)
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.13.1 [`new Array()`](ch_arrays.html#new-array)
- en: 31.13.2 [Static methods of `Array`](ch_arrays.html#static-methods-of-array)
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.13.2 [`Array`的静态方法](ch_arrays.html#static-methods-of-array)
- en: 31.13.3 [Methods of `Array.prototype`](ch_arrays.html#quickref-array-prototype)
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.13.3 [`Array.prototype`的方法](ch_arrays.html#quickref-array-prototype)
- en: 31.13.4 [Sources](ch_arrays.html#sources-3)
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31.13.4 [来源](ch_arrays.html#sources-3)
- en: '* * *'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '31.1 Cheat sheet: Arrays'
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.1 数组速查表
- en: JavaScript Arrays are a very flexible data structure and used as lists, stacks,
    queues, tuples (e.g. pairs), and more.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript数组是一种非常灵活的数据结构，用作列表、堆栈、队列、元组（例如对）等。
- en: Some Array-related operations destructively change Arrays. Others non-destructively
    produce new Arrays with the changes applied to a copy of the original content.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一些与数组相关的操作会破坏性地改变数组。其他操作会非破坏性地产生对原始内容副本应用了更改的新数组。
- en: 31.1.1 Using Arrays
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.1.1 使用数组
- en: 'Creating an Array, reading and writing elements:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组，读取和写入元素：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The length of an Array:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的长度：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Adding elements destructively via `.push()`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`.push()`破坏性地添加元素：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Adding elements non-destructively via spreading (`...`):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展（`...`）非破坏性地添加元素：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Clearing Arrays (removing all elements):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 清除数组（删除所有元素）：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Looping over elements:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 循环遍历元素：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Looping over index-value pairs:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 循环遍历索引-值对：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Creating and filling Arrays when we can’t use Array literals (e.g. because
    we don’t know their lengths in advance or they are too large):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在无法使用数组文字（例如因为我们事先不知道它们的长度或者它们太大）时创建和填充数组：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 31.1.2 Array methods
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.1.2 数组方法
- en: This section gives a brief overview of the Array API. There is [a more comprehensive
    quick reference](ch_arrays.html#quickref-array-api) at the end of this chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 本节简要概述了数组API。本章末尾有[更全面的快速参考](ch_arrays.html#quickref-array-api)。
- en: 'Deriving a new Array from an existing Array:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从现有数组派生新数组：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Removing an Array element at a given index:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定索引处删除数组元素：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Computing a summary of an Array:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 计算数组的摘要：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Reversing and filling:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 反转和填充：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`.sort()` also modifies an Array and returns it:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`.sort()`也修改数组并返回它：'
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finding Array elements:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 查找数组元素：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Adding or removing an element at the start or the end:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在开头或结尾添加或删除元素：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 31.2 The two ways of using Arrays in JavaScript
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.2 在JavaScript中使用数组的两种方式
- en: 'There are two ways of using Arrays in JavaScript:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中有两种使用数组的方式：
- en: 'Fixed-layout Arrays: Used this way, Arrays have a fixed number of indexed elements.
    Each of those elements can have a different type.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定布局数组：以这种方式使用，数组具有固定数量的索引元素。每个元素可以具有不同的类型。
- en: 'Sequence Arrays: Used this way, Arrays have a variable number of indexed elements.
    Each of those elements has the same type.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列数组：以这种方式使用，数组具有可变数量的索引元素。每个元素具有相同的类型。
- en: In practice, these two ways are often mixed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这两种方式经常混合使用。
- en: Notably, sequence Arrays are so flexible that we can use them as (traditional)
    arrays, stacks, and queues. We’ll see how later.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，序列数组非常灵活，我们可以将它们用作（传统的）数组、堆栈和队列。稍后我们会看到。
- en: 31.3 Basic Array operations
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.3 基本数组操作
- en: 31.3.1 Creating, reading, writing Arrays
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.3.1 创建、读取、写入数组
- en: 'The best way to create an Array is via an *Array literal*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组的最佳方式是通过*数组文字*：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The Array literal starts and ends with square brackets `[]`. It creates an
    Array with three *elements*: `''a''`, `''b''`, and `''c''`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 数组文字以方括号`[]`开始和结束。它创建一个包含三个*元素*：'a'，'b'和'c'的数组。
- en: 'Trailing commas are allowed and ignored in Array literals:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 数组文字中允许并忽略尾随逗号：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To read an Array element, we put an index in square brackets (indices start
    at zero):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取数组元素，我们将索引放在方括号中（索引从零开始）：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To change an Array element, we assign to an Array with an index:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改数组元素，我们将索引分配给数组：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The range of Array indices is 32 bits (excluding the maximum length): [0, 2^(32)−1)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 数组索引的范围为32位（不包括最大长度）：[0, 2^(32)−1]
- en: 31.3.2 The `.length` of an Array
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.3.2 数组的`.length`
- en: Every Array has a property `.length` that can be used to both read and change(!)
    the number of elements in an Array.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数组都有一个属性`.length`，可用于读取和更改(!)数组中的元素数量。
- en: 'The length of an Array is always the highest index plus one:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的长度始终是最高索引加一：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we write to the Array at the index of the length, we append an element:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在长度的索引处写入数组，我们将添加一个元素：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Another way of (destructively) appending an element is via the Array method
    `.push()`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种（破坏性地）附加元素的方法是通过数组方法`.push()`：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we set `.length`, we are pruning the Array by removing elements:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们设置`.length`，我们正在修剪数组，删除元素：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Removing empty
    lines via `.push()`**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **练习：通过`.push()`删除空行**'
- en: '`exercises/arrays/remove_empty_lines_push_test.mjs`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/arrays/remove_empty_lines_push_test.mjs`'
- en: 31.3.3 Referring to elements via negative indices
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.3.3 通过负索引引用元素
- en: 'Several Array methods support negative indices. If an index is negative, it
    is added to the length of an Array to produce a usable index. Therefore, the following
    two invocations of `.slice()` are equivalent: They both copy `arr` starting at
    the last element.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 几种数组方法支持负索引。如果索引为负数，则将其添加到数组的长度以产生可用索引。因此，`.slice()`的以下两个调用是等效的：它们都从最后一个元素开始复制`arr`。
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '31.3.3.1 `.at()`: reading single elements (supports negative indices) [ES2022]'
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '31.3.3.1 `.at()`: 读取单个元素（支持负索引）[ES2022]'
- en: 'The Array method `.at()` returns the element at a given index. It supports
    positive and negative indices (`-1` refers to the last element, `-2` refers to
    the second-last element, etc.):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 数组方法`.at()`返回给定索引处的元素。它支持正数和负数索引（`-1`指最后一个元素，`-2`指倒数第二个元素等）：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In contrast, the bracket operator `[]` does not support negative indices (and
    can’t be changed because that would break existing code). It interprets them as
    keys of non-element properties:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，方括号运算符`[]`不支持负索引（并且不能更改，因为那样会破坏现有的代码）。它将它们解释为非元素属性的键：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 31.3.4 Clearing Arrays
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.3.4 清除数组
- en: 'To clear (empty) an Array, we can either set its `.length` to zero:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 清除（清空）一个数组，我们可以将其`.length`设置为零：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'or we can assign a new empty Array to the variable storing the Array:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以将一个新的空数组赋给存储数组的变量：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The latter approach has the advantage of not affecting other locations that
    point to the same Array. If, however, we do want to reset a shared Array for everyone,
    then we need the former approach.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 后一种方法的优点是不会影响指向相同数组的其他位置。但是，如果我们确实想要为所有人重置共享的数组，那么我们需要前一种方法。
- en: 31.3.5 Spreading into Array literals [ES6]
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.3.5 扩展到数组文字[ES6]
- en: 'Inside an Array literal, a *spread element* consists of three dots (`...`)
    followed by an expression. It results in the expression being evaluated and then
    iterated over. Each iterated value becomes an additional Array element – for example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组文字中，*扩展元素*由三个点（`...`）后跟一个表达式组成。它导致表达式被评估然后被迭代。每个迭代的值都成为额外的数组元素 - 例如：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That means that we can use spreading to create a copy of an Array and to convert
    an iterable to an Array:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以使用扩展来创建数组的副本并将可迭代对象转换为数组：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'However, for both previous use cases, I find `Array.from()` more self-descriptive
    and prefer it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于前面的两种用例，我发现`Array.from()`更具有自我描述性，并更喜欢它：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Spreading is also convenient for concatenating Arrays (and other iterables)
    into Arrays:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展也方便将数组（和其他可迭代对象）连接到数组中：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Due to spreading using iteration, it only works if the value is iterable:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于扩展使用迭代，只有当值可迭代时才有效：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![](../Images/0ac255e56dc93a43365d8502301c8688.png)  **Spreading and `Array.from()`
    produce shallow copies**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/0ac255e56dc93a43365d8502301c8688.png) **扩展和`Array.from()`产生浅层副本**'
- en: 'Copying Arrays via spreading or via `Array.from()` is shallow: We get new entries
    in a new Array, but the values are shared with the original Array. The consequences
    of shallow copying are demonstrated in [§28.4 “Spreading into object literals
    (`...`) [ES2018]”](ch_objects.html#spreading-into-object-literals).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展或通过`Array.from()`复制数组是浅层的：我们在新数组中获得新条目，但值与原始数组共享。浅层复制的后果在[§28.4“扩展到对象字面量（`...`）[ES2018]”](ch_objects.html#spreading-into-object-literals)中得到了证明。
- en: '31.3.6 Arrays: listing indices and entries [ES6]'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.3.6 数组：列出索引和条目[ES6]
- en: 'Method `.keys()` lists the indices of an Array:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`.keys()`列出数组的索引：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`.keys()` returns an iterable. In line A, we convert that iterable to an Array.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`.keys()`返回一个可迭代对象。在A行，我们将该可迭代对象转换为数组。'
- en: 'Listing Array indices is different from listing properties. The former produces
    numbers; the latter produces stringified numbers (in addition to non-index property
    keys):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列出数组索引与列出属性不同。前者产生数字；后者产生字符串化的数字（除了非索引属性键）：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Method `.entries()` lists the contents of an Array as [index, element] pairs:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`.entries()`列出数组的内容为[索引，元素]对：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 31.3.7 Is a value an Array?
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.3.7 是否值为数组？
- en: 'Following are two ways of checking if a value is an Array:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是检查值是否为数组的两种方法：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`instanceof` is usually fine. We need `Array.isArray()` if a value may come
    from another *realm*. Roughly, a realm is an instance of JavaScript’s global scope.
    Some realms are isolated from each other (e.g., [Web Workers](ch_async-js.html#web-workers)
    in browsers), but there are also realms between which we can move data – for example,
    same-origin iframes in browsers. `x instanceof Array` checks the prototype chain
    of `x` and therefore returns `false` if `x` is an Array from another realm.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof`通常很好。如果值可能来自另一个*领域*，我们需要`Array.isArray()`。粗略地说，领域是JavaScript全局范围的一个实例。一些领域彼此隔离（例如，浏览器中的[Web
    Workers](ch_async-js.html#web-workers)），但也有一些领域之间可以移动数据 - 例如，浏览器中的同源iframe。`x
    instanceof Array`检查`x`的原型链，因此如果`x`是来自另一个领域的数组，则返回`false`。'
- en: '`typeof` categorizes Arrays as objects:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof`将数组归类为对象：'
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 31.4 `for-of` and Arrays [ES6]
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.4 `for-of`和数组[ES6]
- en: We have already encountered the `for-of` loop earlier in this book. This section
    briefly recaps how to use it for Arrays.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本书的早期遇到了`for-of`循环。本节简要回顾了如何在数组中使用它。
- en: '31.4.1 `for-of`: iterating over elements'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.4.1 `for-of`：遍历元素
- en: 'The following `for-of` loop iterates over the elements of an Array:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`for-of`循环遍历数组的元素：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '31.4.2 `for-of`: iterating over indices'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.4.2 `for-of`：遍历索引
- en: 'This `for-of` loop iterates over the indices of an Array:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`for-of`循环遍历数组的索引：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '31.4.3 `for-of`: iterating over [index, element] pairs'
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.4.3 `for-of`：遍历[索引，元素]对
- en: The following `for-of` loop iterates over [index, element] pairs. Destructuring
    (described [later](ch_destructuring.html)), gives us convenient syntax for setting
    up `index` and `element` in the head of `for-of`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`for-of`循环遐射[索引，元素]对。解构（稍后描述）为我们提供了在`for-of`头部设置`index`和`element`的便捷语法。
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 31.5 Array-like objects
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.5 类似数组的对象
- en: 'Some operations that work with Arrays require only the bare minimum: values
    must only be *Array-like*. An Array-like value is an object with the following
    properties:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一些适用于数组的操作仅需要最低限度：值必须只是*类似数组*。类似数组的值是具有以下属性的对象：
- en: '`.length`: holds the length of the Array-like object.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.length`：保存类似数组对象的长度。'
- en: '`[0]`: holds the element at index 0 (etc.). Note that if we use numbers as
    property names, they are always coerced to strings. Therefore, `[0]` retrieves
    the value of the property whose key is `''0''`.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[0]`：保存索引0处的元素（等等）。请注意，如果我们使用数字作为属性名称，它们总是被强制转换为字符串。因此，`[0]`检索其键为`''0''`的属性的值。'
- en: 'For example, `Array.from()` accepts Array-like objects and converts them to
    Arrays:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Array.from()`接受类数组对象并将其转换为数组：
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The TypeScript interface for Array-like objects is:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Array-like对象的TypeScript接口是：
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **Array-like objects are
    relatively rare in modern JavaScript**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](../Images/b666ba365e94edaf0ef510fd7e12c7de.png) **类数组对象在现代JavaScript中相对较少**
- en: Array-like objects used to be common before ES6; now we don’t see them very
    often.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6之前，类数组对象很常见；现在我们很少见到它们。
- en: 31.6 Converting iterables and Array-like values to Arrays
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.6 将可迭代对象和类数组值转换为数组
- en: 'There are two common ways of converting iterables and Array-like values to
    Arrays:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 将可迭代对象和类数组值转换为数组有两种常见的方法：
- en: Spreading into Arrays
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展为数组
- en: '`Array.from()`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.from()`'
- en: I prefer the latter – I find it more self-explanatory.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢后者-我觉得它更加自解释。
- en: 31.6.1 Converting iterables to Arrays via spreading (`...`)
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.6.1 通过扩展（`...`）将可迭代对象转换为数组
- en: 'Inside an Array literal, spreading via `...` converts any iterable object into
    a series of Array elements. For example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组字面量内，通过`...`扩展将任何可迭代对象转换为一系列数组元素。例如：
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The conversion works because the DOM collection is iterable.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 转换起作用是因为DOM集合是可迭代的。
- en: 31.6.2 Converting iterables and Array-like objects to Arrays via `Array.from()`
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.6.2 通过`Array.from()`将可迭代对象和类数组对象转换为数组
- en: '`Array.from()` can be used in two modes.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.from()`可以以两种模式使用。'
- en: '31.6.2.1 Mode 1 of `Array.from()`: converting'
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 31.6.2.1 `Array.from()`的模式1：转换
- en: 'The first mode has the following type signature:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种模式具有以下类型签名：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Interface `Iterable` is shown [in the chapter on synchronous iteration](ch_sync-iteration.html#iterable-iterator-iteratorresult).
    Interface `ArrayLike` appeared [earlier in this chapter](ch_arrays.html#array-like-objects).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterable`接口显示在[同步迭代章节](ch_sync-iteration.html#iterable-iterator-iteratorresult)。`ArrayLike`接口出现在[本章前面](ch_arrays.html#array-like-objects)。'
- en: 'With a single parameter, `Array.from()` converts anything iterable or Array-like
    to an Array:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个参数，`Array.from()`将任何可迭代对象或类数组转换为数组：
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '31.6.2.2 Mode 2 of `Array.from()`: converting and mapping'
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 31.6.2.2 `Array.from()`的模式2：转换和映射
- en: 'The second mode of `Array.from()` involves two parameters:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.from()`的第二种模式涉及两个参数：'
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In this mode, `Array.from()` does several things:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模式下，`Array.from()`做了几件事：
- en: It iterates over `iterable`.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它遍历`iterable`。
- en: It calls `mapFunc` with each iterated value. The optional parameter `thisArg`
    specifies a `this` for `mapFunc`.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它调用`mapFunc`与每个迭代的值。可选参数`thisArg`指定了`mapFunc`的`this`。
- en: It applies `mapFunc` to each iterated value.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将`mapFunc`应用于每个迭代的值。
- en: It collects the results in a new Array and returns it.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将结果收集到一个新数组中并返回它。
- en: 'In other words: we are going from an iterable with elements of type `T` to
    an Array with elements of type `U`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：我们从类型为`T`的可迭代元素转换为类型为`U`的数组。
- en: 'This is an example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 31.7 Creating and filling Arrays with arbitrary lengths
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.7 创建和填充任意长度的数组
- en: 'The best way of creating an Array is via an Array literal. However, we can’t
    always use one: The Array may be too large, we may not know its length during
    development, or we may want to keep its length flexible. Then I recommend the
    following techniques for creating, and possibly filling, Arrays.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组的最佳方式是通过数组字面量。但是，我们并不总是能够使用数组字面量：数组可能太大，我们可能在开发过程中不知道其长度，或者我们可能希望保持其长度的灵活性。那么我推荐以下技术来创建和可能填充数组。
- en: 31.7.1 Do we need to create an empty Array that we’ll fill completely later
    on?
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.7.1 我们需要创建一个稍后完全填充的空数组吗？
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that the result has three [*holes* (empty slots)](ch_arrays.html#array-holes)
    – the last comma in an Array literal is always ignored.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，结果有三个[*holes*（空槽）](ch_arrays.html#array-holes) - 数组字面量中的最后一个逗号总是被忽略。
- en: 31.7.2 Do we need to create an Array filled with a primitive value?
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.7.2 我们需要创建一个填充有原始值的数组吗？
- en: '[PRE49]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Caveat: If we use `.fill()` with an object, then each Array element will refer
    to this object (sharing it).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果我们使用`.fill()`与一个对象，那么每个数组元素将引用此对象（共享它）。
- en: '[PRE50]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The next subsection explains how to fix this.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节将解释如何修复这个问题。
- en: 31.7.3 Do we need to create an Array filled with objects?
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.7.3 我们需要创建一个填充有对象的数组吗？
- en: '[PRE51]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'For large sizes, the temporary Array can consume quite a bit of memory. The
    following approach doesn’t have this downside but is less self-descriptive:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大尺寸，临时数组可能会消耗大量内存。以下方法没有这个缺点，但是不够自描述：
- en: '[PRE52]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Instead of a temporary Array, we are using a temporary [Array-like object](ch_arrays.html#array-like-objects).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用临时的[类数组对象](ch_arrays.html#array-like-objects)而不是临时数组。
- en: 31.7.4 Do we need to create a range of integers?
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.7.4 我们需要创建一个整数范围吗？
- en: '[PRE53]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here is an alternative, slightly hacky technique for creating integer ranges
    that start at zero:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个替代的、稍微巧妙的创建以零开头的整数范围的技术：
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This works because `.keys()` treats [*holes*](ch_arrays.html#array-holes) like
    `undefined` elements and lists their indices.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`.keys()`将[*holes*](ch_arrays.html#array-holes)视为`undefined`元素并列出它们的索引。
- en: 31.7.5 Use a Typed Array if the elements are all integers or all floats
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.7.5 如果元素都是整数或浮点数，使用Typed Array
- en: When dealing with Arrays of integers or floats, we should consider [*Typed Arrays*](ch_typed-arrays.html),
    which were created for this purpose.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理整数或浮点数数组时，我们应该考虑[*Typed Arrays*](ch_typed-arrays.html)，这是为此目的而创建的。
- en: 31.8 Multidimensional Arrays
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.8 多维数组
- en: 'JavaScript does not have real multidimensional Arrays; we need to resort to
    Arrays whose elements are Arrays:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript没有真正的多维数组；我们需要求助于其元素为数组的数组：
- en: '[PRE55]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 31.9 More Array features (advanced)
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.9 更多数组特性（高级）
- en: In this section, we look at phenomena we don’t encounter often when working
    with Arrays.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究在使用数组时不经常遇到的现象。
- en: 31.9.1 Array indices are (slightly special) property keys
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.9.1 数组索引是（稍微特殊的）属性键
- en: 'You’d think that Array elements are special because we are accessing them via
    numbers. But the square brackets operator `[]` for doing so is the same operator
    that is used for accessing properties. It coerces any value (that is not a symbol)
    to a string. Therefore, Array elements are (almost) normal properties (line A)
    and it doesn’t matter if we use numbers or strings as indices (lines B and C):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为数组元素很特殊，因为我们是通过数字访问它们的。但是用于这样做的方括号运算符`[]`与用于访问属性的运算符相同。它将任何值（不是符号）强制转换为字符串。因此，数组元素（几乎）是正常属性（A行），并且使用数字或字符串作为索引并不重要（B和C行）：
- en: '[PRE56]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: To make matters even more confusing, this is only how the language specification
    defines things (the theory of JavaScript, if you will). Most JavaScript engines
    optimize under the hood and do use actual integers to access Array elements (the
    practice of JavaScript, if you will).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 更让事情变得更加混乱的是，这只是语言规范定义事物的方式（如果你愿意的话，这是JavaScript的理论）。大多数JavaScript引擎在幕后进行优化，并确实使用实际的整数来访问数组元素（如果你愿意的话，这是JavaScript的实践）。
- en: 'Property keys (strings!) that are used for Array elements are called [*indices*](https://tc39.github.io/ecma262/#integer-index).
    A string `str` is an index if converting it to a 32-bit unsigned integer and back
    results in the original value. Written as a formula:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 用于数组元素的属性键（字符串！）称为[*索引*](https://tc39.github.io/ecma262/#integer-index)。如果将字符串`str`转换为32位无符号整数，然后再转换回原始值，则该字符串是一个索引。写成一个公式：
- en: '[PRE57]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 31.9.1.1 Listing indices
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 31.9.1.1 列出索引
- en: 'When listing property keys, [indices are treated specially](ch_objects.html#order-of-properties)
    – they always come first and are sorted like numbers (`''2''` comes before `''10''`):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在列出属性键时，[索引被特殊对待](ch_objects.html#order-of-properties) – 它们总是首先出现，并且像数字一样排序（`'2'`出现在`'10'`之前）：
- en: '[PRE58]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Note that `.length`, `.entries()` and `.keys()` treat Array indices as numbers
    and ignore non-index properties:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`.length`，`.entries()`和`.keys()`将数组索引视为数字，并忽略非索引属性：
- en: '[PRE59]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We used [`Array.from()`](ch_arrays.html#Array.from) to convert the iterables
    returned by `.keys()` and `.entries()` to Arrays.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用[`Array.from()`](ch_arrays.html#Array.from)将`.keys()`和`.entries()`返回的可迭代对象转换为数组。
- en: 31.9.2 Arrays are dictionaries and can have holes
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.9.2 数组是字典，可以有空洞
- en: 'We distinguish two kinds of Arrays in JavaScript:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在JavaScript中区分两种数组：
- en: An Array `arr` is *dense* if all indices `i`, with 0 ≤ `i` < `arr.length`, exist.
    That is, the indices form a contiguous range.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果所有索引`i`，其中0 ≤ `i` < `arr.length`，都存在，则数组`arr`是*密集的*。也就是说，索引形成一个连续的范围。
- en: An Array is *sparse* if the range of indices has *holes* in it. That is, some
    indices are missing.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果索引范围中有*空洞*，则数组是*稀疏的*。也就是说，一些索引是缺失的。
- en: Arrays can be sparse in JavaScript because Arrays are actually dictionaries
    from indices to values.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的数组可以是稀疏的，因为数组实际上是从索引到值的字典。
- en: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png)  **Recommendation: avoid
    holes**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐：避免空洞
- en: 'So far, we have only seen dense Arrays and it’s indeed recommended to avoid
    holes: They make our code more complicated and are not handled consistently by
    Array methods. Additionally, JavaScript engines optimize dense Arrays, making
    them faster.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了密集的数组，确实建议避免空洞：它们使我们的代码更加复杂，并且数组方法处理不一致。此外，JavaScript引擎优化了密集数组，使它们更快。
- en: 31.9.2.1 Creating holes
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 31.9.2.1 创建空洞
- en: 'We can create holes by skipping indices when assigning elements:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当分配元素时，我们可以通过跳过索引来创建空洞：
- en: '[PRE60]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In line A, we are using `Object.keys()` because `arr.keys()` treats holes as
    if they were `undefined` elements and does not reveal them.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在A行，我们使用`Object.keys()`，因为`arr.keys()`将空洞视为`undefined`元素，并且不会显示它们。
- en: 'Another way of creating holes is to skip elements in Array literals:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 创建空洞的另一种方法是跳过数组文字中的元素：
- en: '[PRE61]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can also delete Array elements:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以删除数组元素：
- en: '[PRE62]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 31.9.2.2 How do Array operations treat holes?
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 31.9.2.2 数组操作如何处理空洞？
- en: Alas, there are many different ways in which Array operations treat holes.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，数组操作处理空洞的方式有很多不同。
- en: 'Some Array operations remove holes:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数组操作会删除空洞：
- en: '[PRE63]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Some Array operations ignore holes:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数组操作会忽略空洞：
- en: '[PRE64]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Some Array operations ignore but preserve holes:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数组操作会忽略但保留空洞：
- en: '[PRE65]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Some Array operations treat holes as `undefined` elements:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数组操作将空洞视为`undefined`元素：
- en: '[PRE66]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`Object.keys()` works differently than `.keys()` (strings vs. numbers, holes
    don’t have keys):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.keys()`的工作方式与`.keys()`不同（字符串vs. 数字，空洞没有键）：'
- en: '[PRE67]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: There is no rule to remember here. If it ever matters how an Array operation
    treats holes, the best approach is to do a quick test in a console.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有规则需要记住。如果数组操作如何处理空洞很重要，最好的方法是在控制台中进行快速测试。
- en: 31.10 Adding and removing elements (destructively and non-destructively)
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.10 添加和删除元素（破坏性和非破坏性）
- en: JavaScript’s `Array` is quite flexible and more like a combination of array,
    stack, and queue. This section explores ways of adding and removing Array elements.
    Most operations can be performed both *destructively* (modifying the Array) and
    *non-destructively* (producing a modified copy).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的`Array`非常灵活，更像是数组、堆栈和队列的组合。本节探讨了添加和删除数组元素的方法。大多数操作都可以进行*破坏性*（修改数组）和*非破坏性*（生成修改后的副本）。
- en: 31.10.1 Prepending elements and Arrays
  id: totrans-279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.10.1 前置元素和数组
- en: 'In the following code, we destructively prepend single elements to `arr1` and
    an Array to `arr2`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们破坏性地将单个元素前置到`arr1`，并将数组前置到`arr2`：
- en: '[PRE68]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Spreading lets us unshift an Array into `arr2`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展让我们将一个数组推入`arr2`。
- en: 'Non-destructive prepending is done via spread elements:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展元素进行非破坏性的前置：
- en: '[PRE69]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 31.10.2 Appending elements and Arrays
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.10.2 附加元素和数组
- en: 'In the following code, we destructively append single elements to `arr1` and
    an Array to `arr2`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们破坏性地将单个元素附加到`arr1`，并将数组附加到`arr2`：
- en: '[PRE70]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Spreading (`...`) lets us push an Array into `arr2` (line A).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展（`...`）让我们将一个数组推入`arr2`（A行）。
- en: 'Non-destructive appending is done via spread elements:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展元素进行非破坏性的附加：
- en: '[PRE71]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 31.10.3 Removing elements
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.10.3 删除元素
- en: 'These are three destructive ways of removing Array elements:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是移除数组元素的三种破坏性方式：
- en: '[PRE72]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`.splice()` is covered in more detail in [the quick reference at the end of
    this chapter](ch_arrays.html#quickref-array-prototype).'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`.splice()`在[本章末尾的快速参考](ch_arrays.html#quickref-array-prototype)中有更详细的介绍。'
- en: Destructuring via a rest element lets us non-destructively remove elements from
    the beginning of an Array (destructuring is covered [later](ch_destructuring.html)).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 通过剩余元素的解构，我们可以非破坏性地从数组的开头移除元素（解构在[后面](ch_destructuring.html)有介绍）。
- en: '[PRE73]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Alas, a rest element must come last in an Array. Therefore, we can only use
    it to extract suffixes.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，剩余元素必须在数组中的最后。因此，我们只能用它来提取后缀。
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Implementing
    a queue via an Array**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](../Images/90f73f1851c5b1baf43cb746913c09e6.png) **练习：通过数组实现队列**
- en: '`exercises/arrays/queue_via_array_test.mjs`'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/arrays/queue_via_array_test.mjs`'
- en: '31.11 Methods: iteration and transformation (`.find()`, `.map()`, `.filter()`,
    etc.)'
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.11 方法：迭代和转换（`.find()`，`.map()`，`.filter()`等）
- en: In this section, we take a look at Array methods for iterating over Arrays and
    for transforming Arrays.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍用于迭代数组和转换数组的数组方法。
- en: 31.11.1 Callbacks for iteration and transformation methods
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.11.1 迭代和转换方法的回调
- en: All iteration and transformation methods use callbacks. The former feed all
    iterated values to their callbacks; the latter ask their callbacks how to transform
    Arrays.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 所有迭代和转换方法都使用回调。前者将所有迭代值传递给它们的回调；后者询问它们的回调如何转换数组。
- en: 'These callbacks have type signatures that look as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这些回调的类型签名如下：
- en: '[PRE74]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'That is, the callback gets three parameters (it is free to ignore any of them):'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，回调有三个参数（可以自由忽略其中任何一个）：
- en: '`value` is the most important one. This parameter holds the iterated value
    that is currently being processed.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`是最重要的。此参数保存当前正在处理的迭代值。'
- en: '`index` can additionally tell the callback what the index of the iterated value
    is.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`还可以告诉回调迭代值的索引。'
- en: '`array` points to the current Array (the receiver of the method call). Some
    algorithms need to refer to the whole Array – e.g., to search it for answers.
    This parameter lets us write reusable callbacks for such algorithms.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array`指向当前数组（方法调用的接收者）。有些算法需要引用整个数组，例如搜索答案。此参数使我们能够为这些算法编写可重用的回调。'
- en: 'What the callback is expected to return depends on the method it is passed
    to. Possibilities include:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 回调预期返回的内容取决于传递给它的方法。可能的情况包括：
- en: '`.map()` fills its result with the values returned by its callback:'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.map()`用其回调返回的值填充其结果：'
- en: '[PRE75]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`.find()` returns the first Array element for which its callback returns `true`:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.find()`返回其回调返回`true`的第一个数组元素：'
- en: '[PRE76]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Both of these methods are described in more detail later.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法稍后将更详细地描述。
- en: '31.11.2 Searching elements: `.find()`, `.findIndex()`'
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.11.2 搜索元素：`.find()`，`.findIndex()`
- en: '`.find()` returns the first element for which its callback returns a truthy
    value (and `undefined` if it can’t find anything):'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`.find()`返回其回调返回真值的第一个元素（如果找不到任何内容，则返回`undefined`）：'
- en: '[PRE77]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '`.findIndex()` returns the index of the first element for which its callback
    returns a truthy value (and `-1` if it can’t find anything):'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`.findIndex()`返回其回调返回真值的第一个元素的索引（如果找不到任何内容，则返回`-1`）：'
- en: '[PRE78]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '`.findIndex()` can be implemented as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`.findIndex()`可以实现如下：'
- en: '[PRE79]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '31.11.3 `.map()`: copy while giving elements new values'
  id: totrans-323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.11.3 `.map()`：在给元素新值的同时复制
- en: '`.map()` returns a modified copy of the receiver. The elements of the copy
    are the results of applying `map`’s callback to the elements of the receiver.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`.map()`返回接收者的修改副本。副本的元素是将`map`的回调应用于接收者的元素的结果。'
- en: 'All of this is easier to understand via examples:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以通过示例更容易理解：
- en: '[PRE80]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '`.map()` can be implemented as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`.map()`可以实现如下：'
- en: '[PRE81]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Numbering
    lines via `.map()`**'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](../Images/90f73f1851c5b1baf43cb746913c09e6.png) **练习：通过`.map()`编号行**
- en: '`exercises/arrays/number_lines_test.mjs`'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/arrays/number_lines_test.mjs`'
- en: '31.11.4 `.flatMap()`: mapping to zero or more values'
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.11.4 `.flatMap()`：映射到零个或多个值
- en: 'The type signature of `Array<T>.prototype.flatMap()` is:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array<T>.prototype.flatMap()`的类型签名是：'
- en: '[PRE82]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Both `.map()` and `.flatMap()` take a function `callback` as a parameter that
    controls how an input Array is translated to an output Array:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`.map()`和`.flatMap()`都接受一个函数`callback`作为参数，控制如何将输入数组转换为输出数组：'
- en: With `.map()`, each input Array element is translated to exactly one output
    element. That is, `callback` returns a single value.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`.map()`，每个输入数组元素都被转换为一个输出元素。也就是说，`callback`返回一个单一值。
- en: With `.flatMap()`, each input Array element is translated to zero or more output
    elements. That is, `callback` returns an Array of values (it can also return non-Array
    values, but that is rare).
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`.flatMap()`，每个输入数组元素都被转换为零个或多个输出元素。也就是说，`callback`返回一个值的数组（也可以返回非数组值，但这很少见）。
- en: 'This is `.flatMap()` in action:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`.flatMap()`的实际应用：
- en: '[PRE83]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We’ll consider use cases next, before exploring how this method could be implemented.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨如何实现此方法之前，我们将首先考虑使用情况。
- en: '31.11.4.1 Use case: filtering and mapping at the same time'
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 31.11.4.1 用例：同时过滤和映射
- en: The result of the Array method `.map()` always has the same length as the Array
    it is invoked on. That is, its callback can’t skip Array elements it isn’t interested
    in. The ability of `.flatMap()` to do so is useful in the next example.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 数组方法`.map()`的结果始终与调用它的数组长度相同。也就是说，它的回调不能跳过它不感兴趣的数组元素。`.flatMap()`具有这样做的能力，在下一个示例中非常有用。
- en: 'We will use the following function `processArray()` to create an Array that
    we’ll then filter and map via `.flatMap()`:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下函数`processArray()`创建一个数组，然后通过`.flatMap()`进行过滤和映射：
- en: '[PRE84]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Next, we create an Array `results` via `processArray()`:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过`processArray()`创建一个数组`results`：
- en: '[PRE85]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We can now use `.flatMap()` to extract just the values or just the errors from
    `results`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`.flatMap()`来提取`results`中的值或错误：
- en: '[PRE86]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '31.11.4.2 Use case: mapping single input values to multiple output values'
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 31.11.4.2 用例：将单个输入值映射到多个输出值
- en: The Array method `.map()` maps each input Array element to one output element.
    But what if we want to map it to multiple output elements?
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 数组方法`.map()`将每个输入数组元素映射到一个输出元素。但是如果我们想要将其映射到多个输出元素呢？
- en: 'That becomes necessary in the following example:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下示例中变得必要：
- en: '[PRE87]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We want to convert an Array of strings to an Array of Unicode characters (code
    points). The following function achieves that via `.flatMap()`:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要将字符串数组转换为Unicode字符（代码点）数组。以下函数通过`.flatMap()`实现了这一点：
- en: '[PRE88]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 31.11.4.3 A simple implementation
  id: totrans-354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 31.11.4.3 一个简单的实现
- en: 'We can implement `.flatMap()` as follows. Note: This implementation is simpler
    than the built-in version, which, for example, performs more checks.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下实现`.flatMap()`。注意：这个实现比内置版本更简单，例如，执行了更多的检查。
- en: '[PRE89]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercises: `.flatMap()`**'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png) **练习：`.flatMap()`**'
- en: '`exercises/arrays/convert_to_numbers_test.mjs`'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exercises/arrays/convert_to_numbers_test.mjs`'
- en: '`exercises/arrays/replace_objects_test.mjs`'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exercises/arrays/replace_objects_test.mjs`'
- en: '31.11.5 `.filter()`: only keep some of the elements'
  id: totrans-360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '31.11.5 `.filter()`: 仅保留一些元素'
- en: The Array method `.filter()` returns an Array collecting all elements for which
    the callback returns a truthy value.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 数组方法`.filter()`返回一个数组，其中收集了回调返回真值的所有元素。
- en: 'For example:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE90]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '`.filter()` can be implemented as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`.filter()`可以如下实现：'
- en: '[PRE91]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Removing empty
    lines via `.filter()`**'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png) **练习：通过`.filter()`删除空行**'
- en: '`exercises/arrays/remove_empty_lines_filter_test.mjs`'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/arrays/remove_empty_lines_filter_test.mjs`'
- en: '31.11.6 `.reduce()`: deriving a value from an Array (advanced)'
  id: totrans-368
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '31.11.6 `.reduce()`: 从数组中派生值（高级）'
- en: 'Method `.reduce()` is a powerful tool for computing a “summary” of an Array
    `arr`. A summary can be any kind of value:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`.reduce()`是计算数组`arr`的“摘要”的强大工具。摘要可以是任何类型的值：
- en: A number. For example, the sum of all elements of `arr`.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数字。例如，`arr`的所有元素的总和。
- en: An Array. For example, a copy of `arr`, where each element is twice the original
    element.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数组。例如，`arr`的副本，其中每个元素都是原始元素的两倍。
- en: Etc.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等等。
- en: '`reduce` is also known as `foldl` (“fold left”) in functional programming and
    popular there. One caveat is that it can make code difficult to understand.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`在函数式编程中也被称为`foldl`（“从左向右折叠”），并且在那里很受欢迎。一个警告是它可能使代码难以理解。'
- en: '`.reduce()` has the following type signature (inside an `Array<T>`):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`.reduce()`具有以下类型签名（在`Array<T>`中）：'
- en: '[PRE92]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '`T` is the type of the Array elements, `U` is the type of the summary. The
    two may or may not be different. `accumulator` is just another name for “summary”.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`T`是数组元素的类型，`U`是摘要的类型。这两者可能相同，也可能不同。`accumulator`只是“summary”的另一个名称。'
- en: 'To compute the summary of an Array `arr`, `.reduce()` feeds all Array elements
    to its callback one at a time:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算数组`arr`的摘要，`.reduce()`将所有数组元素逐个传递给它的回调函数：
- en: '[PRE93]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '`callback` combines the previously computed summary (stored in its parameter
    `accumulator`) with the current Array element and returns the next `accumulator`.
    The result of `.reduce()` is the final accumulator – the last result of `callback`
    after it has visited all elements.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`callback`将先前计算的摘要（存储在其参数`accumulator`中）与当前数组元素组合，并返回下一个`accumulator`。`.reduce()`的结果是最终的累加器
    - 在访问所有元素后`callback`的最后结果。'
- en: 'In other words: `callback` does most of the work; `.reduce()` just invokes
    it in a useful manner.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：`callback` 承担了大部分工作；`.reduce()` 只是以一种有用的方式调用它。
- en: We could say that the callback folds Array elements into the accumulator. That’s
    why this operation is called “fold” in functional programming.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说回调将数组元素折叠到累加器中。这就是为什么这个操作在函数式编程中被称为“折叠”的原因。
- en: 31.11.6.1 A first example
  id: totrans-382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 31.11.6.1 第一个例子
- en: 'Let’s look at an example of `.reduce()` in action: function `addAll()` computes
    the sum of all numbers in an Array `arr`.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个`.reduce()`的示例：函数`addAll()`计算数组`arr`中所有数字的总和。
- en: '[PRE94]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: In this case, the accumulator holds the sum of all Array elements that `callback`
    has already visited.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，累加器保存了`callback`已经访问过的所有数组元素的总和。
- en: 'How was the result `6` derived from the Array in line A? Via the following
    invocations of `callback`:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在A行中，结果`6`是如何从数组中派生出来的？通过以下对`callback`的调用：
- en: '[PRE95]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Notes:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 注：
- en: The first parameters are the current accumulators (starting with parameter `init`
    of `.reduce()`).
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是当前累加器（从`.reduce()`的参数`init`开始）。
- en: The second parameters are the current Array elements.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是当前数组元素。
- en: The results are the next accumulators.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果是下一个累加器。
- en: The last result of `callback` is also the result of `.reduce()`.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback`的最后结果也是`.reduce()`的结果。'
- en: 'Alternatively, we could have implemented `addAll()` via a `for-of` loop:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过`for-of`循环来实现`addAll()`：
- en: '[PRE96]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'It’s hard to say which of the two implementations is “better”: the one based
    on `.reduce()` is a little more concise, while the one based on `for-of` may be
    a little easier to understand – especially if someone is not familiar with functional
    programming.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 很难说哪种实现“更好”：基于`.reduce()`的实现更加简洁，而基于`for-of`的实现可能更容易理解 - 尤其是对于不熟悉函数式编程的人来说。
- en: '31.11.6.2 Example: finding indices via `.reduce()`'
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 31.11.6.2 通过`.reduce()`查找索引的示例
- en: 'The following function is an implementation of the Array method `.indexOf()`.
    It returns the first index at which the given `searchValue` appears inside the
    Array `arr`:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数是数组方法`.indexOf()`的实现。它返回给定的`searchValue`在数组`arr`中第一次出现的索引：
- en: '[PRE97]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: One limitation of `.reduce()` is that we can’t finish early (in a `for-of` loop,
    we can `break`). Here, we always immediately return the result once we have found
    it.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`.reduce()`的一个限制是我们无法提前完成（在`for-of`循环中，我们可以`break`）。在这里，一旦找到结果，我们总是立即返回结果。'
- en: '31.11.6.3 Example: doubling Array elements'
  id: totrans-400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 31.11.6.3 例子：数组元素加倍
- en: 'Function `double(arr)` returns a copy of `inArr` whose elements are all multiplied
    by 2:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`double(arr)`返回`inArr`的副本，其中的每个元素都乘以2：
- en: '[PRE98]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We modify the initial value `[]` by pushing into it. A non-destructive, more
    functional version of `double()` looks as follows:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将其推入来修改初始值`[]`。`double()`的非破坏性、更加功能性的版本如下：
- en: '[PRE99]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: This version is more elegant but also slower and uses more memory.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本更加优雅，但也更慢，使用的内存更多。
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercises: `.reduce()`**'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png) **练习：`.reduce()`**'
- en: '`map()` via `.reduce()`: `exercises/arrays/map_via_reduce_test.mjs`'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`.reduce()`进行`map()`：`exercises/arrays/map_via_reduce_test.mjs`
- en: '`filter()` via `.reduce()`: `exercises/arrays/filter_via_reduce_test.mjs`'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`.reduce()`进行`filter()`：`exercises/arrays/filter_via_reduce_test.mjs`
- en: '`countMatches()` via `.reduce()`: `exercises/arrays/count_matches_via_reduce_test.mjs`'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`.reduce()`计算`countMatches()`：`exercises/arrays/count_matches_via_reduce_test.mjs`
- en: '31.12 `.sort()`: sorting Arrays'
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '31.12 `.sort()`: 排序数组'
- en: '`.sort()` has the following type definition:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`.sort()`具有以下类型定义：'
- en: '[PRE100]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'By default, `.sort()` sorts string representations of the elements. These representations
    are compared via `<`. This operator compares *lexicographically* (the first characters
    are most significant). We can see that when sorting numbers:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`.sort()`对元素的字符串表示进行排序。这些表示通过`<`进行比较。这个操作符进行*词典顺序*比较（第一个字符最重要）。我们可以看到在对数字进行排序时：
- en: '[PRE101]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'When sorting human-language strings, we need to be aware that they are compared
    according to their code unit values (char codes):'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在对人类语言字符串进行排序时，我们需要意识到它们是根据它们的代码单元值（字符代码）进行比较的：
- en: '[PRE102]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: All unaccented uppercase letters come before all unaccented lowercase letters,
    which come before all accented letters. We can use `Intl`, [the JavaScript internationalization
    API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl)
    if we want proper sorting for human languages.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 所有无重音的大写字母都排在所有无重音的小写字母之前，后者排在所有重音字母之前。如果我们想要人类语言的正确排序，我们可以使用`Intl`，[JavaScript国际化API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl)。
- en: '`.sort()` sorts *in place*; it changes and returns its receiver:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`.sort()`就地排序；它会更改并返回其接收者：'
- en: '[PRE103]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 31.12.1 Customizing the sort order
  id: totrans-420
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.12.1 自定义排序顺序
- en: 'We can customize the sort order via the parameter `compareFunc`, which must
    return a number that is:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过参数`compareFunc`自定义排序顺序，该参数必须返回一个数字，即：
- en: negative if `a < b`
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`a < b`则为负
- en: zero if `a === b`
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`a === b`则为零
- en: positive if `a > b`
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`a > b`则为正
- en: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png)  **Tip for remembering
    these rules**'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png) **记住这些规则的提示**'
- en: A negative number is *less than* zero (etc.).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 负数*小于*零（等等）。
- en: 31.12.2 Sorting numbers
  id: totrans-427
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.12.2 排序数字
- en: 'We can use this helper function to sort numbers:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个辅助函数来排序数字：
- en: '[PRE104]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The following is a quick and dirty alternative.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个快速而肮脏的替代方法。
- en: '[PRE105]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The downsides of this approach are:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是：
- en: It is cryptic.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是神秘的。
- en: There is a risk of numeric overflow or underflow, if `a-b` becomes a large positive
    or negative number.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`a-b`变成一个很大的正数或负数，就会有数值溢出或下溢的风险。
- en: 31.12.3 Sorting objects
  id: totrans-435
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.12.3 排序对象
- en: We also need to use a compare function if we want to sort objects. As an example,
    the following code shows how to sort objects by age.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要对对象进行排序，我们还需要使用比较函数。例如，以下代码显示了如何按年龄对对象进行排序。
- en: '[PRE106]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Sorting objects
    by name**'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png) **练习：按名称对对象进行排序**'
- en: '`exercises/arrays/sort_objects_test.mjs`'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/arrays/sort_objects_test.mjs`'
- en: '31.13 Quick reference: `Array`'
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.13 `Array`快速参考
- en: 'Legend:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 传奇：
- en: '`R`: method does not change the Array (non-destructive).'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R`：方法不改变数组（非破坏性）。'
- en: '`W`: method changes the Array (destructive).'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`W`：方法改变了数组（破坏性）。'
- en: 31.13.1 `new Array()`
  id: totrans-444
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.13.1 `new Array()`
- en: '`new Array(n)` creates an Array of length `n` that contains `n` holes:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`new Array(n)`创建一个包含`n`个空位的长度为`n`的数组：'
- en: '[PRE107]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '`new Array()` creates an empty Array. However, I recommend to always use `[]`
    instead.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`new Array()`创建一个空数组。但是，我建议始终使用`[]`。'
- en: 31.13.2 Static methods of `Array`
  id: totrans-448
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.13.2 `Array`的静态方法
- en: '`Array.from<T>(iterable: Iterable<T> | ArrayLike<T>): T[]` ^([ES6])'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.from<T>(iterable: Iterable<T> | ArrayLike<T>): T[]` ^([ES6])'
- en: '`Array.from<T,U>(iterable: Iterable<T> | ArrayLike<T>, mapFunc: (v: T, k: number)
    => U, thisArg?: any): U[]` ^([ES6])'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.from<T,U>(iterable: Iterable<T> | ArrayLike<T>, mapFunc: (v: T, k: number)
    => U, thisArg?: any): U[]` ^([ES6])'
- en: Converts an iterable or [an Array-like object](ch_arrays.html#array-like-objects)
    to an Array. Optionally, the input values can be translated via `mapFunc` before
    they are added to the output Array.
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将可迭代对象或[类数组对象](ch_arrays.html#array-like-objects)转换为数组。可选地，输入值可以在添加到输出数组之前通过`mapFunc`进行转换。
- en: 'Examples:'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例子：
- en: '[PRE108]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '`Array.of<T>(...items: T[]): T[]` ^([ES6])'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.of<T>(...items: T[]): T[]` ^([ES6])'
- en: 'This static method is mainly useful for subclasses of `Array`, where it serves
    as a custom Array literal:'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个静态方法主要用于`Array`的子类，它作为自定义数组文字：
- en: '[PRE109]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 31.13.3 Methods of `Array.prototype`
  id: totrans-457
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.13.3 `Array.prototype`的方法
- en: '`.at(index: number): T | undefined` ^([R, ES2022])'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.at(index: number): T | undefined` ^([R, ES2022])'
- en: Returns the Array element at `index`. If `index` is negative, it is added to
    `.length` before it is used (`-1` becomes `this.length-1`, etc.).
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回`index`处的数组元素。如果`index`为负，则在使用之前将其添加到`.length`（`-1`变为`this.length-1`等）。
- en: '[PRE110]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '`.concat(...items: Array<T[] | T>): T[]` ^([R, ES3])'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.concat(...items: Array<T[] | T>): T[]` ^([R, ES3])'
- en: Returns a new Array that is the concatenation of the receiver and all `items`.
    Non-Array parameters (such as `'b'` in the following example) are treated as if
    they were Arrays with single elements.
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回一个新的数组，该数组是接收者和所有`items`的连接。非数组参数（例如以下示例中的`'b'`）将被视为具有单个元素的数组。
- en: '[PRE111]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '`.copyWithin(target: number, start: number, end=this.length): this` ^([W, ES6])'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.copyWithin(target: number, start: number, end=this.length): this` ^([W, ES6])'
- en: Copies the elements whose indices range from (including) `start` to (excluding)
    `end` to indices starting with `target`. Overlapping is handled correctly.
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将索引范围从（包括）`start`到（不包括）`end`的元素复制到以`target`开头的索引。重叠部分被正确处理。
- en: '[PRE112]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: If `start` or `end` is negative, then `.length` is added to it.
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`start`或`end`为负数，则将其添加到`.length`。
- en: '`.entries(): Iterable<[number, T]>` ^([R, ES6])'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.entries(): Iterable<[number, T]>` ^([R, ES6])'
- en: Returns an iterable over [index, element] pairs.
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回一个可迭代的[index, element]对。
- en: '[PRE113]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '`.every(callback: (value: T, index: number, array: Array<T>) => boolean, thisArg?:
    any): boolean` ^([R, ES5])'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if `callback` returns a truthy value for every element. Otherwise,
    it returns `false`. It stops as soon as it receives a falsy value. This method
    corresponds to universal quantification (“for all”, `∀`) in mathematics.
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Related method: `.some()` (“exists”).'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.fill(value: T, start=0, end=this.length): this` ^([W, ES6])'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigns `value` to every index between (including) `start` and (excluding) `end`.
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Caveat: Don’t use this method to fill an Array with an object `obj`; then each
    element will refer to `obj` (sharing it). In this case, it’s better to [use `Array.from()`](ch_arrays.html#filling-arrays).'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.filter(callback: (value: T, index: number, array: Array<T>) => any, thisArg?:
    any): T[]` ^([R, ES5])'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns an Array with only those elements for which `callback` returns a truthy
    value.
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '`.find(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?:
    any): T | undefined` ^([R, ES6])'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result is the first element for which `predicate` returns a truthy value.
    If there is no such element, the result is `undefined`.
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '`.findIndex(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?:
    any): number` ^([R, ES6])'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result is the index of the first element for which `predicate` returns a
    truthy value. If there is no such element, the result is `-1`.
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '`.flat(depth = 1): any[]` ^([R, ES2019])'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '“Flattens” an Array: It descends into the Arrays that are nested inside the
    input Array and creates a copy where all values it finds at level `depth` or lower
    are moved to the top level.'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '`.flatMap<U>(callback: (value: T, index: number, array: T[]) => U|Array<U>,
    thisValue?: any): U[]` ^([R, ES2019])'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result is produced by invoking `callback()` for each element of the original
    Array and concatenating the Arrays it returns.
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '`.forEach(callback: (value: T, index: number, array: Array<T>) => void, thisArg?:
    any): void` ^([R, ES5])'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls `callback` for each element.
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'A `for-of` loop is usually a better choice: it’s faster, supports `break` and
    can iterate over arbitrary iterables.'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.includes(searchElement: T, fromIndex=0): boolean` ^([R, ES2016])'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if the receiver has an element whose value is `searchElement`
    and `false`, otherwise. Searching starts at index `fromIndex`.
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '`.indexOf(searchElement: T, fromIndex=0): number` ^([R, ES5])'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the index of the first element that is strictly equal to `searchElement`.
    Returns `-1` if there is no such element. Starts searching at index `fromIndex`,
    visiting higher indices next.
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '`.join(separator = '',''): string` ^([R, ES1])'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a string by concatenating string representations of all elements, separating
    them with `separator`.
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '`.keys(): Iterable<number>` ^([R, ES6])'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns an iterable over the keys of the receiver.
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '`.lastIndexOf(searchElement: T, fromIndex=this.length-1): number` ^([R, ES5])'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the index of the last element that is strictly equal to `searchElement`.
    Returns `-1` if there is no such element. Starts searching at index `fromIndex`,
    visiting lower indices next.
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '`.map<U>(mapFunc: (value: T, index: number, array: Array<T>) => U, thisArg?:
    any): U[]` ^([R, ES5])'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a new Array, in which every element is the result of `mapFunc` being
    applied to the corresponding element of the receiver.
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '`.pop(): T | undefined` ^([W, ES3])'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removes and returns the last element of the receiver. That is, it treats the
    end of the receiver as a stack. The opposite of `.push()`.
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '`.push(...items: T[]): number` ^([W, ES3])'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds zero or more `items` to the end of the receiver. That is, it treats the
    end of the receiver as a stack. The return value is the length of the receiver
    after the change. The opposite of `.pop()`.
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'We can push an Array by spreading (`...`) it into arguments:'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '`.reduce<U>(callback: (accumulator: U, element: T, index: number, array: T[])
    => U, init?: U): U` ^([R, ES5])'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This method produces a summary of the receiver: it feeds all Array elements
    to `callback`, which combines a current summary (in parameter `accumulator`) with
    the current Array element and returns the next `accumulator`:'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The result of `.reduce()` is the last result of `callback` after it has visited
    all Array elements.
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: If no `init` is provided, the Array element at index 0 is used and the element
    at index 1 is visited first. Therefore, the Array must have at least length 1.
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.reduceRight<U>(callback: (accumulator: U, element: T, index: number, array:
    T[]) => U, init?: U): U` ^([R, ES5])'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Works like `.reduce()`, but visits the Array elements backward, starting with
    the last element.
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '`.reverse(): this` ^([W, ES1])'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rearranges the elements of the receiver so that they are in reverse order and
    then returns the receiver.
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '`.shift(): T | undefined` ^([W, ES3])'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removes and returns the first element of the receiver. The opposite of `.unshift()`.
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '`.slice(start=0, end=this.length): T[]` ^([R, ES3])'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a new Array containing the elements of the receiver whose indices are
    between (including) `start` and (excluding) `end`.
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Negative indices are allowed and added to `.length`:'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '`.some(callback: (value: T, index: number, array: Array<T>) => boolean, thisArg?:
    any): boolean` ^([R, ES5])'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if `callback` returns a truthy value for at least one element.
    Otherwise, it returns `false`. It stops as soon as it receives a truthy value.
    This method corresponds to existential quantification (“exists”, `∃`) in mathematics.
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Related method: `.every()` (“for all”).'
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.sort(compareFunc?: (a: T, b: T) => number): this` ^([W, ES1])'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sorts the receiver and returns it. By default, it sorts string representations
    of the elements. It does so lexicographically and according to the code unit values
    (char codes) of the characters:'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'We can customize the sort order via `compareFunc`, which returns a number that
    is:'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: negative if `a < b`
  id: totrans-552
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: zero if `a === b`
  id: totrans-553
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: positive if `a > b`
  id: totrans-554
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Trick for sorting numbers (with a risk of numeric overflow or underflow):'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **`.sort()` is stable**'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since ECMAScript 2019, sorting is guaranteed to be stable: if elements are
    considered equal by sorting, then sorting does not change the order of those elements
    (relative to each other).'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.splice(start: number, deleteCount=this.length-start, ...items: T[]): T[]`
    ^([W, ES3])'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At index `start`, it removes `deleteCount` elements and inserts the `items`.
    It returns the deleted elements.
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '`start` can be negative and is added to `.length` if it is:'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-563
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '`.toString(): string` ^([R, ES1])'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converts all elements to strings via `String()`, concatenates them while separating
    them with commas, and returns the result.
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '`.unshift(...items: T[]): number` ^([W, ES3])'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserts the `items` at the beginning of the receiver and returns its length
    after this modification.
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '`.values(): Iterable<T>` ^([R, ES6])'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns an iterable over the values of the receiver.
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 31.13.4 Sources
  id: totrans-573
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[TypeScript’s built-in typings](https://github.com/Microsoft/TypeScript/blob/master/lib/)'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MDN web docs for JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ECMAScript language specification](https://tc39.github.io/ecma262/)'
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz**'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/22)'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
