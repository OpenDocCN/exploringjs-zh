- en: 31 Arrays (Array)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/impatient-js/ch_arrays.html](https://exploringjs.com/impatient-js/ch_arrays.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '31.1 [Cheat sheet: Arrays](ch_arrays.html#cheat-sheet-arrays)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.1.1 [Using Arrays](ch_arrays.html#using-arrays)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.1.2 [Array methods](ch_arrays.html#array-methods)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.2 [The two ways of using Arrays in JavaScript](ch_arrays.html#ways-of-using-arrays)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.3 [Basic Array operations](ch_arrays.html#basic-array-operations)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.3.1 [Creating, reading, writing Arrays](ch_arrays.html#array-literals)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.3.2 [The `.length` of an Array](ch_arrays.html#the-.length-of-an-array)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.3.3 [Referring to elements via negative indices](ch_arrays.html#referring-to-elements-via-negative-indices)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.3.4 [Clearing Arrays](ch_arrays.html#clearing-arrays)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.3.5 [Spreading into Array literals [ES6]](ch_arrays.html#spreading-into-array-literals)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '31.3.6 [Arrays: listing indices and entries [ES6]](ch_arrays.html#arrays-listing-indices-and-entries-es6)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.3.7 [Is a value an Array?](ch_arrays.html#is-a-value-an-array)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.4 [`for-of` and Arrays [ES6]](ch_arrays.html#for-of-and-arrays-es6)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '31.4.1 [`for-of`: iterating over elements](ch_arrays.html#for-of-iterating-over-elements)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '31.4.2 [`for-of`: iterating over indices](ch_arrays.html#for-of-iterating-over-indices)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '31.4.3 [`for-of`: iterating over [index, element] pairs](ch_arrays.html#for-of-iterating-over-index-element-pairs)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.5 [Array-like objects](ch_arrays.html#array-like-objects)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.6 [Converting iterables and Array-like values to Arrays](ch_arrays.html#converting-to-array)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.6.1 [Converting iterables to Arrays via spreading (`...`)](ch_arrays.html#converting-iterables-to-arrays-via-spreading-...)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.6.2 [Converting iterables and Array-like objects to Arrays via `Array.from()`](ch_arrays.html#Array.from)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.7 [Creating and filling Arrays with arbitrary lengths](ch_arrays.html#filling-arrays)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.7.1 [Do we need to create an empty Array that we’ll fill completely later
    on?](ch_arrays.html#do-we-need-to-create-an-empty-array-that-well-fill-completely-later-on)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.7.2 [Do we need to create an Array filled with a primitive value?](ch_arrays.html#do-we-need-to-create-an-array-filled-with-a-primitive-value)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.7.3 [Do we need to create an Array filled with objects?](ch_arrays.html#creating-arrays-filled-with-objects)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.7.4 [Do we need to create a range of integers?](ch_arrays.html#create-range-of-integers)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.7.5 [Use a Typed Array if the elements are all integers or all floats](ch_arrays.html#use-a-typed-array-if-the-elements-are-all-integers-or-all-floats)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.8 [Multidimensional Arrays](ch_arrays.html#multidimensional-arrays)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.9 [More Array features (advanced)](ch_arrays.html#more-array-features-advanced)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.9.1 [Array indices are (slightly special) property keys](ch_arrays.html#array-indices)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.9.2 [Arrays are dictionaries and can have holes](ch_arrays.html#array-holes)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.10 [Adding and removing elements (destructively and non-destructively)](ch_arrays.html#adding-and-removing-elements-destructively-and-non-destructively)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.10.1 [Prepending elements and Arrays](ch_arrays.html#prepending-elements-and-arrays)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.10.2 [Appending elements and Arrays](ch_arrays.html#appending-elements-and-arrays)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.10.3 [Removing elements](ch_arrays.html#removing-elements)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '31.11 [Methods: iteration and transformation (`.find()`, `.map()`, `.filter()`,
    etc.)](ch_arrays.html#methods-iteration-and-transformation-.find-.map-.filter-etc.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.11.1 [Callbacks for iteration and transformation methods](ch_arrays.html#callbacks-for-iteration-and-transformation-methods)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '31.11.2 [Searching elements: `.find()`, `.findIndex()`](ch_arrays.html#searching-elements-.find-.findindex)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '31.11.3 [`.map()`: copy while giving elements new values](ch_arrays.html#map-copy-while-giving-elements-new-values)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '31.11.4 [`.flatMap()`: mapping to zero or more values](ch_arrays.html#Array.prototype.flatMap)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '31.11.5 [`.filter()`: only keep some of the elements](ch_arrays.html#filter-only-keep-some-of-the-elements)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '31.11.6 [`.reduce()`: deriving a value from an Array (advanced)](ch_arrays.html#Array.prototype.reduce)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '31.12 [`.sort()`: sorting Arrays](ch_arrays.html#Array.prototype.sort)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.12.1 [Customizing the sort order](ch_arrays.html#customizing-array-sorting)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.12.2 [Sorting numbers](ch_arrays.html#sorting-numbers)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.12.3 [Sorting objects](ch_arrays.html#sorting-objects)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '31.13 [Quick reference: `Array`](ch_arrays.html#quickref-array-api)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.13.1 [`new Array()`](ch_arrays.html#new-array)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.13.2 [Static methods of `Array`](ch_arrays.html#static-methods-of-array)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.13.3 [Methods of `Array.prototype`](ch_arrays.html#quickref-array-prototype)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.13.4 [Sources](ch_arrays.html#sources-3)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '31.1 Cheat sheet: Arrays'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript Arrays are a very flexible data structure and used as lists, stacks,
    queues, tuples (e.g. pairs), and more.
  prefs: []
  type: TYPE_NORMAL
- en: Some Array-related operations destructively change Arrays. Others non-destructively
    produce new Arrays with the changes applied to a copy of the original content.
  prefs: []
  type: TYPE_NORMAL
- en: 31.1.1 Using Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Creating an Array, reading and writing elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The length of an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding elements destructively via `.push()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding elements non-destructively via spreading (`...`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearing Arrays (removing all elements):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Looping over elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Looping over index-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating and filling Arrays when we can’t use Array literals (e.g. because
    we don’t know their lengths in advance or they are too large):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 31.1.2 Array methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This section gives a brief overview of the Array API. There is [a more comprehensive
    quick reference](ch_arrays.html#quickref-array-api) at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deriving a new Array from an existing Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Removing an Array element at a given index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Computing a summary of an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Reversing and filling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`.sort()` also modifies an Array and returns it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finding Array elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding or removing an element at the start or the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 31.2 The two ways of using Arrays in JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two ways of using Arrays in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixed-layout Arrays: Used this way, Arrays have a fixed number of indexed elements.
    Each of those elements can have a different type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sequence Arrays: Used this way, Arrays have a variable number of indexed elements.
    Each of those elements has the same type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In practice, these two ways are often mixed.
  prefs: []
  type: TYPE_NORMAL
- en: Notably, sequence Arrays are so flexible that we can use them as (traditional)
    arrays, stacks, and queues. We’ll see how later.
  prefs: []
  type: TYPE_NORMAL
- en: 31.3 Basic Array operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 31.3.1 Creating, reading, writing Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The best way to create an Array is via an *Array literal*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The Array literal starts and ends with square brackets `[]`. It creates an
    Array with three *elements*: `''a''`, `''b''`, and `''c''`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Trailing commas are allowed and ignored in Array literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To read an Array element, we put an index in square brackets (indices start
    at zero):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To change an Array element, we assign to an Array with an index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The range of Array indices is 32 bits (excluding the maximum length): [0, 2^(32)−1)'
  prefs: []
  type: TYPE_NORMAL
- en: 31.3.2 The `.length` of an Array
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Every Array has a property `.length` that can be used to both read and change(!)
    the number of elements in an Array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The length of an Array is always the highest index plus one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we write to the Array at the index of the length, we append an element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way of (destructively) appending an element is via the Array method
    `.push()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we set `.length`, we are pruning the Array by removing elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Removing empty
    lines via `.push()`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/arrays/remove_empty_lines_push_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: 31.3.3 Referring to elements via negative indices
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Several Array methods support negative indices. If an index is negative, it
    is added to the length of an Array to produce a usable index. Therefore, the following
    two invocations of `.slice()` are equivalent: They both copy `arr` starting at
    the last element.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '31.3.3.1 `.at()`: reading single elements (supports negative indices) [ES2022]'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The Array method `.at()` returns the element at a given index. It supports
    positive and negative indices (`-1` refers to the last element, `-2` refers to
    the second-last element, etc.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, the bracket operator `[]` does not support negative indices (and
    can’t be changed because that would break existing code). It interprets them as
    keys of non-element properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 31.3.4 Clearing Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To clear (empty) an Array, we can either set its `.length` to zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'or we can assign a new empty Array to the variable storing the Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The latter approach has the advantage of not affecting other locations that
    point to the same Array. If, however, we do want to reset a shared Array for everyone,
    then we need the former approach.
  prefs: []
  type: TYPE_NORMAL
- en: 31.3.5 Spreading into Array literals [ES6]
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside an Array literal, a *spread element* consists of three dots (`...`)
    followed by an expression. It results in the expression being evaluated and then
    iterated over. Each iterated value becomes an additional Array element – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'That means that we can use spreading to create a copy of an Array and to convert
    an iterable to an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'However, for both previous use cases, I find `Array.from()` more self-descriptive
    and prefer it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Spreading is also convenient for concatenating Arrays (and other iterables)
    into Arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to spreading using iteration, it only works if the value is iterable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/0ac255e56dc93a43365d8502301c8688.png)  **Spreading and `Array.from()`
    produce shallow copies**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copying Arrays via spreading or via `Array.from()` is shallow: We get new entries
    in a new Array, but the values are shared with the original Array. The consequences
    of shallow copying are demonstrated in [§28.4 “Spreading into object literals
    (`...`) [ES2018]”](ch_objects.html#spreading-into-object-literals).'
  prefs: []
  type: TYPE_NORMAL
- en: '31.3.6 Arrays: listing indices and entries [ES6]'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Method `.keys()` lists the indices of an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`.keys()` returns an iterable. In line A, we convert that iterable to an Array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing Array indices is different from listing properties. The former produces
    numbers; the latter produces stringified numbers (in addition to non-index property
    keys):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Method `.entries()` lists the contents of an Array as [index, element] pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 31.3.7 Is a value an Array?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Following are two ways of checking if a value is an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`instanceof` is usually fine. We need `Array.isArray()` if a value may come
    from another *realm*. Roughly, a realm is an instance of JavaScript’s global scope.
    Some realms are isolated from each other (e.g., [Web Workers](ch_async-js.html#web-workers)
    in browsers), but there are also realms between which we can move data – for example,
    same-origin iframes in browsers. `x instanceof Array` checks the prototype chain
    of `x` and therefore returns `false` if `x` is an Array from another realm.'
  prefs: []
  type: TYPE_NORMAL
- en: '`typeof` categorizes Arrays as objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 31.4 `for-of` and Arrays [ES6]
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already encountered the `for-of` loop earlier in this book. This section
    briefly recaps how to use it for Arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '31.4.1 `for-of`: iterating over elements'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following `for-of` loop iterates over the elements of an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '31.4.2 `for-of`: iterating over indices'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This `for-of` loop iterates over the indices of an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '31.4.3 `for-of`: iterating over [index, element] pairs'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following `for-of` loop iterates over [index, element] pairs. Destructuring
    (described [later](ch_destructuring.html)), gives us convenient syntax for setting
    up `index` and `element` in the head of `for-of`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 31.5 Array-like objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some operations that work with Arrays require only the bare minimum: values
    must only be *Array-like*. An Array-like value is an object with the following
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.length`: holds the length of the Array-like object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[0]`: holds the element at index 0 (etc.). Note that if we use numbers as
    property names, they are always coerced to strings. Therefore, `[0]` retrieves
    the value of the property whose key is `''0''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, `Array.from()` accepts Array-like objects and converts them to
    Arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The TypeScript interface for Array-like objects is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **Array-like objects are
    relatively rare in modern JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: Array-like objects used to be common before ES6; now we don’t see them very
    often.
  prefs: []
  type: TYPE_NORMAL
- en: 31.6 Converting iterables and Array-like values to Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two common ways of converting iterables and Array-like values to
    Arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: Spreading into Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.from()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I prefer the latter – I find it more self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: 31.6.1 Converting iterables to Arrays via spreading (`...`)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside an Array literal, spreading via `...` converts any iterable object into
    a series of Array elements. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The conversion works because the DOM collection is iterable.
  prefs: []
  type: TYPE_NORMAL
- en: 31.6.2 Converting iterables and Array-like objects to Arrays via `Array.from()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Array.from()` can be used in two modes.'
  prefs: []
  type: TYPE_NORMAL
- en: '31.6.2.1 Mode 1 of `Array.from()`: converting'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The first mode has the following type signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Interface `Iterable` is shown [in the chapter on synchronous iteration](ch_sync-iteration.html#iterable-iterator-iteratorresult).
    Interface `ArrayLike` appeared [earlier in this chapter](ch_arrays.html#array-like-objects).
  prefs: []
  type: TYPE_NORMAL
- en: 'With a single parameter, `Array.from()` converts anything iterable or Array-like
    to an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '31.6.2.2 Mode 2 of `Array.from()`: converting and mapping'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The second mode of `Array.from()` involves two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In this mode, `Array.from()` does several things:'
  prefs: []
  type: TYPE_NORMAL
- en: It iterates over `iterable`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It calls `mapFunc` with each iterated value. The optional parameter `thisArg`
    specifies a `this` for `mapFunc`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It applies `mapFunc` to each iterated value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It collects the results in a new Array and returns it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In other words: we are going from an iterable with elements of type `T` to
    an Array with elements of type `U`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 31.7 Creating and filling Arrays with arbitrary lengths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The best way of creating an Array is via an Array literal. However, we can’t
    always use one: The Array may be too large, we may not know its length during
    development, or we may want to keep its length flexible. Then I recommend the
    following techniques for creating, and possibly filling, Arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: 31.7.1 Do we need to create an empty Array that we’ll fill completely later
    on?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note that the result has three [*holes* (empty slots)](ch_arrays.html#array-holes)
    – the last comma in an Array literal is always ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 31.7.2 Do we need to create an Array filled with a primitive value?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Caveat: If we use `.fill()` with an object, then each Array element will refer
    to this object (sharing it).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The next subsection explains how to fix this.
  prefs: []
  type: TYPE_NORMAL
- en: 31.7.3 Do we need to create an Array filled with objects?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'For large sizes, the temporary Array can consume quite a bit of memory. The
    following approach doesn’t have this downside but is less self-descriptive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Instead of a temporary Array, we are using a temporary [Array-like object](ch_arrays.html#array-like-objects).
  prefs: []
  type: TYPE_NORMAL
- en: 31.7.4 Do we need to create a range of integers?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an alternative, slightly hacky technique for creating integer ranges
    that start at zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This works because `.keys()` treats [*holes*](ch_arrays.html#array-holes) like
    `undefined` elements and lists their indices.
  prefs: []
  type: TYPE_NORMAL
- en: 31.7.5 Use a Typed Array if the elements are all integers or all floats
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When dealing with Arrays of integers or floats, we should consider [*Typed Arrays*](ch_typed-arrays.html),
    which were created for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 31.8 Multidimensional Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript does not have real multidimensional Arrays; we need to resort to
    Arrays whose elements are Arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 31.9 More Array features (advanced)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we look at phenomena we don’t encounter often when working
    with Arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 31.9.1 Array indices are (slightly special) property keys
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’d think that Array elements are special because we are accessing them via
    numbers. But the square brackets operator `[]` for doing so is the same operator
    that is used for accessing properties. It coerces any value (that is not a symbol)
    to a string. Therefore, Array elements are (almost) normal properties (line A)
    and it doesn’t matter if we use numbers or strings as indices (lines B and C):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: To make matters even more confusing, this is only how the language specification
    defines things (the theory of JavaScript, if you will). Most JavaScript engines
    optimize under the hood and do use actual integers to access Array elements (the
    practice of JavaScript, if you will).
  prefs: []
  type: TYPE_NORMAL
- en: 'Property keys (strings!) that are used for Array elements are called [*indices*](https://tc39.github.io/ecma262/#integer-index).
    A string `str` is an index if converting it to a 32-bit unsigned integer and back
    results in the original value. Written as a formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 31.9.1.1 Listing indices
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When listing property keys, [indices are treated specially](ch_objects.html#order-of-properties)
    – they always come first and are sorted like numbers (`''2''` comes before `''10''`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `.length`, `.entries()` and `.keys()` treat Array indices as numbers
    and ignore non-index properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We used [`Array.from()`](ch_arrays.html#Array.from) to convert the iterables
    returned by `.keys()` and `.entries()` to Arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 31.9.2 Arrays are dictionaries and can have holes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We distinguish two kinds of Arrays in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: An Array `arr` is *dense* if all indices `i`, with 0 ≤ `i` < `arr.length`, exist.
    That is, the indices form a contiguous range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Array is *sparse* if the range of indices has *holes* in it. That is, some
    indices are missing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays can be sparse in JavaScript because Arrays are actually dictionaries
    from indices to values.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png)  **Recommendation: avoid
    holes**'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have only seen dense Arrays and it’s indeed recommended to avoid
    holes: They make our code more complicated and are not handled consistently by
    Array methods. Additionally, JavaScript engines optimize dense Arrays, making
    them faster.'
  prefs: []
  type: TYPE_NORMAL
- en: 31.9.2.1 Creating holes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can create holes by skipping indices when assigning elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In line A, we are using `Object.keys()` because `arr.keys()` treats holes as
    if they were `undefined` elements and does not reveal them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of creating holes is to skip elements in Array literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also delete Array elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 31.9.2.2 How do Array operations treat holes?
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Alas, there are many different ways in which Array operations treat holes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some Array operations remove holes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Some Array operations ignore holes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Some Array operations ignore but preserve holes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Some Array operations treat holes as `undefined` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '`Object.keys()` works differently than `.keys()` (strings vs. numbers, holes
    don’t have keys):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: There is no rule to remember here. If it ever matters how an Array operation
    treats holes, the best approach is to do a quick test in a console.
  prefs: []
  type: TYPE_NORMAL
- en: 31.10 Adding and removing elements (destructively and non-destructively)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript’s `Array` is quite flexible and more like a combination of array,
    stack, and queue. This section explores ways of adding and removing Array elements.
    Most operations can be performed both *destructively* (modifying the Array) and
    *non-destructively* (producing a modified copy).
  prefs: []
  type: TYPE_NORMAL
- en: 31.10.1 Prepending elements and Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the following code, we destructively prepend single elements to `arr1` and
    an Array to `arr2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Spreading lets us unshift an Array into `arr2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Non-destructive prepending is done via spread elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 31.10.2 Appending elements and Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the following code, we destructively append single elements to `arr1` and
    an Array to `arr2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Spreading (`...`) lets us push an Array into `arr2` (line A).
  prefs: []
  type: TYPE_NORMAL
- en: 'Non-destructive appending is done via spread elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 31.10.3 Removing elements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These are three destructive ways of removing Array elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '`.splice()` is covered in more detail in [the quick reference at the end of
    this chapter](ch_arrays.html#quickref-array-prototype).'
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring via a rest element lets us non-destructively remove elements from
    the beginning of an Array (destructuring is covered [later](ch_destructuring.html)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Alas, a rest element must come last in an Array. Therefore, we can only use
    it to extract suffixes.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Implementing
    a queue via an Array**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/arrays/queue_via_array_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '31.11 Methods: iteration and transformation (`.find()`, `.map()`, `.filter()`,
    etc.)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we take a look at Array methods for iterating over Arrays and
    for transforming Arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 31.11.1 Callbacks for iteration and transformation methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All iteration and transformation methods use callbacks. The former feed all
    iterated values to their callbacks; the latter ask their callbacks how to transform
    Arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'These callbacks have type signatures that look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, the callback gets three parameters (it is free to ignore any of them):'
  prefs: []
  type: TYPE_NORMAL
- en: '`value` is the most important one. This parameter holds the iterated value
    that is currently being processed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index` can additionally tell the callback what the index of the iterated value
    is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array` points to the current Array (the receiver of the method call). Some
    algorithms need to refer to the whole Array – e.g., to search it for answers.
    This parameter lets us write reusable callbacks for such algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What the callback is expected to return depends on the method it is passed
    to. Possibilities include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.map()` fills its result with the values returned by its callback:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.find()` returns the first Array element for which its callback returns `true`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Both of these methods are described in more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: '31.11.2 Searching elements: `.find()`, `.findIndex()`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`.find()` returns the first element for which its callback returns a truthy
    value (and `undefined` if it can’t find anything):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '`.findIndex()` returns the index of the first element for which its callback
    returns a truthy value (and `-1` if it can’t find anything):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '`.findIndex()` can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '31.11.3 `.map()`: copy while giving elements new values'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`.map()` returns a modified copy of the receiver. The elements of the copy
    are the results of applying `map`’s callback to the elements of the receiver.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All of this is easier to understand via examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '`.map()` can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Numbering
    lines via `.map()`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/arrays/number_lines_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '31.11.4 `.flatMap()`: mapping to zero or more values'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The type signature of `Array<T>.prototype.flatMap()` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `.map()` and `.flatMap()` take a function `callback` as a parameter that
    controls how an input Array is translated to an output Array:'
  prefs: []
  type: TYPE_NORMAL
- en: With `.map()`, each input Array element is translated to exactly one output
    element. That is, `callback` returns a single value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `.flatMap()`, each input Array element is translated to zero or more output
    elements. That is, `callback` returns an Array of values (it can also return non-Array
    values, but that is rare).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is `.flatMap()` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: We’ll consider use cases next, before exploring how this method could be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '31.11.4.1 Use case: filtering and mapping at the same time'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The result of the Array method `.map()` always has the same length as the Array
    it is invoked on. That is, its callback can’t skip Array elements it isn’t interested
    in. The ability of `.flatMap()` to do so is useful in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the following function `processArray()` to create an Array that
    we’ll then filter and map via `.flatMap()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create an Array `results` via `processArray()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use `.flatMap()` to extract just the values or just the errors from
    `results`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '31.11.4.2 Use case: mapping single input values to multiple output values'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Array method `.map()` maps each input Array element to one output element.
    But what if we want to map it to multiple output elements?
  prefs: []
  type: TYPE_NORMAL
- en: 'That becomes necessary in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to convert an Array of strings to an Array of Unicode characters (code
    points). The following function achieves that via `.flatMap()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 31.11.4.3 A simple implementation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can implement `.flatMap()` as follows. Note: This implementation is simpler
    than the built-in version, which, for example, performs more checks.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercises: `.flatMap()`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/arrays/convert_to_numbers_test.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exercises/arrays/replace_objects_test.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '31.11.5 `.filter()`: only keep some of the elements'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Array method `.filter()` returns an Array collecting all elements for which
    the callback returns a truthy value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '`.filter()` can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Removing empty
    lines via `.filter()`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/arrays/remove_empty_lines_filter_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '31.11.6 `.reduce()`: deriving a value from an Array (advanced)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Method `.reduce()` is a powerful tool for computing a “summary” of an Array
    `arr`. A summary can be any kind of value:'
  prefs: []
  type: TYPE_NORMAL
- en: A number. For example, the sum of all elements of `arr`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Array. For example, a copy of `arr`, where each element is twice the original
    element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduce` is also known as `foldl` (“fold left”) in functional programming and
    popular there. One caveat is that it can make code difficult to understand.'
  prefs: []
  type: TYPE_NORMAL
- en: '`.reduce()` has the following type signature (inside an `Array<T>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '`T` is the type of the Array elements, `U` is the type of the summary. The
    two may or may not be different. `accumulator` is just another name for “summary”.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute the summary of an Array `arr`, `.reduce()` feeds all Array elements
    to its callback one at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '`callback` combines the previously computed summary (stored in its parameter
    `accumulator`) with the current Array element and returns the next `accumulator`.
    The result of `.reduce()` is the final accumulator – the last result of `callback`
    after it has visited all elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words: `callback` does most of the work; `.reduce()` just invokes
    it in a useful manner.'
  prefs: []
  type: TYPE_NORMAL
- en: We could say that the callback folds Array elements into the accumulator. That’s
    why this operation is called “fold” in functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: 31.11.6.1 A first example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s look at an example of `.reduce()` in action: function `addAll()` computes
    the sum of all numbers in an Array `arr`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the accumulator holds the sum of all Array elements that `callback`
    has already visited.
  prefs: []
  type: TYPE_NORMAL
- en: 'How was the result `6` derived from the Array in line A? Via the following
    invocations of `callback`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Notes:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameters are the current accumulators (starting with parameter `init`
    of `.reduce()`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameters are the current Array elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The results are the next accumulators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last result of `callback` is also the result of `.reduce()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alternatively, we could have implemented `addAll()` via a `for-of` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s hard to say which of the two implementations is “better”: the one based
    on `.reduce()` is a little more concise, while the one based on `for-of` may be
    a little easier to understand – especially if someone is not familiar with functional
    programming.'
  prefs: []
  type: TYPE_NORMAL
- en: '31.11.6.2 Example: finding indices via `.reduce()`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following function is an implementation of the Array method `.indexOf()`.
    It returns the first index at which the given `searchValue` appears inside the
    Array `arr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: One limitation of `.reduce()` is that we can’t finish early (in a `for-of` loop,
    we can `break`). Here, we always immediately return the result once we have found
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '31.11.6.3 Example: doubling Array elements'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Function `double(arr)` returns a copy of `inArr` whose elements are all multiplied
    by 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'We modify the initial value `[]` by pushing into it. A non-destructive, more
    functional version of `double()` looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: This version is more elegant but also slower and uses more memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercises: `.reduce()`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`map()` via `.reduce()`: `exercises/arrays/map_via_reduce_test.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter()` via `.reduce()`: `exercises/arrays/filter_via_reduce_test.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`countMatches()` via `.reduce()`: `exercises/arrays/count_matches_via_reduce_test.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '31.12 `.sort()`: sorting Arrays'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`.sort()` has the following type definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, `.sort()` sorts string representations of the elements. These representations
    are compared via `<`. This operator compares *lexicographically* (the first characters
    are most significant). We can see that when sorting numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'When sorting human-language strings, we need to be aware that they are compared
    according to their code unit values (char codes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: All unaccented uppercase letters come before all unaccented lowercase letters,
    which come before all accented letters. We can use `Intl`, [the JavaScript internationalization
    API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl)
    if we want proper sorting for human languages.
  prefs: []
  type: TYPE_NORMAL
- en: '`.sort()` sorts *in place*; it changes and returns its receiver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 31.12.1 Customizing the sort order
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can customize the sort order via the parameter `compareFunc`, which must
    return a number that is:'
  prefs: []
  type: TYPE_NORMAL
- en: negative if `a < b`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: zero if `a === b`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: positive if `a > b`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png)  **Tip for remembering
    these rules**'
  prefs: []
  type: TYPE_NORMAL
- en: A negative number is *less than* zero (etc.).
  prefs: []
  type: TYPE_NORMAL
- en: 31.12.2 Sorting numbers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can use this helper function to sort numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The following is a quick and dirty alternative.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The downsides of this approach are:'
  prefs: []
  type: TYPE_NORMAL
- en: It is cryptic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a risk of numeric overflow or underflow, if `a-b` becomes a large positive
    or negative number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.12.3 Sorting objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We also need to use a compare function if we want to sort objects. As an example,
    the following code shows how to sort objects by age.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Sorting objects
    by name**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/arrays/sort_objects_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '31.13 Quick reference: `Array`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Legend:'
  prefs: []
  type: TYPE_NORMAL
- en: '`R`: method does not change the Array (non-destructive).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`W`: method changes the Array (destructive).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 31.13.1 `new Array()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`new Array(n)` creates an Array of length `n` that contains `n` holes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '`new Array()` creates an empty Array. However, I recommend to always use `[]`
    instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 31.13.2 Static methods of `Array`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Array.from<T>(iterable: Iterable<T> | ArrayLike<T>): T[]` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.from<T,U>(iterable: Iterable<T> | ArrayLike<T>, mapFunc: (v: T, k: number)
    => U, thisArg?: any): U[]` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converts an iterable or [an Array-like object](ch_arrays.html#array-like-objects)
    to an Array. Optionally, the input values can be translated via `mapFunc` before
    they are added to the output Array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Examples:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.of<T>(...items: T[]): T[]` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This static method is mainly useful for subclasses of `Array`, where it serves
    as a custom Array literal:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 31.13.3 Methods of `Array.prototype`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`.at(index: number): T | undefined` ^([R, ES2022])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the Array element at `index`. If `index` is negative, it is added to
    `.length` before it is used (`-1` becomes `this.length-1`, etc.).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.concat(...items: Array<T[] | T>): T[]` ^([R, ES3])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a new Array that is the concatenation of the receiver and all `items`.
    Non-Array parameters (such as `'b'` in the following example) are treated as if
    they were Arrays with single elements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.copyWithin(target: number, start: number, end=this.length): this` ^([W, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copies the elements whose indices range from (including) `start` to (excluding)
    `end` to indices starting with `target`. Overlapping is handled correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If `start` or `end` is negative, then `.length` is added to it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.entries(): Iterable<[number, T]>` ^([R, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns an iterable over [index, element] pairs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.every(callback: (value: T, index: number, array: Array<T>) => boolean, thisArg?:
    any): boolean` ^([R, ES5])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if `callback` returns a truthy value for every element. Otherwise,
    it returns `false`. It stops as soon as it receives a falsy value. This method
    corresponds to universal quantification (“for all”, `∀`) in mathematics.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Related method: `.some()` (“exists”).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.fill(value: T, start=0, end=this.length): this` ^([W, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigns `value` to every index between (including) `start` and (excluding) `end`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Caveat: Don’t use this method to fill an Array with an object `obj`; then each
    element will refer to `obj` (sharing it). In this case, it’s better to [use `Array.from()`](ch_arrays.html#filling-arrays).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.filter(callback: (value: T, index: number, array: Array<T>) => any, thisArg?:
    any): T[]` ^([R, ES5])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns an Array with only those elements for which `callback` returns a truthy
    value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.find(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?:
    any): T | undefined` ^([R, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result is the first element for which `predicate` returns a truthy value.
    If there is no such element, the result is `undefined`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.findIndex(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?:
    any): number` ^([R, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result is the index of the first element for which `predicate` returns a
    truthy value. If there is no such element, the result is `-1`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.flat(depth = 1): any[]` ^([R, ES2019])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '“Flattens” an Array: It descends into the Arrays that are nested inside the
    input Array and creates a copy where all values it finds at level `depth` or lower
    are moved to the top level.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.flatMap<U>(callback: (value: T, index: number, array: T[]) => U|Array<U>,
    thisValue?: any): U[]` ^([R, ES2019])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result is produced by invoking `callback()` for each element of the original
    Array and concatenating the Arrays it returns.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.forEach(callback: (value: T, index: number, array: Array<T>) => void, thisArg?:
    any): void` ^([R, ES5])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls `callback` for each element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A `for-of` loop is usually a better choice: it’s faster, supports `break` and
    can iterate over arbitrary iterables.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.includes(searchElement: T, fromIndex=0): boolean` ^([R, ES2016])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if the receiver has an element whose value is `searchElement`
    and `false`, otherwise. Searching starts at index `fromIndex`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.indexOf(searchElement: T, fromIndex=0): number` ^([R, ES5])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the index of the first element that is strictly equal to `searchElement`.
    Returns `-1` if there is no such element. Starts searching at index `fromIndex`,
    visiting higher indices next.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.join(separator = '',''): string` ^([R, ES1])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a string by concatenating string representations of all elements, separating
    them with `separator`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.keys(): Iterable<number>` ^([R, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns an iterable over the keys of the receiver.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.lastIndexOf(searchElement: T, fromIndex=this.length-1): number` ^([R, ES5])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the index of the last element that is strictly equal to `searchElement`.
    Returns `-1` if there is no such element. Starts searching at index `fromIndex`,
    visiting lower indices next.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.map<U>(mapFunc: (value: T, index: number, array: Array<T>) => U, thisArg?:
    any): U[]` ^([R, ES5])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a new Array, in which every element is the result of `mapFunc` being
    applied to the corresponding element of the receiver.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.pop(): T | undefined` ^([W, ES3])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removes and returns the last element of the receiver. That is, it treats the
    end of the receiver as a stack. The opposite of `.push()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.push(...items: T[]): number` ^([W, ES3])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds zero or more `items` to the end of the receiver. That is, it treats the
    end of the receiver as a stack. The return value is the length of the receiver
    after the change. The opposite of `.pop()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can push an Array by spreading (`...`) it into arguments:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.reduce<U>(callback: (accumulator: U, element: T, index: number, array: T[])
    => U, init?: U): U` ^([R, ES5])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This method produces a summary of the receiver: it feeds all Array elements
    to `callback`, which combines a current summary (in parameter `accumulator`) with
    the current Array element and returns the next `accumulator`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result of `.reduce()` is the last result of `callback` after it has visited
    all Array elements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If no `init` is provided, the Array element at index 0 is used and the element
    at index 1 is visited first. Therefore, the Array must have at least length 1.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.reduceRight<U>(callback: (accumulator: U, element: T, index: number, array:
    T[]) => U, init?: U): U` ^([R, ES5])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Works like `.reduce()`, but visits the Array elements backward, starting with
    the last element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.reverse(): this` ^([W, ES1])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rearranges the elements of the receiver so that they are in reverse order and
    then returns the receiver.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.shift(): T | undefined` ^([W, ES3])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removes and returns the first element of the receiver. The opposite of `.unshift()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.slice(start=0, end=this.length): T[]` ^([R, ES3])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a new Array containing the elements of the receiver whose indices are
    between (including) `start` and (excluding) `end`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Negative indices are allowed and added to `.length`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.some(callback: (value: T, index: number, array: Array<T>) => boolean, thisArg?:
    any): boolean` ^([R, ES5])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if `callback` returns a truthy value for at least one element.
    Otherwise, it returns `false`. It stops as soon as it receives a truthy value.
    This method corresponds to existential quantification (“exists”, `∃`) in mathematics.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Related method: `.every()` (“for all”).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.sort(compareFunc?: (a: T, b: T) => number): this` ^([W, ES1])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sorts the receiver and returns it. By default, it sorts string representations
    of the elements. It does so lexicographically and according to the code unit values
    (char codes) of the characters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can customize the sort order via `compareFunc`, which returns a number that
    is:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: negative if `a < b`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: zero if `a === b`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: positive if `a > b`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Trick for sorting numbers (with a risk of numeric overflow or underflow):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **`.sort()` is stable**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since ECMAScript 2019, sorting is guaranteed to be stable: if elements are
    considered equal by sorting, then sorting does not change the order of those elements
    (relative to each other).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.splice(start: number, deleteCount=this.length-start, ...items: T[]): T[]`
    ^([W, ES3])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At index `start`, it removes `deleteCount` elements and inserts the `items`.
    It returns the deleted elements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`start` can be negative and is added to `.length` if it is:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.toString(): string` ^([R, ES1])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converts all elements to strings via `String()`, concatenates them while separating
    them with commas, and returns the result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.unshift(...items: T[]): number` ^([W, ES3])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserts the `items` at the beginning of the receiver and returns its length
    after this modification.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.values(): Iterable<T>` ^([R, ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns an iterable over the values of the receiver.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 31.13.4 Sources
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[TypeScript’s built-in typings](https://github.com/Microsoft/TypeScript/blob/master/lib/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MDN web docs for JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ECMAScript language specification](https://tc39.github.io/ecma262/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz**'
  prefs: []
  type: TYPE_NORMAL
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  prefs: []
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/22)'
  prefs: []
  type: TYPE_NORMAL
