["```js\nfunction readProfiles(filePaths) {\n  const profiles = [];\n  for (const filePath of filePaths) {\n    try {\n      const profile = readOneProfile(filePath);\n      profiles.push(profile);\n    } catch (err) { // (A)\n      console.log('Error in: '+filePath, err);\n    }\n  }\n}\nfunction readOneProfile(filePath) {\n  const profile = new Profile();\n  const file = openFile(filePath);\n  // ··· (Read the data in `file` into `profile`)\n  return profile;\n}\nfunction openFile(filePath) {\n  if (!fs.existsSync(filePath)) {\n    throw new Error('Could not find file '+filePath); // (B)\n  }\n  // ··· (Open the file whose path is `filePath`)\n}\n\n```", "```js\nreadProfiles(···)\n  for (const filePath of filePaths)\n    try\n      readOneProfile(···)\n        openFile(···)\n          if (!fs.existsSync(filePath))\n            throw\n\n```", "```js\nthrow «value»;\n\n```", "```js\n    const err = new Error('Could not find the file');\n    err.filePath = filePath;\n    throw err;\n\n    ```", "```js\n    class MyError extends Error {\n    }\n    function func() {\n     throw new MyError('Problem!');\n    }\n    assert.throws(\n     () => func(),\n     MyError\n    );\n\n    ```", "```js\ntry {\n  «try_statements»\n} catch (error) {\n  «catch_statements»\n} finally {\n  «finally_statements»\n}\n\n```", "```js\nconst errorObject = new Error();\nfunction func() {\n throw errorObject; // (A)\n}\n\ntry {\n func();\n} catch (err) { // (B)\n assert.equal(err, errorObject);\n}\n\n```", "```js\ntry {\n  // ···\n} catch {\n  // ···\n}\n\n```", "```js\nfunction throws(func) {\n  try {\n    func();\n  } catch {\n    return; // everything OK\n  }\n  throw new Error('Function didn’t throw an exception!');\n}\n\n```", "```js\nconst resource = createResource();\ntry {\n  // Work with `resource`. Errors may be thrown.\n} finally {\n  resource.destroy();\n}\n\n```", "```js\nlet finallyWasExecuted = false;\nassert.throws(\n  () => {\n    try {\n      throw new Error(); // (A)\n    } finally {\n      finallyWasExecuted = true;\n    }\n  },\n  Error\n);\nassert.equal(finallyWasExecuted, true);\n\n```", "```js\nlet finallyWasExecuted = false;\nfunction func() {\n try {\n return; // (A)\n } finally {\n finallyWasExecuted = true;\n }\n}\nfunc();\nassert.equal(finallyWasExecuted, true);\n\n```", "```js\nclass Error {\n  // Actually a prototype data property\n  get name(): string {\n    return 'Error';\n  }\n\n  // Instance properties\n  message: string;\n  cause?: unknown; // ES2022\n  stack: string; // non-standard but widely supported\n\n  constructor(\n message: string = '',\n options?: ErrorOptions // ES2022\n  ) {}\n}\ninterface ErrorOptions {\n  cause?: unknown; // ES2022\n}\n\n```", "```js\n> Error.prototype.name\n'Error'\n> RangeError.prototype.name\n'RangeError'\n\n```", "```js\n> new RangeError().name\n'RangeError'\n> new RangeError().constructor.name\n'RangeError'\n\n```", "```js\nconst err = new Error('Hello!');\nassert.equal(String(err), 'Error: Hello!');\nassert.equal(err.message, 'Hello!');\n\n```", "```js\nassert.equal(new Error().message, '');\n\n```", "```js\nfunction h(z) {\n  const error = new Error();\n  console.log(error.stack);\n}\nfunction g(y) {\n  h(y + 1);\n}\nfunction f(x) {\n  g(x + 1);\n}\nf(3);\n\n```", "```js\nError\n    at h (demos/async-js/stack_trace.mjs:2:17)\n    at g (demos/async-js/stack_trace.mjs:6:3)\n    at f (demos/async-js/stack_trace.mjs:9:3)\n    at demos/async-js/stack_trace.mjs:11:1\n\n```", "```js\nconst err = new Error('msg', {cause: 'the cause'});\nassert.equal(err.cause, 'the cause');\n\n```", "```js\nfunction readFiles(filePaths) {\n  return filePaths.map(\n    (filePath) => {\n      try {\n        const text = readText(filePath);\n        const json = JSON.parse(text);\n        return processJson(json);\n      } catch (error) {\n        throw new Error( // (A)\n          `While processing ${filePath}`,\n          {cause: error}\n        );\n      }\n    });\n}\n\n```", "```js\nimport assert from 'node:assert/strict';\nimport * as util from 'node:util';\n\nouterFunction();\n\nfunction outerFunction() {\n try {\n innerFunction();\n } catch (err) {\n const errorWithCause = new Error(\n 'Outer error', {cause: err}\n );\n assert.deepEqual(\n util.inspect(errorWithCause).split(/\\r?\\n/), // (A)\n [\n 'Error: Outer error',\n '    at outerFunction (file:///tmp/main.mjs:10:28)',\n '    at file:///tmp/main.mjs:4:1',\n '    ... 2 lines matching cause stack trace ...',\n '  [cause]: TypeError: The cause',\n '      at innerFunction (file:///tmp/main.mjs:31:9)',\n '      at outerFunction (file:///tmp/main.mjs:8:5)',\n '      at file:///tmp/main.mjs:4:1',\n '}',\n ]\n );\n }\n}\n\nfunction innerFunction() {\n throw new TypeError('The cause');\n} \n```", "```js\nimport assert from 'node:assert/strict';\nimport * as util from 'node:util';\n\nconst error = new Error(\n  'Could not reach server', {\n    cause: {server: 'https://127.0.0.1'}\n  }\n);\nassert.deepEqual(\n  util.inspect(error).split(/\\r?\\n/),\n  [\n    \"Error: Could not reach server\",\n    \"    at file:///tmp/main.mjs:4:15\",\n    \"  [cause]: { server: 'https://127.0.0.1' }\",\n    \"}\",\n  ]\n);\n\n```", "```js\nclass MyCustomError extends Error {\n  constructor(message, options) {\n    super(message, options);\n    // ···\n  }\n}\n\n```"]