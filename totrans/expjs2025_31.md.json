["```js\nfunction readProfiles(filePaths) {\n const profiles = [];\n for (const filePath of filePaths) {\n try {\n const profile = readOneProfile(filePath);\n profiles.push(profile);\n } catch (err) { // (A)\n console.log('Error in: '+filePath, err);\n }\n }\n}\nfunction readOneProfile(filePath) {\n const profile = new Profile();\n const file = openFile(filePath);\n // ··· (Read the data in `file` into `profile`)\n return profile;\n}\nfunction openFile(filePath) {\n if (!fs.existsSync(filePath)) {\n throw new Error('Could not find file '+filePath); // (B)\n }\n // ··· (Open the file whose path is `filePath`)\n}\n\n```", "```js\nreadProfiles(···)\n for (const filePath of filePaths)\n try\n readOneProfile(···)\n openFile(···)\n if (!fs.existsSync(filePath))\n throw\n\n```", "```js\nthrow «value»;\n\n```", "```js\n    const err = new Error('Could not find the file');\n    err.filePath = filePath;\n    throw err;\n\n    ```", "```js\n    class MyError extends Error {\n    }\n    function func() {\n     throw new MyError('Problem!');\n    }\n    assert.throws(\n     () => func(),\n     MyError\n    );\n\n    ```", "```js\ntry {\n «try_statements»\n} catch (error) {\n «catch_statements»\n} finally {\n «finally_statements»\n}\n\n```", "```js\nconst errorObject = new Error();\nfunction func() {\n throw errorObject; // (A)\n}\n `try {`\n `func();`\n`} catch (err) { // (B)`\n `assert.equal(err, errorObject);`\n`}` \n```", "```js```", "``` ##### [26.3.2.1 Omitting the `catch` binding ^(ES2019)](#omitting-catch-binding)    We can omit the `catch` parameter if we are not interested in the value that was thrown:    ```", "```    That may occasionally be useful. For example, Node.js has the API function [`assert.throws(func)`](https://nodejs.org/api/assert.html#assert_assert_throws_fn_error_message) that checks whether an error is thrown inside `func`. It could be implemented as follows.    ```", "```    However, a more complete implementation of this function would have a `catch` parameter and would, for example, check that its type is as expected.    #### [26.3.3 The `finally` clause](#the-finally-clause)    The code inside the `finally` clause is always executed at the end of a `try` statement – no matter what happens in the `try` block or the `catch` clause.    Let’s look at a common use case for `finally`: We have created a resource and want to always destroy it when we are done with it, no matter what happens while working with it. We would implement that as follows:    ```", "```    ##### [26.3.3.1 `finally` is always executed](#finally-is-always-executed)    The `finally` clause is always executed, even if an error is thrown (line A):    ```", "```    And even if there is a `return` statement (line A):    ```", "```    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Exception handling**    `exercises/exception-handling/call_function_test.mjs`    ### [26.4 The superclass of all built-in exception classes: `Error`](#class-Error)    This is what `Error`’s instance properties and constructor look like:    ```", "```   ```", "````` ```js```` The constructor has two parameters:    *   `message` specifies an error message. *   `options` was introduced in ECMAScript 2022\\. It contains an object where one property is currently supported:     *   `.cause` specifies which exception (if any) caused the current error.    The subsections after the next one explain the instance properties `.message` and `.stack` in more detail. The next section explains `.cause`.    #### [26.4.1 `Error.prototype.name`](#errorprototypename)    Each built-in error class `E` has a property `E.prototype.name`:    ```js > Error.prototype.name 'Error' > RangeError.prototype.name 'RangeError'  ```    Therefore, there are two ways to get the name of the class of a built-in error object:    ```js > new RangeError().name 'RangeError' > new RangeError().constructor.name 'RangeError'  ```    #### [26.4.2 Error instance property `.message`](#error.message)    `.message` contains just the error message:    ```js const err = new Error('Hello!'); assert.equal(String(err), 'Error: Hello!'); assert.equal(err.message, 'Hello!');  ```    If we omit the message then the empty string is used as a default value (inherited from `Error.prototype.message`):    If we omit the message, it is the empty string:    ```js assert.equal(new Error().message, '');  ```    #### [26.4.3 Error instance property `.stack`](#error-stack)    The instance property `.stack` is not an ECMAScript feature, but is widely supported by JavaScript engines. It is usually a string, but its exact structure is not standardized and varies between engines.    This is what it looks like on the JavaScript engine V8:    ```js function h(z) {  const error = new Error();  console.log(error.stack); } function g(y) {  h(y + 1); } function f(x) {  g(x + 1); } f(3);  ```    Output:    ```js Error  at h (demos/async-js/stack_trace.mjs:2:17)  at g (demos/async-js/stack_trace.mjs:6:3)  at f (demos/async-js/stack_trace.mjs:9:3)  at demos/async-js/stack_trace.mjs:11:1  ```    The first line of this *stack trace* (a trace of the call stack) shows that the `Error` was created in line 2\\. The last line shows that everything started in line 11.    ### [26.5 Chaining errors: the instance property `.cause` ^(ES2022)](#error-cause)    The instance property `.cause` is created via the options object in the second parameter of `new Error()`. It specifies which other error caused the current one.    ```js const err = new Error('msg', {cause: 'the cause'}); assert.equal(err.cause, 'the cause');  ```    #### [26.5.1 Why would we want to chain errors?](#why-would-we-want-to-chain-errors)    Sometimes, we catch errors that are thrown during a more deeply nested function call and would like to attach more information to it:    ```js function readFiles(filePaths) {  return filePaths.map(  (filePath) => {  try {  const text = readText(filePath);  const json = JSON.parse(text);  return processJson(json);  } catch (error) {  throw new Error( // (A)  `While processing ${filePath}`,  {cause: error}  );  }  }); }  ```    The statements inside the `try` clause may throw all kinds of errors. At the locations where those errors are thrown, there is often no awareness of the file that caused them. That’s why we attach that information in line A.    If an error is shown on the console (e.g. because it was caught or logged) or if we use Node’s `util.inspect()` (line A), we can see the cause and its stack trace:    ```js import assert from 'node:assert/strict'; import * as util from 'node:util';  `outerFunction();`  ``` `function outerFunction() {`  `try {`  `innerFunction();`  `} catch (err) {`  `const errorWithCause = new Error(`  `'Outer error', {cause: err}`  `);`  `assert.deepEqual(`  `util.inspect(errorWithCause).split(/\\r?\\n/), // (A)`  `[`  `'Error: Outer error',`  `'    at outerFunction (file:///tmp/main.mjs:10:28)',`  `'    at file:///tmp/main.mjs:4:1',`  `'    ... 2 lines matching cause stack trace ...',`  `'  [cause]: TypeError: The cause',`  `'      at innerFunction (file:///tmp/main.mjs:31:9)',`  `'      at outerFunction (file:///tmp/main.mjs:8:5)',`  `'      at file:///tmp/main.mjs:4:1',`  `'}',`  `]`  `);`  `}` `}`  `` `function innerFunction() {`  `throw new TypeError('The cause');` `}` `` ```js  ```   ```js``` `````", "```js import assert from 'node:assert/strict'; import * as util from 'node:util';  `const error = new Error(`  `'Could not reach server', {`  `cause: {server: 'https://127.0.0.1'}`  `}` `);` `assert.deepEqual(`  `util.inspect(error).split(/\\r?\\n/),`  `[`  `\"Error: Could not reach server\",`  `\"    at file:///tmp/main.mjs:4:15\",`  `\"  [cause]: { server: 'https://127.0.0.1' }\",`  `\"}\",`  `]` `);`  ```", "```js` Some people recommend using `.cause` to provide data as context for an error. What are the pros and cons of doing that?    *   Pro: The context data is displayed nicely alongside the error. *   Cons:     *   `.cause` only supports arbitrary data because in JavaScript, we can `throw` arbitrary data. Using it for non-thrown data means we are kind of misusing this mechanism.     *   If we use `.cause` for context data, we can’t chain exceptions anymore.    ### [26.6 Subclasses of `Error`](#subclasses-of-error)    #### [26.6.1 The built-in subclasses of `Error`](#built-in-error-subclasses)    `Error` has the following subclasses – quoting [the ECMAScript specification](https://tc39.es/ecma262/#sec-native-error-types-used-in-this-standard):    *   [`AggregateError`](ch_promises.html#AggregateError) ^(ES2021) represents multiple errors at once. In the standard library, only `Promise.any()` uses it. *   `RangeError` indicates a value that is not in the set or range of allowable values. *   `ReferenceError` indicates that an invalid reference value has been detected. *   `SyntaxError` indicates that a parsing error has occurred. *   `TypeError` is used to indicate an unsuccessful operation when none of the other *NativeError* objects are an appropriate indication of the failure cause. *   `URIError` indicates that one of the global URI handling functions was used in a way that is incompatible with its definition.    #### [26.6.2 Subclassing `Error`](#subclassing-error)    Since ECMAScript 2022, the `Error` constructor accepts two parameters (see previous subsection). Therefore, we have two choices when subclassing it: We can either omit the constructor in our subclass or we can invoke `super()` like this:    ```", "```js ```", "```js`` ```", "```js ```", "```js` ```", "```js`` ```"]