["```js\nclass Person {\n #firstName; // (A)\n constructor(firstName) {\n this.#firstName = firstName; // (B)\n }\n describe() {\n return `Person named ${this.#firstName}`;\n }\n static extractNames(persons) {\n return persons.map(person => person.#firstName);\n }\n}\nconst tarzan = new Person('Tarzan');\nassert.equal(\n tarzan.describe(),\n 'Person named Tarzan'\n);\nassert.deepEqual(\n Person.extractNames([tarzan, new Person('Cheeta')]),\n ['Tarzan', 'Cheeta']\n);\n```", "```js\nclass Employee extends Person {\n constructor(firstName, title) {\n super(firstName);\n this.title = title; // (C)\n }\n describe() {\n return super.describe() +\n ` (${this.title})`;\n }\n}\n\nconst jane = new Employee('Jane', 'CTO');\nassert.equal(\n jane.title,\n 'CTO'\n);\nassert.equal(\n jane.describe(),\n 'Person named Jane (CTO)'\n);\n```", "```js\nclass Person {\n #firstName; // (A)\n constructor(firstName) {\n this.#firstName = firstName; // (B)\n }\n describe() {\n return `Person named ${this.#firstName}`;\n }\n static extractNames(persons) {\n return persons.map(person => person.#firstName);\n }\n}\n```", "```js\nconst jane = new Person('Jane');\nconst tarzan = new Person('Tarzan');\n```", "```js\n    assert.deepEqual(\n     Reflect.ownKeys(jane),\n     []\n    );\n    ```", "```js\n    assert.equal(\n     jane.describe(), 'Person named Jane'\n    );\n    assert.equal(\n     tarzan.describe(), 'Person named Tarzan'\n    );\n    ```", "```js\n    assert.deepEqual(\n     Person.extractNames([jane, tarzan]),\n     ['Jane', 'Tarzan']\n    );\n    ```", "```js\nclass Container {\n constructor(value) {\n this.value = value;\n }\n}\nconst abcContainer = new Container('abc');\nassert.equal(\n abcContainer.value, 'abc'\n);\n```", "```js\n// Anonymous class expression\nconst Person = class { \u00b7\u00b7\u00b7 };\n\n// Named class expression\nconst Person = class MyClass { \u00b7\u00b7\u00b7 };\n```", "```js\n> new Person('Jane') instanceof Person\ntrue\n> {} instanceof Person\nfalse\n> {} instanceof Object\ntrue\n> [] instanceof Array\ntrue\n```", "```js\nclass MyClass {\n #instancePrivateField = 1;\n instanceProperty = 2;\n getInstanceValues() {\n return [\n this.#instancePrivateField,\n this.instanceProperty,\n ];\n }\n}\nconst inst = new MyClass();\nassert.deepEqual(\n inst.getInstanceValues(), [1, 2]\n);\n```", "```js\nassert.deepEqual(\n Reflect.ownKeys(inst),\n ['instanceProperty']\n);\n```", "```js\nclass SuperClass {\n #superProp = 'superProp';\n}\nclass SubClass extends SuperClass {\n getSuperProp() {\n return this.#superProp;\n }\n}\n// SyntaxError: Private field '#superProp'\n// must be declared in an enclosing class\n```", "```js\nclass MyClass {\n #instancePrivateField = 1;\n instanceProperty = 2;\n getInstanceValues() {\n return [\n this.#instancePrivateField,\n this.instanceProperty,\n ];\n }\n}\n```", "```js\nlet MyClass;\n{ // Scope of the body of the class\n const instancePrivateFieldKey = Symbol();\n MyClass = class {\n // Very loose approximation of how this\n // works in the language specification\n __PrivateElements__ = new Map([\n [instancePrivateFieldKey, 1],\n ]);\n instanceProperty = 2;\n getInstanceValues() {\n return [\n this.__PrivateElements__.get(instancePrivateFieldKey),\n this.instanceProperty,\n ];\n }\n }\n}\n```", "```js\nclass Color {\n #name; // (A)\n constructor(name) {\n this.#name = name; // (B)\n }\n static getName(obj) {\n return obj.#name;\n }\n}\nclass Person {\n #name; // (C)\n constructor(name) {\n this.#name = name;\n }\n}\n\nassert.equal(\n Color.getName(new Color('green')), 'green'\n);\n\n// We can\u2019t access the private slot #name of a Person in line B:\nassert.throws(\n () => Color.getName(new Person('Jane')),\n {\n name: 'TypeError',\n message: 'Cannot read private member #name from'\n + ' an object whose class did not declare it',\n }\n);\n```", "```js\nclass SuperClass {\n #privateField = 'super';\n getSuperPrivateField() {\n return this.#privateField;\n }\n}\nclass SubClass extends SuperClass {\n #privateField = 'sub';\n getSubPrivateField() {\n return this.#privateField;\n }\n}\nconst inst = new SubClass();\nassert.equal(\n inst.getSuperPrivateField(), 'super'\n);\nassert.equal(\n inst.getSubPrivateField(), 'sub'\n);\n```", "```js\nclass Color {\n #name;\n constructor(name) {\n this.#name = name;\n }\n static check(obj) {\n return #name in obj; // (A)\n }\n}\n```", "```js\nclass C1 {\n #priv() {}\n static check(obj) {\n return #priv in obj;\n }\n}\nassert.equal(C1.check(new C1()), true);\n```", "```js\nclass C2 {\n static #priv = 1;\n static check(obj) {\n return #priv in obj;\n }\n}\nassert.equal(C2.check(C2), true);\nassert.equal(C2.check(new C2()), false);\n```", "```js\nclass C3 {\n static #priv() {}\n static check(obj) {\n return #priv in obj;\n }\n}\nassert.equal(C3.check(C3), true);\n```", "```js\nclass Color {\n #name;\n constructor(name) {\n this.#name = name;\n }\n static check(obj) {\n return #name in obj;\n }\n}\nclass Person {\n #name;\n constructor(name) {\n this.#name = name;\n }\n static check(obj) {\n return #name in obj;\n }\n}\n\n// Detecting Color\u2019s #name\nassert.equal(\n Color.check(new Color()), true\n);\nassert.equal(\n Color.check(new Person()), false\n);\n\n// Detecting Person\u2019s #name\nassert.equal(\n Person.check(new Person()), true\n);\nassert.equal(\n Person.check(new Color()), false\n);\n```", "```js\nclass Person {\n #firstName;\n constructor(firstName) {\n this.#firstName = firstName;\n }\n describe() {\n return `Person named ${this.#firstName}`;\n }\n static extractNames(persons) {\n return persons.map(person => person.#firstName);\n }\n}\n```", "```js\nassert.deepEqual(\n Reflect.ownKeys(Person),\n ['length', 'name', 'prototype', 'extractNames']\n);\n\n// The number of parameters of the constructor\nassert.equal(\n Person.length, 1\n);\n\n// The name of the class\nassert.equal(\n Person.name, 'Person'\n);\n```", "```js\nassert.deepEqual(\n Reflect.ownKeys(Person.prototype),\n ['constructor', 'describe']\n);\n```", "```js\nconst jane = new Person('Jane');\nassert.equal(\n Object.getPrototypeOf(jane), Person.prototype\n);\n\nconst tarzan = new Person('Tarzan');\nassert.equal(\n Object.getPrototypeOf(tarzan), Person.prototype\n);\n```", "```js\n> Person.prototype.constructor === Person\ntrue\n```", "```js\nconst jane = new Person('Jane');\n\nconst cheeta = new jane.constructor('Cheeta');\n// cheeta is also an instance of Person\nassert.equal(cheeta instanceof Person, true);\n```", "```js\nconst tarzan = new Person('Tarzan');\nassert.equal(tarzan.constructor.name, 'Person');\n```", "```js\nclass Person {\n #firstName;\n constructor(firstName) {\n this.#firstName = firstName;\n }\n describe() {\n return 'Person named '+this.#firstName;\n }\n}\nconst jane = new Person('Jane');\n```", "```js\njane.describe()\n```", "```js\n    const func = jane.describe;\n    ```", "```js\n    func.call(jane);\n    ```", "```js\nPerson.prototype.describe.call(jane)\n```", "```js\nconst obj = Object.create(null);\n\n// `obj` is not an instance of Object and doesn\u2019t inherit\n// its prototype method .toString()\nassert.throws(\n () => obj.toString(),\n /^TypeError: obj.toString is not a function$/\n);\nassert.equal(\n Object.prototype.toString.call(obj),\n '[object Object]'\n);\n```", "```js\nfunction StringBuilderConstr(initialString) {\n this.string = initialString;\n}\nStringBuilderConstr.prototype.add = function (str) {\n this.string += str;\n return this;\n};\n\nconst sb = new StringBuilderConstr('\u00a1');\nsb.add('Hola').add('!');\nassert.equal(\n sb.string, '\u00a1Hola!'\n);\n```", "```js\nclass StringBuilderClass {\n constructor(initialString) {\n this.string = initialString;\n }\n add(str) {\n this.string += str;\n return this;\n }\n}\nconst sb = new StringBuilderClass('\u00a1');\nsb.add('Hola').add('!');\nassert.equal(\n sb.string, '\u00a1Hola!'\n);\n```", "```js\nfunction SuperConstructor() {}\nclass SubClass extends SuperConstructor {}\n\nassert.equal(\n new SubClass() instanceof SuperConstructor, true\n);\n```", "```js\n> StringBuilderClass.prototype.constructor === StringBuilderClass\ntrue\n> typeof StringBuilderClass\n'function'\n```", "```js\nclass PublicProtoClass {\n constructor(args) {\n // (Do something with `args` here.)\n }\n publicProtoMethod() {\n return 'publicProtoMethod';\n }\n get publicProtoAccessor() {\n return 'publicProtoGetter';\n }\n set publicProtoAccessor(value) {\n assert.equal(value, 'publicProtoSetter');\n }\n}\n\nassert.deepEqual(\n Reflect.ownKeys(PublicProtoClass.prototype),\n ['constructor', 'publicProtoMethod', 'publicProtoAccessor']\n);\n\nconst inst = new PublicProtoClass('arg1', 'arg2');\nassert.equal(\n inst.publicProtoMethod(), 'publicProtoMethod'\n);\nassert.equal(\n inst.publicProtoAccessor, 'publicProtoGetter'\n);\ninst.publicProtoAccessor = 'publicProtoSetter';\n```", "```js\nconst accessorKey = Symbol('accessorKey');\nconst syncMethodKey = Symbol('syncMethodKey');\nconst syncGenMethodKey = Symbol('syncGenMethodKey');\nconst asyncMethodKey = Symbol('asyncMethodKey');\nconst asyncGenMethodKey = Symbol('asyncGenMethodKey');\n\nclass PublicProtoClass2 {\n // Identifier keys\n get accessor() {}\n set accessor(value) {}\n syncMethod() {}\n * syncGeneratorMethod() {}\n async asyncMethod() {}\n async * asyncGeneratorMethod() {}\n\n // Quoted keys\n get 'an accessor'() {}\n set 'an accessor'(value) {}\n 'sync method'() {}\n * 'sync generator method'() {}\n async 'async method'() {}\n async * 'async generator method'() {}\n\n // Computed keys\n get [accessorKey]() {}\n set [accessorKey](value) {}\n [syncMethodKey]() {}\n * [syncGenMethodKey]() {}\n async [asyncMethodKey]() {}\n async * [asyncGenMethodKey]() {}\n}\n\n// Quoted and computed keys are accessed via square brackets:\nconst inst = new PublicProtoClass2();\ninst['sync method']();\ninst[syncMethodKey]();\n```", "```js\nclass MyClass {\n #privateMethod() {}\n static check() {\n const inst = new MyClass();\n assert.equal(\n #privateMethod in inst, true // (A)\n );\n assert.equal(\n #privateMethod in MyClass.prototype, false\n );\n assert.equal(\n #privateMethod in MyClass, false\n );\n }\n}\nMyClass.check();\n```", "```js\nclass MyClass {\n #privateMethod() {}\n static check() {\n const inst1 = new MyClass();\n const inst2 = new MyClass();\n assert.equal(\n inst1.#privateMethod,\n inst2.#privateMethod\n );\n }\n}\n```", "```js\nclass PrivateMethodClass {\n #privateMethod() {\n return 'privateMethod';\n }\n get #privateAccessor() {\n return 'privateGetter';\n }\n set #privateAccessor(value) {\n assert.equal(value, 'privateSetter');\n }\n callPrivateMembers() {\n assert.equal(this.#privateMethod(), 'privateMethod');\n assert.equal(this.#privateAccessor, 'privateGetter');\n this.#privateAccessor = 'privateSetter';\n }\n}\nassert.deepEqual(\n Reflect.ownKeys(new PrivateMethodClass()), []\n);\n```", "```js\nclass PrivateMethodClass2 {\n get #accessor() {}\n set #accessor(value) {}\n #syncMethod() {}\n * #syncGeneratorMethod() {}\n async #asyncMethod() {}\n async * #asyncGeneratorMethod() {}\n}\n```", "```js\nclass InstPublicClass {\n // Instance public field\n instancePublicField = 0; // (A)\n\n constructor(value) {\n // We don\u2019t need to mention .property elsewhere!\n this.property = value; // (B)\n }\n}\n\nconst inst = new InstPublicClass('constrArg');\nassert.deepEqual(\n Reflect.ownKeys(inst),\n ['instancePublicField', 'property']\n);\nassert.equal(\n inst.instancePublicField, 0\n);\nassert.equal(\n inst.property, 'constrArg'\n);\n```", "```js\nconst computedFieldKey = Symbol('computedFieldKey');\nclass InstPublicClass2 {\n 'quoted field key' = 1;\n [computedFieldKey] = 2;\n}\nconst inst = new InstPublicClass2();\nassert.equal(inst['quoted field key'], 1);\nassert.equal(inst[computedFieldKey], 2);\n```", "```js\nclass MyClass {\n instancePublicField = this;\n}\nconst inst = new MyClass();\nassert.equal(\n inst.instancePublicField, inst\n);\n```", "```js\nclass SuperClass {\n superProp = console.log('superProp');\n constructor() {\n console.log('super-constructor');\n }\n}\nclass SubClass extends SuperClass {\n subProp = console.log('subProp');\n constructor() {\n console.log('BEFORE super()');\n super();\n console.log('AFTER super()');\n }\n}\nnew SubClass();\n\n// Output:\n// 'BEFORE super()'\n// 'superProp'\n// 'super-constructor'\n// 'subProp'\n// 'AFTER super()'\n```", "```js\nclass InstPrivateClass {\n #privateField1 = 'private field 1'; // (A)\n #privateField2; // (B) required!\n constructor(value) {\n this.#privateField2 = value; // (C)\n }\n /**\n * Private fields are not accessible outside the class body.\n */\n checkPrivateValues() {\n assert.equal(\n this.#privateField1, 'private field 1'\n );\n assert.equal(\n this.#privateField2, 'constructor argument'\n );\n }\n}\n\nconst inst = new InstPrivateClass('constructor argument');\n inst.checkPrivateValues();\n\n// No instance properties were created\nassert.deepEqual(\n Reflect.ownKeys(inst),\n []\n);\n```", "```js\nclass Countdown {\n constructor(counter, action) {\n this._counter = counter;\n this._action = action;\n }\n dec() {\n this._counter--;\n if (this._counter === 0) {\n this._action();\n }\n }\n}\n\n// The two properties aren\u2019t really private:\nassert.deepEqual(\n Object.keys(new Countdown()),\n ['_counter', '_action']);\n```", "```js\nconst _counter = new WeakMap();\nconst _action = new WeakMap();\n\nclass Countdown {\n constructor(counter, action) {\n _counter.set(this, counter);\n _action.set(this, action);\n }\n dec() {\n let counter = _counter.get(this);\n counter--;\n _counter.set(this, counter);\n if (counter === 0) {\n _action.get(this)();\n }\n }\n}\n\n// The two pseudo-properties are truly private:\nassert.deepEqual(\n Object.keys(new Countdown()),\n []);\n```", "```js\nlet Countdown;\n{ // class scope\n const _counter = new WeakMap();\n const _action = new WeakMap();\n\n Countdown = class {\n // \u00b7\u00b7\u00b7\n }\n}\n```", "```js\nconst _counter = new WeakMap();\nconst _action = new WeakMap();\n\nclass Countdown {\n constructor(counter, action) {\n _counter.set(this, counter);\n _action.set(this, action);\n }\n dec() {\n privateDec(this);\n }\n}\n\nfunction privateDec(_this) { // (A)\n let counter = _counter.get(_this);\n counter--;\n _counter.set(_this, counter);\n if (counter === 0) {\n _action.get(_this)();\n }\n}\n```", "```js\nconst _superProp = new WeakMap();\nclass SuperClass {\n constructor() {\n _superProp.set(this, 'superProp');\n }\n}\nclass SubClass extends SuperClass {\n getSuperProp() {\n return _superProp.get(this);\n }\n}\nassert.equal(\n new SubClass().getSuperProp(),\n 'superProp'\n);\n```", "```js\nclass StaticPublicMethodsClass {\n static staticMethod() {\n return 'staticMethod';\n }\n static get staticAccessor() {\n return 'staticGetter';\n }\n static set staticAccessor(value) {\n assert.equal(value, 'staticSetter');\n }\n}\nassert.equal(\n StaticPublicMethodsClass.staticMethod(), 'staticMethod'\n);\nassert.equal(\n StaticPublicMethodsClass.staticAccessor, 'staticGetter'\n);\nStaticPublicMethodsClass.staticAccessor = 'staticSetter';\n```", "```js\nconst accessorKey = Symbol('accessorKey');\nconst syncMethodKey = Symbol('syncMethodKey');\nconst syncGenMethodKey = Symbol('syncGenMethodKey');\nconst asyncMethodKey = Symbol('asyncMethodKey');\nconst asyncGenMethodKey = Symbol('asyncGenMethodKey');\n\nclass StaticPublicMethodsClass2 {\n // Identifier keys\n static get accessor() {}\n static set accessor(value) {}\n static syncMethod() {}\n static * syncGeneratorMethod() {}\n static async asyncMethod() {}\n static async * asyncGeneratorMethod() {}\n\n // Quoted keys\n static get 'an accessor'() {}\n static set 'an accessor'(value) {}\n static 'sync method'() {}\n static * 'sync generator method'() {}\n static async 'async method'() {}\n static async * 'async generator method'() {}\n\n // Computed keys\n static get [accessorKey]() {}\n static set [accessorKey](value) {}\n static [syncMethodKey]() {}\n static * [syncGenMethodKey]() {}\n static async [asyncMethodKey]() {}\n static async * [asyncGenMethodKey]() {}\n}\n\n// Quoted and computed keys are accessed via square brackets:\nStaticPublicMethodsClass2['sync method']();\nStaticPublicMethodsClass2[syncMethodKey]();\n```", "```js\nconst computedFieldKey = Symbol('computedFieldKey');\nclass StaticPublicFieldClass {\n static identifierFieldKey = 1;\n static 'quoted field key' = 2;\n static [computedFieldKey] = 3;\n}\n\nassert.deepEqual(\n Reflect.ownKeys(StaticPublicFieldClass),\n [\n 'length', // number of constructor parameters\n 'name', // 'StaticPublicFieldClass'\n 'prototype',\n 'identifierFieldKey',\n 'quoted field key',\n computedFieldKey,\n ],\n);\n\nassert.equal(StaticPublicFieldClass.identifierFieldKey, 1);\nassert.equal(StaticPublicFieldClass['quoted field key'], 2);\nassert.equal(StaticPublicFieldClass[computedFieldKey], 3);\n```", "```js\nclass StaticPrivateClass {\n // Declare and initialize\n static #staticPrivateField = 'hello'; // (A)\n static #twice() { // (B)\n const str = StaticPrivateClass.#staticPrivateField;\n return str + ' ' + str;\n }\n static getResultOfTwice() {\n return StaticPrivateClass.#twice();\n }\n}\n\nassert.deepEqual(\n Reflect.ownKeys(StaticPrivateClass),\n [\n 'length', // number of constructor parameters\n 'name', // 'StaticPublicFieldClass'\n 'prototype',\n 'getResultOfTwice',\n ],\n);\n\nassert.equal(\n StaticPrivateClass.getResultOfTwice(),\n 'hello hello'\n);\n```", "```js\nclass MyClass {\n static #staticPrivateMethod() {}\n static * #staticPrivateGeneratorMethod() {}\n\n static async #staticPrivateAsyncMethod() {}\n static async * #staticPrivateAsyncGeneratorMethod() {}\n\n static get #staticPrivateAccessor() {}\n static set #staticPrivateAccessor(value) {}\n}\n```", "```js\nclass Translator {\n static translations = {\n yes: 'ja',\n no: 'nein',\n maybe: 'vielleicht',\n };\n static englishWords = [];\n static germanWords = [];\n static { // (A)\n for (const [english, german] of Object.entries(this.translations)) {\n this.englishWords.push(english);\n this.germanWords.push(german);\n }\n }\n}\n```", "```js\nclass SuperClass {\n static superField1 = console.log('superField1');\n static {\n assert.equal(this, SuperClass);\n console.log('static block 1 SuperClass');\n }\n static superField2 = console.log('superField2');\n static {\n console.log('static block 2 SuperClass');\n }\n}\n\nclass SubClass extends SuperClass {\n static subField1 = console.log('subField1');\n static {\n assert.equal(this, SubClass);\n console.log('static block 1 SubClass');\n }\n static subField2 = console.log('subField2');\n static {\n console.log('static block 2 SubClass');\n }\n}\n\n// Output:\n// 'superField1'\n// 'static block 1 SuperClass'\n// 'superField2'\n// 'static block 2 SuperClass'\n// 'subField1'\n// 'static block 1 SubClass'\n// 'subField2'\n// 'static block 2 SubClass'\n```", "```js\nclass SuperClass {\n static publicData = 1;\n\n static getPublicViaThis() {\n return this.publicData;\n }\n}\nclass SubClass extends SuperClass {\n}\n```", "```js\nassert.equal(SuperClass.getPublicViaThis(), 1);\n```", "```js\nassert.equal(SubClass.getPublicViaThis(), 1);\n```", "```js\nclass SuperClass {\n static #privateData = 2;\n static getPrivateDataViaThis() {\n return this.#privateData;\n }\n static getPrivateDataViaClassName() {\n return SuperClass.#privateData;\n }\n}\nclass SubClass extends SuperClass {\n}\n```", "```js\nassert.equal(SuperClass.getPrivateDataViaThis(), 2);\n```", "```js\nassert.throws(\n () => SubClass.getPrivateDataViaThis(),\n {\n name: 'TypeError',\n message: 'Cannot read private member #privateData from'\n + ' an object whose class did not declare it',\n }\n);\n```", "```js\nassert.equal(SubClass.getPrivateDataViaClassName(), 2);\n```", "```js\nclass DemoClass {\n static #staticPrivateField = 1;\n #instPrivField = 2;\n\n static staticMethod(inst) {\n // A static method can access static private fields\n // and instance private fields\n assert.equal(DemoClass.#staticPrivateField, 1);\n assert.equal(inst.#instPrivField, 2);\n }\n\n protoMethod() {\n // A prototype method can access instance private fields\n // and static private fields\n assert.equal(this.#instPrivField, 2);\n assert.equal(DemoClass.#staticPrivateField, 1);\n }\n}\n```", "```js\n// Accessing private fields outside their classes triggers\n// syntax errors (before the code is even executed).\nassert.throws(\n () => eval('DemoClass.#staticPrivateField'),\n {\n name: 'SyntaxError',\n message: \"Private field '#staticPrivateField' must\"\n + \" be declared in an enclosing class\",\n }\n);\n// Accessing private fields outside their classes triggers\n// syntax errors (before the code is even executed).\nassert.throws(\n () => eval('new DemoClass().#instPrivField'),\n {\n name: 'SyntaxError',\n message: \"Private field '#instPrivField' must\"\n + \" be declared in an enclosing class\",\n }\n);\n```", "```js\nclass StaticClass {\n static #secret = 'Rumpelstiltskin';\n static #getSecretInParens() {\n return `(${StaticClass.#secret})`;\n }\n static callStaticPrivateMethod() {\n return StaticClass.#getSecretInParens();\n }\n}\n```", "```js\nconst secret = 'Rumpelstiltskin';\nfunction getSecretInParens() {\n return `(${secret})`;\n}\n\n// Only the class is accessible outside the module\nexport class StaticClass {\n static callStaticPrivateMethod() {\n return getSecretInParens();\n }\n}\n```", "```js\nclass Point {\n static fromPolar(radius, angle) {\n const x = radius * Math.cos(angle);\n const y = radius * Math.sin(angle);\n return new Point(x, y);\n }\n constructor(x=0, y=0) {\n this.x = x;\n this.y = y;\n }\n}\n\nassert.deepEqual(\n Point.fromPolar(13, 0.39479111969976155),\n new Point(12, 5)\n);\n```", "```js\n// Only accessible inside the current module\nconst secretToken = Symbol('secretToken'); // (A)\n\nexport class Point {\n static create(x=0, y=0) {\n return new Point(secretToken, x, y);\n }\n static fromPolar(radius, angle) {\n const x = radius * Math.cos(angle);\n const y = radius * Math.sin(angle);\n return new Point(secretToken, x, y);\n }\n constructor(token, x, y) {\n if (token !== secretToken) {\n throw new TypeError('Must use static factory method');\n }\n this.x = x;\n this.y = y;\n }\n}\nPoint.create(3, 4); // OK\nassert.throws(\n () => new Point(3, 4),\n TypeError\n);\n```", "```js\nclass Person {\n #firstName;\n constructor(firstName) {\n this.#firstName = firstName;\n }\n describe() {\n return `Person named ${this.#firstName}`;\n }\n static extractNames(persons) {\n return persons.map(person => person.#firstName);\n }\n}\n\nclass Employee extends Person {\n constructor(firstName, title) {\n super(firstName);\n this.title = title;\n }\n describe() {\n return super.describe() +\n ` (${this.title})`;\n }\n}\n\nconst jane = new Employee('Jane', 'CTO');\nassert.equal(\n jane.title,\n 'CTO'\n);\nassert.equal(\n jane.describe(),\n 'Person named Jane (CTO)'\n);\n```", "```js\n> 'extractNames' in Employee\ntrue\n```", "```js\n> Object.getPrototypeOf(Person.prototype) === Object.prototype\ntrue\n```", "```js\n> Object.getPrototypeOf(Person) === Function.prototype\ntrue\n```", "```js\nx instanceof C\nC.prototype.isPrototypeOf(x)\n```", "```js\n> jane instanceof Employee\ntrue\n> jane instanceof Person\ntrue\n> jane instanceof Object\ntrue\n```", "```js\n> 'abc' instanceof String\nfalse\n> 123 instanceof Number\nfalse\n```", "```js\nassert.equal(\n {a: 1} instanceof Object, true\n);\nassert.equal(\n ['a'] instanceof Object, true\n);\nassert.equal(\n /abc/g instanceof Object, true\n);\nassert.equal(\n new Map() instanceof Object, true\n);\n\nclass C {}\nassert.equal(\n new C() instanceof Object, true\n);\n```", "```js\nconst obj1 = {__proto__: null};\nassert.equal(\n typeof obj1, 'object' // (A)\n);\nassert.equal(\n obj1 instanceof Object, false // (B)\n);\n\nconst obj2 = Object.create(null);\nassert.equal(\n typeof obj2, 'object' // (C)\n);\nassert.equal(\n obj2 instanceof Object, false // (D)\n);\n```", "```js\n> typeof Object.prototype\n'object'\n> Object.getPrototypeOf(Object.prototype)\nnull\n> Object.prototype instanceof Object\nfalse\n```", "```js\nconst p = Object.getPrototypeOf.bind(Object);\n```", "```js\n> p({}) === Object.prototype\ntrue\n> p(p({})) === null\ntrue\n```", "```js\n> p([]) === Array.prototype\ntrue\n> p(p([])) === Object.prototype\ntrue\n> p(p(p([]))) === null\ntrue\n```", "```js\n> p(function () {}) === Function.prototype\ntrue\n> p(p(function () {})) === Object.prototype\ntrue\n```", "```js\nclass A {}\nassert.equal(\n Object.getPrototypeOf(A),\n Function.prototype\n);\n\nassert.equal(\n Object.getPrototypeOf(class {}),\n Function.prototype\n);\n```", "```js\nclass B extends A {}\nassert.equal(\n Object.getPrototypeOf(B),\n A\n);\n\nassert.equal(\n Object.getPrototypeOf(class extends Object {}),\n Object\n);\n```", "```js\n> Object.getPrototypeOf(Object) === Function.prototype\ntrue\n> Object.getPrototypeOf(Array) === Function.prototype\ntrue\n> Object.getPrototypeOf(Function) === Function.prototype\ntrue\n```", "```js\nconst S1 = (Sup) => class extends Sup { /*\u00b7\u00b7\u00b7*/ };\nconst S2 = (Sup) => class extends Sup { /*\u00b7\u00b7\u00b7*/ };\n```", "```js\nclass C extends S2(S1(Object)) {\n /*\u00b7\u00b7\u00b7*/\n}\n```", "```js\nconst Named = (Sup) => class extends Sup {\n name = '(Unnamed)';\n toString() {\n const className = this.constructor.name;\n return `${className} named ${this.name}`;\n }\n};\n```", "```js\nclass City extends Named(Object) {\n constructor(name) {\n super();\n this.name = name;\n }\n}\n```", "```js\nconst paris = new City('Paris');\nassert.equal(\n paris.name, 'Paris'\n);\nassert.equal(\n paris.toString(), 'City named Paris'\n);\n```", "```js\n> {ownProp: true}.hasOwnProperty('ownProp')\ntrue\n> {ownProp: true}.hasOwnProperty('abc')\nfalse\n```", "```js\nconst obj = Object.create(null);\nassert.equal(obj instanceof Object, false);\nassert.throws(\n () => obj.hasOwnProperty('prop'),\n {\n name: 'TypeError',\n message: 'obj.hasOwnProperty is not a function',\n }\n);\n```", "```js\nconst obj = {\n hasOwnProperty: 'yes' // (A)\n};\nassert.throws(\n () => obj.hasOwnProperty('prop'),\n {\n name: 'TypeError',\n message: 'obj.hasOwnProperty is not a function',\n }\n);\n```", "```js\nfunction hasOwnProp(obj, propName) {\n return Object.prototype.hasOwnProperty.call(obj, propName); // (A)\n}\nassert.equal(\n hasOwnProp(Object.create(null), 'prop'), false\n);\nassert.equal(\n hasOwnProp({hasOwnProperty: 'yes'}, 'prop'), false\n);\nassert.equal(\n hasOwnProp({hasOwnProperty: 'yes'}, 'hasOwnProperty'), true\n);\n```", "```js\nconst hasOwnProp = Object.prototype.hasOwnProperty.call\n .bind(Object.prototype.hasOwnProperty);\n```", "```js\n> String({toString() { return 'Hello!' }})\n'Hello!'\n> String({})\n'[object Object]'\n```", "```js\n> undefined.toString()\nTypeError: Cannot read properties of undefined (reading 'toString')\n> null.toString()\nTypeError: Cannot read properties of null (reading 'toString')\n> String(undefined)\n'undefined'\n> String(null)\n'null'\n```", "```js\n> 123.45.toLocaleString('fr')\n'123,45'\n> 123.45.toLocaleString('en')\n'123.45'\n```", "```js\n> Number({valueOf() { return 123 }})\n123\n> Number({})\nNaN\n```", "```js\nconst a = {};\nconst b = {__proto__: a};\nconst c = {__proto__: b};\n\nassert.equal(a.isPrototypeOf(b), true);\nassert.equal(a.isPrototypeOf(c), true);\n\nassert.equal(a.isPrototypeOf(a), false);\nassert.equal(c.isPrototypeOf(a), false);\n```", "```js\nconst obj = {\n // Overrides Object.prototype.isPrototypeOf\n isPrototypeOf: true,\n};\n// Doesn\u2019t work in this case:\nassert.throws(\n () => obj.isPrototypeOf(Object.prototype),\n {\n name: 'TypeError',\n message: 'obj.isPrototypeOf is not a function',\n }\n);\n// Safe way of using .isPrototypeOf():\nassert.equal(\n Object.prototype.isPrototypeOf.call(obj, Object.prototype), false\n);\n```", "```js\nconst proto = {\n enumerableProtoProp: true,\n};\nconst obj = {\n __proto__: proto,\n enumerableObjProp: true,\n nonEnumObjProp: true,\n};\nObject.defineProperty(\n obj, 'nonEnumObjProp',\n {\n enumerable: false,\n }\n);\n\nassert.equal(\n obj.propertyIsEnumerable('enumerableProtoProp'),\n false // not an own property\n);\nassert.equal(\n obj.propertyIsEnumerable('enumerableObjProp'),\n true\n);\nassert.equal(\n obj.propertyIsEnumerable('nonEnumObjProp'),\n false // not enumerable\n);\nassert.equal(\n obj.propertyIsEnumerable('unknownProp'),\n false // not a property\n);\n```", "```js\nconst obj = {\n // Overrides Object.prototype.propertyIsEnumerable\n propertyIsEnumerable: true,\n enumerableProp: 'yes',\n};\n// Doesn\u2019t work in this case:\nassert.throws(\n () => obj.propertyIsEnumerable('enumerableProp'),\n {\n name: 'TypeError',\n message: 'obj.propertyIsEnumerable is not a function',\n }\n);\n// Safe way of using .propertyIsEnumerable():\nassert.equal(\n Object.prototype.propertyIsEnumerable.call(obj, 'enumerableProp'),\n true\n);\n```", "```js\nassert.deepEqual(\n Object.getOwnPropertyDescriptor(obj, 'enumerableProp'),\n {\n value: 'yes',\n writable: true,\n enumerable: true,\n configurable: true,\n }\n);\n```", "```js\nclass Object {\n get __proto__() {\n return Object.getPrototypeOf(this);\n }\n set __proto__(other) {\n Object.setPrototypeOf(this, other);\n }\n // \u00b7\u00b7\u00b7\n}\n```", "```js\n> '__proto__' in {}\ntrue\n> '__proto__' in Object.create(null)\nfalse\n```", "```js\nconst obj = { ownProp: true };\nassert.equal(\n obj.hasOwnProperty('ownProp'), true // own\n);\nassert.equal(\n 'toString' in obj, true // inherited\n);\nassert.equal(\n obj.hasOwnProperty('toString'), false\n);\n```", "```js\nconst obj = {\n // Overrides Object.prototype.hasOwnProperty\n hasOwnProperty: true,\n};\n// Doesn\u2019t work in this case:\nassert.throws(\n () => obj.hasOwnProperty('anyPropKey'),\n {\n name: 'TypeError',\n message: 'obj.hasOwnProperty is not a function',\n }\n);\n// Safe way of using .hasOwnProperty():\nassert.equal(\n Object.prototype.hasOwnProperty.call(obj, 'anyPropKey'), false\n);\n```", "```js\nclass MyClass {\n private value; // (A)\n compare(other) {\n return this.value === other.value;\n }\n}\n```"]