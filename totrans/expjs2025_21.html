<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>17 Booleans</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>17 Booleans</h1>
<blockquote>原文：<a href="https://exploringjs.com/js/book/ch_booleans.html">https://exploringjs.com/js/book/ch_booleans.html</a></blockquote>

        
    
    
    
<p><span id="index-entry-boolean"/></p>
<nav class="local-toc">
  <ol>
    <li>
      <a href="#converting-to-boolean">17.1 Converting to boolean</a>
    </li>
    <li>
      <a href="#falsiness-truthiness">17.2 Falsy and truthy values</a>
      <ol>
        <li>
          <a href="#checking-for-truthiness-or-falsiness">17.2.1 Checking for truthiness or falsiness</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#truthiness-existence-checks">17.3 Truthiness-based existence checks</a>
      <ol>
        <li>
          <a href="#pitfall-truthinessbased-existence-checks-are-imprecise">17.3.1 Pitfall: truthiness-based existence checks are imprecise</a>
        </li>
        <li>
          <a href="#use-case-was-a-parameter-provided">17.3.2 Use case: was a parameter provided?</a>
        </li>
        <li>
          <a href="#use-case-does-a-property-exist">17.3.3 Use case: does a property exist?</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#conditional-operator">17.4 Conditional operator (<code>? :</code>)</a>
    </li>
    <li>
      <a href="#binary-logical-operators">17.5 Binary logical operators: And (<code>x &amp;&amp; y</code>), Or (<code>x || y</code>)</a>
      <ol>
        <li>
          <a href="#value-preservation">17.5.1 Value-preservation</a>
        </li>
        <li>
          <a href="#short-circuiting">17.5.2 Short-circuiting</a>
        </li>
        <li>
          <a href="#logical-and-x--y">17.5.3 Logical And (<code>x &amp;&amp; y</code>)</a>
        </li>
        <li>
          <a href="#logical-or-">17.5.4 Logical Or (<code>||</code>)</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#logical-not">17.6 Logical Not (<code>!</code>)</a>
    </li>
  </ol>
</nav>
<p>The primitive type <em>boolean</em> comprises two values – <code>false</code> and <code>true</code>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">false</span></span>
'boolean'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span></span>
'boolean'
</pre>
<p><span id="index-entry-false"/><span id="index-entry-true"/></p>
<h3 id="converting-to-boolean"><a class="heading-id-link" href="#converting-to-boolean">17.1 Converting to boolean</a></h3>
<p><span id="index-entry-Boolean--"/></p>
<p><span id="index-entry-Converting-to--type-"/></p>
<div class="boxout">
  <p><img src="../Images/38ba63de820aae6f94a019538ae0f222.png" class="boxout-icon" height="24" alt="Icon “details”" data-original-src="https://exploringjs.com/js/book/icon/details.svg"/> <strong>The meaning of “converting to [type]”</strong></p>
  <div class="boxout-vspace"/>
  <p>“Converting to [type]” is short for “Converting arbitrary values to values of type [type]”.</p>
</div>
<p>These are three ways in which we can convert an arbitrary value <code>x</code> to a boolean.</p>
<ul>
  <li>
    <p><code>Boolean(x)</code> <br/>
    Most descriptive; recommended.</p>
  </li>
  <li>
    <p><code>x ? true : false</code> <br/>
    Uses the conditional operator (explained <a href="#conditional-operator">later in this chapter</a>).</p>
  </li>
  <li>
    <p><code>!!x</code> <br/>
    Uses <a href="#logical-not">the logical Not operator (<code>!</code>)</a>. This operator coerces its operand to boolean. It is applied a second time to get a non-negated result.</p>
  </li>
</ul>
<p><a href="#tbl:converting_to_boolean">Table 17.1</a> describes how various values are converted to boolean.</p>
<figure id="tbl:converting_to_boolean" class="float">
  <table class="framed">
    <style>
      th:nth-child(1), td:nth-child(1) {
        text-align: left;
      }
      th:nth-child(2), td:nth-child(2) {
        text-align: left;
      }
    </style>
    <thead>
      <tr>
        <th><code>x</code></th><th><code>Boolean(x)</code></th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>undefined</code></td><td><code>false</code></td>
      </tr>
      <tr>
        <td><code>null</code></td><td><code>false</code></td>
      </tr>
      <tr>
        <td>boolean</td><td><code>x</code> (no change)</td>
      </tr>
      <tr>
        <td>number</td><td><code>0</code> → <code>false</code>, <code>NaN</code> → <code>false</code></td>
      </tr>
      <tr>
        <td/><td>Other numbers → <code>true</code></td>
      </tr>
      <tr>
        <td>bigint</td><td><code>0</code> → <code>false</code></td>
      </tr>
      <tr>
        <td/><td>Other numbers → <code>true</code></td>
      </tr>
      <tr>
        <td>string</td><td><code>''</code> → <code>false</code></td>
      </tr>
      <tr>
        <td/><td>Other strings → <code>true</code></td>
      </tr>
      <tr>
        <td>symbol</td><td><code>true</code></td>
      </tr>
      <tr>
        <td>object</td><td>Always <code>true</code></td>
      </tr>
    </tbody>
  </table>
  <figcaption>
    <p><span class="float-label">Table 17.1:</span> Converting values to booleans.</p>
  </figcaption>
</figure>
<h3 id="falsiness-truthiness"><a class="heading-id-link" href="#falsiness-truthiness">17.2 Falsy and truthy values</a></h3>
<p><span id="index-entry-falsiness"/><span id="index-entry-falsy"/><span id="index-entry-truthiness"/><span id="index-entry-truthy"/></p>
<p>In most locations where JavaScript expects a boolean value, we can instead use an arbitrary value and JavaScript converts it to boolean before using it. Examples include:</p>
<ul>
  <li>
    Condition of an <code>if</code> statement
  </li>
  <li>
    Condition of a <code>while</code> loop
  </li>
  <li>
    Condition of a <code>do-while</code> loop
  </li>
</ul>
<p>Consider the following <code>if</code> statement:</p>
<pre class="language-js">
<span class="hljs-keyword">if</span> (value) {}
</pre>
<p>In many programming languages, this condition is equivalent to:</p>
<pre class="language-js">
<span class="hljs-keyword">if</span> (value === <span class="hljs-literal">true</span>) {}
</pre>
<p>However, in JavaScript, it is equivalent to:</p>
<pre class="language-js">
<span class="hljs-keyword">if</span> (<span class="hljs-title class_">Boolean</span>(value) === <span class="hljs-literal">true</span>) {}
</pre>
<p>That is, JavaScript checks if <code>value</code> is <code>true</code> when converted to boolean. This kind of check is so common that the following names were introduced:</p>
<ul>
  <li>
    A value is called <em>truthy</em> if it is <code>true</code> when converted to boolean.
  </li>
  <li>
    A value is called <em>falsy</em> if it is <code>false</code> when converted to boolean.
  </li>
</ul>
<p>Each value is either truthy or falsy. This is an exhaustive list of falsy values:</p>
<ul>
  <li>
    <code>undefined</code>
  </li>
  <li>
    <code>null</code>
  </li>
  <li>
    Boolean: <code>false</code>
  </li>
  <li>
    Numbers: <code>0</code>, <code>NaN</code>
  </li>
  <li>
    Bigint: <code>0n</code>
  </li>
  <li>
    String: <code>''</code>
  </li>
</ul>
<p>All other values (including all objects) are truthy:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Boolean</span>(<span class="hljs-string">'abc'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Boolean</span>([])</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Boolean</span>({})</span>
true
</pre>
<h4 id="checking-for-truthiness-or-falsiness"><a class="heading-id-link" href="#checking-for-truthiness-or-falsiness">17.2.1 Checking for truthiness or falsiness</a></h4>
<pre class="language-js">
<span class="hljs-keyword">if</span> (x) {
  <span class="hljs-comment">// x is truthy</span>
}
<code/>
<span class="hljs-keyword">if</span> (!x) {
  <span class="hljs-comment">// x is falsy</span>
}
<code/>
<span class="hljs-keyword">if</span> (x) {
  <span class="hljs-comment">// x is truthy</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// x is falsy</span>
}
<code/>
<span class="hljs-keyword">const</span> result = x ? <span class="hljs-string">'truthy'</span> : <span class="hljs-string">'falsy'</span>;
</pre>
<p>The conditional operator that is used in the last line, is explained <a href="#conditional-operator">later in this chapter</a>.</p>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Truthiness</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/booleans/truthiness_exrc.mjs</code></p>
</div>
<h3 id="truthiness-existence-checks"><a class="heading-id-link" href="#truthiness-existence-checks">17.3 Truthiness-based existence checks</a></h3>
<p>In JavaScript, if we read something that doesn’t exist (e.g., a missing parameter or a missing property), we usually get <code>undefined</code> as a result. In these cases, an existence check amounts to comparing a value with <code>undefined</code>. For example, the following code checks if object <code>obj</code> has the property <code>.prop</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">if</span> (obj.<span class="hljs-property">prop</span> !== <span class="hljs-literal">undefined</span>) {
  <span class="hljs-comment">// obj has property .prop</span>
}
</pre>
<p>Due to <code>undefined</code> being falsy, we can shorten this check to:</p>
<pre class="language-js">
<span class="hljs-keyword">if</span> (obj.<span class="hljs-property">prop</span>) {
  <span class="hljs-comment">// obj has property .prop</span>
}
</pre>
<h4 id="pitfall-truthinessbased-existence-checks-are-imprecise"><a class="heading-id-link" href="#pitfall-truthinessbased-existence-checks-are-imprecise">17.3.1 Pitfall: truthiness-based existence checks are imprecise</a></h4>
<p>Truthiness-based existence checks have one pitfall: they are not very precise. Consider this previous example:</p>
<pre class="language-js">
<span class="hljs-keyword">if</span> (obj.<span class="hljs-property">prop</span>) {
  <span class="hljs-comment">// obj has property .prop</span>
}
</pre>
<p>The body of the <code>if</code> statement is skipped if:</p>
<ul>
  <li>
    <code>obj.prop</code> is missing (in which case, JavaScript returns <code>undefined</code>).
  </li>
</ul>
<p>However, it is also skipped if:</p>
<ul>
  <li>
    <code>obj.prop</code> is <code>undefined</code>.
  </li>
  <li>
    <code>obj.prop</code> is any other falsy value (<code>null</code>, <code>0</code>, <code>''</code>, etc.).
  </li>
</ul>
<p>In practice, this rarely causes problems, but we have to be aware of this pitfall.</p>
<h4 id="use-case-was-a-parameter-provided"><a class="heading-id-link" href="#use-case-was-a-parameter-provided">17.3.2 Use case: was a parameter provided?</a></h4>
<p>A truthiness check is often used to determine if the caller of a function provided a parameter:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-keyword">if</span> (!x) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Missing parameter x'</span>);
  }
  <span class="hljs-comment">// ···</span>
}
</pre>
<p>On the plus side, this pattern is established and short. It correctly throws errors for <code>undefined</code> and <code>null</code>.</p>
<p>On the minus side, there is the previously mentioned pitfall: the code also throws errors for all other falsy values.</p>
<p>An alternative is to check for <code>undefined</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">if</span> (x === <span class="hljs-literal">undefined</span>) {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Missing parameter x'</span>);
}
</pre>
<h4 id="use-case-does-a-property-exist"><a class="heading-id-link" href="#use-case-does-a-property-exist">17.3.3 Use case: does a property exist?</a></h4>
<p>Truthiness checks are also often used to determine if a property exists:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">readFile</span>(<span class="hljs-params">fileDesc</span>) {
  <span class="hljs-keyword">if</span> (!fileDesc.<span class="hljs-property">path</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Missing property: .path'</span>);
  }
  <span class="hljs-comment">// ···</span>
}
<span class="hljs-title function_">readFile</span>({ <span class="hljs-attr">path</span>: <span class="hljs-string">'foo.txt'</span> }); <span class="hljs-comment">// no error</span>
</pre>
<p>This pattern is also established and has the usual caveat: it not only throws if the property is missing, but also if it exists and has any of the falsy values.</p>
<p>If we truly want to check if the property exists, we have to use <a href="ch_objects.html#in-operator">the <code>in</code> operator</a>:</p>
<pre class="language-js">
<span class="hljs-keyword">if</span> (! (<span class="hljs-string">'path'</span> <span class="hljs-keyword">in</span> fileDesc)) {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Missing property: .path'</span>);
}
</pre>
<h3 id="conditional-operator"><a class="heading-id-link" href="#conditional-operator">17.4 Conditional operator (<code>? :</code>)</a></h3>
<p><span id="index-entry-conditional-operator"/><span id="index-entry-ternary-operator"/><span id="index-entry--:"/></p>
<p>The conditional operator is the expression version of the <code>if</code> statement. Its syntax is:</p>
<pre class="language-txt">
«condition» ? «thenExpression» : «elseExpression»
</pre>
<p>It is evaluated as follows:</p>
<ul>
  <li>
    If <code>condition</code> is truthy, evaluate and return <code>thenExpression</code>.
  </li>
  <li>
    Otherwise, evaluate and return <code>elseExpression</code>.
  </li>
</ul>
<p>The conditional operator is also called <em>ternary operator</em> because it has three operands.</p>
<p>Examples:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">true</span> ? <span class="hljs-string">'yes'</span> : <span class="hljs-string">'no'</span></span>
'yes'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">false</span> ? <span class="hljs-string">'yes'</span> : <span class="hljs-string">'no'</span></span>
'no'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">''</span> ? <span class="hljs-string">'yes'</span> : <span class="hljs-string">'no'</span></span>
'no'
</pre>
<p>The following code demonstrates that whichever of the two branches “then” and “else” is chosen via the condition, only that branch is evaluated. The other branch isn’t.</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> x = (<span class="hljs-literal">true</span> ? <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'then'</span>) : <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'else'</span>));
</pre>
<p>Output:</p>
<pre>
then
</pre>
<h3 id="binary-logical-operators"><a class="heading-id-link" href="#binary-logical-operators">17.5 Binary logical operators: And (<code>x &amp;&amp; y</code>), Or (<code>x || y</code>)</a></h3>
<p>JavaScript has two binary logical operators:</p>
<ul>
  <li>
    Logical And (<code>x &amp;&amp; y</code>)
  </li>
  <li>
    Logical Or (<code>x || y</code>)
  </li>
</ul>
<p>They are <em>value-preserving</em> and <em>short-circuiting</em>.</p>
<h4 id="value-preservation"><a class="heading-id-link" href="#value-preservation">17.5.1 Value-preservation</a></h4>
<p><span id="index-entry-value-preservation"/></p>
<p><em>Value-preservation</em> means that operands are interpreted as booleans but returned unchanged:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">12</span> || <span class="hljs-string">'hello'</span></span>
12
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">0</span> || <span class="hljs-string">'hello'</span></span>
'hello'
</pre>
<h4 id="short-circuiting"><a class="heading-id-link" href="#short-circuiting">17.5.2 Short-circuiting</a></h4>
<p><span id="index-entry-short-circuiting"/></p>
<p><em>Short-circuiting</em> means if the first operand already determines the result, then the second operand is not evaluated. The only other operator that delays evaluating its operands is the conditional operator. Usually, all operands are evaluated before performing an operation.</p>
<p>For example, logical And (<code>&amp;&amp;</code>) does not evaluate its second operand if the first one is falsy:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> x = <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'hello'</span>);
<span class="hljs-comment">// No output</span>
</pre>
<p>If the first operand is truthy, <code>console.log()</code> is executed:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> x = <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'hello'</span>);
</pre>
<p>Output:</p>
<pre>
hello
</pre>
<h4 id="logical-and-x--y"><a class="heading-id-link" href="#logical-and-x--y">17.5.3 Logical And (<code>x &amp;&amp; y</code>)</a></h4>
<p><span id="index-entry-logical-And"/><span id="index-entry-.x--y"/></p>
<p>The expression <code>a &amp;&amp; b</code> (“<code>a</code> And <code>b</code>”) is evaluated as follows:</p>
<ol>
  <li>
    Evaluate <code>a</code>.
  </li>
  <li>
    Is the result falsy? Return it.
  </li>
  <li>
    Otherwise, evaluate <code>b</code> and return the result.
  </li>
</ol>
<p>In other words, the following two expressions are roughly equivalent:</p>
<pre class="language-js">
a &amp;&amp; b
!a ? a : b
</pre>
<p>Examples:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-literal">true</span></span>
false
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-string">'abc'</span></span>
false
<code/>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-literal">false</span></span>
false
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-string">'abc'</span></span>
'abc'
<code/>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">''</span> &amp;&amp; <span class="hljs-string">'abc'</span></span>
''
</pre>
<h4 id="logical-or-"><a class="heading-id-link" href="#logical-or-">17.5.4 Logical Or (<code>||</code>)</a></h4>
<p><span id="index-entry-logical-Or"/><span id="index-entry-.x--y2"/></p>
<p>The expression <code>a || b</code> (“<code>a</code> Or <code>b</code>”) is evaluated as follows:</p>
<ol>
  <li>
    Evaluate <code>a</code>.
  </li>
  <li>
    Is the result truthy? Return it.
  </li>
  <li>
    Otherwise, evaluate <code>b</code> and return the result.
  </li>
</ol>
<p>In other words, the following two expressions are roughly equivalent:</p>
<pre class="language-js">
a || b
a ? a : b
</pre>
<p>Examples:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">true</span> || <span class="hljs-literal">false</span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">true</span> || <span class="hljs-string">'abc'</span></span>
true
<code/>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">false</span> || <span class="hljs-literal">true</span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">false</span> || <span class="hljs-string">'abc'</span></span>
'abc'
<code/>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'abc'</span> || <span class="hljs-string">'def'</span></span>
'abc'
</pre>
<h5 id="legacy-use-case-for-logical-or--providing-default-values"><a class="heading-id-link" href="#legacy-use-case-for-logical-or--providing-default-values">17.5.4.1 Legacy use case for logical Or (<code>||</code>): providing default values</a></h5>
<p>ECMAScript 2020 introduced the nullish coalescing operator (<code>??</code>) for default values. Before that, logical Or was used for this purpose:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> valueToUse = receivedValue || defaultValue;
</pre>
<p>See <a href="ch_undefined-null.html#nullish-coalescing-operator">“The nullish coalescing operator (<code>??</code>) for default values<span> <sup>ES2020</sup></span>” (§16.4)</a> for more information on <code>??</code> and the downsides of <code>||</code> in this case.</p>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Legacy exercise: Default values via the Or operator (<code>||</code>)</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/booleans/default_via_or_exrc.mjs</code></p>
</div>
<h3 id="logical-not"><a class="heading-id-link" href="#logical-not">17.6 Logical Not (<code>!</code>)</a></h3>
<p><span id="index-entry-logical-Not"/><span id="index-entry--2"/></p>
<p>The expression <code>!x</code> (“Not <code>x</code>”) is evaluated as follows:</p>
<ol>
  <li>
    Evaluate <code>x</code>.
  </li>
  <li>
    Coerce the result to boolean.
  </li>
  <li>
    Is that result <code>true</code>? Return <code>false</code>.
  </li>
  <li>
    Return <code>true</code>.
  </li>
</ol>
<p>Examples:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">!<span class="hljs-literal">false</span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">!<span class="hljs-literal">true</span></span>
false
<code/>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">!<span class="hljs-number">0</span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">!<span class="hljs-number">123</span></span>
false
<code/>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">!<span class="hljs-string">''</span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">!<span class="hljs-string">'abc'</span></span>
false
</pre>

    
      
</body>
</html>