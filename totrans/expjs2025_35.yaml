- en: 29 Modules ES6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_modules.html](https://exploringjs.com/js/book/ch_modules.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[29.1 Cheat sheet: modules](#cheat-sheet-modules)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.1.1 Named exports, named imports, namespace imports](#named-exports-named-imports-namespace-imports)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.1.2 Dynamic imports via `import()` ^(ES2020)](#dynamic-imports-via-import-es2020)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.1.3 Default exports and imports](#default-exports-and-imports)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.1.4 Kinds of module specifiers](#kinds-of-module-specifiers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.2 JavaScript’s source code units: scripts and modules](#source-code-units)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.2.1 Code before built-in modules was written in ECMAScript 5](#code-before-builtin-modules-was-written-in-ecmascript-5)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.3 Before we had modules, we had scripts](#scripts)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.4 Module systems created prior to ES6](#module-systems-created-prior-to-es6)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.4.1 Server side: CommonJS modules](#server-side-commonjs-modules)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.4.2 Client side: AMD (Asynchronous Module Definition) modules](#client-side-amd-asynchronous-module-definition-modules)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.4.3 Characteristics of JavaScript modules](#characteristics-of-javascript-modules)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.5 ECMAScript modules](#ecmascript-modules)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.5.1 ES modules: syntax, semantics, loader API](#es-modules-syntax-semantics-loader-api)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.6 Named exports and imports](#named-exports-and-imports)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.6.1 Named exports](#named-exports)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.6.2 Named imports](#named-imports)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.6.3 Namespace imports](#namespace-imports)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.6.4 Named exporting styles: inline versus clause (advanced)](#named-exporting-styles-inline-versus-clause-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.7 Default exports and default imports](#default-exports-and-default-imports)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.7.1 The two styles of default-exporting](#the-two-styles-of-defaultexporting)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.7.2 The default export as a named export (advanced)](#the-default-export-as-a-named-export-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.7.3 Recommendations: named exports vs. default exports](#recommendations-named-exports-vs-default-exports)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.8 Re-exporting](#re-exporting)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.9 More details on exporting and importing](#more-details-on-exporting-and-importing)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.9.1 Imports are read-only views on exports](#imports-are-readonly-views-on-exports)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.9.2 ESM’s transparent support for cyclic imports (advanced)](#esms-transparent-support-for-cyclic-imports-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.10 Packages: JavaScript’s units for software distribution](#javascript-packages)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.10.1 Publishing packages: package registries, package managers, package
    names](#publishing-packages)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.10.2 The file system layout of a package](#package-file-system-layout)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.10.3 `package.json`](#packagejson)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.10.4 Package exports: controlling what other packages see](#package-exports)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.10.5 Package imports](#package-imports)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.11 Naming modules](#naming-modules)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.12 Module specifiers](#module-specifiers)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.12.1 Kinds of module specifiers](#kinds-of-module-specifiers-1)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.12.2 Filename extensions in module specifiers](#filename-extensions-in-module-specifiers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.12.3 Module specifiers in Node.js](#module-specifiers-in-nodejs)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.12.4 Module specifiers in browsers](#module-specifiers-in-browsers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.13 `import.meta` – metadata for the current module ^(ES2020)](#import.meta)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.13.1 `import.meta.url`](#import.meta.url)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.13.2 `import.meta.url` and class `URL`](#importmetaurl-and-class-url)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.13.3 `import.meta.url` on Node.js](#importmetaurl-on-nodejs)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.14 Loading modules dynamically via `import()` ^(ES2020) (advanced)](#dynamic-imports)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.14.1 The limitations of static `import` statements](#the-limitations-of-static-import-statements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.14.2 Dynamic imports via the `import()` operator](#dynamic-imports-via-the-import-operator)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.14.3 Use cases for `import()`](#use-cases-for-import)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.15 Top-level `await` in modules ^(ES2022) (advanced)](#top-level-await)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.15.1 Use cases for top-level `await`](#use-cases-for-toplevel-await)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.15.2 How does top-level `await` work under the hood?](#how-does-toplevel-await-work-under-the-hood)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.15.3 The pros and cons of top-level `await`](#the-pros-and-cons-of-toplevel-await)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.16 Import attributes: importing non-JavaScript artifacts ^(ES2025)](#import-attributes)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.16.1 The history of importing non-JavaScript artifacts](#the-history-of-importing-nonjavascript-artifacts)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.16.2 Use cases for importing non-JavaScript artifacts](#use-cases-for-importing-nonjavascript-artifacts)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.16.3 Import attributes](#import-attributes-1)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.16.4 The syntax of import attributes](#the-syntax-of-import-attributes)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.16.5 JSON modules ^(ES2025)](#json-modules)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.17 Polyfills: emulating native web platform features (advanced)](#polyfills)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.17.1 Sources of this section](#sources-of-this-section)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.1 Cheat sheet: modules](#cheat-sheet-modules)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[29.1.1 Named exports, named imports, namespace imports](#named-exports-named-imports-namespace-imports)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we put `export` in front of a named entity inside a module, it becomes a
    *named export* of that module. All other entities are private to the module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The string after `from` is called a *module specifier*. It identifies from which
    module we want to import.
  prefs: []
  type: TYPE_NORMAL
- en: '[29.1.2 Dynamic imports via `import()` ^(ES2020)](#dynamic-imports-via-import-es2020)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far, all imports we have seen were *static*, with the following constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: They have to appear at the top level of a module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The module specifier is fixed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dynamic imports via `import()` don’t have those constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[29.1.3 Default exports and imports](#default-exports-and-imports)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *default export* is most often used when a module only contains a single
    entity (even though it can be combined with named exports):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There can be at most one default export. That’s why `const` or `let` can’t
    be default-exported (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the syntax for importing default exports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[29.1.4 Kinds of module specifiers](#kinds-of-module-specifiers)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Module specifiers identify modules. There are three kinds of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Absolute specifiers* are full URLs – for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Absolute specifiers are mostly used to access libraries that are directly hosted
    on the web.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Relative specifiers* are relative URLs (starting with `''/''`, `''./''` or
    `''../''`) – for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Every module has a URL whose protocol depends on its location (`file:`, `https:`,
    etc.). If it uses a relative specifier, JavaScript turns that specifier into a
    full URL by resolving it against the module’s URL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Relative specifiers are mostly used to access other modules within the same
    code base.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Bare specifiers* are paths (without protocol and domain) that start with neither
    slashes nor dots. They begin with the names of packages. Those names can optionally
    be followed by *subpaths*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Bare specifiers can also refer to packages with scoped names:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each bare specifier refers to exactly one module inside a package; if it has
    no subpath, it refers to the designated “main” module of its package.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A bare specifier is never used directly but always *resolved* – translated to
    an absolute specifier. How resolution works depends on the platform.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[29.2 JavaScript’s source code units: scripts and modules](#source-code-units)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What does “source code unit” mean in the world of JavaScript?
  prefs: []
  type: TYPE_NORMAL
- en: A chunk of JavaScript source code (text)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often one unit is stored in a single file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also embed multiple units in a single HTML file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JavaScript has a rich history of source code units: ES6 brought built-in modules,
    but older formats are still around, too. Understanding the latter helps understand
    the former, so let’s investigate. The next sections describe the following ways
    of delivering JavaScript source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Scripts* are code fragments that browsers run in global scope. They are precursors
    of modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CommonJS modules* are a module format designed for servers (e.g., via Node.js).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*AMD modules* are a module format designed for browsers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ECMAScript modules* are JavaScript’s built-in module format. It supersedes
    all previous formats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Table 29.1](#tbl:source-code-units) gives an overview of these source code
    units. Note that we can choose between two filename extensions for CommonJS modules
    and ECMAScript modules. Which choice to make depends on how we want to use a file.
    Details are given later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Usage | Runs on | Loaded | Filename ext. |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Script | Legacy | browsers | async | `.js` |'
  prefs: []
  type: TYPE_TB
- en: '| CommonJS module | Decreasing | servers | sync | `.js .cjs` |'
  prefs: []
  type: TYPE_TB
- en: '| AMD module | Legacy | browsers | async | `.js` |'
  prefs: []
  type: TYPE_TB
- en: '| ECMAScript module | Modern | browsers, servers | async | `.js .mjs` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 29.1: Ways of delivering JavaScript source code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[29.2.1 Code before built-in modules was written in ECMAScript 5](#code-before-builtin-modules-was-written-in-ecmascript-5)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we get to built-in modules (which were introduced with ES6), all code
    that we’ll see, will be written in ES5\. Among other things:'
  prefs: []
  type: TYPE_NORMAL
- en: ES5 did not have `const` and `let`; only `var`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES5 did not have arrow functions; only function expressions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[29.3 Before we had modules, we had scripts](#scripts)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Initially, browsers only had *scripts* – pieces of code that were executed
    in global scope. As an example, consider an HTML file that loads script files
    via the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The main file is `my-module.js`, where we simulate a module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`myModule` is a global variable that is assigned the result of immediately
    invoking a function expression. The function expression starts in the first line.
    It is invoked in the last line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This way of wrapping a code fragment is called *immediately invoked function
    expression* (IIFE, coined by Ben Alman). What do we gain from an IIFE? `var` is
    not block-scoped (like `const` and `let`), it is function-scoped: the only way
    to create new scopes for `var`-declared variables is via functions or methods
    (with `const` and `let`, we can use either functions, methods, or blocks `{}`).
    Therefore, the IIFE in the example hides all of the following variables from global
    scope and minimizes name clashes: `importedFunc1`, `importedFunc2`, `internalFunc`,
    `exportedFunc`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we are using an IIFE in a particular manner: at the end, we pick
    what we want to export and return it via an object literal. That is called the
    *revealing module pattern* (coined by Christian Heilmann).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This way of simulating modules, has several issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Libraries in script files export and import functionality via global variables,
    which risks name clashes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies are not stated explicitly, and there is no built-in way for a script
    to load the scripts it depends on. Therefore, the web page has to load not just
    the scripts that are needed by the page but also the dependencies of those scripts,
    the dependencies’ dependencies, etc. And it has to do so in the right order!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[29.4 Module systems created prior to ES6](#module-systems-created-prior-to-es6)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Prior to ECMAScript 6, JavaScript did not have built-in modules. Therefore,
    the flexible syntax of the language was used to implement custom module systems
    *within* the language. Two popular ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: CommonJS (targeting the server side)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AMD (Asynchronous Module Definition, targeting the client side)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[29.4.1 Server side: CommonJS modules](#server-side-commonjs-modules)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The original CommonJS standard for modules was created for server and desktop
    platforms. It was the foundation of the original Node.js module system, where
    it achieved enormous popularity. Contributing to that popularity were the npm
    package manager for Node and tools that enabled using Node modules on the client
    side (browserify, webpack, and others).
  prefs: []
  type: TYPE_NORMAL
- en: 'From now on, *CommonJS module* means the Node.js version of this standard (which
    has a few additional features). This is an example of a CommonJS module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'CommonJS can be characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Designed for servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules are meant to be loaded *synchronously* (the importer waits while the
    imported module is loaded and executed).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compact syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[29.4.2 Client side: AMD (Asynchronous Module Definition) modules](#client-side-amd-asynchronous-module-definition-modules)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The AMD module format was created to be easier to use in browsers than the CommonJS
    format. Its most popular implementation is [RequireJS](https://requirejs.org).
    The following is an example of an AMD module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'AMD can be characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Designed for browsers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules are meant to be loaded *asynchronously*. That’s a crucial requirement
    for browsers, where code can’t wait until a module has finished downloading. It
    has to be notified once the module is available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The syntax is slightly more complicated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Benefit of AMD modules (and the reason why they work well for browsers): They
    can be executed directly. In contrast, CommonJS modules must either be compiled
    before deployment or custom source code must be generated and evaluated dynamically
    [(think `eval()`)](ch_dynamic-code-evaluation.html#eval). That isn’t always permitted
    on the web.'
  prefs: []
  type: TYPE_NORMAL
- en: '[29.4.3 Characteristics of JavaScript modules](#characteristics-of-javascript-modules)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Looking at CommonJS and AMD, similarities between JavaScript module systems
    emerge:'
  prefs: []
  type: TYPE_NORMAL
- en: There is one module per file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Such a file is basically a piece of code that is executed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Local scope: The code is executed in a local “module scope”. Therefore, by
    default, all of the variables, functions, and classes declared in it are internal
    and not global.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exports: If we want any declared entity to be exported, we must explicitly
    mark it as an export.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Imports: Each module can import exported entities from other modules. Those
    other modules are identified via *module specifiers* (usually paths, occasionally
    full URLs).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Modules are *singletons*: Even if a module is imported multiple times, only
    a single “instance” of it exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No global variables are used. Instead, module specifiers serve as global IDs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[29.5 ECMAScript modules](#ecmascript-modules)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*ECMAScript modules* (*ES modules* or *ESM*) were introduced with ES6\. They
    continue the tradition of JavaScript modules and have all of their aforementioned
    characteristics. Additionally:'
  prefs: []
  type: TYPE_NORMAL
- en: With CommonJS, ES modules share the compact syntax and support for cyclic dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With AMD, ES modules share being designed for asynchronous loading.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES modules also have new benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is even more compact than CommonJS’s.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules have *static* structures (which can’t be changed at runtime). That helps
    with static checking, optimized access of imports, dead code elimination, and
    more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for cyclic imports is completely transparent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is an example of ES module syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: From now on, “module” means “ECMAScript module”.
  prefs: []
  type: TYPE_NORMAL
- en: '[29.5.1 ES modules: syntax, semantics, loader API](#es-modules-syntax-semantics-loader-api)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The full standard of ES modules comprises the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax (how code is written): What is a module? How are imports and exports
    declared? Etc.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Semantics (how code is executed): How are variable bindings exported? How are
    imports connected with exports? Etc.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A programmatic loader API for configuring module loading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parts 1 and 2 were introduced with ES6\. Work on part 3 is ongoing.
  prefs: []
  type: TYPE_NORMAL
- en: '[29.6 Named exports and imports](#named-exports-and-imports)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[29.6.1 Named exports](#named-exports)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each module can have zero or more *named exports*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the following two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Module `my-math.mjs` has two named exports: `square` and `LIGHT_SPEED`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To export something, we put the keyword `export` in front of a declaration.
    Entities that are not exported are private to a module and can’t be accessed from
    outside.
  prefs: []
  type: TYPE_NORMAL
- en: '[29.6.2 Named imports](#named-imports)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Module `main.mjs` has a single named import, `square`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also rename its import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[29.6.2.1 Syntactic pitfall: named importing is not destructuring](#syntactic-pitfall-named-importing-is-not-destructuring)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Both named importing and destructuring look similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'But they are quite different:'
  prefs: []
  type: TYPE_NORMAL
- en: Imports remain connected with their exports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can destructure again inside a destructuring pattern, but the `{}` in an
    import statement can’t be nested.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The syntax for renaming is different:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rationale: Destructuring is reminiscent of an object literal (including nesting),
    while importing evokes the idea of renaming.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Named exports**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/modules/export_named_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[29.6.3 Namespace imports](#namespace-imports)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Namespace imports* are an alternative to named imports. If we namespace-import
    a module, it becomes an object whose properties are the named exports. This is
    what `main.mjs` looks like if we use a namespace import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[29.6.4 Named exporting styles: inline versus clause (advanced)](#named-exporting-styles-inline-versus-clause-advanced)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The named export style we have seen so far was *inline*: We exported entities
    by prefixing them with the keyword `export`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can also use separate *export clauses*. For example, this is what `lib/my-math.mjs`
    looks like with an export clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With an export clause, we can rename before exporting and use different names
    internally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[29.7 Default exports and default imports](#default-exports-and-default-imports)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each module can have at most one *default export*. The idea is that the module
    *is* the default-exported value.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of default exports, consider the following two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Module `my-func.mjs` has a default export:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Module `main.mjs` default-imports the exported function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the syntactic difference: the curly braces around named imports indicate
    that we are reaching *into* the module, while a default import *is* the module.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “question”](../Images/3decb3ca67c240d2bb04742c1f28af18.png) **What are
    use cases for default exports?**'
  prefs: []
  type: TYPE_NORMAL
- en: The most common use case for a default export is a module that contains a single
    function or a single class.
  prefs: []
  type: TYPE_NORMAL
- en: '[29.7.1 The two styles of default-exporting](#the-two-styles-of-defaultexporting)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are two styles of doing default exports.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can label existing declarations with `export default`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Second, we can directly default-export values. This style of `export default`
    is much like a declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[29.7.1.1 Why are there two default export styles?](#why-are-there-two-default-export-styles)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The reason is that `export default` can’t be used to label `const`: `const`
    may define multiple values, but `export default` needs exactly one value. Consider
    the following hypothetical code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With this code, we don’t know which one of the three values is the default export.
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Default exports**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/modules/export_default_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[29.7.2 The default export as a named export (advanced)](#the-default-export-as-a-named-export-advanced)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Internally, a default export is simply a named export whose name is `default`.
    As an example, consider the previous module `my-func.mjs` with a default export:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following module `my-func2.mjs` is equivalent to that module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For importing, we can use a normal default import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can use a named import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The default export is also available via property `.default` of namespace imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “question”](../Images/3decb3ca67c240d2bb04742c1f28af18.png) **Isn’t
    `default` illegal as a variable name?**'
  prefs: []
  type: TYPE_NORMAL
- en: '`default` can’t be a variable name, but it can be an export name and it can
    be a property name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[29.7.3 Recommendations: named exports vs. default exports](#recommendations-named-exports-vs-default-exports)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These are my recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Avoid mixing named exports and default exports: A module can have both named
    exports and a default export, but it’s usually better to stick to one export style
    per module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is one exception: For unit-testing, it can make sense to name-export
    internal functions (etc.) that complement the default export (the public API of
    the module).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In some cases, you may be sure that the module will only ever export a single
    value (usually a function or a class). That is, conceptually, the module *is*
    the value – similarly to a variable. Then a default export is a good option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can never go wrong with only using named exports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[29.8 Re-exporting](#re-exporting)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A module `library.mjs` can export one or more exports of another module `internal.mjs`
    as if it had made them itself. That is called *re-exporting*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The wildcard re-export turns all exports of module `internal.mjs` into exports
    of `library.mjs`, except the default export.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The namespace re-export turns all exports of module `internal.mjs` into an object
    that becomes the named export `ns` of `library.mjs`. Because `internal.mjs` has
    a default export, `ns` has a property `.default`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code demonstrates the two bullet points above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[29.9 More details on exporting and importing](#more-details-on-exporting-and-importing)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[29.9.1 Imports are read-only views on exports](#imports-are-readonly-views-on-exports)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far, we have used imports and exports intuitively, and everything seems to
    have worked as expected. But now it is time to take a closer look at how imports
    and exports are really related.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following two modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`counter.mjs` exports a (mutable!) variable and a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`main.mjs` name-imports both exports. When we use `incCounter()`, we discover
    that the connection to `counter` is live – we can always access the live state
    of that variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note that while the connection is live and we can read `counter`, we cannot
    change this variable (e.g., via `counter++`).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two benefits to handling imports this way:'
  prefs: []
  type: TYPE_NORMAL
- en: It is easier to split modules because previously shared variables can become
    exports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This behavior is crucial for supporting transparent cyclic imports. Read on
    for more information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[29.9.2 ESM’s transparent support for cyclic imports (advanced)](#esms-transparent-support-for-cyclic-imports-advanced)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'ESM supports cyclic imports transparently. To understand how that is achieved,
    consider the following example: [figure 29.1](#fig:module-imports) shows a directed
    graph of modules importing other modules. P importing M is the cycle in this case.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e021933bd9279348226080408fab73a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 29.1: A directed graph of modules importing modules: M imports N and
    O, N imports P and Q, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After parsing, these modules are set up in two phases:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instantiation: Every module is visited and its imports are connected to its
    exports. Before a parent can be instantiated, all of its children must be instantiated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Evaluation: The bodies of the modules are executed. Once again, children are
    evaluated before parents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This approach handles cyclic imports correctly, due to two features of ES modules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the static structure of ES modules, the exports are already known after
    parsing. That makes it possible to instantiate P before its child M: P can already
    look up M’s exports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When P is evaluated, M hasn’t been evaluated, yet. However, entities in P can
    already mention imports from M. They just can’t use them, yet, because the imported
    values are filled in later. For example, a function in P can access an import
    from M. The only limitation is that we must wait until after the evaluation of
    M, before calling that function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imports being filled in later is enabled by them being “live immutable views”
    on exports.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[29.10 Packages: JavaScript’s units for software distribution](#javascript-packages)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the JavaScripte ecosystem, a *package* is a way of organizing software projects:
    It is a directory with a standardized layout. A package can contain all kinds
    of files - for example:'
  prefs: []
  type: TYPE_NORMAL
- en: A web application written in JavaScript, to be deployed on a server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript libraries (for Node.js, for browsers, for all JavaScript platforms,
    etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Libraries for programming languages other than JavaScript: TypeScript, Rust,
    etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests (e.g. for the libraries in the package)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js-based shell scripts – e.g., development tools such as compilers, test
    runners, and documentation generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many other kinds of artifacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A package can *depend on* other packages (which are called its *dependencies*):'
  prefs: []
  type: TYPE_NORMAL
- en: Libraries needed by the package’s JavaScript code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shell scripts used during development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dependencies of a package are installed inside that package (we’ll see how
    soon).
  prefs: []
  type: TYPE_NORMAL
- en: 'One common distinction between packages is:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Published packages* can be installed by us:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Global installation: We can install them globally so that their shell scripts
    become available at the command line.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Local installation: We can install them as dependencies into our own packages.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Unpublished packages* never become dependencies of other packages, but do
    have dependencies themselves. Examples include web applications that are deployed
    to servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next subsection explains how packages can be published.
  prefs: []
  type: TYPE_NORMAL
- en: '[29.10.1 Publishing packages: package registries, package managers, package
    names](#publishing-packages)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The main way of publishing a package is to upload it to a package registry
    – an online software repository. Two popular public registries are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[The *npm registry*](https://www.npmjs.com) is most widely used and the default
    when using Node.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The open-source package registry JSR](https://jsr.io) has special support
    for TypeScript and was created by the makers of the JavaScript runtime Deno.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Companies can also host their own private registries.
  prefs: []
  type: TYPE_NORMAL
- en: A *package manager* is a command line tool that downloads packages from a registry
    (or other sources) and installs them as shell scripts and/or as dependencies.
    The most popular package manager is called *npm* and comes bundled with Node.js.
    Its name originally stood for “Node Package Manager”. Later, when npm and the
    npm registry were used not only for Node.js packages, that meaning was changed
    to “npm is not a package manager” ([source]([https://en.wikipedia.org/wiki/Npm_(software)#Acronym)).](https://en.wikipedia.org/wiki/Npm_(software)#Acronym)).)
    There are other popular package managers such as jsr, vlt, pnpm and yarn. All
    of these package managers support either or both of the npm registry and JSR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore how the npm registry works. Each package has a name. There are
    two kinds of names:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Global names* are unique across the whole registry. These are two examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Scoped names* consist of two parts: A scope and a name. Scopes are globally
    unique, names are unique per scope. These are two examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The scope starts with an `@` symbol and is separated from the name with a slash.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[29.10.2 The file system layout of a package](#package-file-system-layout)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once a package `my-package` is fully installed, it almost always looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: What are the purposes of these file system entries?
  prefs: []
  type: TYPE_NORMAL
- en: '`package.json` is a file every package must have:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It contains metadata describing the package (its name, its version, its author,
    etc.).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It lists the dependencies of the package: other packages that it needs, such
    as libraries and tools. Per dependency, we record:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A range of version numbers. Not specifying a specific version allows for upgrades
    and for code sharing between dependencies.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By default, dependencies come from the npm registry. But we can also specify
    other sources: a local directory, a GZIP file, a URL pointing to a GZIP file,
    a registry other than npm’s, a git repository, etc.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`node_modules/` is a directory into which the dependencies of the package are
    installed. Each dependency also has a `node_modules` folder with its dependencies,
    etc. The result is a tree of dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most packages also have the file `package-lock.json` that sits next to `package.json`:
    It records the exact versions of the dependencies that were installed and is kept
    up to date if we add more dependencies via npm.'
  prefs: []
  type: TYPE_NORMAL
- en: '[29.10.3 `package.json`](#packagejson)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is a starter `package.json` that can be created via npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: What are the purposes of these properties?
  prefs: []
  type: TYPE_NORMAL
- en: 'Some properties are required for public packages (published on the npm registry):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` specifies the name of this package.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version` is used for version management and follows [semantic versioning](https://semver.org)
    with three dot-separated numbers:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *major version* is incremented when incompatible API changes are made.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *minor version* is incremented when functionality is added in a backward
    compatible manner.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *patch version* is incremented when small changes are made that don’t really
    change the functionality.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other properties for public packages are optional:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`, `keywords`, `author` are optional and make it easier to find
    packages.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`license` clarifies how this package can be used. It makes sense to provide
    this value if the package is public in any way. [“Choose an open source license”](https://choosealicense.com)
    can help with making this choice.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main` is a legacy property and has been superseded by `exports`. It points
    to the code of a library package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scripts` is a property for setting up abbreviations for development-time shell
    commands. These can be executed via `npm run`. For example, the script `test`
    can be executed via `npm run test`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More useful properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, the properties `name` and `version` are required and npm warns us
    if they are missing. However, we can change that via the following setting:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That prevents the package from accidentally being published and allows us to
    omit name and version.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`exports` is for *package exports* – which specify how importers see the content
    of this package. We’ll learn more about package exports [later](#package-exports).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imports` is for *package imports* – which define aliases for module specifiers
    that packages can use internally. We’ll learn more about package imports [later](#package-imports).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dependencies` lists the dependencies of a package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`devDependencies` are dependencies that are only installed during development
    (not when a package is added as a dependency).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following setting means that all files with the name extension `.js` are
    interpreted as ECMAScript modules. Unless we are dealing with legacy code, it
    makes sense to add it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`bin` lists modules within the package that are installed as shell scripts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Icon “external”](../Images/38e6ff55e8d602659f3cdb8893e63f62.png) **More information
    on `package.json`**'
  prefs: []
  type: TYPE_NORMAL
- en: See [the npm documentation](https://docs.npmjs.com/files/package.json).
  prefs: []
  type: TYPE_NORMAL
- en: '[29.10.4 Package exports: controlling what other packages see](#package-exports)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[*Package exports*](https://nodejs.org/api/packages.html#packages_package_entry_points)
    are specified via property `"exports"` in `package.json` and support three important
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hiding the internals of a package:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Without property `"exports"`, every module in a package `my-lib` can be accessed
    via a relative path after the package name – e.g.:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Once the property exists, only specifiers listed in it can be used. Everything
    else is hidden from the outside.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nicer module specifiers: Package exports let us change the bare specifier subpaths
    for importing the modules of a package: They can be shorter, extension-less, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Conditional exports: The same module specifier exports different modules –
    depending on which JavaScript platform an importer uses (browser, Node.js, etc.).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we’ll look at some example. For a more detailed explanation of how package
    exports work, see section [“Package exports: controlling what other packages see”](https://exploringjs.com/nodejs-shell-scripting/ch_packages.html#package-exports-controlling-what-other-packages-see)
    in “Shell scripting with Node.js”.'
  prefs: []
  type: TYPE_NORMAL
- en: '[29.10.4.1 Examples: package exports](#examples-package-exports)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Example – specifying which module is imported via the bare specifier of a package
    (in the past, this was specified via property `main`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Example – specifying a better path for a module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Example – specifying better paths for a tree of modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[29.10.4.2 Examples: conditional package exports](#conditional-package-exports)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The examples in this subsection show excerpts of `package.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example – export different modules for Node.js, browsers and other platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Example – development vs. production:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In Node.js we can specify an environment like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[29.10.5 Package imports](#package-imports)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Package imports](https://nodejs.org/api/packages.html#imports) let a package
    define abbreviations for module specifiers that it can use itself, internally
    (where package exports define abbreviations for other packages). This is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the keys of `"imports"` has to start with a hash sign (`#`). The key
    `"#some-pkg"` is *conditional* (with the same features as [conditional package
    exports](#conditional-package-exports)):'
  prefs: []
  type: TYPE_NORMAL
- en: If the current package is used on Node.js, the module specifier `'#some-pkg'`
    refers to package `some-pkg-node-native`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elsewhere, `'#some-pkg'` refers to the file `./polyfills/some-pkg-polyfill.js`
    inside the current package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that only package imports can refer to external packages, package exports
    can’t do that.
  prefs: []
  type: TYPE_NORMAL
- en: What are the use cases for package imports?
  prefs: []
  type: TYPE_NORMAL
- en: Referring to different platform-specific implementations modules via the same
    module specifier (as demonstrated above).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aliases to modules inside the current package – to avoid relative specifiers
    (which can get complicated with deeply nested directories).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[29.10.5.1 Examples: accessing `package.json` via package imports](#examples-accessing-packagejson-via-package-imports)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s explore two ways of accessing `package.json` via package imports.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can define a package import for the root level of the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the import statement looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we can define a package import just for `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the import statement looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[29.11 Naming modules](#naming-modules)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are no established best practices for naming module files and the variables
    they are imported into.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I’m using the following naming style:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The names of module files are dash-cased and only have lowercase letters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The names of namespace imports are camel-cased and start with lowercase letters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The names of default imports are camel-cased and start with lowercase letters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'What is the thinking behind this style? We want module file names to be similar
    to package names:'
  prefs: []
  type: TYPE_NORMAL
- en: Dashes are far more commonly used than underscores in package names. Maybe that
    is influenced by underscores being very rare in domain names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: npm doesn’t allow uppercase letters in package names ([source](https://docs.npmjs.com/cli/v11/configuring-npm/package-json#name)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to CSS, there are clear rules for translating dash-cased names to camel-cased
    names. We can use these rules for namespace imports and default imports.
  prefs: []
  type: TYPE_NORMAL
- en: '[29.12 Module specifiers](#module-specifiers)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Module specifiers* are the strings that identify modules. They work slightly
    differently in browsers and Node.js. Before we can look at the differences, we
    need to learn about the different categories of module specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[29.12.1 Kinds of module specifiers](#kinds-of-module-specifiers-1)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are three kinds of module specifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Absolute specifiers* are full URLs – for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Absolute specifiers are mostly used to access libraries that are directly hosted
    on the web.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Relative specifiers* are relative URLs (starting with `''/''`, `''./''` or
    `''../''`) – for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Every module has a URL whose protocol depends on its location (`file:`, `https:`,
    etc.). If it uses a relative specifier, JavaScript turns that specifier into a
    full URL by resolving it against the module’s URL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Relative specifiers are mostly used to access other modules within the same
    code base.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Bare specifiers* are paths (without protocol and domain) that start with neither
    slashes nor dots. They begin with the names of packages. Those names can optionally
    be followed by *subpaths*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Bare specifiers can also refer to packages with scoped names:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each bare specifier refers to exactly one module inside a package; if it has
    no subpath, it refers to the designated “main” module of its package.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A bare specifier is never used directly but always *resolved* – translated to
    an absolute specifier. How resolution works depends on the platform. We’ll learn
    more soon.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[29.12.2 Filename extensions in module specifiers](#filename-extensions-in-module-specifiers)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Absolute specifiers and relative specifiers always have filename extensions
    – mainly `.js` or `.mjs`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are three styles of bare specifiers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Style 1: no subpath'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Style 2: a subpath without a filename extension. In this case, the subpath
    works like a modifier for the package name:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Style 3: a subpath with a filename extension. In this case, the package is
    seen as a collection of modules and the subpath points to one of them:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Caveat of style 3 bare specifiers: How the filename extension is interpreted
    depends on the dependency and may differ from the importing package. For example,
    the importing package may use `.mjs` for ESM modules and `.js` for CommonJS modules,
    while the ESM modules exported by the dependency may have bare paths with the
    filename extension `.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[29.12.3 Module specifiers in Node.js](#module-specifiers-in-nodejs)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s see how module specifiers work in Node.js. Especially bare specifiers
    are handled differently than in browsers.
  prefs: []
  type: TYPE_NORMAL
- en: '[29.12.3.1 Resolving module specifiers in Node.js](#resolving-module-specifiers-in-nodejs)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The [*Node.js resolution algorithm*](https://nodejs.org/api/esm.html#resolution-algorithm)
    works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URL of importing module
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Module specifier
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Result: Resolved URL for module specifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a specifier is absolute, resolution is already finished. Three protocols
    are most common:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file:` for local files'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https:` for remote files'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`node:` for built-in modules'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If a specifier is relative, it is resolved against the URL of the importing
    module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If a specifier is bare:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it starts with `'#'`, it is resolved by looking it up among the *package
    imports* (which are explained [later](#package-imports)) and resolving the result.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Otherwise, it is a bare specifier that has one of these formats (the subpath
    is optional):'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`«package»/sub/path`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@«scope»/«scoped-package»/sub/path`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The resolution algorithm traverses the current directory and its ancestors
    until it finds a directory `node_modules` that has a subdirectory matching the
    beginning of the bare specifier, i.e. either:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`node_modules/«package»/`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`node_modules/@«scope»/«scoped-package»/`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: That directory is the directory of the package. By default, the (potentially
    empty) subpath after the package ID is interpreted as relative to the package
    directory. The default can be overridden via *package exports* which are explained
    next.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The result of the resolution algorithm must point to a file. That explains why
    absolute specifiers and relative specifiers always have filename extensions. Bare
    specifiers often don’t because they are abbreviations that are looked up in package
    exports.
  prefs: []
  type: TYPE_NORMAL
- en: 'Module files usually have these filename extensions:'
  prefs: []
  type: TYPE_NORMAL
- en: If a file has the name extension `.mjs`, it is always an ES module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A file that has the name extension `.js` is an ES module if the closest `package.json`
    has this entry:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"type": "module"`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If Node.js executes code provided via stdin, `--eval` or `--print`, we use
    [the following command-line option](https://nodejs.org/api/cli.html#--input-typetype)
    so that it is interpreted as an ES module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[29.12.4 Module specifiers in browsers](#module-specifiers-in-browsers)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In browsers, we can write inline modules like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '`type="module"` tells the browser that this is an ESM module and not [a browser
    script](#scripts).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can only use two kinds of module specifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Read on to find out how to work around this limitation and use npm packages.
  prefs: []
  type: TYPE_NORMAL
- en: '[29.12.4.1 Filename extensions in browsers](#filename-extensions-in-browsers)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Browsers don’t care about filename extensions, only about content types.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, we can use any filename extension for ECMAScript modules, as long as
    they are served with [a JavaScript content type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#textjavascript)
    (`text/javascript` is recommended).
  prefs: []
  type: TYPE_NORMAL
- en: '[29.12.4.2 Using npm packages in browsers](#using-npm-packages-in-browsers)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: On Node.js, npm packages are downloaded into the `node_modules` directory and
    accessed via bare module specifiers. Node.js traverses the file system in order
    to find packages. We can’t do that in web browsers. Three approaches are common
    for bringing npm packages to browsers.
  prefs: []
  type: TYPE_NORMAL
- en: '[29.12.4.2.1 Approach 1: Using a content delivery network](#approach-1-using-a-content-delivery-network)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Content delivery networks (CDNs) such as [`unpkg.com`](https://unpkg.com) and
    [`esm.sh`](https://esm.sh) let us import npm packages via URLs. This is what the
    `unpkg.com` URLs look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'One downside of CDNs is that they introduce an additional point of failure:'
  prefs: []
  type: TYPE_NORMAL
- en: CDNs can go offline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a risk of CDNs serving malicious code – e.g. if they are hacked or
    taken over by a new maintainer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[29.12.4.2.2 Approach 2: Using `node_modules` with bare specifiers and a bundler](#approach-2-using-nodemodules-with-bare-specifiers-and-a-bundler)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A [bundler](ch_next-steps.html#bundler) is a build tool. It works roughly as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Given a directory with a web app. We point the bundler to the app’s *entry point*
    – the module where execution starts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It collects everything that module imports (its imports, the imports of the
    imports, etc.).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It produces a *bundle*, a single file with all the code. That file can be used
    from an HTML page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an app has multiple entry points, the bundler produces multiple bundles.
    It’s also possible to tell it to create bundles for parts of the application that
    are loaded on demand.
  prefs: []
  type: TYPE_NORMAL
- en: When bundling, we can use bare import specifiers in files because bundlers know
    how to find the corresponding modules in `node_modules`. Bundlers also honor package
    exports and package imports.
  prefs: []
  type: TYPE_NORMAL
- en: Why bundle?
  prefs: []
  type: TYPE_NORMAL
- en: Loading a single file tends to be faster than loading multiple files – especially
    if there are many small ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bundlers only include code in the file that is really used (which is especially
    relevant for libraries). That saves storage space and also speeds up loading.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A downside of bundling is that we need to bundle the whole app every time we
    want to run it.
  prefs: []
  type: TYPE_NORMAL
- en: '[29.12.4.2.3 Approach 3: Converting npm packages to browser-compatible files](#approach-3-converting-npm-packages-to-browsercompatible-files)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There are package managers for browsers that let us download modules as single
    bundled files that can be used in browsers. As an example, consider the following
    directory of a web app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We used a bundler to install package `lodash-es` into a single file. Module
    `main.js` can import it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: To deploy this app, the contents of `assets/` and `src/` are copied to the production
    server (in addition to non-JavaScript artifacts).
  prefs: []
  type: TYPE_NORMAL
- en: What are the benefits of this approach compared to using a bundler?
  prefs: []
  type: TYPE_NORMAL
- en: We install the external dependencies once and then can always run our app immediately
    – no prior bundling is required (which can be time-consuming).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unbundled code is easier to debug.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[29.12.4.2.4 Improving approach 3: import maps](#import-maps)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Approach 3 can be further improved: [*Import maps*](https://2ality.com/2022/01/esm-specifiers.html#import-maps)
    are a browser technology that lets us define abbreviations for module specifiers
    – e.g. `''lodash-es''` for `''../assets/lodash-es.js''`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what an import map looks like if we store it *inline* – inside an HTML
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also store import maps in external files (the content type must be `application/importmap+json`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the import in `main.js` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[29.13 `import.meta` – metadata for the current module ^(ES2020)](#import.meta)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The object `import.meta` holds metadata for the current module.
  prefs: []
  type: TYPE_NORMAL
- en: '[29.13.1 `import.meta.url`](#import.meta.url)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The most important property of `import.meta` is `.url` which contains a string
    with the URL of the current module’s file – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[29.13.2 `import.meta.url` and class `URL`](#importmetaurl-and-class-url)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Class `URL` is available via a global variable in browsers and on Node.js.
    We can look up its full functionality in [the Node.js documentation](https://nodejs.org/api/url.html#url_class_url).
    When working with `import.meta.url`, its constructor is especially useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Parameter `input` contains the URL to be parsed. It can be relative if the second
    parameter, `base`, is provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, this constructor lets us resolve a relative path against a
    base URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we get a `URL` instance that points to a file `data.txt` that sits
    next to the current module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[29.13.3 `import.meta.url` on Node.js](#importmetaurl-on-nodejs)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On Node.js, `import.meta.url` is always a string with a `file:` URL – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[29.13.3.1 Example: reading a sibling file of a module](#example-reading-a-sibling-file-of-a-module)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Many Node.js file system operations accept either strings with paths or instances
    of `URL`. That enables us to read a sibling file `data.txt` of the current module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[29.13.3.2 Module `fs` and URLs](#module-fs-and-urls)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For most functions of the module `fs`, we can refer to files via:'
  prefs: []
  type: TYPE_NORMAL
- en: Paths – in strings or instances of `Buffer`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URLs – in instances of `URL` (with the protocol `file:`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on this topic, see [the Node.js API documentation](https://nodejs.org/api/fs.html#fs_file_paths).
  prefs: []
  type: TYPE_NORMAL
- en: '[29.13.3.3 Converting between `file:` URLs and paths](#converting-urls-paths)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[The Node.js module `url`](https://nodejs.org/api/url.html) has two functions
    for converting between `file:` URLs and paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fileURLToPath(url: URL|string): string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converts a `file:` URL to a path.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`pathToFileURL(path: string): URL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converts a path to a `file:` URL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we need a path that can be used in the local file system, then property
    `.pathname` of `URL` instances does not always work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, it is better to use `fileURLToPath()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, `pathToFileURL()` does more than just prepend `'file://'` to an absolute
    path.
  prefs: []
  type: TYPE_NORMAL
- en: '[29.14 Loading modules dynamically via `import()` ^(ES2020) (advanced)](#dynamic-imports)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Icon “reading”](../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png) **The `import()`
    operator returns Promises**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Promises are a technique for handling results that are computed asynchronously
    (i.e., not immediately). It may make sense to postpone reading this section until
    you understand them. More information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[“Promises for asynchronous programming ^(ES6)” (§43)](ch_promises.html#ch_promises)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Async functions ^(ES2017)” (§44)](ch_async-functions.html#ch_async-functions)
    (explains the `await` operator for Promises, which we use in this section)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[29.14.1 The limitations of static `import` statements](#the-limitations-of-static-import-statements)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far, the only way to import a module has been via an `import` statement.
    That statement has several limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: We must use it at the top level of a module. That is, we can’t, for example,
    import something when we are inside a function or inside an `if` statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The module specifier is always fixed. That is, we can’t change what we import
    depending on a condition. And we can’t assemble a specifier dynamically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[29.14.2 Dynamic imports via the `import()` operator](#dynamic-imports-via-the-import-operator)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `import()` operator doesn’t have the limitations of `import` statements.
    It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: This operator is used like a function, receives a string with a module specifier
    and returns a Promise that resolves to a namespace object. The properties of that
    object are the exports of the imported module.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `await` can be used at the top levels of modules (see [next section](#top-level-await)).
  prefs: []
  type: TYPE_NORMAL
- en: '[29.14.2.1 Example: loading a module dynamically](#example-loading-a-module-dynamically)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'We have already seen module `my-math.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `import()` to load this module on demand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Two things in this code can’t be done with `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: We are importing inside a function (not at the top level).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The module specifier comes from a variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Icon “question”](../Images/3decb3ca67c240d2bb04742c1f28af18.png) **Why is
    `import()` an operator and not a function?**'
  prefs: []
  type: TYPE_NORMAL
- en: '`import()` looks like a function but couldn’t be implemented as a function:'
  prefs: []
  type: TYPE_NORMAL
- en: It needs to know the URL of the current module in order to resolve relative
    module specifiers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `import()` were a function, we’d have to explicitly pass this information
    to it (e.g. via an parameter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In contrast, an operator is a core language construct and has implicit access
    to more data, including the URL of the current module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[29.14.3 Use cases for `import()`](#use-cases-for-import)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[29.14.3.1 Loading code on demand](#loading-code-on-demand)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Some functionality of web apps doesn’t have to be present when they start,
    it can be loaded on demand. Then `import()` helps because we can put such functionality
    into modules – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[29.14.3.2 Conditional loading of modules](#conditional-loading-of-modules)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We may want to load a module depending on whether a condition is true. For
    example, a module with [a polyfill](#polyfills) that makes a new feature available
    on legacy platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[29.14.3.3 Computed module specifiers](#computed-module-specifiers)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For applications such as internationalization, it helps if we can dynamically
    compute module specifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[29.15 Top-level `await` in modules ^(ES2022) (advanced)](#top-level-await)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Icon “reading”](../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png) **`await`
    is a feature of async functions**'
  prefs: []
  type: TYPE_NORMAL
- en: '`await` is explained in [“Async functions ^(ES2017)” (§44)](ch_async-functions.html#ch_async-functions).
    It may make sense to postpone reading this section until you understand async
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `await` operator at the top level of a module. If we do that,
    the module becomes asynchronous and works differently. Thankfully, we don’t usually
    see that as programmers because it is handled transparently by the language.
  prefs: []
  type: TYPE_NORMAL
- en: '[29.15.1 Use cases for top-level `await`](#use-cases-for-toplevel-await)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Why would we want to use the `await` operator at the top level of a module?
    It lets us initialize a module with asynchronously loaded data. The next three
    subsections show three examples of where that is useful.
  prefs: []
  type: TYPE_NORMAL
- en: '[29.15.1.1 Loading modules dynamically](#loading-modules-dynamically)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: In line A, we [dynamically import](#dynamic-imports) a module. Thanks to top-level
    `await`, that is almost as convenient as using a normal, static import.
  prefs: []
  type: TYPE_NORMAL
- en: '[29.15.1.2 Using a fallback if module loading fails](#using-a-fallback-if-module-loading-fails)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[29.15.1.3 Using whichever resource loads fastest](#using-whichever-resource-loads-fastest)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Due to [`Promise.any()`](ch_promises.html#Promise.any), variable `resource`
    is initialized via whichever download finishes first.
  prefs: []
  type: TYPE_NORMAL
- en: '[29.15.2 How does top-level `await` work under the hood?](#how-does-toplevel-await-work-under-the-hood)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider the following two files.
  prefs: []
  type: TYPE_NORMAL
- en: '`first.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '`main.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Both are roughly equivalent to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`first.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '`main.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'A module becomes asynchronous if:'
  prefs: []
  type: TYPE_NORMAL
- en: It directly uses top-level `await` (`first.mjs`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It imports one or more asynchronous modules (`main.mjs`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each asynchronous module exports a Promise (line A and line B) that is fulfilled
    after its body was executed. At that point, it is safe to access the exports of
    that module.
  prefs: []
  type: TYPE_NORMAL
- en: In case (2), the importing module waits until the Promises of all imported asynchronous
    modules are fulfilled, before it enters its body (line C). Synchronous modules
    are handled as usually.
  prefs: []
  type: TYPE_NORMAL
- en: Awaited rejections and synchronous exceptions are managed as in async functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[29.15.3 The pros and cons of top-level `await`](#the-pros-and-cons-of-toplevel-await)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What are the pros and cons of top-level `await`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is convenient to have this operator available at the top level of a module,
    especially for dynamically imported modules.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It obviates the need for complicated techniques to ensure that importers don’t
    access data before it is ready.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tt supports asynchronicity transparently: Importers do not need to know if
    an imported module is asynchronous or not.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Top-level `await` delays the initialization of importing modules. Therefore,
    it’s best used sparingly. Asynchronous tasks that take longer are better performed
    later, on demand. However, even modules without top-level `await` can block importers
    (e.g. via an infinite loop at the top level), so blocking per se is not an argument
    against it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On Node.js, ESM modules that use top-level `await` cannot be required from CommonJS.
    That matters if you write an ESM-based package and want it to be usable from CommonJS
    code bases. For more information, see section [“Loading ECMAScript modules using
    `require()`”](https://nodejs.org/api/modules.html#loading-ecmascript-modules-using-require)
    in the Node.js documentation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[29.16 Import attributes: importing non-JavaScript artifacts ^(ES2025)](#import-attributes)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[29.16.1 The history of importing non-JavaScript artifacts](#the-history-of-importing-nonjavascript-artifacts)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Importing artifacts that are not JavaScript code as modules, has a long tradition
    in the JavaScript ecosystem. For example, the JavaScript module loader RequireJS
    has support for so-called [*plugins*](https://requirejs.org/docs/plugins.html).
    To give you a feeling for how old RequireJS is: Version 1.0.0 was released in
    2009\. Specifiers of modules that are imported via a plugin look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, the following module specifier imports a file as JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Inspired by RequireJS, webpack supports the same module specifier syntax for
    its [*loaders*](https://webpack.js.org/loaders/).
  prefs: []
  type: TYPE_NORMAL
- en: '[29.16.2 Use cases for importing non-JavaScript artifacts](#use-cases-for-importing-nonjavascript-artifacts)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These are a few use cases for importing non-JavaScript artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing JSON configuration data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing WebAssembly code as if it were a JavaScript module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing CSS to build user interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more use cases, you can take a look at [the list of webpack’s loaders](https://webpack.js.org/loaders/).
  prefs: []
  type: TYPE_NORMAL
- en: '[29.16.3 Import attributes](#import-attributes-1)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The motivating use case for import attributes was importing JSON data as a
    module. That looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '`type` is an import attribute (more on the syntax soon).'
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder why a JavaScript engine can’t use the filename extension `.json`
    to determine that this is JSON data. However, a core architectural principle of
    the web is to never use the filename extension to determine what’s inside a file.
    Instead, content types are used.
  prefs: []
  type: TYPE_NORMAL
- en: If a server is set up correctly then why not do a normal import and omit the
    import attributes?
  prefs: []
  type: TYPE_NORMAL
- en: The server may be deliberately misconfigured – e.g., an external server not
    controlled by the people who wrote the code. It could swap an imported JSON file
    with code that would be executed by the importer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server may be accidentally misconfigured. With import attributes, we get
    feedback more quickly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given that the expected content type is not explicit in the code, the attributes
    also document the expectations of the programmer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[29.16.4 The syntax of import attributes](#the-syntax-of-import-attributes)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s examine in more detail what import attributes look like.
  prefs: []
  type: TYPE_NORMAL
- en: '[29.16.4.1 Static import statements](#static-import-statements)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We have already seen a normal (static) import statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The import attributes start with the keyword `with`. That keyword is followed
    by an object literal. For now, the following object literal features are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: Unquoted keys and quoted keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values must be strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are no other syntactic restrictions placed on the keys and the values,
    but engines should throw an exception if they don’t support a key and/or a value:'
  prefs: []
  type: TYPE_NORMAL
- en: Attributes change what is imported, so simply ignoring them is risky because
    that changes the runtime behavior of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A side benefit is that this makes it easier to add more features in the future
    because no one will use keys and values in unexpected ways.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[29.16.4.2 Dynamic imports](#dynamic-imports-1)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To support import attributes, [dynamic imports](import-operator) get a second
    parameter – an object with configuration data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The import attributes don’t exist at the top level; they are specified via the
    property `with`. That makes it possible to add more configuration options in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: '[29.16.4.3 Re-export statements](#reexport-statements)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A re-export imports and exports in a single step. For the former, we need attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[29.16.5 JSON modules ^(ES2025)](#json-modules)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Import attributes are really just syntax. They lay the foundation for actual
    features that make use of that syntax. The first ECMAScript feature based on import
    attributes is JSON modules – which we’ve already seen in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a file `config-data.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'It sits next to the following ECMAScript module `main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Importing JSON**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/modules/get-version_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[29.17 Polyfills: emulating native web platform features (advanced)](#polyfills)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **Backends
    have polyfills, too**'
  prefs: []
  type: TYPE_NORMAL
- en: This section is about frontend development and web browsers, but similar ideas
    apply to backend development.
  prefs: []
  type: TYPE_NORMAL
- en: '*Polyfills* help with a conflict that we are facing when developing a web application
    in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: On one hand, we want to use modern web platform features that make the app better
    and/or development easier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, the app should run on as many browsers as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Given a web platform feature X:'
  prefs: []
  type: TYPE_NORMAL
- en: A *polyfill* for X is a piece of code. If it is executed on a platform that
    already has built-in support for X, it does nothing. Otherwise, it makes the feature
    available on the platform. In the latter case, the polyfilled feature is (mostly)
    indistinguishable from a native implementation. In order to achieve that, the
    polyfill usually makes global changes. For example, it may modify global data
    or configure a global module loader. Polyfills are often packaged as modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The term [*polyfill*](https://remysharp.com/2010/10/08/what-is-a-polyfill) was
    coined by Remy Sharp.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A *speculative polyfill* is a polyfill for a proposed web platform feature (that
    is not standardized, yet).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alternative term: *prollyfill*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A *replica* of X is a library that reproduces the API and functionality of X
    locally. Such a library exists independently of a native (and global) implementation
    of X.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Replica* is a new term introduced in this section. Alternative term: *ponyfill*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also the term *shim*, but it doesn’t have a universally agreed upon
    definition. It often means roughly the same as *polyfill*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time our web applications starts, it must first execute all polyfills
    for features that may not be available everywhere. Afterwards, we can be sure
    that those features are available natively.
  prefs: []
  type: TYPE_NORMAL
- en: '[29.17.1 Sources of this section](#sources-of-this-section)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[“What is a Polyfill?”](https://remysharp.com/2010/10/08/what-is-a-polyfill)
    by Remy Sharp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inspiration for the term *replica*: [The Eiffel Tower in Las Vegas](https://en.wikipedia.org/wiki/Paris_Las_Vegas)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Useful clarification of “polyfill” and related terms: [“Polyfills and the evolution
    of the Web”](https://www.w3.org/2001/tag/doc/polyfills/). Edited by Andrew Betts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
