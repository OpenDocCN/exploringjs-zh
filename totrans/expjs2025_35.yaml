- en: 29 Modules ES6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_modules.html](https://exploringjs.com/js/book/ch_modules.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[29.1 Cheat sheet: modules](#cheat-sheet-modules)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.1.1 Named exports, named imports, namespace imports](#named-exports-named-imports-namespace-imports)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.1.2 Dynamic imports via `import()` ^(ES2020)](#dynamic-imports-via-import-es2020)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.1.3 Default exports and imports](#default-exports-and-imports)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.1.4 Kinds of module specifiers](#kinds-of-module-specifiers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.2 JavaScript’s source code units: scripts and modules](#source-code-units)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.2.1 Code before built-in modules was written in ECMAScript 5](#code-before-builtin-modules-was-written-in-ecmascript-5)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.3 Before we had modules, we had scripts](#scripts)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.4 Module systems created prior to ES6](#module-systems-created-prior-to-es6)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.4.1 Server side: CommonJS modules](#server-side-commonjs-modules)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.4.2 Client side: AMD (Asynchronous Module Definition) modules](#client-side-amd-asynchronous-module-definition-modules)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.4.3 Characteristics of JavaScript modules](#characteristics-of-javascript-modules)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.5 ECMAScript modules](#ecmascript-modules)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.5.1 ES modules: syntax, semantics, loader API](#es-modules-syntax-semantics-loader-api)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.6 Named exports and imports](#named-exports-and-imports)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.6.1 Named exports](#named-exports)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.6.2 Named imports](#named-imports)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.6.3 Namespace imports](#namespace-imports)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.6.4 Named exporting styles: inline versus clause (advanced)](#named-exporting-styles-inline-versus-clause-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.7 Default exports and default imports](#default-exports-and-default-imports)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.7.1 The two styles of default-exporting](#the-two-styles-of-defaultexporting)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.7.2 The default export as a named export (advanced)](#the-default-export-as-a-named-export-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.7.3 Recommendations: named exports vs. default exports](#recommendations-named-exports-vs-default-exports)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.8 Re-exporting](#re-exporting)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.9 More details on exporting and importing](#more-details-on-exporting-and-importing)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.9.1 Imports are read-only views on exports](#imports-are-readonly-views-on-exports)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.9.2 ESM’s transparent support for cyclic imports (advanced)](#esms-transparent-support-for-cyclic-imports-advanced)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.10 Packages: JavaScript’s units for software distribution](#javascript-packages)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.10.1 Publishing packages: package registries, package managers, package
    names](#publishing-packages)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.10.2 The file system layout of a package](#package-file-system-layout)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.10.3 `package.json`](#packagejson)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.10.4 Package exports: controlling what other packages see](#package-exports)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.10.5 Package imports](#package-imports)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.11 Naming modules](#naming-modules)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.12 Module specifiers](#module-specifiers)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.12.1 Kinds of module specifiers](#kinds-of-module-specifiers-1)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.12.2 Filename extensions in module specifiers](#filename-extensions-in-module-specifiers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.12.3 Module specifiers in Node.js](#module-specifiers-in-nodejs)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.12.4 Module specifiers in browsers](#module-specifiers-in-browsers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.13 `import.meta` – metadata for the current module ^(ES2020)](#import.meta)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.13.1 `import.meta.url`](#import.meta.url)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.13.2 `import.meta.url` and class `URL`](#importmetaurl-and-class-url)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.13.3 `import.meta.url` on Node.js](#importmetaurl-on-nodejs)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.14 Loading modules dynamically via `import()` ^(ES2020) (advanced)](#dynamic-imports)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.14.1 The limitations of static `import` statements](#the-limitations-of-static-import-statements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.14.2 Dynamic imports via the `import()` operator](#dynamic-imports-via-the-import-operator)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.14.3 Use cases for `import()`](#use-cases-for-import)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.15 Top-level `await` in modules ^(ES2022) (advanced)](#top-level-await)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.15.1 Use cases for top-level `await`](#use-cases-for-toplevel-await)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.15.2 How does top-level `await` work under the hood?](#how-does-toplevel-await-work-under-the-hood)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.15.3 The pros and cons of top-level `await`](#the-pros-and-cons-of-toplevel-await)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.16 Import attributes: importing non-JavaScript artifacts ^(ES2025)](#import-attributes)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.16.1 The history of importing non-JavaScript artifacts](#the-history-of-importing-nonjavascript-artifacts)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.16.2 Use cases for importing non-JavaScript artifacts](#use-cases-for-importing-nonjavascript-artifacts)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.16.3 Import attributes](#import-attributes-1)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.16.4 The syntax of import attributes](#the-syntax-of-import-attributes)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.16.5 JSON modules ^(ES2025)](#json-modules)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.17 Polyfills: emulating native web platform features (advanced)](#polyfills)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.17.1 Sources of this section](#sources-of-this-section)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[29.1 Cheat sheet: modules](#cheat-sheet-modules)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[29.1.1 Named exports, named imports, namespace imports](#named-exports-named-imports-namespace-imports)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we put `export` in front of a named entity inside a module, it becomes a
    *named export* of that module. All other entities are private to the module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2][PRE3][PRE4][PRE5]``js[PRE6]js[PRE7][PRE8][PRE9]`` [PRE10][PRE11][PRE12]``
    `myModule` is a global variable that is assigned the result of immediately invoking
    a function expression. The function expression starts in the first line. It is
    invoked in the last line.    This way of wrapping a code fragment is called *immediately
    invoked function expression* (IIFE, coined by Ben Alman). What do we gain from
    an IIFE? `var` is not block-scoped (like `const` and `let`), it is function-scoped:
    the only way to create new scopes for `var`-declared variables is via functions
    or methods (with `const` and `let`, we can use either functions, methods, or blocks
    `{}`). Therefore, the IIFE in the example hides all of the following variables
    from global scope and minimizes name clashes: `importedFunc1`, `importedFunc2`,
    `internalFunc`, `exportedFunc`.    Note that we are using an IIFE in a particular
    manner: at the end, we pick what we want to export and return it via an object
    literal. That is called the *revealing module pattern* (coined by Christian Heilmann).    This
    way of simulating modules, has several issues:    *   Libraries in script files
    export and import functionality via global variables, which risks name clashes.
    *   Dependencies are not stated explicitly, and there is no built-in way for a
    script to load the scripts it depends on. Therefore, the web page has to load
    not just the scripts that are needed by the page but also the dependencies of
    those scripts, the dependencies’ dependencies, etc. And it has to do so in the
    right order!    ### [29.4 Module systems created prior to ES6](#module-systems-created-prior-to-es6)    Prior
    to ECMAScript 6, JavaScript did not have built-in modules. Therefore, the flexible
    syntax of the language was used to implement custom module systems *within* the
    language. Two popular ones are:    *   CommonJS (targeting the server side) *   AMD
    (Asynchronous Module Definition, targeting the client side)    #### [29.4.1 Server
    side: CommonJS modules](#server-side-commonjs-modules)    The original CommonJS
    standard for modules was created for server and desktop platforms. It was the
    foundation of the original Node.js module system, where it achieved enormous popularity.
    Contributing to that popularity were the npm package manager for Node and tools
    that enabled using Node modules on the client side (browserify, webpack, and others).    From
    now on, *CommonJS module* means the Node.js version of this standard (which has
    a few additional features). This is an example of a CommonJS module:    [PRE13]   [PRE14][PRE15][PRE16]`
    [PRE17][PRE18][PRE19] CommonJS can be characterized as follows:    *   Designed
    for servers. *   Modules are meant to be loaded *synchronously* (the importer
    waits while the imported module is loaded and executed). *   Compact syntax.    ####
    [29.4.2 Client side: AMD (Asynchronous Module Definition) modules](#client-side-amd-asynchronous-module-definition-modules)    The
    AMD module format was created to be easier to use in browsers than the CommonJS
    format. Its most popular implementation is [RequireJS](https://requirejs.org).
    The following is an example of an AMD module.    [PRE20]js   [PRE21]`js[PRE22]`js[PRE23]js[PRE24][PRE25][PRE26]js
    function times(a, b) {  return a * b; } function square(x) {  return times(x,
    x); } const LIGHT_SPEED = 299792458;  `export { square, LIGHT_SPEED }; // semicolon!`  [PRE27]js[PRE28]js[PRE29][PRE30]
    For importing, we can use a normal default import:    [PRE31]js    Or we can use
    a named import:    [PRE32]js    The default export is also available via property
    `.default` of namespace imports:    [PRE33]js    ![Icon “question”](../Images/3decb3ca67c240d2bb04742c1f28af18.png) **Isn’t
    `default` illegal as a variable name?**    `default` can’t be a variable name,
    but it can be an export name and it can be a property name:    [PRE34]js    ####
    [29.7.3 Recommendations: named exports vs. default exports](#recommendations-named-exports-vs-default-exports)    These
    are my recommendations:    *   Avoid mixing named exports and default exports:
    A module can have both named exports and a default export, but it’s usually better
    to stick to one export style per module.               *   There is one exception:
    For unit-testing, it can make sense to name-export internal functions (etc.) that
    complement the default export (the public API of the module). *   In some cases,
    you may be sure that the module will only ever export a single value (usually
    a function or a class). That is, conceptually, the module *is* the value – similarly
    to a variable. Then a default export is a good option.           *   You can never
    go wrong with only using named exports.              ### [29.8 Re-exporting](#re-exporting)    A
    module `library.mjs` can export one or more exports of another module `internal.mjs`
    as if it had made them itself. That is called *re-exporting*.    [PRE35]js    [PRE36]js    *   The
    wildcard re-export turns all exports of module `internal.mjs` into exports of
    `library.mjs`, except the default export. *   The namespace re-export turns all
    exports of module `internal.mjs` into an object that becomes the named export
    `ns` of `library.mjs`. Because `internal.mjs` has a default export, `ns` has a
    property `.default`.    The following code demonstrates the two bullet points
    above:    [PRE37]js   [PRE38] ### [29.9 More details on exporting and importing](#more-details-on-exporting-and-importing)    ####
    [29.9.1 Imports are read-only views on exports](#imports-are-readonly-views-on-exports)    So
    far, we have used imports and exports intuitively, and everything seems to have
    worked as expected. But now it is time to take a closer look at how imports and
    exports are really related.    Consider the following two modules:    [PRE39]    `counter.mjs`
    exports a (mutable!) variable and a function:    [PRE40]    `main.mjs` name-imports
    both exports. When we use `incCounter()`, we discover that the connection to `counter`
    is live – we can always access the live state of that variable:    [PRE41]   [PRE42][PRE43]``js[PRE44]``
    ##### [29.10.4.2 Examples: conditional package exports](#conditional-package-exports)    The
    examples in this subsection show excerpts of `package.json`.    Example – export
    different modules for Node.js, browsers and other platforms:    [PRE45]    Example
    – development vs. production:    [PRE46]    In Node.js we can specify an environment
    like this:    [PRE47]    #### [29.10.5 Package imports](#package-imports)    [Package
    imports](https://nodejs.org/api/packages.html#imports) let a package define abbreviations
    for module specifiers that it can use itself, internally (where package exports
    define abbreviations for other packages). This is an example:    `package.json`:    [PRE48]    Each
    of the keys of `"imports"` has to start with a hash sign (`#`). The key `"#some-pkg"`
    is *conditional* (with the same features as [conditional package exports](#conditional-package-exports)):    *   If
    the current package is used on Node.js, the module specifier `''#some-pkg''` refers
    to package `some-pkg-node-native`.           *   Elsewhere, `''#some-pkg''` refers
    to the file `./polyfills/some-pkg-polyfill.js` inside the current package.              Note
    that only package imports can refer to external packages, package exports can’t
    do that.    What are the use cases for package imports?    *   Referring to different
    platform-specific implementations modules via the same module specifier (as demonstrated
    above). *   Aliases to modules inside the current package – to avoid relative
    specifiers (which can get complicated with deeply nested directories).    #####
    [29.10.5.1 Examples: accessing `package.json` via package imports](#examples-accessing-packagejson-via-package-imports)    Let’s
    explore two ways of accessing `package.json` via package imports.    First, we
    can define a package import for the root level of the package:    [PRE49]    Then
    the import statement looks like this:    [PRE50]    Second, we can define a package
    import just for `package.json`:    [PRE51]    Then the import statement looks
    like this:    [PRE52]    ### [29.11 Naming modules](#naming-modules)    There
    are no established best practices for naming module files and the variables they
    are imported into.    In this chapter, I’m using the following naming style:    *   The
    names of module files are dash-cased and only have lowercase letters:                    [PRE53]           *   The
    names of namespace imports are camel-cased and start with lowercase letters:                    [PRE54]           *   The
    names of default imports are camel-cased and start with lowercase letters:                    [PRE55]              What
    is the thinking behind this style? We want module file names to be similar to
    package names:    *   Dashes are far more commonly used than underscores in package
    names. Maybe that is influenced by underscores being very rare in domain names.           *   npm
    doesn’t allow uppercase letters in package names ([source](https://docs.npmjs.com/cli/v11/configuring-npm/package-json#name)).              Thanks
    to CSS, there are clear rules for translating dash-cased names to camel-cased
    names. We can use these rules for namespace imports and default imports.    ###
    [29.12 Module specifiers](#module-specifiers)    *Module specifiers* are the strings
    that identify modules. They work slightly differently in browsers and Node.js.
    Before we can look at the differences, we need to learn about the different categories
    of module specifiers.    #### [29.12.1 Kinds of module specifiers](#kinds-of-module-specifiers-1)    There
    are three kinds of module specifiers:    *   *Absolute specifiers* are full URLs
    – for example:                    [PRE56]                    Absolute specifiers
    are mostly used to access libraries that are directly hosted on the web.           *   *Relative
    specifiers* are relative URLs (starting with `''/''`, `''./''` or `''../''`) –
    for example:                    [PRE57]                    Every module has a
    URL whose protocol depends on its location (`file:`, `https:`, etc.). If it uses
    a relative specifier, JavaScript turns that specifier into a full URL by resolving
    it against the module’s URL.                    Relative specifiers are mostly
    used to access other modules within the same code base.           *   *Bare specifiers*
    are paths (without protocol and domain) that start with neither slashes nor dots.
    They begin with the names of packages. Those names can optionally be followed
    by *subpaths*:                    [PRE58]                    Bare specifiers can
    also refer to packages with scoped names:                    [PRE59]                    Each
    bare specifier refers to exactly one module inside a package; if it has no subpath,
    it refers to the designated “main” module of its package.                    A
    bare specifier is never used directly but always *resolved* – translated to an
    absolute specifier. How resolution works depends on the platform. We’ll learn
    more soon.              #### [29.12.2 Filename extensions in module specifiers](#filename-extensions-in-module-specifiers)    *   Absolute
    specifiers and relative specifiers always have filename extensions – mainly `.js`
    or `.mjs`. *   There are three styles of bare specifiers:     *   Style 1: no
    subpath                                    [PRE60]                       *   Style
    2: a subpath without a filename extension. In this case, the subpath works like
    a modifier for the package name:                                    [PRE61]                       [PRE62]     ''large-package/misc/util.js''     ''large-package/main/parsing.js''     ''large-package/main/printing.js''          [PRE63]`     [PRE64]``
    Caveat of style 3 bare specifiers: How the filename extension is interpreted depends
    on the dependency and may differ from the importing package. For example, the
    importing package may use `.mjs` for ESM modules and `.js` for CommonJS modules,
    while the ESM modules exported by the dependency may have bare paths with the
    filename extension `.js`.    #### [29.12.3 Module specifiers in Node.js](#module-specifiers-in-nodejs)    Let’s
    see how module specifiers work in Node.js. Especially bare specifiers are handled
    differently than in browsers.    ##### [29.12.3.1 Resolving module specifiers
    in Node.js](#resolving-module-specifiers-in-nodejs)    The [*Node.js resolution
    algorithm*](https://nodejs.org/api/esm.html#resolution-algorithm) works as follows:    *   Parameters:     *   URL
    of importing module     *   Module specifier *   Result: Resolved URL for module
    specifier    This is the algorithm:    *   If a specifier is absolute, resolution
    is already finished. Three protocols are most common:               *   `file:`
    for local files     *   `https:` for remote files     *   `node:` for built-in
    modules *   If a specifier is relative, it is resolved against the URL of the
    importing module.           *   If a specifier is bare:               *   If it
    starts with `''#''`, it is resolved by looking it up among the *package imports*
    (which are explained [later](#package-imports)) and resolving the result.                       *   Otherwise,
    it is a bare specifier that has one of these formats (the subpath is optional):                           *   `«package»/sub/path`         *   `@«scope»/«scoped-package»/sub/path`                  The
    resolution algorithm traverses the current directory and its ancestors until it
    finds a directory `node_modules` that has a subdirectory matching the beginning
    of the bare specifier, i.e. either:                           *   `node_modules/«package»/`         *   `node_modules/@«scope»/«scoped-package»/`                  That
    directory is the directory of the package. By default, the (potentially empty)
    subpath after the package ID is interpreted as relative to the package directory.
    The default can be overridden via *package exports* which are explained next.                      The
    result of the resolution algorithm must point to a file. That explains why absolute
    specifiers and relative specifiers always have filename extensions. Bare specifiers
    often don’t because they are abbreviations that are looked up in package exports.    Module
    files usually have these filename extensions:    *   If a file has the name extension
    `.mjs`, it is always an ES module. *   A file that has the name extension `.js`
    is an ES module if the closest `package.json` has this entry:     *   `"type":
    "module"`    If Node.js executes code provided via stdin, `--eval` or `--print`,
    we use [the following command-line option](https://nodejs.org/api/cli.html#--input-typetype)
    so that it is interpreted as an ES module:    [PRE65]    #### [29.12.4 Module
    specifiers in browsers](#module-specifiers-in-browsers)    In browsers, we can
    write inline modules like this:    [PRE66]    `type="module"` tells the browser
    that this is an ESM module and not [a browser script](#scripts).    We can only
    use two kinds of module specifiers:    [PRE67]   [PRE68]` Read on to find out
    how to work around this limitation and use npm packages.    ##### [29.12.4.1 Filename
    extensions in browsers](#filename-extensions-in-browsers)    Browsers don’t care
    about filename extensions, only about content types.    Hence, we can use any
    filename extension for ECMAScript modules, as long as they are served with [a
    JavaScript content type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#textjavascript)
    (`text/javascript` is recommended).    ##### [29.12.4.2 Using npm packages in
    browsers](#using-npm-packages-in-browsers)    On Node.js, npm packages are downloaded
    into the `node_modules` directory and accessed via bare module specifiers. Node.js
    traverses the file system in order to find packages. We can’t do that in web browsers.
    Three approaches are common for bringing npm packages to browsers.    ###### [29.12.4.2.1 Approach
    1: Using a content delivery network](#approach-1-using-a-content-delivery-network)    Content
    delivery networks (CDNs) such as [`unpkg.com`](https://unpkg.com) and [`esm.sh`](https://esm.sh)
    let us import npm packages via URLs. This is what the `unpkg.com` URLs look like:    [PRE69]    For
    example:    [PRE70]    One downside of CDNs is that they introduce an additional
    point of failure:    *   CDNs can go offline. *   There is a risk of CDNs serving
    malicious code – e.g. if they are hacked or taken over by a new maintainer.    ######
    [29.12.4.2.2 Approach 2: Using `node_modules` with bare specifiers and a bundler](#approach-2-using-nodemodules-with-bare-specifiers-and-a-bundler)    A
    [bundler](ch_next-steps.html#bundler) is a build tool. It works roughly as follows:    *   Given
    a directory with a web app. We point the bundler to the app’s *entry point* –
    the module where execution starts. *   It collects everything that module imports
    (its imports, the imports of the imports, etc.). *   It produces a *bundle*, a
    single file with all the code. That file can be used from an HTML page.    If
    an app has multiple entry points, the bundler produces multiple bundles. It’s
    also possible to tell it to create bundles for parts of the application that are
    loaded on demand.    When bundling, we can use bare import specifiers in files
    because bundlers know how to find the corresponding modules in `node_modules`.
    Bundlers also honor package exports and package imports.    Why bundle?    *   Loading
    a single file tends to be faster than loading multiple files – especially if there
    are many small ones. *   Bundlers only include code in the file that is really
    used (which is especially relevant for libraries). That saves storage space and
    also speeds up loading.    A downside of bundling is that we need to bundle the
    whole app every time we want to run it.    ###### [29.12.4.2.3 Approach 3: Converting
    npm packages to browser-compatible files](#approach-3-converting-npm-packages-to-browsercompatible-files)    There
    are package managers for browsers that let us download modules as single bundled
    files that can be used in browsers. As an example, consider the following directory
    of a web app:    [PRE71]    We used a bundler to install package `lodash-es` into
    a single file. Module `main.js` can import it like this:    [PRE72]    To deploy
    this app, the contents of `assets/` and `src/` are copied to the production server
    (in addition to non-JavaScript artifacts).    What are the benefits of this approach
    compared to using a bundler?    *   We install the external dependencies once
    and then can always run our app immediately – no prior bundling is required (which
    can be time-consuming). *   Unbundled code is easier to debug.    ###### [29.12.4.2.4 Improving
    approach 3: import maps](#import-maps)    Approach 3 can be further improved:
    [*Import maps*](https://2ality.com/2022/01/esm-specifiers.html#import-maps) are
    a browser technology that lets us define abbreviations for module specifiers –
    e.g. `''lodash-es''` for `''../assets/lodash-es.js''`.    This is what an import
    map looks like if we store it *inline* – inside an HTML file:    [PRE73]    We
    can also store import maps in external files (the content type must be `application/importmap+json`):    [PRE74]    Now
    the import in `main.js` looks like this:    [PRE75]    ### [29.13 `import.meta`
    – metadata for the current module ^(ES2020)](#import.meta)    The object `import.meta`
    holds metadata for the current module.    #### [29.13.1 `import.meta.url`](#import.meta.url)    The
    most important property of `import.meta` is `.url` which contains a string with
    the URL of the current module’s file – for example:    [PRE76]    #### [29.13.2 `import.meta.url`
    and class `URL`](#importmetaurl-and-class-url)    Class `URL` is available via
    a global variable in browsers and on Node.js. We can look up its full functionality
    in [the Node.js documentation](https://nodejs.org/api/url.html#url_class_url).
    When working with `import.meta.url`, its constructor is especially useful:    [PRE77]    Parameter
    `input` contains the URL to be parsed. It can be relative if the second parameter,
    `base`, is provided.    In other words, this constructor lets us resolve a relative
    path against a base URL:    [PRE78]    This is how we get a `URL` instance that
    points to a file `data.txt` that sits next to the current module:    [PRE79]    ####
    [29.13.3 `import.meta.url` on Node.js](#importmetaurl-on-nodejs)    On Node.js,
    `import.meta.url` is always a string with a `file:` URL – for example:    [PRE80]    #####
    [29.13.3.1 Example: reading a sibling file of a module](#example-reading-a-sibling-file-of-a-module)    Many
    Node.js file system operations accept either strings with paths or instances of
    `URL`. That enables us to read a sibling file `data.txt` of the current module:    [PRE81]    #####
    [29.13.3.2 Module `fs` and URLs](#module-fs-and-urls)    For most functions of
    the module `fs`, we can refer to files via:    *   Paths – in strings or instances
    of `Buffer`. *   URLs – in instances of `URL` (with the protocol `file:`)    For
    more information on this topic, see [the Node.js API documentation](https://nodejs.org/api/fs.html#fs_file_paths).    #####
    [29.13.3.3 Converting between `file:` URLs and paths](#converting-urls-paths)    [The
    Node.js module `url`](https://nodejs.org/api/url.html) has two functions for converting
    between `file:` URLs and paths:    *   `fileURLToPath(url: URL|string): string`     Converts
    a `file:` URL to a path. *   `pathToFileURL(path: string): URL`     Converts a
    path to a `file:` URL.    If we need a path that can be used in the local file
    system, then property `.pathname` of `URL` instances does not always work:    [PRE82]    Therefore,
    it is better to use `fileURLToPath()`:    [PRE83]    Similarly, `pathToFileURL()`
    does more than just prepend `''file://''` to an absolute path.    ### [29.14 Loading
    modules dynamically via `import()` ^(ES2020) (advanced)](#dynamic-imports)    ![Icon
    “reading”](../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png) **The `import()` operator
    returns Promises**    Promises are a technique for handling results that are computed
    asynchronously (i.e., not immediately). It may make sense to postpone reading
    this section until you understand them. More information:    *   [“Promises for
    asynchronous programming ^(ES6)” (§43)](ch_promises.html#ch_promises) *   [“Async
    functions ^(ES2017)” (§44)](ch_async-functions.html#ch_async-functions) (explains
    the `await` operator for Promises, which we use in this section)    #### [29.14.1 The
    limitations of static `import` statements](#the-limitations-of-static-import-statements)    So
    far, the only way to import a module has been via an `import` statement. That
    statement has several limitations:    *   We must use it at the top level of a
    module. That is, we can’t, for example, import something when we are inside a
    function or inside an `if` statement. *   The module specifier is always fixed.
    That is, we can’t change what we import depending on a condition. And we can’t
    assemble a specifier dynamically.    #### [29.14.2 Dynamic imports via the `import()`
    operator](#dynamic-imports-via-the-import-operator)    The `import()` operator
    doesn’t have the limitations of `import` statements. It looks like this:    [PRE84]    This
    operator is used like a function, receives a string with a module specifier and
    returns a Promise that resolves to a namespace object. The properties of that
    object are the exports of the imported module.    Note that `await` can be used
    at the top levels of modules (see [next section](#top-level-await)).    #####
    [29.14.2.1 Example: loading a module dynamically](#example-loading-a-module-dynamically)    Consider
    the following files:    [PRE85]    We have already seen module `my-math.mjs`:    [PRE86]    We
    can use `import()` to load this module on demand:    [PRE87]   [PRE88] [PRE89]`js
    [PRE90]js`` [PRE91]js[PRE92][PRE93][PRE94][PRE95]js[PRE96]js` [PRE97]`js`` [PRE98]`js[PRE99][PRE100][PRE101]
    [PRE102][PRE103][PRE104][PRE105][PRE106]`` [PRE107][PRE108][PRE109] [PRE110]`js[PRE111]js[PRE112]js[PRE113]js[PRE114]js[PRE115]`'
  prefs: []
  type: TYPE_NORMAL
