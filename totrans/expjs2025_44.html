<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>37 WeakMaps (WeakMap) ES6 (advanced)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>37 WeakMaps (WeakMap) ES6 (advanced)</h1>
<blockquote>原文：<a href="https://exploringjs.com/js/book/ch_weakmaps.html">https://exploringjs.com/js/book/ch_weakmaps.html</a></blockquote>

        
    
    
    
<p><span id="index-entry-WeakMap"/><span id="index-entry-WeakMap2"/></p>
<nav class="local-toc">
  <ol>
    <li>
      <a href="#maps-vs-weakmaps">37.1 How are WeakMaps different from Maps?</a>
    </li>
    <li>
      <a href="#weakmaps-as-black-boxes">37.2 WeakMaps are black boxes</a>
    </li>
    <li>
      <a href="#weakmap-keys-are-weakly-held">37.3 The keys of a WeakMap are <em>weakly held</em></a>
      <ol>
        <li>
          <a href="#weakmap-keys-criteria">37.3.1 What values can be keys in WeakMaps?</a>
        </li>
        <li>
          <a href="#why-are-symbols-as-weakmap-keys-interesting-es2023">37.3.2 Why are symbols as WeakMap keys interesting?<span> <sup>ES2023</sup></span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#attaching-values-to-objects-via-weakmaps">37.4 Use case for WeakMaps: attaching values to objects</a>
      <ol>
        <li>
          <a href="#example-caching-computed-results">37.4.1 Example: caching computed results</a>
        </li>
        <li>
          <a href="#private-data-in-weakmaps">37.4.2 Example: keeping data of objects private</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#quickref-weakmaps">37.5 Quick reference: <code>WeakMap</code></a>
    </li>
  </ol>
</nav>
<h3 id="maps-vs-weakmaps"><a class="heading-id-link" href="#maps-vs-weakmaps">37.1 How are WeakMaps different from Maps?</a></h3>
<p>WeakMaps are similar to Maps, with the following differences:</p>
<ul>
  <li>
    They are black boxes, where a value can only be accessed if we have both the WeakMap and the key.
  </li>
  <li>
    The keys of a WeakMap are <em>weakly held</em>: If a value is a key in a WeakMap, it can still be garbage-collected. That enables two important use cases:
    <ul>
      <li>
        We can attach data to value that we don’t own – e.g., to cache computed results.
      </li>
      <li>
        We can keep part of a value private, by not making the WeakMap public that contains that part.
      </li>
    </ul>
  </li>
</ul>
<p><span refcheck="#weakmaps-as-black-boxes #weakmap-keys-are-weakly-held">The next two sections</span> examine in more detail what that means.</p>
<h3 id="weakmaps-as-black-boxes"><a class="heading-id-link" href="#weakmaps-as-black-boxes">37.2 WeakMaps are black boxes</a></h3>
<p>It is impossible to inspect what’s inside a WeakMap:</p>
<ul>
  <li>
    For example, we can’t iterate or loop over keys, values or entries. And we can’t compute the size.
  </li>
  <li>
    Additionally, we can’t clear a WeakMap either – we have to create a fresh instance.
  </li>
</ul>
<p>These restrictions enable a security property. Quoting <a href="https://github.com/tc39/notes/blob/main/meetings/2014-11/nov-19.md#412-should-weakmapweakset-have-a-clear-method-markm">Mark Miller</a>:</p>
<blockquote>
  <p>The mapping from weakmap/key pair value can only be observed or affected by someone who has both the weakmap and the key. With <code>clear()</code>, someone with only the WeakMap would’ve been able to affect the WeakMap-and-key-to-value mapping.</p>
</blockquote>
<h3 id="weakmap-keys-are-weakly-held"><a class="heading-id-link" href="#weakmap-keys-are-weakly-held">37.3 The keys of a WeakMap are <em>weakly held</em></a></h3>
<p>The keys of a WeakMap are said to be <em>weakly held</em>: Normally if one object refers to another one, then the latter object can’t be garbage-collected as long as the former exists. With a WeakMap, that is different: If an object is a key and not referred to elsewhere, it can be garbage-collected while the WeakMap still exists. That also leads to the corresponding entry being removed (but there is no way to observe that).</p>
<h4 id="weakmap-keys-criteria"><a class="heading-id-link" href="#weakmap-keys-criteria">37.3.1 What values can be keys in WeakMaps?</a></h4>
<p>Which values can be keys in WeakMaps is documented in the ECMAScript specification, via the specification function <a href="https://tc39.es/ecma262/#sec-canbeheldweakly"><code>CanBeHeldWeakly()</code></a>:</p>
<ul>
  <li>
    Objects <sup>ES6</sup>
  </li>
  <li>
    Symbols <sup>ES2023</sup> – as long as they are not registered (created via <code>Symbol.for()</code>)
  </li>
</ul>
<p>All kinds of keys have one thing in common – they have <a href="ch_values.html#primitive-values-vs-objects"><em>identity semantics</em></a>:</p>
<ol>
  <li>
    When compared via <code>===</code>, two keys are considered equal if they have the same identity – they are <em>not</em> compared by comparing their contents (their values). That means there are never two or more different keys (“different” meaning “at different locations in memory”) that are all considered equal. Each key is unique.
  </li>
  <li>
    They are garbage-collected.
  </li>
</ol>
<p>Both conditions are important so that WeakMaps can dispose entries when keys disappear and no memory leaks.</p>
<p>Let’s look at examples:</p>
<ul>
  <li>
    <p>Non-registered symbols can be used as WeakMap keys: They are primitive but they are compared by identity and they are garbage-collected.</p>
  </li>
  <li>
    <p>The following two kinds of values cannot be used as WeakMap keys:</p>
    <ul>
      <li>
        Strings are garbage-collected but they are compared by value.
      </li>
      <li>
        <a href="https://exploringjs.com/es6/ch_symbols.html#sec_symbols-crossing-realms">Registered symbols</a> are different from normal symbols – they do not have identity semantics (<a href="https://tc39.es/ecma262/#sec-canbeheldweakly">source</a>). This is how registered symbols are used:
      </li>
    </ul>
<pre class="language-js">
<code><span class="hljs-comment">// Get a symbol from the registry</span></code>
<code><span class="hljs-keyword">const</span> mySymbol = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">'key-in-symbol-registry'</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-comment">// Retrieve that symbol again</span></code>
<code>  <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">'key-in-symbol-registry'</span>),</code>
<code>  mySymbol</code>
<code>);</code>
</pre>
  </li>
</ul>
<h4 id="why-are-symbols-as-weakmap-keys-interesting-es2023"><a class="heading-id-link" href="#why-are-symbols-as-weakmap-keys-interesting-es2023">37.3.2 Why are symbols as WeakMap keys interesting?<span> <sup>ES2023</sup></span></a></h4>
<p>Symbols as WeakMap keys solve important issues for upcoming JavaScript features:</p>
<ul>
  <li>
    We can put references to objects inside <a href="https://2ality.com/2020/05/records-tuples-first-look.html">records and tuples</a>.
  </li>
  <li>
    We can pass references to objects in and out of <a href="https://2ality.com/2022/04/shadow-realms.html">ShadowRealms</a>.
  </li>
</ul>
<h3 id="attaching-values-to-objects-via-weakmaps"><a class="heading-id-link" href="#attaching-values-to-objects-via-weakmaps">37.4 Use case for WeakMaps: attaching values to objects</a></h3>
<p>We can use WeakMaps to externally attach values to objects – for example:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> externalId = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();</code>
<code>{</code>
<code>  <span class="hljs-keyword">const</span> obj = {};</code>
<code>  externalId.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">'x3cdw5am'</span>); <span class="hljs-comment">// (A)</span></code>
<code>  assert.<span class="hljs-title function_">equal</span>(</code>
<code>    externalId.<span class="hljs-title function_">get</span>(obj), <span class="hljs-comment">// (B)</span></code>
<code>    <span class="hljs-string">'x3cdw5am'</span></code>
<code>  );</code>
<code>}</code>
<code><span class="hljs-comment">// (C)</span></code>
</pre>
<ul>
  <li>
    In line A, we set an external ID for <code>obj</code>.
  </li>
  <li>
    In line B, we get the external ID of <code>obj</code>.
  </li>
  <li>
    In line C, <code>obj</code> can be garbage-collected even though it is a key in the data structure <code>externalId</code>.
  </li>
</ul>
<p>In a way, we created a property for <code>obj</code>, but stored it externally. If <code>externalId</code> were a property, the previous code would look as follows:</p>
<pre class="language-js">
<code>{</code>
<code>  <span class="hljs-keyword">const</span> obj = {};</code>
<code>  obj.<span class="hljs-property">externalId</span> = <span class="hljs-string">'x3cdw5am'</span>;</code>
<code>  assert.<span class="hljs-title function_">equal</span>(</code>
<code>    obj.<span class="hljs-property">externalId</span>,</code>
<code>    <span class="hljs-string">'x3cdw5am'</span></code>
<code>  );</code>
<code>}</code>
</pre>
<h4 id="example-caching-computed-results"><a class="heading-id-link" href="#example-caching-computed-results">37.4.1 Example: caching computed results</a></h4>
<p>With WeakMaps, we can associate previously computed results with objects without having to worry about memory management. The following function <code>countOwnKeys()</code> is an example: it caches previous results in the WeakMap <code>cache</code>.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">countOwnKeys</span>(<span class="hljs-params">obj</span>) {</code>
<code>  <span class="hljs-keyword">if</span> (cache.<span class="hljs-title function_">has</span>(obj)) {</code>
<code>    <span class="hljs-keyword">return</span> [cache.<span class="hljs-title function_">get</span>(obj), <span class="hljs-string">'cached'</span>];</code>
<code>  } <span class="hljs-keyword">else</span> {</code>
<code>    <span class="hljs-keyword">const</span> count = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-property">length</span>;</code>
<code>    cache.<span class="hljs-title function_">set</span>(obj, count);</code>
<code>    <span class="hljs-keyword">return</span> [count, <span class="hljs-string">'computed'</span>];</code>
<code>  }</code>
<code>}</code>
</pre>
<p>If we use this function with an object <code>obj</code>, we can see that the result is only computed for the first invocation, while a cached value is used for the second invocation:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span>};</span></code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">countOwnKeys</span>(obj)</span></code>
<code>[2, 'computed']</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">countOwnKeys</span>(obj)</span></code>
<code>[2, 'cached']</code>
</pre>
<h4 id="private-data-in-weakmaps"><a class="heading-id-link" href="#private-data-in-weakmaps">37.4.2 Example: keeping data of objects private</a></h4>
<p>In the following code, the WeakMaps <code>_counter</code> and <code>_action</code> are used to store the values of virtual properties of instances of <code>Countdown</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> _counter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();</code>
<code><span class="hljs-keyword">const</span> _action = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();</code>
<code/>
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Countdown</span> {</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">counter, action</span>) {</code>
<code>    _counter.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, counter);</code>
<code>    _action.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, action);</code>
<code>  }</code>
<code>  <span class="hljs-title function_">dec</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">let</span> counter = _counter.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>);</span></code>
<code><span class="hljs-params">    counter--;</span></code>
<code><span class="hljs-params">    _counter.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, counter);</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">if</span> (counter === <span class="hljs-number">0</span>) {</span></code>
<code><span class="hljs-params">      _action.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>)();</span></code>
<code><span class="hljs-params">    }</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">}</span></code>
<code/>
<code><span class="hljs-params"><span class="hljs-comment">// The two pseudo-properties are truly private:</span></span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Countdown</span>()),</span></code>
<code><span class="hljs-params">  []);</span></code>
</pre>
<p>This is how <code>Countdown</code> is used:</p>
<pre class="language-js">
<code><span class="hljs-keyword">let</span> invoked = <span class="hljs-literal">false</span>;</code>
<code/>
<code><span class="hljs-keyword">const</span> cd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Countdown</span>(<span class="hljs-number">3</span>, <span class="hljs-function">() =&gt;</span> invoked = <span class="hljs-literal">true</span>);</code>
<code/>
<code>cd.<span class="hljs-title function_">dec</span>(); assert.<span class="hljs-title function_">equal</span>(invoked, <span class="hljs-literal">false</span>);</code>
<code>cd.<span class="hljs-title function_">dec</span>(); assert.<span class="hljs-title function_">equal</span>(invoked, <span class="hljs-literal">false</span>);</code>
<code>cd.<span class="hljs-title function_">dec</span>(); assert.<span class="hljs-title function_">equal</span>(invoked, <span class="hljs-literal">true</span>);</code>
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: WeakMaps for private data</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/weakmaps/weakmaps_private_data_test.mjs</code></p>
</div>
<h3 id="quickref-weakmaps"><a class="heading-id-link" href="#quickref-weakmaps">37.5 Quick reference: <code>WeakMap</code></a></h3>
<p>The constructor and the four methods of <code>WeakMap</code> work the same as <a href="ch_maps.html#quickref-maps">their <code>Map</code> equivalents</a>:</p>
<ul>
  <li>
    <code>new WeakMap&lt;K, V&gt;(entries?: Iterable&lt;[K, V]&gt;)</code> <sup>ES6</sup>
  </li>
  <li>
    <code>WeakMap.prototype.delete(key: K) : boolean</code> <sup>ES6</sup>
  </li>
  <li>
    <code>WeakMap.prototype.get(key: K) : V</code> <sup>ES6</sup>
  </li>
  <li>
    <code>WeakMap.prototype.has(key: K) : boolean</code> <sup>ES6</sup>
  </li>
  <li>
    <code>WeakMap.prototype.set(key: K, value: V) : this</code> <sup>ES6</sup>
  </li>
</ul>

    
      
</body>
</html>