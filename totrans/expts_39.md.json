["```ts\n{\n \"$id\": \"https://example.com/geographical-location.schema.json\",\n \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n \"title\": \"Longitude and Latitude Values\",\n \"description\": \"A geographical coordinate.\",\n \"required\": [ \"latitude\", \"longitude\" ],\n \"type\": \"object\",\n \"properties\": {\n \"latitude\": {\n \"type\": \"number\",\n \"minimum\": -90,\n \"maximum\": 90\n },\n \"longitude\": {\n \"type\": \"number\",\n \"minimum\": -180,\n \"maximum\": 180\n }\n }\n}\n\n```", "```ts\n{\n \"latitude\": 48.858093,\n \"longitude\": 2.294694\n}\n\n```", "```ts\nimport { z } from 'zod';\n\n// Define schema\nconst ProductSchema = z.object({\n name: z.string().min(1), // non-empty\n scores: z.array(\n z.union([ z.number(), z.string() ])\n ),\n});\n\n// Derive TypeScript type from schema\ntype Product = z.infer<typeof ProductSchema>;\ntype _ = Assert<Equal<\n Product,\n {\n name: string,\n scores: Array<number | string>,\n }\n>>;\n\n// Validate data\nconst product = ProductSchema.parse({\n name: 'Toothpaste',\n scores: [ 5, '*****' ],\n});\nassertType<Product>(product);\n\n```", "```ts\nimport * as v from 'valibot';\n\n// Define schema\nconst ProductSchema = v.object({\n name: v.pipe(v.string(), v.minLength(1)), // non-empty\n scores: v.array(\n v.union([ v.number(), v.string() ])\n ),\n});\n\n// Derive TypeScript type from schema\ntype Product = v.InferOutput<typeof ProductSchema>;\ntype _ = Assert<Equal<\n Product,\n {\n name: string,\n scores: Array<number | string>,\n }\n>>;\n\n// Validate data\nconst product = v.parse(ProductSchema, {\n name: 'Toothpaste',\n scores: [ 5, '*****' ],\n});\nassertType<Product>(product);\n\n```", "```ts\nimport { type } from 'arktype';\n\n// Define schema\nconst productSchema = type({\n name: 'string > 0', // non-empty\n scores: '(number | string)[]',\n});\n\n// Derive TypeScript type from schema\ntype Product = typeof productSchema.infer;\ntype _ = Assert<Equal<\n Product,\n {\n name: string,\n scores: Array<number | string>,\n }\n>>;\n\n// Validate data\nconst product = productSchema({\n name: 'Toothpaste',\n scores: [ 5, '*****' ],\n});\nif (product instanceof type.errors) {\n throw new TypeError(product.summary);\n} else {\n assertType<Product>(product);\n}\n\n```", "```ts\nimport * as z from 'zod';\n\nconst FileEntryInputSchema = z.union([\n z.string(),\n z.tuple([z.string(), z.string(), z.array(z.string())]),\n z.interface({\n file: z.string(),\n 'author?': z.string(),\n 'tags?': z.array(z.string()),\n }),\n]);\n\n```", "```ts\ntype FileEntryInput =\n | string\n | [ string, string, Array<string> ]\n | { file: string, author?: string, tags?: Array<string> }\n ;\n\n```", "```ts\ntype _ = Assert<Equal<\n z.infer<typeof FileEntryInputSchema>,\n FileEntryInput\n>>;\n\n```", "```ts\nconst fileEntryInput: FileEntryInput = FileEntryInputSchema.parse( // OK\n ['iceland.txt', 'me', ['vacation', 'family']]\n);\nassert.throws(\n () => FileEntryInputSchema.parse(['iceland.txt', 'me'])\n);\n\n```", "```ts\nconst Schema = z.object({\n file: z.string(),\n author: z.string().optional(),\n tags: z.array(z.string()).optional(),\n});\ntype _ = Assert<Equal<\n z.infer<typeof Schema>,\n {\n file: string,\n author?: string | undefined, // (A)\n tags?: Array<string> | undefined, // (B)\n }\n>>;\n\n```", "```ts\ntype FileEntryInput =\n | string\n | [ string, string, Array<string> ]\n | { file: string, author?: string, tags?: Array<string> }\n ;\n\n```", "```ts\ntype FileEntry = {\n file: string,\n author: null | string,\n tags: Array<string>,\n};\n\n```"]