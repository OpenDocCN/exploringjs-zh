- en: 27 Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 27 模块
- en: 原文：[https://exploringjs.com/impatient-js/ch_modules.html](https://exploringjs.com/impatient-js/ch_modules.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/impatient-js/ch_modules.html](https://exploringjs.com/impatient-js/ch_modules.html)
- en: '* * *'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '27.1 [Cheat sheet: modules](ch_modules.html#cheat-sheet-modules)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.1 [速查表：模块](ch_modules.html#cheat-sheet-modules)
- en: 27.1.1 [Exporting](ch_modules.html#module-exports)
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.1.1 [导出](ch_modules.html#module-exports)
- en: 27.1.2 [Importing](ch_modules.html#importing)
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.1.2 [导入](ch_modules.html#importing)
- en: 27.2 [JavaScript source code formats](ch_modules.html#javascript-source-code-formats)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.2 [JavaScript源代码格式](ch_modules.html#javascript-source-code-formats)
- en: 27.2.1 [Code before built-in modules was written in ECMAScript 5](ch_modules.html#code-before-built-in-modules-was-written-in-ecmascript-5)
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.2.1 [内置模块之前的代码是用ECMAScript 5编写的](ch_modules.html#code-before-built-in-modules-was-written-in-ecmascript-5)
- en: 27.3 [Before we had modules, we had scripts](ch_modules.html#scripts)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.3 [在我们有模块之前，我们有脚本](ch_modules.html#scripts)
- en: 27.4 [Module systems created prior to ES6](ch_modules.html#module-systems-created-prior-to-es6)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.4 [ES6之前创建的模块系统](ch_modules.html#module-systems-created-prior-to-es6)
- en: '27.4.1 [Server side: CommonJS modules](ch_modules.html#server-side-commonjs-modules)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.4.1 [服务器端：CommonJS模块](ch_modules.html#server-side-commonjs-modules)
- en: '27.4.2 [Client side: AMD (Asynchronous Module Definition) modules](ch_modules.html#client-side-amd-asynchronous-module-definition-modules)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.4.2 [客户端：AMD（异步模块定义）模块](ch_modules.html#client-side-amd-asynchronous-module-definition-modules)
- en: 27.4.3 [Characteristics of JavaScript modules](ch_modules.html#characteristics-of-javascript-modules)
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.4.3 [JavaScript模块的特点](ch_modules.html#characteristics-of-javascript-modules)
- en: 27.5 [ECMAScript modules](ch_modules.html#ecmascript-modules)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.5 [ECMAScript模块](ch_modules.html#ecmascript-modules)
- en: '27.5.1 [ES modules: syntax, semantics, loader API](ch_modules.html#es-modules-syntax-semantics-loader-api)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.5.1 [ES模块：语法、语义、加载器API](ch_modules.html#es-modules-syntax-semantics-loader-api)
- en: 27.6 [Named exports and imports](ch_modules.html#named-exports-and-imports)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.6 [命名导出和导入](ch_modules.html#named-exports-and-imports)
- en: 27.6.1 [Named exports](ch_modules.html#named-exports)
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.6.1 [命名导出](ch_modules.html#named-exports)
- en: 27.6.2 [Named imports](ch_modules.html#named-imports)
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.6.2 [命名导入](ch_modules.html#named-imports)
- en: 27.6.3 [Namespace imports](ch_modules.html#namespace-imports)
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.6.3 [命名空间导入](ch_modules.html#namespace-imports)
- en: '27.6.4 [Named exporting styles: inline versus clause (advanced)](ch_modules.html#named-exporting-styles-inline-versus-clause-advanced)'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.6.4 [命名导出风格：内联与子句（高级）](ch_modules.html#named-exporting-styles-inline-versus-clause-advanced)
- en: 27.7 [Default exports and imports](ch_modules.html#default-exports-and-imports)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.7 [默认导出和导入](ch_modules.html#default-exports-and-imports)
- en: 27.7.1 [The two styles of default-exporting](ch_modules.html#the-two-styles-of-default-exporting)
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.7.1 [默认导出的两种风格](ch_modules.html#the-two-styles-of-default-exporting)
- en: 27.7.2 [The default export as a named export (advanced)](ch_modules.html#the-default-export-as-a-named-export-advanced)
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.7.2 [默认导出作为命名导出（高级）](ch_modules.html#the-default-export-as-a-named-export-advanced)
- en: 27.8 [More details on exporting and importing](ch_modules.html#more-details-on-exporting-and-importing)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.8 [导出和导入的更多细节](ch_modules.html#more-details-on-exporting-and-importing)
- en: 27.8.1 [Imports are read-only views on exports](ch_modules.html#imports-are-read-only-views-on-exports)
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.8.1 [导入是对导出的只读视图](ch_modules.html#imports-are-read-only-views-on-exports)
- en: 27.8.2 [ESM’s transparent support for cyclic imports (advanced)](ch_modules.html#esms-transparent-support-for-cyclic-imports-advanced)
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.8.2 [ESM对循环导入的透明支持（高级）](ch_modules.html#esms-transparent-support-for-cyclic-imports-advanced)
- en: 27.9 [npm packages](ch_modules.html#npm-packages)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.9 [npm包](ch_modules.html#npm-packages)
- en: 27.9.1 [Packages are installed inside a directory `node_modules/`](ch_modules.html#packages-are-installed-inside-a-directory-node_modules)
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.9.1 [包安装在`node_modules/`目录中](ch_modules.html#packages-are-installed-inside-a-directory-node_modules)
- en: 27.9.2 [Why can npm be used to install frontend libraries?](ch_modules.html#why-can-npm-be-used-to-install-frontend-libraries)
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.9.2 [npm为什么可以用于安装前端库？](ch_modules.html#why-can-npm-be-used-to-install-frontend-libraries)
- en: 27.10 [Naming modules](ch_modules.html#naming-modules)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.10 [模块命名](ch_modules.html#naming-modules)
- en: 27.11 [Module specifiers](ch_modules.html#module-specifiers)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.11 [模块规范](ch_modules.html#module-specifiers)
- en: 27.11.1 [Categories of module specifiers](ch_modules.html#categories-of-module-specifiers)
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.11.1 [模块规范的类别](ch_modules.html#categories-of-module-specifiers)
- en: 27.11.2 [ES module specifiers in browsers](ch_modules.html#es-module-specifiers-in-browsers)
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.11.2 [浏览器中的ES模块规范](ch_modules.html#es-module-specifiers-in-browsers)
- en: 27.11.3 [ES module specifiers on Node.js](ch_modules.html#es-module-specifiers-on-node.js)
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.11.3 [Node.js上的ES模块规范](ch_modules.html#es-module-specifiers-on-node.js)
- en: 27.12 [`import.meta` – metadata for the current module [ES2020]](ch_modules.html#import.meta)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.12 [`import.meta` – 当前模块的元数据[ES2020]](ch_modules.html#import.meta)
- en: 27.12.1 [`import.meta.url`](ch_modules.html#import.meta.url)
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.12.1 [`import.meta.url`](ch_modules.html#import.meta.url)
- en: 27.12.2 [`import.meta.url` and class `URL`](ch_modules.html#import.meta.url-and-class-url)
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.12.2 [`import.meta.url`和`URL`类](ch_modules.html#import.meta.url-and-class-url)
- en: 27.12.3 [`import.meta.url` on Node.js](ch_modules.html#import.meta.url-on-node.js)
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.12.3 [Node.js上的`import.meta.url`](ch_modules.html#import.meta.url-on-node.js)
- en: 27.13 [Loading modules dynamically via `import()` [ES2020] (advanced)](ch_modules.html#dynamic-imports)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.13 [通过`import()` [ES2020]（高级）动态加载模块](ch_modules.html#dynamic-imports)
- en: 27.13.1 [The limitations of static `import` statements](ch_modules.html#the-limitations-of-static-import-statements)
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.13.1 [静态`import`语句的限制](ch_modules.html#the-limitations-of-static-import-statements)
- en: 27.13.2 [Dynamic imports via the `import()` operator](ch_modules.html#dynamic-imports-via-the-import-operator)
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.13.2 [通过`import()`运算符动态导入](ch_modules.html#dynamic-imports-via-the-import-operator)
- en: 27.13.3 [Use cases for `import()`](ch_modules.html#use-cases-for-import)
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.13.3 [`import()`的用例](ch_modules.html#use-cases-for-import)
- en: 27.14 [Top-level `await` in modules [ES2022] (advanced)](ch_modules.html#top-level-await)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.14 [模块中的顶层`await` [ES2022]（高级）](ch_modules.html#top-level-await)
- en: 27.14.1 [Use cases for top-level `await`](ch_modules.html#use-cases-for-top-level-await)
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.14.1 [顶层`await`的用例](ch_modules.html#use-cases-for-top-level-await)
- en: 27.14.2 [How does top-level `await` work under the hood?](ch_modules.html#how-does-top-level-await-work-under-the-hood)
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.14.2 [顶层`await`在内部是如何工作的？](ch_modules.html#how-does-top-level-await-work-under-the-hood)
- en: 27.14.3 [The pros and cons of top-level `await`](ch_modules.html#the-pros-and-cons-of-top-level-await)
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.14.3 [顶层`await`的利弊](ch_modules.html#the-pros-and-cons-of-top-level-await)
- en: '27.15 [Polyfills: emulating native web platform features (advanced)](ch_modules.html#polyfills)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.15 [Polyfills:模拟原生Web平台功能（高级）](ch_modules.html#polyfills)
- en: 27.15.1 [Sources of this section](ch_modules.html#sources-of-this-section)
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 27.15.1 [本节的来源](ch_modules.html#sources-of-this-section)
- en: '* * *'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '27.1 Cheat sheet: modules'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.1 速查表：模块
- en: 27.1.1 Exporting
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.1.1 导出
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 27.1.2 Importing
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.1.2 导入
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 27.2 JavaScript source code formats
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.2 JavaScript源代码格式
- en: 'The current landscape of JavaScript modules is quite diverse: ES6 brought built-in
    modules, but the source code formats that came before them, are still around,
    too. Understanding the latter helps understand the former, so let’s investigate.
    The next sections describe the following ways of delivering JavaScript source
    code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当前JavaScript模块的格局非常多样化：ES6带来了内置模块，但在它们之前出现的源代码格式仍然存在。了解后者有助于了解前者，因此让我们进行调查。接下来的章节描述了以下传递JavaScript源代码的方式：
- en: '*Scripts* are code fragments that browsers run in global scope. They are precursors
    of modules.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*脚本*是浏览器在全局范围内运行的代码片段。它们是模块的前身。'
- en: '*CommonJS modules* are a module format that is mainly used on servers (e.g.,
    via Node.js).'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CommonJS模块*是一种主要用于服务器的模块格式（例如，通过Node.js）。'
- en: '*AMD modules* are a module format that is mainly used in browsers.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*AMD模块*是一种主要用于浏览器的模块格式。'
- en: '*ECMAScript modules* are JavaScript’s built-in module format. It supersedes
    all previous formats.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ECMAScript模块*是JavaScript的内置模块格式。它取代了所有以前的格式。'
- en: Tbl. [18](#tbl:source-code-formats) gives an overview of these code formats.
    Note that for CommonJS modules and ECMAScript modules, two filename extensions
    are commonly used. Which one is appropriate depends on how we want to use a file.
    Details are given later in this chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Tbl. [18](#tbl:source-code-formats)概述了这些代码格式。请注意，对于CommonJS模块和ECMAScript模块，通常使用两个文件扩展名。哪一个适合取决于我们想要如何使用文件。本章后面会详细介绍。
- en: 'Table 18: Ways of delivering JavaScript source code.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 表18：传递JavaScript源代码的方式。
- en: '|  | Runs on | Loaded | Filename ext. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '|  | 运行在 | 加载 | 文件扩展名 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Script | browsers | async | `.js` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 脚本 | 浏览器 | 异步 | `.js` |'
- en: '| CommonJS module | servers | sync | `.js .cjs` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| CommonJS模块 | 服务器 | 同步 | `.js .cjs` |'
- en: '| AMD module | browsers | async | `.js` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| AMD模块 | 浏览器 | 异步 | `.js` |'
- en: '| ECMAScript module | browsers and servers | async | `.js .mjs` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| ECMAScript模块 | 浏览器和服务器 | 异步 | `.js .mjs` |'
- en: 27.2.1 Code before built-in modules was written in ECMAScript 5
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.2.1 在内置模块之前的代码是用ECMAScript 5编写的
- en: 'Before we get to built-in modules (which were introduced with ES6), all code
    that we’ll see, will be written in ES5\. Among other things:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入内置模块（在ES6中引入）之前，我们将看到的所有代码都将以ES5编写。其中包括：
- en: ES5 did not have `const` and `let`, only `var`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES5没有`const`和`let`，只有`var`。
- en: ES5 did not have arrow functions, only function expressions.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES5没有箭头函数，只有函数表达式。
- en: 27.3 Before we had modules, we had scripts
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.3 在我们有模块之前，我们有脚本
- en: 'Initially, browsers only had *scripts* – pieces of code that were executed
    in global scope. As an example, consider an HTML file that loads script files
    via the following HTML:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，浏览器只有*脚本* - 在全局范围内执行的代码片段。例如，考虑一个通过以下HTML加载脚本文件的HTML文件：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The main file is `my-module.js`, where we simulate a module:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 主文件是`my-module.js`，在那里我们模拟一个模块：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`myModule` is a global variable that is assigned the result of immediately
    invoking a function expression. The function expression starts in the first line.
    It is invoked in the last line.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`myModule`是一个全局变量，它被赋予立即调用函数表达式的结果。函数表达式从第一行开始。它在最后一行被调用。'
- en: 'This way of wrapping a code fragment is called *immediately invoked function
    expression* (IIFE, coined by Ben Alman). What do we gain from an IIFE? `var` is
    not block-scoped (like `const` and `let`), it is function-scoped: the only way
    to create new scopes for `var`-declared variables is via functions or methods
    (with `const` and `let`, we can use either functions, methods, or blocks `{}`).
    Therefore, the IIFE in the example hides all of the following variables from global
    scope and minimizes name clashes: `importedFunc1`, `importedFunc2`, `internalFunc`,
    `exportedFunc`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这种包装代码片段的方式称为*立即调用函数表达式*（IIFE，由Ben Alman创造）。我们从IIFE中获得了什么？`var`不是块作用域（像`const`和`let`一样），它是函数作用域：为`var`声明的变量创建新作用域的唯一方法是通过函数或方法（对于`const`和`let`，我们可以使用函数、方法或块`{}`）。因此，示例中的IIFE隐藏了所有以下变量的全局作用域，并最小化了名称冲突：`importedFunc1`，`importedFunc2`，`internalFunc`，`exportedFunc`。
- en: 'Note that we are using an IIFE in a particular manner: at the end, we pick
    what we want to export and return it via an object literal. That is called the
    *revealing module pattern* (coined by Christian Heilmann).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们以特定方式使用IIFE：最后，我们选择要导出的内容，并通过对象字面量返回它。这被称为*揭示模块模式*（由Christian Heilmann创造）。
- en: 'This way of simulating modules, has several issues:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模拟模块的方式有几个问题：
- en: Libraries in script files export and import functionality via global variables,
    which risks name clashes.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本文件中的库通过全局变量导出和导入功能，这会导致名称冲突。
- en: Dependencies are not stated explicitly, and there is no built-in way for a script
    to load the scripts it depends on. Therefore, the web page has to load not just
    the scripts that are needed by the page but also the dependencies of those scripts,
    the dependencies’ dependencies, etc. And it has to do so in the right order!
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖关系没有明确说明，并且脚本没有内置的方法来加载它所依赖的脚本。因此，网页不仅需要加载页面所需的脚本，还需要加载这些脚本的依赖项，依赖项的依赖项等。而且它必须按正确的顺序这样做！
- en: 27.4 Module systems created prior to ES6
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.4 ES6之前创建的模块系统
- en: 'Prior to ECMAScript 6, JavaScript did not have built-in modules. Therefore,
    the flexible syntax of the language was used to implement custom module systems
    *within* the language. Two popular ones are:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECMAScript 6之前，JavaScript没有内置模块。因此，语言的灵活语法被用于在语言内部实现自定义模块系统。其中两种流行的是：
- en: CommonJS (targeting the server side)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CommonJS（针对服务器端）
- en: AMD (Asynchronous Module Definition, targeting the client side)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AMD（针对客户端的异步模块定义）
- en: '27.4.1 Server side: CommonJS modules'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.4.1 服务器端：CommonJS模块
- en: The original CommonJS standard for modules was created for server and desktop
    platforms. It was the foundation of the original Node.js module system, where
    it achieved enormous popularity. Contributing to that popularity were the npm
    package manager for Node and tools that enabled using Node modules on the client
    side (browserify, webpack, and others).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的原始CommonJS标准是为服务器和桌面平台创建的。它是最初的Node.js模块系统的基础，在那里取得了巨大的流行。贡献于该流行的是Node的npm包管理器和工具，使得可以在客户端使用Node模块（browserify、webpack等）。
- en: 'From now on, *CommonJS module* means the Node.js version of this standard (which
    has a few additional features). This is an example of a CommonJS module:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，*CommonJS模块*指的是这个标准的Node.js版本（它还有一些额外的功能）。这是一个CommonJS模块的例子：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'CommonJS can be characterized as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS可以被描述如下：
- en: Designed for servers.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计用于服务器。
- en: Modules are meant to be loaded *synchronously* (the importer waits while the
    imported module is loaded and executed).
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块被设计为*同步*加载（导入者等待导入的模块被加载和执行）。
- en: Compact syntax.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧凑的语法。
- en: '27.4.2 Client side: AMD (Asynchronous Module Definition) modules'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.4.2 客户端：AMD（异步模块定义）模块
- en: The AMD module format was created to be easier to use in browsers than the CommonJS
    format. Its most popular implementation is [RequireJS](https://requirejs.org).
    The following is an example of an AMD module.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: AMD模块格式是为了在浏览器中比CommonJS格式更容易使用而创建的。它最流行的实现是[RequireJS](https://requirejs.org)。以下是一个AMD模块的例子。
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'AMD can be characterized as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: AMD可以被描述如下：
- en: Designed for browsers.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计用于浏览器。
- en: Modules are meant to be loaded *asynchronously*. That’s a crucial requirement
    for browsers, where code can’t wait until a module has finished downloading. It
    has to be notified once the module is available.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块被设计为*异步*加载。这对于浏览器来说是一个至关重要的要求，因为代码不能等待模块下载完成。它必须在模块可用时得到通知。
- en: The syntax is slightly more complicated.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法稍微复杂一些。
- en: On the plus side, AMD modules can be executed directly. In contrast, CommonJS
    modules must either be compiled before deployment or custom source code must be
    generated and evaluated dynamically [(think `eval()`)](ch_dynamic-code-evaluation.html#eval).
    That isn’t always permitted on the web.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 好处是，AMD模块可以直接执行。相比之下，CommonJS模块必须在部署之前编译，或者必须生成和动态评估自定义源代码[(考虑`eval()`)](ch_dynamic-code-evaluation.html#eval)。这在网络上并不总是被允许。
- en: 27.4.3 Characteristics of JavaScript modules
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.4.3 JavaScript模块的特点
- en: 'Looking at CommonJS and AMD, similarities between JavaScript module systems
    emerge:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 查看CommonJS和AMD，JavaScript模块系统之间的相似之处显现出来：
- en: There is one module per file.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个文件有一个模块。
- en: 'Such a file is basically a piece of code that is executed:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这样的文件基本上是一段被执行的代码：
- en: 'Local scope: The code is executed in a local “module scope”. Therefore, by
    default, all of the variables, functions, and classes declared in it are internal
    and not global.'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部作用域：代码在局部的“模块作用域”中执行。因此，默认情况下，其中声明的所有变量、函数和类都是内部的，而不是全局的。
- en: 'Exports: If we want any declared entity to be exported, we must explicitly
    mark it as an export.'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出：如果我们希望导出任何声明的实体，必须明确将其标记为导出。
- en: 'Imports: Each module can import exported entities from other modules. Those
    other modules are identified via *module specifiers* (usually paths, occasionally
    full URLs).'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入：每个模块可以从其他模块导入导出的实体。这些其他模块通过*模块规范符*（通常是路径，偶尔是完整URL）来标识。
- en: 'Modules are *singletons*: Even if a module is imported multiple times, only
    a single “instance” of it exists.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块是*单例*的：即使一个模块被多次导入，它只存在一个“实例”。
- en: No global variables are used. Instead, module specifiers serve as global IDs.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不使用全局变量。相反，模块规范符充当全局ID。
- en: 27.5 ECMAScript modules
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.5 ECMAScript模块
- en: '*ECMAScript modules* (*ES modules* or *ESM*) were introduced with ES6\. They
    continue the tradition of JavaScript modules and have all of their aforementioned
    characteristics. Additionally:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*ECMAScript模块*（*ES模块*或*ESM*）是在ES6中引入的。它延续了JavaScript模块的传统，并具有所有前述的特点。另外：'
- en: With CommonJS, ES modules share the compact syntax and support for cyclic dependencies.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CommonJS，ES模块共享紧凑的语法和对循环依赖的支持。
- en: With AMD, ES modules share being designed for asynchronous loading.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AMD，ES模块共享被设计用于异步加载的特点。
- en: 'ES modules also have new benefits:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ES模块也有新的好处：
- en: The syntax is even more compact than CommonJS’s.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法甚至比CommonJS更加紧凑。
- en: Modules have *static* structures (which can’t be changed at runtime). That helps
    with static checking, optimized access of imports, dead code elimination, and
    more.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块具有*静态*结构（无法在运行时更改）。这有助于静态检查、优化导入的访问、死代码消除等。
- en: Support for cyclic imports is completely transparent.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对循环导入的支持是完全透明的。
- en: 'This is an example of ES module syntax:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个ES模块语法的例子：
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: From now on, “module” means “ECMAScript module”.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，“模块”指的是“ECMAScript模块”。
- en: '27.5.1 ES modules: syntax, semantics, loader API'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.5.1 ES模块：语法、语义、加载器API
- en: 'The full standard of ES modules comprises the following parts:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ES模块的完整标准包括以下部分：
- en: 'Syntax (how code is written): What is a module? How are imports and exports
    declared? Etc.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语法（代码的编写方式）：什么是模块？如何声明导入和导出？等等。
- en: 'Semantics (how code is executed): How are variable bindings exported? How are
    imports connected with exports? Etc.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语义（代码的执行方式）：变量绑定是如何导出的？导入与导出如何连接？等等。
- en: A programmatic loader API for configuring module loading.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于配置模块加载的编程加载器API。
- en: Parts 1 and 2 were introduced with ES6\. Work on part 3 is ongoing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 部分1和2是在ES6中引入的。第3部分的工作正在进行中。
- en: 27.6 Named exports and imports
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.6 命名导出和导入
- en: 27.6.1 Named exports
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.6.1 命名导出
- en: Each module can have zero or more *named exports*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块可以有零个或多个*命名导出*。
- en: 'As an example, consider the following two files:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下两个文件：
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Module `my-math.mjs` has two named exports: `square` and `LIGHTSPEED`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 模块`my-math.mjs`有两个命名导出：`square`和`LIGHTSPEED`。
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To export something, we put the keyword `export` in front of a declaration.
    Entities that are not exported are private to a module and can’t be accessed from
    outside.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要导出某些东西，我们在声明前面放置关键字`export`。未导出的实体对于模块是私有的，无法从外部访问。
- en: 27.6.2 Named imports
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.6.2 命名导入
- en: 'Module `main.mjs` has a single named import, `square`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 模块`main.mjs`有一个命名导入，`square`：
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It can also rename its import:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以重命名其导入：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '27.6.2.1 Syntactic pitfall: named importing is not destructuring'
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 27.6.2.1 语法陷阱：命名导入不是解构
- en: 'Both named importing and destructuring look similar:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 命名导入和解构看起来很相似：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'But they are quite different:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 但它们是非常不同的：
- en: Imports remain connected with their exports.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入保持与其导出的连接。
- en: We can destructure again inside a destructuring pattern, but the `{}` in an
    import statement can’t be nested.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在解构模式内再次解构，但是导入语句中的`{}`不能嵌套。
- en: 'The syntax for renaming is different:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名的语法不同：
- en: '[PRE12]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Rationale: Destructuring is reminiscent of an object literal (including nesting),
    while importing evokes the idea of renaming.'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原理：解构类似于对象文字（包括嵌套），而导入则唤起重命名的想法。
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Named exports**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **练习：命名导出**'
- en: '`exercises/modules/export_named_test.mjs`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/modules/export_named_test.mjs`'
- en: 27.6.3 Namespace imports
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.6.3 命名空间导入
- en: '*Namespace imports* are an alternative to named imports. If we namespace-import
    a module, it becomes an object whose properties are the named exports. This is
    what `main.mjs` looks like if we use a namespace import:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*命名空间导入*是命名导入的一种替代方法。如果我们对模块进行命名空间导入，它将成为一个对象，其属性是命名导出。如果我们使用命名空间导入，`main.mjs`看起来像这样：'
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '27.6.4 Named exporting styles: inline versus clause (advanced)'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.6.4 命名导出样式：内联与子句（高级）
- en: 'The named export style we have seen so far was *inline*: We exported entities
    by prefixing them with the keyword `export`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的命名导出样式是*内联*的：我们通过在实体前面加上关键字`export`来导出实体。
- en: 'But we can also use separate *export clauses*. For example, this is what `lib/my-math.mjs`
    looks like with an export clause:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以使用单独的*导出子句*。例如，这是带有导出子句的`lib/my-math.mjs`的样子：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With an export clause, we can rename before exporting and use different names
    internally:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用导出子句，我们可以在导出之前重命名并在内部使用不同的名称：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 27.7 Default exports and imports
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.7 默认导出和导入
- en: Each module can have at most one *default export*. The idea is that the module
    *is* the default-exported value.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块最多可以有一个*默认导出*。这个想法是模块*是*默认导出的值。
- en: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png)  **Avoid mixing named exports
    and default exports**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png)  **避免混合命名导出和默认导出**'
- en: A module can have both named exports and a default export, but it’s usually
    better to stick to one export style per module.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 模块既可以具有命名导出，也可以具有默认导出，但通常最好每个模块只使用一种导出样式。
- en: 'As an example for default exports, consider the following two files:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 作为默认导出的示例，请考虑以下两个文件：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Module `my-func.mjs` has a default export:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 模块`my-func.mjs`具有默认导出：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Module `main.mjs` default-imports the exported function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 模块`main.mjs`默认导入导出的函数：
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note the syntactic difference: the curly braces around named imports indicate
    that we are reaching *into* the module, while a default import *is* the module.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意语法上的区别：命名导入周围的大括号表示我们正在*进入*模块，而默认导入*是*模块。
- en: '![](../Images/4e01a86e5fc2028470dca44da5c2d2aa.png)  **What are use cases for
    default exports?**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/4e01a86e5fc2028470dca44da5c2d2aa.png)  **默认导出的用例是什么？**'
- en: The most common use case for a default export is a module that contains a single
    function or a single class.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 默认导出最常见的用例是包含单个函数或单个类的模块。
- en: 27.7.1 The two styles of default-exporting
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.7.1 两种默认导出样式
- en: There are two styles of doing default exports.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种样式可以进行默认导出。
- en: 'First, we can label existing declarations with `export default`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以使用`export default`标记现有声明：
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Second, we can directly default-export values. This style of `export default`
    is much like a declaration.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可以直接默认导出值。这种`export default`的样式很像一个声明。
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 27.7.1.1 Why are there two default export styles?
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 27.7.1.1 为什么有两种默认导出样式？
- en: 'The reason is that `export default` can’t be used to label `const`: `const`
    may define multiple values, but `export default` needs exactly one value. Consider
    the following hypothetical code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是`export default`不能用于标记`const`：`const`可以定义多个值，但`export default`需要确切的一个值。考虑以下假设的代码：
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this code, we don’t know which one of the three values is the default export.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，我们不知道三个值中的哪一个是默认导出。
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Default exports**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **练习：默认导出**'
- en: '`exercises/modules/export_default_test.mjs`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/modules/export_default_test.mjs`'
- en: 27.7.2 The default export as a named export (advanced)
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.7.2 默认导出作为命名导出（高级）
- en: 'Internally, a default export is simply a named export whose name is `default`.
    As an example, consider the previous module `my-func.mjs` with a default export:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，默认导出只是一个名为`default`的命名导出。例如，考虑具有默认导出的先前模块`my-func.mjs`：
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following module `my-func2.mjs` is equivalent to that module:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模块`my-func2.mjs`等效于该模块：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For importing, we can use a normal default import:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于导入，我们可以使用普通的默认导入：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or we can use a named import:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以使用命名导入：
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The default export is also available via property `.default` of namespace imports:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 默认导出也可以通过命名空间导入的属性`.default`来使用：
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![](../Images/4e01a86e5fc2028470dca44da5c2d2aa.png)  **Isn’t `default` illegal
    as a variable name?**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/4e01a86e5fc2028470dca44da5c2d2aa.png)  **`default`作为变量名是非法的吗？**'
- en: '`default` can’t be a variable name, but it can be an export name and it can
    be a property name:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`default`不能是变量名，但它可以是导出名称，也可以是属性名称：'
- en: '[PRE27]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 27.8 More details on exporting and importing
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.8 导出和导入的更多细节
- en: 27.8.1 Imports are read-only views on exports
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.8.1 导入是对导出的只读视图
- en: So far, we have used imports and exports intuitively, and everything seems to
    have worked as expected. But now it is time to take a closer look at how imports
    and exports are really related.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经直触使用了导入和导出，并且一切似乎都按预期工作。但现在是时候更仔细地看一下导入和导出的真正关系了。
- en: 'Consider the following two modules:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下两个模块：
- en: '[PRE28]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`counter.mjs` exports a (mutable!) variable and a function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`counter.mjs`导出一个（可变的！）变量和一个函数：'
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`main.mjs` name-imports both exports. When we use `incCounter()`, we discover
    that the connection to `counter` is live – we can always access the live state
    of that variable:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.mjs`名称导入了两个导出。当我们使用`incCounter()`时，我们发现与`counter`的连接是实时的-我们始终可以访问该变量的实时状态。'
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that while the connection is live and we can read `counter`, we cannot
    change this variable (e.g., via `counter++`).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然连接是实时的，我们可以读取`counter`，但我们不能更改这个变量（例如，通过`counter++`）。
- en: 'There are two benefits to handling imports this way:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式处理导入有两个好处：
- en: It is easier to split modules because previously shared variables can become
    exports.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拆分模块变得更容易，因为以前共享的变量可以成为导出。
- en: This behavior is crucial for supporting transparent cyclic imports. Read on
    for more information.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种行为对支持透明的循环导入至关重要。继续阅读以获取更多信息。
- en: 27.8.2 ESM’s transparent support for cyclic imports (advanced)
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.8.2 ESM对透明支持循环导入（高级）
- en: 'ESM supports cyclic imports transparently. To understand how that is achieved,
    consider the following example: fig. [7](#fig:module-imports) shows a directed
    graph of modules importing other modules. P importing M is the cycle in this case.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ESM支持透明的循环导入。要了解如何实现这一点，考虑以下示例：图[7](#fig:module-imports)显示了一个模块导入其他模块的有向图。在这种情况下，P导入M是循环。
- en: '![Figure 7: A directed graph of modules importing modules: M imports N and
    O, N imports P and Q, etc.](../Images/36a86530c92f02bc0545c60194aa676d.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图7：模块导入模块的有向图：M导入N和O，N导入P和Q，等等。](../Images/36a86530c92f02bc0545c60194aa676d.png)'
- en: 'Figure 7: A directed graph of modules importing modules: M imports N and O,
    N imports P and Q, etc.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：模块导入模块的有向图：M导入N和O，N导入P和Q，等等。
- en: 'After parsing, these modules are set up in two phases:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 解析后，这些模块分两个阶段设置：
- en: 'Instantiation: Every module is visited and its imports are connected to its
    exports. Before a parent can be instantiated, all of its children must be instantiated.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化：访问每个模块并将其导入连接到其导出。在父级实例化之前，必须先实例化其所有子级。
- en: 'Evaluation: The bodies of the modules are executed. Once again, children are
    evaluated before parents.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估：执行模块的主体。再次强调，必须在父级之前评估子级。
- en: 'This approach handles cyclic imports correctly, due to two features of ES modules:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法正确处理了循环导入，这是由于ES模块的两个特性：
- en: 'Due to the static structure of ES modules, the exports are already known after
    parsing. That makes it possible to instantiate P before its child M: P can already
    look up M’s exports.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于ES模块的静态结构，解析后导出已经是已知的。这使得在其子级M之前实例化P成为可能：P已经可以查找M的导出。
- en: When P is evaluated, M hasn’t been evaluated, yet. However, entities in P can
    already mention imports from M. They just can’t use them, yet, because the imported
    values are filled in later. For example, a function in P can access an import
    from M. The only limitation is that we must wait until after the evaluation of
    M, before calling that function.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当P被评估时，M尚未被评估。但是，P中的实体可以已经提到了来自M的导入。它们只是还不能使用它们，因为导入的值稍后填充。例如，P中的一个函数可以访问来自M的导入。唯一的限制是我们必须等到M的评估之后，才能调用该函数。
- en: Imports being filled in later is enabled by them being “live immutable views”
    on exports.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导入稍后填充是由它们成为对导出的“实时不可变视图”而启用的。
- en: 27.9 npm packages
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.9 npm包
- en: 'The *npm software registry* is the dominant way of distributing JavaScript
    libraries and apps for Node.js and web browsers. It is managed via the *npm package
    manager* (short: *npm*). Software is distributed as so-called *packages*. A package
    is a directory containing arbitrary files and a file `package.json` at the top
    level that describes the package. For example, when npm creates an empty package
    inside a directory `my-package/`, we get this `package.json`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*npm软件注册表*是分发JavaScript库和Node.js和Web浏览器应用程序的主要方式。它通过*npm软件包管理器*（简称*npm*）进行管理。软件以所谓的*包*的形式分发。包是一个包含任意文件和顶层描述该包的`package.json`文件的目录。例如，当npm在目录`my-package/`中创建一个空包时，我们得到了这个`package.json`：'
- en: '[PRE31]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Some of these properties contain simple metadata:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些属性包含简单的元数据：
- en: '`name` specifies the name of this package. Once it is uploaded to the npm registry,
    it can be installed via `npm install my-package`.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`指定了这个包的名称。一旦上传到npm注册表，就可以通过`npm install my-package`进行安装。'
- en: '`version` is used for version management and follows [semantic versioning](https://semver.org),
    with three numbers:'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`用于版本管理，并遵循[语义化版本](https://semver.org)，有三个数字：'
- en: 'Major version: is incremented when incompatible API changes are made.'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要版本：当进行不兼容的API更改时递增。
- en: 'Minor version: is incremented when functionality is added in a backward compatible
    manner.'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 次要版本：在向后兼容的方式下添加功能时递增。
- en: 'Patch version: is incremented when backward compatible changes are made.'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补丁版本：在向后兼容的方式下进行更改时递增。
- en: '`description`, `keywords`, `author` make it easier to find packages.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`，`keywords`，`author`使得更容易找到包。'
- en: '`license` clarifies how we can use this package.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`license`澄清了我们如何使用这个包。'
- en: 'Other properties enable advanced configuration:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 其他属性使高级配置成为可能：
- en: '`main`: specifies the module that “is” the package (explained later in this
    chapter).'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main`：指定“是”包的模块（本章后面会解释）。'
- en: '`scripts`: are commands that we can execute via `npm run`. For example, the
    script `test` can be executed via `npm run test`.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scripts`：是我们可以通过`npm run`执行的命令。例如，可以通过`npm run test`执行脚本`test`。'
- en: For more information on `package.json`, consult [the npm documentation](https://docs.npmjs.com/files/package.json).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`package.json`的更多信息，请参阅[npm文档](https://docs.npmjs.com/files/package.json)。
- en: 27.9.1 Packages are installed inside a directory `node_modules/`
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.9.1 包被安装在目录`node_modules/`内
- en: 'npm always installs packages inside a directory `node_modules`. There are usually
    many of these directories. Which one npm uses, depends on the directory where
    one currently is. For example, if we are inside a directory `/tmp/a/b/`, npm tries
    to find a `node_modules` in the current directory, its parent directory, the parent
    directory of the parent, etc. In other words, it searches the following *chain*
    of locations:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: npm总是将包安装在`node_modules`目录中。通常会有许多这样的目录。npm使用哪一个取决于当前所在的目录。例如，如果我们在目录`/tmp/a/b/`中，npm会尝试在当前目录、其父目录、父目录的父目录等中找到`node_modules`。换句话说，它会搜索以下位置的*链*：
- en: '`/tmp/a/b/node_modules`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/tmp/a/b/node_modules`'
- en: '`/tmp/a/node_modules`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/tmp/a/node_modules`'
- en: '`/tmp/node_modules`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/tmp/node_modules`'
- en: 'When installing a package `some-pkg`, npm uses the closest `node_modules`.
    If, for example, we are inside `/tmp/a/b/` and there is a `node_modules` in that
    directory, then npm puts the package inside the directory:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装一个包`some-pkg`时，npm会使用最近的`node_modules`。例如，如果我们在`/tmp/a/b/`中，并且该目录中有一个`node_modules`，那么npm会将包放在该目录中：
- en: '[PRE32]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When importing a module, we can use a special module specifier to tell Node.js
    that we want to import it from an installed package. How exactly that works, is
    explained later. For now, consider the following example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入模块时，我们可以使用特殊的模块规范告诉Node.js我们想要从已安装的包中导入它。这是如何工作的，稍后会有解释。现在，考虑以下示例：
- en: '[PRE33]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To find `the-module.mjs` (Node.js prefers the filename extension `.mjs` for
    ES modules), Node.js walks up the `node_module` chain and searches the following
    locations:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找`the-module.mjs`（Node.js更喜欢使用文件扩展名`.mjs`来表示ES模块），Node.js会沿着`node_module`链向上查找以下位置：
- en: '`/home/jane/proj/node_modules/the-package/the-module.mjs`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/home/jane/proj/node_modules/the-package/the-module.mjs`'
- en: '`/home/jane/node_modules/the-package/the-module.mjs`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/home/jane/node_modules/the-package/the-module.mjs`'
- en: '`/home/node_modules/the-package/the-module.mjs`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/home/node_modules/the-package/the-module.mjs`'
- en: 27.9.2 Why can npm be used to install frontend libraries?
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.9.2 为什么可以使用npm来安装前端库？
- en: Finding installed modules in `node_modules` directories is only supported on
    Node.js. So why can we also use npm to install libraries for browsers?
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在`node_modules`目录中查找已安装的模块只在Node.js上受支持。那么为什么我们也可以使用npm来为浏览器安装库呢？
- en: That is enabled via [bundling tools](ch_remaining-chapters-site.html), such
    as webpack, that compile and optimize code before it is deployed online. During
    this compilation process, the code in npm packages is adapted so that it works
    in browsers.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过[打包工具](ch_remaining-chapters-site.html)（例如webpack）启用的，它会在部署到线上之前编译和优化代码。在这个编译过程中，npm包中的代码会被调整，以便在浏览器中运行。
- en: 27.10 Naming modules
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.10 命名模块
- en: There are no established best practices for naming module files and the variables
    they are imported into.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于命名模块文件和导入到其中的变量，没有已建立的最佳实践。
- en: 'In this chapter, I’m using the following naming style:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我使用以下命名风格：
- en: 'The names of module files are dash-cased and start with lowercase letters:'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块文件的名称是破折号命名，并以小写字母开头：
- en: '[PRE34]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The names of namespace imports are lowercased and camel-cased:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间导入的名称是小写和驼峰式命名：
- en: '[PRE35]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The names of default imports are lowercased and camel-cased:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认导入的名称是小写和驼峰式命名：
- en: '[PRE36]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: What are the rationales behind this style?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风格背后的原因是什么？
- en: 'npm doesn’t allow uppercase letters in package names ([source](https://docs.npmjs.com/files/package.json#name)).
    Thus, we avoid camel case, so that “local” files have names that are consistent
    with those of npm packages. Using only lowercase letters also minimizes conflicts
    between file systems that are case-sensitive and file systems that aren’t: the
    former distinguish files whose names have the same letters, but with different
    cases; the latter don’t.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: npm不允许包名中有大写字母（[来源](https://docs.npmjs.com/files/package.json#name)）。因此，我们避免驼峰命名，以使“本地”文件的名称与npm包的名称一致。仅使用小写字母也可以最小化大小写敏感和不敏感文件系统之间的冲突：前者区分具有相同字母但大小写不同的名称的文件；后者则不区分。
- en: There are clear rules for translating dash-cased file names to camel-cased JavaScript
    variable names. Due to how we name namespace imports, these rules work for both
    namespace imports and default imports.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有明确的规则将破折号命名的文件名转换为驼峰式的JavaScript变量名。由于我们命名命名空间导入的方式，这些规则适用于命名空间导入和默认导入。
- en: 'I also like underscore-cased module file names because we can directly use
    these names for namespace imports (without any translation):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我也喜欢使用下划线命名的模块文件名，因为我们可以直接使用这些名称进行命名空间导入（无需任何转换）：
- en: '[PRE37]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'But that style does not work for default imports: I like underscore-casing
    for namespace objects, but it is not a good choice for functions, etc.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这种风格对于默认导入不起作用：我喜欢使用下划线命名空间对象，但对于函数等来说并不是一个好选择。
- en: 27.11 Module specifiers
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.11 模块规范
- en: '*Module specifiers* are the strings that identify modules. They work slightly
    differently in browsers and Node.js. Before we can look at the differences, we
    need to learn about the different categories of module specifiers.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块规范*是用于标识模块的字符串。它们在浏览器和Node.js中有略微不同的工作方式。在我们看到区别之前，我们需要了解不同类别的模块规范。'
- en: 27.11.1 Categories of module specifiers
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.11.1 模块规范的类别
- en: In ES modules, we distinguish the following categories of specifiers. These
    categories originated with CommonJS modules.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES模块中，我们区分以下类别的规范。这些类别起源于CommonJS模块。
- en: 'Relative path: starts with a dot. Examples:'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对路径：以点开头。例如：
- en: '[PRE38]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Absolute path: starts with a slash. Example:'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绝对路径：以斜杠开头。例如：
- en: '[PRE39]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'URL: includes a protocol (technically, paths are URLs, too). Examples:'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL：包括协议（从技术上讲，路径也是URL）。例如：
- en: '[PRE40]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Bare path: does not start with a dot, a slash or a protocol, and consists of
    a single filename without an extension. Examples:'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 裸路径：不以点、斜杠或协议开头，由单个没有扩展名的文件名组成。例如：
- en: '[PRE41]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Deep import path: starts with a bare path and has at least one slash. Example:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深层导入路径：以裸路径开头，并且至少有一个斜杠。例如：
- en: '[PRE42]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 27.11.2 ES module specifiers in browsers
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.11.2 浏览器中的ES模块规范
- en: 'Browsers handle module specifiers as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器处理模块规范如下：
- en: Relative paths, absolute paths, and URLs work as expected. They all must point
    to real files (in contrast to CommonJS, which lets us omit filename extensions
    and more).
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对路径、绝对路径和URL都能按预期工作。它们都必须指向真实的文件（与CommonJS相反，它允许我们省略文件扩展名等）。
- en: The file name extensions of modules don’t matter, as long as they are served
    with the content type `text/javascript`.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的文件名扩展名并不重要，只要它们以`text/javascript`的内容类型提供即可。
- en: How bare paths will end up being handled is not yet clear. We will probably
    eventually be able to map them to other specifiers via lookup tables.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 裸路径最终将如何处理尚不清楚。我们可能最终能够通过查找表将它们映射到其他规范。
- en: Note that [bundling tools](ch_remaining-chapters-site.html) such as webpack,
    which combine modules into fewer files, are often less strict with specifiers
    than browsers. That’s because they operate at build/compile time (not at runtime)
    and can search for files by traversing the file system.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[打包工具](ch_remaining-chapters-site.html)（如webpack）将模块合并为较少的文件，通常对规范要求不那么严格。这是因为它们在构建/编译时操作（而不是在运行时），并且可以通过遍历文件系统来搜索文件。
- en: 27.11.3 ES module specifiers on Node.js
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.11.3 Node.js上的ES模块规范
- en: 'Node.js handles module specifiers as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js处理模块规范如下：
- en: Relative paths are resolved as they are in web browsers – relative to the path
    of the current module.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对路径会像在Web浏览器中一样解析 - 相对于当前模块的路径。
- en: Absolute paths are currently not supported. As a workaround, we can use URLs
    that start with `file:///`. We can create such URLs via [`url.pathToFileURL()`](ch_modules.html#converting-urls-paths).
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前不支持绝对路径。作为一种解决方法，我们可以使用以`file:///`开头的URL。我们可以通过[`url.pathToFileURL()`](ch_modules.html#converting-urls-paths)创建这样的URL。
- en: Only `file:` is supported as a protocol for URL specifiers.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只支持`file:`作为URL规范的协议。
- en: A bare path is interpreted as a package name and resolved relative to the closest
    `node_modules` directory. What module should be loaded, is determined by looking
    at property `"main"` of the package’s `package.json` (similarly to CommonJS).
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 裸路径被解释为包名，并相对于最近的`node_modules`目录进行解析。应该加载哪个模块是通过查看包的`package.json`的`"main"`属性来确定的（类似于CommonJS）。
- en: Deep import paths are also resolved relatively to the closest `node_modules`
    directory. They contain file names, so it is always clear which module is meant.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深层导入路径也相对于最近的`node_modules`目录进行解析。它们包含文件名，因此始终清楚指的是哪个模块。
- en: 'All specifiers, except bare paths, must refer to actual files. That is, ESM
    does not support the following CommonJS features:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 除了裸路径之外，所有的规范都必须指向实际的文件。也就是说，ESM不支持以下CommonJS特性：
- en: CommonJS automatically adds missing filename extensions.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CommonJS会自动添加丢失的文件扩展名。
- en: CommonJS can import a directory `dir` if there is a `dir/package.json` with
    a `"main"` property.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在带有`"main"`属性的`dir/package.json`，CommonJS可以导入目录`dir`。
- en: CommonJS can import a directory `dir` if there is a module `dir/index.js`.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在`dir/index.js`模块，CommonJS可以导入目录`dir`。
- en: 'All built-in Node.js modules are available via bare paths and have named ESM
    exports – for example:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 所有内置的Node.js模块都可以通过裸路径访问，并且具有命名的ESM导出 - 例如：
- en: '[PRE43]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 27.11.3.1 Filename extensions on Node.js
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 27.11.3.1 Node.js上的文件扩展名
- en: 'Node.js supports the following default filename extensions:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js支持以下默认的文件扩展名：
- en: '`.mjs` for ES modules'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.mjs`用于ES模块'
- en: '`.cjs` for CommonJS modules'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.cjs`用于CommonJS模块'
- en: The filename extension `.js` stands for either ESM or CommonJS. Which one it
    is is configured via the “closest” `package.json` (in the current directory, the
    parent directory, etc.). Using `package.json` in this manner is independent of
    packages.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 文件扩展名`.js`代表ESM或CommonJS。它是通过“最接近”的`package.json`（在当前目录、父目录等）配置的。使用这种方式的`package.json`与包是独立的。
- en: 'In that `package.json`, there is a property `"type"`, which has two settings:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`中，有一个`"type"`属性，它有两个设置：
- en: '`"commonjs"` (the default): files with the extension `.js` or without an extension
    are interpreted as CommonJS modules.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"commonjs"`（默认）：具有扩展名`.js`或没有扩展名的文件被解释为CommonJS模块。'
- en: '`"module"`: files with the extension `.js` or without an extension are interpreted
    as ESM modules.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"module"`：具有扩展名`.js`或没有扩展名的文件被解释为ESM模块。'
- en: 27.11.3.2 Interpreting non-file source code as either CommonJS or ESM
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 27.11.3.2 将非文件源代码解释为CommonJS或ESM
- en: 'Not all source code executed by Node.js comes from files. We can also send
    it code via stdin, `--eval`, and `--print`. The command line option `--input-type`
    lets us specify how such code is interpreted:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js执行的并非所有源代码都来自文件。我们也可以通过stdin、`--eval`和`--print`向其发送代码。命令行选项`--input-type`让我们指定如何解释这样的代码：
- en: 'As CommonJS (the default): `--input-type=commonjs`'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为CommonJS（默认）：`--input-type=commonjs`
- en: 'As ESM: `--input-type=module`'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为ESM：`--input-type=module`
- en: 27.12 `import.meta` – metadata for the current module [ES2020]
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.12 `import.meta` - 当前模块的元数据[ES2020]
- en: The object `import.meta` holds metadata for the current module.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 对象`import.meta`保存了当前模块的元数据。
- en: 27.12.1 `import.meta.url`
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.12.1 `import.meta.url`
- en: 'The most important property of `import.meta` is `.url` which contains a string
    with the URL of the current module’s file – for example:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`import.meta`最重要的属性是`.url`，其中包含当前模块文件的URL字符串 - 例如：'
- en: '[PRE44]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 27.12.2 `import.meta.url` and class `URL`
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.12.2 `import.meta.url`和类`URL`
- en: 'Class `URL` is available via a global variable in browsers and on Node.js.
    We can look up its full functionality in [the Node.js documentation](https://nodejs.org/api/url.html#url_class_url).
    When working with `import.meta.url`, its constructor is especially useful:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器和Node.js中，类`URL`可以通过全局变量访问。我们可以在[Node.js文档](https://nodejs.org/api/url.html#url_class_url)中查找其完整功能。在使用`import.meta.url`时，它的构造函数特别有用：
- en: '[PRE45]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Parameter `input` contains the URL to be parsed. It can be relative if the second
    parameter, `base`, is provided.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`input`包含要解析的URL。如果提供了第二个参数`base`，它可以是相对的。
- en: 'In other words, this constructor lets us resolve a relative path against a
    base URL:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这个构造函数让我们根据基本URL解析相对路径：
- en: '[PRE46]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is how we get a `URL` instance that points to a file `data.txt` that sits
    next to the current module:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何获得一个指向与当前模块相邻的文件`data.txt`的`URL`实例：
- en: '[PRE47]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 27.12.3 `import.meta.url` on Node.js
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.12.3 Node.js上的`import.meta.url`
- en: 'On Node.js, `import.meta.url` is always a string with a `file:` URL – for example:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js上，`import.meta.url`始终是一个带有`file:` URL的字符串 - 例如：
- en: '[PRE48]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '27.12.3.1 Example: reading a sibling file of a module'
  id: totrans-332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 27.12.3.1 示例：读取模块的同级文件
- en: 'Many Node.js file system operations accept either strings with paths or instances
    of `URL`. That enables us to read a sibling file `data.txt` of the current module:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Node.js文件系统操作接受路径字符串或`URL`实例。这使我们能够读取当前模块的同级文件`data.txt`：
- en: '[PRE49]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 27.12.3.2 Module `fs` and URLs
  id: totrans-335
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 27.12.3.2 模块`fs`和URL
- en: 'For most functions of the module `fs`, we can refer to files via:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模块`fs`的大多数函数，我们可以通过以下方式引用文件：
- en: Paths – in strings or instances of `Buffer`.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径 - 以字符串或`Buffer`实例的形式。
- en: URLs – in instances of `URL` (with the protocol `file:`)
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL - 在`URL`实例中（使用协议`file:`）
- en: For more information on this topic, see [the Node.js API documentation](https://nodejs.org/api/fs.html#fs_file_paths).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此主题的更多信息，请参阅[Node.js API文档](https://nodejs.org/api/fs.html#fs_file_paths)。
- en: 27.12.3.3 Converting between `file:` URLs and paths
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 27.12.3.3 在`file:` URL和路径之间转换
- en: '[The Node.js module `url`](https://nodejs.org/api/url.html) has two functions
    for converting between `file:` URLs and paths:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '[Node.js模块`url`](https://nodejs.org/api/url.html)有两个函数用于在`file:` URL和路径之间转换：'
- en: '`fileURLToPath(url: URL|string): string`'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileURLToPath(url: URL|string): string`'
- en: Converts a `file:` URL to a path.
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将`file:` URL转换为路径。
- en: '`pathToFileURL(path: string): URL`'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pathToFileURL(path: string): URL`'
- en: Converts a path to a `file:` URL.
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将路径转换为`file:` URL。
- en: 'If we need a path that can be used in the local file system, then property
    `.pathname` of `URL` instances does not always work:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要一个可以在本地文件系统中使用的路径，那么`URL`实例的`.pathname`属性并不总是有效：
- en: '[PRE50]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Therefore, it is better to use `fileURLToPath()`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好使用`fileURLToPath()`：
- en: '[PRE51]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Similarly, `pathToFileURL()` does more than just prepend `'file://'` to an absolute
    path.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`pathToFileURL()`不仅仅是在绝对路径前面添加`'file://'`。
- en: 27.13 Loading modules dynamically via `import()` [ES2020] (advanced)
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.13 通过`import()`动态加载模块[ES2020]（高级）
- en: '![](../Images/ec8e6930fbe484fc519f3aa7b812c3fd.png)  **The `import()` operator
    uses Promises**'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/ec8e6930fbe484fc519f3aa7b812c3fd.png) **`import()`操作符使用Promises**'
- en: Promises are a technique for handling results that are computed asynchronously
    (i.e., not immediately). They are explained in [§40 “Promises for asynchronous
    programming [ES6]”](ch_promises.html). It may make sense to postpone reading this
    section until you understand them.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Promises是一种处理异步计算结果的技术（即不是立即计算的）。它们在[§40“Promises for asynchronous programming
    [ES6]”](ch_promises.html)中有解释。在理解它们之前，推迟阅读本节可能是有意义的。
- en: 27.13.1 The limitations of static `import` statements
  id: totrans-354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.13.1 静态`import`语句的限制
- en: 'So far, the only way to import a module has been via an `import` statement.
    That statement has several limitations:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，导入模块的唯一方法是通过`import`语句。该语句有几个限制：
- en: We must use it at the top level of a module. That is, we can’t, for example,
    import something when we are inside a function or inside an `if` statement.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须在模块的顶层使用它。也就是说，我们不能在函数内部或`if`语句内部导入某些东西。
- en: The module specifier is always fixed. That is, we can’t change what we import
    depending on a condition. And we can’t assemble a specifier dynamically.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块标识符是固定的。也就是说，我们不能根据条件改变导入的内容。我们也不能动态组装一个标识符。
- en: 27.13.2 Dynamic imports via the `import()` operator
  id: totrans-358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.13.2 通过`import()`操作符动态导入
- en: 'The `import()` operator doesn’t have the limitations of `import` statements.
    It looks like this:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`import()`操作符没有`import`语句的限制。它看起来像这样：'
- en: '[PRE52]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This operator is used like a function, receives a string with a module specifier
    and returns a Promise that resolves to a namespace object. The properties of that
    object are the exports of the imported module.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符像一个函数一样使用，接收一个带有模块标识符的字符串，并返回一个解析为命名空间对象的Promise。该对象的属性是导入模块的导出。
- en: '`import()` is even more convenient to use via [`await`](ch_async-functions.html):'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 通过[`await`](ch_async-functions.html)来使用`import()`更加方便：
- en: '[PRE53]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that `await` can be used at the top levels of modules (see [next section](ch_modules.html#top-level-await)).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`await`可以在模块的顶层使用（参见[下一节](ch_modules.html#top-level-await)）。
- en: Let’s look at an example of using `import()`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用`import()`的例子。
- en: '27.13.2.1 Example: loading a module dynamically'
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 27.13.2.1 示例：动态加载模块
- en: 'Consider the following files:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下文件：
- en: '[PRE54]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We have already seen module `my-math.mjs`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了模块`my-math.mjs`：
- en: '[PRE55]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can use `import()` to load this module on demand:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`import()`按需加载这个模块：
- en: '[PRE56]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Two things in this code can’t be done with `import` statements:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中有两件事是无法通过`import`语句完成的：
- en: We are importing inside a function (not at the top level).
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在函数内部导入（而不是在顶层）。
- en: The module specifier comes from a variable.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块标识符来自一个变量。
- en: Next, we’ll implement the same functionality as in `main1.mjs` but via a feature
    called [*async function* or *async/await*](ch_async-functions.html) which provides
    nicer syntax for Promises.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现与`main1.mjs`中相同的功能，但通过一个称为[*async function*或*async/await*](ch_async-functions.html)的特性来实现，它为Promises提供了更好的语法。
- en: '[PRE57]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![](../Images/4e01a86e5fc2028470dca44da5c2d2aa.png)  **Why is `import()` an
    operator and not a function?**'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/4e01a86e5fc2028470dca44da5c2d2aa.png) **为什么`import()`是一个操作符而不是一个函数？**'
- en: '`import()` looks like a function but couldn’t be implemented as a function:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`import()`看起来像一个函数，但不能作为一个函数实现：'
- en: It needs to know the URL of the current module in order to resolve relative
    module specifiers.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要知道当前模块的URL以解析相对模块标识符。
- en: If `import()` were a function, we’d have to explicitly pass this information
    to it (e.g. via an parameter).
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`import()`是一个函数，我们必须明确地将这些信息传递给它（例如通过参数）。
- en: In contrast, an operator is a core language construct and has implicit access
    to more data, including the URL of the current module.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相比之下，操作符是一种核心语言构造，并且隐式访问更多数据，包括当前模块的URL。
- en: 27.13.3 Use cases for `import()`
  id: totrans-383
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.13.3 `import()`的用例
- en: 27.13.3.1 Loading code on demand
  id: totrans-384
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 27.13.3.1 按需加载代码
- en: 'Some functionality of web apps doesn’t have to be present when they start,
    it can be loaded on demand. Then `import()` helps because we can put such functionality
    into modules – for example:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序的一些功能在启动时不必存在，可以按需加载。然后`import()`有所帮助，因为我们可以将这样的功能放入模块中 - 例如：
- en: '[PRE58]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 27.13.3.2 Conditional loading of modules
  id: totrans-387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 27.13.3.2 模块的条件加载
- en: 'We may want to load a module depending on whether a condition is true. For
    example, a module with [a polyfill](ch_modules.html#polyfills) that makes a new
    feature available on legacy platforms:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望根据条件是否为真来加载一个模块。例如，具有[Polyfill](ch_modules.html#polyfills)的模块可以在旧平台上提供新功能：
- en: '[PRE59]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 27.13.3.3 Computed module specifiers
  id: totrans-390
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 27.13.3.3 计算模块规范
- en: 'For applications such as internationalization, it helps if we can dynamically
    compute module specifiers:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 对于国际化等应用程序，如果我们可以动态计算模块规范，这将有所帮助：
- en: '[PRE60]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 27.14 Top-level `await` in modules [ES2022] (advanced)
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.14 模块中的顶层`await` [ES2022]（高级）
- en: '![](../Images/ec8e6930fbe484fc519f3aa7b812c3fd.png)  **`await` is a feature
    of async functions**'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/ec8e6930fbe484fc519f3aa7b812c3fd.png)  **`await`是异步函数的一个特性**'
- en: '`await` is explained in [§41 “Async functions”](ch_async-functions.html). It
    may make sense to postpone reading this section until you understand async functions.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`await`在[§41“异步函数”](ch_async-functions.html)中有解释。在理解异步函数之前，推迟阅读本节可能是有意义的。'
- en: We can use the `await` operator at the top level of a module. If we do that,
    the module becomes asynchronous and works differently. Thankfully, we don’t usually
    see that as programmers because it is handled transparently by the language.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在模块的顶层使用`await`运算符。如果这样做，模块将变成异步的，并且工作方式会有所不同。幸运的是，我们通常不会作为程序员看到这一点，因为语言会透明地处理它。
- en: 27.14.1 Use cases for top-level `await`
  id: totrans-397
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.14.1 顶层`await`的用例
- en: Why would we want to use the `await` operator at the top level of a module?
    It lets us initialize a module with asynchronously loaded data. The next three
    subsections show three examples of where that is useful.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们希望在模块的顶层使用`await`运算符？它让我们可以使用异步加载的数据初始化模块。接下来的三个小节展示了这种用法的三个例子。
- en: 27.14.1.1 Loading modules dynamically
  id: totrans-399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 27.14.1.1 动态加载模块
- en: '[PRE61]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In line A, we [dynamically import](ch_modules.html#dynamic-imports) a module.
    Thanks to top-level `await`, that is almost as convenient as using a normal, static
    import.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在A行，我们[动态导入](ch_modules.html#dynamic-imports)一个模块。由于顶层`await`，这几乎和使用普通的静态导入一样方便。
- en: 27.14.1.2 Using a fallback if module loading fails
  id: totrans-402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 27.14.1.2 在模块加载失败时使用备用
- en: '[PRE62]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 27.14.1.3 Using whichever resource loads fastest
  id: totrans-404
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 27.14.1.3 使用加载最快的资源
- en: '[PRE63]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Due to [`Promise.any()`](ch_promises.html#Promise.any-AggregateError), variable
    `resource` is initialized via whichever download finishes first.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 由于[`Promise.any()`](ch_promises.html#Promise.any-AggregateError)，变量`resource`是通过任何首次完成的下载进行初始化。
- en: 27.14.2 How does top-level `await` work under the hood?
  id: totrans-407
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.14.2 顶层`await`在底层是如何工作的？
- en: Consider the following two files.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下两个文件。
- en: '`first.mjs`:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`first.mjs`：'
- en: '[PRE64]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`main.mjs`:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.mjs`：'
- en: '[PRE65]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Both are roughly equivalent to the following code:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 两者大致等同于以下代码：
- en: '`first.mjs`:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`first.mjs`：'
- en: '[PRE66]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`main.mjs`:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.mjs`：'
- en: '[PRE67]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'A module becomes asynchronous if:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果：
- en: It directly uses top-level `await` (`first.mjs`).
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它直接使用顶层`await`（`first.mjs`）。
- en: It imports one or more asynchronous modules (`main.mjs`).
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它导入一个或多个异步模块（`main.mjs`）。
- en: Each asynchronous module exports a Promise (line A and line B) that is fulfilled
    after its body was executed. At that point, it is safe to access the exports of
    that module.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 每个异步模块都导出一个Promise（A行和B行），在其主体执行后实现。在这一点上，安全地访问该模块的导出。
- en: In case (2), the importing module waits until the Promises of all imported asynchronous
    modules are fulfilled, before it enters its body (line C). Synchronous modules
    are handled as usually.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在情况（2）中，导入模块会等待所有导入的异步模块的Promise被实现，然后再进入其主体（C行）。同步模块则像通常一样处理。
- en: Awaited rejections and synchronous exceptions are managed as in async functions.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 等待的拒绝和同步异常的处理方式与异步函数中的处理方式相同。
- en: 27.14.3 The pros and cons of top-level `await`
  id: totrans-424
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.14.3 顶层`await`的利弊
- en: 'The two most important benefits of top-level `await` are:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层`await`的两个最重要的好处是：
- en: It ensures that modules don’t access asynchronous imports before they are fully
    initialized.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它确保模块在完全初始化之前不会访问异步导入。
- en: 'It handles asynchronicity transparently: Importers do not need to know if an
    imported module is asynchronous or not.'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它透明地处理异步性：导入者不需要知道导入的模块是异步的还是同步的。
- en: On the downside, top-level `await` delays the initialization of importing modules.
    Therefore, it‘s best used sparingly. Asynchronous tasks that take longer are better
    performed later, on demand.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，顶层`await`延迟了导入模块的初始化。因此，最好是谨慎使用。需要更长时间的异步任务最好稍后执行。
- en: However, even modules without top-level `await` can block importers (e.g. via
    an infinite loop at the top level), so blocking per se is not an argument against
    it.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使没有顶层`await`的模块也可能阻止导入者（例如在顶层的无限循环中），因此阻塞本身并不是反对它的论点。
- en: '27.15 Polyfills: emulating native web platform features (advanced)'
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 27.15 Polyfills：模拟原生Web平台功能（高级）
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **Backends have polyfills,
    too**'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **后端也有Polyfills**'
- en: This section is about frontend development and web browsers, but similar ideas
    apply to backend development.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是关于前端开发和Web浏览器，但类似的想法也适用于后端开发。
- en: '*Polyfills* help with a conflict that we are facing when developing a web application
    in JavaScript:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '*Polyfills*有助于解决我们在JavaScript中开发Web应用程序时面临的冲突：'
- en: On one hand, we want to use modern web platform features that make the app better
    and/or development easier.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一方面，我们希望使用使应用程序更好和/或开发更容易的现代Web平台功能。
- en: On the other hand, the app should run on as many browsers as possible.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，应用程序应该在尽可能多的浏览器上运行。
- en: 'Given a web platform feature X:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个Web平台功能X：
- en: A *polyfill* for X is a piece of code. If it is executed on a platform that
    already has built-in support for X, it does nothing. Otherwise, it makes the feature
    available on the platform. In the latter case, the polyfilled feature is (mostly)
    indistinguishable from a native implementation. In order to achieve that, the
    polyfill usually makes global changes. For example, it may modify global data
    or configure a global module loader. Polyfills are often packaged as modules.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X的*polyfill*是一段代码。如果它在已经内置对X的支持的平台上执行，它什么也不做。否则，它会在平台上提供该功能。在后一种情况下，polyfilled功能（大多数情况下）与本机实现几乎无法区分。为了实现这一点，polyfill通常会进行全局更改。例如，它可能修改全局数据或配置全局模块加载器。Polyfills通常打包为模块。
- en: The term [*polyfill*](https://remysharp.com/2010/10/08/what-is-a-polyfill) was
    coined by Remy Sharp.
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 术语[*polyfill*](https://remysharp.com/2010/10/08/what-is-a-polyfill)是由Remy Sharp创造的。
- en: A *speculative polyfill* is a polyfill for a proposed web platform feature (that
    is not standardized, yet).
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*推测性polyfill*是针对提议的Web平台功能的polyfill（尚未标准化）。'
- en: 'Alternative term: *prollyfill*'
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替代术语：*prollyfill*
- en: A *replica* of X is a library that reproduces the API and functionality of X
    locally. Such a library exists independently of a native (and global) implementation
    of X.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X的*复制品*是一个在本地复制X的API和功能的库。这样的库独立于X的本机（和全局）实现。
- en: '*Replica* is a new term introduced in this section. Alternative term: *ponyfill*'
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*复制品*是本节中引入的一个新术语。替代术语：*ponyfill*'
- en: There is also the term *shim*, but it doesn’t have a universally agreed upon
    definition. It often means roughly the same as *polyfill*.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有一个术语*shim*，但它没有一个普遍认可的定义。它通常意思大致相同于*polyfill*。
- en: Every time our web applications starts, it must first execute all polyfills
    for features that may not be available everywhere. Afterwards, we can be sure
    that those features are available natively.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们的Web应用程序启动时，它必须首先执行所有可能不是在所有地方都可用的功能的polyfills。之后，我们可以确保这些功能在本地是可用的。
- en: 27.15.1 Sources of this section
  id: totrans-445
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 27.15.1 本节的来源
- en: '[“What is a Polyfill?”](https://remysharp.com/2010/10/08/what-is-a-polyfill)
    by Remy Sharp'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“什么是Polyfill？”](https://remysharp.com/2010/10/08/what-is-a-polyfill) by Remy
    Sharp'
- en: 'Inspiration for the term *replica*: [The Eiffel Tower in Las Vegas](https://en.wikipedia.org/wiki/Paris_Las_Vegas)'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*复制品*这个术语的灵感来源：[拉斯维加斯的埃菲尔铁塔](https://en.wikipedia.org/wiki/Paris_Las_Vegas)'
- en: 'Useful clarification of “polyfill” and related terms: [“Polyfills and the evolution
    of the Web”](https://www.w3.org/2001/tag/doc/polyfills/). Edited by Andrew Betts.'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用的澄清“polyfill”和相关术语：[“Polyfills and the evolution of the Web”](https://www.w3.org/2001/tag/doc/polyfills/)。由Andrew
    Betts编辑。
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz**'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png) **测验**'
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[测验应用程序](ch_quizzes-exercises.html#quizzes)。
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/20)'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '[评论](https://github.com/rauschma/impatient-js/issues/20)'
