- en: 27 Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/impatient-js/ch_modules.html](https://exploringjs.com/impatient-js/ch_modules.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '27.1 [Cheat sheet: modules](ch_modules.html#cheat-sheet-modules)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.1.1 [Exporting](ch_modules.html#module-exports)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.1.2 [Importing](ch_modules.html#importing)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.2 [JavaScript source code formats](ch_modules.html#javascript-source-code-formats)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.2.1 [Code before built-in modules was written in ECMAScript 5](ch_modules.html#code-before-built-in-modules-was-written-in-ecmascript-5)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.3 [Before we had modules, we had scripts](ch_modules.html#scripts)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.4 [Module systems created prior to ES6](ch_modules.html#module-systems-created-prior-to-es6)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '27.4.1 [Server side: CommonJS modules](ch_modules.html#server-side-commonjs-modules)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '27.4.2 [Client side: AMD (Asynchronous Module Definition) modules](ch_modules.html#client-side-amd-asynchronous-module-definition-modules)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.4.3 [Characteristics of JavaScript modules](ch_modules.html#characteristics-of-javascript-modules)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.5 [ECMAScript modules](ch_modules.html#ecmascript-modules)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '27.5.1 [ES modules: syntax, semantics, loader API](ch_modules.html#es-modules-syntax-semantics-loader-api)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.6 [Named exports and imports](ch_modules.html#named-exports-and-imports)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.6.1 [Named exports](ch_modules.html#named-exports)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.6.2 [Named imports](ch_modules.html#named-imports)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.6.3 [Namespace imports](ch_modules.html#namespace-imports)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '27.6.4 [Named exporting styles: inline versus clause (advanced)](ch_modules.html#named-exporting-styles-inline-versus-clause-advanced)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.7 [Default exports and imports](ch_modules.html#default-exports-and-imports)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.7.1 [The two styles of default-exporting](ch_modules.html#the-two-styles-of-default-exporting)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.7.2 [The default export as a named export (advanced)](ch_modules.html#the-default-export-as-a-named-export-advanced)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.8 [More details on exporting and importing](ch_modules.html#more-details-on-exporting-and-importing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.8.1 [Imports are read-only views on exports](ch_modules.html#imports-are-read-only-views-on-exports)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.8.2 [ESM’s transparent support for cyclic imports (advanced)](ch_modules.html#esms-transparent-support-for-cyclic-imports-advanced)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.9 [npm packages](ch_modules.html#npm-packages)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.9.1 [Packages are installed inside a directory `node_modules/`](ch_modules.html#packages-are-installed-inside-a-directory-node_modules)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.9.2 [Why can npm be used to install frontend libraries?](ch_modules.html#why-can-npm-be-used-to-install-frontend-libraries)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.10 [Naming modules](ch_modules.html#naming-modules)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.11 [Module specifiers](ch_modules.html#module-specifiers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.11.1 [Categories of module specifiers](ch_modules.html#categories-of-module-specifiers)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.11.2 [ES module specifiers in browsers](ch_modules.html#es-module-specifiers-in-browsers)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.11.3 [ES module specifiers on Node.js](ch_modules.html#es-module-specifiers-on-node.js)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.12 [`import.meta` – metadata for the current module [ES2020]](ch_modules.html#import.meta)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.12.1 [`import.meta.url`](ch_modules.html#import.meta.url)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.12.2 [`import.meta.url` and class `URL`](ch_modules.html#import.meta.url-and-class-url)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.12.3 [`import.meta.url` on Node.js](ch_modules.html#import.meta.url-on-node.js)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.13 [Loading modules dynamically via `import()` [ES2020] (advanced)](ch_modules.html#dynamic-imports)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.13.1 [The limitations of static `import` statements](ch_modules.html#the-limitations-of-static-import-statements)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.13.2 [Dynamic imports via the `import()` operator](ch_modules.html#dynamic-imports-via-the-import-operator)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.13.3 [Use cases for `import()`](ch_modules.html#use-cases-for-import)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.14 [Top-level `await` in modules [ES2022] (advanced)](ch_modules.html#top-level-await)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.14.1 [Use cases for top-level `await`](ch_modules.html#use-cases-for-top-level-await)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.14.2 [How does top-level `await` work under the hood?](ch_modules.html#how-does-top-level-await-work-under-the-hood)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.14.3 [The pros and cons of top-level `await`](ch_modules.html#the-pros-and-cons-of-top-level-await)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '27.15 [Polyfills: emulating native web platform features (advanced)](ch_modules.html#polyfills)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.15.1 [Sources of this section](ch_modules.html#sources-of-this-section)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '27.1 Cheat sheet: modules'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 27.1.1 Exporting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 27.1.2 Importing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 27.2 JavaScript source code formats
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The current landscape of JavaScript modules is quite diverse: ES6 brought built-in
    modules, but the source code formats that came before them, are still around,
    too. Understanding the latter helps understand the former, so let’s investigate.
    The next sections describe the following ways of delivering JavaScript source
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Scripts* are code fragments that browsers run in global scope. They are precursors
    of modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CommonJS modules* are a module format that is mainly used on servers (e.g.,
    via Node.js).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*AMD modules* are a module format that is mainly used in browsers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ECMAScript modules* are JavaScript’s built-in module format. It supersedes
    all previous formats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tbl. [18](#tbl:source-code-formats) gives an overview of these code formats.
    Note that for CommonJS modules and ECMAScript modules, two filename extensions
    are commonly used. Which one is appropriate depends on how we want to use a file.
    Details are given later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 18: Ways of delivering JavaScript source code.'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Runs on | Loaded | Filename ext. |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Script | browsers | async | `.js` |'
  prefs: []
  type: TYPE_TB
- en: '| CommonJS module | servers | sync | `.js .cjs` |'
  prefs: []
  type: TYPE_TB
- en: '| AMD module | browsers | async | `.js` |'
  prefs: []
  type: TYPE_TB
- en: '| ECMAScript module | browsers and servers | async | `.js .mjs` |'
  prefs: []
  type: TYPE_TB
- en: 27.2.1 Code before built-in modules was written in ECMAScript 5
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we get to built-in modules (which were introduced with ES6), all code
    that we’ll see, will be written in ES5\. Among other things:'
  prefs: []
  type: TYPE_NORMAL
- en: ES5 did not have `const` and `let`, only `var`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES5 did not have arrow functions, only function expressions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.3 Before we had modules, we had scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Initially, browsers only had *scripts* – pieces of code that were executed
    in global scope. As an example, consider an HTML file that loads script files
    via the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The main file is `my-module.js`, where we simulate a module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`myModule` is a global variable that is assigned the result of immediately
    invoking a function expression. The function expression starts in the first line.
    It is invoked in the last line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This way of wrapping a code fragment is called *immediately invoked function
    expression* (IIFE, coined by Ben Alman). What do we gain from an IIFE? `var` is
    not block-scoped (like `const` and `let`), it is function-scoped: the only way
    to create new scopes for `var`-declared variables is via functions or methods
    (with `const` and `let`, we can use either functions, methods, or blocks `{}`).
    Therefore, the IIFE in the example hides all of the following variables from global
    scope and minimizes name clashes: `importedFunc1`, `importedFunc2`, `internalFunc`,
    `exportedFunc`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we are using an IIFE in a particular manner: at the end, we pick
    what we want to export and return it via an object literal. That is called the
    *revealing module pattern* (coined by Christian Heilmann).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This way of simulating modules, has several issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Libraries in script files export and import functionality via global variables,
    which risks name clashes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies are not stated explicitly, and there is no built-in way for a script
    to load the scripts it depends on. Therefore, the web page has to load not just
    the scripts that are needed by the page but also the dependencies of those scripts,
    the dependencies’ dependencies, etc. And it has to do so in the right order!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.4 Module systems created prior to ES6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Prior to ECMAScript 6, JavaScript did not have built-in modules. Therefore,
    the flexible syntax of the language was used to implement custom module systems
    *within* the language. Two popular ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: CommonJS (targeting the server side)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AMD (Asynchronous Module Definition, targeting the client side)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '27.4.1 Server side: CommonJS modules'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The original CommonJS standard for modules was created for server and desktop
    platforms. It was the foundation of the original Node.js module system, where
    it achieved enormous popularity. Contributing to that popularity were the npm
    package manager for Node and tools that enabled using Node modules on the client
    side (browserify, webpack, and others).
  prefs: []
  type: TYPE_NORMAL
- en: 'From now on, *CommonJS module* means the Node.js version of this standard (which
    has a few additional features). This is an example of a CommonJS module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'CommonJS can be characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Designed for servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules are meant to be loaded *synchronously* (the importer waits while the
    imported module is loaded and executed).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compact syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '27.4.2 Client side: AMD (Asynchronous Module Definition) modules'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The AMD module format was created to be easier to use in browsers than the CommonJS
    format. Its most popular implementation is [RequireJS](https://requirejs.org).
    The following is an example of an AMD module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'AMD can be characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Designed for browsers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules are meant to be loaded *asynchronously*. That’s a crucial requirement
    for browsers, where code can’t wait until a module has finished downloading. It
    has to be notified once the module is available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The syntax is slightly more complicated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the plus side, AMD modules can be executed directly. In contrast, CommonJS
    modules must either be compiled before deployment or custom source code must be
    generated and evaluated dynamically [(think `eval()`)](ch_dynamic-code-evaluation.html#eval).
    That isn’t always permitted on the web.
  prefs: []
  type: TYPE_NORMAL
- en: 27.4.3 Characteristics of JavaScript modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Looking at CommonJS and AMD, similarities between JavaScript module systems
    emerge:'
  prefs: []
  type: TYPE_NORMAL
- en: There is one module per file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Such a file is basically a piece of code that is executed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Local scope: The code is executed in a local “module scope”. Therefore, by
    default, all of the variables, functions, and classes declared in it are internal
    and not global.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exports: If we want any declared entity to be exported, we must explicitly
    mark it as an export.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Imports: Each module can import exported entities from other modules. Those
    other modules are identified via *module specifiers* (usually paths, occasionally
    full URLs).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Modules are *singletons*: Even if a module is imported multiple times, only
    a single “instance” of it exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No global variables are used. Instead, module specifiers serve as global IDs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.5 ECMAScript modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*ECMAScript modules* (*ES modules* or *ESM*) were introduced with ES6\. They
    continue the tradition of JavaScript modules and have all of their aforementioned
    characteristics. Additionally:'
  prefs: []
  type: TYPE_NORMAL
- en: With CommonJS, ES modules share the compact syntax and support for cyclic dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With AMD, ES modules share being designed for asynchronous loading.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES modules also have new benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is even more compact than CommonJS’s.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules have *static* structures (which can’t be changed at runtime). That helps
    with static checking, optimized access of imports, dead code elimination, and
    more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for cyclic imports is completely transparent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is an example of ES module syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: From now on, “module” means “ECMAScript module”.
  prefs: []
  type: TYPE_NORMAL
- en: '27.5.1 ES modules: syntax, semantics, loader API'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The full standard of ES modules comprises the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax (how code is written): What is a module? How are imports and exports
    declared? Etc.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Semantics (how code is executed): How are variable bindings exported? How are
    imports connected with exports? Etc.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A programmatic loader API for configuring module loading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parts 1 and 2 were introduced with ES6\. Work on part 3 is ongoing.
  prefs: []
  type: TYPE_NORMAL
- en: 27.6 Named exports and imports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 27.6.1 Named exports
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each module can have zero or more *named exports*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the following two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Module `my-math.mjs` has two named exports: `square` and `LIGHTSPEED`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To export something, we put the keyword `export` in front of a declaration.
    Entities that are not exported are private to a module and can’t be accessed from
    outside.
  prefs: []
  type: TYPE_NORMAL
- en: 27.6.2 Named imports
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Module `main.mjs` has a single named import, `square`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also rename its import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '27.6.2.1 Syntactic pitfall: named importing is not destructuring'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Both named importing and destructuring look similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'But they are quite different:'
  prefs: []
  type: TYPE_NORMAL
- en: Imports remain connected with their exports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can destructure again inside a destructuring pattern, but the `{}` in an
    import statement can’t be nested.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The syntax for renaming is different:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rationale: Destructuring is reminiscent of an object literal (including nesting),
    while importing evokes the idea of renaming.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Named exports**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/modules/export_named_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: 27.6.3 Namespace imports
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Namespace imports* are an alternative to named imports. If we namespace-import
    a module, it becomes an object whose properties are the named exports. This is
    what `main.mjs` looks like if we use a namespace import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '27.6.4 Named exporting styles: inline versus clause (advanced)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The named export style we have seen so far was *inline*: We exported entities
    by prefixing them with the keyword `export`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can also use separate *export clauses*. For example, this is what `lib/my-math.mjs`
    looks like with an export clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With an export clause, we can rename before exporting and use different names
    internally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 27.7 Default exports and imports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each module can have at most one *default export*. The idea is that the module
    *is* the default-exported value.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png)  **Avoid mixing named exports
    and default exports**'
  prefs: []
  type: TYPE_NORMAL
- en: A module can have both named exports and a default export, but it’s usually
    better to stick to one export style per module.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example for default exports, consider the following two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Module `my-func.mjs` has a default export:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Module `main.mjs` default-imports the exported function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the syntactic difference: the curly braces around named imports indicate
    that we are reaching *into* the module, while a default import *is* the module.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4e01a86e5fc2028470dca44da5c2d2aa.png)  **What are use cases for
    default exports?**'
  prefs: []
  type: TYPE_NORMAL
- en: The most common use case for a default export is a module that contains a single
    function or a single class.
  prefs: []
  type: TYPE_NORMAL
- en: 27.7.1 The two styles of default-exporting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are two styles of doing default exports.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can label existing declarations with `export default`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Second, we can directly default-export values. This style of `export default`
    is much like a declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 27.7.1.1 Why are there two default export styles?
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The reason is that `export default` can’t be used to label `const`: `const`
    may define multiple values, but `export default` needs exactly one value. Consider
    the following hypothetical code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With this code, we don’t know which one of the three values is the default export.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Default exports**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/modules/export_default_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: 27.7.2 The default export as a named export (advanced)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Internally, a default export is simply a named export whose name is `default`.
    As an example, consider the previous module `my-func.mjs` with a default export:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following module `my-func2.mjs` is equivalent to that module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'For importing, we can use a normal default import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can use a named import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The default export is also available via property `.default` of namespace imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/4e01a86e5fc2028470dca44da5c2d2aa.png)  **Isn’t `default` illegal
    as a variable name?**'
  prefs: []
  type: TYPE_NORMAL
- en: '`default` can’t be a variable name, but it can be an export name and it can
    be a property name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 27.8 More details on exporting and importing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 27.8.1 Imports are read-only views on exports
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far, we have used imports and exports intuitively, and everything seems to
    have worked as expected. But now it is time to take a closer look at how imports
    and exports are really related.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following two modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`counter.mjs` exports a (mutable!) variable and a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`main.mjs` name-imports both exports. When we use `incCounter()`, we discover
    that the connection to `counter` is live – we can always access the live state
    of that variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that while the connection is live and we can read `counter`, we cannot
    change this variable (e.g., via `counter++`).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two benefits to handling imports this way:'
  prefs: []
  type: TYPE_NORMAL
- en: It is easier to split modules because previously shared variables can become
    exports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This behavior is crucial for supporting transparent cyclic imports. Read on
    for more information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.8.2 ESM’s transparent support for cyclic imports (advanced)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'ESM supports cyclic imports transparently. To understand how that is achieved,
    consider the following example: fig. [7](#fig:module-imports) shows a directed
    graph of modules importing other modules. P importing M is the cycle in this case.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7: A directed graph of modules importing modules: M imports N and
    O, N imports P and Q, etc.](../Images/36a86530c92f02bc0545c60194aa676d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: A directed graph of modules importing modules: M imports N and O,
    N imports P and Q, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After parsing, these modules are set up in two phases:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instantiation: Every module is visited and its imports are connected to its
    exports. Before a parent can be instantiated, all of its children must be instantiated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Evaluation: The bodies of the modules are executed. Once again, children are
    evaluated before parents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This approach handles cyclic imports correctly, due to two features of ES modules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the static structure of ES modules, the exports are already known after
    parsing. That makes it possible to instantiate P before its child M: P can already
    look up M’s exports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When P is evaluated, M hasn’t been evaluated, yet. However, entities in P can
    already mention imports from M. They just can’t use them, yet, because the imported
    values are filled in later. For example, a function in P can access an import
    from M. The only limitation is that we must wait until after the evaluation of
    M, before calling that function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imports being filled in later is enabled by them being “live immutable views”
    on exports.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 27.9 npm packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *npm software registry* is the dominant way of distributing JavaScript
    libraries and apps for Node.js and web browsers. It is managed via the *npm package
    manager* (short: *npm*). Software is distributed as so-called *packages*. A package
    is a directory containing arbitrary files and a file `package.json` at the top
    level that describes the package. For example, when npm creates an empty package
    inside a directory `my-package/`, we get this `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of these properties contain simple metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` specifies the name of this package. Once it is uploaded to the npm registry,
    it can be installed via `npm install my-package`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version` is used for version management and follows [semantic versioning](https://semver.org),
    with three numbers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Major version: is incremented when incompatible API changes are made.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Minor version: is incremented when functionality is added in a backward compatible
    manner.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Patch version: is incremented when backward compatible changes are made.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`, `keywords`, `author` make it easier to find packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`license` clarifies how we can use this package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other properties enable advanced configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`main`: specifies the module that “is” the package (explained later in this
    chapter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scripts`: are commands that we can execute via `npm run`. For example, the
    script `test` can be executed via `npm run test`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on `package.json`, consult [the npm documentation](https://docs.npmjs.com/files/package.json).
  prefs: []
  type: TYPE_NORMAL
- en: 27.9.1 Packages are installed inside a directory `node_modules/`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'npm always installs packages inside a directory `node_modules`. There are usually
    many of these directories. Which one npm uses, depends on the directory where
    one currently is. For example, if we are inside a directory `/tmp/a/b/`, npm tries
    to find a `node_modules` in the current directory, its parent directory, the parent
    directory of the parent, etc. In other words, it searches the following *chain*
    of locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/tmp/a/b/node_modules`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/tmp/a/node_modules`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/tmp/node_modules`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When installing a package `some-pkg`, npm uses the closest `node_modules`.
    If, for example, we are inside `/tmp/a/b/` and there is a `node_modules` in that
    directory, then npm puts the package inside the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When importing a module, we can use a special module specifier to tell Node.js
    that we want to import it from an installed package. How exactly that works, is
    explained later. For now, consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To find `the-module.mjs` (Node.js prefers the filename extension `.mjs` for
    ES modules), Node.js walks up the `node_module` chain and searches the following
    locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/home/jane/proj/node_modules/the-package/the-module.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/home/jane/node_modules/the-package/the-module.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/home/node_modules/the-package/the-module.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.9.2 Why can npm be used to install frontend libraries?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finding installed modules in `node_modules` directories is only supported on
    Node.js. So why can we also use npm to install libraries for browsers?
  prefs: []
  type: TYPE_NORMAL
- en: That is enabled via [bundling tools](ch_remaining-chapters-site.html), such
    as webpack, that compile and optimize code before it is deployed online. During
    this compilation process, the code in npm packages is adapted so that it works
    in browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 27.10 Naming modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are no established best practices for naming module files and the variables
    they are imported into.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I’m using the following naming style:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The names of module files are dash-cased and start with lowercase letters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The names of namespace imports are lowercased and camel-cased:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The names of default imports are lowercased and camel-cased:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What are the rationales behind this style?
  prefs: []
  type: TYPE_NORMAL
- en: 'npm doesn’t allow uppercase letters in package names ([source](https://docs.npmjs.com/files/package.json#name)).
    Thus, we avoid camel case, so that “local” files have names that are consistent
    with those of npm packages. Using only lowercase letters also minimizes conflicts
    between file systems that are case-sensitive and file systems that aren’t: the
    former distinguish files whose names have the same letters, but with different
    cases; the latter don’t.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are clear rules for translating dash-cased file names to camel-cased JavaScript
    variable names. Due to how we name namespace imports, these rules work for both
    namespace imports and default imports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I also like underscore-cased module file names because we can directly use
    these names for namespace imports (without any translation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'But that style does not work for default imports: I like underscore-casing
    for namespace objects, but it is not a good choice for functions, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: 27.11 Module specifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Module specifiers* are the strings that identify modules. They work slightly
    differently in browsers and Node.js. Before we can look at the differences, we
    need to learn about the different categories of module specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: 27.11.1 Categories of module specifiers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In ES modules, we distinguish the following categories of specifiers. These
    categories originated with CommonJS modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Relative path: starts with a dot. Examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Absolute path: starts with a slash. Example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'URL: includes a protocol (technically, paths are URLs, too). Examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Bare path: does not start with a dot, a slash or a protocol, and consists of
    a single filename without an extension. Examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Deep import path: starts with a bare path and has at least one slash. Example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 27.11.2 ES module specifiers in browsers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Browsers handle module specifiers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Relative paths, absolute paths, and URLs work as expected. They all must point
    to real files (in contrast to CommonJS, which lets us omit filename extensions
    and more).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file name extensions of modules don’t matter, as long as they are served
    with the content type `text/javascript`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How bare paths will end up being handled is not yet clear. We will probably
    eventually be able to map them to other specifiers via lookup tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that [bundling tools](ch_remaining-chapters-site.html) such as webpack,
    which combine modules into fewer files, are often less strict with specifiers
    than browsers. That’s because they operate at build/compile time (not at runtime)
    and can search for files by traversing the file system.
  prefs: []
  type: TYPE_NORMAL
- en: 27.11.3 ES module specifiers on Node.js
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Node.js handles module specifiers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Relative paths are resolved as they are in web browsers – relative to the path
    of the current module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Absolute paths are currently not supported. As a workaround, we can use URLs
    that start with `file:///`. We can create such URLs via [`url.pathToFileURL()`](ch_modules.html#converting-urls-paths).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only `file:` is supported as a protocol for URL specifiers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bare path is interpreted as a package name and resolved relative to the closest
    `node_modules` directory. What module should be loaded, is determined by looking
    at property `"main"` of the package’s `package.json` (similarly to CommonJS).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deep import paths are also resolved relatively to the closest `node_modules`
    directory. They contain file names, so it is always clear which module is meant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All specifiers, except bare paths, must refer to actual files. That is, ESM
    does not support the following CommonJS features:'
  prefs: []
  type: TYPE_NORMAL
- en: CommonJS automatically adds missing filename extensions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CommonJS can import a directory `dir` if there is a `dir/package.json` with
    a `"main"` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CommonJS can import a directory `dir` if there is a module `dir/index.js`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All built-in Node.js modules are available via bare paths and have named ESM
    exports – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 27.11.3.1 Filename extensions on Node.js
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Node.js supports the following default filename extensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.mjs` for ES modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.cjs` for CommonJS modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The filename extension `.js` stands for either ESM or CommonJS. Which one it
    is is configured via the “closest” `package.json` (in the current directory, the
    parent directory, etc.). Using `package.json` in this manner is independent of
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that `package.json`, there is a property `"type"`, which has two settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"commonjs"` (the default): files with the extension `.js` or without an extension
    are interpreted as CommonJS modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"module"`: files with the extension `.js` or without an extension are interpreted
    as ESM modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.11.3.2 Interpreting non-file source code as either CommonJS or ESM
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Not all source code executed by Node.js comes from files. We can also send
    it code via stdin, `--eval`, and `--print`. The command line option `--input-type`
    lets us specify how such code is interpreted:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As CommonJS (the default): `--input-type=commonjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As ESM: `--input-type=module`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.12 `import.meta` – metadata for the current module [ES2020]
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The object `import.meta` holds metadata for the current module.
  prefs: []
  type: TYPE_NORMAL
- en: 27.12.1 `import.meta.url`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The most important property of `import.meta` is `.url` which contains a string
    with the URL of the current module’s file – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 27.12.2 `import.meta.url` and class `URL`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Class `URL` is available via a global variable in browsers and on Node.js.
    We can look up its full functionality in [the Node.js documentation](https://nodejs.org/api/url.html#url_class_url).
    When working with `import.meta.url`, its constructor is especially useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Parameter `input` contains the URL to be parsed. It can be relative if the second
    parameter, `base`, is provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, this constructor lets us resolve a relative path against a
    base URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we get a `URL` instance that points to a file `data.txt` that sits
    next to the current module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 27.12.3 `import.meta.url` on Node.js
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On Node.js, `import.meta.url` is always a string with a `file:` URL – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '27.12.3.1 Example: reading a sibling file of a module'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Many Node.js file system operations accept either strings with paths or instances
    of `URL`. That enables us to read a sibling file `data.txt` of the current module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 27.12.3.2 Module `fs` and URLs
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For most functions of the module `fs`, we can refer to files via:'
  prefs: []
  type: TYPE_NORMAL
- en: Paths – in strings or instances of `Buffer`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URLs – in instances of `URL` (with the protocol `file:`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on this topic, see [the Node.js API documentation](https://nodejs.org/api/fs.html#fs_file_paths).
  prefs: []
  type: TYPE_NORMAL
- en: 27.12.3.3 Converting between `file:` URLs and paths
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[The Node.js module `url`](https://nodejs.org/api/url.html) has two functions
    for converting between `file:` URLs and paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fileURLToPath(url: URL|string): string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converts a `file:` URL to a path.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`pathToFileURL(path: string): URL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converts a path to a `file:` URL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we need a path that can be used in the local file system, then property
    `.pathname` of `URL` instances does not always work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, it is better to use `fileURLToPath()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, `pathToFileURL()` does more than just prepend `'file://'` to an absolute
    path.
  prefs: []
  type: TYPE_NORMAL
- en: 27.13 Loading modules dynamically via `import()` [ES2020] (advanced)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](../Images/ec8e6930fbe484fc519f3aa7b812c3fd.png)  **The `import()` operator
    uses Promises**'
  prefs: []
  type: TYPE_NORMAL
- en: Promises are a technique for handling results that are computed asynchronously
    (i.e., not immediately). They are explained in [§40 “Promises for asynchronous
    programming [ES6]”](ch_promises.html). It may make sense to postpone reading this
    section until you understand them.
  prefs: []
  type: TYPE_NORMAL
- en: 27.13.1 The limitations of static `import` statements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far, the only way to import a module has been via an `import` statement.
    That statement has several limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: We must use it at the top level of a module. That is, we can’t, for example,
    import something when we are inside a function or inside an `if` statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The module specifier is always fixed. That is, we can’t change what we import
    depending on a condition. And we can’t assemble a specifier dynamically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.13.2 Dynamic imports via the `import()` operator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `import()` operator doesn’t have the limitations of `import` statements.
    It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This operator is used like a function, receives a string with a module specifier
    and returns a Promise that resolves to a namespace object. The properties of that
    object are the exports of the imported module.
  prefs: []
  type: TYPE_NORMAL
- en: '`import()` is even more convenient to use via [`await`](ch_async-functions.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note that `await` can be used at the top levels of modules (see [next section](ch_modules.html#top-level-await)).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an example of using `import()`.
  prefs: []
  type: TYPE_NORMAL
- en: '27.13.2.1 Example: loading a module dynamically'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We have already seen module `my-math.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `import()` to load this module on demand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Two things in this code can’t be done with `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: We are importing inside a function (not at the top level).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The module specifier comes from a variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we’ll implement the same functionality as in `main1.mjs` but via a feature
    called [*async function* or *async/await*](ch_async-functions.html) which provides
    nicer syntax for Promises.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/4e01a86e5fc2028470dca44da5c2d2aa.png)  **Why is `import()` an
    operator and not a function?**'
  prefs: []
  type: TYPE_NORMAL
- en: '`import()` looks like a function but couldn’t be implemented as a function:'
  prefs: []
  type: TYPE_NORMAL
- en: It needs to know the URL of the current module in order to resolve relative
    module specifiers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `import()` were a function, we’d have to explicitly pass this information
    to it (e.g. via an parameter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In contrast, an operator is a core language construct and has implicit access
    to more data, including the URL of the current module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 27.13.3 Use cases for `import()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 27.13.3.1 Loading code on demand
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Some functionality of web apps doesn’t have to be present when they start,
    it can be loaded on demand. Then `import()` helps because we can put such functionality
    into modules – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 27.13.3.2 Conditional loading of modules
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We may want to load a module depending on whether a condition is true. For
    example, a module with [a polyfill](ch_modules.html#polyfills) that makes a new
    feature available on legacy platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 27.13.3.3 Computed module specifiers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For applications such as internationalization, it helps if we can dynamically
    compute module specifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 27.14 Top-level `await` in modules [ES2022] (advanced)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](../Images/ec8e6930fbe484fc519f3aa7b812c3fd.png)  **`await` is a feature
    of async functions**'
  prefs: []
  type: TYPE_NORMAL
- en: '`await` is explained in [§41 “Async functions”](ch_async-functions.html). It
    may make sense to postpone reading this section until you understand async functions.'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `await` operator at the top level of a module. If we do that,
    the module becomes asynchronous and works differently. Thankfully, we don’t usually
    see that as programmers because it is handled transparently by the language.
  prefs: []
  type: TYPE_NORMAL
- en: 27.14.1 Use cases for top-level `await`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Why would we want to use the `await` operator at the top level of a module?
    It lets us initialize a module with asynchronously loaded data. The next three
    subsections show three examples of where that is useful.
  prefs: []
  type: TYPE_NORMAL
- en: 27.14.1.1 Loading modules dynamically
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In line A, we [dynamically import](ch_modules.html#dynamic-imports) a module.
    Thanks to top-level `await`, that is almost as convenient as using a normal, static
    import.
  prefs: []
  type: TYPE_NORMAL
- en: 27.14.1.2 Using a fallback if module loading fails
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 27.14.1.3 Using whichever resource loads fastest
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Due to [`Promise.any()`](ch_promises.html#Promise.any-AggregateError), variable
    `resource` is initialized via whichever download finishes first.
  prefs: []
  type: TYPE_NORMAL
- en: 27.14.2 How does top-level `await` work under the hood?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider the following two files.
  prefs: []
  type: TYPE_NORMAL
- en: '`first.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '`main.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Both are roughly equivalent to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`first.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '`main.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'A module becomes asynchronous if:'
  prefs: []
  type: TYPE_NORMAL
- en: It directly uses top-level `await` (`first.mjs`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It imports one or more asynchronous modules (`main.mjs`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each asynchronous module exports a Promise (line A and line B) that is fulfilled
    after its body was executed. At that point, it is safe to access the exports of
    that module.
  prefs: []
  type: TYPE_NORMAL
- en: In case (2), the importing module waits until the Promises of all imported asynchronous
    modules are fulfilled, before it enters its body (line C). Synchronous modules
    are handled as usually.
  prefs: []
  type: TYPE_NORMAL
- en: Awaited rejections and synchronous exceptions are managed as in async functions.
  prefs: []
  type: TYPE_NORMAL
- en: 27.14.3 The pros and cons of top-level `await`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The two most important benefits of top-level `await` are:'
  prefs: []
  type: TYPE_NORMAL
- en: It ensures that modules don’t access asynchronous imports before they are fully
    initialized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It handles asynchronicity transparently: Importers do not need to know if an
    imported module is asynchronous or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the downside, top-level `await` delays the initialization of importing modules.
    Therefore, it‘s best used sparingly. Asynchronous tasks that take longer are better
    performed later, on demand.
  prefs: []
  type: TYPE_NORMAL
- en: However, even modules without top-level `await` can block importers (e.g. via
    an infinite loop at the top level), so blocking per se is not an argument against
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '27.15 Polyfills: emulating native web platform features (advanced)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **Backends have polyfills,
    too**'
  prefs: []
  type: TYPE_NORMAL
- en: This section is about frontend development and web browsers, but similar ideas
    apply to backend development.
  prefs: []
  type: TYPE_NORMAL
- en: '*Polyfills* help with a conflict that we are facing when developing a web application
    in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: On one hand, we want to use modern web platform features that make the app better
    and/or development easier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, the app should run on as many browsers as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Given a web platform feature X:'
  prefs: []
  type: TYPE_NORMAL
- en: A *polyfill* for X is a piece of code. If it is executed on a platform that
    already has built-in support for X, it does nothing. Otherwise, it makes the feature
    available on the platform. In the latter case, the polyfilled feature is (mostly)
    indistinguishable from a native implementation. In order to achieve that, the
    polyfill usually makes global changes. For example, it may modify global data
    or configure a global module loader. Polyfills are often packaged as modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The term [*polyfill*](https://remysharp.com/2010/10/08/what-is-a-polyfill) was
    coined by Remy Sharp.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A *speculative polyfill* is a polyfill for a proposed web platform feature (that
    is not standardized, yet).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alternative term: *prollyfill*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A *replica* of X is a library that reproduces the API and functionality of X
    locally. Such a library exists independently of a native (and global) implementation
    of X.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Replica* is a new term introduced in this section. Alternative term: *ponyfill*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also the term *shim*, but it doesn’t have a universally agreed upon
    definition. It often means roughly the same as *polyfill*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time our web applications starts, it must first execute all polyfills
    for features that may not be available everywhere. Afterwards, we can be sure
    that those features are available natively.
  prefs: []
  type: TYPE_NORMAL
- en: 27.15.1 Sources of this section
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[“What is a Polyfill?”](https://remysharp.com/2010/10/08/what-is-a-polyfill)
    by Remy Sharp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inspiration for the term *replica*: [The Eiffel Tower in Las Vegas](https://en.wikipedia.org/wiki/Paris_Las_Vegas)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Useful clarification of “polyfill” and related terms: [“Polyfills and the evolution
    of the Web”](https://www.w3.org/2001/tag/doc/polyfills/). Edited by Andrew Betts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz**'
  prefs: []
  type: TYPE_NORMAL
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  prefs: []
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/20)'
  prefs: []
  type: TYPE_NORMAL
