- en: '35 Typed Arrays: handling binary data ES6 (advanced)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_typed-arrays.html](https://exploringjs.com/js/book/ch_typed-arrays.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[35.1 The Typed Array API: containers for binary data](#the-typed-array-api-containers-for-binary-data)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.1.1 Use cases for Typed Arrays](#use-cases-for-typed-arrays)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.1.2 The core classes: `ArrayBuffer`, Typed Arrays, `DataView`](#typed-array-api-classes)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.1.3 `SharedArrayBuffer` ^(ES2017)](#SharedArrayBuffer)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.2 Using Typed Arrays](#using-typed-arrays)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.2.1 Creating Typed Arrays](#creating-typed-arrays)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.2.2 The wrapped ArrayBuffer](#the-wrapped-arraybuffer)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.2.3 Getting and setting elements](#getting-and-setting-elements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.2.4 Concatenating Typed Arrays](#concatenating-typed-arrays)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.2.5 Typed Arrays vs. normal Arrays](#typed-arrays-vs-arrays)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.3 Using DataViews](#using-dataviews)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.4 Element types](#typed-array-element-types)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.4.1 Handling overflow and underflow](#handling-overflow-underflow)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.4.2 Endianness](#typed-arrays-endianness)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.5 Converting to and from Typed Arrays](#converting-to-and-from-typed-arrays)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.5.1 The static method `«ElementType»Array.from()`](#the-static-method-elementtypearrayfrom)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.5.2 Typed Arrays are iterable](#typed-arrays-are-iterable)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.5.3 Converting Typed Arrays to and from normal Arrays](#converting-typed-arrays-to-and-from-normal-arrays)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.5.4 Converting a `Uint8Array` (UTF-8) to and from a string](#uint8array-to-from-string)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.6 Resizing ArrayBuffers ^(ES2024)](#resizing-array-buffers)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.6.1 New features for ArrayBuffers](#new-features-for-arraybuffers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.6.2 How Typed Arrays react to changing ArrayBuffer sizes](#how-typed-arrays-react-to-changing-arraybuffer-sizes)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.6.3 Guidelines given by the ECMAScript specification](#guidelines-given-by-the-ecmascript-specification)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.7 Transferring and detaching ArrayBuffers ^(ES2024)](#transferring-detaching-array-buffers)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.7.1 Preparation: transferring data and detaching](#preparation-transferring-data-and-detaching)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.7.2 Methods related to transferring and detaching](#methods-related-to-transferring-and-detaching)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.7.3 Transferring ArrayBuffers via `structuredClone()`](#transferring-arraybuffers-via-structuredclone)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.7.4 Transferring an ArrayBuffer within the same agent](#transferring-an-arraybuffer-within-the-same-agent)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.7.5 How does detaching an ArrayBuffer affect its wrappers?](#how-does-detaching-an-arraybuffer-affect-its-wrappers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.7.6 `ArrayBuffer.prototype.transferToFixedLength()`](#arraybufferprototypetransfertofixedlength)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.8 Quick references: indices vs. offsets](#typed-arrays-indices-offsets)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.9 Quick reference: ArrayBuffers](#quick-reference-arraybuffers)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.9.1 `new ArrayBuffer()`](#new-arraybuffer)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.9.2 `ArrayBuffer.*`](#arraybuffer)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.9.3 `ArrayBuffer.prototype.*`: getting and slicing](#arraybufferprototype-getting-and-slicing)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.9.4 `ArrayBuffer.prototype.*`: resizing](#arraybufferprototype-resizing)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.10 Quick reference: Typed Arrays](#quick-reference-typed-arrays)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.10.1 `TypedArray.*`](#typedarray)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.10.2 `TypedArray.prototype.*`](#typedarrayprototype)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.10.3 `new «ElementType»Array()`](#new-elementtypearray)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.10.4 `«ElementType»Array.*`](#elementtypearray)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.10.5 `«ElementType»Array.prototype.*`](#elementtypearrayprototype)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.11 Quick reference: DataViews](#quick-reference-dataviews)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.11.1 `new DataView()`](#new-dataview)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.11.2 `DataView.prototype.*`](#dataviewprototype)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.1 The Typed Array API: containers for binary data](#the-typed-array-api-containers-for-binary-data)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Much data on the web is text: JSON files, HTML files, CSS files, JavaScript
    code, etc. JavaScript handles such data well via its built-in strings.'
  prefs: []
  type: TYPE_NORMAL
- en: However, before 2011, it did not handle binary data well. [The Typed Array Specification
    1.0](https://web.archive.org/web/20160529225618/https://www.khronos.org/registry/typedarray/specs/1.0/)
    was introduced on February 8, 2011 and provides tools for working with binary
    data. With ECMAScript 6, Typed Arrays were added to the core language and gained
    methods that were previously only available for normal Arrays (`.map()`, `.filter()`,
    etc.).
  prefs: []
  type: TYPE_NORMAL
- en: '[35.1.1 Use cases for Typed Arrays](#use-cases-for-typed-arrays)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The main uses cases for Typed Arrays are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Processing binary data: managing image data, manipulating binary files, handling
    binary network protocols, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interacting with native APIs: Native APIs often receive and return data in
    a binary format, which we could neither store nor manipulate well in pre-ES6 JavaScript.
    That meant that whenever we were communicating with such an API, data had to be
    converted from JavaScript to binary and back for every call. Typed Arrays eliminate
    this bottleneck. Examples include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[WebGL](https://www.khronos.org/webgl/), “a low-level 3D graphics API based
    on OpenGL ES, exposed to ECMAScript via the HTML5 Canvas element”. Typed Arrays
    were initially created for WebGL. Section [“History of Typed Arrays”](https://web.dev/articles/webgl-typed-arrays#toc-history)
    of the article [“Typed Arrays: Binary Data in the Browser”](https://web.dev/articles/webgl-typed-arrays#toc-history)
    (by Ilmari Heikkinen for HTML5 Rocks) has more information.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[WebGPU](https://www.w3.org/TR/webgpu/), “an API for performing operations,
    such as rendering and computation, on a Graphics Processing Unit”. For example,
    WebGPU uses ArrayBuffers as wrappers for backing stores.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[WebAssembly](https://webassembly.org) (short: “Wasm”), “a binary instruction
    format for a stack-based virtual machine. Wasm is designed as a portable compilation
    target for programming languages, enabling deployment on the web for client and
    server applications.” For example, the memory of WebAssembly code is stored in
    an ArrayBuffer or a SharedArrayBuffer ([details](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Memory)).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[35.1.2 The core classes: `ArrayBuffer`, Typed Arrays, `DataView`](#typed-array-api-classes)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Typed Array API stores binary data in instances of `ArrayBuffer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An ArrayBuffer itself is a black box: if we want to access its data, we must
    wrap it in another object – a *view object*. Two kinds of view objects are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Typed Arrays* work similarly to normal Arrays and let us access the data as
    an indexed sequence of elements that all have the same type. Examples include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Uint8Array`: Elements are unsigned 8-bit integers. *Unsigned* means that their
    ranges start at zero.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int16Array`: Elements are signed 16-bit integers. *Signed* means that they
    have a sign and can be negative, zero, or positive.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Float16Array`: Elements are 16-bit floating point numbers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*DataViews* let us interpret the data as various types (`Uint8`, `Int16`, `Float16`,
    etc.) that we can read and write at any byte offset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 35.1](#fig:typed_arrays_class_diagram) shows a class diagram of the
    API.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a115834d4de67018f7d77365cf61bfce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 35.1: The classes of the Typed Array API.'
  prefs: []
  type: TYPE_NORMAL
- en: '[35.1.3 `SharedArrayBuffer` ^(ES2017)](#SharedArrayBuffer)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: SharedArrayBuffer is an ArrayBuffer whose memory can be accessed by multiple
    *agents* (an agent being the main thread or a web worker) concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: Where ArrayBuffers can be [*transferred*](#transferring-detaching-array-buffers)
    (moved, not copied) between agents, SharedArrayBuffers are not transferable and
    must be cloned. However, that only clones their outer parts. The data storage
    itself is shared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SharedArrayBuffers can be [resized](#resizing-array-buffers) but they can only
    grow not shrink because shrinking shared memory is too complicated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Atomics` is a global namespace for an API that complements SharedArrayBuffers.
    The ECMAScript specification [describes it](https://tc39.es/ecma262/#sec-atomics-object)
    as “functions that operate indivisibly (atomically) on shared memory array cells
    as well as functions that let agents wait for and dispatch primitive events. When
    used with discipline, the Atomics functions allow multi-agent programs that communicate
    through shared memory to execute in a well-understood order even on parallel CPUs.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See MDN Web Docs for more information on [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer)
    and [`Atomics`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics).
  prefs: []
  type: TYPE_NORMAL
- en: '[35.2 Using Typed Arrays](#using-typed-arrays)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Typed Arrays are used much like normal Arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[35.2.1 Creating Typed Arrays](#creating-typed-arrays)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following code shows three different ways of creating the same Typed Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[35.2.2 The wrapped ArrayBuffer](#the-wrapped-arraybuffer)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[35.2.3 Getting and setting elements](#getting-and-setting-elements)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[35.2.4 Concatenating Typed Arrays](#concatenating-typed-arrays)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Typed Arrays don’t have a method `.concat()`, like normal Arrays do. The workaround
    is to use their overloaded method `.set()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It copies the existing `typedArray` or `arrayLike` into the receiver, at index
    `offset`. `TypedArray` is an internal abstract superclass of all concrete Typed
    Array classes (that doesn’t actually have a global name).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function uses that method to copy zero or more Typed Arrays (or
    Array-like objects) into an instance of `resultConstructor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[35.2.5 Typed Arrays vs. normal Arrays](#typed-arrays-vs-arrays)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Typed Arrays are much like normal Arrays: they have a `.length`, elements can
    be accessed via the bracket operator `[]`, and they have most of the standard
    Array methods. They differ from normal Arrays in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Typed Arrays have buffers. The elements of a Typed Array `ta` are not stored
    in `ta`, they are stored in an associated ArrayBuffer that can be accessed via
    `ta.buffer`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Typed Arrays are initialized with zeros:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new Array(4)` creates a normal Array without any elements. It only has four
    *holes* (indices less than the `.length` that have no associated elements).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new Uint8Array(4)` creates a Typed Array whose four elements are all 0.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All of the elements of a Typed Array have the same type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting elements converts values to that type.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Getting elements returns numbers or bigints.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The `.length` of a Typed Array is derived from its ArrayBuffer and never changes
    (unless we switch to a different ArrayBuffer).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normal Arrays can have holes; Typed Arrays can’t.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Converting between strings and UTF-16**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/typed-arrays/utf-16-conversion_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[35.3 Using DataViews](#using-dataviews)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is how DataViews are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[35.4 Element types](#typed-array-element-types)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Element | Typed Array | Bytes | Description | Get/Set |  |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Int8` | `Int8Array` | 1 | 8-bit signed integer | `number` | ES6 |'
  prefs: []
  type: TYPE_TB
- en: '| `Uint8` | `Uint8Array` | 1 | 8-bit unsigned int | `number` | ES6 |'
  prefs: []
  type: TYPE_TB
- en: '| (`Uint8C`) | `Uint8ClampedArray` | 1 | 8-bit unsigned int | `number` | ES6
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Int16` | `Int16Array` | 2 | 16-bit signed int | `number` | ES6 |'
  prefs: []
  type: TYPE_TB
- en: '| `Uint16` | `Uint16Array` | 2 | 16-bit unsigned int | `number` | ES6 |'
  prefs: []
  type: TYPE_TB
- en: '| `Int32` | `Int32Array` | 4 | 32-bit signed int | `number` | ES6 |'
  prefs: []
  type: TYPE_TB
- en: '| `Uint32` | `Uint32Array` | 4 | 32-bit unsigned int | `number` | ES6 |'
  prefs: []
  type: TYPE_TB
- en: '| `BigInt64` | `BigInt64Array` | 8 | 64-bit signed int | `bigint` | ES2020
    |'
  prefs: []
  type: TYPE_TB
- en: '| `BigUint64` | `BigUint64Array` | 8 | 64-bit unsigned int | `bigint` | ES2020
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Float16` | `Float16Array` | 2 | 16-bit floating point | `number` | ES2025
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Float32` | `Float32Array` | 4 | 32-bit floating point | `number` | ES6 |'
  prefs: []
  type: TYPE_TB
- en: '| `Float64` | `Float64Array` | 8 | 64-bit floating point | `number` | ES6 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 35.1: Element types supported by the Typed Array API.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 35.1](#tbl:typed-array-element-types) lists the available element types.
    These types (e.g., `Int32`) show up in two locations:'
  prefs: []
  type: TYPE_NORMAL
- en: In Typed Arrays, they specify the types of the elements. For example, all elements
    of a `Int32Array` have the type `Int32`. The element type is the only aspect of
    Typed Arrays that differs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In DataViews, they are the lenses through which they access their ArrayBuffers
    when we use methods such as `.getInt32()` and `.setInt32()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The element type `Uint8C` is special: it is not supported by `DataView` and
    only exists to enable `Uint8ClampedArray`. This Typed Array is used by the `canvas`
    element (where it replaces `CanvasPixelArray`) and should otherwise be avoided.
    The only difference between `Uint8C` and `Uint8` is how overflow is handled (as
    explained next).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Typed Arrays and Array Buffers use numbers and bigints to import and export
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: The types `BigInt64` and `BigUint64` are handled via bigints. For example, setters
    accept bigints and getters return bigints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All other element types are handled via numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[35.4.1 Handling overflow and underflow](#handling-overflow-underflow)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[35.4.1.1 Handling overflow for integers](#handling-overflow-for-integers)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Normally, when a value is out of the range of the element type, modulo arithmetic
    is used to convert it to a value within range. For signed and unsigned integers
    that means that:'
  prefs: []
  type: TYPE_NORMAL
- en: The highest value plus one is converted to the lowest value (0 for unsigned
    integers).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lowest value minus one is converted to the highest value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following function helps illustrate how conversion works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Modulo conversion for unsigned 8-bit integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Modulo conversion for signed 8-bit integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Clamped conversion is different:'
  prefs: []
  type: TYPE_NORMAL
- en: All negatively overflowing values are converted to the lowest value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All positively overflowing values are converted to the highest value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[35.4.1.2 Handling overflow and underflow for floats](#handling-overflow-and-underflow-for-floats)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is positive overflow (positive numbers being too far away from zero),
    the result is positive infinity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is negative overflow (negative numbers being too far away from zero),
    the result is negative infinity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Arithmetic underflow means that a number has too many digits after a binary
    point (it is too close to an integer). If that happens, digits that can’t be represented
    are omitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Useful related function: [`Math.f16round(x)`](ch_math.html#qref-Math.f16round)
    rounds `x` to 16 bits (within a 64-bit float).'
  prefs: []
  type: TYPE_NORMAL
- en: '[35.4.2 Endianness](#typed-arrays-endianness)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Whenever a type (such as `Uint16`) is stored as a sequence of multiple bytes,
    *endianness* matters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Big endian: the most significant byte comes first. For example, the `Uint16`
    value 0x4321 is stored as two bytes – first 0x43, then 0x21.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Little endian: the least significant byte comes first. For example, the `Uint16`
    value 0x4321 is stored as two bytes – first 0x21, then 0x43.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Endianness tends to be fixed per CPU architecture and consistent across native
    APIs. Typed Arrays are used to communicate with those APIs, which is why their
    endianness follows the endianness of the platform and can’t be changed.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the endianness of protocols and binary files varies, but
    is fixed per format, across platforms. Therefore, we must be able to access data
    with either endianness. DataViews serve this use case and let us specify endianness
    when we get or set a value.
  prefs: []
  type: TYPE_NORMAL
- en: '[Quoting Wikipedia on Endianness](https://en.wikipedia.org/wiki/Endianness):'
  prefs: []
  type: TYPE_NORMAL
- en: Big-endian representation is the most common convention in data networking;
    fields in the protocols of the Internet protocol suite, such as IPv4, IPv6, TCP,
    and UDP, are transmitted in big-endian order. For this reason, big-endian byte
    order is also referred to as network byte order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Little-endian storage is popular for microprocessors in part due to significant
    historical influence on microprocessor designs by Intel Corporation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other orderings are also possible. Those are generically called *middle-endian*
    or *mixed-endian*.
  prefs: []
  type: TYPE_NORMAL
- en: '[35.5 Converting to and from Typed Arrays](#converting-to-and-from-typed-arrays)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, `«ElementType»Array` stands for `Int8Array`, `Uint8Array`,
    etc. `ElementType` is `Int8`, `Uint8`, etc.
  prefs: []
  type: TYPE_NORMAL
- en: '[35.5.1 The static method `«ElementType»Array.from()`](#the-static-method-elementtypearrayfrom)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This method has the type signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`.from()` converts `source` into an instance of `this` (a Typed Array).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, normal Arrays are iterable and can be converted with this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Typed Arrays are also iterable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`source` can also be [an *Array-like object*](ch_arrays.html#array-like-objects):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The optional `mapfn` lets us transform the elements of `source` before they
    become elements of the result. Why perform the two steps *mapping* and *conversion*
    in one go? Compared to mapping separately via `.map()`, there are two advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: No intermediate Array or Typed Array is needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When converting between Typed Arrays with different precisions, less can go
    wrong.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read on for an explanation of the second advantage.
  prefs: []
  type: TYPE_NORMAL
- en: '[35.5.1.1 Pitfall: mapping while converting between Typed Array types](#pitfall-mapping-while-converting-between-typed-array-types)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The static method `.from()` can optionally both map and convert between Typed
    Array types. Less can go wrong if we use that method.
  prefs: []
  type: TYPE_NORMAL
- en: To see why that is, let us first convert a Typed Array to a Typed Array with
    a higher precision. If we use `.from()` to map, the result is automatically correct.
    Otherwise, we must first convert and then map.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If we go from a Typed Array to a Typed Array with a lower precision, mapping
    via `.from()` produces the correct result. Otherwise, we must first map and then
    convert.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that if we map via `.map()`, then input type and output type
    are the same. In contrast, `.from()` goes from an arbitrary input type to an output
    type that we specify via its receiver.
  prefs: []
  type: TYPE_NORMAL
- en: '[35.5.2 Typed Arrays are iterable](#typed-arrays-are-iterable)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Typed Arrays are [iterable](ch_sync-iteration.html#ch_sync-iteration). That
    means that we can use the `for-of` loop and other iteration-based mechanisms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: ArrayBuffers and DataViews are not iterable.
  prefs: []
  type: TYPE_NORMAL
- en: '[35.5.3 Converting Typed Arrays to and from normal Arrays](#converting-typed-arrays-to-and-from-normal-arrays)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To convert a normal Array to a Typed Array, we pass it to:'
  prefs: []
  type: TYPE_NORMAL
- en: A Typed Array constructor – which accepts Typed Arrays, iterable values and
    Array-like objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`«ElementType»Array.from()` – which accepts iterable values and Array-like
    values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert a Typed Array to a normal Array, we can use `Array.from()` or spreading
    (because Typed Arrays are iterable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[35.5.4 Converting a `Uint8Array` (UTF-8) to and from a string](#uint8array-to-from-string)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The class `TextEncoder` and `TextDecoder` are not part of ECMAScript proper
    but supported by all major JavaScript platforms (browsers, Node.js, etc.). Therefore,
    we can use them to convert between `Uint8Array` and string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Converting a string to UTF-8-encoded bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting UTF-8-encoded bytes to a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[35.6 Resizing ArrayBuffers ^(ES2024)](#resizing-array-buffers)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before ArrayBuffers became resizable, they had fixed sizes. If we wanted one
    to grow or shrink, we had to allocate a new one and copy the old one over. That
    costs time and can fragment the address space on 32-bit systems.
  prefs: []
  type: TYPE_NORMAL
- en: '[35.6.1 New features for ArrayBuffers](#new-features-for-arraybuffers)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These are the changes introduced by resizing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The existing constructor gets one more parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is one new method and two new getters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ArrayBuffer.prototype.resize(newByteLength: number)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Resizes the ArrayBuffer.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get ArrayBuffer.prototype.resizable`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a boolean indicating if this ArrayBuffer is resizable.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get ArrayBuffer.prototype.maxByteLength`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `options.maxByteLength` if it was provided to the constructor. Otherwise,
    it returns `this.byteLength`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The existing method `.slice()` always returns non-resizable ArrayBuffers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `options` object of the constructor determines whether or not an ArrayBuffer
    is resizable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[35.6.2 How Typed Arrays react to changing ArrayBuffer sizes](#how-typed-arrays-react-to-changing-arraybuffer-sizes)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is what constructors of Typed Arrays look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If `length` is `undefined` then the `.length` and `.byteLength` of the Typed
    Array instance automatically tracks the length of a resizable `buffer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If an ArrayBuffer is resized then a wrapper with a fixed length can *go out
    of bounds*: The wrapper’s range isn’t covered by the ArrayBuffer anymore. That
    is treated by JavaScript as if the ArrayBuffer were [*detached*](#transferring-detaching-array-buffers):'
  prefs: []
  type: TYPE_NORMAL
- en: '`.length`, `.byteLength` and `.byteOffset` are zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting elements returns `undefined`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting elements is silently ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All element-related methods throw errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[35.6.3 Guidelines given by the ECMAScript specification](#guidelines-given-by-the-ecmascript-specification)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The ECMAScript specification gives [the following guidelines](https://tc39.es/ecma262/#sec-resizable-arraybuffer-guidelines)
    for working with resizable ArrayBuffers:'
  prefs: []
  type: TYPE_NORMAL
- en: We recommend that programs be tested in their deployment environments where
    possible. The amount of available physical memory differs greatly between hardware
    devices. Similarly, virtual memory subsystems also differ greatly between hardware
    devices as well as operating systems. An application that runs without out-of-memory
    errors on a 64-bit desktop web browser could run out of memory on a 32-bit mobile
    web browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When choosing a value for the `maxByteLength` option for resizable ArrayBuffer,
    we recommend that the smallest possible size for the application be chosen. We
    recommend that `maxByteLength` does not exceed 1,073,741,824 (2^(30) bytes or
    1 GiB).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that successfully constructing a resizable ArrayBuffer for a particular
    maximum size does not guarantee that future resizes will succeed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[35.7 Transferring and detaching ArrayBuffers ^(ES2024)](#transferring-detaching-array-buffers)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[35.7.1 Preparation: transferring data and detaching](#preparation-transferring-data-and-detaching)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The web API (not the ECMAScript standard) has long supported [*structured cloning*](https://html.spec.whatwg.org/multipage/structured-data.html#safe-passing-of-structured-data)
    for safely moving values across realms (`globalThis`, iframes, web workers, etc.).
    Some objects can also be *transferred*: After cloning, the original becomes *detached*
    (inaccessible) and ownership switches from the original to the clone. Transferring
    is usually faster than copying, especially if large amounts of memory are involved.
    These are the most common classes of [*transferable objects*](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Transferable_objects):'
  prefs: []
  type: TYPE_NORMAL
- en: '`ArrayBuffer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Streams:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadableStream`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TransformStream`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WritableStream`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DOM-related data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImageBitmap`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OffscreenCanvas`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Miscellaneous communication:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MessagePort`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTCDataChannel`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[35.7.2 Methods related to transferring and detaching](#methods-related-to-transferring-and-detaching)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Two methods let us explicitly transfer an ArrayBuffer to a new object (we’ll
    see soon why that is useful):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ArrayBuffer.prototype.transfer(newLength?: number)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ArrayBuffer.prototype.transferToFixedLength(newLength?: number)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One getter tells us if an ArrayBuffer is detached:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get ArrayBuffer.prototype.detached`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[35.7.3 Transferring ArrayBuffers via `structuredClone()`](#transferring-arraybuffers-via-structuredclone)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The broadly supported [`structuredClone()`](ch_objects.html#structuredClone)
    also lets us transfer (and therefore detach) ArrayBuffers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The ArrayBuffer method `.transfer()` simply gives us a more concise way to
    detach an ArrayBuffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[35.7.4 Transferring an ArrayBuffer within the same agent](#transferring-an-arraybuffer-within-the-same-agent)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Transferring is most often used between two *agents* (an agent being the main
    thread or a web worker). However, transferring within the same agent can make
    sense too: If a function gets a (potentially shared) ArrayBuffer as a parameter,
    it can transfer it so that no external code can interfere with what it does. Example
    (taken from [the ECMAScript proposal](https://github.com/tc39/proposal-arraybuffer-transfer?tab=readme-ov-file#ownership)
    and slightly edited):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[35.7.5 How does detaching an ArrayBuffer affect its wrappers?](#how-does-detaching-an-arraybuffer-affect-its-wrappers)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[35.7.5.1 Typed Arrays with detached ArrayBuffers](#typed-arrays-with-detached-arraybuffers)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Preparation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Lengths and offsets are all zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting elements returns `undefined`; setting elements fails silently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'All element-related methods throw exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[35.7.5.2 DataViews with detached ArrayBuffers](#dataviews-with-detached-arraybuffers)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'All data-related methods of DataViews throw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[35.7.5.3 We can’t create new wrappers with detached ArrayBuffers](#we-cant-create-new-wrappers-with-detached-arraybuffers)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[35.7.6 `ArrayBuffer.prototype.transferToFixedLength()`](#arraybufferprototypetransfertofixedlength)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This method rounds out the API: It transfers and converts a resizable ArrayBuffer
    to one with a fixed length. That may free up memory that was held in preparation
    for growth.'
  prefs: []
  type: TYPE_NORMAL
- en: '[35.8 Quick references: indices vs. offsets](#typed-arrays-indices-offsets)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In preparation for the quick references on ArrayBuffers, Typed Arrays, and
    DataViews, we need learn the differences between indices and offsets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Indices for the bracket operator `[ ]`: We can only use non-negative indices
    (starting at 0).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In normal Arrays, writing to negative indices creates properties:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In Typed Arrays, writing to negative indices is ignored:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Indices for methods of ArrayBuffers, Typed Arrays, and DataViews: Every index
    can be negative. If it is, it is added to the length of the entity to produce
    the actual index. Therefore, `-1` refers to the last element, `-2` to the second-last,
    etc. Methods of normal Arrays work the same way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Offsets passed to methods of Typed Arrays and DataViews: must be non-negative
    – for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Whether a parameter is an index or an offset can only be determined by looking
    at documentation; there is no simple rule.
  prefs: []
  type: TYPE_NORMAL
- en: '[35.9 Quick reference: ArrayBuffers](#quick-reference-arraybuffers)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ArrayBuffers store binary data, which is meant to be accessed via Typed Arrays
    and DataViews.
  prefs: []
  type: TYPE_NORMAL
- en: '[35.9.1 `new ArrayBuffer()`](#new-arraybuffer)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`new ArrayBuffer(byteLength, options?)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Invoking this constructor via `new` creates an instance whose capacity is `length`
    bytes. Each of those bytes is initially 0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If `options.maxByteLength` is provided, the ArrayBuffer can be resized. Otherwise,
    it has a fixed length.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[35.9.2 `ArrayBuffer.*`](#arraybuffer)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`ArrayBuffer.isView(arg)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if `arg` is a *view* for an ArrayBuffer (i.e., if it is a Typed
    Array or a DataView).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[35.9.3 `ArrayBuffer.prototype.*`: getting and slicing](#arraybufferprototype-getting-and-slicing)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`get ArrayBuffer.prototype.byteLength` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the capacity of this ArrayBuffer in bytes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ArrayBuffer.prototype.slice(startIndex=0, endIndex=this.byteLength)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creates a new ArrayBuffer that contains the bytes of this ArrayBuffer whose
    indices are greater than or equal to `startIndex` and less than `endIndex`. `start`
    and `endIndex` can be negative (see [“Quick references: indices vs. offsets” (§35.8)](#typed-arrays-indices-offsets)).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[35.9.4 `ArrayBuffer.prototype.*`: resizing](#arraybufferprototype-resizing)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`ArrayBuffer.prototype.resize(newByteLength)` ES2024'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes the size of this ArrayBuffer. For more information, see [“Resizing ArrayBuffers
    ^(ES2024)” (§35.6)](#resizing-array-buffers).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`get ArrayBuffer.prototype.resizable` ES2024'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if this ArrayBuffer is resizable and `false` if it is not.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`get ArrayBuffer.prototype.maxByteLength` ES2024'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `options.maxByteLength` if it was provided to the constructor. Otherwise,
    it returns `this.byteLength`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[35.10 Quick reference: Typed Arrays](#quick-reference-typed-arrays)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The properties of the various Typed Array objects are introduced in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TypedArray`: First, we look at the abstract superclass of all Typed Array
    classes (which was shown in the class diagram [at the beginning of this chapter](#fig:typed_arrays_class_diagram)).
    That superclass is called `TypedArray` but it does not have a global name in JavaScript:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`«ElementType»Array`: The concrete Typed Array classes are called `Uint8Array`,
    `Int16Array`, `Float16Array`, etc. These are the classes that we use via `new`,
    `.of`, and `.from()`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.10.1 `TypedArray.*`](#typedarray)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Both static `TypedArray` methods are inherited by its subclasses (`Uint8Array`,
    etc.). Therefore, we can use these methods via the subclasses, which are concrete
    and can have direct instances.
  prefs: []
  type: TYPE_NORMAL
- en: '`TypedArray.from(iterableOrArrayLike, mapFunc?)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Converts an iterable (including Arrays and Typed Arrays) or [an Array-like object](ch_arrays.html#array-like-objects)
    to an instance of the Typed Array class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The optional `mapFunc` lets us transform the elements of `source` before they
    become elements of the result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`TypedArray.of(...items)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creates a new instance of the Typed Array class whose elements are `items` (coerced
    to the element type).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[35.10.2 `TypedArray.prototype.*`](#typedarrayprototype)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Indices accepted by Typed Array methods can be negative (they work like traditional
    Array methods that way). Offsets must be non-negative. For details, see [“Quick
    references: indices vs. offsets” (§35.8)](#typed-arrays-indices-offsets).'
  prefs: []
  type: TYPE_NORMAL
- en: '[35.10.2.1 Properties specific to Typed Arrays](#properties-specific-to-typed-arrays)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following properties are specific to Typed Arrays; normal Arrays don’t
    have them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get TypedArray.prototype.buffer` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the ArrayBuffer backing this Typed Array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`get TypedArray.prototype.length` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the length in elements of this Typed Array’s buffer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`get TypedArray.prototype.byteLength` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the size in bytes of this Typed Array’s buffer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`get TypedArray.prototype.byteOffset` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the offset where this Typed Array “starts” inside its ArrayBuffer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.set(typedArrayOrArrayLike, offset=0)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copies all elements of the first parameter to this Typed Array. The element
    at index 0 of the parameter is written to index `offset` of this Typed Array (etc.).
    For more information on Array-like objects, see [“Array-like objects” (§34.5)](ch_arrays.html#array-like-objects).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.subarray(startIndex=0, endIndex=this.length)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a new Typed Array that has the same buffer as this Typed Array, but
    a (generally) smaller range. If `startIndex` is non-negative then the first element
    of the resulting Typed Array is `this[startIndex]`, the second `this[startIndex+1]`
    (etc.). If `startIndex` in negative, it is converted appropriately.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[35.10.2.2 Array methods](#array-methods)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following methods are basically the same as the methods of normal Arrays
    (the ECMAScript versions specify when the methods were added to Arrays – Typed
    Arrays didn’t exist in ECMAScript before ES6):'
  prefs: []
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.at(index)` ^(ES2022, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.copyWithin(target, start, end=this.length)` ^(ES6, W)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.entries()` ^(ES6, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.every(predicate, thisArg?)` ^(ES5, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.fill(start=0, end=this.length)` ^(ES6, W)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.filter(predicate, thisArg?)` ^(ES5, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.find(predicate, thisArg?)` ^(ES6, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.findIndex(predicate, thisArg?)` ^(ES6, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.findLast(predicate, thisArg?)` ^(ES2023, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.findLastIndex(predicate, thisArg?)` ^(ES2023, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.forEach(callback)` ^(ES5, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.includes(searchElement, fromIndex)` ^(ES2016, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.indexOf(searchElement, fromIndex)` ^(ES5, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.join(separator = '','')` ^(ES1, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.keys()` ^(ES6, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.lastIndexOf(searchElement, fromIndex)` ^(ES5, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.map(callback, thisArg?)` ^(ES5, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.reduce(callback, initialValue?)` ^(ES5, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.reduceRight(callback, initialValue?)` ^(ES5, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.reverse()` ^(ES1, W)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.slice(start?, end?)` ^(ES3, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.some(predicate, thisArg?)` ^(ES5, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.sort(compareFunc?)` ^(ES1, W)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.toLocaleString()` ^(ES3, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.toReversed()` ^(ES2023, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.toSorted(compareFunc?)` ^(ES2023, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.toSpliced(start?, deleteCount?, ...items)` ^(ES2023,
    R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.toString()` ^(ES1, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.values()` ^(ES6, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.with(index, value)` ^(ES2023, R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For details on how these methods work, see [“Quick reference: `Array`” (§34.18)](ch_arrays.html#quickref-Array).'
  prefs: []
  type: TYPE_NORMAL
- en: '[35.10.3 `new «ElementType»Array()`](#new-elementtypearray)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Each Typed Array constructor has a name that follows the pattern `«ElementType»Array`,
    where `«ElementType»` is one of the element types listed in [Table 35.1](#tbl:typed-array-element-types).
    That means there are 12 constructors for Typed Arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Int8Array`, `Uint8Array`, `Uint8ClampedArray`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int16Array`, `Uint16Array`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int32Array`, `Uint32Array`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BigInt64Array`, `BigUint64Array`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Float16Array`, `Float32Array`, `Float64Array`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each constructor has several *overloaded* versions – it behaves differently
    depending on how many arguments it receives and what their types are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`new «ElementType»Array(length=0)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creates a new `«ElementType»Array` with the given `length` and the appropriate
    buffer. The buffer’s size in bytes is:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`new «ElementType»Array(source: TypedArray)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a new instance of `«ElementType»Array` whose elements have the same
    values as the elements of `source`, but coerced to `ElementType`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`new «ElementType»Array(source: Iterable<number>)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BigInt64Array`, `BigUint64Array`: `bigint` instead of `number`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a new instance of `«ElementType»Array` whose elements have the same
    values as the items of `source`, but coerced to `ElementType`. For more information
    on iterables, see [“Synchronous iteration ^(ES6)” (§32)](ch_sync-iteration.html#ch_sync-iteration).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new «ElementType»Array(source: ArrayLike<number>)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BigInt64Array`, `BigUint64Array`: `bigint` instead of `number`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a new instance of `«ElementType»Array` whose elements have the same
    values as the elements of `source`, but coerced to `ElementType`. For more information
    on Array-like objects, see [“Array-like objects” (§34.5)](ch_arrays.html#array-like-objects).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new «ElementType»Array(buffer: ArrayBuffer, byteOffset=0, length=0)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a new `«ElementType»Array` whose buffer is `buffer`. It starts accessing
    the buffer at the given `byteOffset` and will have the given `length`. Note that
    `length` counts elements of the Typed Array (with 1–8 bytes each), not bytes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[35.10.4 `«ElementType»Array.*`](#elementtypearray)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`«ElementType»Array.BYTES_PER_ELEMENT: number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Counts how many bytes are needed to store a single element:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[35.10.5 `«ElementType»Array.prototype.*`](#elementtypearrayprototype)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`«ElementType»Array.prototype.BYTES_PER_ELEMENT: number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same as `«ElementType»Array.BYTES_PER_ELEMENT`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[35.11 Quick reference: DataViews](#quick-reference-dataviews)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[35.11.1 `new DataView()`](#new-dataview)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`new DataView(arrayBuffer, byteOffset?, byteLength?)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a new DataView whose data is stored in the ArrayBuffer `buffer`. By
    default, the new DataView can access all of `buffer`. The last two parameters
    allow us to change that.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[35.11.2 `DataView.prototype.*`](#dataviewprototype)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the remainder of this section, `«ElementType»` refers to either:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Int8`, `Uint8`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int16`, `Uint16`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int32`, `Uint32`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BigInt64`, `BigUint64`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Float16`, `Float32`, `Float64`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the properties of `DataView.prototype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get DataView.prototype.buffer` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the ArrayBuffer of this DataView.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`get DataView.prototype.byteLength` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns how many bytes can be accessed by this DataView.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`get DataView.prototype.byteOffset` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns at which offset this DataView starts accessing the bytes in its buffer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`DataView.prototype.get«ElementType»(byteOffset, littleEndian=false)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`BigInt64`, `BigUint64`: `bigint`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All other element types: `number`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reads a value from the buffer of this DataView.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`DataView.prototype.set«ElementType»(byteOffset, value, littleEndian=false)`
    ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type of `value`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`BigInt64`, `BigUint64`: `bigint`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All other element types: `number`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Writes `value` to the buffer of this DataView.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
