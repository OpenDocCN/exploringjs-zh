- en: '35 Typed Arrays: handling binary data ES6 (advanced)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_typed-arrays.html](https://exploringjs.com/js/book/ch_typed-arrays.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[35.1 The Typed Array API: containers for binary data](#the-typed-array-api-containers-for-binary-data)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.1.1 Use cases for Typed Arrays](#use-cases-for-typed-arrays)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.1.2 The core classes: `ArrayBuffer`, Typed Arrays, `DataView`](#typed-array-api-classes)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.1.3 `SharedArrayBuffer` ^(ES2017)](#SharedArrayBuffer)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.2 Using Typed Arrays](#using-typed-arrays)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.2.1 Creating Typed Arrays](#creating-typed-arrays)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.2.2 The wrapped ArrayBuffer](#the-wrapped-arraybuffer)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.2.3 Getting and setting elements](#getting-and-setting-elements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.2.4 Concatenating Typed Arrays](#concatenating-typed-arrays)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.2.5 Typed Arrays vs. normal Arrays](#typed-arrays-vs-arrays)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.3 Using DataViews](#using-dataviews)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.4 Element types](#typed-array-element-types)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.4.1 Handling overflow and underflow](#handling-overflow-underflow)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.4.2 Endianness](#typed-arrays-endianness)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.5 Converting to and from Typed Arrays](#converting-to-and-from-typed-arrays)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.5.1 The static method `«ElementType»Array.from()`](#the-static-method-elementtypearrayfrom)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.5.2 Typed Arrays are iterable](#typed-arrays-are-iterable)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.5.3 Converting Typed Arrays to and from normal Arrays](#converting-typed-arrays-to-and-from-normal-arrays)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.5.4 Converting a `Uint8Array` (UTF-8) to and from a string](#uint8array-to-from-string)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.6 Resizing ArrayBuffers ^(ES2024)](#resizing-array-buffers)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.6.1 New features for ArrayBuffers](#new-features-for-arraybuffers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.6.2 How Typed Arrays react to changing ArrayBuffer sizes](#how-typed-arrays-react-to-changing-arraybuffer-sizes)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.6.3 Guidelines given by the ECMAScript specification](#guidelines-given-by-the-ecmascript-specification)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.7 Transferring and detaching ArrayBuffers ^(ES2024)](#transferring-detaching-array-buffers)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.7.1 Preparation: transferring data and detaching](#preparation-transferring-data-and-detaching)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.7.2 Methods related to transferring and detaching](#methods-related-to-transferring-and-detaching)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.7.3 Transferring ArrayBuffers via `structuredClone()`](#transferring-arraybuffers-via-structuredclone)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.7.4 Transferring an ArrayBuffer within the same agent](#transferring-an-arraybuffer-within-the-same-agent)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.7.5 How does detaching an ArrayBuffer affect its wrappers?](#how-does-detaching-an-arraybuffer-affect-its-wrappers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.7.6 `ArrayBuffer.prototype.transferToFixedLength()`](#arraybufferprototypetransfertofixedlength)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.8 Quick references: indices vs. offsets](#typed-arrays-indices-offsets)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.9 Quick reference: ArrayBuffers](#quick-reference-arraybuffers)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.9.1 `new ArrayBuffer()`](#new-arraybuffer)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.9.2 `ArrayBuffer.*`](#arraybuffer)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.9.3 `ArrayBuffer.prototype.*`: getting and slicing](#arraybufferprototype-getting-and-slicing)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.9.4 `ArrayBuffer.prototype.*`: resizing](#arraybufferprototype-resizing)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.10 Quick reference: Typed Arrays](#quick-reference-typed-arrays)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.10.1 `TypedArray.*`](#typedarray)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.10.2 `TypedArray.prototype.*`](#typedarrayprototype)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.10.3 `new «ElementType»Array()`](#new-elementtypearray)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.10.4 `«ElementType»Array.*`](#elementtypearray)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.10.5 `«ElementType»Array.prototype.*`](#elementtypearrayprototype)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.11 Quick reference: DataViews](#quick-reference-dataviews)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.11.1 `new DataView()`](#new-dataview)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.11.2 `DataView.prototype.*`](#dataviewprototype)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[35.1 The Typed Array API: containers for binary data](#the-typed-array-api-containers-for-binary-data)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Much data on the web is text: JSON files, HTML files, CSS files, JavaScript
    code, etc. JavaScript handles such data well via its built-in strings.'
  prefs: []
  type: TYPE_NORMAL
- en: However, before 2011, it did not handle binary data well. [The Typed Array Specification
    1.0](https://web.archive.org/web/20160529225618/https://www.khronos.org/registry/typedarray/specs/1.0/)
    was introduced on February 8, 2011 and provides tools for working with binary
    data. With ECMAScript 6, Typed Arrays were added to the core language and gained
    methods that were previously only available for normal Arrays (`.map()`, `.filter()`,
    etc.).
  prefs: []
  type: TYPE_NORMAL
- en: '[35.1.1 Use cases for Typed Arrays](#use-cases-for-typed-arrays)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The main uses cases for Typed Arrays are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Processing binary data: managing image data, manipulating binary files, handling
    binary network protocols, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interacting with native APIs: Native APIs often receive and return data in
    a binary format, which we could neither store nor manipulate well in pre-ES6 JavaScript.
    That meant that whenever we were communicating with such an API, data had to be
    converted from JavaScript to binary and back for every call. Typed Arrays eliminate
    this bottleneck. Examples include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[WebGL](https://www.khronos.org/webgl/), “a low-level 3D graphics API based
    on OpenGL ES, exposed to ECMAScript via the HTML5 Canvas element”. Typed Arrays
    were initially created for WebGL. Section [“History of Typed Arrays”](https://web.dev/articles/webgl-typed-arrays#toc-history)
    of the article [“Typed Arrays: Binary Data in the Browser”](https://web.dev/articles/webgl-typed-arrays#toc-history)
    (by Ilmari Heikkinen for HTML5 Rocks) has more information.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[WebGPU](https://www.w3.org/TR/webgpu/), “an API for performing operations,
    such as rendering and computation, on a Graphics Processing Unit”. For example,
    WebGPU uses ArrayBuffers as wrappers for backing stores.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[WebAssembly](https://webassembly.org) (short: “Wasm”), “a binary instruction
    format for a stack-based virtual machine. Wasm is designed as a portable compilation
    target for programming languages, enabling deployment on the web for client and
    server applications.” For example, the memory of WebAssembly code is stored in
    an ArrayBuffer or a SharedArrayBuffer ([details](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Memory)).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[35.1.2 The core classes: `ArrayBuffer`, Typed Arrays, `DataView`](#typed-array-api-classes)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Typed Array API stores binary data in instances of `ArrayBuffer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An ArrayBuffer itself is a black box: if we want to access its data, we must
    wrap it in another object – a *view object*. Two kinds of view objects are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Typed Arrays* work similarly to normal Arrays and let us access the data as
    an indexed sequence of elements that all have the same type. Examples include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Uint8Array`: Elements are unsigned 8-bit integers. *Unsigned* means that their
    ranges start at zero.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int16Array`: Elements are signed 16-bit integers. *Signed* means that they
    have a sign and can be negative, zero, or positive.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Float16Array`: Elements are 16-bit floating point numbers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*DataViews* let us interpret the data as various types (`Uint8`, `Int16`, `Float16`,
    etc.) that we can read and write at any byte offset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 35.1](#fig:typed_arrays_class_diagram) shows a class diagram of the
    API.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a115834d4de67018f7d77365cf61bfce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 35.1: The classes of the Typed Array API.'
  prefs: []
  type: TYPE_NORMAL
- en: '[35.1.3 `SharedArrayBuffer` ^(ES2017)](#SharedArrayBuffer)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: SharedArrayBuffer is an ArrayBuffer whose memory can be accessed by multiple
    *agents* (an agent being the main thread or a web worker) concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: Where ArrayBuffers can be [*transferred*](#transferring-detaching-array-buffers)
    (moved, not copied) between agents, SharedArrayBuffers are not transferable and
    must be cloned. However, that only clones their outer parts. The data storage
    itself is shared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SharedArrayBuffers can be [resized](#resizing-array-buffers) but they can only
    grow not shrink because shrinking shared memory is too complicated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Atomics` is a global namespace for an API that complements SharedArrayBuffers.
    The ECMAScript specification [describes it](https://tc39.es/ecma262/#sec-atomics-object)
    as “functions that operate indivisibly (atomically) on shared memory array cells
    as well as functions that let agents wait for and dispatch primitive events. When
    used with discipline, the Atomics functions allow multi-agent programs that communicate
    through shared memory to execute in a well-understood order even on parallel CPUs.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See MDN Web Docs for more information on [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer)
    and [`Atomics`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics).
  prefs: []
  type: TYPE_NORMAL
- en: '[35.2 Using Typed Arrays](#using-typed-arrays)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Typed Arrays are used much like normal Arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[35.2.1 Creating Typed Arrays](#creating-typed-arrays)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following code shows three different ways of creating the same Typed Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1] `const ta3 = Uint8Array.from([0, 1, 2]);` `assert.deepEqual(ta3, ta1);`  ``
    `const ta4 = new Uint8Array(3); // length of Typed Array` `ta4[0] = 0;` `ta4[1]
    = 1;` `ta4[2] = 2;` `assert.deepEqual(ta4, ta1);` `` [PRE2]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3][PRE4][PRE5][PRE6]``js[PRE7]js[PRE8]`js[PRE9]js` #### [35.2.3 Getting
    and setting elements](#getting-and-setting-elements)    [PRE10]js   [PRE11]`js[PRE12]js[PRE13]js[PRE14]js[PRE15]js[PRE16]js[PRE17]`js[PRE18]js[PRE19][PRE20][PRE21]js
    const float16 = new Float16Array(1); function setAndGet(typedArray, value) {  typedArray[0]
    = value;  return typedArray[0]; }  [PRE22]js assert.equal(  setAndGet(float16,
    2**15),  32768 ); assert.equal(  setAndGet(float16, 2**16),  Infinity ); assert.equal(  2**16,  65536
    // float64 );  [PRE23]js assert.equal(  setAndGet(float16, -(2**15)),  -32768
    ); assert.equal(  setAndGet(float16, -(2**16)),  -Infinity ); assert.equal(  -(2**16),  -65536
    // float64 );  [PRE24]js assert.equal(  setAndGet(float16, 2**-24),  5.960464477539063e-8
    ); assert.equal(  setAndGet(float16, 2**-25),  0, ); assert.equal(  2**-25,  2.9802322387695312e-8
    // float64 );  [PRE25]js .from<S>(  source: Iterable<S>|ArrayLike<S>,  mapfn?:
    S => ElementType, thisArg?: any)  : «ElementType»Array  [PRE26]js assert.deepEqual(  Uint16Array.from([0,
    1, 2]),  Uint16Array.of(0, 1, 2));  [PRE27]js assert.deepEqual(  Uint16Array.from(Uint8Array.of(0,
    1, 2)),  Uint16Array.of(0, 1, 2));  [PRE28]js assert.deepEqual(  Uint16Array.from({0:0,
    1:1, 2:2, length: 3}),  Uint16Array.of(0, 1, 2));  [PRE29]js const typedArray
    = Int8Array.of(127, 126, 125); assert.deepEqual(  Int16Array.from(typedArray,
    x => x * 2),  Int16Array.of(254, 252, 250));  `assert.deepEqual(`  `Int16Array.from(typedArray).map(x
    => x * 2),`  `Int16Array.of(254, 252, 250)); // OK` `assert.deepEqual(`  `Int16Array.from(typedArray.map(x
    => x * 2)),`  `Int16Array.of(-2, -4, -6)); // wrong`  [PRE30]js[PRE31]js[PRE32][PRE33]
    Converting UTF-8-encoded bytes to a string:    [PRE34]js   [PRE35] ### [35.6 Resizing
    ArrayBuffers ^(ES2024)](#resizing-array-buffers)    Before ArrayBuffers became
    resizable, they had fixed sizes. If we wanted one to grow or shrink, we had to
    allocate a new one and copy the old one over. That costs time and can fragment
    the address space on 32-bit systems.    #### [35.6.1 New features for ArrayBuffers](#new-features-for-arraybuffers)    These
    are the changes introduced by resizing:    *   The existing constructor gets one
    more parameter:                    [PRE36]           *   There is one new method
    and two new getters:               *   `ArrayBuffer.prototype.resize(newByteLength:
    number)`         *   Resizes the ArrayBuffer.     *   `get ArrayBuffer.prototype.resizable`         *   Returns
    a boolean indicating if this ArrayBuffer is resizable.     *   `get ArrayBuffer.prototype.maxByteLength`         *   Returns
    `options.maxByteLength` if it was provided to the constructor. Otherwise, it returns
    `this.byteLength`. *   The existing method `.slice()` always returns non-resizable
    ArrayBuffers.              The `options` object of the constructor determines
    whether or not an ArrayBuffer is resizable:    [PRE37]   [PRE38][PRE39]``js[PRE40]``
    If an ArrayBuffer is resized then a wrapper with a fixed length can *go out of
    bounds*: The wrapper’s range isn’t covered by the ArrayBuffer anymore. That is
    treated by JavaScript as if the ArrayBuffer were [*detached*](#transferring-detaching-array-buffers):    *   `.length`,
    `.byteLength` and `.byteOffset` are zero. *   Getting elements returns `undefined`.
    *   Setting elements is silently ignored. *   All element-related methods throw
    errors.    [PRE41]    #### [35.6.3 Guidelines given by the ECMAScript specification](#guidelines-given-by-the-ecmascript-specification)    The
    ECMAScript specification gives [the following guidelines](https://tc39.es/ecma262/#sec-resizable-arraybuffer-guidelines)
    for working with resizable ArrayBuffers:    *   We recommend that programs be
    tested in their deployment environments where possible. The amount of available
    physical memory differs greatly between hardware devices. Similarly, virtual memory
    subsystems also differ greatly between hardware devices as well as operating systems.
    An application that runs without out-of-memory errors on a 64-bit desktop web
    browser could run out of memory on a 32-bit mobile web browser.           *   When
    choosing a value for the `maxByteLength` option for resizable ArrayBuffer, we
    recommend that the smallest possible size for the application be chosen. We recommend
    that `maxByteLength` does not exceed 1,073,741,824 (2^(30) bytes or 1 GiB).           *   Please
    note that successfully constructing a resizable ArrayBuffer for a particular maximum
    size does not guarantee that future resizes will succeed.              ### [35.7 Transferring
    and detaching ArrayBuffers ^(ES2024)](#transferring-detaching-array-buffers)    ####
    [35.7.1 Preparation: transferring data and detaching](#preparation-transferring-data-and-detaching)    The
    web API (not the ECMAScript standard) has long supported [*structured cloning*](https://html.spec.whatwg.org/multipage/structured-data.html#safe-passing-of-structured-data)
    for safely moving values across realms (`globalThis`, iframes, web workers, etc.).
    Some objects can also be *transferred*: After cloning, the original becomes *detached*
    (inaccessible) and ownership switches from the original to the clone. Transferring
    is usually faster than copying, especially if large amounts of memory are involved.
    These are the most common classes of [*transferable objects*](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Transferable_objects):    *   `ArrayBuffer`
    *   Streams:     *   `ReadableStream`     *   `TransformStream`     *   `WritableStream`
    *   DOM-related data:     *   `ImageBitmap`     *   `OffscreenCanvas` *   Miscellaneous
    communication:     *   `MessagePort`     *   `RTCDataChannel`    #### [35.7.2 Methods
    related to transferring and detaching](#methods-related-to-transferring-and-detaching)    *   Two
    methods let us explicitly transfer an ArrayBuffer to a new object (we’ll see soon
    why that is useful):     *   `ArrayBuffer.prototype.transfer(newLength?: number)`     *   `ArrayBuffer.prototype.transferToFixedLength(newLength?:
    number)` *   One getter tells us if an ArrayBuffer is detached:     *   `get ArrayBuffer.prototype.detached`    ####
    [35.7.3 Transferring ArrayBuffers via `structuredClone()`](#transferring-arraybuffers-via-structuredclone)    The
    broadly supported [`structuredClone()`](ch_objects.html#structuredClone) also
    lets us transfer (and therefore detach) ArrayBuffers:    [PRE42]   [PRE43]`` [PRE44]`
    [PRE45]    The ArrayBuffer method `.transfer()` simply gives us a more concise
    way to detach an ArrayBuffer:    [PRE46]   [PRE47] #### [35.7.4 Transferring an
    ArrayBuffer within the same agent](#transferring-an-arraybuffer-within-the-same-agent)    Transferring
    is most often used between two *agents* (an agent being the main thread or a web
    worker). However, transferring within the same agent can make sense too: If a
    function gets a (potentially shared) ArrayBuffer as a parameter, it can transfer
    it so that no external code can interfere with what it does. Example (taken from
    [the ECMAScript proposal](https://github.com/tc39/proposal-arraybuffer-transfer?tab=readme-ov-file#ownership)
    and slightly edited):    [PRE48]js ``// `await` pauses this function – which gives
    external``  ``// code the opportunity to access `arrayBuffer`.``  `await validate(owned);`  `await
    fs.writeFile("data.bin", owned);` `}` [PRE49]js   [PRE50]`js [PRE51]js`` [PRE52]js[PRE53][PRE54][PRE55][PRE56]js[PRE57]js`
    [PRE58]`js`` [PRE59]`js[PRE60][PRE61][PRE62] [PRE63][PRE64][PRE65][PRE66][PRE67]``
    [PRE68][PRE69][PRE70] [PRE71]`js[PRE72]js[PRE73]js[PRE74]js[PRE75]js[PRE76]js`
    [PRE77]`js[PRE78]js[PRE79]```'
  prefs: []
  type: TYPE_NORMAL
