<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>35 Extracting parts of compound types via infer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>35 Extracting parts of compound types via infer</h1>
<blockquote>原文：<a href="https://exploringjs.com/ts/book/ch_infer-keyword.html">https://exploringjs.com/ts/book/ch_infer-keyword.html</a></blockquote>

    
        <div id="adbox">
      <div id="adbox-explain">(Ad, please don’t block.)</div>
              
          </div>
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#infer-extracting-types-inside-the-extends-clause-of-a-conditional-type">35.1 <code>infer</code>: extracting types inside the <code>extends</code> clause of a conditional type</a>
      <ol>
        <li>
          <a href="#example-extracting-property-keys-and-values-via-record">35.1.1 Example: extracting property keys and values via <code>Record</code></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#constraining-infer-via-extends">35.2 Constraining <code>infer</code> via <code>extends</code></a>
    </li>
    <li>
      <a href="#built-in-utility-types-that-use-infer">35.3 Built-in utility types that use <code>infer</code></a>
      <ol>
        <li>
          <a href="#extracting-parts-of-function-types">35.3.1 Extracting parts of function types via <code>infer</code></a>
        </li>
        <li>
          <a href="#extracting-parts-of-class-types-via-infer">35.3.2 Extracting parts of class types via <code>infer</code></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#example-synchronous-version-of-an-asynchronous-interface">35.4 Example: synchronous version of an asynchronous interface</a>
    </li>
    <li>
      <a href="#using-infer-to-define-local-type-variables">35.5 Using <code>infer</code> to define local type variables</a>
    </li>
    <li>
      <a href="#sources-of-this-chapter-5">35.6 Sources of this chapter</a>
    </li>
  </ol>
</nav>
<p>In this chapter, we explore how we can extract parts of compound types via the <code>infer</code> keyword.</p>
<p>It helps if you are loosely familiar with <a href="ch_conditional-types.html#ch_conditional-types">conditional types</a>.</p>
<h3 id="infer-extracting-types-inside-the-extends-clause-of-a-conditional-type"><a class="heading-id-link" href="#infer-extracting-types-inside-the-extends-clause-of-a-conditional-type">35.1 <code>infer</code>: extracting types inside the <code>extends</code> clause of a conditional type</a></h3>
<p><code>infer</code> is used inside the constraint part of a conditional type:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Type</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Constraint</span> ? &lt;then&gt; : &lt;<span class="hljs-keyword">else</span>&gt;;</code>
</pre>
<p>A constraint can be a type pattern – e.g.:</p>
<pre class="language-ts">
<code>T[]</code>
<code><span class="hljs-title class_">Promise</span>&lt;T&gt;</code>
<code><span class="hljs-function">(<span class="hljs-params">arg: T</span>) =&gt;</span> R</code>
</pre>
<p>At any location where we can mention an existing type variable (such as <code>T</code> or <code>R</code> in the previous examples), we can also introduce a new type variable <code>X</code> via <code>infer X</code>. Let’s look at an example: The following generic type <code>ElemType&lt;Arr&gt;</code> extracts the element type of an Array type:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ElemType</span>&lt;<span class="hljs-title class_">Arr</span>&gt; = <span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;infer <span class="hljs-title class_">Elem</span>&gt; ? <span class="hljs-title class_">Elem</span> : <span class="hljs-built_in">never</span>;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">ElemType</span>&lt;<span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;, <span class="hljs-built_in">string</span></code>
<code>&gt;&gt;;</code>
</pre>
<p><code>infer</code> has a lot in common with <a href="https://exploringjs.com/js/book/ch_destructuring.html#ch_destructuring">destructuring</a> in JavaScript.</p>
<h4 id="example-extracting-property-keys-and-values-via-record"><a class="heading-id-link" href="#example-extracting-property-keys-and-values-via-record">35.1.1 Example: extracting property keys and values via <code>Record</code></a></h4>
<p>The utility type <code>Record</code> lets us implement the <code>keyof</code> operator ourselves:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-title class_">Color</span> = {</code>
<code>  <span class="hljs-attr">red</span>: <span class="hljs-number">0</span>,</code>
<code>  <span class="hljs-attr">green</span>: <span class="hljs-number">1</span>,</code>
<code>  <span class="hljs-attr">blue</span>: <span class="hljs-number">2</span>,</code>
<code>} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code>
<code/>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">KeyOf</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span>&lt;infer K, <span class="hljs-built_in">any</span>&gt; ? K : <span class="hljs-built_in">never</span>;</code>
<code><span class="hljs-keyword">type</span> _1 = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">KeyOf</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Color</span>&gt;,</code>
<code>  <span class="hljs-string">"red"</span> | <span class="hljs-string">"green"</span> | <span class="hljs-string">"blue"</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>We can also implement a utility type <code>PropValues</code> that extracts property values:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">PropValues</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">any</span>, infer V&gt; ? V : <span class="hljs-built_in">never</span>;</code>
<code><span class="hljs-keyword">type</span> _2 = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">PropValues</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Color</span>&gt;,</code>
<code>  <span class="hljs-number">0</span> | <span class="hljs-number">1</span> | <span class="hljs-number">2</span></code>
<code>&gt;&gt;;</code>
</pre>
<h3 id="constraining-infer-via-extends"><a class="heading-id-link" href="#constraining-infer-via-extends">35.2 Constraining <code>infer</code> via <code>extends</code></a></h3>
<p>In some cases, we need to help <code>infer</code> by using <code>extends</code> to constrain what can be inferred – e.g. (based on <a href="https://mastodon.social/@hcschuetz/114127961269403080">an idea by Heribert Schütz</a>):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">EnumFromTuple</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; =</code>
<code>  T <span class="hljs-keyword">extends</span> [</code>
<code>    infer <span class="hljs-title class_">First</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, <span class="hljs-comment">// (A)</span></code>
<code>    ...infer <span class="hljs-title class_">Rest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-comment">// (B)</span></code>
<code>  ]</code>
<code>    ? <span class="hljs-title class_">Record</span>&lt;<span class="hljs-title class_">First</span>, <span class="hljs-title class_">First</span>&gt; &amp; <span class="hljs-title class_">EnumFromTuple</span>&lt;<span class="hljs-title class_">Rest</span>&gt;</code>
<code>    : {}</code>
<code>  ;</code>
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt; <span class="hljs-comment">// (C)</span></code>
<code>    <span class="hljs-title class_">EnumFromTuple</span>&lt;[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]&gt;,</code>
<code>    <span class="hljs-title class_">Record</span>&lt;<span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>&gt; &amp; <span class="hljs-title class_">Record</span>&lt;<span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>&gt;</code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt; <span class="hljs-comment">// (D)</span></code>
<code>    <span class="hljs-title class_">EnumFromTuple</span>&lt;[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]&gt;,</code>
<code>    { <span class="hljs-attr">a</span>: <span class="hljs-string">'a'</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">'b'</span> }</code>
<code>  &gt;&gt;,</code>
<code>];</code>
</pre>
<p>Notes:</p>
<ul>
  <li>
    This code does not work without the two <code>extends</code> in line A and line B.
  </li>
  <li>
    Line C shows us the exact result produced by <code>EnumFromTuple</code>.
  </li>
  <li>
    Line D shows us that the result is assignable from and to a simple object literal type.
  </li>
</ul>
<h3 id="built-in-utility-types-that-use-infer"><a class="heading-id-link" href="#built-in-utility-types-that-use-infer">35.3 Built-in utility types that use <code>infer</code></a></h3>
<p>TypeScript has several built-in <a href="https://www.typescriptlang.org/docs/handbook/utility-types.html">utility types</a>. In this section, we look at those that use <code>infer</code>.</p>
<h4 id="extracting-parts-of-function-types"><a class="heading-id-link" href="#extracting-parts-of-function-types">35.3.1 Extracting parts of function types via <code>infer</code></a></h4>
<pre class="language-ts">
<code><span class="hljs-comment">/**</span></code>
<code><span class="hljs-comment"> * Obtain the parameters of a function type in a tuple</span></code>
<code><span class="hljs-comment"> */</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Parameters</span>&lt;T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span>&gt; =</code>
<code>  T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: infer P) =&gt; <span class="hljs-built_in">any</span> ? P : <span class="hljs-built_in">never</span>;</code>
<code/>
<code><span class="hljs-comment">/**</span></code>
<code><span class="hljs-comment"> * Obtain the return type of a function type</span></code>
<code><span class="hljs-comment"> */</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReturnType</span>&lt;T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span>&gt; =</code>
<code>  T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; infer R ? R : <span class="hljs-built_in">any</span>;</code>
</pre>
<p>Both of these utility types are straightforward: We put <code>infer</code> where we want to extract a type. Let’s use both types:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {</code>
<code>  <span class="hljs-keyword">return</span> x + y;</code>
<code>}</code>
<code><span class="hljs-keyword">type</span> _1 = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-keyword">typeof</span> add,</code>
<code>  <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span></code>
<code>&gt;&gt;;</code>
<code><span class="hljs-keyword">type</span> _2 = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-keyword">typeof</span> add&gt;,</code>
<code>  [<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>]</code>
<code>&gt;&gt;;</code>
<code><span class="hljs-keyword">type</span> _3 = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> add&gt;,</code>
<code>  <span class="hljs-built_in">number</span></code>
<code>&gt;&gt;;</code>
</pre>
<h4 id="extracting-parts-of-class-types-via-infer"><a class="heading-id-link" href="#extracting-parts-of-class-types-via-infer">35.3.2 Extracting parts of class types via <code>infer</code></a></h4>
<p>The following non-built-in utility type for classes demonstrate how <a href="ch_classes-as-values.html#construct-signatures"><em>construct signatures</em></a> work:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Class</span>&lt;T&gt; = <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">any</span>&gt;) =&gt; T;</code>
</pre>
<p>This type includes all classes whose instances have the type <code>T</code>. The keyword <code>abstract</code> means that it includes both abstract and concrete classes. Without that keyword, it would only include classes that are instantiable.</p>
<p>Construct signatures enable us to extract parts of classes:</p>
<pre class="language-ts">
<code><span class="hljs-comment">/**</span></code>
<code><span class="hljs-comment"> * Obtain the parameters of a constructor function type in a tuple</span></code>
<code><span class="hljs-comment"> */</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ConstructorParameters</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span>&gt; =</code>
<code>  T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">new</span> (...<span class="hljs-attr">args</span>: infer P) =&gt; <span class="hljs-built_in">any</span> ? P : <span class="hljs-built_in">never</span>;</code>
<code/>
<code><span class="hljs-comment">/**</span></code>
<code><span class="hljs-comment"> * Obtain the return type of a constructor function type</span></code>
<code><span class="hljs-comment"> */</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">InstanceType</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span>&gt; =</code>
<code>  T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; infer R ? R : <span class="hljs-built_in">any</span>;</code>
</pre>
<p>To demonstrate these utility types, let’s define a class we can apply them to:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {</code>
<code>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;</code>
<code>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;</code>
<code>  }</code>
<code>}</code>
</pre>
<p>Note that the class <code>Point</code> defines two things:</p>
<ul>
  <li>
    A type: the type <code>Point</code> for instances of the class.
  </li>
  <li>
    A value: a factory for objects whose type is <code>Point</code>. That value has the type <code>Class&lt;Point&gt;</code>.
  </li>
</ul>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">pointAsValue</span>: <span class="hljs-title class_">Class</span>&lt;<span class="hljs-title class_">Point</span>&gt; = <span class="hljs-title class_">Point</span>;</code>
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">ConstructorParameters</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Point</span>&gt;,</code>
<code>    [<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>]</code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">InstanceType</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Point</span>&gt;,</code>
<code>    <span class="hljs-title class_">Point</span></code>
<code>  &gt;&gt;,</code>
<code>];</code>
</pre>
<h3 id="example-synchronous-version-of-an-asynchronous-interface"><a class="heading-id-link" href="#example-synchronous-version-of-an-asynchronous-interface">35.4 Example: synchronous version of an asynchronous interface</a></h3>
<p>The following example is a little more complex: It converts all asynchronous methods in an object type to synchronous methods:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Syncify</span>&lt;<span class="hljs-title class_">Intf</span>&gt; = {</code>
<code>  [K <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Intf</span>]:</code>
<code>    <span class="hljs-title class_">Intf</span>[K] <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: infer A) =&gt; <span class="hljs-title class_">Promise</span>&lt;infer R&gt; <span class="hljs-comment">// (A)</span></code>
<code>    ? <span class="hljs-function">(<span class="hljs-params">...args: A</span>) =&gt;</span> R <span class="hljs-comment">// (B)</span></code>
<code>    : <span class="hljs-title class_">Intf</span>[K] <span class="hljs-comment">// (C)</span></code>
<code>};</code>
</pre>
<ul>
  <li>
    Condition: Is the current property value <code>Intf[K]</code> a function? (Line A)
  </li>
  <li>
    If yes: The new property value is a function with the same parameters <code>A</code> but an unwrapped return type <code>R</code>. (Line B)
  </li>
  <li>
    If no: The new property value is the same as the old property value. (Line C)
  </li>
</ul>
<p>Let’s apply <code>Syncify</code> to an interface <code>AsyncService</code> with Promise-based methods:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">AsyncService</span> {</code>
<code>  <span class="hljs-title function_">factorize</span>(<span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt;&gt;;</code>
<code>  <span class="hljs-title function_">createDigest</span>(<span class="hljs-attr">text</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;;</code>
<code>}</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">SyncService</span> = <span class="hljs-title class_">Syncify</span>&lt;<span class="hljs-title class_">AsyncService</span>&gt;;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">SyncService</span>,</code>
<code>  {</code>
<code>    <span class="hljs-attr">factorize</span>: <span class="hljs-function">(<span class="hljs-params">num: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt;,</code>
<code>    <span class="hljs-attr">createDigest</span>: <span class="hljs-function">(<span class="hljs-params">text: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">string</span>,</code>
<code>  }</code>
<code>&gt;&gt;;</code>
</pre>
<h3 id="using-infer-to-define-local-type-variables"><a class="heading-id-link" href="#using-infer-to-define-local-type-variables">35.5 Using <code>infer</code> to define local type variables</a></h3>
<p>We can use <code>infer</code> to define local type variables such as <code>W</code> below:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">WrapTriple</span>&lt;T&gt; = <span class="hljs-title class_">Promise</span>&lt;T&gt; <span class="hljs-keyword">extends</span> infer W</code>
<code>  ? [W, W, W]</code>
<code>  : <span class="hljs-built_in">never</span></code>
<code>;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">WrapTriple</span>&lt;<span class="hljs-built_in">number</span>&gt;,</code>
<code>  [<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">number</span>&gt;, <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">number</span>&gt;, <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">number</span>&gt;]</code>
<code>&gt;&gt;;</code>
</pre>
<p>For more information, see <a href="ch_computing-with-types-overview.html#local-type-variables">“Defining local type variables” (§33.8)</a>.</p>
<h3 id="sources-of-this-chapter-5"><a class="heading-id-link" href="#sources-of-this-chapter-5">35.6 Sources of this chapter</a></h3>
<ul>
  <li>
    Section <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-2-8-2/#inferring-within-conditional-types">“Inferring within conditional types”</a> in the blog post announcing TypeScript 2.8.
  </li>
  <li>
    Section <a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types">“Inferring Within Conditional Types”</a> in the official TypeScript Handbook.
  </li>
</ul>

    
      
</body>
</html>