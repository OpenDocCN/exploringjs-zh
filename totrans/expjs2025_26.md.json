["```js\nconst str1 = 'Don\\'t say \"goodbye\"'; // string literal\nconst str2 = \"Don't say \\\"goodbye\\\"\"; // string literals\nassert.equal(\n `As easy as ${123}!`, // template literal\n 'As easy as 123!',\n);\n\n```", "```js\nassert.equal(\n String.raw`\\ \\n\\t`, // (A)\n '\\\\ \\\\n\\\\t',\n);\n\n```", "```js\n> String(undefined)\n'undefined'\n> String(null)\n'null'\n> String(123.45)\n'123.45'\n> String(true)\n'true'\n\n```", "```js\n// There is no type for characters;\n// reading characters produces strings:\nconst str3 = 'abc';\nassert.equal(\n str3[2], 'c' // no negative indices allowed\n);\nassert.equal(\n str3.at(-1), 'c' // negative indices allowed\n);\n `// Copying more than one character:`\n`assert.equal(`\n `'abc'.slice(0, 2), 'ab'`\n`);` \n```", "```js```", "````js````", "```js assert.equal(  'I bought ' + 3 + ' apples',  'I bought 3 apples', );  `let str = '';` `str += 'I bought ';` `str += 3;` `str += ' apples';` `assert.equal(`  `str, 'I bought 3 apples',` `);`  ```", "```js```", "````js````", "```js const graphemeCluster = 'üòµ‚Äçüí´'; assert.equal(  // 5 JavaScript characters  'üòµ‚Äçüí´'.length, 5 ); assert.deepEqual(  // Iteration splits into code points  Array.from(graphemeCluster),  ['üòµ', '\\u200D', 'üí´'] );  ```", "```js > 'abca'.includes('a') true > 'abca'.startsWith('ab') true > 'abca'.endsWith('ca') true  `> 'abca'.indexOf('a')` `0` `> 'abca'.lastIndexOf('a')` `3`  ```", "```js```", "````js``` Splitting and joining:    ``` assert.deepEqual(  'a, b,c'.split(/, ?/),  ['a', 'b', 'c'] ); assert.equal(  ['a', 'b', 'c'].join(', '),  'a, b, c' );  ```js    Padding and trimming:    ``` > '7'.padStart(3, '0') '007' > 'yes'.padEnd(6, '!') 'yes!!!'  `> '\\t abc\\n '.trim()` `'abc'` `> '\\t abc\\n '.trimStart()` `'abc\\n '` `> '\\t abc\\n '.trimEnd()` `'\\t abc'`  ```js   ````", "`````` Repeating and changing case:    ```js > '*'.repeat(5) '*****' > '= b2b ='.toUpperCase() '= B2B =' > 'ŒëŒíŒì'.toLowerCase() 'Œ±Œ≤Œ≥'  ```    ### [22.2‚ÄÉPlain string literals](#plain-string-literals)    Plain string literals are delimited by either single quotes or double quotes:    ```js const str1 = 'abc'; const str2 = \"abc\"; assert.equal(str1, str2);  ```    Single quotes are used more often because it makes it easier to mention HTML, where double quotes are preferred.    [The next chapter](ch_template-literals.html#ch_template-literals) covers *template literals*, which give us:    *   String interpolation *   Multiple lines *   Raw string literals (backslash has no special meaning)    #### [22.2.1‚ÄÉEscaping](#escaping)    The backslash lets us create special characters:    *   Unix line break: `'\\n'` *   Windows line break: `'\\r\\n'` *   Tab: `'\\t'` *   Backslash: `'\\\\'`    The backslash also lets us use the delimiter of a string literal inside that literal:    ```js assert.equal(  'She said: \"Let\\'s go!\"',  \"She said: \\\"Let's go!\\\"\");  ```    ### [22.3‚ÄÉAccessing JavaScript characters](#accessing-javascript-characters)    JavaScript has no extra data type for characters ‚Äì characters are always represented as strings.    ```js const str = 'abc';  `// Reading a JavaScript character at a given index` `assert.equal(str[1], 'b');`  `` `// Counting the JavaScript characters in a string:` `assert.equal(str.length, 3);` ``  ```   ```js``````", "``````js```` The characters we see on screen are called *grapheme clusters*. Most of them are represented by single JavaScript characters. However, there are also grapheme clusters (especially emojis) that are represented by multiple JavaScript characters:    ```js > 'üôÇ'.length 2  ```    How that works is explained in [‚ÄúAtoms of text: code points, JavaScript characters, grapheme clusters‚Äù (¬ß22.7)](#atoms-of-text).    ### [22.4‚ÄÉString concatenation](#string-concatenation)    #### [22.4.1‚ÄÉString concatenation via `+`](#string-concatenation-via-plus)    If at least one operand is a string, the plus operator (`+`) converts any non-strings to strings and concatenates the result:    ```js assert.equal(3 + ' times ' + 4, '3 times 4');  ```    The assignment operator `+=` is useful if we want to assemble a string, piece by piece:    ```js let str = ''; // must be `let`! str += 'Say it'; str += ' one more'; str += ' time';  `assert.equal(str, 'Say it one more time');`  ```   ```js``````", "```js function getPackingList(isAbroad = false, days = 1) {  const items = [];  items.push('tooth brush');  if (isAbroad) {  items.push('passport');  }  if (days > 3) {  items.push('water bottle');  }  return items.join(', '); // (A) } assert.equal(  getPackingList(),  'tooth brush' ); assert.equal(  getPackingList(true, 7),  'tooth brush, passport, water bottle' );  ```", "```js class UnexpectedValueError extends Error {  constructor(value) {  super('Unexpected value: ' + value); // (A)  } }  ```", "```js > new UnexpectedValueError(Symbol()) TypeError: Cannot convert a Symbol value to a string > new UnexpectedValueError({__proto__:null}) TypeError: Cannot convert object to primitive value  ```", "```js > '' + Symbol() TypeError: Cannot convert a Symbol value to a string  ```", "```js > String({__proto__: null, [Symbol.toPrimitive]() {return 'YES'}}) 'YES' > String({__proto__: null, toString() {return 'YES'}}) 'YES' > String({__proto__: null, valueOf() {return 'YES'}}) 'YES'  `> String({__proto__: null}) // no method available` `TypeError: Cannot convert object to primitive value`  ```", "```js```", "```js > String({a: 1}) '[object Object]'  ```", "```js > String(['a', 'b']) 'a,b' > String(['a', ['b']]) 'a,b'  `> String([1, 2])` `'1,2'` `> String(['1', '2'])` `'1,2'`  `` `> String([true])` `'true'` `> String(['true'])` `'true'` `> String(true)` `'true'` ``  ```", "```js```", "```js```", "``` > Symbol.prototype[Symbol.toPrimitive]() TypeError: Symbol.prototype [ @@toPrimitive ] requires that 'this' be a Symbol > String(Symbol.prototype) TypeError: Symbol.prototype [ @@toPrimitive ] requires that 'this' be a Symbol  ```", "``` > JSON.stringify({a: 1}) '{\"a\":1}' > JSON.stringify(['a', ['b']]) '[\"a\",[\"b\"]]'  ```", "``` > JSON.stringify({__proto__: null, a: 1}) '{\"a\":1}'  ```", "``` > JSON.stringify(undefined) undefined > JSON.stringify(Symbol()) undefined > JSON.stringify(() => {}) undefined  ```", "``` > JSON.stringify(123n) TypeError: Do not know how to serialize a BigInt  ```", "``` > JSON.stringify({a: Symbol(), b: 2}) '{\"b\":2}'  ```", "``` > JSON.stringify(['a', Symbol(), 'b']) '[\"a\",null,\"b\"]'  ```", "``` assert.equal( JSON.stringify({first: 'Robin', last: 'Doe'}, null, 2), `{  \"first\": \"Robin\",  \"last\": \"Doe\" }` );  ```", "``` const strWithNewlinesAndTabs = ` TAB->\t<-TAB Second line  `; console.log(JSON.stringify(strWithNewlinesAndTabs));  ```", "``` \"\\nTAB->\\t<-TAB\\nSecond line \\n\"  ```", "``` function toString(v) {  if (typeof v === 'bigint') {  return v + 'n';  }  return JSON.stringify(v) ?? String(v); // (A) }  ```", "``` import * as util from 'node:util';  `const cycle = {};` `cycle.prop = cycle;` `assert.equal(`  `util.inspect(cycle),`  `'<ref *1> { prop: [Circular *1] }'` `);`  ```", "````` ##### [22.5.4.4‚ÄÉAlternative to stringification: logging data to the console](#alternative-to-stringification-logging-data-to-the-console)    Console methods such as `console.log()` tend to produce good output and have few limitations:    ```js console.log({__proto__: null, prop: Symbol()});  ```    Output:    ```js [Object: null prototype] { prop: Symbol() }  ```    However, by default, they only display objects up to a certain depth:    ```js console.log({a: {b: {c: {d: true}}}});  ```    Output:    ```js { a: { b: { c: [Object] } } }  ```    Node.js lets us specify the depth for `console.dir()` ‚Äì¬†with `null` meaning infinite:    ```js console.dir({a: {b: {c: {d: true}}}}, {depth: null});  ```    Output:    ```js {  a: { b: { c: { d: true } } } }  ```    In browsers, `console.dir()` does not have an options object but lets us interactively and incrementally descend into objects.    #### [22.5.5‚ÄÉCustomizing how objects are converted to strings](#customizing-how-objects-are-converted-to-strings)    ##### [22.5.5.1‚ÄÉCustomizing the string conversion of objects](#customizing-the-string-conversion-of-objects)    We can customize the built-in way of stringifying objects by implementing the method `.toString()`:    ```js const helloObj = {  toString() {  return 'Hello!';  } }; assert.equal(  String(helloObj), 'Hello!' );  ```    ##### [22.5.5.2‚ÄÉCustomizing the conversion to JSON](#customizing-the-conversion-to-json)    We can customize how an object is converted to JSON by implementing the method `.toJSON()`:    ```js const point = {  x: 1,  y: 2,  toJSON() {  return [this.x, this.y];  } } assert.equal(  JSON.stringify(point), '[1,2]' );  ```    ### [22.6‚ÄÉComparing strings](#comparing-strings)    Strings can be compared via the following operators:    ```js < <= > >=  ```    There is one important caveat to consider: These operators compare based on the numeric values of JavaScript characters. That means that the order that JavaScript uses for strings is different from the one used in dictionaries and phone books:    ```js > 'A' < 'B' // ok true > 'a' < 'B' // not ok false > '√§' < 'b' // not ok false  ```    Properly comparing text is beyond the scope of this book. It is supported via [the ECMAScript Internationalization API (`Intl`)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl).    ### [22.7‚ÄÉAtoms of text: code points, JavaScript characters, grapheme clusters](#atoms-of-text)    Quick recap of [‚ÄúUnicode ‚Äì a brief introduction (advanced)‚Äù (¬ß21)](ch_unicode.html#ch_unicode):    *   *Code points* are the atomic parts of Unicode text. Each code point is 21 bits in size.           *   Each *JavaScript* character is a UTF-16 code unit (16 bits). We need one to two code units to encode a code point. Most code points fit into one code unit.           *   *Grapheme clusters* (*user-perceived characters*) represent written symbols, as displayed on screen or paper. One or more code points are needed to encode a single grapheme cluster. Most grapheme clusters are one code point long.              The following code demonstrates that a single code point comprises one or two JavaScript characters. We count the latter via `.length`:    ```js // 3 code points, 3 JavaScript characters: assert.equal('abc'.length, 3);  `// 1 code point, 2 JavaScript characters:` `assert.equal('üôÇ'.length, 2);`  ```   ```js` The following table summarizes the concepts we have just explored:     | Entity | Size | Encoded via | | --- | --- | --- | | JavaScript character (UTF-16 code unit) | 16 bits | ‚Äì | | Unicode code point | 21 bits | 1‚Äì2 code units | | Unicode grapheme cluster |  | 1+ code points |    #### [22.7.1‚ÄÉWorking with code units (JavaScript characters)](#working-with-code-units-javascript-characters)    Indices and lengths of strings are based on JavaScript characters ‚Äì which are UTF-16 code units.    ##### [22.7.1.1‚ÄÉAccessing code units](#accessing-code-units)    Code units are accessed like Array elements:    ``` > const str = 'Œ±Œ≤Œ≥'; > str.length 3 > str[0] 'Œ±'  ```js    `str.split('')` splits into code units:    ``` > str.split('') [ 'Œ±', 'Œ≤', 'Œ≥' ] > 'AüôÇ'.split('') [ 'A', '\\uD83D', '\\uDE42' ]  ```js    The emoji üôÇ consists of two code units.    ##### [22.7.1.2‚ÄÉEscaping code units](#escaping-code-units)    To specify a code unit hexadecimally, we can use a *Unicode code unit escape* with exactly four hexadecimal digits:    ``` > '\\u03B1\\u03B2\\u03B3' 'Œ±Œ≤Œ≥'  ```js    **ASCII escapes:** If the code point of a character is below 256, we can refer to it via an *ASCII escape* with exactly two hexadecimal digits:    ``` > 'He\\x6C\\x6Co' 'Hello'  ```js    ![Icon ‚Äúdetails‚Äù](../Images/38ba63de820aae6f94a019538ae0f222.png)‚ÄÇ**Official name of an ASCII escape: hexadecimal escape sequence**    It was the first escape that used hexadecimal numbers.    ##### [22.7.1.3‚ÄÉConverting code units to numbers (char codes)](#converting-code-units-to-numbers-char-codes)    To get the char code of a character, we can use `.charCodeAt()`:    ``` > 'Œ±'.charCodeAt(0).toString(16) '3b1'  ```js    `String.fromCharCode()` converts a char code to a string:    ``` > String.fromCharCode(0x3B1) 'Œ±'  ```js    #### [22.7.2‚ÄÉWorking with code points](#working-with-code-points)    ##### [22.7.2.1‚ÄÉAccessing code points](#accessing-code-points)    Iteration (which is described [later in this book](ch_sync-iteration.html#ch_sync-iteration)) splits strings into code points:    ``` const codePoints = 'AüôÇ'; for (const codePoint of codePoints) {  console.log(codePoint + ' ' + codePoint.length); }  ```js    Output:    ``` A 1 üôÇ 2  ```js    `Array.from()` uses iteration:    ``` > Array.from('AüôÇ') [ 'A', 'üôÇ' ]  ```js    Therefore, this is how we can count the number of code points in a string:    ``` > Array.from('AüôÇ').length 2 > 'AüôÇ'.length 3  ```js    ##### [22.7.2.2‚ÄÉEscaping code points](#escaping-code-points)    A *Unicode code point escape* lets us specify a code point hexadecimally (1‚Äì5 digits). It produces one or two JavaScript characters.    ``` > '\\u{1F642}' 'üôÇ'  ```js    ##### [22.7.2.3‚ÄÉConverting code points in strings to numbers](#converting-code-points-in-strings-to-numbers)    `.codePointAt()` returns the code point number for a sequence of 1‚Äì2 JavaScript characters:    ``` > 'üôÇ'.codePointAt(0).toString(16) '1f642'  ```js    `String.fromCodePoint()` converts a code point number to 1‚Äì2 JavaScript characters:    ``` > String.fromCodePoint(0x1F642) 'üôÇ'  ```js    ##### [22.7.2.4‚ÄÉRegular expressions for code points](#regular-expressions-for-code-points)    If we use the flag `/v` for a regular expression, it supports Unicode better and matches code points not code units:    ``` > 'üôÇ'.match(/./g) [ '\\uD83D', '\\uDE42' ] > 'üôÇ'.match(/./gv) [ 'üôÇ' ]  ```js    More information: [‚ÄúFlag `/v`: limited support for multi-code-point grapheme clusters ^(ES2024)‚Äù (¬ß46.11.4)](ch_regexps.html#regexp-flag-unicode-sets).    #### [22.7.3‚ÄÉWorking with grapheme clusters](#working-with-grapheme-clusters)    ##### [22.7.3.1‚ÄÉAccessing grapheme clusters](#accessing-grapheme-clusters)    This is a grapheme cluster that consists of 3 code points:    ``` const graphemeCluster = 'üòµ‚Äçüí´'; assert.deepEqual(  // Iteration splits into code points  Array.from(graphemeCluster),  ['üòµ', '\\u200D', 'üí´'] ); assert.equal(  // 5 JavaScript characters  'üòµ‚Äçüí´'.length, 5 );  ```js    To split a string into grapheme clusters, we can use [`Intl.Segmenter`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter) ‚Äì a class that isn‚Äôt part of ECMAScript proper, but part of [the ECMAScript internationalization API](https://ecma-international.org/publications-and-standards/standards/ecma-402/). It is supported by most JavaScript platforms. This is how we can use it:    ``` const segmenter = new Intl.Segmenter('en-US', { granularity: 'grapheme' }); assert.deepEqual(  Array.from(segmenter.segment('AüôÇüòµ‚Äçüí´')),  [  { segment: 'A', index: 0, input: 'AüôÇüòµ‚Äçüí´' },  { segment: 'üôÇ', index: 1, input: 'AüôÇüòµ‚Äçüí´' },  { segment: 'üòµ‚Äçüí´', index: 3, input: 'AüôÇüòµ‚Äçüí´' },  ] );  ```js    `.segmenter()` returns an iterable over segment objects. We can use it via `for-of`, `Array.from()`, `Iterator.from()`, etc.    ##### [22.7.3.2‚ÄÉRegular expressions for grapheme clusters](#regular-expressions-for-grapheme-clusters)    The regular expression flag `/v` provides some limited support for grapheme clusters ‚Äì e.g., we can match emojis with potentially multiple code points like this:    ``` > 'AüôÇüòµ‚Äçüí´'.match(/\\p{RGI_Emoji}/gv) [ 'üôÇ', 'üòµ‚Äçüí´' ]  ```js    More information: [‚ÄúFlag `/v`: limited support for multi-code-point grapheme clusters ^(ES2024)‚Äù (¬ß46.11.4)](ch_regexps.html#regexp-flag-unicode-sets).    ### [22.8‚ÄÉQuick reference: Strings](#quickref-string)    #### [22.8.1‚ÄÉConverting to string](#converting-to-string)    [Table 22.1](#tbl:converting-to-string) describes how various values are converted to strings.     | `x` | `String(x)` | | --- | --- | | `undefined` | `'undefined'` | | `null` | `'null'` | | boolean | `false` ‚Üí `'false'`, `true` ‚Üí `'true'` | | number | Example: `123` ‚Üí `'123'` | | bigint | Example: `123n` ‚Üí `'123'` | | string | `x` (input, unchanged) | | symbol | Example: `Symbol('abc')` ‚Üí `'Symbol(abc)'` | | object | Configurable via, e.g., `toString()` |      Table 22.1: Converting values to strings.      #### [22.8.2‚ÄÉNumeric values of text atoms](#numeric-values-of-text-atoms)    *   **Char code**: number representing a JavaScript character. JavaScript‚Äôs name for *Unicode code unit*.     *   Size: 16 bits, unsigned     *   Convert number to string: `String.fromCharCode()` ^(ES1)     *   Convert string to number: string method `.charCodeAt()` ^(ES1) *   **Code point**: number representing an atomic part of Unicode text.     *   Size: 21 bits, unsigned (17 planes, 16 bits each)     *   Convert number to string: `String.fromCodePoint()` ^(ES6)     *   Convert string to number: string method `.codePointAt()` ^(ES6)    #### [22.8.3‚ÄÉ`String.prototype.*`: regular expression methods](#stringprototype-regular-expression-methods)    The following methods are listed in [the quick reference for regular expressions](ch_regexps.html#quickref-RegExp):    *   `String.prototype.match()` *   `String.prototype.matchAll()` *   `String.prototype.replace()` *   `String.prototype.replaceAll()` *   `String.prototype.search()` *   `String.prototype.split()`    #### [22.8.4‚ÄÉ`String.prototype.*`: finding and matching](#stringprototype-finding-and-matching)    *   `String.prototype.startsWith(searchString, startPos=0)` ES6                    Returns `true` if `searchString` occurs in the string at index `startPos`. Returns `false` otherwise.                    ```     > '.gitignore'.startsWith('.')     true     > 'abcde'.startsWith('bc', 1)     true          ```js           *   `String.prototype.endsWith(searchString, endPos=this.length)` ES6                    Returns `true` if the string would end with `searchString` if its length were `endPos`. Returns `false` otherwise.                    ```     > 'poem.txt'.endsWith('.txt')     true     > 'abcde'.endsWith('cd', 4)     true          ```js           *   `String.prototype.includes(searchString, startPos=0)` ES6                    Returns `true` if the string contains the `searchString` and `false` otherwise. The search starts at `startPos`.                    ```     > 'abc'.includes('b')     true     > 'abc'.includes('b', 2)     false          ```js           *   `String.prototype.indexOf(searchString, minIndex=0)` ES1               *   If `searchString` appears at `minIndex` or after: Return the lowest index where it is found. Otherwise: Return `-1`.          ```     > 'aaax'.indexOf('aa', 0)     0     > 'aaax'.indexOf('aa', 1)     1     > 'aaax'.indexOf('aa', 2)     -1          ```js           *   `String.prototype.lastIndexOf(searchString, maxIndex?)` ES1               *   If `searchString` appears at `maxIndex` or before: Return the highest index where it is found. Otherwise: Return `-1`.     *   If `maxIndex` is missing, the search starts at `this.length - searchString.length` (assuming that `searchString` is shorter than `this`).          ```     > 'xaaa'.lastIndexOf('aa', 3)     2     > 'xaaa'.lastIndexOf('aa', 2)     2     > 'xaaa'.lastIndexOf('aa', 1)     1     > 'xaaa'.lastIndexOf('aa', 0)     -1          ```js              #### [22.8.5‚ÄÉ`String.prototype.*`: extracting](#stringprototype-extracting)    *   `String.prototype.slice(start=0, end=this.length)` ES3                    Returns the substring of the string that starts at (including) index `start` and ends at (excluding) index `end`. If an index is negative, it is added to `.length` before it is used (`-1` becomes `this.length-1`, etc.).                    ```     > 'abc'.slice(1, 3)     'bc'     > 'abc'.slice(1)     'bc'     > 'abc'.slice(-2)     'bc'          ```js           *   `String.prototype.at(index: number)` ES2022               *   Returns the JavaScript character at `index` as a string.     *   If the index is out of bounds, it returns `undefined`.     *   If `index` is negative, it is added to `.length` before it is used (`-1` becomes `this.length-1`, etc.).          ```     > 'abc'.at(0)     'a'     > 'abc'.at(-1)     'c'          ```js           *   `String.prototype.substring(start, end=this.length)` ES1                    Use `.slice()` instead of this method. `.substring()` wasn‚Äôt implemented consistently in older engines and doesn‚Äôt support negative indices.              #### [22.8.6‚ÄÉ`String.prototype.*`: combining](#stringprototype-combining)    *   `String.prototype.concat(...strings)` ES3                    Returns the concatenation of the string and `strings`. `'a'.concat('b')` is equivalent to `'a'+'b'`. The latter is much more popular.                    ```     > 'ab'.concat('cd', 'ef', 'gh')     'abcdefgh'          ```js           *   `String.prototype.padEnd(len, fillString=' ')` ES2017                    Appends (fragments of) `fillString` to the string until it has the desired length `len`. If it already has or exceeds `len`, then it is returned without any changes.                    ```     > '#'.padEnd(2)     '# '     > 'abc'.padEnd(2)     'abc'     > '#'.padEnd(5, 'abc')     '#abca'          ```js           *   `String.prototype.padStart(len, fillString=' ')` ES2017                    Prepends (fragments of) `fillString` to the string until it has the desired length `len`. If it already has or exceeds `len`, then it is returned without any changes.                    ```     > '#'.padStart(2)     ' #'     > 'abc'.padStart(2)     'abc'     > '#'.padStart(5, 'abc')     'abca#'          ```js           *   `String.prototype.repeat(count=0)` ES6                    Returns the string, concatenated `count` times.                    ```     > '*'.repeat()     ''     > '*'.repeat(3)     '***'          ```js              #### [22.8.7‚ÄÉ`String.prototype.*`: transforming](#stringprototype-transforming)    *   `String.prototype.toUpperCase()` ES1                    Returns a copy of the string in which all lowercase alphabetic characters are converted to uppercase. How well that works for various alphabets, depends on the JavaScript engine.                    ```     > '-a2b-'.toUpperCase()     '-A2B-'     > 'Œ±Œ≤Œ≥'.toUpperCase()     'ŒëŒíŒì'          ```js           *   `String.prototype.toLowerCase()` ES1                    Returns a copy of the string in which all uppercase alphabetic characters are converted to lowercase. How well that works for various alphabets, depends on the JavaScript engine.                    ```     > '-A2B-'.toLowerCase()     '-a2b-'     > 'ŒëŒíŒì'.toLowerCase()     'Œ±Œ≤Œ≥'          ```js           *   `String.prototype.trim()` ES5                    Returns a copy of the string in which all leading and trailing whitespace (spaces, tabs, line terminators, etc.) is gone.                    ```     > '\\r\\n#\\t  '.trim()     '#'     > '  abc  '.trim()     'abc'          ```js           *   `String.prototype.trimStart()` ES2019                    Similar to `.trim()` but only the beginning of the string is trimmed:                    ```     > '  abc  '.trimStart()     'abc  '          ```js           *   `String.prototype.trimEnd()` ES2019                    Similar to `.trim()` but only the end of the string is trimmed:                    ```     > '  abc  '.trimEnd()     '  abc'          ```js           *   `String.prototype.normalize(form = 'NFC')` ES6               *   Normalizes the string according to [the Unicode Normalization Forms](https://unicode.org/reports/tr15/).     *   Values of `form`: `'NFC', 'NFD', 'NFKC', 'NFKD'` *   `String.prototype.isWellFormed()` ES2024                    Returns `true` if a string is ill-formed and contains *lone surrogates* (see [`.toWellFormed()`](#qref-String.prototype.toWellFormed) for more information). Otherwise, it returns `false`.                    ```     > 'üôÇ'.split('') // split into code units     [ '\\uD83D', '\\uDE42' ]     > '\\uD83D\\uDE42'.isWellFormed()     true     > '\\uD83D\\uDE42\\uD83D'.isWellFormed() // lone surrogate 0xD83D     false          ```js           *   `String.prototype.toWellFormed()` ES2024                    Each JavaScript string character is a [UTF-16 code unit](ch_unicode.html#utf-16). One code point is encoded as either one UTF-16 code unit or two UTF-16 code unit. In the latter case, the two code units are called *leading surrogate* and *trailing surrogate*. A surrogate without its partner is called a *lone surrogate*. A string with one or more lone surrogates is *ill-formed*.                    `.toWellFormed()` converts an ill-formed string to a well-formed one by replacing each lone surrogate with code point 0xFFFD (‚Äúreplacement character‚Äù). That character is often displayed as a ÔøΩ (a black rhombus with a white question mark). It is located in the *Specials* Unicode block of characters, at the very end of the *Basic Multilingual Plane*. [This is what Wikipedia says about the replacement character](https://en.wikipedia.org/wiki/Specials_%28Unicode_block%29#Replacement_character): ‚ÄúIt is used to indicate problems when a system is unable to render a stream of data to correct symbols.‚Äù                    ```     assert.deepEqual(      'üôÇ'.split(''), // split into code units      ['\\uD83D', '\\uDE42']     );     assert.deepEqual(      // 0xD83D is a lone surrogate      '\\uD83D\\uDE42\\uD83D'.toWellFormed().split(''),      ['\\uD83D', '\\uDE42', '\\uFFFD']     );          ```js              #### [22.8.8‚ÄÉSources of this quick reference](#sources-of-this-quick-reference)    *   [ECMAScript language specification](https://tc39.es/ecma262/) *   [TypeScript‚Äôs built-in typings](https://github.com/microsoft/TypeScript/tree/main/src/lib/) *   [MDN web docs for JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)    ![Icon ‚Äúexercise‚Äù](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png)‚ÄÇ**Exercise: Using string methods**    `exercises/strings/remove_extension_test.mjs` ```` ```js`` `````", "``````js` ``````", "``````js``` ``````", "```` ```js````", "```js` ```", "```js```", "``` ```", "```````js``` ``````js```````", "``````js``````"]