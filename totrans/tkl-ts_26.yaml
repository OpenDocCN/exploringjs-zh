- en: 21 Type assertions (related to casting)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/tackling-ts/ch_type-assertions.html](https://exploringjs.com/tackling-ts/ch_type-assertions.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 21.1 [Type assertions](ch_type-assertions.html#type-assertions)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 21.1.1 [Alternative syntax for type assertions](ch_type-assertions.html#alternative-syntax-for-type-assertions)
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '21.1.2 [Example: asserting an interface](ch_type-assertions.html#example-asserting-an-interface)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '21.1.3 [Example: asserting an index signature](ch_type-assertions.html#example-asserting-an-index-signature)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 21.2 [Constructs related to type assertions](ch_type-assertions.html#constructs-related-to-type-assertions)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 21.2.1 [Non-nullish assertion operator (postfix `!`)](ch_type-assertions.html#non-nullish-assertion-operator-postfix)
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 21.2.2 [Definite assignment assertions](ch_type-assertions.html#definite-assignment-assertions)
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is about *type assertions* in TypeScript, which are related to
    type casts in other languages and performed via the `as` operator.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 21.1 Type assertions
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A type assertion lets us override a static type that TypeScript has computed
    for a value. That is useful for working around limitations of the type system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Type assertions are related to type casts in other languages, but they don’t
    throw exceptions and don’t do anything at runtime (they do perform a few minimal
    checks statically).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Comments:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: In line A, we widen the type of the Array to `object`.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line B, we see that this type doesn’t let us access any properties ([details](https://2ality.com/2020/01/typing-objects-typescript.html#object-%28lowercase-“o”%29-in-typescript%3A-non-primitive-values)).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line C, we use a type assertion (the operator `as`) to tell TypeScript that
    `data` is an Array. Now we can access property `.length`.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type assertions are a last resort and should be avoided as much as possible.
    They (temporarily) remove the safety net that the static type system normally
    gives us.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, in line A, we also overrode TypeScript’s static type. But we did
    it via a type annotation. This way of overriding is much safer than type assertions
    because we are much more constrained: TypeScript’s type must be assignable to
    the type of the annotation.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 21.1.1 Alternative syntax for type assertions
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'TypeScript has an alternative “angle-bracket” syntax for type assertions:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I recommend avoiding this syntax. It has grown out of style and is not compatible
    with React JSX code (in `.tsx` files).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '21.1.2 Example: asserting an interface'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to access property `.name` of an arbitrary object `obj`, we temporarily
    change the static type of `obj` to `Named` (line A and line B).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '21.1.3 Example: asserting an index signature'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the following code (line A), we use the type assertion `as Dict`, so that
    we can access the properties of a value whose inferred type is `object`. That
    is, we are overriding the static type `object` with the static type `Dict`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 21.2 Constructs related to type assertions
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 21.2.1 Non-nullish assertion operator (postfix `!`)
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a value’s type is a union that includes the types `undefined` or `null`,
    the *non-nullish assertion operator* (or *non-null assertion operator*) removes
    these types from the union. We are telling TypeScript: “This value can’t be `undefined`
    or `null`.” As a consequence, we can perform operations that are prevented by
    the types of these two values – for example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '21.2.1.1 Example – Maps: `.get()` after `.has()`'
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'After we use the Map method `.has()`, we know that a Map has a given key. Alas,
    the result of `.get()` does not reflect that knowledge, which is why we have to
    use the nullish assertion operator:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can avoid the nullish assertion operator whenever the values of a Map can’t
    be `undefined`. Then missing entries can be detected by checking if the result
    of `.get()` is `undefined`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 21.2.2 Definite assignment assertions
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If [*strict property initialization*](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#strict-class-initialization)
    is switched on, we occasionally need to tell TypeScript that we do initialize
    certain properties – even though it thinks we don’t.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果打开了*strict property initialization*，我们偶尔需要告诉TypeScript我们确实初始化了某些属性 - 尽管它认为我们没有。
- en: 'This is an example where TypeScript complains even though it shouldn’t:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子，即使不应该，TypeScript也会抱怨：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The errors go away if we use *definite assignment assertions* (exclamation
    marks) in line A and line B:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在A行和B行使用*definite assignment assertions*（感叹号），错误就会消失：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Comments](https://github.com/rauschma/tackling-ts/issues/22)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[评论](https://github.com/rauschma/tackling-ts/issues/22)'
