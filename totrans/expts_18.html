<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>14 The top types any and unknown</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>14 The top types any and unknown</h1>
<blockquote>原文：<a href="https://exploringjs.com/ts/book/ch_any-unknown.html">https://exploringjs.com/ts/book/ch_any-unknown.html</a></blockquote>

    
        <div id="adbox">
      <div id="adbox-explain">(Ad, please don’t block.)</div>
              
          </div>
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#typescript-s-two-top-types">14.1 TypeScript’s two top types</a>
    </li>
    <li>
      <a href="#the-top-type-any">14.2 The top type <code>any</code></a>
      <ol>
        <li>
          <a href="#example-json-parse">14.2.1 Example: <code>JSON.parse()</code></a>
        </li>
        <li>
          <a href="#example-string">14.2.2 Example: <code>String()</code></a>
        </li>
        <li>
          <a href="#noImplicitAny">14.2.3 The compiler option <code>noImplicitAny</code></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#the-top-type-unknown">14.3 The top type <code>unknown</code></a>
    </li>
  </ol>
</nav>
<p>In TypeScript, <code>any</code> and <code>unknown</code> are types that contain all values. In this chapter, we examine what they are and what they can be used for.</p>
<h3 id="typescript-s-two-top-types"><a class="heading-id-link" href="#typescript-s-two-top-types">14.1 TypeScript’s two top types</a></h3>
<p><code>any</code> and <code>unknown</code> are so-called <em>top types</em> in TypeScript. Quoting <a href="https://en.wikipedia.org/wiki/Top_type">Wikipedia</a>:</p>
<blockquote>
  <p>The <em>top type</em> […] is the <em>universal</em> type, sometimes called the <em>universal supertype</em> as all other types in any given type system are subtypes […]. In most cases it is the type which contains every possible [value] in the type system of interest.</p>
</blockquote>
<p>That is, when viewing types as sets of values (for more information on what types are, see <a href="ch_what-is-a-type.html#ch_what-is-a-type">“What is a type in TypeScript? Two perspectives” (§13)</a>), <code>any</code> and <code>unknown</code> are sets that contain all values.</p>
<p>TypeScript also has the <em>bottom type</em> <code>never</code>, which is the empty set and explained in <a href="ch_never.html#ch_never">“The bottom type <code>never</code>” (§15)</a>.</p>
<h3 id="the-top-type-any"><a class="heading-id-link" href="#the-top-type-any">14.2 The top type <code>any</code></a></h3>
<p>If a value has type <code>any</code>, we can do everything with it:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">value: <span class="hljs-built_in">any</span></span>) {</code>
<code>  <span class="hljs-comment">// Only allowed for numbers, but they are a subtype of `any`</span></code>
<code>  <span class="hljs-number">5</span> * value;</code>
<code/>
<code>  <span class="hljs-comment">// Normally the type signature of `value` must contain .propName</span></code>
<code>  value.<span class="hljs-property">propName</span>;</code>
<code/>
<code>  <span class="hljs-comment">// Normally only allowed for Arrays and types with index signatures</span></code>
<code>  value[<span class="hljs-number">123</span>];</code>
<code>}</code>
</pre>
<p>Every type is assignable to type <code>any</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">let</span> <span class="hljs-attr">storageLocation</span>: <span class="hljs-built_in">any</span>;</code>
<code/>
<code>storageLocation = <span class="hljs-literal">null</span>;</code>
<code>storageLocation = <span class="hljs-literal">true</span>;</code>
<code>storageLocation = {};</code>
</pre>
<p>Type <code>any</code> is assignable to every type:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">value: <span class="hljs-built_in">any</span></span>) {</code>
<code>  <span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>: <span class="hljs-literal">null</span> = value;</code>
<code>  <span class="hljs-keyword">const</span> <span class="hljs-attr">b</span>: <span class="hljs-built_in">boolean</span> = value;</code>
<code>  <span class="hljs-keyword">const</span> <span class="hljs-attr">c</span>: <span class="hljs-built_in">object</span> = value;</code>
<code>}</code>
</pre>
<p>With <code>any</code> we lose any protection that is normally given to us by TypeScript’s static type system. Therefore, it should only be used as a last resort, if we can’t use more specific types or <code>unknown</code>.</p>
<h4 id="example-json-parse"><a class="heading-id-link" href="#example-json-parse">14.2.1 Example: <code>JSON.parse()</code></a></h4>
<p>The result of <code>JSON.parse()</code> depends on dynamic input, which is why the return type is <code>any</code> (I have omitted the parameter <code>reviver</code> from the signature):</p>
<pre class="language-ts">
<code><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-attr">text</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">any</span>;</code>
</pre>
<p><code>JSON.parse()</code> was added to TypeScript before the type <code>unknown</code> existed. Otherwise, its return type would probably be <code>unknown</code>.</p>
<h4 id="example-string"><a class="heading-id-link" href="#example-string">14.2.2 Example: <code>String()</code></a></h4>
<p>The function <code>String()</code>, which converts arbitrary values to strings, has the following type signature:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">StringConstructor</span> {</code>
<code>  (value?: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">string</span>; <span class="hljs-comment">// call signature</span></code>
<code>  <span class="hljs-comment">// ···</span></code>
<code>}</code>
</pre>
<h4 id="noImplicitAny"><a class="heading-id-link" href="#noImplicitAny">14.2.3 The compiler option <code>noImplicitAny</code></a></h4>
<p>If the compiler option <code>noImplicitAny</code> is <code>true</code>, TypeScript requires explicit type annotations in locations where it can’t infer types. The most important example is parameters definitions. If this option is <code>false</code>, it (implicitly) uses the type <code>any</code> in those locations.</p>
<p>This is an example of a compiler error that is caused by <code>noImplicitAny</code> being <code>true</code>:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// @ts-expect-error: Parameter 'name' implicitly has an 'any' type.</span></code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">name</span>) {</code>
<code>  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>!`</span></code>
<code>}</code>
<code>assertType&lt;</code>
<code>  <span class="hljs-function">(<span class="hljs-params">name: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">string</span></code>
<code>&gt;(hello);</code>
</pre>
<p>TypeScript does not complain about us using the type <code>any</code> explicitly:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">name: <span class="hljs-built_in">any</span></span>) {</code>
<code>  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>!`</span></code>
<code>}</code>
</pre>
<h3 id="the-top-type-unknown"><a class="heading-id-link" href="#the-top-type-unknown">14.3 The top type <code>unknown</code></a></h3>
<p>The type <code>unknown</code> is a type-safe version of the type <code>any</code>. Whenever you are thinking of using <code>any</code>, try using <code>unknown</code> first. <code>unknown</code> is similar to <code>any</code> in that we can assign any value to it:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">let</span> <span class="hljs-attr">storageLocation</span>: <span class="hljs-built_in">unknown</span>;</code>
<code/>
<code>storageLocation = <span class="hljs-literal">null</span>;</code>
<code>storageLocation = <span class="hljs-literal">true</span>;</code>
<code>storageLocation = {};</code>
</pre>
<p>However, an <code>unknown</code> value is not assignable to anything:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span></span>) {</code>
<code>  <span class="hljs-comment">// @ts-expect-error: Type 'unknown' is not assignable to type 'null'.</span></code>
<code>  <span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>: <span class="hljs-literal">null</span> = value;</code>
<code>  <span class="hljs-comment">// @ts-expect-error: Type 'unknown' is not assignable to type 'boolean'.</span></code>
<code>  <span class="hljs-keyword">const</span> <span class="hljs-attr">b</span>: <span class="hljs-built_in">boolean</span> = value;</code>
<code>  <span class="hljs-comment">// @ts-expect-error: Type 'unknown' is not assignable to type 'object'.</span></code>
<code>  <span class="hljs-keyword">const</span> <span class="hljs-attr">c</span>: <span class="hljs-built_in">object</span> = value;</code>
<code>}</code>
</pre>
<p>Therefore, if we have a value of type <code>unknown</code>, we must narrow that type before we can do anything with the value – e.g., via:</p>
<ul>
  <li>
    <p><a href="ch_type-assertions.html#ch_type-assertions">Type assertions</a>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span></span>) {</code>
<code>  <span class="hljs-comment">// @ts-expect-error: 'value' is of type 'unknown'.</span></code>
<code>  value.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>);</code>
<code/>
<code>  <span class="hljs-comment">// Type assertion:</span></code>
<code>  (value <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// OK</span></code>
<code>}</code>
</pre>
  </li>
  <li>
    <p>Equality:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span></span>) {</code>
<code>  <span class="hljs-comment">// @ts-expect-error: 'value' is of type 'unknown'.</span></code>
<code>  value * <span class="hljs-number">5</span>;</code>
<code/>
<code>  <span class="hljs-keyword">if</span> (value === <span class="hljs-number">123</span>) { <span class="hljs-comment">// equality</span></code>
<code>    assertType&lt;<span class="hljs-number">123</span>&gt;(value);</code>
<code>    value * <span class="hljs-number">5</span>; <span class="hljs-comment">// OK</span></code>
<code>  }</code>
<code>}</code>
</pre>
  </li>
  <li>
    <p><a href="ch_type-guards.html#ch_type-guards">Type guards</a>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span></span>) {</code>
<code>  <span class="hljs-comment">// @ts-expect-error: 'value' is of type 'unknown'.</span></code>
<code>  value.<span class="hljs-property">length</span>;</code>
<code/>
<code>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'string'</span>) { <span class="hljs-comment">// type guard</span></code>
<code>    assertType&lt;<span class="hljs-built_in">string</span>&gt;(value);</code>
<code>    value.<span class="hljs-property">length</span>; <span class="hljs-comment">// OK</span></code>
<code>  }</code>
<code>}</code>
</pre>
  </li>
  <li>
    <p><a href="ch_assertion-functions.html#ch_assertion-functions">Assertion functions</a>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span></span>) {</code>
<code>  <span class="hljs-comment">// @ts-expect-error: 'value' is of type 'unknown'.</span></code>
<code>  value.<span class="hljs-title function_">test</span>(<span class="hljs-string">'abc'</span>);</code>
<code/>
<code>  <span class="hljs-title function_">assertIsRegExp</span>(value); <span class="hljs-comment">// assertion function</span></code>
<code/>
<code>  assertType&lt;<span class="hljs-title class_">RegExp</span>&gt;(value);</code>
<code>  value.<span class="hljs-title function_">test</span>(<span class="hljs-string">'abc'</span>); <span class="hljs-comment">// OK</span></code>
<code>}</code>
<code/>
<code><span class="hljs-comment">/** An assertion function */</span></code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">assertIsRegExp</span>(<span class="hljs-params">arg: <span class="hljs-built_in">unknown</span></span>): asserts arg is <span class="hljs-title class_">RegExp</span> {</code>
<code>  <span class="hljs-keyword">if</span> (! (arg <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>)) {</code>
<code>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">'Not a RegExp: '</span> + arg);</code>
<code>  }</code>
<code>}</code>
</pre>
  </li>
</ul>

    
      
</body>
</html>