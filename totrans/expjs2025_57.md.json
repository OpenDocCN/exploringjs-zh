["```js\n{\n  \"first\": \"Jane\",\n  \"last\": \"Porter\",\n  \"married\": true,\n  \"born\": 1890,\n  \"friends\": [ \"Tarzan\", \"Cheeta\" ]\n}\n\n```", "```js\nassert.equal(\n  JSON.stringify({prop: ['a', 'b']}),\n  '{\"prop\":[\"a\",\"b\"]}'\n);\n\n```", "```js\nassert.equal(\nJSON.stringify({prop: ['a', 'b']}, null, 2),\n`{\n \"prop\": [\n \"a\",\n \"b\"\n ]\n}`\n);\n\n```", "```js\n    > JSON.stringify(null)\n    'null'\n    > JSON.stringify(true)\n    'true'\n    > JSON.stringify(123)\n    '123'\n    > JSON.stringify('abc')\n    '\"abc\"'\n\n    ```", "```js\n    > JSON.stringify(NaN)\n    'null'\n    > JSON.stringify(Infinity)\n    'null'\n\n    ```", "```js\n    > JSON.stringify(123n)\n    TypeError: Do not know how to serialize a BigInt\n\n    ```", "```js\n    > JSON.stringify(undefined)\n    undefined\n    > JSON.stringify(Symbol())\n    undefined\n\n    ```", "```js\n    > JSON.stringify({toJSON() {return true}})\n    'true' \n    ```", "```js\n    > JSON.stringify(new Date(2999, 11, 31))\n    '\"2999-12-30T23:00:00.000Z\"'\n\n    ```", "```js\n    > JSON.stringify(new Boolean(true))\n    'true'\n    > JSON.stringify(new Number(123))\n    '123'\n\n    ```", "```js\n    > JSON.stringify([undefined, 123, Symbol()])\n    '[null,123,null]'\n\n    ```", "```js\n    > JSON.stringify({a: undefined, b: true, c: Symbol()})\n    '{\"b\":true}'\n\n    ```", "```js\n    > JSON.stringify(() => {})\n    undefined\n\n    ```", "```js\nconst cycle = {};\ncycle.prop = cycle;\nassert.throws(\n  () => JSON.stringify(cycle),\n  /^TypeError: Converting circular structure to JSON/\n);\n\n```", "```js\n> JSON.parse('{\"prop\":[\"a\",\"b\"]}')\n{ prop: [ 'a', 'b' ] }\n\n```", "```js\nclass Point {\n  static fromJson(jsonObj) { // (A)\n    return new Point(jsonObj.x, jsonObj.y);\n  }\n\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toJSON() { // (B)\n return {x: this.x, y: this.y};\n }\n}\n\n```", "```js\n    assert.deepEqual(\n      Point.fromJson(JSON.parse('{\"x\":3,\"y\":5}')),\n      new Point(3, 5) );\n\n    ```", "```js\n    assert.equal(\n      JSON.stringify(new Point(3, 5)),\n      '{\"x\":3,\"y\":5}' );\n\n    ```", "```js\nconst obj = {\n  a: 1,\n  b: {\n    c: 2,\n    d: 3,\n  }\n};\nassert.equal(\n  JSON.stringify(obj, ['b', 'c']),\n  '{\"b\":{\"c\":2}}');\n\n```", "```js\ntype ValueVisitor = (key: string, value: any) => any;\n\n```", "```js\nconst log = [];\nfunction valueVisitor(key, value) {\n  log.push({this: this, key, value});\n  return value; // no change\n}\n\nconst root = {\n  a: 1,\n  b: {\n    c: 2,\n    d: 3,\n  }\n};\nJSON.stringify(root, valueVisitor);\nassert.deepEqual(log, [\n  { this: { '': root }, key: '',  value: root   },\n  { this: root        , key: 'a', value: 1      },\n  { this: root        , key: 'b', value: root.b },\n  { this: root.b      , key: 'c', value: 2      },\n  { this: root.b      , key: 'd', value: 3      },\n]);\n\n```", "```js\nconst obj = {\n  name: 'abc',\n  regex: /abc/ui,\n};\nassert.equal(\n  JSON.stringify(obj),\n  '{\"name\":\"abc\",\"regex\":{}}');\n\n```", "```js\nfunction replacer(key, value) {\n  if (value instanceof RegExp) {\n    return {\n      __type__: 'RegExp',\n      source: value.source,\n      flags: value.flags,\n    };\n  } else {\n    return value; // no change\n  }\n}\nassert.equal(\nJSON.stringify(obj, replacer, 2),\n`{\n \"name\": \"abc\",\n \"regex\": {\n \"__type__\": \"RegExp\",\n \"source\": \"abc\",\n \"flags\": \"iu\"\n }\n}`);\n\n```", "```js\nfunction reviver(key, value) {\n  // Very simple check\n  if (value && value.__type__ === 'RegExp') {\n    return new RegExp(value.source, value.flags);\n  } else {\n    return value;\n  }\n}\nconst str = `{\n \"name\": \"abc\",\n \"regex\": {\n \"__type__\": \"RegExp\",\n \"source\": \"abc\",\n \"flags\": \"iu\"\n }\n}`;\nassert.deepEqual(\n  JSON.parse(str, reviver),\n  {\n    name: 'abc',\n    regex: /abc/ui,\n  });\n\n```"]