["```js\n{\n \"first\": \"Jane\",\n \"last\": \"Porter\",\n \"married\": true,\n \"born\": 1890,\n \"friends\": [ \"Tarzan\", \"Cheeta\" ]\n}\n\n```", "```js\nassert.equal(\n JSON.stringify({prop: ['a', 'b']}),\n '{\"prop\":[\"a\",\"b\"]}'\n);\n\n```", "```js\nassert.equal(\nJSON.stringify({prop: ['a', 'b']}, null, 2),\n`{\n \"prop\": [\n \"a\",\n \"b\"\n ]\n}`\n);\n\n```", "```js\n    > JSON.stringify(null)\n    'null'\n    > JSON.stringify(true)\n    'true'\n    > JSON.stringify(123)\n    '123'\n    > JSON.stringify('abc')\n    '\"abc\"'\n\n    ```", "```js\n    > JSON.stringify(NaN)\n    'null'\n    > JSON.stringify(Infinity)\n    'null'\n\n    ```", "```js\n    > JSON.stringify(123n)\n    TypeError: Do not know how to serialize a BigInt\n\n    ```", "```js\n    > JSON.stringify(undefined)\n    undefined\n    > JSON.stringify(Symbol())\n    undefined\n\n    ```", "```js\n    > JSON.stringify({toJSON() {return true}})\n    'true'\n\n    ```", "```js\n    > JSON.stringify(new Date(2999, 11, 31))\n    '\"2999-12-30T23:00:00.000Z\"'\n\n    ```", "```js\n    > JSON.stringify(new Boolean(true))\n    'true'\n    > JSON.stringify(new Number(123))\n    '123'\n\n    ```", "```js\n    > JSON.stringify([undefined, 123, Symbol()])\n    '[null,123,null]'\n\n    ```", "```js\n    > JSON.stringify({a: undefined, b: true, c: Symbol()})\n    '{\"b\":true}'\n\n    ```", "```js\n    > JSON.stringify(() => {})\n    undefined\n\n    ```", "```js\nconst cycle = {};\ncycle.prop = cycle;\nassert.throws(\n () => JSON.stringify(cycle),\n /^TypeError: Converting circular structure to JSON/\n);\n\n```", "```js\n> JSON.parse('{\"prop\":[\"a\",\"b\"]}')\n{ prop: [ 'a', 'b' ] }\n\n```", "```js\nclass Point {\n static fromJson(jsonObj) { // (A)\n return new Point(jsonObj.x, jsonObj.y);\n }\n `constructor(x, y) {`\n `this.x = x;`\n `this.y = y;`\n `}`\n\n `toJSON() { // (B)`\n `return {x: this.x, y: this.y};`\n `}`\n`}` \n```", "```js`` *   Converting JSON to a point: We use the static method `Point.fromJson()` to parse JSON and create an instance of `Point`.                    ```", "```js           *   Converting a point to JSON: `JSON.stringify()` internally calls [the previously mentioned method `.toJSON()`](#json-stringify-details).                    ```", "```js              ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Converting an object to and from JSON**    `exercises/json/to_from_json_test.mjs`    ### [48.4 Customizing stringification and parsing (advanced)](#json-replacers-revivers)    Stringification and parsing can be customized as follows:    *   `JSON.stringify(data, replacer?, space?)`                    The optional parameter `replacer` contains either:               *   An Array with names of properties. If a value in `data` is stringified as an object literal, then only the mentioned properties are considered. All other properties are ignored.     *   A *value visitor*, a function that can transform JavaScript data before it is stringified. *   `JSON.parse(text, reviver?)`                    The optional parameter `reviver` contains a value visitor that can transform the parsed JSON data before it is returned.              #### [48.4.1 `.stringfy()`: specifying which properties of objects to stringify](#stringfy-specifying-which-properties-of-objects-to-stringify)    If the second parameter of `.stringify()` is an Array, then only object properties, whose names are mentioned there, are included in the result:    ```", "```js    #### [48.4.2 `.stringify()` and `.parse()`: value visitors](#json-value-visitors)    What I call a *value visitor* is a function that transforms JavaScript data:    *   `JSON.stringify()` lets the value visitor in its parameter `replacer` transform JavaScript data before it is stringified. *   `JSON.parse()` lets the value visitor in its parameter `reviver` transform parsed JavaScript data before it is returned.    In this section, JavaScript data is considered to be a tree of values. If the data is atomic, it is a tree that only has a root. All values in the tree are fed to the value visitor, one at a time. Depending on what the visitor returns, the current value is omitted, changed, or preserved.    A value visitor has the following type signature:    ```", "```js    The parameters are:    *   `value`: The current value. *   `this`: Parent of current value. The parent of the root value `r` is `{'': r}`.     *   Note: `this` is an implicit parameter and only available if the value visitor is an ordinary function. *   `key`: Key or index of the current value inside its parent. The key of the root value is `''`.    The value visitor can return:    *   `value`: means there won’t be any change. *   A different value `x`: leads to `value` being replaced with `x` in the output tree. *   `undefined`: leads to `value` being omitted in the output tree.    #### [48.4.3 Example: visiting values](#example-visiting-values)    The following code shows in which order a value visitor sees values:    ```", "```js   ```", "```js const obj = {  name: 'abc',  regex: /abc/ui, }; assert.equal(  JSON.stringify(obj),  '{\"name\":\"abc\",\"regex\":{}}');  ```", "```js function replacer(key, value) {  if (value instanceof RegExp) {  return {  __type__: 'RegExp',  source: value.source,  flags: value.flags,  };  } else {  return value; // no change  } } assert.equal( JSON.stringify(obj, replacer, 2), `{  \"name\": \"abc\",  \"regex\": {  \"__type__\": \"RegExp\",  \"source\": \"abc\",  \"flags\": \"iu\"  } }`);  ```", "```js function reviver(key, value) {  // Very simple check  if (value && value.__type__ === 'RegExp') {  return new RegExp(value.source, value.flags);  } else {  return value;  } } const str = `{  \"name\": \"abc\",  \"regex\": {  \"__type__\": \"RegExp\",  \"source\": \"abc\",  \"flags\": \"iu\"  } }`; assert.deepEqual(  JSON.parse(str, reviver),  {  name: 'abc',  regex: /abc/ui,  });  ```", "```js` ```"]