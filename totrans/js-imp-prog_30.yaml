- en: 25 Callable values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/impatient-js/ch_callables.html](https://exploringjs.com/impatient-js/ch_callables.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 25.1 [Kinds of functions](ch_callables.html#kinds-of-functions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.2 [Ordinary functions](ch_callables.html#ordinary-functions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.2.1 [Named function expressions (advanced)](ch_callables.html#named-function-expressions)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '25.2.2 [Terminology: function definitions and function expressions](ch_callables.html#terminology-function-definitions-and-function-expressions)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.2.3 [Parts of a function declaration](ch_callables.html#parts-of-a-function-declaration)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.2.4 [Roles played by ordinary functions](ch_callables.html#roles-of-ordinary-functions)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '25.2.5 [Terminology: entity vs. syntax vs. role (advanced)](ch_callables.html#terminology-entity-vs.-syntax-vs.-role-advanced)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.3 [Specialized functions](ch_callables.html#specialized-functions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.3.1 [Specialized functions are still functions](ch_callables.html#specialized-functions-are-still-functions)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.3.2 [Arrow functions](ch_callables.html#arrow-functions)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.3.3 [The special variable `this` in methods, ordinary functions and arrow
    functions](ch_callables.html#this-in-callables)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '25.3.4 [Recommendation: prefer specialized functions over ordinary functions](ch_callables.html#prefer-specialized-functions)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '25.4 [Summary: kinds of callable values](ch_callables.html#summary-kinds-of-callable-values)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.5 [Returning values from functions and methods](ch_callables.html#returning-values-from-functions-and-methods)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.6 [Parameter handling](ch_callables.html#parameter-handling)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '25.6.1 [Terminology: parameters vs. arguments](ch_callables.html#terminology-parameters-vs.-arguments)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '25.6.2 [Terminology: callback](ch_callables.html#callback-function)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.6.3 [Too many or not enough arguments](ch_callables.html#too-many-or-not-enough-arguments)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.6.4 [Parameter default values](ch_callables.html#parameter-default-values)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.6.5 [Rest parameters](ch_callables.html#rest-parameters)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.6.6 [Named parameters](ch_callables.html#named-parameters)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.6.7 [Simulating named parameters](ch_callables.html#simulating-named-parameters)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.6.8 [Spreading (`...`) into function calls](ch_callables.html#spread-arguments)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '25.7 [Methods of functions: `.call()`, `.apply()`, `.bind()`](ch_callables.html#methods-of-functions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.7.1 [The function method `.call()`](ch_callables.html#Function.prototype.call)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.7.2 [The function method `.apply()`](ch_callables.html#Function.prototype.apply)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.7.3 [The function method `.bind()`](ch_callables.html#Function.prototype.bind)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we look at JavaScript values that can be invoked: functions,
    methods, and classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 25.1 Kinds of functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript has two categories of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An *ordinary function* can play several roles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real function
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Method
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor function
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A *specialized function* can only play one of those roles – for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An *arrow function* can only be a real function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A *method* can only be a method.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A *class* can only be a constructor function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Specialized functions were added to the language in ECMAScript 6.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Read on to find out what all of those things mean.
  prefs: []
  type: TYPE_NORMAL
- en: 25.2 Ordinary functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code shows two ways of doing (roughly) the same thing: creating
    an ordinary function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside a scope, function declarations are activated early (see [§11.8 “Declarations:
    scope and activation”](ch_variables-assignment.html#declarations-scope-activation))
    and can be called before they are declared. That is occasionally useful.'
  prefs: []
  type: TYPE_NORMAL
- en: Variable declarations, such as the one for `ordinary2`, are not activated early.
  prefs: []
  type: TYPE_NORMAL
- en: 25.2.1 Named function expressions (advanced)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far, we have only seen anonymous function expressions – which don’t have
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'But there are also *named function expressions*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`myName` is only accessible inside the body of the function. The function can
    use it to refer to itself (for self-recursion, etc.) – independently of which
    variable it is assigned to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if they are not assigned to variables, named function expressions have
    names (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that functions created via function declarations or variable declarations
    always have names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: One benefit of functions having names is that those names show up in [error
    stack traces](ch_exception-handling.html#error-stack).
  prefs: []
  type: TYPE_NORMAL
- en: '25.2.2 Terminology: function definitions and function expressions'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *function definition* is syntax that creates functions:'
  prefs: []
  type: TYPE_NORMAL
- en: A function declaration (a statement)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Function declarations always produce ordinary functions. Function expressions
    produce either ordinary functions or specialized functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ordinary function expressions (which we have already encountered):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anonymous function expressions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Named function expressions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Specialized function expressions (which we’ll look at later):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrow functions (which are always expressions)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: While function declarations are still popular in JavaScript, function expressions
    are almost always arrow functions in modern code.
  prefs: []
  type: TYPE_NORMAL
- en: 25.2.3 Parts of a function declaration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s examine the parts of a function declaration via the following example.
    Most of the terms also apply to function expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`add` is the *name* of the function declaration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add(x, y)` is the *head* of the function declaration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x` and `y` are the *parameters*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The curly braces (`{` and `}`) and everything between them are the *body* of
    the function declaration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `return` statement explicitly returns a value from the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.2.3.1 Trailing commas in parameter lists
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'JavaScript has always allowed and ignored trailing commas in Array literals.
    Since ES5, they are also allowed in object literals. Since ES2017, we can add
    trailing commas to parameter lists (declarations and invocations):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 25.2.4 Roles played by ordinary functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following function declaration from the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This function declaration creates an ordinary function whose name is `add`.
    As an ordinary function, `add()` can play three roles:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Real function: invoked via a function call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Method: stored in a property, invoked via a method call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In line A, `obj` is called the *receiver* of the method call.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Constructor function: invoked via `new`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As an aside, the names of constructor functions (incl. classes) normally start
    with capital letters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '25.2.5 Terminology: entity vs. syntax vs. role (advanced)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The distinction between the concepts *syntax*, *entity*, and *role* is subtle
    and often doesn’t matter. But I’d like to sharpen your eye for it:'
  prefs: []
  type: TYPE_NORMAL
- en: An *entity* is a JavaScript feature as it “lives” in RAM. An ordinary function
    is an entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Entities include: ordinary functions, arrow functions, methods, and classes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Syntax* is the code that we use to create entities. Function declarations
    and anonymous function expressions are syntax. They both create entities that
    are called ordinary functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Syntax includes: function declarations and anonymous function expressions.
    The syntax that produces arrow functions is also called *arrow functions*. The
    same is true for methods and classes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A *role* describes how we use entities. The entity *ordinary function* can play
    the role *real function*, or the role *method*, or the role *class*. The entity
    *arrow function* can also play the role *real function*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The roles of functions are: real function, method, and constructor function.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Many other programming languages only have a single entity that plays the role
    *real function*. Then they can use the name *function* for both role and entity.
  prefs: []
  type: TYPE_NORMAL
- en: 25.3 Specialized functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Specialized functions are single-purpose versions of ordinary functions. Each
    one of them specializes in a single role:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of an *arrow function* is to be a real function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The purpose of a *method* is to be a method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The purpose of a *class* is to be a constructor function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Apart from nicer syntax, each kind of specialized function also supports new
    features, making them better at their jobs than ordinary functions.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions are explained soon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods are explained [in the chapter on single objects](ch_objects.html#methods-and-this).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes are explained [in the chapter on classes](ch_classes.html#classes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tbl. [16](#tbl:capabilities-of-functions) lists the capabilities of ordinary
    and specialized functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 16: Capabilities of four kinds of functions. If a cell value is in parentheses,
    that implies some kind of limitation. The special variable `this` is explained
    in [§25.3.3 “The special variable `this` in methods, ordinary functions and arrow
    functions”](ch_callables.html#this-in-callables).'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Function call | Method call | Constructor call |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Ordinary function | (`this === undefined`) | `✔` | `✔` |'
  prefs: []
  type: TYPE_TB
- en: '| Arrow function | `✔` | (lexical `this`) | `✘` |'
  prefs: []
  type: TYPE_TB
- en: '| Method | (`this === undefined`) | `✔` | `✘` |'
  prefs: []
  type: TYPE_TB
- en: '| Class | `✘` | `✘` | `✔` |'
  prefs: []
  type: TYPE_TB
- en: 25.3.1 Specialized functions are still functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It’s important to note that arrow functions, methods, and classes are still
    categorized as functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 25.3.2 Arrow functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Arrow functions were added to JavaScript for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: To provide a more concise way for creating functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'They work better as real functions inside methods: Methods can refer to the
    object that received a method call via the special variable `this`. Arrow functions
    can access the `this` of a surrounding method, ordinary functions can’t (because
    they have their own `this`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll first examine the syntax of arrow functions and then how `this` works
    in various functions.
  prefs: []
  type: TYPE_NORMAL
- en: 25.3.2.1 The syntax of arrow functions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s review the syntax of an anonymous function expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The (roughly) equivalent arrow function looks as follows. Arrow functions are
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, the body of the arrow function is a block. But it can also be an expression.
    The following arrow function works exactly like the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If an arrow function has only a single parameter and that parameter is an identifier
    (not [a destructuring pattern](ch_destructuring.html)) then you can omit the parentheses
    around the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'That is convenient when passing arrow functions as parameters to other functions
    or methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This previous example demonstrates one benefit of arrow functions – conciseness.
    If we perform the same task with a function expression, our code is more verbose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '25.3.2.2 Syntax pitfall: returning an object literal from an arrow function'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you want the expression body of an arrow function to be an object literal,
    you must put the literal in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t, JavaScript thinks, the arrow function has a block body (that
    doesn’t return anything):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`{a: 1}` is interpreted as a block with [the label `a:`](ch_control-flow.html#labels)
    and the expression statement `1`. Without an explicit `return` statement, the
    block body returns `undefined`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This pitfall is caused by [syntactic ambiguity](ch_syntax.html#ambiguous-syntax):
    object literals and code blocks have the same syntax. We use the parentheses to
    tell JavaScript that the body is an expression (an object literal) and not a statement
    (a block).'
  prefs: []
  type: TYPE_NORMAL
- en: 25.3.3 The special variable `this` in methods, ordinary functions and arrow
    functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '![](../Images/ec8e6930fbe484fc519f3aa7b812c3fd.png)  **The special variable
    `this` is an object-oriented feature**'
  prefs: []
  type: TYPE_NORMAL
- en: We are taking a quick look at the special variable `this` here, in order to
    understand why arrow functions are better real functions than ordinary functions.
  prefs: []
  type: TYPE_NORMAL
- en: But this feature only matters in object-oriented programming and is covered
    in more depth in [§28.5 “Methods and the special variable `this`”](ch_objects.html#methods-and-this).
    Therefore, don’t worry if you don’t fully understand it yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside methods, the special variable `this` lets us access the *receiver* –
    the object which received the method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Ordinary functions can be methods and therefore also have the implicit parameter
    `this`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`this` is even an implicit parameter when we use an ordinary function as a
    real function. Then its value is `undefined` (if [strict mode](ch_syntax.html#strict-mode)
    is active, which it almost always is):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'That means that an ordinary function, used as a real function, can’t access
    the `this` of a surrounding method (line A). In contrast, arrow functions don’t
    have `this` as an implicit parameter. They treat it like any other variable and
    can therefore access the `this` of a surrounding method (line B):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we can observe two ways of handling `this`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic `this`: In line A, we try to access the `this` of `.someMethod()` from
    an ordinary function. There, it is *shadowed* by the function’s own `this`, which
    is `undefined` (as filled in by the function call). Given that ordinary functions
    receive their `this` via (dynamic) function or method calls, their `this` is called
    *dynamic*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lexical `this`: In line B, we again try to access the `this` of `.someMethod()`.
    This time, we succeed because the arrow function does not have its own `this`.
    `this` is resolved *lexically*, just like any other variable. That’s why the `this`
    of arrow functions is called *lexical*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '25.3.4 Recommendation: prefer specialized functions over ordinary functions'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Normally, you should prefer specialized functions over ordinary functions, especially
    classes and methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to real functions, the choice between an arrow function and an
    ordinary function is less clear-cut, though:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For anonymous inline function expressions, arrow functions are clear winners,
    due to their compact syntax and them not having `this` as an implicit parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For stand-alone named function declarations, arrow functions still benefit
    from lexical `this`. But function declarations (which produce ordinary functions)
    have nice syntax and early activation is also occasionally useful (see [§11.8
    “Declarations: scope and activation”](ch_variables-assignment.html#declarations-scope-activation)).
    If `this` doesn’t appear in the body of an ordinary function, there is no downside
    to using it as a real function. The static checking tool ESLint can warn us during
    development when we do this wrong via [a built-in rule](https://eslint.org/docs/rules/no-invalid-this).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '25.4 Summary: kinds of callable values'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](../Images/ec8e6930fbe484fc519f3aa7b812c3fd.png)  **This section refers
    to upcoming content**'
  prefs: []
  type: TYPE_NORMAL
- en: This section mainly serves as a reference for the current and upcoming chapters.
    Don’t worry if you don’t understand everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, all (real) functions and methods, that we have seen, were:'
  prefs: []
  type: TYPE_NORMAL
- en: Single-result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Later chapters will cover other modes of programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Iteration* treats objects as containers of data (so-called *iterables*) and
    provides a standardized way for retrieving what is inside them. If a function
    or a method returns an iterable, it returns multiple values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Asynchronous programming* deals with handling a long-running computation.
    You are notified when the computation is finished and can do something else in
    between. The standard pattern for asynchronously delivering single results is
    called *Promise*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These modes can be combined – for example, there are synchronous iterables and
    asynchronous iterables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several new kinds of functions and methods help with some of the mode combinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Async functions* help implement functions that return Promises. There are
    also *async methods*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Synchronous generator functions* help implement functions that return synchronous
    iterables. There are also *synchronous generator methods*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Asynchronous generator functions* help implement functions that return asynchronous
    iterables. There are also *asynchronous generator methods*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That leaves us with 4 kinds (2 × 2) of functions and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous vs. asynchronous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generator vs. single-result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tbl. [17](#tbl:syntax-functions-methods) gives an overview of the syntax for
    creating these 4 kinds of functions and methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 17: Syntax for creating functions and methods. The last column specifies
    how many values are produced by an entity.'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  | **Result** | **#** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Sync function** | **Sync method** |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `function f() {}` | `{ m() {} }` | value | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `f = function () {}` |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `f = () => {}` |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Sync generator function** | **Sync gen. method** |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `function* f() {}` | `{ * m() {} }` | iterable | 0+ |'
  prefs: []
  type: TYPE_TB
- en: '| `f = function* () {}` |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Async function** | **Async method** |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `async function f() {}` | `{ async m() {} }` | Promise | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `f = async function () {}` |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `f = async () => {}` |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Async generator function** | **Async gen. method** |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `async function* f() {}` | `{ async * m() {} }` | async iterable | 0+ |'
  prefs: []
  type: TYPE_TB
- en: '| `f = async function* () {}` |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 25.5 Returning values from functions and methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (Everything mentioned in this section applies to both functions and methods.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The `return` statement explicitly returns a value from a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If, at the end of a function, you haven’t returned anything explicitly, JavaScript
    returns `undefined` for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 25.6 Parameter handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once again, I am only mentioning functions in this section, but everything also
    applies to methods.
  prefs: []
  type: TYPE_NORMAL
- en: '25.6.1 Terminology: parameters vs. arguments'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The term *parameter* and the term *argument* basically mean the same thing.
    If you want to, you can make the following distinction:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Parameters* are part of a function definition. They are also called *formal
    parameters* and *formal arguments*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Arguments* are part of a function call. They are also called *actual parameters*
    and *actual arguments*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '25.6.2 Terminology: callback'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *callback* or *callback function* is a function that is an argument of a function
    or method call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 25.6.3 Too many or not enough arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'JavaScript does not complain if a function call provides a different number
    of arguments than expected by the function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: Extra arguments are ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing parameters are set to `undefined`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 25.6.4 Parameter default values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Parameter default values specify the value to use if a parameter has not been
    provided – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`undefined` also triggers the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 25.6.5 Rest parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A rest parameter is declared by prefixing an identifier with three dots (`...`).
    During a function or method call, it receives an Array with all remaining arguments.
    If there are no extra arguments at the end, it is an empty Array – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two restrictions related to how we can use rest parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: We cannot use more than one rest parameter per function definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A rest parameter must always come last. As a consequence, we can’t access the
    last parameter like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 25.6.5.1 Enforcing a certain number of arguments via a rest parameter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can use a rest parameter to enforce a certain number of arguments. Take,
    for example, the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we force callers to always provide two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In line A, we access the elements of `args` via [*destructuring*](ch_destructuring.html).
  prefs: []
  type: TYPE_NORMAL
- en: 25.6.6 Named parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When someone calls a function, the arguments provided by the caller are assigned
    to the parameters received by the callee. Two common ways of performing the mapping
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Positional parameters: An argument is assigned to a parameter if they have
    the same position. A function call with only positional arguments looks as follows.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Named parameters: An argument is assigned to a parameter if they have the same
    name. JavaScript doesn’t have named parameters, but you can simulate them. For
    example, this is a function call with only (simulated) named arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Named parameters have several benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: 'They lead to more self-explanatory code because each argument has a descriptive
    label. Just compare the two versions of `selectEntries()`: with the second one,
    it is much easier to see what happens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of the arguments doesn’t matter (as long as the names are correct).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Handling more than one optional parameter is more convenient: callers can easily
    provide any subset of all optional parameters and don’t have to be aware of the
    ones they omit (with positional parameters, you have to fill in preceding optional
    parameters, with `undefined`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.6.7 Simulating named parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'JavaScript doesn’t have real named parameters. The official way of simulating
    them is via object literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This function uses [*destructuring*](ch_destructuring.html) to access the properties
    of its single parameter. The pattern it uses is an abbreviation for the following
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This destructuring pattern works for empty object literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'But it does not work if you call the function without any parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You can fix this by providing a default value for the whole pattern. This default
    value works the same as default values for simpler parameter definitions: if the
    parameter is missing, the default is used.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 25.6.8 Spreading (`...`) into function calls
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you put three dots (`...`) in front of the argument of a function call,
    then you *spread* it. That means that the argument must be [an *iterable* object](ch_sync-iteration.html)
    and the iterated values all become arguments. In other words, a single argument
    is expanded into multiple arguments – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Spreading and rest parameters use the same syntax (`...`), but they serve opposite
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Rest parameters are used when defining functions or methods. They collect arguments
    into Arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spread arguments are used when calling functions or methods. They turn iterable
    objects into arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '25.6.8.1 Example: spreading into `Math.max()`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`Math.max()` returns the largest one of its zero or more arguments. Alas, it
    can’t be used for Arrays, but spreading gives us a way out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '25.6.8.2 Example: spreading into `Array.prototype.push()`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Similarly, the Array method `.push()` destructively adds its zero or more parameters
    to the end of its Array. JavaScript has no method for destructively appending
    an Array to another one. Once again, we are saved by spreading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercises: Parameter
    handling**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Positional parameters: `exercises/callables/positional_parameters_test.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Named parameters: `exercises/callables/named_parameters_test.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '25.7 Methods of functions: `.call()`, `.apply()`, `.bind()`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Functions are objects and have methods. In this section, we look at three of
    those methods: `.call()`, `.apply()`, and `.bind()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 25.7.1 The function method `.call()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Each function `someFunc` has the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This method invocation is loosely equivalent to the following function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'However, with `.call()`, we can also specify a value for [the implicit parameter
    `this`](ch_callables.html#this-in-callables). In other words: `.call()` makes
    the implicit parameter `this` explicit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates the use of `.call()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have seen before, if we function-call an ordinary function, its `this`
    is `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, the previous function call is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In arrow functions, the value for `this` provided via `.call()` (or other means)
    is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 25.7.2 The function method `.apply()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Each function `someFunc` has the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This method invocation is loosely equivalent to the following function call
    (which uses [spreading](ch_callables.html#spread-arguments)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: However, with `.apply()`, we can also specify a value for [the implicit parameter
    `this`](ch_callables.html#this-in-callables).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates the use of `.apply()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 25.7.3 The function method `.bind()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`.bind()` is another method of function objects. This method is invoked as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`.bind()` returns a new function `boundFunc()`. Calling that function invokes
    `someFunc()` with `this` set to `thisValue` and these parameters: `arg1`, `arg2`,
    followed by the parameters of `boundFunc()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, the following two function calls are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 25.7.3.1 An alternative to `.bind()`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Another way of pre-filling `this` and parameters is via an arrow function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 25.7.3.2 An implementation of `.bind()`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Considering the previous section, `.bind()` can be implemented as a real function
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '25.7.3.3 Example: binding a real function'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Using `.bind()` for real functions is somewhat unintuitive because we have to
    provide a value for `this`. Given that it is `undefined` during function calls,
    it is usually set to `undefined` or `null`.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we create `add8()`, a function that has one parameter,
    by binding the first parameter of `add()` to `8`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz**'
  prefs: []
  type: TYPE_NORMAL
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  prefs: []
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/17)'
  prefs: []
  type: TYPE_NORMAL
