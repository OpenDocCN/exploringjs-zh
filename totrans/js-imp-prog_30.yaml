- en: 25 Callable values
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/impatient-js/ch_callables.html](https://exploringjs.com/impatient-js/ch_callables.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 25.1 [Kinds of functions](ch_callables.html#kinds-of-functions)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.2 [Ordinary functions](ch_callables.html#ordinary-functions)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.2.1 [Named function expressions (advanced)](ch_callables.html#named-function-expressions)
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '25.2.2 [Terminology: function definitions and function expressions](ch_callables.html#terminology-function-definitions-and-function-expressions)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.2.3 [Parts of a function declaration](ch_callables.html#parts-of-a-function-declaration)
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.2.4 [Roles played by ordinary functions](ch_callables.html#roles-of-ordinary-functions)
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '25.2.5 [Terminology: entity vs. syntax vs. role (advanced)](ch_callables.html#terminology-entity-vs.-syntax-vs.-role-advanced)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.3 [Specialized functions](ch_callables.html#specialized-functions)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.3.1 [Specialized functions are still functions](ch_callables.html#specialized-functions-are-still-functions)
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.3.2 [Arrow functions](ch_callables.html#arrow-functions)
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.3.3 [The special variable `this` in methods, ordinary functions and arrow
    functions](ch_callables.html#this-in-callables)
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '25.3.4 [Recommendation: prefer specialized functions over ordinary functions](ch_callables.html#prefer-specialized-functions)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '25.4 [Summary: kinds of callable values](ch_callables.html#summary-kinds-of-callable-values)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.5 [Returning values from functions and methods](ch_callables.html#returning-values-from-functions-and-methods)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.6 [Parameter handling](ch_callables.html#parameter-handling)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '25.6.1 [Terminology: parameters vs. arguments](ch_callables.html#terminology-parameters-vs.-arguments)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '25.6.2 [Terminology: callback](ch_callables.html#callback-function)'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.6.3 [Too many or not enough arguments](ch_callables.html#too-many-or-not-enough-arguments)
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.6.4 [Parameter default values](ch_callables.html#parameter-default-values)
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.6.5 [Rest parameters](ch_callables.html#rest-parameters)
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.6.6 [Named parameters](ch_callables.html#named-parameters)
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.6.7 [Simulating named parameters](ch_callables.html#simulating-named-parameters)
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.6.8 [Spreading (`...`) into function calls](ch_callables.html#spread-arguments)
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '25.7 [Methods of functions: `.call()`, `.apply()`, `.bind()`](ch_callables.html#methods-of-functions)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.7.1 [The function method `.call()`](ch_callables.html#Function.prototype.call)
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.7.2 [The function method `.apply()`](ch_callables.html#Function.prototype.apply)
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 25.7.3 [The function method `.bind()`](ch_callables.html#Function.prototype.bind)
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we look at JavaScript values that can be invoked: functions,
    methods, and classes.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 25.1 Kinds of functions
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript has two categories of functions:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'An *ordinary function* can play several roles:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real function
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Method
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor function
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A *specialized function* can only play one of those roles – for example:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An *arrow function* can only be a real function.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A *method* can only be a method.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A *class* can only be a constructor function.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Specialized functions were added to the language in ECMAScript 6.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Read on to find out what all of those things mean.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 25.2 Ordinary functions
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code shows two ways of doing (roughly) the same thing: creating
    an ordinary function.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inside a scope, function declarations are activated early (see [§11.8 “Declarations:
    scope and activation”](ch_variables-assignment.html#declarations-scope-activation))
    and can be called before they are declared. That is occasionally useful.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Variable declarations, such as the one for `ordinary2`, are not activated early.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 25.2.1 Named function expressions (advanced)
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far, we have only seen anonymous function expressions – which don’t have
    names:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'But there are also *named function expressions*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`myName` is only accessible inside the body of the function. The function can
    use it to refer to itself (for self-recursion, etc.) – independently of which
    variable it is assigned to:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Even if they are not assigned to variables, named function expressions have
    names (line A):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它们没有分配给变量，命名函数表达式也有名称（第 A 行）：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that functions created via function declarations or variable declarations
    always have names:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过函数声明或变量声明创建的函数始终具有名称：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: One benefit of functions having names is that those names show up in [error
    stack traces](ch_exception-handling.html#error-stack).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 函数具有名称的一个好处是，这些名称会出现在 [错误堆栈跟踪](ch_exception-handling.html#error-stack) 中。
- en: '25.2.2 Terminology: function definitions and function expressions'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 25.2.2 术语：函数定义和函数表达式
- en: 'A *function definition* is syntax that creates functions:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数定义* 是创建函数的语法：'
- en: A function declaration (a statement)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数声明（一个语句）
- en: A function expression
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数表达式
- en: 'Function declarations always produce ordinary functions. Function expressions
    produce either ordinary functions or specialized functions:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明总是产生普通函数。函数表达式产生普通函数或专门的函数：
- en: 'Ordinary function expressions (which we have already encountered):'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通函数表达式（我们已经遇到过的）：
- en: Anonymous function expressions
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名函数表达式
- en: Named function expressions
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名函数表达式
- en: 'Specialized function expressions (which we’ll look at later):'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专门的函数表达式（稍后我们将看到）：
- en: Arrow functions (which are always expressions)
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数（它们总是表达式）
- en: While function declarations are still popular in JavaScript, function expressions
    are almost always arrow functions in modern code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 JavaScript 中函数声明仍然很受欢迎，但在现代代码中，函数表达式几乎总是箭头函数。
- en: 25.2.3 Parts of a function declaration
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 25.2.3 函数声明的各个部分
- en: Let’s examine the parts of a function declaration via the following example.
    Most of the terms also apply to function expressions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来检查函数声明的各个部分。大多数术语也适用于函数表达式。
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`add` is the *name* of the function declaration.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add` 是函数声明的 *名称*。'
- en: '`add(x, y)` is the *head* of the function declaration.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add(x, y)` 是函数声明的 *头部*。'
- en: '`x` and `y` are the *parameters*.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x` 和 `y` 是 *参数*。'
- en: The curly braces (`{` and `}`) and everything between them are the *body* of
    the function declaration.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花括号（`{` 和 `}`）及其之间的所有内容是函数声明的 *主体*。
- en: The `return` statement explicitly returns a value from the function.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return` 语句明确地从函数中返回一个值。'
- en: 25.2.3.1 Trailing commas in parameter lists
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 25.2.3.1 参数列表中的尾随逗号
- en: 'JavaScript has always allowed and ignored trailing commas in Array literals.
    Since ES5, they are also allowed in object literals. Since ES2017, we can add
    trailing commas to parameter lists (declarations and invocations):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 一直允许并忽略数组文字中的尾随逗号。自 ES5 以来，它们也允许在对象文字中。自 ES2017 以来，我们可以在参数列表（声明和调用）中添加尾随逗号：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 25.2.4 Roles played by ordinary functions
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 25.2.4 普通函数扮演的角色
- en: 'Consider the following function declaration from the previous section:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑前一节中的以下函数声明：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This function declaration creates an ordinary function whose name is `add`.
    As an ordinary function, `add()` can play three roles:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数声明创建了一个名为 `add` 的普通函数。作为普通函数，`add()` 可以扮演三种角色：
- en: 'Real function: invoked via a function call.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真实函数：通过函数调用调用。
- en: '[PRE9]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Method: stored in a property, invoked via a method call.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法：存储在属性中，通过方法调用调用。
- en: '[PRE10]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In line A, `obj` is called the *receiver* of the method call.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 A 行，`obj` 被称为方法调用的 *接收者*。
- en: 'Constructor function: invoked via `new`.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数：通过 `new` 调用。
- en: '[PRE11]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As an aside, the names of constructor functions (incl. classes) normally start
    with capital letters.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 顺便说一下，构造函数（包括类）的名称通常以大写字母开头。
- en: '25.2.5 Terminology: entity vs. syntax vs. role (advanced)'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 25.2.5 术语：实体 vs. 语法 vs. 角色（高级）
- en: 'The distinction between the concepts *syntax*, *entity*, and *role* is subtle
    and often doesn’t matter. But I’d like to sharpen your eye for it:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*语法*、*实体* 和 *角色* 的概念之间的区别是微妙的，通常并不重要。但我想让你对此有更敏锐的观察力：'
- en: An *entity* is a JavaScript feature as it “lives” in RAM. An ordinary function
    is an entity.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实体* 是 JavaScript 中的一个特性，因为它“存在”于 RAM 中。普通函数是一个实体。'
- en: 'Entities include: ordinary functions, arrow functions, methods, and classes.'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体包括：普通函数、箭头函数、方法和类。
- en: '*Syntax* is the code that we use to create entities. Function declarations
    and anonymous function expressions are syntax. They both create entities that
    are called ordinary functions.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*语法* 是我们用来创建实体的代码。函数声明和匿名函数表达式是语法。它们都创建被称为普通函数的实体。'
- en: 'Syntax includes: function declarations and anonymous function expressions.
    The syntax that produces arrow functions is also called *arrow functions*. The
    same is true for methods and classes.'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法包括：函数声明和匿名函数表达式。产生箭头函数的语法也称为 *箭头函数*。对于方法和类也是如此。
- en: A *role* describes how we use entities. The entity *ordinary function* can play
    the role *real function*, or the role *method*, or the role *class*. The entity
    *arrow function* can also play the role *real function*.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*角色* 描述了我们如何使用实体。实体 *普通函数* 可以扮演 *真实函数* 的角色，或者 *方法* 的角色，或者 *类* 的角色。实体 *箭头函数*
    也可以扮演 *真实函数* 的角色。'
- en: 'The roles of functions are: real function, method, and constructor function.'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的角色是：真实函数、方法和构造函数。
- en: Many other programming languages only have a single entity that plays the role
    *real function*. Then they can use the name *function* for both role and entity.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他编程语言只有一个实体扮演 *真实函数* 的角色。然后它们可以将 *函数* 这个名称用于角色和实体。
- en: 25.3 Specialized functions
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 25.3 专门的函数
- en: 'Specialized functions are single-purpose versions of ordinary functions. Each
    one of them specializes in a single role:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 专门的函数是普通函数的单一版本。它们中的每一个都专门从事一个角色：
- en: 'The purpose of an *arrow function* is to be a real function:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数的目的是成为真实函数：
- en: '[PRE12]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The purpose of a *method* is to be a method:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*方法* 的目的是成为方法：'
- en: '[PRE13]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The purpose of a *class* is to be a constructor function:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类* 的目的是成为构造函数：'
- en: '[PRE14]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Apart from nicer syntax, each kind of specialized function also supports new
    features, making them better at their jobs than ordinary functions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更好的语法之外，每种专门的函数还支持新功能，使它们在其工作中比普通函数更好。
- en: Arrow functions are explained soon.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数很快就会解释。
- en: Methods are explained [in the chapter on single objects](ch_objects.html#methods-and-this).
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法在[单个对象章节](ch_objects.html#methods-and-this)中有解释。
- en: Classes are explained [in the chapter on classes](ch_classes.html#classes).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类在[类章节](ch_classes.html#classes)中有解释。
- en: Tbl. [16](#tbl:capabilities-of-functions) lists the capabilities of ordinary
    and specialized functions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Tbl. [16](#tbl:capabilities-of-functions) 列出了普通和专门函数的功能。
- en: 'Table 16: Capabilities of four kinds of functions. If a cell value is in parentheses,
    that implies some kind of limitation. The special variable `this` is explained
    in [§25.3.3 “The special variable `this` in methods, ordinary functions and arrow
    functions”](ch_callables.html#this-in-callables).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 表16：四种函数的功能。如果单元格值在括号中，那意味着某种限制。特殊变量`this`在[§25.3.3 “方法、普通函数和箭头函数中的特殊变量`this`”](ch_callables.html#this-in-callables)中有解释。
- en: '|  | Function call | Method call | Constructor call |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|  | 函数调用 | 方法调用 | 构造函数调用 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Ordinary function | (`this === undefined`) | `✔` | `✔` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 普通函数 | (`this === undefined`) | `✔` | `✔` |'
- en: '| Arrow function | `✔` | (lexical `this`) | `✘` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 箭头函数 | `✔` | (词法`this`) | `✘` |'
- en: '| Method | (`this === undefined`) | `✔` | `✘` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | (`this === undefined`) | `✔` | `✘` |'
- en: '| Class | `✘` | `✘` | `✔` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 类 | `✘` | `✘` | `✔` |'
- en: 25.3.1 Specialized functions are still functions
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 25.3.1 专门函数仍然是函数
- en: 'It’s important to note that arrow functions, methods, and classes are still
    categorized as functions:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，箭头函数、方法和类仍然被归类为函数：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 25.3.2 Arrow functions
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 25.3.2 箭头函数
- en: 'Arrow functions were added to JavaScript for two reasons:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数被添加到JavaScript中有两个原因：
- en: To provide a more concise way for creating functions.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了提供一种更简洁的创建函数的方式。
- en: 'They work better as real functions inside methods: Methods can refer to the
    object that received a method call via the special variable `this`. Arrow functions
    can access the `this` of a surrounding method, ordinary functions can’t (because
    they have their own `this`).'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们在方法内部作为真正的函数工作得更好：方法可以通过特殊变量`this`引用接收方法调用的对象。箭头函数可以访问周围方法的`this`，普通函数不能（因为它们有自己的`this`）。
- en: We’ll first examine the syntax of arrow functions and then how `this` works
    in various functions.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将研究箭头函数的语法，然后再看各种函数中的`this`是如何工作的。
- en: 25.3.2.1 The syntax of arrow functions
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 25.3.2.1 箭头函数的语法
- en: 'Let’s review the syntax of an anonymous function expression:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下匿名函数表达式的语法：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The (roughly) equivalent arrow function looks as follows. Arrow functions are
    expressions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数的（大致）等效形式如下。箭头函数是表达式。
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, the body of the arrow function is a block. But it can also be an expression.
    The following arrow function works exactly like the previous one.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，箭头函数的体是一个块。但它也可以是一个表达式。下面的箭头函数与前一个完全相同。
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If an arrow function has only a single parameter and that parameter is an identifier
    (not [a destructuring pattern](ch_destructuring.html)) then you can omit the parentheses
    around the parameter:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果箭头函数只有一个参数，并且该参数是一个标识符（不是[解构模式](ch_destructuring.html)），那么你可以省略参数周围的括号：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'That is convenient when passing arrow functions as parameters to other functions
    or methods:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当将箭头函数作为参数传递给其他函数或方法时，这是很方便的：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This previous example demonstrates one benefit of arrow functions – conciseness.
    If we perform the same task with a function expression, our code is more verbose:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子展示了箭头函数的一个好处 - 简洁性。如果我们用函数表达式执行相同的任务，我们的代码会更冗长：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '25.3.2.2 Syntax pitfall: returning an object literal from an arrow function'
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 25.3.2.2 语法陷阱：从箭头函数返回对象字面量
- en: 'If you want the expression body of an arrow function to be an object literal,
    you must put the literal in parentheses:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望箭头函数的表达式体是一个对象字面量，你必须将字面量放在括号中：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you don’t, JavaScript thinks, the arrow function has a block body (that
    doesn’t return anything):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不这样做，JavaScript会认为箭头函数有一个块体（不返回任何东西）：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`{a: 1}` is interpreted as a block with [the label `a:`](ch_control-flow.html#labels)
    and the expression statement `1`. Without an explicit `return` statement, the
    block body returns `undefined`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`{a: 1}`被解释为一个带有[标签`a:`](ch_control-flow.html#labels)和表达式语句`1`的块。没有显式的`return`语句，块体返回`undefined`。'
- en: 'This pitfall is caused by [syntactic ambiguity](ch_syntax.html#ambiguous-syntax):
    object literals and code blocks have the same syntax. We use the parentheses to
    tell JavaScript that the body is an expression (an object literal) and not a statement
    (a block).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个陷阱是由[语法歧义](ch_syntax.html#ambiguous-syntax)引起的：对象字面量和代码块具有相同的语法。我们使用括号告诉JavaScript，体是一个表达式（对象字面量），而不是一个语句（块）。
- en: 25.3.3 The special variable `this` in methods, ordinary functions and arrow
    functions
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 25.3.3 方法、普通函数和箭头函数中的特殊变量`this`
- en: '![](../Images/ec8e6930fbe484fc519f3aa7b812c3fd.png)  **The special variable
    `this` is an object-oriented feature**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/ec8e6930fbe484fc519f3aa7b812c3fd.png)  **特殊变量`this`是面向对象的特性**'
- en: We are taking a quick look at the special variable `this` here, in order to
    understand why arrow functions are better real functions than ordinary functions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里快速看一下特殊变量`this`，以便理解为什么箭头函数比普通函数更好。
- en: But this feature only matters in object-oriented programming and is covered
    in more depth in [§28.5 “Methods and the special variable `this`”](ch_objects.html#methods-and-this).
    Therefore, don’t worry if you don’t fully understand it yet.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个特性只在面向对象编程中才重要，并且在[§28.5 “方法和特殊变量`this`”](ch_objects.html#methods-and-this)中有更深入的介绍。因此，如果你还没有完全理解，不要担心。
- en: 'Inside methods, the special variable `this` lets us access the *receiver* –
    the object which received the method call:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法内部，特殊变量`this`让我们可以访问*接收者* - 接收方法调用的对象：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Ordinary functions can be methods and therefore also have the implicit parameter
    `this`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 普通函数可以是方法，因此也有隐式参数`this`：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`this` is even an implicit parameter when we use an ordinary function as a
    real function. Then its value is `undefined` (if [strict mode](ch_syntax.html#strict-mode)
    is active, which it almost always is):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将普通函数用作真正的函数时，`this`甚至是一个隐式参数。然后它的值是`undefined`（如果[严格模式](ch_syntax.html#strict-mode)激活，几乎总是激活的）：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'That means that an ordinary function, used as a real function, can’t access
    the `this` of a surrounding method (line A). In contrast, arrow functions don’t
    have `this` as an implicit parameter. They treat it like any other variable and
    can therefore access the `this` of a surrounding method (line B):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着普通函数作为真正的函数时，无法访问周围方法的`this`（A行）。相反，箭头函数没有`this`作为隐式参数。它们将其视为任何其他变量，因此可以访问周围方法的`this`（B行）：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this code, we can observe two ways of handling `this`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们可以观察到处理`this`的两种方式：
- en: 'Dynamic `this`: In line A, we try to access the `this` of `.someMethod()` from
    an ordinary function. There, it is *shadowed* by the function’s own `this`, which
    is `undefined` (as filled in by the function call). Given that ordinary functions
    receive their `this` via (dynamic) function or method calls, their `this` is called
    *dynamic*.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态`this`：在A行，我们尝试从普通函数访问`.someMethod()`的`this`。在那里，它被函数自己的`this`*遮蔽*，这是`undefined`（由函数调用填充）。鉴于普通函数通过（动态）函数或方法调用接收它们的`this`，它们的`this`被称为*动态*。
- en: 'Lexical `this`: In line B, we again try to access the `this` of `.someMethod()`.
    This time, we succeed because the arrow function does not have its own `this`.
    `this` is resolved *lexically*, just like any other variable. That’s why the `this`
    of arrow functions is called *lexical*.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 词汇`this`：在B行，我们再次尝试访问`.someMethod()`的`this`。这次，我们成功了，因为箭头函数没有自己的`this`。`this`被*词法*解析，就像任何其他变量一样。这就是为什么箭头函数的`this`被称为*词法*。
- en: '25.3.4 Recommendation: prefer specialized functions over ordinary functions'
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 25.3.4 建议：优先选择专门的函数而不是普通函数
- en: Normally, you should prefer specialized functions over ordinary functions, especially
    classes and methods.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您应该优先选择专门的函数而不是普通函数，特别是类和方法。
- en: 'When it comes to real functions, the choice between an arrow function and an
    ordinary function is less clear-cut, though:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到真正的函数时，箭头函数和普通函数之间的选择并不那么明确：
- en: 'For anonymous inline function expressions, arrow functions are clear winners,
    due to their compact syntax and them not having `this` as an implicit parameter:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于匿名内联函数表达式，箭头函数是明显的赢家，因为它们的紧凑语法和它们不具有`this`作为隐式参数：
- en: '[PRE28]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For stand-alone named function declarations, arrow functions still benefit
    from lexical `this`. But function declarations (which produce ordinary functions)
    have nice syntax and early activation is also occasionally useful (see [§11.8
    “Declarations: scope and activation”](ch_variables-assignment.html#declarations-scope-activation)).
    If `this` doesn’t appear in the body of an ordinary function, there is no downside
    to using it as a real function. The static checking tool ESLint can warn us during
    development when we do this wrong via [a built-in rule](https://eslint.org/docs/rules/no-invalid-this).'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于独立的命名函数声明，箭头函数仍然受益于词法`this`。但是函数声明（产生普通函数）具有良好的语法，早期激活也偶尔有用（参见[§11.8“声明：范围和激活”](ch_variables-assignment.html#declarations-scope-activation)）。如果普通函数的主体中没有出现`this`，那么使用它作为真正的函数就没有任何缺点。在开发过程中，静态检查工具ESLint可以通过[内置规则](https://eslint.org/docs/rules/no-invalid-this)警告我们是否错误地这样做。
- en: '[PRE29]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '25.4 Summary: kinds of callable values'
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 25.4 总结：可调用值的种类
- en: '![](../Images/ec8e6930fbe484fc519f3aa7b812c3fd.png)  **This section refers
    to upcoming content**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/ec8e6930fbe484fc519f3aa7b812c3fd.png)  **本节涉及即将到来的内容**'
- en: This section mainly serves as a reference for the current and upcoming chapters.
    Don’t worry if you don’t understand everything.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 本节主要作为当前和即将到来的章节的参考。如果您不理解一切，不要担心。
- en: 'So far, all (real) functions and methods, that we have seen, were:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的所有（真正的）函数和方法都是：
- en: Single-result
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单结果
- en: Synchronous
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步
- en: 'Later chapters will cover other modes of programming:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 后续章节将涵盖其他编程模式：
- en: '*Iteration* treats objects as containers of data (so-called *iterables*) and
    provides a standardized way for retrieving what is inside them. If a function
    or a method returns an iterable, it returns multiple values.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*迭代*将对象视为数据容器（所谓的*可迭代*）并提供了一种标准化的方法来检索其中的内容。如果函数或方法返回可迭代对象，则会返回多个值。'
- en: '*Asynchronous programming* deals with handling a long-running computation.
    You are notified when the computation is finished and can do something else in
    between. The standard pattern for asynchronously delivering single results is
    called *Promise*.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异步编程*处理长时间运行的计算。当计算完成时，会通知您，并且可以在其中间做其他事情。异步交付单个结果的标准模式称为*Promise*。'
- en: These modes can be combined – for example, there are synchronous iterables and
    asynchronous iterables.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式可以组合使用-例如，有同步可迭代和异步可迭代。
- en: 'Several new kinds of functions and methods help with some of the mode combinations:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 几种新的函数和方法有助于处理一些模式组合：
- en: '*Async functions* help implement functions that return Promises. There are
    also *async methods*.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异步函数*有助于实现返回Promise的函数。还有*异步方法*。'
- en: '*Synchronous generator functions* help implement functions that return synchronous
    iterables. There are also *synchronous generator methods*.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*同步生成器函数*有助于实现返回同步可迭代对象的函数。还有*同步生成器方法*。'
- en: '*Asynchronous generator functions* help implement functions that return asynchronous
    iterables. There are also *asynchronous generator methods*.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异步生成器函数*有助于实现返回异步可迭代对象的函数。还有*异步生成器方法*。'
- en: 'That leaves us with 4 kinds (2 × 2) of functions and methods:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们有4种（2×2）函数和方法：
- en: Synchronous vs. asynchronous
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步与异步
- en: Generator vs. single-result
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器与单结果
- en: Tbl. [17](#tbl:syntax-functions-methods) gives an overview of the syntax for
    creating these 4 kinds of functions and methods.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Tbl. [17](#tbl:syntax-functions-methods)提供了创建这4种函数和方法的语法概述。
- en: 'Table 17: Syntax for creating functions and methods. The last column specifies
    how many values are produced by an entity.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  | **Result** | **#** |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| **Sync function** | **Sync method** |  |  |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| `function f() {}` | `{ m() {} }` | value | 1 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| `f = function () {}` |  |  |  |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| `f = () => {}` |  |  |  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| **Sync generator function** | **Sync gen. method** |  |  |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '| `function* f() {}` | `{ * m() {} }` | iterable | 0+ |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| `f = function* () {}` |  |  |  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| **Async function** | **Async method** |  |  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| `async function f() {}` | `{ async m() {} }` | Promise | 1 |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '| `f = async function () {}` |  |  |  |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: '| `f = async () => {}` |  |  |  |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
- en: '| **Async generator function** | **Async gen. method** |  |  |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
- en: '| `async function* f() {}` | `{ async * m() {} }` | async iterable | 0+ |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
- en: '| `f = async function* () {}` |  |  |  |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
- en: 25.5 Returning values from functions and methods
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (Everything mentioned in this section applies to both functions and methods.)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'The `return` statement explicitly returns a value from a function:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Another example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If, at the end of a function, you haven’t returned anything explicitly, JavaScript
    returns `undefined` for you:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 25.6 Parameter handling
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once again, I am only mentioning functions in this section, but everything also
    applies to methods.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '25.6.1 Terminology: parameters vs. arguments'
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The term *parameter* and the term *argument* basically mean the same thing.
    If you want to, you can make the following distinction:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '*Parameters* are part of a function definition. They are also called *formal
    parameters* and *formal arguments*.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Arguments* are part of a function call. They are also called *actual parameters*
    and *actual arguments*.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '25.6.2 Terminology: callback'
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *callback* or *callback function* is a function that is an argument of a function
    or method call.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a callback:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 25.6.3 Too many or not enough arguments
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'JavaScript does not complain if a function call provides a different number
    of arguments than expected by the function definition:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Extra arguments are ignored.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing parameters are set to `undefined`.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 25.6.4 Parameter default values
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Parameter default values specify the value to use if a parameter has not been
    provided – for example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`undefined` also triggers the default value:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 25.6.5 Rest parameters
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A rest parameter is declared by prefixing an identifier with three dots (`...`).
    During a function or method call, it receives an Array with all remaining arguments.
    If there are no extra arguments at the end, it is an empty Array – for example:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There are two restrictions related to how we can use rest parameters:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: We cannot use more than one rest parameter per function definition.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A rest parameter must always come last. As a consequence, we can’t access the
    last parameter like this:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 25.6.5.1 Enforcing a certain number of arguments via a rest parameter
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can use a rest parameter to enforce a certain number of arguments. Take,
    for example, the following function:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is how we force callers to always provide two arguments:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In line A, we access the elements of `args` via [*destructuring*](ch_destructuring.html).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 25.6.6 Named parameters
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When someone calls a function, the arguments provided by the caller are assigned
    to the parameters received by the callee. Two common ways of performing the mapping
    are:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Positional parameters: An argument is assigned to a parameter if they have
    the same position. A function call with only positional arguments looks as follows.'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Named parameters: An argument is assigned to a parameter if they have the same
    name. JavaScript doesn’t have named parameters, but you can simulate them. For
    example, this is a function call with only (simulated) named arguments:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Named parameters have several benefits:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'They lead to more self-explanatory code because each argument has a descriptive
    label. Just compare the two versions of `selectEntries()`: with the second one,
    it is much easier to see what happens.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of the arguments doesn’t matter (as long as the names are correct).
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数的顺序不重要（只要名称正确）。
- en: 'Handling more than one optional parameter is more convenient: callers can easily
    provide any subset of all optional parameters and don’t have to be aware of the
    ones they omit (with positional parameters, you have to fill in preceding optional
    parameters, with `undefined`).'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理多个可选参数比较方便：调用者可以轻松地提供所有可选参数的任意子集，并且不必知道省略的参数（对于位置参数，您必须填写前面的可选参数，使用`undefined`）。
- en: 25.6.7 Simulating named parameters
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 25.6.7 模拟命名参数
- en: 'JavaScript doesn’t have real named parameters. The official way of simulating
    them is via object literals:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript没有真正的命名参数。模拟它们的官方方式是通过对象字面量：
- en: '[PRE44]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This function uses [*destructuring*](ch_destructuring.html) to access the properties
    of its single parameter. The pattern it uses is an abbreviation for the following
    pattern:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用[*解构*](ch_destructuring.html)来访问其单个参数的属性。它使用的模式是以下模式的缩写：
- en: '[PRE45]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This destructuring pattern works for empty object literals:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解构模式适用于空对象字面量：
- en: '[PRE46]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'But it does not work if you call the function without any parameters:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你在没有任何参数的情况下调用函数，它就不起作用：
- en: '[PRE47]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can fix this by providing a default value for the whole pattern. This default
    value works the same as default values for simpler parameter definitions: if the
    parameter is missing, the default is used.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过为整个模式提供默认值来解决这个问题。这个默认值的工作方式与更简单的参数定义的默认值相同：如果参数缺失，则使用默认值。
- en: '[PRE48]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 25.6.8 Spreading (`...`) into function calls
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 25.6.8 扩展(`...`)到函数调用
- en: 'If you put three dots (`...`) in front of the argument of a function call,
    then you *spread* it. That means that the argument must be [an *iterable* object](ch_sync-iteration.html)
    and the iterated values all become arguments. In other words, a single argument
    is expanded into multiple arguments – for example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在函数调用的参数前面加上三个点(`...`)，那么就会*扩展*它。这意味着参数必须是[可迭代对象](ch_sync-iteration.html)，并且迭代的值都成为参数。换句话说，一个参数被扩展为多个参数
    - 例如：
- en: '[PRE49]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Spreading and rest parameters use the same syntax (`...`), but they serve opposite
    purposes:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展和剩余参数使用相同的语法(`...`)，但它们具有相反的目的：
- en: Rest parameters are used when defining functions or methods. They collect arguments
    into Arrays.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩余参数用于定义函数或方法时。它们将参数收集到数组中。
- en: Spread arguments are used when calling functions or methods. They turn iterable
    objects into arguments.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用函数或方法时使用扩展参数。它们将可迭代对象转换为参数。
- en: '25.6.8.1 Example: spreading into `Math.max()`'
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 25.6.8.1 示例：扩展到`Math.max()`
- en: '`Math.max()` returns the largest one of its zero or more arguments. Alas, it
    can’t be used for Arrays, but spreading gives us a way out:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.max()`返回其零个或多个参数中的最大值。遗憾的是，它不能用于数组，但扩展给了我们一条出路：'
- en: '[PRE50]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '25.6.8.2 Example: spreading into `Array.prototype.push()`'
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 25.6.8.2 示例：扩展到`Array.prototype.push()`
- en: 'Similarly, the Array method `.push()` destructively adds its zero or more parameters
    to the end of its Array. JavaScript has no method for destructively appending
    an Array to another one. Once again, we are saved by spreading:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，数组方法`.push()`会将其零个或多个参数破坏性地添加到数组的末尾。JavaScript没有一种方法可以将一个数组破坏性地附加到另一个数组上。我们再次通过扩展来解决这个问题：
- en: '[PRE51]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercises: Parameter
    handling**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **练习：参数处理**'
- en: 'Positional parameters: `exercises/callables/positional_parameters_test.mjs`'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置参数：`exercises/callables/positional_parameters_test.mjs`
- en: 'Named parameters: `exercises/callables/named_parameters_test.mjs`'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名参数：`exercises/callables/named_parameters_test.mjs`
- en: '25.7 Methods of functions: `.call()`, `.apply()`, `.bind()`'
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 25.7 函数的方法：`.call()`，`.apply()`，`.bind()`
- en: 'Functions are objects and have methods. In this section, we look at three of
    those methods: `.call()`, `.apply()`, and `.bind()`.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是对象，有方法。在本节中，我们将介绍其中三种方法：`.call()`，`.apply()`和`.bind()`。
- en: 25.7.1 The function method `.call()`
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 25.7.1 函数方法`.call()`
- en: 'Each function `someFunc` has the following method:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数`someFunc`都有以下方法：
- en: '[PRE52]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This method invocation is loosely equivalent to the following function call:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法调用大致相当于以下函数调用：
- en: '[PRE53]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'However, with `.call()`, we can also specify a value for [the implicit parameter
    `this`](ch_callables.html#this-in-callables). In other words: `.call()` makes
    the implicit parameter `this` explicit.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`.call()`，我们也可以为[隐式参数`this`](ch_callables.html#this-in-callables)指定一个值。换句话说：`.call()`使隐式参数`this`变为显式参数。
- en: 'The following code demonstrates the use of `.call()`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了`.call()`的使用：
- en: '[PRE54]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'As we have seen before, if we function-call an ordinary function, its `this`
    is `undefined`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，如果我们调用一个普通函数，它的`this`是`undefined`：
- en: '[PRE55]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Therefore, the previous function call is equivalent to:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的函数调用等价于：
- en: '[PRE56]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In arrow functions, the value for `this` provided via `.call()` (or other means)
    is ignored.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在箭头函数中，通过`.call()`（或其他方式）提供的`this`值会被忽略。
- en: 25.7.2 The function method `.apply()`
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 25.7.2 函数方法`.apply()`
- en: 'Each function `someFunc` has the following method:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数`someFunc`都有以下方法：
- en: '[PRE57]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This method invocation is loosely equivalent to the following function call
    (which uses [spreading](ch_callables.html#spread-arguments)):'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法调用大致相当于以下函数调用（使用[扩展](ch_callables.html#spread-arguments)）：
- en: '[PRE58]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: However, with `.apply()`, we can also specify a value for [the implicit parameter
    `this`](ch_callables.html#this-in-callables).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`.apply()`，我们也可以为[隐式参数`this`](ch_callables.html#this-in-callables)指定一个值。
- en: 'The following code demonstrates the use of `.apply()`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了`.apply()`的使用：
- en: '[PRE59]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 25.7.3 The function method `.bind()`
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 25.7.3 函数方法`.bind()`
- en: '`.bind()` is another method of function objects. This method is invoked as
    follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`.bind()`是函数对象的另一种方法。该方法的调用方式如下：'
- en: '[PRE60]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`.bind()` returns a new function `boundFunc()`. Calling that function invokes
    `someFunc()` with `this` set to `thisValue` and these parameters: `arg1`, `arg2`,
    followed by the parameters of `boundFunc()`.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`.bind()`返回一个新的函数`boundFunc()`。调用该函数会将`this`设置为`thisValue`并传入这些参数：`arg1`，`arg2`，以及`boundFunc()`的参数。'
- en: 'That is, the following two function calls are equivalent:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，以下两个函数调用是等价的：
- en: '[PRE61]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 25.7.3.1 An alternative to `.bind()`
  id: totrans-317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 25.7.3.1 `.bind()`的替代方法
- en: 'Another way of pre-filling `this` and parameters is via an arrow function:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种预填充`this`和参数的方法是通过箭头函数：
- en: '[PRE62]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 25.7.3.2 An implementation of `.bind()`
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 25.7.3.2 `.bind()`的实现
- en: 'Considering the previous section, `.bind()` can be implemented as a real function
    as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到前一节，`.bind()`可以实现为一个真实函数，如下所示：
- en: '[PRE63]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '25.7.3.3 Example: binding a real function'
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 25.7.3.3 示例：绑定一个真实函数
- en: Using `.bind()` for real functions is somewhat unintuitive because we have to
    provide a value for `this`. Given that it is `undefined` during function calls,
    it is usually set to `undefined` or `null`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 对于真实函数使用`.bind()`有点不直观，因为我们必须为`this`提供一个值。鉴于在函数调用期间它是`undefined`，通常将其设置为`undefined`或`null`。
- en: In the following example, we create `add8()`, a function that has one parameter,
    by binding the first parameter of `add()` to `8`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们通过将`add()`的第一个参数绑定到`8`来创建一个只有一个参数的函数`add8()`。
- en: '[PRE64]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png) **测验**'
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[测验应用程序](ch_quizzes-exercises.html#quizzes)。
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/17)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '[评论](https://github.com/rauschma/impatient-js/issues/17)'
