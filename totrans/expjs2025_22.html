<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>18 Numbers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>18 Numbers</h1>
<blockquote>原文：<a href="https://exploringjs.com/js/book/ch_numbers.html">https://exploringjs.com/js/book/ch_numbers.html</a></blockquote>

        
    
    
    
<p><span id="index-entry-number"/></p>
<nav class="local-toc">
  <ol>
    <li>
      <a href="#numbers-are-used-for-both-floating-point-numbers-and-integers">18.1 Numbers are used for both floating point numbers and integers</a>
    </li>
    <li>
      <a href="#number-literals">18.2 Number literals</a>
      <ol>
        <li>
          <a href="#integer-literals">18.2.1 Integer literals</a>
        </li>
        <li>
          <a href="#floating-point-literals">18.2.2 Floating point literals</a>
        </li>
        <li>
          <a href="#properties-of-decimal-integer-literals">18.2.3 Syntactic pitfall: properties of decimal integer literals</a>
        </li>
        <li>
          <a href="#numeric-separator-number-literals">18.2.4 Underscores (<code>_</code>) as separators in number literals<span> <sup>ES2021</sup></span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#arithmetic-operators">18.3 Arithmetic operators</a>
      <ol>
        <li>
          <a href="#binary-arithmetic-operators">18.3.1 Binary arithmetic operators</a>
        </li>
        <li>
          <a href="#unary-plus--and-negation-">18.3.2 Unary plus (<code>+</code>) and negation (<code>-</code>)</a>
        </li>
        <li>
          <a href="#incrementing--and-decrementing-">18.3.3 Incrementing (<code>++</code>) and decrementing (<code>--</code>)</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#converting-to-number">18.4 Converting to number</a>
    </li>
    <li>
      <a href="#numeric-error-values">18.5 The numeric error values <code>NaN</code> and <code>Infinity</code></a>
      <ol>
        <li>
          <a href="#NaN">18.5.1 Error value: <code>NaN</code></a>
        </li>
        <li>
          <a href="#error-value-infinity">18.5.2 Error value: <code>Infinity</code></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#the-precision-of-numbers-careful-with-decimal-fractions">18.6 The precision of numbers: careful with decimal fractions</a>
    </li>
    <li>
      <a href="#advanced-2">18.7 (Advanced)</a>
    </li>
    <li>
      <a href="#floating-point-precision">18.8 Background: floating point precision</a>
      <ol>
        <li>
          <a href="#a-simplified-representation-of-floating-point-numbers">18.8.1 A simplified representation of floating point numbers</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#integer-numbers">18.9 Integer numbers in JavaScript</a>
      <ol>
        <li>
          <a href="#how-are-integers-different-from-floating-point-numbers-with-fractions">18.9.1 How are integers different from floating point numbers with fractions?</a>
        </li>
        <li>
          <a href="#converting-to-integer">18.9.2 Converting to integer</a>
        </li>
        <li>
          <a href="#ranges-of-integer-numbers-in-javascript">18.9.3 Ranges of integer numbers in JavaScript</a>
        </li>
        <li>
          <a href="#safe-integers">18.9.4 Safe integers</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#bitwise-operators-advanced">18.10 Bitwise operators<span> (advanced)</span></a>
      <ol>
        <li>
          <a href="#bitwise-operators-32-bit-operands">18.10.1 Internally, bitwise operators work with 32-bit integers</a>
        </li>
        <li>
          <a href="#bitwise-not">18.10.2 Bitwise Not</a>
        </li>
        <li>
          <a href="#binary-bitwise-operators">18.10.3 Binary bitwise operators</a>
        </li>
        <li>
          <a href="#bitwise-shift-operators">18.10.4 Bitwise shift operators</a>
        </li>
        <li>
          <a href="#b32">18.10.5 <code>b32()</code>: displaying unsigned 32-bit integers in binary notation</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#quick-reference-numbers">18.11 Quick reference: numbers</a>
      <ol>
        <li>
          <a href="#global-functions-for-numbers">18.11.1 Global functions for numbers</a>
        </li>
        <li>
          <a href="#number-data-properties">18.11.2 <code>Number.*</code>: data properties</a>
        </li>
        <li>
          <a href="#number-methods">18.11.3 <code>Number.*</code>: methods</a>
        </li>
        <li>
          <a href="#numberprototype">18.11.4 <code>Number.prototype.*</code></a>
        </li>
        <li>
          <a href="#number-data-properties-and-methods-for-integers">18.11.5 <code>Number.*</code>: data properties and methods for integers</a>
        </li>
        <li>
          <a href="#sources">18.11.6 Sources</a>
        </li>
      </ol>
    </li>
  </ol>
</nav>
<p>JavaScript has two kinds of numeric values:</p>
<ul>
  <li>
    <em>Numbers</em> are <em>doubles</em> – 64-bit floating point numbers implemented according to the <em>IEEE Standard for Floating-Point Arithmetic</em> (IEEE 754).
    <ul>
      <li>
        They are also used for smaller integers within a range of plus/minus 53 bits. For more information, see <a href="#integer-numbers">“Integer numbers in JavaScript” (§18.9)</a>.
      </li>
    </ul>
  </li>
  <li>
    <em>Bigints</em> represent integers with an arbitrary precision.
  </li>
</ul>
<p>This chapter covers numbers. Bigints are covered <a href="ch_bigints.html#ch_bigints">later in this book</a>.</p>
<h3 id="numbers-are-used-for-both-floating-point-numbers-and-integers"><a class="heading-id-link" href="#numbers-are-used-for-both-floating-point-numbers-and-integers">18.1 Numbers are used for both floating point numbers and integers</a></h3>
<p>The type <code>number</code> is used for both floating point numbers and integers in JavaScript:</p>
<pre class="language-js">
<code><span class="hljs-number">123.45</span> <span class="hljs-comment">// floating point number literal</span></code>
<code><span class="hljs-number">98</span> <span class="hljs-comment">// integer literal</span></code>
</pre>
<p>However, all numbers are floating point numbers. Integer numbers are simply floating point numbers without a decimal fraction:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">98</span> === <span class="hljs-number">98.0</span></span></code>
<code>true</code>
</pre>
<h3 id="number-literals"><a class="heading-id-link" href="#number-literals">18.2 Number literals</a></h3>
<p>Let’s examine literals for numbers.</p>
<h4 id="integer-literals"><a class="heading-id-link" href="#integer-literals">18.2.1 Integer literals</a></h4>
<p><span id="index-entry-binary-integer-literal"/><span id="index-entry-octal-integer-literal"/><span id="index-entry-decimal-integer-literal"/><span id="index-entry-hexadecimal-integer-literal"/></p>
<p>Several <em>integer literals</em> let us express integers with various bases:</p>
<pre class="language-js">
<code><span class="hljs-comment">// Binary (base 2)</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">0b11</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// ES6</span></code>
<code/>
<code><span class="hljs-comment">// Octal (base 8)</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">0o10</span>, <span class="hljs-number">8</span>); <span class="hljs-comment">// ES6</span></code>
<code/>
<code><span class="hljs-comment">// Decimal (base 10)</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">35</span>, <span class="hljs-number">35</span>);</code>
<code/>
<code><span class="hljs-comment">// Hexadecimal (base 16)</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">0xE7</span>, <span class="hljs-number">231</span>);</code>
</pre>
<h4 id="floating-point-literals"><a class="heading-id-link" href="#floating-point-literals">18.2.2 Floating point literals</a></h4>
<p><span id="index-entry-floating-point-literal"/><span id="index-entry-decimal-floating-point-literal"/></p>
<p>Floating point numbers can only be expressed in base 10.</p>
<p>Fractions:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">35.0</span></span></code>
<code>35</code>
</pre>
<p>Exponent: <code>eN</code> means ×10<sup>N</sup></p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">3e2</span></span></code>
<code>300</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">3e-2</span></span></code>
<code>0.03</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">0.3e2</span></span></code>
<code>30</code>
</pre>
<h4 id="properties-of-decimal-integer-literals"><a class="heading-id-link" href="#properties-of-decimal-integer-literals">18.2.3 Syntactic pitfall: properties of decimal integer literals</a></h4>
<p>Accessing a property of an decimal integer literal entails a pitfall: If the decimal integer literal is immediately followed by a dot, then that dot is interpreted as a decimal dot:</p>
<pre class="language-txt">
<code>7.toString(); // SyntaxError</code>
</pre>
<p>There are four ways to work around this pitfall:</p>
<pre class="language-js">
<code>(<span class="hljs-number">7</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>)</code>
<code><span class="hljs-number">7.0</span>.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>)</code>
<code><span class="hljs-number">7.</span>.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>)</code>
<code><span class="hljs-number">7</span> .<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>)  <span class="hljs-comment">// space before dot</span></code>
</pre>
<p>Note that non-decimal integer literals don’t have this pitfall:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">0b11</span>.<span class="hljs-title function_">toString</span>()</span></code>
<code>'3'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">0o11</span>.<span class="hljs-title function_">toString</span>()</span></code>
<code>'9'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">0x11</span>.<span class="hljs-title function_">toString</span>()</span></code>
<code>'17'</code>
</pre>
<h4 id="numeric-separator-number-literals"><a class="heading-id-link" href="#numeric-separator-number-literals">18.2.4 Underscores (<code>_</code>) as separators in number literals<span> <sup>ES2021</sup></span></a></h4>
<p>Grouping digits to make long numbers more readable has a long tradition. For example:</p>
<ul>
  <li>
    In 1825, London had 1,335,000 inhabitants. 
  </li>
  <li>
    The distance between Earth and Sun is 149,600,000 km.
  </li>
</ul>
<p>Since ES2021, we can use underscores as separators in number literals:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> inhabitantsOfLondon = <span class="hljs-number">1_335_000</span>;</code>
<code><span class="hljs-keyword">const</span> distanceEarthSunInKm = <span class="hljs-number">149_600_000</span>;</code>
</pre>
<p>With other bases, grouping is important, too:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> fileSystemPermission = <span class="hljs-number">0b111_111_000</span>;</code>
<code><span class="hljs-keyword">const</span> bytes = <span class="hljs-number">0b1111_10101011_11110000_00001101</span>;</code>
<code><span class="hljs-keyword">const</span> words = <span class="hljs-number">0xFAB_F00D</span>;</code>
</pre>
<p>We can also use the separator in fractions and exponents:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> massOfElectronInKg = <span class="hljs-number">9.109_383_56e-31</span>;</code>
<code><span class="hljs-keyword">const</span> trillionInShortScale = <span class="hljs-number">1e1_2</span>;</code>
</pre>
<h5 id="where-can-we-put-separators"><a class="heading-id-link" href="#where-can-we-put-separators">18.2.4.1 Where can we put separators?</a></h5>
<p>The locations of separators are restricted in two ways:</p>
<ul>
  <li>
    <p>We can only put underscores between two digits. Therefore, all of the following number literals are illegal:</p>
<pre class="language-js">
<code>3_<span class="hljs-number">.141</span></code>
<code><span class="hljs-number">3.</span>_141</code>
<code/>
<code>1_e12</code>
<code>1e_12</code>
<code/>
<code>_1464301  <span class="hljs-comment">// valid variable name!</span></code>
<code>1464301_</code>
<code/>
<code>0_b111111000</code>
<code>0b_111111000</code>
</pre>
  </li>
  <li>
    <p>We can’t use more than one underscore in a row:</p>
<pre class="language-js">
<code>123__456 <span class="hljs-comment">// two underscores – not allowed</span></code>
</pre>
  </li>
</ul>
<p>The motivation behind these restrictions is to keep parsing simple and to avoid strange edge cases.</p>
<h5 id="parsing-numbers-with-separators"><a class="heading-id-link" href="#parsing-numbers-with-separators">18.2.4.2 Parsing numbers with separators</a></h5>
<p>The following functions for parsing numbers do not support separators:</p>
<ul>
  <li>
    <code>Number()</code>
  </li>
  <li>
    <code>Number.parseInt()</code>
  </li>
  <li>
    <code>Number.parseFloat()</code>
  </li>
</ul>
<p>For example:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>(<span class="hljs-string">'123_456'</span>)</span></code>
<code>NaN</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'123_456'</span>)</span></code>
<code>123</code>
</pre>
<p>The rationale is that numeric separators are for code. Other kinds of input should be processed differently.</p>
<h3 id="arithmetic-operators"><a class="heading-id-link" href="#arithmetic-operators">18.3 Arithmetic operators</a></h3>
<h4 id="binary-arithmetic-operators"><a class="heading-id-link" href="#binary-arithmetic-operators">18.3.1 Binary arithmetic operators</a></h4>
<p><span id="index-entry-minus-operator--binary-"/><span id="index-entry-.x-y2"/><span id="index-entry-subtraction"/>
<span id="index-entry-times-operator"/><span id="index-entry-.x-y3"/><span id="index-entry-multiplication"/>
<span id="index-entry-divided-by-operator"/><span id="index-entry-.x-y4"/><span id="index-entry-division"/>
<span id="index-entry-remainder-operator"/><span id="index-entry-.x٪y"/>
<span id="index-entry-to-the-power-of-operator"/><span id="index-entry-.x--y3"/><span id="index-entry-exponentiation"/></p>
<p><a href="#tbl:binary-arithmetic-operators">Table 18.1</a> lists JavaScript’s binary arithmetic operators.</p>
<figure id="tbl:binary-arithmetic-operators" class="float">
  <table class="framed">
    <style>
      th:nth-child(1), td:nth-child(1) {
        text-align: left;
      }
      th:nth-child(2), td:nth-child(2) {
        text-align: left;
      }
      th:nth-child(3), td:nth-child(3) {
        text-align: left;
      }
      th:nth-child(4), td:nth-child(4) {
        text-align: left;
      }
    </style>
    <thead>
      <tr>
        <th>Operator</th><th>Name</th><th/><th>Example</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>n + m</code></td><td>Addition</td><td>ES1</td><td><code>3 + 4</code> → <code>7</code></td>
      </tr>
      <tr>
        <td><code>n - m</code></td><td>Subtraction</td><td>ES1</td><td><code>9 - 1</code> → <code>8</code></td>
      </tr>
      <tr>
        <td><code>n * m</code></td><td>Multiplication</td><td>ES1</td><td><code>3 * 2.25</code> → <code>6.75</code></td>
      </tr>
      <tr>
        <td><code>n / m</code></td><td>Division</td><td>ES1</td><td><code>5.625 / 5</code> → <code>1.125</code></td>
      </tr>
      <tr>
        <td><code>n % m</code></td><td>Remainder</td><td>ES1</td><td><code>8 % 5</code> → <code>3</code></td>
      </tr>
      <tr>
        <td/><td/><td/><td><code>-8 % 5</code> → <code>-3</code></td>
      </tr>
      <tr>
        <td><code>n ** m</code></td><td>Exponentiation</td><td>ES2016</td><td><code>4 ** 2</code> → <code>16</code></td>
      </tr>
    </tbody>
  </table>
  <figcaption>
    <p><span class="float-label">Table 18.1:</span> Binary arithmetic operators.</p>
  </figcaption>
</figure>
<h5 id="is-a-remainder-operator"><a class="heading-id-link" href="#-is-a-remainder-operator">18.3.1.1 <code>%</code> is a remainder operator</a></h5>
<p><code>%</code> is a remainder operator, not a modulo operator. Its result has the sign of the first operand:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">5</span> % <span class="hljs-number">3</span></span></code>
<code>2</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">-<span class="hljs-number">5</span> % <span class="hljs-number">3</span></span></code>
<code>-2</code>
</pre>
<p>For more information on the difference between remainder and modulo, see the blog post <a href="https://2ality.com/2019/08/remainder-vs-modulo.html">“Remainder operator vs. modulo operator (with JavaScript code)”</a> on 2ality.</p>
<h4 id="unary-plus--and-negation-"><a class="heading-id-link" href="#unary-plus--and-negation-">18.3.2 Unary plus (<code>+</code>) and negation (<code>-</code>)</a></h4>
<p><span id="index-entry-plus-operator--unary-"/><span id="index-entry--x"/>
<span id="index-entry-minus-operator--unary-"/><span id="index-entry--x2"/></p>
<p><a href="#tbl:unary-plus-negation">Table 18.2</a> summarizes the two operators <em>unary plus</em> (<code>+</code>) and <em>negation</em> (<code>-</code>).</p>
<figure id="tbl:unary-plus-negation" class="float">
  <table class="framed">
    <style>
      th:nth-child(1), td:nth-child(1) {
        text-align: left;
      }
      th:nth-child(2), td:nth-child(2) {
        text-align: left;
      }
      th:nth-child(3), td:nth-child(3) {
        text-align: left;
      }
      th:nth-child(4), td:nth-child(4) {
        text-align: left;
      }
    </style>
    <thead>
      <tr>
        <th>Operator</th><th>Name</th><th/><th>Example</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>+n</code></td><td>Unary plus</td><td>ES1</td><td><code>+(-7)</code> → <code>-7</code></td>
      </tr>
      <tr>
        <td><code>-n</code></td><td>Unary negation</td><td>ES1</td><td><code>-(-7)</code> → <code>7</code></td>
      </tr>
    </tbody>
  </table>
  <figcaption>
    <p><span class="float-label">Table 18.2:</span> The operators unary plus (<code>+</code>) and negation (<code>-</code>).</p>
  </figcaption>
</figure>
<p>Both operators coerce their operands to numbers:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">+<span class="hljs-string">'5'</span></span></code>
<code>5</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">+<span class="hljs-string">'-12'</span></span></code>
<code>-12</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">-<span class="hljs-string">'9'</span></span></code>
<code>-9</code>
</pre>
<p>Thus, unary plus lets us convert arbitrary values to numbers.</p>
<h4 id="incrementing--and-decrementing-"><a class="heading-id-link" href="#incrementing--and-decrementing-">18.3.3 Incrementing (<code>++</code>) and decrementing (<code>--</code>)</a></h4>
<p><span id="index-entry-incrementation-operator--prefix-"/><span id="index-entry---prefix"/>
<span id="index-entry-incrementation-operator--suffix-"/><span id="index-entry---suffix"/>
<span id="index-entry-decrementation-operator--prefix-"/><span id="index-entry---prefix2"/>
<span id="index-entry-decrementation-operator--suffix-"/><span id="index-entry---suffix2"/></p>
<p>The incrementation operator <code>++</code> exists in a prefix version and a suffix version. In both versions, it destructively adds one to its operand. Therefore, its operand must be a storage location that can be changed.</p>
<p>The decrementation operator <code>--</code> works the same, but subtracts one from its operand. The next two examples explain the difference between the prefix and the suffix version.</p>
<p><a href="#tbl:incrementing-decrementing">Table 18.3</a> summarizes the incrementation and decrementation operators.</p>
<figure id="tbl:incrementing-decrementing" class="float">
  <table class="framed">
    <style>
      th:nth-child(1), td:nth-child(1) {
        text-align: left;
      }
      th:nth-child(2), td:nth-child(2) {
        text-align: left;
      }
      th:nth-child(3), td:nth-child(3) {
        text-align: left;
      }
      th:nth-child(4), td:nth-child(4) {
        text-align: left;
      }
    </style>
    <thead>
      <tr>
        <th>Operator</th><th>Name</th><th/><th>Example</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>v++</code></td><td>Increment</td><td>ES1</td><td><code>let v=0; [v++, v]</code> → <code>[0, 1]</code></td>
      </tr>
      <tr>
        <td><code>++v</code></td><td>Increment</td><td>ES1</td><td><code>let v=0; [++v, v]</code> → <code>[1, 1]</code></td>
      </tr>
      <tr>
        <td><code>v--</code></td><td>Decrement</td><td>ES1</td><td><code>let v=1; [v--, v]</code> → <code>[1, 0]</code></td>
      </tr>
      <tr>
        <td><code>--v</code></td><td>Decrement</td><td>ES1</td><td><code>let v=1; [--v, v]</code> → <code>[0, 0]</code></td>
      </tr>
    </tbody>
  </table>
  <figcaption>
    <p><span class="float-label">Table 18.3:</span> Incrementation operators and decrementation operators.</p>
  </figcaption>
</figure>
<p>Next, we’ll look at examples of these operators in use.</p>
<p>Prefix <code>++</code> and prefix <code>--</code> change their operands and then return them.</p>
<pre class="language-js">
<code><span class="hljs-keyword">let</span> foo = <span class="hljs-number">3</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(++foo, <span class="hljs-number">4</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(foo, <span class="hljs-number">4</span>);</code>
<code/>
<code><span class="hljs-keyword">let</span> bar = <span class="hljs-number">3</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(--bar, <span class="hljs-number">2</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(bar, <span class="hljs-number">2</span>);</code>
</pre>
<p>Suffix <code>++</code> and suffix <code>--</code> return their operands and then change them.</p>
<pre class="language-js">
<code><span class="hljs-keyword">let</span> foo = <span class="hljs-number">3</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(foo++, <span class="hljs-number">3</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(foo, <span class="hljs-number">4</span>);</code>
<code/>
<code><span class="hljs-keyword">let</span> bar = <span class="hljs-number">3</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(bar--, <span class="hljs-number">3</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(bar, <span class="hljs-number">2</span>);</code>
</pre>
<h5 id="operands-not-just-variables"><a class="heading-id-link" href="#operands-not-just-variables">18.3.3.1 Operands: not just variables</a></h5>
<p>We can also apply these operators to property values:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> };</code>
<code>++obj.<span class="hljs-property">a</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(obj.<span class="hljs-property">a</span>, <span class="hljs-number">2</span>);</code>
</pre>
<p>And to Array elements:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> arr = [ <span class="hljs-number">4</span> ];</code>
<code>arr[<span class="hljs-number">0</span>]++;</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(arr, [<span class="hljs-number">5</span>]);</code>
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Number operators</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/numbers/is_odd_test.mjs</code></p>
</div>
<h3 id="converting-to-number"><a class="heading-id-link" href="#converting-to-number">18.4 Converting to number</a></h3>
<p><span id="index-entry-Number--"/></p>
<p>These are three ways of converting values to numbers:</p>
<ul>
  <li>
    <code>Number(value)</code>: has a descriptive name and is therefore recommended. <a href="#tbl:converting-values-to-numbers">Table 18.4</a> summarizes how it works.
  </li>
  <li>
    <code>+value</code>: is equivalent to <code>Number(value)</code>.
  </li>
  <li>
    <code>parseFloat(value)</code>: has <a href="#qref-Number.parseFloat">quirks</a> and should be avoided.
  </li>
</ul>
<figure id="tbl:converting-values-to-numbers" class="float">
  <table class="framed">
    <style>
      th:nth-child(1), td:nth-child(1) {
        text-align: left;
      }
      th:nth-child(2), td:nth-child(2) {
        text-align: left;
      }
    </style>
    <thead>
      <tr>
        <th><code>x</code></th><th><code>Number(x)</code></th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>undefined</code></td><td><code>NaN</code></td>
      </tr>
      <tr>
        <td><code>null</code></td><td><code>0</code></td>
      </tr>
      <tr>
        <td>boolean</td><td><code>false</code> → <code>0</code>, <code>true</code> → <code>1</code></td>
      </tr>
      <tr>
        <td>number</td><td><code>x</code> (no change)</td>
      </tr>
      <tr>
        <td>bigint</td><td><code>-1n</code> → <code>-1</code>, <code>1n</code> → <code>1</code>, etc.</td>
      </tr>
      <tr>
        <td>string</td><td><code>''</code> → <code>0</code></td>
      </tr>
      <tr>
        <td/><td>Other → parsed number, ignoring leading/trailing whitespace</td>
      </tr>
      <tr>
        <td>symbol</td><td>Throws <code>TypeError</code></td>
      </tr>
      <tr>
        <td>object</td><td>Configurable (e.g. via <code>.valueOf()</code>)</td>
      </tr>
    </tbody>
  </table>
  <figcaption>
    <p><span class="float-label">Table 18.4:</span> Converting values to numbers.</p>
  </figcaption>
</figure>
<p>Examples:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-number">123.45</span>), <span class="hljs-number">123.45</span>);</code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-string">''</span>), <span class="hljs-number">0</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-string">'\n 123.45 \t'</span>), <span class="hljs-number">123.45</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-string">'xyz'</span>), <span class="hljs-title class_">NaN</span>);</code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">Number</span>(-<span class="hljs-number">123n</span>), -<span class="hljs-number">123</span>);</code>
</pre>
<p>How objects are converted to numbers can be configured – for example, by overriding <code>.valueOf()</code>:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>({ <span class="hljs-title function_">valueOf</span>(<span class="hljs-params"/>) { <span class="hljs-keyword">return</span> <span class="hljs-number">123</span> } })</span></code>
<code>123</code>
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Converting to number</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/numbers/parse_number_test.mjs</code></p>
</div>
<h3 id="numeric-error-values"><a class="heading-id-link" href="#numeric-error-values">18.5 The numeric error values <code>NaN</code> and <code>Infinity</code></a></h3>
<p>JavaScript has two numeric error values:</p>
<ul>
  <li>
    <code>NaN</code>:
    <ul>
      <li>
        Returned if parsing a number doesn’t work or an operation can’t be performed.
      </li>
      <li>
        Detected via <code>Number.isNaN()</code>. <code>NaN</code> is not strictly equal to itself.
      </li>
    </ul>
  </li>
  <li>
    <code>Infinity</code>:
    <ul>
      <li>
        Returned if a number is too large or if a number is divided by zero.
      </li>
      <li>
        Detected via <code>Number.isFinite()</code> or by comparing via <code>===</code>.
      </li>
    </ul>
  </li>
</ul>
<h4 id="NaN"><a class="heading-id-link" href="#NaN">18.5.1 Error value: <code>NaN</code></a></h4>
<p><span id="index-entry-NaN"/></p>
<p><code>NaN</code> is an abbreviation of “not a number”. Ironically, JavaScript considers it to be a number:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">NaN</span></span></code>
<code>'number'</code>
</pre>
<p>When is <code>NaN</code> returned?</p>
<p><code>NaN</code> is returned if a number can’t be parsed:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>(<span class="hljs-string">'$$$'</span>)</span></code>
<code>NaN</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>(<span class="hljs-literal">undefined</span>)</span></code>
<code>NaN</code>
</pre>
<p><code>NaN</code> is returned if an operation can’t be performed:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">log</span>(-<span class="hljs-number">1</span>)</span></code>
<code>NaN</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(-<span class="hljs-number">1</span>)</span></code>
<code>NaN</code>
</pre>
<p><code>NaN</code> is returned if an operand or argument is <code>NaN</code> (to propagate errors):</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">NaN</span> - <span class="hljs-number">3</span></span></code>
<code>NaN</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">7</span> ** <span class="hljs-title class_">NaN</span></span></code>
<code>NaN</code>
</pre>
<h5 id="checking-for-nan"><a class="heading-id-link" href="#checking-for-nan">18.5.1.1 Checking for <code>NaN</code></a></h5>
<p><code>NaN</code> is the only JavaScript value that is not strictly equal to itself:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> n = <span class="hljs-title class_">NaN</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(n === n, <span class="hljs-literal">false</span>);</code>
</pre>
<p>These are several ways of checking if a value <code>x</code> is <code>NaN</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> x = <span class="hljs-title class_">NaN</span>;</code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(x), <span class="hljs-literal">true</span>); <span class="hljs-comment">// preferred</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(x, <span class="hljs-title class_">NaN</span>), <span class="hljs-literal">true</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(x !== x, <span class="hljs-literal">true</span>);</code>
</pre>
<p>In the last line, we use the comparison quirk to detect <code>NaN</code>.</p>
<h5 id="finding-nan-in-arrays"><a class="heading-id-link" href="#finding-nan-in-arrays">18.5.1.2 Finding <code>NaN</code> in Arrays</a></h5>
<p>Some Array methods can’t find <code>NaN</code>:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-title class_">NaN</span>].<span class="hljs-title function_">indexOf</span>(<span class="hljs-title class_">NaN</span>)</span></code>
<code>-1</code>
</pre>
<p>Others can:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-title class_">NaN</span>].<span class="hljs-title function_">includes</span>(<span class="hljs-title class_">NaN</span>)</span></code>
<code>true</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-title class_">NaN</span>].<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(x))</span></code>
<code>0</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-title class_">NaN</span>].<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(x))</span></code>
<code>NaN</code>
</pre>
<p>Alas, there is no simple rule of thumb. We have to check for each method how it handles <code>NaN</code>.</p>
<h4 id="error-value-infinity"><a class="heading-id-link" href="#error-value-infinity">18.5.2 Error value: <code>Infinity</code></a></h4>
<p><span id="index-entry-Infinity"/></p>
<p>When is the error value <code>Infinity</code> returned?</p>
<p><code>Infinity</code> is returned if a number is too large:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1023</span>)</span></code>
<code>8.98846567431158e+307</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1024</span>)</span></code>
<code>Infinity</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">-<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1024</span>)</span></code>
<code>-Infinity</code>
</pre>
<p><code>Infinity</code> is returned if there is a division by zero:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">5</span> / <span class="hljs-number">0</span></span></code>
<code>Infinity</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">-<span class="hljs-number">5</span> / <span class="hljs-number">0</span></span></code>
<code>-Infinity</code>
</pre>
<h5 id="infinity-as-a-default-value"><a class="heading-id-link" href="#infinity-as-a-default-value">18.5.2.1 <code>Infinity</code> as a default value</a></h5>
<p><code>Infinity</code> is larger than all other numbers (except <code>NaN</code>), making it a good default value:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMinimum</span>(<span class="hljs-params">numbers</span>) {</code>
<code>  <span class="hljs-keyword">let</span> min = <span class="hljs-title class_">Infinity</span>;</code>
<code>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> n <span class="hljs-keyword">of</span> numbers) {</code>
<code>    <span class="hljs-keyword">if</span> (n &lt; min) min = n;</code>
<code>  }</code>
<code>  <span class="hljs-keyword">return</span> min;</code>
<code>}</code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">findMinimum</span>([<span class="hljs-number">5</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]), -<span class="hljs-number">1</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">findMinimum</span>([]), <span class="hljs-title class_">Infinity</span>);</code>
</pre>
<p>This explains the following result:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>()</span></code>
<code>Infinity</code>
</pre>
<h5 id="checking-for-infinity"><a class="heading-id-link" href="#checking-for-infinity">18.5.2.2 Checking for <code>Infinity</code></a></h5>
<p>These are two common ways of checking if a value <code>x</code> is <code>Infinity</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> x = <span class="hljs-title class_">Infinity</span>;</code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(x === <span class="hljs-title class_">Infinity</span>, <span class="hljs-literal">true</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isFinite</span>(x), <span class="hljs-literal">false</span>);</code>
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Comparing numbers</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/numbers/find_max_test.mjs</code></p>
</div>
<h3 id="the-precision-of-numbers-careful-with-decimal-fractions"><a class="heading-id-link" href="#the-precision-of-numbers-careful-with-decimal-fractions">18.6 The precision of numbers: careful with decimal fractions</a></h3>
<p>Internally, JavaScript floating point numbers are represented with base 2 (according to the IEEE 754 standard). That means that decimal fractions (base 10) can’t always be represented precisely:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span></span></code>
<code>0.30000000000000004</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">1.3</span> * <span class="hljs-number">3</span></span></code>
<code>3.9000000000000004</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">1.4</span> * <span class="hljs-number">100000000000000</span></span></code>
<code>139999999999999.98</code>
</pre>
<p>We therefore need to take rounding errors into consideration when performing arithmetic in JavaScript.</p>
<p>Read on for an explanation of this phenomenon.</p>
<h3 id="advanced-2"><a class="heading-id-link" href="#advanced-2">18.7 (Advanced)</a></h3>
<p>All remaining sections of this chapter are advanced.</p>
<h3 id="floating-point-precision"><a class="heading-id-link" href="#floating-point-precision">18.8 Background: floating point precision</a></h3>
<p>In JavaScript, computations with numbers don’t always produce correct results – for example:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span></span></code>
<code>0.30000000000000004</code>
</pre>
<p>To understand why, we need to explore how JavaScript represents floating point numbers internally. It uses three integers to do so, which take up a total of 64 bits of storage (double precision):</p>
<table class="framed">
  <style>
    th:nth-child(1), td:nth-child(1) {
      text-align: left;
    }
    th:nth-child(2), td:nth-child(2) {
      text-align: left;
    }
    th:nth-child(3), td:nth-child(3) {
      text-align: left;
    }
  </style>
  <thead>
    <tr>
      <th>Component</th><th>Size</th><th>Integer range</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Sign</td><td>1 bit</td><td>[0, 1]</td>
    </tr>
    <tr>
      <td>Fraction</td><td>52 bits</td><td>[0, 2<sup>52</sup>−1]</td>
    </tr>
    <tr>
      <td>Exponent</td><td>11 bits</td><td>[−1023, 1024]</td>
    </tr>
  </tbody>
</table>
<p>The floating point number represented by these integers is computed as follows:</p>
<blockquote>
  <p>(–1)<sup>sign</sup> × 0b1.fraction × 2<sup>exponent</sup></p>
</blockquote>
<p>This representation can’t encode a zero because its second component (involving the fraction) always has a leading 1. Therefore, a zero is encoded via the special exponent −1023 and a fraction 0.</p>
<h4 id="a-simplified-representation-of-floating-point-numbers"><a class="heading-id-link" href="#a-simplified-representation-of-floating-point-numbers">18.8.1 A simplified representation of floating point numbers</a></h4>
<p>To make further discussions easier, we simplify the previous representation:</p>
<ul>
  <li>
    Instead of base 2 (binary), we use base 10 (decimal) because that’s what most people are more familiar with.
  </li>
  <li>
    The <em>fraction</em> is a natural number that is interpreted as a fraction (digits after a point). We switch to a <em>mantissa</em>, an integer that is interpreted as itself. As a consequence, the exponent is used differently, but its fundamental role doesn’t change.
  </li>
  <li>
    As the mantissa is an integer (with its own sign), we don’t need a separate sign, anymore.
  </li>
</ul>
<p>The new representation works like this:</p>
<blockquote>
  <p>mantissa × 10<sup>exponent</sup></p>
</blockquote>
<p>Let’s try out this representation for a few floating point numbers.</p>
<ul>
  <li>
    <p>To encode the integer 123, we use the mantissa 123 and multiply it with 1 (10<sup>0</sup>):</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">123</span> * (<span class="hljs-number">10</span> ** <span class="hljs-number">0</span>)</span></code>
<code>123</code>
</pre>
  </li>
  <li>
    <p>To encode the integer −45, we use the mantissa −45 and, again, the exponent zero:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">-<span class="hljs-number">45</span> * (<span class="hljs-number">10</span> ** <span class="hljs-number">0</span>)</span></code>
<code>-45</code>
</pre>
  </li>
  <li>
    <p>For the number 1.5, we imagine there being a point after the mantissa. We use the negative exponent −1 to move that point one digit to the left:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">15</span> * (<span class="hljs-number">10</span> ** -<span class="hljs-number">1</span>)</span></code>
<code>1.5</code>
</pre>
  </li>
  <li>
    <p>For the number 0.25, we move the point two digits to the left:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">25</span> * (<span class="hljs-number">10</span> ** -<span class="hljs-number">2</span>)</span></code>
<code>0.25</code>
</pre>
  </li>
</ul>
<p>In other words: As soon as we have decimal digits, the exponent becomes negative. We can also write such a number as a fraction:</p>
<ul>
  <li>
    Numerator (above the horizontal fraction bar): the mantissa
  </li>
  <li>
    Denominator (below the horizontal fraction bar): a 10 with a positive exponent ≥ 1.
  </li>
</ul>
<p>For example:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">15</span> * (<span class="hljs-number">10</span> ** -<span class="hljs-number">1</span>) === <span class="hljs-number">15</span> / (<span class="hljs-number">10</span> ** <span class="hljs-number">1</span>)</span></code>
<code>true</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">25</span> * (<span class="hljs-number">10</span> ** -<span class="hljs-number">2</span>) === <span class="hljs-number">25</span> / (<span class="hljs-number">10</span> ** <span class="hljs-number">2</span>)</span></code>
<code>true</code>
</pre>
<p>These fractions help with understanding why there are numbers that our encoding cannot represent:</p>
<ul>
  <li>
    <p><code>1/10</code> can be represented. It already has the required format: a power of 10 in the denominator.</p>
  </li>
  <li>
    <p><code>1/2</code> can be represented as <code>5/10</code>. We turned the 2 in the denominator into a power of 10 by multiplying the numerator and denominator by 5.</p>
  </li>
  <li>
    <p><code>1/4</code> can be represented as <code>25/100</code>. We turned the 4 in the denominator into a power of 10 by multiplying the numerator and denominator by 25.</p>
  </li>
  <li>
    <p><code>1/3</code> cannot be represented. There is no way to turn the denominator into a power of 10. (The prime factors of 10 are 2 and 5. Therefore, any denominator that only has these prime factors can be converted to a power of 10, by multiplying both the numerator and denominator by enough twos and fives. If a denominator has a different prime factor, then there’s nothing we can do.)</p>
  </li>
</ul>
<p>To conclude our excursion, we switch back to base 2:</p>
<ul>
  <li>
    <code>0.5 = 1/2</code> can be represented with base 2 because the denominator is already a power of 2.
  </li>
  <li>
    <code>0.25 = 1/4</code> can be represented with base 2 because the denominator is already a power of 2.
  </li>
  <li>
    <code>0.1 = 1/10</code> cannot be represented because the denominator cannot be converted to a power of 2.
  </li>
  <li>
    <code>0.2 = 2/10</code> cannot be represented because the denominator cannot be converted to a power of 2.
  </li>
</ul>
<p>Now we can see why <code>0.1 + 0.2</code> doesn’t produce a correct result: internally, neither of the two operands can be represented precisely.</p>
<p>The only way to compute precisely with decimal fractions is by internally switching to base 10. For many programming languages, base 2 is the default and base 10 an option. For example:</p>
<ul>
  <li>
    Java has the class <a href="https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html"><code>BigDecimal</code></a>.
  </li>
  <li>
    Python has the module <a href="https://docs.python.org/3/library/decimal.html"><code>decimal</code></a>.
  </li>
</ul>
<p>There are plans to add something similar to JavaScript: <a href="https://github.com/tc39/proposal-decimal">the ECMAScript proposal “Decimal”</a>. Until that happens, we can use libraries such as <a href="https://github.com/MikeMcl/big.js/">big.js</a>.</p>
<h3 id="integer-numbers"><a class="heading-id-link" href="#integer-numbers">18.9 Integer numbers in JavaScript</a></h3>
<p><span id="index-entry-integer-numbers"/></p>
<p>Integer numbers are normal (floating point) numbers without decimal fractions:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">1</span> === <span class="hljs-number">1.0</span></span></code>
<code>true</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(<span class="hljs-number">1.0</span>)</span></code>
<code>true</code>
</pre>
<p>In this section, we’ll look at a few tools for working with these pseudo-integers. JavaScript also supports <a href="ch_bigints.html#ch_bigints"><em>bigints</em></a>, which are real integers.</p>
<h4 id="how-are-integers-different-from-floating-point-numbers-with-fractions"><a class="heading-id-link" href="#how-are-integers-different-from-floating-point-numbers-with-fractions">18.9.1 How are integers different from floating point numbers with fractions?</a></h4>
<p>As we have seen, JavaScript (non-bigint) integers are simply floating point numbers without decimal fractions. But they are different in the following ways:</p>
<ul>
  <li>
    <p>In some locations, only integers are allowed – e.g., the <code>Array</code> constructor only accepts integers as lengths:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1.1</span>)</span></code>
<code>RangeError: Invalid array length</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1.0</span>)</span></code>
<code>[,]</code>
</pre>
  </li>
  <li>
    <p>In some locations, numbers with fractions are coerced to numbers without fractions – e.g., the bitwise Or (<code>|</code>) operation coerces its operands to 32-bit integers:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">3.9</span> | <span class="hljs-number">0</span></span></code>
<code>3</code>
</pre>
  </li>
  <li>
    <p>JavaScript has several constants and operations for working with integers:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">log2</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span>)</span></code>
<code>53</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(<span class="hljs-number">123.0</span>)</span></code>
<code>true</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'123'</span>)</span></code>
<code>123</code>
</pre>
  </li>
  <li>
    <p>Non-decimal integer literals can’t have fractions (the suffix <code>.1</code> is interpreted as reading a property – whose name illegally starts with a digit):</p>
<pre class="language-js">
<code><span class="hljs-number">0b1</span><span class="hljs-number">.1</span> <span class="hljs-comment">// SyntaxError</span></code>
<code><span class="hljs-number">0o7</span><span class="hljs-number">.1</span> <span class="hljs-comment">// SyntaxError</span></code>
<code><span class="hljs-number">0xF</span><span class="hljs-number">.1</span> <span class="hljs-comment">// SyntaxError</span></code>
</pre>
  </li>
  <li>
    <p>Some JavaScript engines internally represent smaller integers differently – as real integers. For example, V8 does this for the following “small integer” ranges (<a href="https://medium.com/fhinkel/v8-internals-how-small-is-a-small-integer-e0badc18b6da">source</a>):</p>
    <ul>
      <li>
        32-bit systems: 30 bits plus sign
      </li>
      <li>
        64-bit systems: 31 bits plus sign
      </li>
    </ul>
  </li>
</ul>
<h4 id="converting-to-integer"><a class="heading-id-link" href="#converting-to-integer">18.9.2 Converting to integer</a></h4>
<p>The recommended way of converting numbers to integers is to use one of the rounding methods of the <code>Math</code> object:</p>
<ul>
  <li>
    <p><code>Math.floor(n)</code>: returns the largest integer <code>i</code> ≤ <code>n</code></p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-number">2.1</span>)</span></code>
<code>2</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-number">2.9</span>)</span></code>
<code>2</code>
</pre>
  </li>
  <li>
    <p><code>Math.ceil(n)</code>: returns the smallest integer <code>i</code> ≥ <code>n</code></p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(<span class="hljs-number">2.1</span>)</span></code>
<code>3</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(<span class="hljs-number">2.9</span>)</span></code>
<code>3</code>
</pre>
  </li>
  <li>
    <p><code>Math.round(n)</code>: returns the integer that is “closest” to <code>n</code> with <code>__.5</code> being rounded up – for example:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-number">2.4</span>)</span></code>
<code>2</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-number">2.5</span>)</span></code>
<code>3</code>
</pre>
  </li>
  <li>
    <p><code>Math.trunc(n)</code>: removes any decimal fraction (after the point) that <code>n</code> has, therefore turning it into an integer.</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">trunc</span>(<span class="hljs-number">2.1</span>)</span></code>
<code>2</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">trunc</span>(<span class="hljs-number">2.9</span>)</span></code>
<code>2</code>
</pre>
  </li>
</ul>
<p>For more information on rounding, see <a href="ch_math.html#math-rounding">“Rounding” (§19.3)</a>.</p>
<h4 id="ranges-of-integer-numbers-in-javascript"><a class="heading-id-link" href="#ranges-of-integer-numbers-in-javascript">18.9.3 Ranges of integer numbers in JavaScript</a></h4>
<p>These are important ranges of integer numbers in JavaScript:</p>
<ul>
  <li>
    <strong>Safe integers:</strong> can be represented “safely” by JavaScript (more on what that means in <span refcheck="#safe-integers">the next subsection</span>)
    <ul>
      <li>
        Precision: 53 bits plus sign
      </li>
      <li>
        Range: (−2<sup>53</sup>, 2<sup>53</sup>)
      </li>
    </ul>
  </li>
  <li>
    <strong>Array indices</strong>
    <ul>
      <li>
        Precision: 32 bits, unsigned
      </li>
      <li>
        Range: [0, 2<sup>32</sup>−1) (excluding the maximum length)
      </li>
      <li>
        Typed Arrays have a larger range of 53 bits (safe and unsigned)
      </li>
    </ul>
  </li>
  <li>
    <strong>Bitwise operators</strong> (bitwise Or, etc.)
    <ul>
      <li>
        Precision: 32 bits
      </li>
      <li>
        Range of unsigned right shift (<code>&gt;&gt;&gt;</code>): unsigned, [0, 2<sup>32</sup>)
      </li>
      <li>
        Range of all other bitwise operators: signed, [−2<sup>31</sup>, 2<sup>31</sup>)
      </li>
    </ul>
  </li>
</ul>
<h4 id="safe-integers"><a class="heading-id-link" href="#safe-integers">18.9.4 Safe integers</a></h4>
<p><span id="index-entry-safe-integer"/><span id="index-entry-integer--safe"/></p>
<p>This is the range of integer numbers that are <em>safe</em> in JavaScript (53 bits plus a sign):</p>
<blockquote>
  <p>[–(2<sup>53</sup>)+1, 2<sup>53</sup>–1]</p>
</blockquote>
<p>An integer is <em>safe</em> if it is represented by exactly one JavaScript number. Given that JavaScript numbers are encoded as a fraction multiplied by 2 to the power of an exponent, higher integers can also be represented, but then there are gaps between them.</p>
<p>For example (18014398509481984 is 2<sup>54</sup>):</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">18014398509481983</span></span></code>
<code>18014398509481984</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">18014398509481984</span></span></code>
<code>18014398509481984</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">18014398509481985</span></span></code>
<code>18014398509481984</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">18014398509481986</span></span></code>
<code>18014398509481984</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">18014398509481987</span></span></code>
<code>18014398509481988</code>
</pre>
<p>The following mathematical integers are therefore not safe:</p>
<ul>
  <li>
    The mathematical integer 18014398509481984 is represented by these JavaScript numbers:
    <ul>
      <li>
        18014398509481983
      </li>
      <li>
        18014398509481984
      </li>
      <li>
        18014398509481985
      </li>
      <li>
        18014398509481986
      </li>
    </ul>
  </li>
  <li>
    The mathematical integer 18014398509481985 is not represented by any JavaScript number.
  </li>
</ul>
<p>The following properties of <code>Number</code> help determine if an integer is safe:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span>, (<span class="hljs-number">2</span> ** <span class="hljs-number">53</span>) - <span class="hljs-number">1</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_SAFE_INTEGER</span>, -<span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span>);</code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isSafeInteger</span>(<span class="hljs-number">5</span>), <span class="hljs-literal">true</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isSafeInteger</span>(<span class="hljs-string">'5'</span>), <span class="hljs-literal">false</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isSafeInteger</span>(<span class="hljs-number">5.1</span>), <span class="hljs-literal">false</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isSafeInteger</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span>), <span class="hljs-literal">true</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isSafeInteger</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span>+<span class="hljs-number">1</span>), <span class="hljs-literal">false</span>);</code>
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Detecting safe integers</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/numbers/is_safe_integer_test.mjs</code></p>
</div>
<h5 id="safe-computations"><a class="heading-id-link" href="#safe-computations">18.9.4.1 Safe computations</a></h5>
<p>Let’s look at computations involving unsafe integers.</p>
<p>The following result is incorrect and unsafe, even though both of its operands are safe:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">9007199254740990</span> + <span class="hljs-number">3</span></span></code>
<code>9007199254740992</code>
</pre>
<p>The following result is safe, but incorrect. The first operand is unsafe; the second operand is safe:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">9007199254740995</span> - <span class="hljs-number">10</span></span></code>
<code>9007199254740986</code>
</pre>
<p>Therefore, the result of an expression <code>a op b</code> is correct if and only if:</p>
<pre class="language-js">
<code><span class="hljs-title function_">isSafeInteger</span>(a) &amp;&amp; <span class="hljs-title function_">isSafeInteger</span>(b) &amp;&amp; <span class="hljs-title function_">isSafeInteger</span>(a op b)</code>
</pre>
<p>That is, both operands and the result must be safe.</p>
<h3 id="bitwise-operators-advanced"><a class="heading-id-link" href="#bitwise-operators-advanced">18.10 Bitwise operators<span> (advanced)</span></a></h3>
<h4 id="bitwise-operators-32-bit-operands"><a class="heading-id-link" href="#bitwise-operators-32-bit-operands">18.10.1 Internally, bitwise operators work with 32-bit integers</a></h4>
<p>Internally, JavaScript’s bitwise operators work with 32-bit integers. They produce their results in the following steps:</p>
<ul>
  <li>
    Input (JavaScript numbers): The 1–2 operands are first converted to JavaScript numbers (64-bit floating point numbers) and then to 32-bit integers.
  </li>
  <li>
    Computation (32-bit integers): The actual operation processes 32-bit integers and produces a 32-bit integer.
  </li>
  <li>
    Output (JavaScript number): Before returning the result, it is converted back to a JavaScript number.
  </li>
</ul>
<h5 id="the-types-of-operands-and-results"><a class="heading-id-link" href="#the-types-of-operands-and-results">18.10.1.1 The types of operands and results</a></h5>
<p>For each bitwise operator, this book mentions the types of its operands and its result. Each type is always one of the following two:</p>
<table class="framed">
  <style>
    th:nth-child(1), td:nth-child(1) {
      text-align: left;
    }
    th:nth-child(2), td:nth-child(2) {
      text-align: left;
    }
    th:nth-child(3), td:nth-child(3) {
      text-align: left;
    }
    th:nth-child(4), td:nth-child(4) {
      text-align: left;
    }
  </style>
  <thead>
    <tr>
      <th>Type</th><th>Description</th><th>Size</th><th>Range</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Int32</td><td>signed 32-bit integer</td><td>32 bits incl. sign</td><td>[−2<sup>31</sup>, 2<sup>31</sup>)</td>
    </tr>
    <tr>
      <td>Uint32</td><td>unsigned 32-bit integer</td><td>32 bits</td><td>[0, 2<sup>32</sup>)</td>
    </tr>
  </tbody>
</table>
<p>Considering the previously mentioned steps, I recommend to pretend that bitwise operators internally work with unsigned 32-bit integers (step “computation”) and that Int32 and Uint32 only affect how JavaScript numbers are converted to and from integers (steps “input” and “output”).</p>
<h5 id="displaying-javascript-numbers-as-unsigned-32bit-integers"><a class="heading-id-link" href="#displaying-javascript-numbers-as-unsigned-32bit-integers">18.10.1.2 Displaying JavaScript numbers as unsigned 32-bit integers</a></h5>
<p>While exploring the bitwise operators, it occasionally helps to display JavaScript numbers as unsigned 32-bit integers in binary notation. That’s what <code>b32()</code> does (whose implementation is shown later):</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">b32</span>(-<span class="hljs-number">1</span>),</code>
<code>  <span class="hljs-string">'11111111111111111111111111111111'</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">b32</span>(<span class="hljs-number">1</span>),</code>
<code>  <span class="hljs-string">'00000000000000000000000000000001'</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">b32</span>(<span class="hljs-number">2</span> ** <span class="hljs-number">31</span>),</code>
<code>  <span class="hljs-string">'10000000000000000000000000000000'</span>);</code>
</pre>
<h4 id="bitwise-not"><a class="heading-id-link" href="#bitwise-not">18.10.2 Bitwise Not</a></h4>
<p><span id="index-entry-bitwise-Not"/><span id="index-entry--x3"/>
<span id="index-entry-ones--complement"/></p>
<figure id="tbl:bitwise-not" class="float">
  <table class="framed">
    <style>
      th:nth-child(1), td:nth-child(1) {
        text-align: left;
      }
      th:nth-child(2), td:nth-child(2) {
        text-align: left;
      }
      th:nth-child(3), td:nth-child(3) {
        text-align: left;
      }
      th:nth-child(4), td:nth-child(4) {
        text-align: left;
      }
    </style>
    <thead>
      <tr>
        <th>Operation</th><th>Name</th><th>Type signature</th><th/>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>~num</code></td><td>Bitwise Not, <em>ones’ complement</em></td><td>Int32 → Int32</td><td>ES1</td>
      </tr>
    </tbody>
  </table>
  <figcaption>
    <p><span class="float-label">Table 18.5:</span> The bitwise Not operator.</p>
  </figcaption>
</figure>
<p>The bitwise Not operator (<a href="#tbl:bitwise-not">table 18.5</a>) inverts each binary digit of its operand:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">b32</span>(~<span class="hljs-number">0b100</span>)</span></code>
<code>'11111111111111111111111111111011'</code>
</pre>
<p>This so-called <em>ones’ complement</em> is similar to a negative for some arithmetic operations. For example, adding an integer to its ones’ complement is always <code>-1</code>:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">4</span> + ~<span class="hljs-number">4</span></span></code>
<code>-1</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">-<span class="hljs-number">11</span> + ~-<span class="hljs-number">11</span></span></code>
<code>-1</code>
</pre>
<h4 id="binary-bitwise-operators"><a class="heading-id-link" href="#binary-bitwise-operators">18.10.3 Binary bitwise operators</a></h4>
<p><span id="index-entry-bitwise-And"/><span id="index-entry-.x-y5"/>
<span id="index-entry-bitwise-Or"/><span id="index-entry-.x-y6"/>
<span id="index-entry-bitwise-Xor"/><span id="index-entry-.x-y7"/></p>
<figure id="tbl:binary-bitwise-operators" class="float">
  <table class="framed">
    <style>
      th:nth-child(1), td:nth-child(1) {
        text-align: left;
      }
      th:nth-child(2), td:nth-child(2) {
        text-align: left;
      }
      th:nth-child(3), td:nth-child(3) {
        text-align: left;
      }
      th:nth-child(4), td:nth-child(4) {
        text-align: left;
      }
    </style>
    <thead>
      <tr>
        <th>Operation</th><th>Name</th><th>Type signature</th><th/>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>num1 &amp; num2</code></td><td>Bitwise And</td><td>Int32 × Int32 → Int32</td><td>ES1</td>
      </tr>
      <tr>
        <td><code>num1 ¦ num2</code></td><td>Bitwise Or</td><td>Int32 × Int32 → Int32</td><td>ES1</td>
      </tr>
      <tr>
        <td><code>num1 ^ num2</code></td><td>Bitwise Xor</td><td>Int32 × Int32 → Int32</td><td>ES1</td>
      </tr>
    </tbody>
  </table>
  <figcaption>
    <p><span class="float-label">Table 18.6:</span> Binary bitwise operators.</p>
  </figcaption>
</figure>
<p>The binary bitwise operators (<a href="#tbl:binary-bitwise-operators">table 18.6</a>) combine the bits of their operands to produce their results:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">(<span class="hljs-number">0b1010</span> &amp; <span class="hljs-number">0b0011</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">4</span>, <span class="hljs-string">'0'</span>)</span></code>
<code>'0010'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">(<span class="hljs-number">0b1010</span> | <span class="hljs-number">0b0011</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">4</span>, <span class="hljs-string">'0'</span>)</span></code>
<code>'1011'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">(<span class="hljs-number">0b1010</span> ^ <span class="hljs-number">0b0011</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">4</span>, <span class="hljs-string">'0'</span>)</span></code>
<code>'1001'</code>
</pre>
<h4 id="bitwise-shift-operators"><a class="heading-id-link" href="#bitwise-shift-operators">18.10.4 Bitwise shift operators</a></h4>
<p><span id="index-entry-left-shift-operator"/><span id="index-entry-.x--y4"/>
<span id="index-entry-signed-right-shift-operator"/><span id="index-entry-.x--y5"/>
<span id="index-entry-unsigned-right-shift-operator"/><span id="index-entry-.x---y3"/></p>
<figure id="tbl:bitwise-shift-operators-short" class="float">
  <table class="framed">
    <style>
      th:nth-child(1), td:nth-child(1) {
        text-align: left;
      }
      th:nth-child(2), td:nth-child(2) {
        text-align: left;
      }
      th:nth-child(3), td:nth-child(3) {
        text-align: left;
      }
      th:nth-child(4), td:nth-child(4) {
        text-align: left;
      }
    </style>
    <thead>
      <tr>
        <th>Operation</th><th>Name</th><th>Type signature</th><th/>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>num &lt;&lt; count</code></td><td>Left shift</td><td>Int32 × Uint32 → Int32</td><td>ES1</td>
      </tr>
      <tr>
        <td><code>num &gt;&gt; count</code></td><td>Signed right shift</td><td>Int32 × Uint32 → Int32</td><td>ES1</td>
      </tr>
      <tr>
        <td><code>num &gt;&gt;&gt; count</code></td><td>Unsigned right shift</td><td>Uint32 × Uint32 → Uint32</td><td>ES1</td>
      </tr>
    </tbody>
  </table>
  <figcaption>
    <p><span class="float-label">Table 18.7:</span> Bitwise shift operators.</p>
  </figcaption>
</figure>
<p>The shift operators (<a href="#tbl:bitwise-shift-operators-short">table 18.7</a>) move binary digits to the left or to the right:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">(<span class="hljs-number">0b10</span> &lt;&lt; <span class="hljs-number">1</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>)</span></code>
<code>'100'</code>
</pre>
<p><code>&gt;&gt;</code> preserves highest bit, <code>&gt;&gt;&gt;</code> doesn’t:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">b32</span>(<span class="hljs-number">0b10000000000000000000000000000010</span> &gt;&gt; <span class="hljs-number">1</span>)</span></code>
<code>'11000000000000000000000000000001'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">b32</span>(<span class="hljs-number">0b10000000000000000000000000000010</span> &gt;&gt;&gt; <span class="hljs-number">1</span>)</span></code>
<code>'01000000000000000000000000000001'</code>
</pre>
<h4 id="b32"><a class="heading-id-link" href="#b32">18.10.5 <code>b32()</code>: displaying unsigned 32-bit integers in binary notation</a></h4>
<p>We have now used <code>b32()</code> a few times. The following code is an implementation of it:</p>
<pre class="language-js">
<code><span class="hljs-comment">/**</span></code>
<code><span class="hljs-comment"> * Return a string representing n as a 32-bit unsigned integer,</span></code>
<code><span class="hljs-comment"> * in binary notation.</span></code>
<code><span class="hljs-comment"> */</span></code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">b32</span>(<span class="hljs-params">n</span>) {</code>
<code>  <span class="hljs-comment">// &gt;&gt;&gt; ensures highest bit isn’t interpreted as a sign</span></code>
<code>  <span class="hljs-keyword">return</span> (n &gt;&gt;&gt; <span class="hljs-number">0</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">32</span>, <span class="hljs-string">'0'</span>);</code>
<code>}</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">b32</span>(<span class="hljs-number">6</span>),</code>
<code>  <span class="hljs-string">'00000000000000000000000000000110'</span>);</code>
</pre>
<p><code>n &gt;&gt;&gt; 0</code> means that we are shifting <code>n</code> zero bits to the right. Therefore, in principle, the <code>&gt;&gt;&gt;</code> operator does nothing, but it still coerces <code>n</code> to an unsigned 32-bit integer:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">12</span> &gt;&gt;&gt; <span class="hljs-number">0</span></span></code>
<code>12</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">-<span class="hljs-number">12</span> &gt;&gt;&gt; <span class="hljs-number">0</span></span></code>
<code>4294967284</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">(<span class="hljs-number">2</span>**<span class="hljs-number">32</span> + <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">0</span></span></code>
<code>1</code>
</pre>
<h3 id="quick-reference-numbers"><a class="heading-id-link" href="#quick-reference-numbers">18.11 Quick reference: numbers</a></h3>
<h4 id="global-functions-for-numbers"><a class="heading-id-link" href="#global-functions-for-numbers">18.11.1 Global functions for numbers</a></h4>
<p>JavaScript has the following four global functions for numbers:</p>
<ul>
  <li>
    <code>isFinite()</code>
  </li>
  <li>
    <code>isNaN()</code>
  </li>
  <li>
    <code>parseFloat()</code>
  </li>
  <li>
    <code>parseInt()</code>
  </li>
</ul>
<p>However, it is better to use the corresponding methods of <code>Number</code> (<code>Number.isFinite()</code>, etc.), which have fewer pitfalls. They were introduced with ES6 and are discussed below.</p>
<h4 id="number-data-properties"><a class="heading-id-link" href="#number-data-properties">18.11.2 <code>Number.*</code>: data properties</a></h4>
<ul>
  <li>
    <p><code id="qref-Number.EPSILON">Number.EPSILON</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>The difference between 1 and the next representable floating point number. In general, <a href="https://en.wikipedia.org/wiki/Machine_epsilon">a machine epsilon</a> provides an upper bound for rounding errors in floating point arithmetic.</p>
    <ul>
      <li>
        Approximately: 2.2204460492503130808472633361816 × 10<sup>-16</sup>
      </li>
    </ul>
  </li>
  <li>
    <p><code id="qref-Number.MAX_VALUE">Number.MAX_VALUE</code> <span class="ibox ibox-small" size="small">ES1</span></p>
    <p>The largest positive finite JavaScript number.</p>
    <ul>
      <li>
        Approximately: 1.7976931348623157 × 10<sup>308</sup>
      </li>
    </ul>
  </li>
  <li>
    <p><code id="qref-Number.MIN_VALUE">Number.MIN_VALUE</code> <span class="ibox ibox-small" size="small">ES1</span></p>
    <p>The smallest positive JavaScript number. Approximately 5 × 10<sup>−324</sup>.</p>
  </li>
  <li>
    <p><code id="qref-Number.NaN">Number.NaN</code> <span class="ibox ibox-small" size="small">ES1</span></p>
    <p>The same as the global variable <code>NaN</code>.</p>
  </li>
  <li>
    <p><code id="qref-Number.NEGATIVE_INFINITY">Number.NEGATIVE_INFINITY</code> <span class="ibox ibox-small" size="small">ES1</span></p>
    <p>The same as <code>-Number.POSITIVE_INFINITY</code>.</p>
  </li>
  <li>
    <p><code id="qref-Number.POSITIVE_INFINITY">Number.POSITIVE_INFINITY</code> <span class="ibox ibox-small" size="small">ES1</span></p>
    <p>The same as the global variable <code>Infinity</code>.</p>
  </li>
</ul>
<h4 id="number-methods"><a class="heading-id-link" href="#number-methods">18.11.3 <code>Number.*</code>: methods</a></h4>
<ul>
  <li>
    <p><code id="qref-Number.isFinite">Number.isFinite(num)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>Returns <code>true</code> if <code>num</code> is an actual number (neither <code>Infinity</code> nor <code>-Infinity</code> nor <code>NaN</code>).</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isFinite</span>(<span class="hljs-title class_">Infinity</span>)</span></code>
<code>false</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isFinite</span>(-<span class="hljs-title class_">Infinity</span>)</span></code>
<code>false</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isFinite</span>(<span class="hljs-title class_">NaN</span>)</span></code>
<code>false</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isFinite</span>(<span class="hljs-number">123</span>)</span></code>
<code>true</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Number.isNaN">Number.isNaN(num)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>Returns <code>true</code> if <code>num</code> is the value <code>NaN</code>:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>)</span></code>
<code>true</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-number">123</span>)</span></code>
<code>false</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">'abc'</span>)</span></code>
<code>false</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Number.parseFloat">Number.parseFloat(str)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>Coerces its parameter to string and parses it as a floating point number. It ignores leading whitespace and illegal trailing characters:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">'\t 123.4#'</span>)</span></code>
<code>123.4</code>
</pre>
    <p>That can hide problems. Thus, for converting strings to numbers, <code>Number()</code> is usually a better choice because it only ignores leading and trailing whitespace:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>(<span class="hljs-string">'\t 123.4#'</span>)</span></code>
<code>NaN</code>
</pre>
  </li>
</ul>
<h4 id="numberprototype"><a class="heading-id-link" href="#numberprototype">18.11.4 <code>Number.prototype.*</code></a></h4>
<p>(<code>Number.prototype</code> is where the methods of numbers are stored.)</p>
<ul>
  <li>
    <p><code id="qref-Number.prototype.toExponential">Number.prototype.toExponential(fractionDigits?)</code> <span class="ibox ibox-small" size="small">ES3</span></p>
    <ul>
      <li>
        Returns a string that represents the number via exponential notation.
      </li>
      <li>
        With <code>fractionDigits</code>, we can specify, how many digits should be shown of the number that is multiplied with the exponent.
        <ul>
          <li>
            The default is to show as many digits as necessary.
          </li>
        </ul>
      </li>
    </ul>
    <p>Example: number too small to get a positive exponent via <code>.toString()</code>.</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">1234.</span>.<span class="hljs-title function_">toString</span>()</span></code>
<code>'1234'</code>
<code/>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">1234.</span>.<span class="hljs-title function_">toExponential</span>() <span class="hljs-comment">// 3 fraction digits</span></span></code>
<code>'1.234e+3'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">1234.</span>.<span class="hljs-title function_">toExponential</span>(<span class="hljs-number">5</span>)</span></code>
<code>'1.23400e+3'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">1234.</span>.<span class="hljs-title function_">toExponential</span>(<span class="hljs-number">1</span>)</span></code>
<code>'1.2e+3'</code>
</pre>
    <p>Example: fraction not small enough to get a negative exponent via <code>.toString()</code>.</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">0.003</span>.<span class="hljs-title function_">toString</span>()</span></code>
<code>'0.003'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">0.003</span>.<span class="hljs-title function_">toExponential</span>()</span></code>
<code>'3e-3'</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Number.prototype.toFixed">Number.prototype.toFixed(fractionDigits=0)</code> <span class="ibox ibox-small" size="small">ES3</span></p>
    <p>Returns an exponent-free string representation of the number, rounded to <code>fractionDigits</code> digits.</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">0.00000012</span>.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// with exponent</span></span></code>
<code>'1.2e-7'</code>
<code/>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">0.00000012</span>.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">10</span>) <span class="hljs-comment">// no exponent</span></span></code>
<code>'0.0000001200'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">0.00000012</span>.<span class="hljs-title function_">toFixed</span>()</span></code>
<code>'0'</code>
</pre>
    <p>If the number is 10<sup>21</sup> or greater, even <code>.toFixed()</code> uses an exponent:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">(<span class="hljs-number">10</span> ** <span class="hljs-number">21</span>).<span class="hljs-title function_">toFixed</span>()</span></code>
<code>'1e+21'</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Number.prototype.toPrecision">Number.prototype.toPrecision(precision?)</code> <span class="ibox ibox-small" size="small">ES3</span></p>
    <ul>
      <li>
        Works like <code>.toString()</code>, but <code>precision</code> specifies how many digits should be shown overall.
      </li>
      <li>
        If <code>precision</code> is missing, <code>.toString()</code> is used.
      </li>
    </ul>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">1234.</span>.<span class="hljs-title function_">toPrecision</span>(<span class="hljs-number">3</span>)  <span class="hljs-comment">// requires exponential notation</span></span></code>
<code>'1.23e+3'</code>
<code/>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">1234.</span>.<span class="hljs-title function_">toPrecision</span>(<span class="hljs-number">4</span>)</span></code>
<code>'1234'</code>
<code/>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">1234.</span>.<span class="hljs-title function_">toPrecision</span>(<span class="hljs-number">5</span>)</span></code>
<code>'1234.0'</code>
<code/>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">1.234</span>.<span class="hljs-title function_">toPrecision</span>(<span class="hljs-number">3</span>)</span></code>
<code>'1.23'</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Number.prototype.toString">Number.prototype.toString(radix=10)</code> <span class="ibox ibox-small" size="small">ES1</span></p>
    <p>Returns a string representation of the number.</p>
    <p>By default, we get a base 10 numeral as a result:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">123.456</span>.<span class="hljs-title function_">toString</span>()</span></code>
<code>'123.456'</code>
</pre>
    <p>If we want the numeral to have a different base, we can specify it via <code>radix</code>:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">4.</span>.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// binary (base 2)</span></span></code>
<code>'100'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">4.5</span>.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>)</span></code>
<code>'100.1'</code>
<code/>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">255.</span>.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>) <span class="hljs-comment">// hexadecimal (base 16)</span></span></code>
<code>'ff'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">255.66796875</span>.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>)</span></code>
<code>'ff.ab'</code>
<code/>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">1234567890.</span>.<span class="hljs-title function_">toString</span>(<span class="hljs-number">36</span>)</span></code>
<code>'kf12oi'</code>
</pre>
    <p><code>Number.parseInt()</code> provides the inverse operation: it converts a string that contains an integer (no fraction!) numeral with a given base, to a number.</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'kf12oi'</span>, <span class="hljs-number">36</span>)</span></code>
<code>1234567890</code>
</pre>
  </li>
</ul>
<h4 id="number-data-properties-and-methods-for-integers"><a class="heading-id-link" href="#number-data-properties-and-methods-for-integers">18.11.5 <code>Number.*</code>: data properties and methods for integers</a></h4>
<ul>
  <li>
    <p><code id="qref-Number.MIN_SAFE_INTEGER">Number.MIN_SAFE_INTEGER</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>The smallest integer that JavaScript can represent unambiguously (−2<sup>53</sup>+1).</p>
  </li>
  <li>
    <p><code id="qref-Number.MAX_SAFE_INTEGER">Number.MAX_SAFE_INTEGER</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>The largest integer that JavaScript can represent unambiguously (2<sup>53</sup>−1).</p>
  </li>
  <li>
    <p><code id="qref-Number.isInteger">Number.isInteger(num)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>Returns <code>true</code> if <code>num</code> is a number and does not have a decimal fraction.</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(-<span class="hljs-number">17</span>)</span></code>
<code>true</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(<span class="hljs-number">33</span>)</span></code>
<code>true</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(<span class="hljs-number">33.1</span>)</span></code>
<code>false</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(<span class="hljs-string">'33'</span>)</span></code>
<code>false</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(<span class="hljs-title class_">NaN</span>)</span></code>
<code>false</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(<span class="hljs-title class_">Infinity</span>)</span></code>
<code>false</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Number.isSafeInteger">Number.isSafeInteger(num)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>Returns <code>true</code> if <code>num</code> is a number and unambiguously represents an integer.</p>
  </li>
  <li>
    <p><code id="qref-Number.parseInt">Number.parseInt(str, radix=10)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>Coerces its parameter to string and parses it as an integer, ignoring leading whitespace and illegal trailing characters:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'  123#'</span>)</span></code>
<code>123</code>
</pre>
    <p>The parameter <code>radix</code> specifies the base of the number to be parsed:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'101'</span>, <span class="hljs-number">2</span>)</span></code>
<code>5</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'FF'</span>, <span class="hljs-number">16</span>)</span></code>
<code>255</code>
</pre>
    <p>Do not use this method to convert numbers to integers: coercing to string is inefficient. And stopping before the first non-digit is not a good algorithm for removing the fraction of a number. Here is an example where it goes wrong:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">1e21</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// wrong</span></span></code>
<code>1</code>
</pre>
    <p>It is better to use one of the rounding functions of <code>Math</code> to convert a number to an integer:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">trunc</span>(<span class="hljs-number">1e21</span>) <span class="hljs-comment">// correct</span></span></code>
<code>1e+21</code>
</pre>
  </li>
</ul>
<h4 id="sources"><a class="heading-id-link" href="#sources">18.11.6 Sources</a></h4>
<ul>
  <li>
    Wikipedia
  </li>
  <li>
    <a href="https://github.com/microsoft/TypeScript/tree/main/src/lib/">TypeScript’s built-in typings</a>
  </li>
  <li>
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">MDN web docs for JavaScript</a>
  </li>
  <li>
    <a href="https://tc39.es/ecma262/">ECMAScript language specification</a>
  </li>
</ul>

    
      
</body>
</html>