["```js\nconst myObject = { // object literal\n  myProperty: 1,\n  myMethod() {\n return 2;\n }, // comma!\n get myAccessor() {\n return this.myProperty;\n }, // comma!\n set myAccessor(value) {\n this.myProperty = value;\n }, // last comma is optional\n};\n\nassert.equal(\n myObject.myProperty, 1\n);\nassert.equal(\n myObject.myMethod(), 2\n);\nassert.equal(\n myObject.myAccessor, 1\n);\nmyObject.myAccessor = 3;\nassert.equal(\n myObject.myProperty, 3\n);\n\n```", "```js\nconst original = {\n  a: 1,\n  b: {\n    c: 3,\n  },\n};\n\n// Spreading (...) copies one object “into” another one:\nconst modifiedCopy = {\n  ...original, // spreading\n  d: 4,\n};\n\nassert.deepEqual(\n  modifiedCopy,\n  {\n    a: 1,\n    b: {\n      c: 3,\n    },\n    d: 4,\n  }\n);\n\n// Caveat: spreading copies shallowly (property values are shared)\nmodifiedCopy.a = 5; // does not affect `original`\nmodifiedCopy.b.c = 6; // affects `original`\nassert.deepEqual(\n  original,\n  {\n    a: 1, // unchanged\n    b: {\n      c: 6, // changed\n    },\n  },\n);\n\n```", "```js\nconst exactCopy = {...obj};\n\n```", "```js\n// `obj1` has no prototype (its prototype is `null`)\nconst obj1 = Object.create(null); // (A)\nassert.equal(\n  Object.getPrototypeOf(obj1), null // (B)\n);\n\n// `obj2` has the prototype `proto`\nconst proto = {\n  protoProp: 'protoProp',\n};\nconst obj2 = {\n  __proto__: proto, // (C)\n  objProp: 'objProp',\n}\nassert.equal(\n  Object.getPrototypeOf(obj2), proto\n);\n\n```", "```js\n// `obj2` inherits .protoProp from `proto`\nassert.equal(\n  obj2.protoProp, 'protoProp'\n);\nassert.deepEqual(\n  Reflect.ownKeys(obj2),\n  ['objProp'] // own properties of `obj2`\n);\n\n```", "```js\n    const fixedLayoutObject = {\n      product: 'carrot',\n      quantity: 4,\n    };\n\n    ```", "```js\n    const dictionaryObject = {\n      ['one']: 1,\n      ['two']: 2,\n    };\n\n    ```", "```js\nconst jane = {\n  first: 'Jane',\n  last: 'Doe', // optional trailing comma\n};\n\n```", "```js\nconst obj = {\n  if: true,\n  const: true,\n};\n\n```", "```js\n> Object.keys({a:1, b:2})\n[ 'a', 'b' ]\n\n```", "```js\nfunction createPoint(x, y) {\n  return {x, y}; // Same as: {x: x, y: y}\n}\nassert.deepEqual(\n  createPoint(9, 2),\n  { x: 9, y: 2 }\n);\n\n```", "```js\nconst jane = {\n  first: 'Jane',\n  last: 'Doe',\n};\n\n// Get property .first\nassert.equal(jane.first, 'Jane'); // (A)\n\n```", "```js\nassert.equal(jane.unknownProperty, undefined);\n\n```", "```js\nconst obj = {\n  prop: 1,\n};\nassert.equal(obj.prop, 1);\nobj.prop = 2; // (A)\nassert.equal(obj.prop, 2);\n\n```", "```js\nconst obj = {}; // empty object\nassert.deepEqual(\n  Object.keys(obj), []);\n\nobj.unknownProperty = 'abc';\nassert.deepEqual(\n  Object.keys(obj), ['unknownProperty']);\n\n```", "```js\nconst jane = {\n  first: 'Jane', // value property\n  says(text) {   // method\n    return `${this.first} says “${text}”`; // (A)\n  }, // comma as separator (optional at end)\n};\nassert.equal(jane.says('hello'), 'Jane says “hello”');\n\n```", "```js\nconst jane = {\n  first: 'Jane',\n  last: 'Doe',\n  get full() {\n    return `${this.first} ${this.last}`;\n  },\n};\n\nassert.equal(jane.full, 'Jane Doe');\njane.first = 'John';\nassert.equal(jane.full, 'John Doe');\n\n```", "```js\nconst jane = {\n  first: 'Jane',\n  last: 'Doe',\n  set full(fullName) {\n    const parts = fullName.split(' ');\n    this.first = parts[0];\n    this.last = parts[1];\n  },\n};\n\njane.full = 'Richard Roe';\nassert.equal(jane.first, 'Richard');\nassert.equal(jane.last, 'Roe');\n\n```", "```js\nfunction createCounter() {\n // Private data via closure\n let value = 0;\n return {\n get value() {\n return value;\n },\n inc() {\n value++;\n },\n };\n}\n\nconst counter = createCounter();\nassert.equal(counter.value, 0);\n\ncounter.inc();\nassert.equal(counter.value, 1);\n\nassert.throws(\n () => counter.value = 5,\n /^TypeError: Cannot set property value of #<Object> which has only a getter$/\n); \n```", "```js\nconst obj1 = {a: 1, b: 2};\nconst obj2 = {c: 3};\nassert.deepEqual(\n  {...obj1, ...obj2, d: 4},\n  {a: 1, b: 2, c: 3, d: 4}\n);\n\n```", "```js\n> const obj = {one: 1, two: 2, three: 3};\n> {...obj, one: true}\n{ one: true, two: 2, three: 3 }\n> {one: true, ...obj}\n{ one: 1, two: 2, three: 3 }\n\n```", "```js\n> {...undefined}\n{}\n> {...null}\n{}\n> {...123}\n{}\n> {...'abc'}\n{ '0': 'a', '1': 'b', '2': 'c' }\n> {...['a', 'b']}\n{ '0': 'a', '1': 'b' }\n\n```", "```js\nconst symbolKey = Symbol('symbolKey');\nconst obj = {\n  stringKey: 1,\n  [symbolKey]: 2,\n};\nassert.deepEqual(\n  {...obj, anotherStringKey: 3},\n  {\n    stringKey: 1,\n    [symbolKey]: 2,\n    anotherStringKey: 3,\n  }\n);\n\n```", "```js\nconst DEFAULTS = {alpha: 'a', beta: 'b'};\nconst providedData = {alpha: 1};\n\nconst allData = {...DEFAULTS, ...providedData};\nassert.deepEqual(allData, {alpha: 1, beta: 'b'});\n\n```", "```js\nconst providedData = {alpha: 1};\n\nconst allData = {alpha: 'a', beta: 'b', ...providedData};\nassert.deepEqual(allData, {alpha: 1, beta: 'b'});\n\n```", "```js\nconst obj = {alpha: 'a', beta: 'b'};\nobj.alpha = 1; // (A)\nassert.deepEqual(obj, {alpha: 1, beta: 'b'});\n\n```", "```js\nconst obj = {alpha: 'a', beta: 'b'};\nconst updatedObj = {...obj, alpha: 1};\nassert.deepEqual(updatedObj, {alpha: 1, beta: 'b'});\n\n```", "```js\nObject.assign(target, source_1, source_2, ···)\n\n```", "```js\nconst target = { a: 1 };\n\nconst result = Object.assign(\n  target,\n  {b: 2},\n  {c: 3, b: true}\n);\n\nassert.deepEqual(\n  result, { a: 1, b: true, c: 3 }\n);\n// target was modified and returned:\nassert.equal(result, target);\n\n```", "```js\nconst obj = {id: 'e1fd960b', values: ['a', 'b']};\nconst shallowCopy = {...obj};\n\n```", "```js\nshallowCopy.id = 'yes';\nassert.equal(obj.id, 'e1fd960b');\n\n```", "```js\nshallowCopy.values.push('x');\nassert.deepEqual(\n  shallowCopy, {id: 'yes', values: ['a', 'b', 'x']}\n);\nassert.deepEqual(\n  obj, {id: 'e1fd960b', values: ['a', 'b', 'x']}\n);\n\n```", "```js\nconst obj = {id: 'e1fd960b', values: ['a', 'b']};\n// Copy the properties of `obj` into a new object\nconst shallowCopy = Object.assign({}, obj);\n\n```", "```js\nstructuredClone(value: any): any\n\n```", "```js\nconst obj = {id: 'e1fd960b', values: ['a', 'b']};\nconst deepCopy = structuredClone(obj);\n\ndeepCopy.values.push('x');\nassert.deepEqual(\n  deepCopy, {id: 'e1fd960b', values: ['a', 'b', 'x']}\n);\nassert.deepEqual(\n  obj, {id: 'e1fd960b', values: ['a', 'b']}\n);\n\n```", "```js\n> typeof structuredClone(true)\n'boolean'\n> typeof structuredClone(123)\n'number'\n> typeof structuredClone(123n)\n'bigint'\n> typeof structuredClone('abc')\n'string'\n\n```", "```js\n> structuredClone({prop: true})\n{ prop: true }\n> structuredClone(['a', 'b', 'c'])\n[ 'a', 'b', 'c' ]\n\n```", "```js\n> structuredClone(/^a+$/) instanceof RegExp\ntrue\n> structuredClone(new Date()) instanceof Date\ntrue\n\n```", "```js\n> structuredClone(Symbol())\nDOMException [DataCloneError]: Symbol() could not be cloned.\n> structuredClone({[Symbol()]: true}) // property is ignored\n{}\n> structuredClone({prop: Symbol()})\nDOMException [DataCloneError]: Symbol() could not be cloned.\n\n```", "```js\n> structuredClone(function () {}) // ordinary function\nDOMException [DataCloneError]: function () {} could not be cloned.\n> structuredClone(() => {}) // arrow function\nDOMException [DataCloneError]: () => {} could not be cloned.\n> structuredClone(class {})\nDOMException [DataCloneError]: class {} could not be cloned.\n\n> structuredClone({ m(){} }.m) // method\nDOMException [DataCloneError]: m(){} could not be cloned.\n> structuredClone({ m(){} }) // object with method\nDOMException [DataCloneError]: m(){} could not be cloned. \n```", "```js\ntry {\n  structuredClone(() => {});\n} catch (err) {\n  assert.equal(\n    err instanceof DOMException, true\n  );\n  assert.equal(\n    err.name, 'DataCloneError'\n  );\n  assert.equal(\n    err.code, DOMException.DATA_CLONE_ERR\n  );\n}\n\n```", "```js\nclass C {}\nconst copy = structuredClone(new C());\n\nassert.equal(copy instanceof C, false);\nassert.equal(\n  Object.getPrototypeOf(copy),\n  Object.prototype\n);\n\n```", "```js\nclass C {\n  static hasPrivateField(value) {\n    return #privateField in value;\n  }\n  #privateField = true;\n}\n\nconst original = new C();\nassert.equal(\n  C.hasPrivateField(original), true\n);\nconst copy = structuredClone(original);\nassert.equal(\n  C.hasPrivateField(copy), false\n);\n\n```", "```js\nconst cycle = {};\ncycle.prop = cycle;\n\nconst copy = structuredClone(cycle);\nassert.equal(\n  copy.prop, copy\n);\n\n```", "```js\nconst obj = Object.defineProperties(\n  {},\n  {\n    accessor: {\n      get: function () {\n return 123;\n },\n set: undefined,\n enumerable: true,\n configurable: true,\n },\n }\n);\nconst copy = structuredClone(obj);\nassert.deepEqual(\n Object.getOwnPropertyDescriptors(copy),\n {\n accessor: {\n value: 123,\n writable: true,\n enumerable: true,\n configurable: true,\n },\n }\n);\n\n```", "```js\nwritable: true,\nenumerable: true,\nconfigurable: true,\n\n```", "```js\nconst obj = Object.defineProperties(\n  {},\n  {\n    readOnlyProp: {\n      value: 'abc',\n      writable: false,\n      enumerable: true,\n      configurable: false,\n    },\n  }\n);\nconst copy = structuredClone(obj);\nassert.deepEqual(\n  Object.getOwnPropertyDescriptors(copy),\n  {\n    readOnlyProp: {\n      value: 'abc',\n      writable: true,\n      enumerable: true,\n      configurable: true,\n    }\n  }\n);\n\n```", "```js\nconst jane = {\n  first: 'Jane',\n  says(text) {\n    return `${this.first} says “${text}”`;\n  },\n};\n\n```", "```js\nassert.equal(typeof jane.says, 'function');\n\n```", "```js\nconst jane = {\n  first: 'Jane',\n  says: function (text) {\n    return `${this.first} says “${text}”`;\n  },\n};\n\n```", "```js\nconst obj = {\n  someMethod(x, y) {\n    assert.equal(this, obj); // (A)\n    assert.equal(x, 'a');\n    assert.equal(y, 'b');\n  }\n};\nobj.someMethod('a', 'b'); // (B)\n\n```", "```js\nobj.someMethod('a', 'b')\n\n```", "```js\nobj.someMethod.call(obj, 'a', 'b');\n\n```", "```js\nconst func = obj.someMethod;\nfunc.call(obj, 'a', 'b');\n\n```", "```js\nconst jane = {\n  first: 'Jane',\n  says(text) {\n    return `${this.first} says “${text}”`; // (A)\n  },\n};\n\nconst func = jane.says.bind(jane, 'hello');\nassert.equal(func(), 'Jane says “hello”');\n\n```", "```js\nconst jane = {\n  first: 'Jane',\n  says(text) {\n    return `${this.first} says “${text}”`;\n  },\n};\nconst func = jane.says; // extract the method\nassert.throws(\n  () => func('hello'), // (A)\n  {\n    name: 'TypeError',\n    message: \"Cannot read properties of undefined (reading 'first')\",\n  }\n);\n\n```", "```js\nassert.throws(\n  () => jane.says.call(undefined, 'hello'), // `this` is undefined!\n  {\n    name: 'TypeError',\n    message: \"Cannot read properties of undefined (reading 'first')\",\n  }\n);\n\n```", "```js\nconst func2 = jane.says.bind(jane);\nassert.equal(func2('hello'), 'Jane says “hello”');\n\n```", "```js\nconst func3 = text => jane.says(text);\nassert.equal(func3('hello'), 'Jane says “hello”');\n\n```", "```js\nclass ClickHandler {\n  constructor(id, elem) {\n    this.id = id;\n    elem.addEventListener('click', this.handleClick); // (A)\n  }\n  handleClick(event) {\n    alert('Clicked ' + this.id);\n  }\n}\n\n```", "```js\nconst listener = this.handleClick.bind(this);\nelem.addEventListener('click', listener);\n\n// Later, possibly:\nelem.removeEventListener('click', listener);\n\n```", "```js\nconst prefixer = {\n  prefix: '==> ',\n  prefixStringArray(stringArray) {\n    return stringArray.map(\n      function (x) {\n        return this.prefix + x; // (A)\n      });\n  },\n};\nassert.throws(\n  () => prefixer.prefixStringArray(['a', 'b']),\n  {\n    name: 'TypeError',\n    message: \"Cannot read properties of undefined (reading 'prefix')\",\n  }\n);\n\n```", "```js\nconst prefixer = {\n  prefix: '==> ',\n  prefixStringArray(stringArray) {\n    return stringArray.map(\n      (x) => {\n        return this.prefix + x;\n      });\n  },\n};\nassert.deepEqual(\n  prefixer.prefixStringArray(['a', 'b']),\n  ['==> a', '==> b']);\n\n```", "```js\nprefixStringArray(stringArray) {\n  const that = this; // (A)\n  return stringArray.map(\n    function (x) {\n      return that.prefix + x;\n    });\n},\n\n```", "```js\nprefixStringArray(stringArray) {\n  return stringArray.map(\n    function (x) {\n      return this.prefix + x;\n    }.bind(this)); // (A)\n},\n\n```", "```js\nprefixStringArray(stringArray) {\n  return stringArray.map(\n    function (x) {\n      return this.prefix + x;\n    },\n    this); // (A)\n},\n\n```", "```js\nobj?.prop     // optional fixed property getting\nobj?.[«expr»] // optional dynamic property getting\nfunc?.(«arg0», «arg1», ···) // optional function or method call\n\n```", "```js\n> null?.prop\nundefined\n> {prop: 1}?.prop\n1\n\n> null?.(123)\nundefined\n> String?.(123)\n'123'\n\n```", "```js\nconst persons = [\n  {\n    surname: 'Zoe',\n    address: {\n      street: {\n        name: 'Sesame Street',\n        number: '123',\n      },\n    },\n  },\n  {\n    surname: 'Mariner',\n  },\n  {\n    surname: 'Carmen',\n    address: {\n    },\n  },\n];\n\n```", "```js\nconst streetNames = persons.map(\n  p => p.address?.street?.name);\nassert.deepEqual(\n  streetNames, ['Sesame Street', undefined, undefined]\n);\n\n```", "```js\nconst streetNames = persons.map(\n  p => p.address?.street?.name ?? '(no name)');\nassert.deepEqual(\n  streetNames, ['Sesame Street', '(no name)', '(no name)']\n);\n\n```", "```js\no?.prop\n(o !== undefined && o !== null) ? o.prop : undefined\n\n```", "```js\nassert.equal(undefined?.prop, undefined);\nassert.equal(null?.prop,      undefined);\nassert.equal({prop:1}?.prop,  1);\n\n```", "```js\no?.[«expr»]\n(o !== undefined && o !== null) ? o[«expr»] : undefined\n\n```", "```js\nconst key = 'prop';\nassert.equal(undefined?.[key], undefined);\nassert.equal(null?.[key], undefined);\nassert.equal({prop:1}?.[key], 1);\n\n```", "```js\nf?.(arg0, arg1)\n(f !== undefined && f !== null) ? f(arg0, arg1) : undefined\n\n```", "```js\nassert.equal(undefined?.(123), undefined);\nassert.equal(null?.(123), undefined);\nassert.equal(String?.(123), '123');\n\n```", "```js\nassert.throws(\n  () => true?.(123),\n  TypeError);\n\n```", "```js\nfunction invokeM(value) {\n  return value?.a.b.m(); // (A)\n}\n\nconst obj = {\n  a: {\n    b: {\n      m() { return 'result' }\n }\n }\n};\nassert.equal(\n invokeM(obj), 'result'\n);\nassert.equal(\n invokeM(undefined), undefined // (B)\n);\n\n```", "```js\nobj?.[«expr»]          // better: obj?[«expr»]\nfunc?.(«arg0», «arg1») // better: func?(«arg0», «arg1»)\n\n```", "```js\nobj?['a', 'b', 'c'].map(x => x+x)\nobj ? ['a', 'b', 'c'].map(x => x+x) : []\n\n```", "```js\nconst proto = {\n  protoProp: 'a',\n};\nconst obj = {\n  __proto__: proto,\n  objProp: 'b',\n};\n\n// obj inherits .protoProp:\nassert.equal(obj.protoProp, 'a');\nassert.equal('protoProp' in obj, true);\n\n```", "```js\n> const obj = { one: 1 };\n> typeof obj.one // own\n'number'\n> typeof obj.toString // inherited\n'function'\n\n```", "```js\n> Object.keys(obj)\n[ 'one' ]\n\n```", "```js\nconst proto = {\n  protoProp: 'a',\n};\nconst obj = {\n  __proto__: proto,\n};\n\n```", "```js\n// In the beginning, obj has no own properties\nassert.deepEqual(Object.keys(obj), []);\n\nobj.protoProp = 'x'; // (A)\n\n// We created an own property:\nassert.deepEqual(Object.keys(obj), ['protoProp']);\n\n// The inherited property itself is unchanged:\nassert.equal(proto.protoProp, 'a');\n\n// The own property overrides the inherited property:\nassert.equal(obj.protoProp, 'x');\n\n```", "```js\n    Object.getPrototypeOf(obj: object): object\n\n    ```", "```js\n    Object.create(proto: object): object\n\n    ```", "```js\n// Two objects with null prototypes\nconst obj1 = {__proto__: null};\nconst obj2 = Object.create(null);\n\nassert.equal(\n  Object.getPrototypeOf(obj1), null\n);\n\nconst proto = {};\nObject.setPrototypeOf(obj1, proto);\nassert.equal(\n  Object.getPrototypeOf(obj1), proto\n);\n\n```", "```js\nconst a = {};\nconst b = {__proto__: a};\nconst c = {__proto__: b};\n\nassert.equal(a.isPrototypeOf(b), true);\nassert.equal(a.isPrototypeOf(c), true);\n\nassert.equal(c.isPrototypeOf(a), false);\nassert.equal(a.isPrototypeOf(a), false);\n\n```", "```js\nconst proto = {\n  protoProp: 'protoProp',\n};\nconst obj = {\n  __proto__: proto,\n  objProp: 'objProp',\n}\nassert.equal('protoProp' in obj, true); // (A)\nassert.equal(Object.hasOwn(obj, 'protoProp'), false); // (B)\nassert.equal(Object.hasOwn(proto, 'protoProp'), true); // (C)\n\n```", "```js\nconst jane = {\n  firstName: 'Jane',\n  describe() {\n return 'Person named '+this.firstName;\n },\n};\nconst tarzan = {\n firstName: 'Tarzan',\n describe() {\n return 'Person named '+this.firstName;\n },\n};\n\nassert.equal(jane.describe(), 'Person named Jane');\nassert.equal(tarzan.describe(), 'Person named Tarzan'); \n```", "```js\nconst PersonProto = {\n  describe() {\n return 'Person named ' + this.firstName;\n },\n};\nconst jane = {\n __proto__: PersonProto,\n firstName: 'Jane',\n};\nconst tarzan = {\n __proto__: PersonProto,\n firstName: 'Tarzan',\n};\n\n```", "```js\nassert.equal(jane.describe(), 'Person named Jane');\nassert.equal(tarzan.describe(), 'Person named Tarzan');\n\n```", "```js\nconst obj = {\n  mustBeAnIdentifier: 123,\n};\n\n// Get property\nassert.equal(obj.mustBeAnIdentifier, 123);\n\n// Set property\nobj.mustBeAnIdentifier = 'abc';\nassert.equal(obj.mustBeAnIdentifier, 'abc');\n\n```", "```js\nconst obj = {\n  'Can be any string!': 123,\n};\n\n```", "```js\n// Get property\nassert.equal(obj['Can be any string!'], 123);\n\n// Set property\nobj['Can be any string!'] = 'abc';\nassert.equal(obj['Can be any string!'], 'abc');\n\n```", "```js\nconst obj = {\n  'A nice method'() {\n    return 'Yes!';\n  },\n};\n\nassert.equal(obj['A nice method'](), 'Yes!');\n\n```", "```js\nconst obj = {\n  ['Hello world!']: true,\n  ['p'+'r'+'o'+'p']: 123,\n  [Symbol.toStringTag]: 'Goodbye', // (A)\n};\n\nassert.equal(obj['Hello world!'], true);\nassert.equal(obj.prop, 123);\nassert.equal(obj[Symbol.toStringTag], 'Goodbye');\n\n```", "```js\nassert.equal(obj['p'+'r'+'o'+'p'], 123);\nassert.equal(obj['==> prop'.slice(4)], 123);\n\n```", "```js\nconst methodKey = Symbol();\nconst obj = {\n  [methodKey]() {\n    return 'Yes!';\n  },\n};\n\nassert.equal(obj[methodKey](), 'Yes!');\n\n```", "```js\nconst obj = {\n  alpha: 'abc',\n  beta: false,\n};\n\nassert.equal('alpha' in obj, true);\nassert.equal('beta' in obj, true);\nassert.equal('unknownKey' in obj, false);\n\n```", "```js\nassert.equal(\n  obj.alpha ? 'exists' : 'does not exist',\n  'exists');\nassert.equal(\n  obj.unknownKey ? 'exists' : 'does not exist',\n  'does not exist');\n\n```", "```js\nassert.equal(\n  obj.beta ? 'exists' : 'does not exist',\n  'does not exist'); // should be: 'exists'\n\n```", "```js\nconst obj = {\n  myProp: 123,\n};\n\nassert.deepEqual(Object.keys(obj), ['myProp']);\ndelete obj.myProp;\nassert.deepEqual(Object.keys(obj), []);\n\n```", "```js\nconst enumerableSymbolKey = Symbol('enumerableSymbolKey');\nconst nonEnumSymbolKey = Symbol('nonEnumSymbolKey');\n\n// We create enumerable properties via an object literal\nconst obj = {\n  enumerableStringKey: 1,\n  [enumerableSymbolKey]: 2,\n}\n\n// For non-enumerable properties, we need a more powerful tool\nObject.defineProperties(obj, {\n  nonEnumStringKey: {\n    value: 3,\n    enumerable: false,\n  },\n  [nonEnumSymbolKey]: {\n    value: 4,\n    enumerable: false,\n  },\n});\n\n// Non-enumerable properties are ignored by spreading:\nassert.deepEqual(\n  {...obj},\n  {\n    enumerableStringKey: 1,\n    [enumerableSymbolKey]: 2,\n  }\n);\n\n```", "```js\nconst enumerableSymbolKey = Symbol('enumerableSymbolKey');\nconst nonEnumSymbolKey = Symbol('nonEnumSymbolKey');\n\nconst obj = {\n  enumerableStringKey: 1,\n  [enumerableSymbolKey]: 2,\n}\nObject.defineProperties(obj, {\n  nonEnumStringKey: {\n    value: 3,\n    enumerable: false,\n  },\n  [nonEnumSymbolKey]: {\n    value: 4,\n    enumerable: false,\n  },\n});\n\nassert.deepEqual(\n  Object.keys(obj),\n  ['enumerableStringKey']\n);\nassert.deepEqual(\n  Object.getOwnPropertyNames(obj),\n  ['enumerableStringKey', 'nonEnumStringKey']\n);\nassert.deepEqual(\n  Object.getOwnPropertySymbols(obj),\n  [enumerableSymbolKey, nonEnumSymbolKey]\n);\nassert.deepEqual(\n  Reflect.ownKeys(obj),\n  [\n    'enumerableStringKey', 'nonEnumStringKey',\n    enumerableSymbolKey, nonEnumSymbolKey,\n  ]\n);\n\n```", "```js\nconst firstName = Symbol('firstName');\nconst obj = {\n  [firstName]: 'Jane',\n  lastName: 'Doe',\n};\nassert.deepEqual(\n  Object.values(obj),\n  ['Doe']);\n\n```", "```js\nconst firstName = Symbol('firstName');\nconst obj = {\n  [firstName]: 'Jane',\n  lastName: 'Doe',\n};\nObject.defineProperty(\n  obj, 'city', {value: 'Metropolis', enumerable: false}\n);\nassert.deepEqual(\n  Object.entries(obj),\n  [\n    ['lastName', 'Doe'],\n  ]);\n\n```", "```js\nfunction entries(obj) {\n  return Object.keys(obj)\n  .map(key => [key, obj[key]]);\n}\n\n```", "```js\nconst obj = {\n  b: true,\n  a: true,\n  10: true,\n  2: true,\n};\nassert.deepEqual(\n  Object.keys(obj),\n  ['2', '10', 'b', 'a']\n);\n\n```", "```js\nconst symbolKey = Symbol('symbolKey');\nassert.deepEqual(\n  Object.fromEntries(\n    [\n      ['stringKey', 1],\n      [symbolKey, 2],\n    ]\n  ),\n  {\n    stringKey: 1,\n    [symbolKey]: 2,\n  }\n);\n\n```", "```js\npick(object, ...keys)\n\n```", "```js\nconst address = {\n  street: 'Evergreen Terrace',\n  number: '742',\n  city: 'Springfield',\n  state: 'NT',\n  zip: '49007',\n};\nassert.deepEqual(\n  pick(address, 'street', 'number'),\n  {\n    street: 'Evergreen Terrace',\n    number: '742',\n  }\n);\n\n```", "```js\nfunction pick(object, ...keys) {\n  const filteredEntries = Object.entries(object)\n    .filter(([key, _value]) => keys.includes(key));\n  return Object.fromEntries(filteredEntries);\n}\n\n```", "```js\ninvert(object)\n\n```", "```js\nassert.deepEqual(\n  invert({a: 1, b: 2, c: 3}),\n  {1: 'a', 2: 'b', 3: 'c'}\n);\n\n```", "```js\nfunction invert(object) {\n  const reversedEntries = Object.entries(object)\n    .map(([key, value]) => [value, key]);\n  return Object.fromEntries(reversedEntries);\n}\n\n```", "```js\nfunction fromEntries(iterable) {\n  const result = {};\n  for (const [key, value] of iterable) {\n    let coercedKey;\n    if (typeof key === 'string' || typeof key === 'symbol') {\n      coercedKey = key;\n    } else {\n      coercedKey = String(key);\n    }\n    result[coercedKey] = value;\n  }\n  return result;\n}\n\n```", "```js\nconst dict = {};\nassert.equal(\n  typeof dict['toString'], 'function'\n);\n\n```", "```js\nconst dict = {};\nassert.equal(\n  'toString' in dict, true\n);\n\n```", "```js\nconst dict = {};\nassert.equal(\n  Object.hasOwn(dict, 'toString'), false\n);\n\n```", "```js\nconst dict = {};\n\ndict['__proto__'] = 123;\n// No property was added to dict:\nassert.deepEqual(\n  Object.keys(dict), []\n);\n\n```", "```js\nconst dict = Object.create(null);\n\n// No inherited properties\nassert.equal(\n  dict['toString'], undefined\n);\nassert.equal(\n  'toString' in dict, false\n);\n\n// No special behavior with key '__proto__'\ndict['__proto__'] = true;\nassert.deepEqual(\n  Object.keys(dict), ['__proto__']\n);\n\n```", "```js\nconst htmlToLatex = {\n  __proto__: null,\n  'i': 'textit',\n  'b': 'textbf',\n  'u': 'underline',\n};\n\n```", "```js\n    assert.equal(\n      Object.getPrototypeOf(import.meta), null\n    );\n\n    ```", "```js\n    const grouped = Object.groupBy([], x => x);\n    assert.equal(\n      Object.getPrototypeOf(grouped), null\n    );\n\n    ```", "```js\n    const matchObj = /(?<group>x)/.exec('x');\n    assert.equal(\n      Object.getPrototypeOf(matchObj.groups), null\n    );\n\n    ```", "```js\nconst obj = { myProp: 123 };\nassert.deepEqual(\n  Object.getOwnPropertyDescriptor(obj, 'myProp'),\n  {\n    value: 123,\n    writable: true,\n    enumerable: true,\n    configurable: true,\n  });\n\n```", "```js\nassert.deepEqual(Object.keys(obj), ['myProp']);\n\n// Hide property `myProp` from Object.keys()\n// by making it non-enumerable\nObject.defineProperty(obj, 'myProp', {\n  enumerable: false,\n});\n\nassert.deepEqual(Object.keys(obj), []);\n\n```", "```js\nconst obj = {\n  myMethod() {},\n get myGetter() {},\n};\nconst propDescs = Object.getOwnPropertyDescriptors(obj);\npropDescs.myMethod.value = typeof propDescs.myMethod.value;\npropDescs.myGetter.get = typeof propDescs.myGetter.get;\nassert.deepEqual(\n propDescs,\n {\n myMethod: {\n value: 'function',\n writable: true,\n enumerable: true,\n configurable: true\n },\n myGetter: {\n get: 'function',\n set: undefined,\n enumerable: true,\n configurable: true\n }\n }\n);\n\n```", "```js\nconst frozen = Object.freeze({ x: 2, y: 5 });\nassert.throws(\n  () => frozen.x = 7,\n  {\n    name: 'TypeError',\n    message: /^Cannot assign to read only property 'x'/,\n  }\n);\n\n```", "```js\n    > const obj = Object.create(null);\n    > Object.getPrototypeOf(obj)\n    null\n\n    ```", "```js\n    const obj = Object.create(\n      null,\n      {\n        color: {\n          value: 'green',\n          writable: true,\n          enumerable: true,\n          configurable: true,\n        },\n      }\n    );\n    assert.deepEqual(\n      obj,\n      {\n        __proto__: null,\n        color: 'green',\n      }\n    );\n\n    ```", "```js\n    assert.equal(\n      Object.getPrototypeOf({__proto__: null}), null\n    );\n    assert.equal(\n      Object.getPrototypeOf({}), Object.prototype\n    );\n    assert.equal(\n      Object.getPrototypeOf(Object.prototype), null\n    );\n\n    ```", "```js\n    const obj = {};\n    assert.equal(\n      Object.getPrototypeOf(obj), Object.prototype\n    );\n    Object.setPrototypeOf(obj, null);\n    assert.equal(\n      Object.getPrototypeOf(obj), null\n    );\n\n    ```", "```js\n    const obj = {};\n    Object.defineProperty(\n      obj, 'color',\n      {\n        value: 'green',\n        writable: true,\n        enumerable: true,\n        configurable: true,\n      }\n    );\n    assert.deepEqual(\n      obj,\n      {\n        color: 'green',\n      }\n    );\n\n    ```", "```js\n    const obj = {};\n    Object.defineProperties(\n      obj,\n      {\n        color: {\n          value: 'green',\n          writable: true,\n          enumerable: true,\n          configurable: true,\n        },\n      }\n    );\n    assert.deepEqual(\n      obj,\n      {\n        color: 'green',\n      }\n    );\n\n    ```", "```js\n    > Object.getOwnPropertyDescriptor({a: 1, b: 2}, 'a')\n    { value: 1, writable: true, enumerable: true, configurable: true }\n    > Object.getOwnPropertyDescriptor({a: 1, b: 2}, 'x')\n    undefined\n\n    ```", "```js\n    > Object.getOwnPropertyDescriptors({a: 1, b: 2})\n    {\n      a: { value: 1, writable: true, enumerable: true, configurable: true },\n      b: { value: 2, writable: true, enumerable: true, configurable: true },\n    }\n\n    ```", "```js\n    const enumSymbolKey = Symbol('enumSymbolKey');\n    const nonEnumSymbolKey = Symbol('nonEnumSymbolKey');\n\n    const obj = Object.defineProperties(\n      {},\n      {\n        enumStringKey: {\n          value: 1, enumerable: true,\n        },\n        [enumSymbolKey]: {\n          value: 2, enumerable: true,\n        },\n        nonEnumStringKey: {\n          value: 3, enumerable: false,\n        },\n        [nonEnumSymbolKey]: {\n          value: 4, enumerable: false,\n        },\n      }\n    );\n    assert.deepEqual(\n      Object.keys(obj),\n      ['enumStringKey']\n    );\n\n    ```", "```js\n    const enumSymbolKey = Symbol('enumSymbolKey');\n    const nonEnumSymbolKey = Symbol('nonEnumSymbolKey');\n\n    const obj = Object.defineProperties(\n      {},\n      {\n        enumStringKey: {\n          value: 1, enumerable: true,\n        },\n        [enumSymbolKey]: {\n          value: 2, enumerable: true,\n        },\n        nonEnumStringKey: {\n          value: 3, enumerable: false,\n        },\n        [nonEnumSymbolKey]: {\n          value: 4, enumerable: false,\n        },\n      }\n    );\n    assert.deepEqual(\n      Object.getOwnPropertyNames(obj),\n      ['enumStringKey', 'nonEnumStringKey']\n    );\n\n    ```", "```js\n    const enumSymbolKey = Symbol('enumSymbolKey');\n    const nonEnumSymbolKey = Symbol('nonEnumSymbolKey');\n\n    const obj = Object.defineProperties(\n      {},\n      {\n        enumStringKey: {\n          value: 1, enumerable: true,\n        },\n        [enumSymbolKey]: {\n          value: 2, enumerable: true,\n        },\n        nonEnumStringKey: {\n          value: 3, enumerable: false,\n        },\n        [nonEnumSymbolKey]: {\n          value: 4, enumerable: false,\n        },\n      }\n    );\n    assert.deepEqual(\n      Object.getOwnPropertySymbols(obj),\n      [enumSymbolKey, nonEnumSymbolKey]\n    );\n\n    ```", "```js\n    > Object.values({a: 1, b: 2})\n    [ 1, 2 ]\n\n    ```", "```js\n    const obj = {\n      a: 1,\n      b: 2,\n      [Symbol('myKey')]: 3,\n    };\n    assert.deepEqual(\n      Object.entries(obj),\n      [\n        ['a', 1],\n        ['b', 2],\n        // Property with symbol key is ignored\n      ]\n    );\n\n    ```", "```js\n    > Object.fromEntries([['a', 1], ['b', 2]])\n    { a: 1, b: 2 }\n\n    ```", "```js\n    > Object.hasOwn({a: 1, b: 2}, 'a')\n    true\n    > Object.hasOwn({a: 1, b: 2}, 'x')\n    false\n\n    ```", "```js\n    const frozen = Object.freeze({ x: 2, y: 5 });\n    assert.equal(\n      Object.isFrozen(frozen), true\n    );\n    assert.throws(\n      () => frozen.x = 7,\n      {\n        name: 'TypeError',\n        message: /^Cannot assign to read only property 'x'/,\n      }\n    );\n\n    ```", "```js\n    > const obj = {a: 1, b: 1};\n    > Object.assign(obj, {b: 2, c: 2}, {d: 3})\n    { a: 1, b: 2, c: 2, d: 3 }\n    > obj\n    { a: 1, b: 2, c: 2, d: 3 }\n\n    ```", "```js\n    Object.groupBy<K extends PropertyKey, T>(\n      items: Iterable<T>,\n      computeGroupKey: (item: T, index: number) => K,\n    ): {[key: K]: Array<T>}\n\n    ```", "```js\n    assert.deepEqual(\n      Object.groupBy(\n        ['orange', 'apricot', 'banana', 'apple', 'blueberry'],\n        (str) => str[0] // compute group key\n      ),\n      {\n        __proto__: null,\n        'o': ['orange'],\n        'a': ['apricot', 'apple'],\n        'b': ['banana', 'blueberry'],\n      }\n    );\n\n    ```", "```js\n    > NaN === NaN\n    false\n    > Object.is(NaN, NaN)\n    true\n\n    > -0 === 0\n    true\n    > Object.is(-0, 0)\n    false\n\n    ```", "```js\n    func.apply(thisArg, argArray) // not safe\n    Function.prototype.apply.call(func, thisArg, argArray) // safe\n\n    ```", "```js\n    Reflect.apply(func, thisArg, argArray)\n\n    ```"]