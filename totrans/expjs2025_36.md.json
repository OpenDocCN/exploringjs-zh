["```js\nconst myObject = { // object literal\n myProperty: 1,\n myMethod() {\n return 2;\n }, // comma!\n get myAccessor() {\n return this.myProperty;\n }, // comma!\n set myAccessor(value) {\n this.myProperty = value;\n }, // last comma is optional\n};\n `assert.equal(`\n `myObject.myProperty, 1`\n`);`\n`assert.equal(`\n `myObject.myMethod(), 2`\n`);`\n`assert.equal(`\n `myObject.myAccessor, 1`\n`);`\n`myObject.myAccessor = 3;`\n`assert.equal(`\n `myObject.myProperty, 3`\n`);` \n```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js`` Being able to create objects directly (without classes) is one of the highlights of JavaScript.    Spreading into objects:    ``` const original = {  a: 1,  b: {  c: 3,  }, };  `// Spreading (...) copies one object “into” another one:` `const modifiedCopy = {`  `...original, // spreading`  `d: 4,` `};`  ```js` `assert.deepEqual(`  `modifiedCopy,`  `{`  `a: 1,`  `b: {`  `c: 3,`  `},`  `d: 4,`  `}` `);`  ``` `// Caveat: spreading copies shallowly (property values are shared)` `` modifiedCopy.a = 5; // does not affect `original` `` `` modifiedCopy.b.c = 6; // affects `original` `` `assert.deepEqual(`  `original,`  `{`  `a: 1, // unchanged`  `b: {`  `c: 6, // changed`  `},`  `},` `);` ```js ````", "```js   ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js We can also use spreading to make an unmodified (shallow) copy of an object:    ``` const exactCopy = {...obj};  ```js    #### [30.1.2 Cheat sheet: prototype chains](#cheat-sheet-prototype-chains)    Prototypes are JavaScript’s fundamental inheritance mechanism. Even classes are based on it. Each object has `null` or an object as its prototype. The latter object can also have a prototype, etc. In general, we get *chains* of prototypes.    Prototypes are managed like this:    ``` // `obj1` has no prototype (its prototype is `null`) const obj1 = Object.create(null); // (A) assert.equal(  Object.getPrototypeOf(obj1), null // (B) );  `` // `obj2` has the prototype `proto` `` `const proto = {`  `protoProp: 'protoProp',` `};` `const obj2 = {`  `__proto__: proto, // (C)`  `objProp: 'objProp',` `}` `assert.equal(`  `Object.getPrototypeOf(obj2), proto` `);`  ```js   ````", "```````js```````", "```````js```````", "```````js```````", "``` Notes:    *   Setting an object’s prototype while creating the object: line A, line C *   Retrieving the prototype of an object: line B    Each object inherits all the properties of its prototype:    ```", "```js    The non-inherited properties of an object are called its *own* properties.    The most important use case for prototypes is that several objects can share methods by inheriting them from a common prototype.    ### [30.2 What is an object?](#what-is-an-object)    Objects in JavaScript:    *   An object is a set of *slots* (key-value entries). *   Public slots are called *properties*:     *   A property key can only be a string or a symbol. *   Private slots can only be created via classes and are explained in [“Public slots (properties) vs. private slots” (§31.2.4)](ch_classes.html#private-slots).    #### [30.2.1 The two ways of using objects](#ways-of-using-objects)    There are two ways of using objects in JavaScript:    *   Fixed-layout objects: Used this way, objects work like records in databases. They have a fixed number of properties, whose keys are known at development time. Their values generally have different types.                    ```", "```js           *   Dictionary objects: Used this way, objects work like lookup tables or maps. They have a variable number of properties, whose keys are not known at development time. All of their values have the same type.                    ```", "```js              Note that the two ways can also be mixed: Some objects are both fixed-layout objects and dictionary objects.    The ways of using objects influence how they are explained in this chapter:    *   [First, we’ll explore fixed-layout objects.](#fixed-layout-objects) Even though property keys are strings or symbols under the hood, they will appear as fixed identifiers to us. *   [Later, we’ll explore dictionary objects.](#dictionary-objects) Note that [Maps](ch_maps.html#ch_maps) are usually better dictionaries than objects. However, some of the operations that we’ll encounter are also useful for fixed-layout objects.    ### [30.3 Fixed-layout objects](#fixed-layout-objects)    Let’s first explore *fixed-layout objects*.    #### [30.3.1 Object literals: properties](#object-literals)    *Object literals* are one way of creating fixed-layout objects. They are a stand-out feature of JavaScript: we can directly create objects – no need for classes! This is an example:    ```", "```js    In the example, we created an object via an object literal, which starts and ends with curly braces `{}`. Inside it, we defined two *properties* (key-value entries):    *   The first property has the key `first` and the value `'Jane'`. *   The second property has the key `last` and the value `'Doe'`.    Since ES5, trailing commas are allowed in object literals.    We will later see other ways of specifying property keys, but with this way of specifying them, they must follow the rules of JavaScript variable names. For example, we can use `first_name` as a property key, but not `first-name`). However, reserved words are allowed:    ```", "```js    In order to check the effects of various operations on objects, we’ll occasionally use `Object.keys()` in this part of the chapter. It lists property keys:    ```", "```js    #### [30.3.2 Object literals: property value shorthands](#object-literals-property-value-shorthands)    Whenever the value of a property is defined via a variable that has the same name as the key, we can omit the key.    ```", "```js    #### [30.3.3 Getting properties](#getting-properties)    This is how we *get* (read) a property (line A):    ```", "```js   ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js`` Getting an unknown property produces `undefined`:    ```", "```js    #### [30.3.4 Setting properties](#setting-properties)    This is how we *set* (write to) a property (line A):    ```", "```js    We just changed an existing property via setting. If we set an unknown property, we create a new entry:    ```", "```js   ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js` #### [30.3.5 Object literals: methods](#object-literals-methods)    The following code shows how to create the method `.says()` via an object literal:    ```", "```js    During the method call `jane.says('hello')`, `jane` is called the *receiver* of the method call and assigned to the special variable `this` (more on `this` in [“Methods and the special variable `this`” (§30.6)](#methods-and-this)). That enables method `.says()` to access the sibling property `.first` in line A.    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Creating an object via an object literal**    `exercises/objects/color_point_object_test.mjs`    #### [30.3.6 Object literals: accessors](#object-literal-accessors)    *Accessors* are methods that are invoked by accessing a property. It consists of either or both of:    *   A *getter* is invoked by getting a property. *   A *setter* is invoked by setting a property.    ##### [30.3.6.1 Getters](#getters)    A getter is created by prefixing a method definition with the modifier `get`:    ```", "```js   ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js ##### [30.3.6.2 Setters](#setters)    A setter is created by prefixing a method definition with the modifier `set`:    ```", "```js   ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js function createCounter() {  // Private data via closure  let value = 0;  return {  get value() {  return value;  },  inc() {  value++;  },  }; }  `const counter = createCounter();` `assert.equal(counter.value, 0);`  ```", "```js  ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js const obj1 = {a: 1, b: 2}; const obj2 = {c: 3}; assert.deepEqual(  {...obj1, ...obj2, d: 4},  {a: 1, b: 2, c: 3, d: 4} );  ```", "```js > const obj = {one: 1, two: 2, three: 3}; > {...obj, one: true} { one: true, two: 2, three: 3 } > {one: true, ...obj} { one: 1, two: 2, three: 3 }  ```", "```js > {...undefined} {} > {...null} {} > {...123} {} > {...'abc'} { '0': 'a', '1': 'b', '2': 'c' } > {...['a', 'b']} { '0': 'a', '1': 'b' }  ```", "```js const symbolKey = Symbol('symbolKey'); const obj = {  stringKey: 1,  [symbolKey]: 2, }; assert.deepEqual(  {...obj, anotherStringKey: 3},  {  stringKey: 1,  [symbolKey]: 2,  anotherStringKey: 3,  } );  ```", "```js const DEFAULTS = {alpha: 'a', beta: 'b'}; const providedData = {alpha: 1};  `const allData = {...DEFAULTS, ...providedData};` `assert.deepEqual(allData, {alpha: 1, beta: 'b'});`  ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js const providedData = {alpha: 1};  `const allData = {alpha: 'a', beta: 'b', ...providedData};` `assert.deepEqual(allData, {alpha: 1, beta: 'b'});`  ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js const obj = {alpha: 'a', beta: 'b'}; obj.alpha = 1; // (A) assert.deepEqual(obj, {alpha: 1, beta: 'b'});  ```", "```js const obj = {alpha: 'a', beta: 'b'}; const updatedObj = {...obj, alpha: 1}; assert.deepEqual(updatedObj, {alpha: 1, beta: 'b'});  ```", "```js Object.assign(target, source_1, source_2, ···)  ```", "```js const target = { a: 1 };  `const result = Object.assign(`  `target,`  `{b: 2},`  `{c: 3, b: true}` `);`  `` `assert.deepEqual(`  `result, { a: 1, b: true, c: 3 }` `);` `// target was modified and returned:` `assert.equal(result, target);` ``  ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js``` The use cases for `Object.assign()` are similar to those for spread properties. In a way, it spreads destructively.    ### [30.5 Copying objects: spreading vs. `Object.assign()` vs. `structuredClone()`](#copying-objects)    #### [30.5.1 Copying objects via spreading is *shallow*](#copying-objects-via-spreading-is-shallow)    One common way of copying Arrays and plain objects in JavaScript is via spreading. This code demonstrates the latter:    ``` const obj = {id: 'e1fd960b', values: ['a', 'b']}; const shallowCopy = {...obj};  ```js    Alas, this way of copying is *shallow*: The properties (key-value entries) are copied but not the property values.    On one hand, the key-value entry `shallowCopy.id` is a copy, so changing it does not change `obj`:    ``` shallowCopy.id = 'yes'; assert.equal(obj.id, 'e1fd960b');  ```js    On the other hand, the Array in `shallowCopy.values` is shared with `obj`. If we change it, we also change `obj`:    ``` shallowCopy.values.push('x'); assert.deepEqual(  shallowCopy, {id: 'yes', values: ['a', 'b', 'x']} ); assert.deepEqual(  obj, {id: 'e1fd960b', values: ['a', 'b', 'x']} );  ```js    Copying via `Object.assign()` is similar to copying via spreading and also shallow:    ``` const obj = {id: 'e1fd960b', values: ['a', 'b']}; // Copy the properties of `obj` into a new object const shallowCopy = Object.assign({}, obj);  ```js    #### [30.5.2 Copying objects deeply via `structuredClone()`](#structuredClone)    `structuredClone()` is a function for copying objects. Even though it is not part of ECMAScript, it is [well-supported](https://developer.mozilla.org/en-US/docs/Web/API/Window/structuredClone#browser_compatibility) on all major JavaScript platforms. It has the following typeSignature:    ``` structuredClone(value: any): any  ```js    `structuredClone()` copies objects deeply:    ``` const obj = {id: 'e1fd960b', values: ['a', 'b']}; const deepCopy = structuredClone(obj);  `deepCopy.values.push('x');` `assert.deepEqual(`  `deepCopy, {id: 'e1fd960b', values: ['a', 'b', 'x']}` `);` `assert.deepEqual(`  `obj, {id: 'e1fd960b', values: ['a', 'b']}` `);`  ```js   ````", "```````js```````", "```````js```````", "`````` ![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **`structuredClone()` has a second paramater**    `structuredClone()` has a second parameter which is beyond the scope of this chapter. For more information, see:    *   [“Transferring ArrayBuffers via `structuredClone()`” (§35.7.3)](ch_typed-arrays.html#transferring-arraybuffers-via-structuredclone) *   [The MDN page for `structuredClone()`](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone)    #### [30.5.3 Which values can `structuredClone()` copy?](#which-values-can-structuredclone-copy)    *   It can copy all primitive values except symbols. *   It can copy all built-in objects except functions and DOM nodes. *   Instances of user-defined classes become plain objects. *   Private fields are not copied. *   Cyclical references are copied correctly.    Given that the original use case for `structuredClone()` was copying objects to other processes, these limitations make sense.    Read on for more information.    ##### [30.5.3.1 Most primitive values can be copied](#most-primitive-values-can-be-copied)    ```js > typeof structuredClone(true) 'boolean' > typeof structuredClone(123) 'number' > typeof structuredClone(123n) 'bigint' > typeof structuredClone('abc') 'string'  ```    ##### [30.5.3.2 Most built-in objects can be copied](#most-builtin-objects-can-be-copied)    Arrays and plain objects can be copied:    ```js > structuredClone({prop: true}) { prop: true } > structuredClone(['a', 'b', 'c']) [ 'a', 'b', 'c' ]  ```    Instances of most built-in classes can be copied – even though they have internal slots. They remain instances of their classes.    ```js > structuredClone(/^a+$/) instanceof RegExp true > structuredClone(new Date()) instanceof Date true  ```    ##### [30.5.3.3 Copying symbols and some objects produces exceptions](#copying-symbols-and-some-objects-produces-exceptions)    Symbols and some objects cannot be copied – `structuredClone()` throws a `DOMException` if we try to copy them or if we try to copy an object that contains them:    *   Symbols *   Functions (ordinary functions, arrow functions, classes, methods) *   DOM nodes    Examples – cloning symbols:    ```js > structuredClone(Symbol()) DOMException [DataCloneError]: Symbol() could not be cloned. > structuredClone({[Symbol()]: true}) // property is ignored {} > structuredClone({prop: Symbol()}) DOMException [DataCloneError]: Symbol() could not be cloned.  ```    Examples – cloning functions:    ```js > structuredClone(function () {}) // ordinary function DOMException [DataCloneError]: function () {} could not be cloned. > structuredClone(() => {}) // arrow function DOMException [DataCloneError]: () => {} could not be cloned. > structuredClone(class {}) DOMException [DataCloneError]: class {} could not be cloned.  `> structuredClone({ m(){} }.m) // method` `DOMException [DataCloneError]: m(){} could not be cloned.` `> structuredClone({ m(){} }) // object with method` `DOMException [DataCloneError]: m(){} could not be cloned.`  ```   ```js``````", "```````js```````", "```````js```````", "``` try {  structuredClone(() => {}); } catch (err) {  assert.equal(  err instanceof DOMException, true  );  assert.equal(  err.name, 'DataCloneError'  );  assert.equal(  err.code, DOMException.DATA_CLONE_ERR  ); }  ```", "``` class C {} const copy = structuredClone(new C());  `assert.equal(copy instanceof C, false);` `assert.equal(`  `Object.getPrototypeOf(copy),`  `Object.prototype` `);`  ```", "``````js``````", "```````js```````", "```````js```` ##### [30.5.3.5 Private fields are not copied](#private-fields-are-not-copied)    This limitation is related to the previous subsection – private fields are not copied by `structuredClone()`:    ```js class C {  static hasPrivateField(value) {  return #privateField in value;  }  #privateField = true; }  `const original = new C();` `assert.equal(`  `C.hasPrivateField(original), true` `);` `const copy = structuredClone(original);` `assert.equal(`  `C.hasPrivateField(copy), false` `);`  ```   ```js```````", "```````js```````", "```````js`````` ##### [30.5.3.6 Cyclical references are copied correctly](#cyclical-references-are-copied-correctly)    If we copy an object with a reference cycle, the result has the same structure:    ```js const cycle = {}; cycle.prop = cycle;  `const copy = structuredClone(cycle);` `assert.equal(`  `copy.prop, copy` `);`  ```   ```js```````", "```````js```````", "```````js````` #### [30.5.4 The property attributes of copied objects](#the-property-attributes-of-copied-objects)    `structuredClone()` doesn’t always faithfully copy the [property attributes](#property-attributes-property-descriptors) of objects:    *   Accessors are turned into data properties. *   In copies, the property attributes always have default values.    Read on for more information.    ##### [30.5.4.1 Accessors become data properties](#accessors-become-data-properties)    Accessors become data properties:    ```js const obj = Object.defineProperties(  {},  {  accessor: {  get: function () {  return 123;  },  set: undefined,  enumerable: true,  configurable: true,  },  } ); const copy = structuredClone(obj); assert.deepEqual(  Object.getOwnPropertyDescriptors(copy),  {  accessor: {  value: 123,  writable: true,  enumerable: true,  configurable: true,  },  } );  ```    ##### [30.5.4.2 Copies of properties have default attribute values](#copies-of-properties-have-default-attribute-values)    Data properties of copies always have the following attributes:    ```js writable: true, enumerable: true, configurable: true,  ```    ```js const obj = Object.defineProperties(  {},  {  readOnlyProp: {  value: 'abc',  writable: false,  enumerable: true,  configurable: false,  },  } ); const copy = structuredClone(obj); assert.deepEqual(  Object.getOwnPropertyDescriptors(copy),  {  readOnlyProp: {  value: 'abc',  writable: true,  enumerable: true,  configurable: true,  }  } );  ```    #### [30.5.5 Alternatives without the limitations of `structuredClone()`?](#alternatives-without-the-limitations-of-structuredclone)    If we can’t live with the limitations of `structuredClone()`, such as turning instances of classes into plain objects, we can use the Lodash function [`cloneDeep()`](https://lodash.com/docs#cloneDeep) – which has fewer limitations.    #### [30.5.6 Sources of this section](#sources-of-this-section-1)    *   [Section “Safe passing of structured data”](https://html.spec.whatwg.org/#safe-passing-of-structured-data) in the WHATWG HTML standard *   [“The structured clone algorithm”](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm) on MDN *   [“`structuredClone()`”](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone) on MDN    ### [30.6 Methods and the special variable `this`](#methods-and-this)    #### [30.6.1 Methods are properties whose values are functions](#methods-are-properties-whose-values-are-functions)    Let’s revisit the example that was used to introduce methods:    ```js const jane = {  first: 'Jane',  says(text) {  return `${this.first} says “${text}”`;  }, };  ```    Somewhat surprisingly, methods are functions:    ```js assert.equal(typeof jane.says, 'function');  ```    Why is that? We learned [in the chapter on callable values](ch_callables.html#roles-of-ordinary-functions) that ordinary functions play several roles. *Method* is one of those roles. Therefore, internally, `jane` roughly looks as follows.    ```js const jane = {  first: 'Jane',  says: function (text) {  return `${this.first} says “${text}”`;  }, };  ```    #### [30.6.2 The special variable `this`](#the-special-variable-this)    Consider the following code:    ```js const obj = {  someMethod(x, y) {  assert.equal(this, obj); // (A)  assert.equal(x, 'a');  assert.equal(y, 'b');  } }; obj.someMethod('a', 'b'); // (B)  ```    In line B, `obj` is the *receiver* of a method call. It is passed to the function stored in `obj.someMethod` via an implicit (hidden) parameter whose name is `this` (line A).    ![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **How to understand `this`**    The best way to understand `this` is as an implicit parameter of ordinary functions and methods.    #### [30.6.3 Methods and `.call()`](#methods-call)    Methods are functions and functions have methods themselves. One of those methods is [`.call()`](ch_callables.html#Function.prototype.call). Let’s look at an example to understand how this method works.    In the previous section, there was this method invocation:    ```js obj.someMethod('a', 'b')  ```    This invocation is equivalent to:    ```js obj.someMethod.call(obj, 'a', 'b');  ```    Which is also equivalent to:    ```js const func = obj.someMethod; func.call(obj, 'a', 'b');  ```    `.call()` makes the normally implicit parameter `this` explicit: When invoking a function via `.call()`, the first parameter is `this`, followed by the regular (explicit) function parameters.    As an aside, this means that there are actually two different dot operators:    1.  One for accessing properties: `obj.prop` 2.  Another one for calling methods: `obj.prop()`    They are different in that (2) is not just (1) followed by the function call operator `()`. Instead, (2) additionally provides a value for `this`.    #### [30.6.4 Methods and `.bind()`](#methods-bind)    [`.bind()`](ch_callables.html#Function.prototype.bind) is another method of function objects. In the following code, we use `.bind()` to turn method `.says()` into the stand-alone function `func()`:    ```js const jane = {  first: 'Jane',  says(text) {  return `${this.first} says “${text}”`; // (A)  }, };  `const func = jane.says.bind(jane, 'hello');` `assert.equal(func(), 'Jane says “hello”');`  ```   ```js```````", "```````js```````", "```````js```` Setting `this` to `jane` via `.bind()` is crucial here. Otherwise, `func()` wouldn’t work properly because `this` is used in line A. In the next section, we’ll explore why that is.    #### [30.6.5 `this` pitfall: extracting methods](#extracting-methods)    We now know quite a bit about functions and methods and are ready to take a look at the biggest pitfall involving methods and `this`: function-calling a method extracted from an object can fail if we are not careful.    In the following example, we fail when we extract method `jane.says()`, store it in the variable `func`, and function-call `func`.    ```js const jane = {  first: 'Jane',  says(text) {  return `${this.first} says “${text}”`;  }, }; const func = jane.says; // extract the method assert.throws(  () => func('hello'), // (A)  {  name: 'TypeError',  message: \"Cannot read properties of undefined (reading 'first')\",  } );  ```    In line A, we are making a normal function call. And in normal function calls, `this` is `undefined` (if [strict mode](ch_syntax.html#strict-mode) is active, which it almost always is). Line A is therefore equivalent to:    ```js assert.throws(  () => jane.says.call(undefined, 'hello'), // `this` is undefined!  {  name: 'TypeError',  message: \"Cannot read properties of undefined (reading 'first')\",  } );  ```    How do we fix this? We need to use `.bind()` to extract method `.says()`:    ```js const func2 = jane.says.bind(jane); assert.equal(func2('hello'), 'Jane says “hello”');  ```    The `.bind()` ensures that `this` is always `jane` when we call `func()`.    We can also use arrow functions to extract methods:    ```js const func3 = text => jane.says(text); assert.equal(func3('hello'), 'Jane says “hello”');  ```    ##### [30.6.5.1 Example: extracting a method](#example-extracting-a-method)    The following is a simplified version of code that we may see in actual web development:    ```js class ClickHandler {  constructor(id, elem) {  this.id = id;  elem.addEventListener('click', this.handleClick); // (A)  }  handleClick(event) {  alert('Clicked ' + this.id);  } }  ```    In line A, we don’t extract the method `.handleClick()` properly. Instead, we should do:    ```js const listener = this.handleClick.bind(this); elem.addEventListener('click', listener);  `// Later, possibly:` `elem.removeEventListener('click', listener);`  ```   ```js```````", "```````js```````", "```````js``` Each invocation of `.bind()` creates a new function. That’s why we need to store the result somewhere if we want to remove it later on.    ##### [30.6.5.2 How to avoid the pitfall of extracting methods](#how-to-avoid-the-pitfall-of-extracting-methods)    Alas, there is no simple way around the pitfall of extracting methods: Whenever we extract a method, we have to be careful and do it properly – for example, by binding `this` or by using an arrow function.    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Extracting a method**    `exercises/objects/method_extraction_exrc.mjs`    #### [30.6.6 `this` pitfall: accidentally shadowing `this`](#shadowing-this)    ![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Accidentally shadowing `this` is only an issue with ordinary functions**    Arrow functions don’t shadow `this`.    Consider the following problem: when we are inside an ordinary function, we can’t access the `this` of the surrounding scope because the ordinary function has its own `this`. In other words, a variable in an inner scope hides a variable in an outer scope. That is called [*shadowing*](ch_variables-assignment.html#shadowing-variables). The following code is an example:    ``` const prefixer = {  prefix: '==> ',  prefixStringArray(stringArray) {  return stringArray.map(  function (x) {  return this.prefix + x; // (A)  });  }, }; assert.throws(  () => prefixer.prefixStringArray(['a', 'b']),  {  name: 'TypeError',  message: \"Cannot read properties of undefined (reading 'prefix')\",  } );  ```js    In line A, we want to access the `this` of `.prefixStringArray()`. But we can’t since the surrounding ordinary function has its own `this` that *shadows* (and blocks access to) the `this` of the method. The value of the former `this` is `undefined` due to the callback being function-called. That explains the error message.    The simplest way to fix this problem is via an arrow function, which doesn’t have its own `this` and therefore doesn’t shadow anything:    ``` const prefixer = {  prefix: '==> ',  prefixStringArray(stringArray) {  return stringArray.map(  (x) => {  return this.prefix + x;  });  }, }; assert.deepEqual(  prefixer.prefixStringArray(['a', 'b']),  ['==> a', '==> b']);  ```js    We can also store `this` in a different variable (line A), so that it doesn’t get shadowed:    ``` prefixStringArray(stringArray) {  const that = this; // (A)  return stringArray.map(  function (x) {  return that.prefix + x;  }); },  ```js    Another option is to specify a fixed `this` for the callback via `.bind()` (line A):    ``` prefixStringArray(stringArray) {  return stringArray.map(  function (x) {  return this.prefix + x;  }.bind(this)); // (A) },  ```js    Lastly, `.map()` lets us specify a value for `this` (line A) that it uses when invoking the callback:    ``` prefixStringArray(stringArray) {  return stringArray.map(  function (x) {  return this.prefix + x;  },  this); // (A) },  ```js    ##### [30.6.6.1 Avoiding the pitfall of accidentally shadowing `this`](#avoiding-the-pitfall-of-accidentally-shadowing-this)    If we follow the advice in [“Recommendation: prefer specialized functions over ordinary functions” (§27.3.4)](ch_callables.html#prefer-specialized-functions), we can avoid the pitfall of accidentally shadowing `this`. This is a summary:    *   Use arrow functions as anonymous inline functions. They don’t have `this` as an implicit parameter and don’t shadow it.           *   For named stand-alone function declarations we can either use arrow functions or function declarations. If we do the latter, we have to make sure `this` isn’t mentioned in their bodies.              #### [30.6.7 The value of `this` in various contexts (advanced)](#the-value-of-this-in-various-contexts-advanced)    What is the value of `this` in various contexts?    Inside a callable entity, the value of `this` depends on how the callable entity is invoked and what kind of callable entity it is:    *   Function call:     *   Ordinary functions: `this === undefined` (in [strict mode](ch_syntax.html#strict-mode))     *   Arrow functions: `this` is same as in surrounding scope (lexical `this`) *   Method call: `this` is receiver of call *   `new`: `this` refers to the newly created instance    We can also access `this` in all common top-level scopes:    *   `<script>` element: `this === globalThis` *   ECMAScript modules: `this === undefined` *   CommonJS modules: `this === module.exports`    ![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Tip: pretend that `this` doesn’t exist in top-level scopes**    I like to do that because top-level `this` is confusing and there are better alternatives for its (few) use cases.    ### [30.7 Optional chaining for property getting and method calls ^(ES2020) (advanced)](#optional-chaining)    The following kinds of optional chaining operations exist:    ``` obj?.prop     // optional fixed property getting obj?.[«expr»] // optional dynamic property getting func?.(«arg0», «arg1», ···) // optional function or method call  ```js    The rough idea is:    *   If the value before the question mark is neither `undefined` nor `null`, then perform the operation after the question mark. *   Otherwise, return `undefined`.    Each of the three syntaxes is covered in more detail later. These are a few first examples:    ``` > null?.prop undefined > {prop: 1}?.prop 1  `> null?.(123)` `undefined` `> String?.(123)` `'123'`  ```js   ``````js```````", "```````js```````", "`````` ![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Mnemonic for the optional chaining operator (`?.`)**    Are you occasionally unsure if the optional chaining operator starts with a dot (`.?`) or a question mark (`?.`)? Then this mnemonic may help you:    *   **If** (`?`) the left-hand side is not nullish *   **then** (`.`) access a property.    #### [30.7.1 Example: optional fixed property getting](#example-optional-fixed-property-getting)    Consider the following data:    ```js const persons = [  {  surname: 'Zoe',  address: {  street: {  name: 'Sesame Street',  number: '123',  },  },  },  {  surname: 'Mariner',  },  {  surname: 'Carmen',  address: {  },  }, ];  ```    We can use optional chaining to safely extract street names:    ```js const streetNames = persons.map(  p => p.address?.street?.name); assert.deepEqual(  streetNames, ['Sesame Street', undefined, undefined] );  ```    ##### [30.7.1.1 Handling defaults via nullish coalescing](#handling-defaults-via-nullish-coalescing)    The [nullish coalescing operator](ch_undefined-null.html#nullish-coalescing-operator) allows us to use the default value `'(no name)'` instead of `undefined`:    ```js const streetNames = persons.map(  p => p.address?.street?.name ?? '(no name)'); assert.deepEqual(  streetNames, ['Sesame Street', '(no name)', '(no name)'] );  ```    #### [30.7.2 The operators in more detail (advanced)](#the-operators-in-more-detail-advanced)    ##### [30.7.2.1 Optional fixed property getting](#optional-fixed-property-getting)    The following two expressions are equivalent:    ```js o?.prop (o !== undefined && o !== null) ? o.prop : undefined  ```    Examples:    ```js assert.equal(undefined?.prop, undefined); assert.equal(null?.prop,      undefined); assert.equal({prop:1}?.prop,  1);  ```    ##### [30.7.2.2 Optional dynamic property getting](#optional-dynamic-property-getting)    The following two expressions are equivalent:    ```js o?.[«expr»] (o !== undefined && o !== null) ? o[«expr»] : undefined  ```    Examples:    ```js const key = 'prop'; assert.equal(undefined?.[key], undefined); assert.equal(null?.[key], undefined); assert.equal({prop:1}?.[key], 1);  ```    ##### [30.7.2.3 Optional function or method call](#optional-function-or-method-call)    The following two expressions are equivalent:    ```js f?.(arg0, arg1) (f !== undefined && f !== null) ? f(arg0, arg1) : undefined  ```    Examples:    ```js assert.equal(undefined?.(123), undefined); assert.equal(null?.(123), undefined); assert.equal(String?.(123), '123');  ```    Note that this operator produces an error if its left-hand side is not callable:    ```js assert.throws(  () => true?.(123),  TypeError);  ```    Why? The idea is that the operator only tolerates deliberate omissions. An uncallable value (other than `undefined` and `null`) is probably an error and should be reported, rather than worked around.    #### [30.7.3 Short-circuiting with optional property getting](#shortcircuiting-with-optional-property-getting)    In a chain of property gettings and method invocations, evaluation stops once the first optional operator encounters `undefined` or `null` at its left-hand side:    ```js function invokeM(value) {  return value?.a.b.m(); // (A) }  `const obj = {`  `a: {`  `b: {`  `m() { return 'result' }`  `}`  `}` `};` `assert.equal(`  `invokeM(obj), 'result'` `);` `assert.equal(`  `invokeM(undefined), undefined // (B)` `);`  ```   ```js``````", "```````js```````", "```````js` Consider `invokeM(undefined)` in line B: `undefined?.a` is `undefined`. Therefore we’d expect `.b` to fail in line A. But it doesn’t: The `?.` operator encounters the value `undefined` and the evaluation of the whole expression immediately returns `undefined`.    This behavior differs from a normal operator where JavaScript always evaluates all operands before evaluating the operator. It is called *short-circuiting*. Other short-circuiting operators are:    *   `(a && b)`: `b` is only evaluated if `a` is truthy. *   `(a || b)`: `b` is only evaluated if `a` is falsy. *   `(c ? t : e)`: If `c` is truthy, `t` is evaluated. Otherwise, `e` is evaluated.    #### [30.7.4 Optional chaining: downsides and alternatives](#optional-chaining-downsides-and-alternatives)    Optional chaining also has downsides:    *   Deeply nested structures are more difficult to manage. For example, refactoring is harder if there are many sequences of property names: Each one enforces the structure of multiple objects. *   Being so forgiving when accessing data hides problems that will surface much later and are then harder to debug. For example, a typo early in a sequence of optional property names has more negative effects than a normal typo.    An alternative to optional chaining is to extract the information once, in a single location:    *   We can either write a helper function that extracts the data. *   Or we can write a function whose input is deeply nested data and whose output is simpler, normalized data.    With either approach, it is possible to perform checks and to fail early if there are problems.    Further reading:    *   “[Overly defensive programming](https://blog.vcarl.com/overly-defensive-programming/)” by Carl Vitullo    #### [30.7.5 Frequently asked questions](#frequently-asked-questions)    ##### [30.7.5.1 Why are there dots in `o?.[x]` and `f?.()`?](#why-are-there-dots-in-ox-and-f)    The syntaxes of the following two optional operator are not ideal:    ``` obj?.[«expr»]          // better: obj?[«expr»] func?.(«arg0», «arg1») // better: func?(«arg0», «arg1»)  ```js    Alas, the less elegant syntax is necessary because distinguishing the ideal syntax (first expression) from the conditional operator (second expression) is too complicated:    ``` obj?['a', 'b', 'c'].map(x => x+x) obj ? ['a', 'b', 'c'].map(x => x+x) : []  ```js    ##### [30.7.5.2 Why does `null?.prop` evaluate to `undefined` and not `null`?](#why-does-nullprop-evaluate-to-undefined-and-not-null)    The operator `?.` is mainly about its right-hand side: Does property `.prop` exist? If not, stop early. Therefore, keeping information about its left-hand side is rarely useful. However, only having a single “early termination” value does simplify things.    ### [30.8 Prototype chains](#prototype-chains)    Prototypes are JavaScript’s only inheritance mechanism: Each object has a prototype that is either `null` or an object. In the latter case, the object inherits all of the prototype’s properties.    In an object literal, we can set the prototype via the special property `__proto__`:    ``` const proto = {  protoProp: 'a', }; const obj = {  __proto__: proto,  objProp: 'b', };  `// obj inherits .protoProp:` `assert.equal(obj.protoProp, 'a');` `assert.equal('protoProp' in obj, true);`  ```js   ``````js```````", "```````js```````", "```` Given that a prototype object can have a prototype itself, we get a chain of objects – the so-called *prototype chain*. Inheritance gives us the impression that we are dealing with single objects, but we are actually dealing with chains of objects.    [Figure 30.2](#fig:oo_proto_chain) shows what the prototype chain of `obj` looks like.    ![](../Images/3f6a70b31e906acd64d926d104282b8f.png)      Figure 30.2: `obj` starts a chain of objects that continues with `proto` and other objects.      Non-inherited properties are called *own properties*. `obj` has one own property, `.objProp`.    #### [30.8.1 JavaScript’s operations: all properties vs. own properties](#javascripts-operations-all-properties-vs-own-properties)    Some operations consider all properties (own and inherited) – for example, getting properties:    ```js > const obj = { one: 1 }; > typeof obj.one // own 'number' > typeof obj.toString // inherited 'function'  ```    Other operations only consider own properties – for example, `Object.keys()`:    ```js > Object.keys(obj) [ 'one' ]  ```    Read on for another operation that also only considers own properties: setting properties.    #### [30.8.2 Pitfall: only the first member of a prototype chain is mutated](#pitfall-only-the-first-member-of-a-prototype-chain-is-mutated)    Given an object `obj` with a chain of prototype objects, it makes sense that setting an own property of `obj` only changes `obj`. However, setting an inherited property via `obj` also only changes `obj`. It creates a new own property in `obj` that overrides the inherited property. Let’s explore how that works with the following object:    ```js const proto = {  protoProp: 'a', }; const obj = {  __proto__: proto, };  ```    In the next code snippet, we set the inherited property `obj.protoProp` (line A). That “changes” it by creating an own property: When reading `obj.protoProp`, the own property is found first and its value *overrides* the value of the inherited property.    ```js // In the beginning, obj has no own properties assert.deepEqual(Object.keys(obj), []);  `obj.protoProp = 'x'; // (A)`  ````", "```js `// The inherited property itself is unchanged:` `assert.equal(proto.protoProp, 'a');`  `` `// The own property overrides the inherited property:` `assert.equal(obj.protoProp, 'x');` `` ```", "```js`  ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js     Object.getPrototypeOf(obj: object): object          ```", "```js     Object.create(proto: object): object          ```", "```js // Two objects with null prototypes const obj1 = {__proto__: null}; const obj2 = Object.create(null);  `assert.equal(`  `Object.getPrototypeOf(obj1), null` `);`  `` `const proto = {};` `Object.setPrototypeOf(obj1, proto);` `assert.equal(`  `Object.getPrototypeOf(obj1), proto` `);` ``  ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js``` ##### [30.8.3.2 Checking if an object is in the prototype chain of another object](#check-if-object-in-prototype-chain)    So far, “`proto` is a prototype of `obj`” always meant “`proto` is a *direct* prototype of `obj`”. But it can also be used more loosely and mean that `proto` is in the prototype chain of `obj`. That looser relationship can be checked via `.isPrototypeOf()`:    For example:    ``` const a = {}; const b = {__proto__: a}; const c = {__proto__: b};  `assert.equal(a.isPrototypeOf(b), true);` `assert.equal(a.isPrototypeOf(c), true);`  `` `assert.equal(c.isPrototypeOf(a), false);` `assert.equal(a.isPrototypeOf(a), false);` ``  ```js   ````", "```````js```````", "`````` ```js``````", "```````js```````", "``` const proto = {  protoProp: 'protoProp', }; const obj = {  __proto__: proto,  objProp: 'objProp', } assert.equal('protoProp' in obj, true); // (A) assert.equal(Object.hasOwn(obj, 'protoProp'), false); // (B) assert.equal(Object.hasOwn(proto, 'protoProp'), true); // (C)  ```", "``` const jane = {  firstName: 'Jane',  describe() {  return 'Person named '+this.firstName;  }, }; const tarzan = {  firstName: 'Tarzan',  describe() {  return 'Person named '+this.firstName;  }, };  `assert.equal(jane.describe(), 'Person named Jane');` `assert.equal(tarzan.describe(), 'Person named Tarzan');`  ```", "``````js``````", "```````js```` We have two objects that are very similar. Both have two properties whose names are `.firstName` and `.describe`. Additionally, method `.describe()` is the same. How can we avoid duplicating that method?    We can move it to an object `PersonProto` and make that object a prototype of both `jane` and `tarzan`:    ```js const PersonProto = {  describe() {  return 'Person named ' + this.firstName;  }, }; const jane = {  __proto__: PersonProto,  firstName: 'Jane', }; const tarzan = {  __proto__: PersonProto,  firstName: 'Tarzan', };  ```    The name of the prototype reflects that both `jane` and `tarzan` are persons.    ![](../Images/54ca73b37654dc412734fbf20bbd28dd.png)      Figure 30.4: Objects `jane` and `tarzan` share method `.describe()`, via their common prototype `PersonProto`.      [Figure 30.4](#fig:oo_person_shared) illustrates how the three objects are connected: The objects at the bottom now contain the properties that are specific to `jane` and `tarzan`. The object at the top contains the properties that are shared between them.    When we make the method call `jane.describe()`, `this` points to the receiver of that method call, `jane` (in the bottom-left corner of the diagram). That’s why the method still works. `tarzan.describe()` works similarly.    ```js assert.equal(jane.describe(), 'Person named Jane'); assert.equal(tarzan.describe(), 'Person named Tarzan');  ```    Looking ahead to the next chapter on classes – this is how classes are organized internally:    *   All instances share a common prototype with methods. *   Instance-specific data is stored in own properties in each instance.    [“The internals of classes” (§31.3)](ch_classes.html#internals-of-classes) explains this in more detail.    ### [30.9 Dictionary objects (advanced)](#dictionary-objects)    Objects work best as fixed-layout objects. But before ES6, JavaScript did not have a data structure for dictionaries (ES6 brought [Maps](ch_maps.html#ch_maps)). Therefore, objects had to be used as dictionaries, which imposed a signficant constraint: Dictionary keys had to be strings (symbols were also introduced with ES6).    We first look at features of objects that are related to dictionaries but also useful for fixed-layout objects. This section concludes with tips for actually using objects as dictionaries. (Spoiler: If possible, it’s better to use Maps.)    #### [30.9.1 Quoted keys in object literals](#object-literals-quoted-keys)    So far, we have always used fixed-layout objects. Property keys were fixed tokens that had to be valid identifiers and internally became strings:    ```js const obj = {  mustBeAnIdentifier: 123, };  `// Get property` `assert.equal(obj.mustBeAnIdentifier, 123);`  `` `// Set property` `obj.mustBeAnIdentifier = 'abc';` `assert.equal(obj.mustBeAnIdentifier, 'abc');` ``  ```   ```js```````", "```````js`````` ```js```````", "```````js````` As a next step, we’ll go beyond this limitation for property keys: In this subsection, we’ll use arbitrary fixed strings as keys. In the next subsection, we’ll dynamically compute keys.    Two syntaxes enable us to use arbitrary strings as property keys.    First, when creating property keys via object literals, we can quote property keys (with single or double quotes):    ```js const obj = {  'Can be any string!': 123, };  ```    Second, when getting or setting properties, we can use square brackets with strings inside them:    ```js // Get property assert.equal(obj['Can be any string!'], 123);  `// Set property` `obj['Can be any string!'] = 'abc';` `assert.equal(obj['Can be any string!'], 'abc');`  ```   ```js```````", "```````js```` We can also use these syntaxes for methods:    ```js const obj = {  'A nice method'() {  return 'Yes!';  }, };  `assert.equal(obj['A nice method'](), 'Yes!');`  ```   ```js```````", "```````js``` #### [30.9.2 Computed keys in object literals](#object-literals-computed-keys)    In the previous subsection, property keys were specified via fixed strings inside object literals. In this section we learn how to dynamically compute property keys. That enables us to use either arbitrary strings or symbols.    The syntax of dynamically computed property keys in object literals is inspired by dynamically accessing properties. That is, we can use square brackets to wrap expressions:    ``` const obj = {  ['Hello world!']: true,  ['p'+'r'+'o'+'p']: 123,  [Symbol.toStringTag]: 'Goodbye', // (A) };  `assert.equal(obj['Hello world!'], true);` `assert.equal(obj.prop, 123);` `assert.equal(obj[Symbol.toStringTag], 'Goodbye');`  ```js   ``````js```````", "`````` The main use case for computed keys is having symbols as property keys (line A).    Note that the square brackets operator for getting and setting properties works with arbitrary expressions:    ```js assert.equal(obj['p'+'r'+'o'+'p'], 123); assert.equal(obj['==> prop'.slice(4)], 123);  ```    Methods can have computed property keys, too:    ```js const methodKey = Symbol(); const obj = {  [methodKey]() {  return 'Yes!';  }, };  `assert.equal(obj[methodKey](), 'Yes!');`  ```   ```js``````", "```````js` For the remainder of this chapter, we’ll mostly use fixed property keys again (because they are syntactically more convenient). But all features are also available for arbitrary strings and symbols.    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Non-destructively updating a property via spreading (computed key)**    `exercises/objects/update_property_test.mjs`    #### [30.9.3 The `in` operator: is there a property with a given key?](#in-operator)    The `in` operator checks if an object has a property with a given key:    ``` const obj = {  alpha: 'abc',  beta: false, };  `assert.equal('alpha' in obj, true);` `assert.equal('beta' in obj, true);` `assert.equal('unknownKey' in obj, false);`  ```js   ``````js```````", "```` ##### [30.9.3.1 Checking if a property exists via truthiness](#checking-if-a-property-exists-via-truthiness)    We can also use a truthiness check to determine if a property exists:    ```js assert.equal(  obj.alpha ? 'exists' : 'does not exist',  'exists'); assert.equal(  obj.unknownKey ? 'exists' : 'does not exist',  'does not exist');  ```    The previous checks work because `obj.alpha` is truthy and because reading a missing property returns `undefined` (which is falsy).    There is, however, one important caveat: truthiness checks fail if the property exists, but has a falsy value (`undefined`, `null`, `false`, `0`, `\"\"`, etc.):    ```js assert.equal(  obj.beta ? 'exists' : 'does not exist',  'does not exist'); // should be: 'exists'  ```    #### [30.9.4 Deleting properties](#deleting-properties)    We can delete properties via the `delete` operator:    ```js const obj = {  myProp: 123, };  `assert.deepEqual(Object.keys(obj), ['myProp']);` `delete obj.myProp;` `assert.deepEqual(Object.keys(obj), []);`  ```   ```js````", "```js```", "``` #### [30.9.5 Enumerability](#enumerability)    *Enumerability* is an [*attribute*](#property-attributes-property-descriptors) of a property. Non-enumerable properties are ignored by some operations – for example, by `Object.keys()` and when spreading properties. By default, most properties are enumerable. The next example shows how to change that and how it affects spreading.    ```", "``` `// For non-enumerable properties, we need a more powerful tool` `Object.defineProperties(obj, {`  `nonEnumStringKey: {`  `value: 3,`  `enumerable: false,`  `},`  `[nonEnumSymbolKey]: {`  `value: 4,`  `enumerable: false,`  `},` `});`  `` `// Non-enumerable properties are ignored by spreading:` `assert.deepEqual(`  `{...obj},`  `{`  `enumerableStringKey: 1,`  `[enumerableSymbolKey]: 2,`  `}` `);` `` ```", "```   ```", "```````js````` ```js```````", "```` `Object.defineProperties()` is explained [later in this chapter](#property-attributes-property-descriptors). The next subsection shows how these operations are affected by enumerability:    #### [30.9.6 Listing property keys via `Object.keys()` etc.](#listing-property-keys)     |  | enumerable | non-e. | string | symbol | | --- | --- | --- | --- | --- | | `Object.keys()` | ✔ |  | ✔ |  | | `Object.getOwnPropertyNames()` | ✔ | ✔ | ✔ |  | | `Object.getOwnPropertySymbols()` | ✔ | ✔ |  | ✔ | | `Reflect.ownKeys()` | ✔ | ✔ | ✔ | ✔ |      Table 30.1: Standard library methods for listing *own* (non-inherited) property keys. All of them return Arrays with strings and/or symbols.      Each of the methods in [table 30.1](#tbl:listing-property-keys) returns an Array with the own property keys of the parameter. In the names of the methods, we can see that the following distinction is made:    *   A *property key* can be either a string or a symbol. (`Object.keys()` is older and does not yet follow this convention.) *   A *property name* is a property key whose value is a string. *   A *property symbol* is a property key whose value is a symbol.    To demonstrate the four operations, we revisit the example from the previous subsection:    ```js const enumerableSymbolKey = Symbol('enumerableSymbolKey'); const nonEnumSymbolKey = Symbol('nonEnumSymbolKey');  `const obj = {`  `enumerableStringKey: 1,`  `[enumerableSymbolKey]: 2,` `}` `Object.defineProperties(obj, {`  `nonEnumStringKey: {`  `value: 3,`  `enumerable: false,`  `},`  `[nonEnumSymbolKey]: {`  `value: 4,`  `enumerable: false,`  `},` `});`  `` `assert.deepEqual(`  `Object.keys(obj),`  `['enumerableStringKey']` `);` `assert.deepEqual(`  `Object.getOwnPropertyNames(obj),`  `['enumerableStringKey', 'nonEnumStringKey']` `);` `assert.deepEqual(`  `Object.getOwnPropertySymbols(obj),`  `[enumerableSymbolKey, nonEnumSymbolKey]` `);` `assert.deepEqual(`  `Reflect.ownKeys(obj),`  `[`  `'enumerableStringKey', 'nonEnumStringKey',`  `enumerableSymbolKey, nonEnumSymbolKey,`  `]` `);` ``  ```   ```js````", "```js```", "``````js``````", "```js const firstName = Symbol('firstName'); const obj = {  [firstName]: 'Jane',  lastName: 'Doe', }; assert.deepEqual(  Object.values(obj),  ['Doe']);  ```", "```js const firstName = Symbol('firstName'); const obj = {  [firstName]: 'Jane',  lastName: 'Doe', }; Object.defineProperty(  obj, 'city', {value: 'Metropolis', enumerable: false} ); assert.deepEqual(  Object.entries(obj),  [  ['lastName', 'Doe'],  ]);  ```", "```js function entries(obj) {  return Object.keys(obj)  .map(key => [key, obj[key]]); }  ```", "```js const obj = {  b: true,  a: true,  10: true,  2: true, }; assert.deepEqual(  Object.keys(obj),  ['2', '10', 'b', 'a'] );  ```", "```js const symbolKey = Symbol('symbolKey'); assert.deepEqual(  Object.fromEntries(  [  ['stringKey', 1],  [symbolKey, 2],  ]  ),  {  stringKey: 1,  [symbolKey]: 2,  } );  ```", "```js pick(object, ...keys)  ```", "```js const address = {  street: 'Evergreen Terrace',  number: '742',  city: 'Springfield',  state: 'NT',  zip: '49007', }; assert.deepEqual(  pick(address, 'street', 'number'),  {  street: 'Evergreen Terrace',  number: '742',  } );  ```", "```js function pick(object, ...keys) {  const filteredEntries = Object.entries(object)  .filter(([key, _value]) => keys.includes(key));  return Object.fromEntries(filteredEntries); }  ```", "```js invert(object)  ```", "```js assert.deepEqual(  invert({a: 1, b: 2, c: 3}),  {1: 'a', 2: 'b', 3: 'c'} );  ```", "```js function invert(object) {  const reversedEntries = Object.entries(object)  .map(([key, value]) => [value, key]);  return Object.fromEntries(reversedEntries); }  ```", "```js function fromEntries(iterable) {  const result = {};  for (const [key, value] of iterable) {  let coercedKey;  if (typeof key === 'string' || typeof key === 'symbol') {  coercedKey = key;  } else {  coercedKey = String(key);  }  result[coercedKey] = value;  }  return result; }  ```", "```js const dict = {}; assert.equal(  typeof dict['toString'], 'function' );  ```", "```js const dict = {}; assert.equal(  'toString' in dict, true );  ```", "```js const dict = {}; assert.equal(  Object.hasOwn(dict, 'toString'), false );  ```", "```js const dict = {};  `dict['__proto__'] = 123;` `// No property was added to dict:` `assert.deepEqual(`  `Object.keys(dict), []` `);`  ```", "```js```", "````js` ##### [30.9.11.4 Objects with `null` prototypes as dictionaries](#dictionary-objects-with-null-prototypes)    Maps are usually the best choice when it comes to dictionaries: They have a convenient method-based API and support keys beyond strings and symbols.    However, objects with `null` prototypes are also decent dictionaries and don’t have the pitfalls we just encountered:    ``` const dict = Object.create(null);  `// No inherited properties` `assert.equal(`  `dict['toString'], undefined` `);` `assert.equal(`  `'toString' in dict, false` `);`  `` `// No special behavior with key '__proto__'` `dict['__proto__'] = true;` `assert.deepEqual(`  `Object.keys(dict), ['__proto__']` `);` ``  ```js   ````", "```` ```js````", "```js const htmlToLatex = {  __proto__: null,  'i': 'textit',  'b': 'textbf',  'u': 'underline', };  ```", "```js     assert.equal(      Object.getPrototypeOf(import.meta), null     );          ```", "```js     const grouped = Object.groupBy([], x => x);     assert.equal(      Object.getPrototypeOf(grouped), null     );          ```", "```js     const matchObj = /(?<group>x)/.exec('x');     assert.equal(      Object.getPrototypeOf(matchObj.groups), null     );          ```", "```js const obj = { myProp: 123 }; assert.deepEqual(  Object.getOwnPropertyDescriptor(obj, 'myProp'),  {  value: 123,  writable: true,  enumerable: true,  configurable: true,  });  ```", "```js assert.deepEqual(Object.keys(obj), ['myProp']);  ``// Hide property `myProp` from Object.keys()`` `// by making it non-enumerable` `Object.defineProperty(obj, 'myProp', {`  `enumerable: false,` `});`  `` `assert.deepEqual(Object.keys(obj), []);` ``  ```", "```js```", "```js```", "```js const obj = {  myMethod() {},  get myGetter() {}, }; const propDescs = Object.getOwnPropertyDescriptors(obj); propDescs.myMethod.value = typeof propDescs.myMethod.value; propDescs.myGetter.get = typeof propDescs.myGetter.get; assert.deepEqual(  propDescs,  {  myMethod: {  value: 'function',  writable: true,  enumerable: true,  configurable: true  },  myGetter: {  get: 'function',  set: undefined,  enumerable: true,  configurable: true  }  } );  ```", "```js const frozen = Object.freeze({ x: 2, y: 5 }); assert.throws(  () => frozen.x = 7,  {  name: 'TypeError',  message: /^Cannot assign to read only property 'x'/,  } );  ```", "```js     > const obj = Object.create(null);     > Object.getPrototypeOf(obj)     null          ```", "```js     const obj = Object.create(      null,      {      color: {      value: 'green',      writable: true,      enumerable: true,      configurable: true,      },      }     );     assert.deepEqual(      obj,      {      __proto__: null,      color: 'green',      }     );          ```", "```js     assert.equal(      Object.getPrototypeOf({__proto__: null}), null     );     assert.equal(      Object.getPrototypeOf({}), Object.prototype     );     assert.equal(      Object.getPrototypeOf(Object.prototype), null     );          ```", "```js     const obj = {};     assert.equal(      Object.getPrototypeOf(obj), Object.prototype     );     Object.setPrototypeOf(obj, null);     assert.equal(      Object.getPrototypeOf(obj), null     );          ```", "```js     const obj = {};     Object.defineProperty(      obj, 'color',      {      value: 'green',      writable: true,      enumerable: true,      configurable: true,      }     );     assert.deepEqual(      obj,      {      color: 'green',      }     );          ```", "```js     const obj = {};     Object.defineProperties(      obj,      {      color: {      value: 'green',      writable: true,      enumerable: true,      configurable: true,      },      }     );     assert.deepEqual(      obj,      {      color: 'green',      }     );          ```", "```js     > Object.getOwnPropertyDescriptor({a: 1, b: 2}, 'a')     { value: 1, writable: true, enumerable: true, configurable: true }     > Object.getOwnPropertyDescriptor({a: 1, b: 2}, 'x')     undefined          ```", "```js     > Object.getOwnPropertyDescriptors({a: 1, b: 2})     {      a: { value: 1, writable: true, enumerable: true, configurable: true },      b: { value: 2, writable: true, enumerable: true, configurable: true },     }          ```", "```js     const enumSymbolKey = Symbol('enumSymbolKey');     const nonEnumSymbolKey = Symbol('nonEnumSymbolKey');      `const obj = Object.defineProperties(`      `{},`      `{`      `enumStringKey: {`      `value: 1, enumerable: true,`      `},`      `[enumSymbolKey]: {`      `value: 2, enumerable: true,`      `},`      `nonEnumStringKey: {`      `value: 3, enumerable: false,`      `},`      `[nonEnumSymbolKey]: {`      `value: 4, enumerable: false,`      `},`      `}`     `);`     `assert.deepEqual(`      `Object.keys(obj),`      `['enumStringKey']`     `);`      ```", "```js```", "```     const enumSymbolKey = Symbol('enumSymbolKey');     const nonEnumSymbolKey = Symbol('nonEnumSymbolKey');      `const obj = Object.defineProperties(`      `{},`      `{`      `enumStringKey: {`      `value: 1, enumerable: true,`      `},`      `[enumSymbolKey]: {`      `value: 2, enumerable: true,`      `},`      `nonEnumStringKey: {`      `value: 3, enumerable: false,`      `},`      `[nonEnumSymbolKey]: {`      `value: 4, enumerable: false,`      `},`      `}`     `);`     `assert.deepEqual(`      `Object.getOwnPropertyNames(obj),`      `['enumStringKey', 'nonEnumStringKey']`     `);`      ```", "````` *   `Object.getOwnPropertySymbols(obj)` ES6                    Returns an Array with all own property keys that are symbols (enumerable and non-enumerable ones).                    ```js     const enumSymbolKey = Symbol('enumSymbolKey');     const nonEnumSymbolKey = Symbol('nonEnumSymbolKey');      `const obj = Object.defineProperties(`      `{},`      `{`      `enumStringKey: {`      `value: 1, enumerable: true,`      `},`      `[enumSymbolKey]: {`      `value: 2, enumerable: true,`      `},`      `nonEnumStringKey: {`      `value: 3, enumerable: false,`      `},`      `[nonEnumSymbolKey]: {`      `value: 4, enumerable: false,`      `},`      `}`     `);`     `assert.deepEqual(`      `Object.getOwnPropertySymbols(obj),`      `[enumSymbolKey, nonEnumSymbolKey]`     `);`      ```          ```js` *   `Object.values(obj)` ES2017                    Returns an Array with the values of all enumerable own string-keyed properties.                    ```     > Object.values({a: 1, b: 2})     [ 1, 2 ]          ```js          *   `Object.entries(obj)` ES2017               *   Returns an Array with one key-value pair (encoded as a two-element Array) per property of `obj`.     *   Only own enumerable properties with string keys are included.     *   Inverse operation: [`Object.fromEntries()`](#qref-Object.fromEntries)          ```     const obj = {      a: 1,      b: 2,      [Symbol('myKey')]: 3,     };     assert.deepEqual(      Object.entries(obj),      [      ['a', 1],      ['b', 2],      // Property with symbol key is ignored      ]     );          ```js          *   `Object.fromEntries(keyValueIterable)` ES2019               *   Creates an object whose own properties are specified by `keyValueIterable`.     *   Inverse operation: [`Object.entries()`](#qref-Object.entries)          ```     > Object.fromEntries([['a', 1], ['b', 2]])     { a: 1, b: 2 }          ```js          *   `Object.hasOwn(obj, key)` ES2022               *   Returns `true` if `obj` has an own property whose key is `key`. If not, it returns `false`.          ```     > Object.hasOwn({a: 1, b: 2}, 'a')     true     > Object.hasOwn({a: 1, b: 2}, 'x')     false          ```js ```` ```js`` `````", "``````js ````` #### [30.12.4 `Object.*`: protecting objects](#object-protecting-objects)    More information: [“Protecting objects from being changed ^(ES5) (advanced)” (§30.11)](#protecting-objects)    *   `Object.preventExtensions(obj)` ES5               *   Makes `obj` non-extensible and returns it.     *   Effect:         *   `obj` is non-extensible: We can’t add properties or change its prototype.     *   Only the top level of `obj` is changed (shallow change). Nested objects are not affected.     *   Related: [`Object.isExtensible()`](#qref-Object.isExtensible) *   `Object.isExtensible(obj)` ES5               *   Returns `true` if `obj` is extensible and `false` if it isn’t.     *   Related: [`Object.preventExtensions()`](#qref-Object.preventExtensions) *   `Object.seal(obj)` ES5               *   Seals `obj` and returns it.     *   Effect:         *   `obj` is non-extensible: We can’t add properties or change its prototype.         *   `obj` is sealed: Additionally, all of its properties are unconfigurable.     *   Only the top level of `obj` is changed (shallow change). Nested objects are not affected.     *   Related: [`Object.isSealed()`](#qref-Object.isSealed) *   `Object.isSealed(obj)` ES5               *   Returns `true` if `obj` is sealed and `false` if it isn’t.     *   Related: [`Object.seal()`](#qref-Object.seal) *   `Object.freeze(obj)` ES5               *   Freezes `obj` and returns it.     *   Effect:         *   `obj` is non-extensible: We can’t add properties or change its prototype.         *   `obj` is sealed: Additionally, all of its properties are unconfigurable.         *   `obj` is frozen: Additionally, all of its properties are non-writable.     *   Only the top level of `obj` is changed (shallow change). Nested objects are not affected.     *   Related: [`Object.isFrozen()`](#qref-Object.isFrozen)          ```js     const frozen = Object.freeze({ x: 2, y: 5 });     assert.equal(      Object.isFrozen(frozen), true     );     assert.throws(      () => frozen.x = 7,      {      name: 'TypeError',      message: /^Cannot assign to read only property 'x'/,      }     );          ```           *   `Object.isFrozen(obj)` ES5               *   Returns `true` if `obj` is frozen.     *   Related: [`Object.freeze()`](#qref-Object.freeze)    #### [30.12.5 `Object.*`: miscellaneous](#object-miscellaneous)    *   `Object.assign(target, ...sources)` ES6                    Assigns all enumerable own string-keyed properties of each of the `sources` to `target` and returns `target`.                    ```js     > const obj = {a: 1, b: 1};     > Object.assign(obj, {b: 2, c: 2}, {d: 3})     { a: 1, b: 2, c: 2, d: 3 }     > obj     { a: 1, b: 2, c: 2, d: 3 }          ```           *   `Object.groupBy(items, computeGroupKey)` ES2024                    ```js     Object.groupBy<K extends PropertyKey, T>(      items: Iterable<T>,      computeGroupKey: (item: T, index: number) => K,     ): {[key: K]: Array<T>}          ```               *   The callback `computeGroupKey` returns a *group key* for each of the `items`.     *   The result of `Object.groupBy()` is an object where:         *   The key of each property is a group key and         *   its value is an Array with all items that have that group key.          ```js     assert.deepEqual(      Object.groupBy(      ['orange', 'apricot', 'banana', 'apple', 'blueberry'],      (str) => str[0] // compute group key      ),      {      __proto__: null,      'o': ['orange'],      'a': ['apricot', 'apple'],      'b': ['banana', 'blueberry'],      }     );          ```           *   `Object.is(value1, value2)` ES6                    Is mostly equivalent to `value1 === value2` – with two exceptions:                    ```js     > NaN === NaN     false     > Object.is(NaN, NaN)     true      `> -0 === 0`     `true`     `> Object.is(-0, 0)`     `false`      ```           ``*   Considering all `NaN` values to be equal can be useful – e.g., when searching for a value in an Array. *   The value `-0` is rare and it’s usually best to pretend it is the same as `0`.``     ```js`#### [30.12.6 `Object.prototype.*`](#objectprototype)    `Object.prototype` has the following properties:    *   `Object.prototype.__proto__` (getter and setter) *   `Object.prototype.hasOwnProperty()` *   `Object.prototype.isPrototypeOf()` *   `Object.prototype.propertyIsEnumerable()` *   `Object.prototype.toLocaleString()` *   `Object.prototype.toString()` *   `Object.prototype.valueOf()`    These methods are explained in detail in [“Quick reference: `Object.prototype.*`” (§31.10)](ch_classes.html#quickref-object-prototype).    ### [30.13 Quick reference: `Reflect`](#quickref-reflect)    `Reflect` provides functionality for [JavaScript proxies](https://exploringjs.com/deep-js/ch_proxies.html) that is also occasionally useful elsewhere:    *   `Reflect.apply(target, thisArgument, argumentsList)` ES6               *   Invokes `target` with the arguments provided by `argumentsList` and `this` set to `thisArgument`.     *   Equivalent to `target.apply(thisArgument, argumentsList)` *   `Reflect.construct(target, argumentsList, newTarget=target)` ES6               *   The `new` operator as a function.     *   `target` is the constructor to invoke.     *   The optional parameter `newTarget` points to the constructor that started the current chain of constructor calls. *   `Reflect.defineProperty(target, propertyKey, propDesc)` ES6               *   Similar to `Object.defineProperty()`.     *   Returns a boolean indicating whether or not the operation succeeded. *   `Reflect.deleteProperty(target, propertyKey)` ES6                    The `delete` operator as a function. It works slightly differently, though:               *   It returns `true` if it successfully deleted the property or if the property never existed.     *   It returns `false` if the property could not be deleted and still exists.          In sloppy mode, the `delete` operator returns the same results as this method. But in strict mode, it throws a `TypeError` instead of returning `false`.                    The only way to protect properties from deletion is by making them non-configurable.           *   `Reflect.get(target, propertyKey, receiver=target)` ES6                    A function that gets properties. The optional parameter `receiver` is needed if `get` reaches a getter (somewhere in the prototype chain). Then it provides the value for `this`.           *   `Reflect.getOwnPropertyDescriptor(target, propertyKey)` ES6                    Same as `Object.getOwnPropertyDescriptor()`.           *   `Reflect.getPrototypeOf(target)` ES6                    Same as `Object.getPrototypeOf()`.           *   `Reflect.has(target, propertyKey)` ES6                    The `in` operator as a function.           *   `Reflect.isExtensible(target)` ES6                    Same as `Object.isExtensible()`.           *   `Reflect.ownKeys(target)` ES6                    Returns all own property keys (strings and symbols) in an Array.           *   `Reflect.preventExtensions(target)` ES6               *   Similar to `Object.preventExtensions()`.     *   Returns a boolean indicating whether or not the operation succeeded. *   `Reflect.set(target, propertyKey, value, receiver=target)` ES6               *   Sets properties.     *   Returns a boolean indicating whether or not the operation succeeded. *   `Reflect.setPrototypeOf(target, proto)` ES6               *   Same as `Object.setPrototypeOf()`.     *   Returns a boolean indicating whether or not the operation succeeded.    #### [30.13.1 `Reflect.*` vs. `Object.*`](#reflect-vs-object)    General recommendations:    *   Use `Object.*` whenever you can. *   Use `Reflect.*` when working with [ECMAScript proxies](https://exploringjs.com/deep-js/ch_proxies.html). Its methods are well adapted to ECMAScript’s meta-object protocol (MOP) which also return boolean error flags instead of exceptions.    What are use cases for `Reflect` beyond proxies?    *   `Reflect.ownKeys()` lists all own property keys – functionality that isn’t provided anywhere else.           *   Same functionality as `Object` but different return values: `Reflect` duplicates the following methods of `Object`, but its methods return booleans indicating whether the operation succeeded (where the `Object` methods return the object that was modified).               *   `Object.defineProperty(obj, propKey, propDesc)`     *   `Object.preventExtensions(obj)`     *   `Object.setPrototypeOf(obj, proto)` *   Operators as functions: The following `Reflect` methods implement functionality that is otherwise only available via operators:               *   `Reflect.construct(target, argumentsList, newTarget=target)`     *   `Reflect.deleteProperty(target, propertyKey)`     *   `Reflect.get(target, propertyKey, receiver=target)`     *   `Reflect.has(target, propertyKey)`     *   `Reflect.set(target, propertyKey, value, receiver=target)` *   Shorter version of `apply()`: If we want to be completely safe about invoking the method `apply()` on a function, we can’t do so via dynamic dispatch, because the function may have an own property with the key `'apply'`:                    ```     func.apply(thisArg, argArray) // not safe     Function.prototype.apply.call(func, thisArg, argArray) // safe          ```js                    Using `Reflect.apply()` is shorter:                    ```     Reflect.apply(func, thisArg, argArray)          ```js           *   No exceptions when deleting properties: the `delete` operator throws in strict mode if we try to delete a non-configurable own property. `Reflect.deleteProperty()` returns `false` in that case.```` ```js`` ``````", "``````js` ``````", "``````js``` ``````", "```` ```js````", "```js` ```", "```js```", "``` ```", "```````js``` ``````js```````", "``````js``````", "``````js``````", "``` ```", "```js```", "````js````", "```js```", "````js````", "```js` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "``````js``````", "```````js` ``````js```````", "```````js`` ``````js```````", "```````js``` ``````js```````", "```````js```` ```js```````", "```````js```````", "``````js``````", "```````js`````` ```js```````", "```````js```````", "``` ```", "```js```", "````js````", "```js```", "````js` ````", "```````js```````", "```````js`` ``````js```````", "```````js```````", "``` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "``````js``````", "```````js```````", "```````js` ``````js```````", "```````js```````", "```````js`` ``````js```````", "```````js```````", "```````js``` ``````js```````", "```````js```````", "```````js```` ```js```````", "```````js```````", "```````js```````", "``````js``````", "```````js```````", "```````js`````` ```js```````", "```````js```````", "```````js```````", "``` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js` ````", "```````js```````", "```````js```````", "```````js`` ``````js```````", "```````js```````", "```````js```````", "``` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "``````js``````", "```````js```````", "```````js```````", "```````js` ``````js```````", "```````js```````", "```````js```````", "```````js`` ``````js```````", "```````js```````", "```````js```````", "```````js``` ``````js```````", "```````js```````", "```````js```````", "```````js```` ```js```````", "```````js```````", "```````js```````", "```````js```````", "``````js``````", "```````js```````", "```````js```````", "```````js``````"]