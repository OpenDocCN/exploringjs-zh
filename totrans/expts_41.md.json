["```ts\ntype Result = Uppercase<'hello'>;\ntype _ = Assert<Equal<\n Result, 'HELLO'\n>>;\n\n```", "```ts\nconst result = 'hello'.toUpperCase();\nassert.equal(\n result, 'HELLO'\n);\n\n```", "```ts\ntype BooleanLiteralType = true;\ntype NumberLiteralType = 12.34;\ntype BigIntLiteralType = 1234n;\ntype StringLiteralType = 'abc';\n\n```", "```ts\ntype InstantiatedGenericType = Array<number>;\n\ntype TupleType = [boolean, bigint];\n\ntype ObjectLiteralType = {\n prop1: string,\n prop2: number,\n};\n\n```", "```ts\ntype Person = {\n givenName: string,\n familyName: string,\n};\ntype _ = Assert<Equal<\n keyof Person,\n 'givenName' | 'familyName'\n>>;\n\n```", "```ts\ntype Pair<T> = [T, T]; // (A)\ntype Result = Pair<'abc'>; // (B)\ntype _ = Assert<Equal<\n Result, ['abc', 'abc']\n>>;\n\n```", "```ts\nconst pair = (x) => [x, x];\nconst result = pair('abc');\nassert.deepEqual(\n result, ['abc', 'abc']\n);\n\n```", "```ts\ntype Pair<T> = [T, T];\n\n```", "```ts\nlet v1: number;\nlet v2: Pair<3>;\n\n```", "```ts\ntype Pair<T='hello'> = [T, T];\ntype _ = Assert<Equal<\n Pair,\n ['hello', 'hello']\n>>;\n\n```", "```ts\ntype NumberPair<T extends number> = [T, T];\n\ntype P1 = NumberPair<123>; // OK\ntype P2 = NumberPair<number>; // OK\n\n// @ts-expect-error: Type 'string' does not satisfy the constraint 'number'.\ntype P3 = NumberPair<'abc'>;\n\n```", "```ts\ntype NumberPair<T extends number> = [T, T];\nconst numberPair = (x: number) => [x, x];\n\n```", "```ts\ntype NumberPair<T extends number = 0> = [T, T];\ntype _ = Assert<Equal<\n NumberPair,\n [0, 0]\n>>;\n\n```", "```ts\nlet programLevelVariable = 'abc';\n\n// The right-hand side of `=` is a type expression\ntype TypeLevelType = Array<typeof programLevelVariable>;\ntype _ = Assert<Equal<\n TypeLevelType,\n Array<string>\n>>;\n\n```", "```ts\nassert.equal(\n typeof 'abc',\n 'string'\n);\nassert.equal(\n typeof 123,\n 'number'\n);\n\n```", "```ts\nconst robin = {\n givenName: 'Robin',\n familyName: 'Doe',\n};\ntype _ = Assert<Equal<\n typeof robin,\n {\n givenName: string;\n familyName: string;\n }\n>>;\n\n```", "```ts\nconst article = {\n tags: ['dev', 'typescript'],\n};\ntype _ = [\n Assert<Equal<\n typeof article,\n {\n tags: string[];\n }\n >>,\n Assert<Equal<\n typeof article.tags,\n string[]\n >>,\n Assert<Equal<\n typeof article.tags[0],\n string\n >>,\n];\n\n```", "```ts\ntype _ = typeof 'abc';\n // Error: Identifier expected.\n\n```", "```ts\ntype Obj = {\n prop1: 'a',\n prop2: 'b',\n};\n\ntype _ = Assert<Equal<\n keyof Obj,\n 'prop1' | 'prop2'\n>>;\n\n```", "```ts\ntype _ = Assert<Equal<\n keyof {},\n never\n>>;\n\n```", "```ts\n> Object.keys({0: 'a', 1: 'b'})\n[ '0', '1' ]\n> Object.keys({'0': 'a', '1': 'b'})\n[ '0', '1' ]\n\n```", "```ts\n> Object.keys(['a', 'b'])\n[ '0', '1' ]\n\n```", "```ts\ntype _ = Assert<Equal<\n keyof {0: 'a', '1': 'b'},\n 0 | '1'\n>>;\n\n```", "```ts\nconst obj = {0: 'a', '1': 'b'};\ntype _ = Assert<Equal<\n keyof typeof obj,\n 0 | '1'\n>>;\n\n```", "```ts\ntype _ = Assert<Includes<\n keyof Array<string>,\n number // type for all indices\n>>;\n\n```", "```ts\ntype NumberIndexSignature = {\n [k: number]: unknown,\n};\ntype _ = Assert<Equal<\n keyof NumberIndexSignature,\n number\n>>;\n\n```", "```ts\ntype StringIndexSignature = {\n [k: string]: unknown,\n};\ntype _ = Assert<Equal<\n keyof StringIndexSignature,\n string | number\n>>;\n\n```", "```ts\ntype _ = Assert<Includes<\n keyof Array<string>,\n number | 'length' | 'push' | 'join'\n>>;\n\n```", "```ts\ntype _ = Assert<Includes<\n keyof ['a', 'b'],\n number | '0' | '1' | 'length' | 'push' | 'join'\n>>;\n\n```", "```ts\ntype A = { a: number, shared: string };\ntype B = { b: number, shared: string };\n\ntype _1 = Assert<Equal<\n keyof (A & B),\n 'a' | 'b' | 'shared'\n>>;\n\ntype _2 = Assert<Equal<\n keyof (A | B),\n 'shared'\n>>;\n\n```", "```ts\ntype Obj = {\n 0: 'a',\n 1: 'b',\n prop0: 'c',\n prop1: 'd',\n [Symbol.iterator]: 'e',\n};\n\ntype _ = [\n Assert<Equal<\n Obj[0 | 1],\n 'a' | 'b'\n >>,\n // The stringified versions of number keys work the same\n Assert<Equal<\n Obj['0' | '1'],\n 'a' | 'b'\n >>,\n Assert<Equal<\n Obj['prop0' | 'prop1'],\n 'c' | 'd'\n >>,\n Assert<Equal<\n Obj[keyof Obj],\n 'a' | 'b' | 'c' | 'd' | 'e'\n >>,\n // - Symbol.iterator is a value (program level).\n // - typeof Symbol.iterator is a type (type level).\n Assert<Equal<\n Obj[typeof Symbol.iterator],\n 'e'\n >>,\n];\n\n```", "```ts\ntype Obj = {prop: 'yes'};\ntype _ = [\n // @ts-expect-error: Type 'Obj' has no matching index signature for type\n // 'string'.\n Obj[string],\n // @ts-expect-error: Type 'Obj' has no matching index signature for type\n // 'number'.\n Obj[number],\n];\n\n```", "```ts\ntype Obj = {\n [key: string]: RegExp, // (A)\n};\ntype _ = [\n Assert<Equal<\n keyof Obj, // (B)\n string | number\n >>,\n Assert<Equal<\n Obj[string],\n RegExp\n >>,\n Assert<Equal<\n Obj[number],\n RegExp\n >>,\n];\n\n```", "```ts\ntype Tuple = ['a', 'b', 'c'];\ntype _ = [\n Assert<Equal<\n Tuple[0 | 1],\n 'a' | 'b'\n >>,\n Assert<Equal<\n Tuple['0' | '1'],\n 'a' | 'b'\n >>,\n Assert<Equal<\n Tuple[number],\n 'a' | 'b' | 'c'\n >>,\n];\n\n```", "```ts\ntype ValueOf<T> = T[keyof T];\n\ntype Obj = { a: string, b: number };\ntype _ = Assert<Equal<\n ValueOf<Obj>,\n string | number\n>>;\n\n```", "```ts\nfunction get<O, K extends keyof O>(obj: O, key: K): O[K] {\n return obj[key];\n}\nconst obj = {\n a: 1,\n b: 2,\n};\nconst result = get(obj, 'a');\nassert.equal(result, 1);\nassertType<number>(result);\n\n```", "```ts\n// @ts-expect-error: Argument of type '\"aaa\"' is not assignable to\n// parameter of type '\"a\" | \"b\"'.\nget(obj, 'aaa');\n\n```", "```ts\ntype TypeofLookupTable = {\n 'undefined': undefined,\n 'boolean': boolean,\n 'number': number,\n 'bigint': bigint,\n 'string': string,\n 'symbol': symbol,\n 'object': null | object,\n 'function': Function,\n};\ntype TypeofResult = keyof TypeofLookupTable;\ntype TypeofStringToType<S extends TypeofResult> = TypeofLookupTable[S];\ntype _ = [\n Assert<Equal<\n TypeofStringToType<'undefined'>,\n undefined\n >>,\n Assert<Equal<\n TypeofStringToType<'bigint'>,\n bigint\n >>,\n];\n\n```", "```ts\ninterface GlobalEventHandlersEventMap {\n \"abort\": UIEvent;\n \"animationcancel\": AnimationEvent;\n \"animationend\": AnimationEvent;\n \"animationiteration\": AnimationEvent;\n \"animationstart\": AnimationEvent;\n \"auxclick\": MouseEvent;\n \"beforeinput\": InputEvent;\n \"beforetoggle\": Event;\n \"blur\": FocusEvent;\n \"cancel\": Event;\n \"canplay\": Event;\n \"canplaythrough\": Event;\n \"change\": Event;\n \"click\": MouseEvent;\n // ···\n}\n\n/** One of the interfaces extended by interface `Window` */\ninterface GlobalEventHandlers {\n // ···\n addEventListener<K extends keyof GlobalEventHandlersEventMap>(\n type: K, // a string\n listener: (\n this: GlobalEventHandlers,\n ev: GlobalEventHandlersEventMap[K]\n ) => any,\n options?: boolean | AddEventListenerOptions\n ): void;\n}\n\n```", "```ts\n«Sub» extends «Super» ? «TrueBranch» : «FalseBranch»\n\n```", "```ts\ntype IsNumber<T> = T extends number ? true : false;\ntype _ = [\n Assert<Equal<\n IsNumber<123>, true\n >>,\n Assert<Equal<\n IsNumber<number>, true\n >>,\n Assert<Equal<\n IsNumber<'abc'>, false\n >>,\n];\n\n```", "```ts\ntype ElemType<Arr> = Arr extends Array<infer Elem> ? Elem : never;\ntype _ = Assert<Equal<\n ElemType<Array<string>>, string\n>>;\n\n```", "```ts\ntype Result = let Var = «Value» in «Body»;\n\n```", "```ts\ntype Result = «Value» extends infer Var ? «Body» : never;\n\n```", "```ts\ntype Result = [«Value1», «Value2», «Value3»] extends\n infer [Var1, Var2, Var3]\n ? «Body»\n : never\n;\n\n```", "```ts\ntype WrapTriple<T> = Promise<T> extends infer W\n ? [W, W, W]\n : never\n;\ntype _ = Assert<Equal<\n WrapTriple<number>,\n [Promise<number>, Promise<number>, Promise<number>]\n>>;\n\n```", "```ts\ntype WrapTriple2<T, W=Promise<T>> = [W, W, W];\n\n```", "```ts\n{\n [K in keyof T]: «PropValue»\n}\n\n```", "```ts\ntype InputObj = {\n str: string,\n num: number,\n};\ntype Arrayify<Obj> = {\n [K in keyof Obj]: Array<Obj[K]>\n};\ntype _ = Assert<Equal<\n Arrayify<InputObj>,\n {\n str: Array<string>,\n num: Array<number>,\n }\n>>;\n\n```", "```ts\ntype MethodName = 'compute';\ntype AsyncMethodName = `async${Capitalize<MethodName>}`; // (A)\ntype _ = Assert<Equal<\n AsyncMethodName, 'asyncCompute'\n>>;\n\n```", "```ts\ntype AsyncMethodName = 'asyncCompute';\ntype MethodName = Uncapitalize<\n AsyncMethodName extends `async${infer MN}` ? MN : never // (A)\n>;\ntype _ = Assert<Equal<\n MethodName, 'compute'\n>>;\n\n```", "```ts\ntype Union1 = 'a' | 'b' | 0 | 1;\ntype Union2 = 'b' | 'c' | 1 | 2;\ntype Intersection = Union1 & Union2;\ntype _ = Assert<Equal<\n Intersection,\n 1 | 'b'\n>>;\n\n```", "```ts\ntype Union1 = 'a' | 'b';\ntype Union2 = 'b' | 'c';\ntype UnionResult = Union1 | Union2;\ntype _ = Assert<Equal<\n UnionResult,\n 'a' | 'b' | 'c'\n>>;\n\n```", "```ts\ntype Union = 'l' | 'f' | 'r';\ntype _ = Assert<Equal<\n `${Union}ight`, // (A)\n 'light' | 'fight' | 'right'\n>>;\n\n```", "```ts\ntype Union = { prop: 1 } | { prop: 2 } | { prop: 3 };\ntype _ = Assert<Equal<\n Union['prop'],\n 1 | 2 | 3\n>>;\n\n```", "```ts\ntype WrapStrings<T> = T extends string ? Promise<T> : T;\ntype _ = [\n Assert<Equal<\n WrapStrings<'abc'>, // normal instantiation\n Promise<'abc'>\n >>,\n Assert<Equal<\n WrapStrings<123>, // normal instantiation\n 123\n >>,\n Assert<Equal<\n WrapStrings<'a' | 'b' | 0 | 1>, // distributed instantiation\n Promise<'a'> | Promise<'b'> | 0 | 1\n >>,\n];\n\n```", "```ts\ntype KeepStrings<T> = T extends string ? T : never;\ntype _ = [\n Assert<Equal<\n KeepStrings<'abc'>, // normal instantiation\n 'abc'\n >>,\n Assert<Equal<\n KeepStrings<123>, // normal instantiation\n never\n >>,\n Assert<Equal<\n KeepStrings<'a' | 'b' | 0 | 1>, // distributed instantiation\n 'a' | 'b'\n >>,\n];\n\n```", "```ts\ntype PrependDollarSign<Obj> = {\n [Key in (keyof Obj & string) as `$${Key}`]: Obj[Key]\n};\nfunction prependDollarSign<\n Obj extends object\n>(obj: Obj): PrependDollarSign<Obj> { // (A)\n // @ts-expect-error: Type '{ [k: string]: any; }' is not assignable to\n // type 'PrependDollarSign<Obj>'.\n return Object.fromEntries( // (B)\n Object.entries(obj)\n .map(\n ([key, value]) => ['$'+key, value]\n )\n );\n}\n\n```", "```ts\nfunction prependDollarSign<\n Obj extends object\n>(obj: Obj): PrependDollarSign<Obj> { // (A)\n return Object.fromEntries(\n Object.entries(obj)\n .map(\n ([key, value]) => ['$'+key, value]\n )\n ) as any; // (B)\n}\n\nconst dollarObject = prependDollarSign({\n prop: 123,\n});\nassert.deepEqual(\n dollarObject,\n {\n $prop: 123,\n }\n);\nassertType<\n {\n $prop: number,\n }\n>(dollarObject);\n\n```"]