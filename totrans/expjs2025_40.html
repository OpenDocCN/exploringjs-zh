<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>33 Synchronous generators ES6 (advanced)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>33 Synchronous generators ES6 (advanced)</h1>
<blockquote>原文：<a href="https://exploringjs.com/js/book/ch_sync-generators.html">https://exploringjs.com/js/book/ch_sync-generators.html</a></blockquote>

        
    
    
    
<p><span id="index-entry-synchronous-generator"/><span id="index-entry-generator--synchronous"/></p>
<nav class="local-toc">
  <ol>
    <li>
      <a href="#what-are-sync-generators">33.1 What are synchronous generators?</a>
      <ol>
        <li>
          <a href="#generators-return-iterators">33.1.1 Generator functions return iterators and fill them via <code>yield</code></a>
        </li>
        <li>
          <a href="#yield-pauses-a-generator-function">33.1.2 <code>yield</code> pauses a generator function</a>
        </li>
        <li>
          <a href="#why-does-yield-pause-execution">33.1.3 Why does <code>yield</code> pause execution?</a>
        </li>
        <li>
          <a href="#example-mapping-over-iterables">33.1.4 Example: Mapping over iterables</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#calling-generators-from-generators-advanced">33.2 Calling generators from generators<span> (advanced)</span></a>
      <ol>
        <li>
          <a href="#yield-star">33.2.1 Calling generators via <code>yield*</code></a>
        </li>
        <li>
          <a href="#example-iterating-over-a-tree">33.2.2 Example: Iterating over a tree</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#reusing-traversals">33.3 Use case for generators: reusing traversals</a>
      <ol>
        <li>
          <a href="#external-iteration-internal-iteration">33.3.1 Background: external iteration vs. internal iteration</a>
        </li>
        <li>
          <a href="#the-traversal-to-reuse">33.3.2 The traversal to reuse</a>
        </li>
        <li>
          <a href="#internal-iteration-example">33.3.3 Example: internal iteration (push)</a>
        </li>
        <li>
          <a href="#external-iteration-example">33.3.4 External iteration (pull)</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#advanced-features-of-generators">33.4 Advanced features of generators</a>
    </li>
  </ol>
</nav>
<h3 id="what-are-sync-generators"><a class="heading-id-link" href="#what-are-sync-generators">33.1 What are synchronous generators?</a></h3>
<p><span id="index-entry-function-"/></p>
<p>Synchronous generators are special versions of function definitions and method definitions that help with processing synchronous iterables and synchronous iterators. They always return synchronous iterators (which are iterable):</p>
<pre class="language-js">
<code><span class="hljs-comment">// Generator function declaration</span></code>
<code><span class="hljs-keyword">function</span>* <span class="hljs-title function_">genFunc1</span>(<span class="hljs-params">) { <span class="hljs-comment">/*···*/</span> }</span></code>
<code/>
<code><span class="hljs-params"><span class="hljs-comment">// Generator function expression</span></span></code>
<code><span class="hljs-params"><span class="hljs-keyword">const</span> genFunc2 = <span class="hljs-keyword">function</span>* () { <span class="hljs-comment">/*···*/</span> };</span></code>
<code/>
<code><span class="hljs-params"><span class="hljs-comment">// Generator method definition in an object literal</span></span></code>
<code><span class="hljs-params"><span class="hljs-keyword">const</span> obj = {</span></code>
<code><span class="hljs-params">  * <span class="hljs-title function_">generatorMethod</span>(<span class="hljs-params"/>) {</span></code>
<code><span class="hljs-params">    <span class="hljs-comment">// ···</span></span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">};</span></code>
<code/>
<code><span class="hljs-params"><span class="hljs-comment">// Generator method definition in a class definition</span></span></code>
<code><span class="hljs-params"><span class="hljs-comment">// (class declaration or class expression)</span></span></code>
<code><span class="hljs-params"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {</span></code>
<code><span class="hljs-params">  * <span class="hljs-title function_">generatorMethod</span>(<span class="hljs-params"/>) {</span></code>
<code><span class="hljs-params">    <span class="hljs-comment">// ···</span></span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p>Asterisks (<code>*</code>) mark functions and methods as generators:</p>
<ul>
  <li>
    Functions: The pseudo-keyword <code>function*</code> is a combination of the keyword <code>function</code> and an asterisk.
  </li>
  <li>
    Methods: The <code>*</code> is a modifier (similar to <code>static</code> and <code>get</code>).
  </li>
</ul>
<h4 id="generators-return-iterators"><a class="heading-id-link" href="#generators-return-iterators">33.1.1 Generator functions return iterators and fill them via <code>yield</code></a></h4>
<p><span id="index-entry-yield--synchronous-generator-"/></p>
<p>If we call a generator function, it returns an iterator (which is also iterable – as all built-in iterators are). The generator fills that iterator via the <code>yield</code> operator:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span>* <span class="hljs-title function_">createIterator</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> <span class="hljs-string">'a'</span>;</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> <span class="hljs-string">'b'</span>;</span></code>
<code><span class="hljs-params">}</span></code>
<code/>
<code><span class="hljs-params"><span class="hljs-comment">// Converting the result to an Array</span></span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-comment">// Using an Iterator method</span></span></code>
<code><span class="hljs-params">  <span class="hljs-title function_">createIterator</span>().<span class="hljs-title function_">toArray</span>(),</span></code>
<code><span class="hljs-params">  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]</span></code>
<code><span class="hljs-params">);</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-comment">// The iterator is iterable, so Array.from() works</span></span></code>
<code><span class="hljs-params">  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-title function_">createIterator</span>()),</span></code>
<code><span class="hljs-params">  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]</span></code>
<code><span class="hljs-params">);</span></code>
<code/>
<code><span class="hljs-params"><span class="hljs-comment">// We can use for-of because the iterator is iterable</span></span></code>
<code><span class="hljs-params"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> <span class="hljs-title function_">createIterator</span>()) {</span></code>
<code><span class="hljs-params">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p>Output:</p>
<pre>
<code>a</code>
<code>b</code>
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Creating an iterator over a range of integers</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/sync-generators/integer-range_test.mjs</code></p>
</div>
<h4 id="yield-pauses-a-generator-function"><a class="heading-id-link" href="#yield-pauses-a-generator-function">33.1.2 <code>yield</code> pauses a generator function</a></h4>
<p>Using a generator function involves the following steps:</p>
<ul>
  <li>
    Function-calling it returns an iterator <code>iter</code>.
  </li>
  <li>
    Iterating over <code>iter</code> repeatedly invokes <code>iter.next()</code>. Each time, we jump into the body of the generator function until there is a <code>yield</code> that returns a value.
  </li>
</ul>
<p>Therefore, <code>yield</code> does more than just add values to iterators – it also pauses and exits the generator function:</p>
<ul>
  <li>
    Like <code>return</code>, a <code>yield</code> exits the body of the function and returns a value (to/via <code>.next()</code>).
  </li>
  <li>
    Unlike <code>return</code>, if we repeat the invocation (of <code>.next()</code>), execution resumes directly after the <code>yield</code>.
  </li>
</ul>
<p>Let’s examine what that means via the following generator function.</p>
<pre class="language-js">
<code><span class="hljs-keyword">let</span> location = <span class="hljs-number">0</span>;</code>
<code><span class="hljs-keyword">function</span>* <span class="hljs-title function_">genFunc2</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  location = <span class="hljs-number">1</span>;</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> <span class="hljs-string">'a'</span>;</span></code>
<code><span class="hljs-params">  location = <span class="hljs-number">2</span>;</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> <span class="hljs-string">'b'</span>;</span></code>
<code><span class="hljs-params">  location = <span class="hljs-number">3</span>;</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p>In order to use <code>genFunc2()</code>, we must first create the iterator/iterable <code>iter</code>. <code>genFunc2()</code> is now paused “before” its body.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> iter = <span class="hljs-title function_">genFunc2</span>();</code>
<code><span class="hljs-comment">// genFunc2() is now paused “before” its body:</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(location, <span class="hljs-number">0</span>);</code>
</pre>
<p><code>iter</code> implements <a href="ch_sync-iteration.html#ch_sync-iteration">the iteration protocol</a>. Therefore, we control the execution of <code>genFunc2()</code> via <code>iter.next()</code>. Calling that method resumes the paused <code>genFunc2()</code> and executes it until there is a <code>yield</code>. Then execution pauses and <code>.next()</code> returns the operand of the <code>yield</code>:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  iter.<span class="hljs-title function_">next</span>(), {<span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>});</code>
<code><span class="hljs-comment">// genFunc2() is now paused directly after the first `yield`:</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(location, <span class="hljs-number">1</span>);</code>
</pre>
<p>Note that the yielded value <code>'a'</code> is wrapped in an object, which is how iterators always deliver their values.</p>
<p>We call <code>iter.next()</code> again and execution continues where we previously paused. Once we encounter the second <code>yield</code>, <code>genFunc2()</code> is paused and <code>.next()</code> returns the yielded value <code>'b'</code>.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  iter.<span class="hljs-title function_">next</span>(), {<span class="hljs-attr">value</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>});</code>
<code><span class="hljs-comment">// genFunc2() is now paused directly after the second `yield`:</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(location, <span class="hljs-number">2</span>);</code>
</pre>
<p>We call <code>iter.next()</code> one more time and execution continues until it leaves the body of <code>genFunc2()</code>:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  iter.<span class="hljs-title function_">next</span>(), {<span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>});</code>
<code><span class="hljs-comment">// We have reached the end of genFunc2():</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(location, <span class="hljs-number">3</span>);</code>
</pre>
<p>This time, property <code>.done</code> of the result of <code>.next()</code> is <code>true</code>, which means that the iterator is finished.</p>
<h4 id="why-does-yield-pause-execution"><a class="heading-id-link" href="#why-does-yield-pause-execution">33.1.3 Why does <code>yield</code> pause execution?</a></h4>
<p>What are the benefits of <code>yield</code> pausing execution? Why doesn’t it simply work like the Array method <code>.push()</code> and fill the iterator with values without pausing?</p>
<p>Due to pausing, generators provide many of the features of <em>coroutines</em> (think processes that are multitasked cooperatively). For example, when we ask for the next value of an iterator, that value is computed <em>lazily</em> (on demand). The following two generator functions demonstrate what that means.</p>
<pre class="language-js">
<code><span class="hljs-comment">/**</span></code>
<code><span class="hljs-comment"> * Returns an iterator over lines</span></code>
<code><span class="hljs-comment"> */</span></code>
<code><span class="hljs-keyword">function</span>* <span class="hljs-title function_">genLines</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> <span class="hljs-string">'A line'</span>;</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> <span class="hljs-string">'Another line'</span>;</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> <span class="hljs-string">'Last line'</span>;</span></code>
<code><span class="hljs-params">}</span></code>
<code/>
<code><span class="hljs-params"><span class="hljs-comment">/**</span></span></code>
<code><span class="hljs-params"><span class="hljs-comment"> * Input: iterable over lines</span></span></code>
<code><span class="hljs-params"><span class="hljs-comment"> * Output: iterator over numbered lines</span></span></code>
<code><span class="hljs-params"><span class="hljs-comment"> */</span></span></code>
<code><span class="hljs-params"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">numberLines</span>(<span class="hljs-params">lineIterable</span>) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">let</span> lineNumber = <span class="hljs-number">1</span>;</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> line <span class="hljs-keyword">of</span> lineIterable) { <span class="hljs-comment">// input</span></span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">yield</span> lineNumber + <span class="hljs-string">': '</span> + line; <span class="hljs-comment">// output</span></span></code>
<code><span class="hljs-params">    lineNumber++;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p>Note that the <code>yield</code> in <code>numberLines()</code> appears inside a <code>for-of</code> loop. <code>yield</code> can be used inside loops, but not inside callbacks (more on that later).</p>
<p>Let’s combine both generators to produce the iterator <code>numberedLines</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> numberedLines = <span class="hljs-title function_">numberLines</span>(<span class="hljs-title function_">genLines</span>());</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  numberedLines.<span class="hljs-title function_">next</span>(),</code>
<code>  {<span class="hljs-attr">value</span>: <span class="hljs-string">'1: A line'</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>}</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  numberedLines.<span class="hljs-title function_">next</span>(),</code>
<code>  {<span class="hljs-attr">value</span>: <span class="hljs-string">'2: Another line'</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>}</code>
<code>);</code>
</pre>
<p>The key benefit of using generators here is that everything works incrementally: via <code>numberedLines.next()</code>, we ask <code>numberLines()</code> for only a single numbered line. In turn, it asks <code>genLines()</code> for only a single unnumbered line.</p>
<p>This incrementalism continues to work if, for example, <code>genLines()</code> reads its lines from a large text file: If we ask <code>numberLines()</code> for a numbered line, we get one as soon as <code>genLines()</code> has read its first line from the text file.</p>
<p>Without generators, <code>genLines()</code> would first read all lines and return them. Then <code>numberLines()</code> would number all lines and return them. We therefore have to wait much longer until we get the first numbered line.</p>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Turning a normal function into a generator</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/sync-generators/fib_seq_test.mjs</code></p>
</div>
<h4 id="example-mapping-over-iterables"><a class="heading-id-link" href="#example-mapping-over-iterables">33.1.4 Example: Mapping over iterables</a></h4>
<p>The following function <code>mapIter()</code> is similar to the Array method <code>.map()</code>, but it returns an iterator, not an Array, and produces its results on demand.</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span>* <span class="hljs-title function_">mapIter</span>(<span class="hljs-params">iterable, func</span>) {</code>
<code>  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;</code>
<code>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> iterable) {</code>
<code>    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">func</span>(x, index);</code>
<code>    index++;</code>
<code>  }</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">const</span> iterator = <span class="hljs-title function_">mapIter</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>], <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + x);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(iterator), [<span class="hljs-string">'aa'</span>, <span class="hljs-string">'bb'</span>]</code>
<code>);</code>
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Filtering iterables</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/sync-generators/filter_iter_gen_test.mjs</code></p>
</div>
<h3 id="calling-generators-from-generators-advanced"><a class="heading-id-link" href="#calling-generators-from-generators-advanced">33.2 Calling generators from generators<span> (advanced)</span></a></h3>
<h4 id="yield-star"><a class="heading-id-link" href="#yield-star">33.2.1 Calling generators via <code>yield*</code></a></h4>
<p><span id="index-entry-yield---synchronous-generator-"/></p>
<p><code>yield</code> only works directly inside generators – so far we haven’t seen a way of delegating yielding to another function or method.</p>
<p>Let’s first examine what does <em>not</em> work: in the following example, we’d like <code>compute()</code> to call <code>helper()</code>, so that the latter yields two values for the former. Alas, a naive approach fails:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span>* <span class="hljs-title function_">helper</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> <span class="hljs-string">'a'</span>;</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> <span class="hljs-string">'b'</span>;</span></code>
<code><span class="hljs-params">}</span></code>
<code><span class="hljs-params"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">compute</span>(<span class="hljs-params"/>) {</span></code>
<code><span class="hljs-params">  <span class="hljs-comment">// Nothing happens if we call `helper()`:</span></span></code>
<code><span class="hljs-params">  <span class="hljs-title function_">helper</span>();</span></code>
<code><span class="hljs-params">}</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-title function_">compute</span>()), []</span></code>
<code><span class="hljs-params">);</span></code>
</pre>
<p>Why doesn’t this work? The function call <code>helper()</code> returns an iterator, which we ignore.</p>
<p>What we want is for <code>compute()</code> to yield everything that is yielded by <code>helper()</code>. That’s what the <code>yield*</code> operator does:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span>* <span class="hljs-title function_">helper</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> <span class="hljs-string">'a'</span>;</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> <span class="hljs-string">'b'</span>;</span></code>
<code><span class="hljs-params">}</span></code>
<code><span class="hljs-params"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">compute</span>(<span class="hljs-params"/>) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span>* <span class="hljs-title function_">helper</span>();</span></code>
<code><span class="hljs-params">}</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-title function_">compute</span>()), [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]</span></code>
<code><span class="hljs-params">);</span></code>
</pre>
<p>In other words, the previous <code>compute()</code> is roughly equivalent to:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span>* <span class="hljs-title function_">compute</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> <span class="hljs-title function_">helper</span>()) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">yield</span> x;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p>Note that <code>yield*</code> works with any iterable:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span>* <span class="hljs-title function_">gen</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span>* [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];</span></code>
<code><span class="hljs-params">}</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-title function_">gen</span>()), [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]</span></code>
<code><span class="hljs-params">);</span></code>
</pre>
<h4 id="example-iterating-over-a-tree"><a class="heading-id-link" href="#example-iterating-over-a-tree">33.2.2 Example: Iterating over a tree</a></h4>
<p><code>yield*</code> lets us make recursive calls in generators, which is useful when iterating over recursive data structures such as trees. Take, for example, the following data structure for binary trees.</p>
<pre class="language-js">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span> {</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value, left=<span class="hljs-literal">null</span>, right=<span class="hljs-literal">null</span></span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">left</span> = left;</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">right</span> = right;</code>
<code>  }</code>
<code/>
<code>  <span class="hljs-comment">/** Prefix iteration: parent before children */</span></code>
<code>  * [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() {</code>
<code>    <span class="hljs-keyword">yield</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;</code>
<code>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">left</span>) {</code>
<code>      <span class="hljs-comment">// Same as yield* this.left[Symbol.iterator]()</span></code>
<code>      <span class="hljs-keyword">yield</span>* <span class="hljs-variable language_">this</span>.<span class="hljs-property">left</span>;</code>
<code>    }</code>
<code>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">right</span>) {</code>
<code>      <span class="hljs-keyword">yield</span>* <span class="hljs-variable language_">this</span>.<span class="hljs-property">right</span>;</code>
<code>    }</code>
<code>  }</code>
<code>}</code>
</pre>
<p>Method <code>[Symbol.iterator]()</code> adds support for the iteration protocol, which means that we can use a <code>for-of</code> loop to iterate over an instance of <code>BinaryTree</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryTree</span>(<span class="hljs-string">'a'</span>,</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryTree</span>(<span class="hljs-string">'b'</span>,</code>
<code>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryTree</span>(<span class="hljs-string">'c'</span>),</code>
<code>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryTree</span>(<span class="hljs-string">'d'</span>)),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryTree</span>(<span class="hljs-string">'e'</span>));</code>
<code/>
<code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> tree) {</code>
<code>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);</code>
<code>}</code>
</pre>
<p>Output:</p>
<pre>
<code>a</code>
<code>b</code>
<code>c</code>
<code>d</code>
<code>e</code>
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Iterating over a nested Array</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/sync-generators/iter_nested_arrays_test.mjs</code></p>
</div>
<h3 id="reusing-traversals"><a class="heading-id-link" href="#reusing-traversals">33.3 Use case for generators: reusing traversals</a></h3>
<p>One important use case for generators is extracting and reusing traversals.</p>
<h4 id="external-iteration-internal-iteration"><a class="heading-id-link" href="#external-iteration-internal-iteration">33.3.1 Background: external iteration vs. internal iteration</a></h4>
<p><span id="index-entry-internal-iteration"/><span id="index-entry-iteration--internal"/>
<span id="index-entry-external-iteration"/><span id="index-entry-iteration--external"/></p>
<p>In preparation for the next subsections, we need to learn about two different styles of iterating over the values “inside” an object:</p>
<ul>
  <li>
    <p>External iteration (pull): Our code asks the object for the values via an iteration protocol. For example, the <code>for-of</code> loop is based on JavaScript’s iteration protocol:</p>
<pre class="language-js">
<code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]) {</code>
<code>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);</code>
<code>}</code>
</pre>
    <p>Output:</p>
<pre>
<code>a</code>
<code>b</code>
</pre>
  </li>
  <li>
    <p>Internal iteration (push): We pass a callback function to a method of the object and the method feeds the values to the callback. For example, Arrays have the method <code>.forEach()</code>:</p>
<pre class="language-js">
<code>[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> {</code>
<code>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);</code>
<code>});</code>
</pre>
    <p>Output:</p>
<pre>
<code>a</code>
<code>b</code>
</pre>
  </li>
</ul>
<p>The next subsections have examples of both styles of iteration.</p>
<h4 id="the-traversal-to-reuse"><a class="heading-id-link" href="#the-traversal-to-reuse">33.3.2 The traversal to reuse</a></h4>
<p>As an example, consider the following function that traverses a tree of files and logs their paths (it uses <a href="https://nodejs.org/docs/latest/api/">the Node.js API</a> for doing so):</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">logPaths</span>(<span class="hljs-params">dir</span>) {</code>
<code>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> fileName <span class="hljs-keyword">of</span> fs.<span class="hljs-title function_">readdirSync</span>(dir)) {</code>
<code>    <span class="hljs-keyword">const</span> filePath = path.<span class="hljs-title function_">join</span>(dir, fileName);</code>
<code>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(filePath);</code>
<code>    <span class="hljs-keyword">const</span> stats = fs.<span class="hljs-title function_">statSync</span>(filePath);</code>
<code>    <span class="hljs-keyword">if</span> (stats.<span class="hljs-title function_">isDirectory</span>()) {</code>
<code>      <span class="hljs-title function_">logPaths</span>(filePath); <span class="hljs-comment">// recursive call</span></code>
<code>    }</code>
<code>  }</code>
<code>}</code>
</pre>
<p>Consider the following directory:</p>
<pre class="language-txt">
<code>mydir/</code>
<code>  a.txt</code>
<code>  b.txt</code>
<code>  subdir/</code>
<code>    c.txt</code>
</pre>
<p>Let’s log the paths inside <code>mydir/</code>:</p>
<pre class="language-js">
<code><span class="hljs-title function_">logPaths</span>(<span class="hljs-string">'mydir'</span>);</code>
</pre>
<p>Output:</p>
<pre>
<code>mydir/a.txt</code>
<code>mydir/b.txt</code>
<code>mydir/subdir</code>
<code>mydir/subdir/c.txt</code>
</pre>
<p>How can we reuse this traversal and do something other than logging the paths?</p>
<h4 id="internal-iteration-example"><a class="heading-id-link" href="#internal-iteration-example">33.3.3 Example: internal iteration (push)</a></h4>
<p>One way of reusing traversal code is via <em>internal iteration</em>: Each traversed value is passed to a callback (line A).</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">visitPaths</span>(<span class="hljs-params">dir, callback</span>) {</code>
<code>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> fileName <span class="hljs-keyword">of</span> fs.<span class="hljs-title function_">readdirSync</span>(dir)) {</code>
<code>    <span class="hljs-keyword">const</span> filePath = path.<span class="hljs-title function_">join</span>(dir, fileName);</code>
<code>    <span class="hljs-title function_">callback</span>(filePath); <span class="hljs-comment">// (A)</span></code>
<code>    <span class="hljs-keyword">const</span> stats = fs.<span class="hljs-title function_">statSync</span>(filePath);</code>
<code>    <span class="hljs-keyword">if</span> (stats.<span class="hljs-title function_">isDirectory</span>()) {</code>
<code>      <span class="hljs-title function_">visitPaths</span>(filePath, callback);</code>
<code>    }</code>
<code>  }</code>
<code>}</code>
<code><span class="hljs-keyword">const</span> paths = [];</code>
<code><span class="hljs-title function_">visitPaths</span>(<span class="hljs-string">'mydir'</span>, <span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> paths.<span class="hljs-title function_">push</span>(p));</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  paths,</code>
<code>  [</code>
<code>    <span class="hljs-string">'mydir/a.txt'</span>,</code>
<code>    <span class="hljs-string">'mydir/b.txt'</span>,</code>
<code>    <span class="hljs-string">'mydir/subdir'</span>,</code>
<code>    <span class="hljs-string">'mydir/subdir/c.txt'</span>,</code>
<code>  ]);</code>
</pre>
<h4 id="external-iteration-example"><a class="heading-id-link" href="#external-iteration-example">33.3.4 External iteration (pull)</a></h4>
<p>Another way of reusing traversal code is via <em>external iteration</em>: We can write a generator that yields all traversed values (line A).</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span>* <span class="hljs-title function_">iterPaths</span>(<span class="hljs-params">dir</span>) {</code>
<code>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> fileName <span class="hljs-keyword">of</span> fs.<span class="hljs-title function_">readdirSync</span>(dir)) {</code>
<code>    <span class="hljs-keyword">const</span> filePath = path.<span class="hljs-title function_">join</span>(dir, fileName);</code>
<code>    <span class="hljs-keyword">yield</span> filePath; <span class="hljs-comment">// (A)</span></code>
<code>    <span class="hljs-keyword">const</span> stats = fs.<span class="hljs-title function_">statSync</span>(filePath);</code>
<code>    <span class="hljs-keyword">if</span> (stats.<span class="hljs-title function_">isDirectory</span>()) {</code>
<code>      <span class="hljs-keyword">yield</span>* <span class="hljs-title function_">iterPaths</span>(filePath);</code>
<code>    }</code>
<code>  }</code>
<code>}</code>
<code><span class="hljs-keyword">const</span> paths = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-title function_">iterPaths</span>(<span class="hljs-string">'mydir'</span>));</code>
</pre>
<h3 id="advanced-features-of-generators"><a class="heading-id-link" href="#advanced-features-of-generators">33.4 Advanced features of generators</a></h3>
<p><a href="https://exploringjs.com/es6/ch_generators.html">The chapter on generators</a> in <em>Exploring ES6</em> covers two features that are beyond the scope of this book:</p>
<ul>
  <li>
    <code>yield</code> can also <em>receive</em> data, via an argument of <code>.next()</code>.
  </li>
  <li>
    Generators can also <code>return</code> values (not just <code>yield</code> them). Such values do not become iteration values, but can be retrieved via <code>yield*</code>.
  </li>
</ul>

    
      
</body>
</html>