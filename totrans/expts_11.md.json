["```ts\n{\n \"extends\": \"@tsconfig/node-lts/tsconfig.json\",\n}\n\n```", "```ts\n{\n \"include\": [\"src/**/*\"],\n}\n\n```", "```ts\n\"compilerOptions\": {\n \"rootDir\": \"src\",\n \"outDir\": \"dist\",\n}\n\n```", "```ts\n{\n \"include\": [\"src/**/*\"],\n \"compilerOptions\": {\n // Specify explicitly (don’t derive from source file paths):\n \"rootDir\": \"src\",\n \"outDir\": \"dist\",\n // ···\n }\n}\n\n```", "```ts\n{\n \"include\": [\"src/**/*\", \"test/**/*\"],\n \"compilerOptions\": {\n \"rootDir\": \".\",\n \"outDir\": \"dist\",\n // ···\n }\n}\n\n```", "```ts\n{\n \"include\": [\"src/**/*\"],\n}\n\n```", "```ts\n/tmp/my-proj/\n tsconfig.json\n src/\n main.ts\n test/\n test.ts\n dist/\n main.js\n test/\n test.js\n\n```", "```ts\n{\n \"include\": [\"src/**/*\"],\n}\n\n```", "```ts\n/tmp/my-proj/\n tsconfig.json\n src/\n core/\n cli/\n main.ts\n test/\n test.ts\n dist/\n main.js\n test/\n test.js\n\n```", "```ts\n{\n \"include\": [\"src/**/*\", \"test/**/*\"],\n}\n\n```", "```ts\n/tmp/my-proj/\n tsconfig.json\n src/\n main.ts\n test/\n test.ts\n dist/\n src/\n main.js\n test/\n test.js\n\n```", "```ts\n\"compilerOptions\": {\n \"sourceMap\": true,\n}\n\n```", "```ts\n\"compilerOptions\": {\n \"declaration\": true,\n \"declarationMap\": true, // enables importers to jump to source\n}\n\n```", "```ts\n\"compilerOptions\": {\n \"newLine\": \"lf\",\n \"removeComments\": false,\n}\n\n```", "```ts\n\"compilerOptions\": {\n \"target\": \"ESNext\", // sets up \"lib\" accordingly\n \"skipLibCheck\": true,\n}\n\n```", "```ts\n/// <reference lib=\"es2024\" />\n/// <reference lib=\"dom\" />\n/// <reference lib=\"webworker.importscripts\" />\n/// <reference lib=\"scripthost\" />\n/// <reference lib=\"dom.iterable\" />\n/// <reference lib=\"dom.asynciterable\" />\n\n```", "```ts\nfor (const x of document.querySelectorAll('div')) {}\n\n```", "```ts\nnpm install @types/node\n\n```", "```ts\n\"compilerOptions\": {\n \"module\": \"NodeNext\",\n \"noUncheckedSideEffectImports\": true,\n}\n\n```", "```ts\nimport './component-styles.css';\n\n```", "```ts\nimport './does-not-exist.js'; // no error!\n\n```", "```ts\n\"compilerOptions\": {\n \"allowImportingTsExtensions\": true,\n // Only needed if compiling to JavaScript:\n \"rewriteRelativeImportExtensions\": true,\n}\n\n```", "```ts\nimport {someFunc} from './lib/utilities.js';\n\n```", "```ts\nimport {someFunc} from './lib/utilities.ts';\n\n```", "```ts\n\"compilerOptions\": {\n \"resolveJsonModule\": true,\n}\n\n```", "```ts\nimport data from './data.json' with {type: 'json'};\nconsole.log(data.version);\n\n```", "```ts\n// ./src/globals.d.ts\ndeclare module \"*.css\" {}\n\n```", "```ts\n\"compilerOptions\": {\n \"strict\": true,\n \"exactOptionalPropertyTypes\": true,\n \"noFallthroughCasesInSwitch\": true,\n \"noImplicitOverride\": true,\n \"noImplicitReturns\": true,\n \"noPropertyAccessFromIndexSignature\": true,\n \"noUncheckedIndexedAccess\": true,\n}\n\n```", "```ts\ninterface Settings {\n // Absent property means “system”\n colorTheme?: 'dark' | 'light';\n}\nconst obj1: Settings = {}; // allowed\n// @ts-expect-error: Type '{ colorTheme: undefined; }' is not\n// assignable to type 'Settings' with\n// 'exactOptionalPropertyTypes: true'. Consider adding 'undefined'\n// to the types of the target's properties.\nconst obj2: Settings = { colorTheme: undefined };\n\n```", "```ts\nconst tuple1: [number, string?] = [1];\nconst tuple2: [number, string?] = [1, 'hello'];\n// @ts-expect-error: Type '[number, undefined]' is not assignable to\n// type '[number, string?]'.\nconst tuple3: [number, string?] = [1, undefined];\n\n```", "```ts\ntype Obj = {\n num?: number,\n};\nfunction createObj(num?: number): Obj {\n // @ts-expect-error: Type '{ num: number | undefined; }' is not\n // assignable to type 'Obj' with\n // 'exactOptionalPropertyTypes: true'.\n return { num };\n} \n\n```", "```ts\nconst optionDefaults: { a: number } = { a: 1 };\n// This assignment is an error with `exactOptionalPropertyTypes`\nconst options: { a?: number } = { a: undefined }; // (A)\n\nconst result = { ...optionDefaults, ...options };\nassertType<\n { a: number }\n>(result);\nassert.deepEqual(\n result, { a: undefined }\n);\n\n```", "```ts\nfunction f(obj: {prop?: number}): void {\n if ('prop' in obj) {\n // Without `exactOptionalPropertyTypes`, the type would be:\n // number | undefined\n assertType<number>(obj.prop);\n }\n}\n\n```", "```ts\ninterface ObjectWithId {\n id: string,\n [key: string]: string;\n}\nfunction f(obj: ObjectWithId) {\n const value1 = obj.id; // allowed\n const value2 = obj['unknownProp']; // allowed\n // @ts-expect-error: Property 'unknownProp' comes from an index\n // signature, so it must be accessed with ['unknownProp'].\n const value3 = obj.unknownProp;\n}\n\n```", "```ts\ninterface ObjectWithId {\n id: string,\n [key: string]: string;\n}\nfunction f(obj: ObjectWithId): void {\n assertType<string>(obj.id);\n assertType<undefined | string>(obj['unknownProp']);\n}\n\n```", "```ts\nfunction f(obj: Record<string, number>): void {\n // Without `noUncheckedIndexedAccess`, this type would be:\n // number\n assertType<undefined | number>(obj['hello']);\n}\n\n```", "```ts\nconst arr = ['a', 'b'];\nconst elem = arr[0];\n// Without `noUncheckedIndexedAccess`, this type would be:\n// string\nassertType<undefined | string>(elem);\n\n```", "```ts\nfunction logElemAt0(arr: Array<string>) {\n if (0 < arr.length) {\n const elem = arr[0];\n assertType<undefined | string>(elem);\n console.log(elem);\n }\n}\n\n```", "```ts\nfunction logElemAt0(arr: Array<string>) {\n if (0 in arr) {\n const elem = arr[0];\n assertType<string>(elem);\n console.log(elem);\n }\n}\n\n```", "```ts\n\"compilerOptions\": {\n \"noEmit\": true,\n}\n\n```", "```ts\n\"compilerOptions\": {\n \"erasableSyntaxOnly\": true,\n \"verbatimModuleSyntax\": true, // implies \"isolatedModules\"\n}\n\n```", "```ts\n<someType>someValue // not allowed\n\n```", "```ts\nsomeValue as someType // allowed\n\n```", "```ts\n// Input: TypeScript\nimport { type SomeInterface, SomeClass } from './my-module.js';\n\n// Output: JavaScript\nimport { SomeClass } from './my-module.js';\n\n```", "```ts\nimport type { Type1, Type2, Type3 } from './types.js';\n\n```", "```ts\nexport type MyType = {};\nexport interface MyInterface {}\n\n```", "```ts\ntype Type1 = {};\ntype Type2 = {};\nexport {\n type Type1,\n type Type2,\n}\n\ntype Type3 = {};\ntype Type4 = {};\nexport type {\n Type3,\n Type4,\n}\n\n```", "```ts\nexport default interface DefaultInterface {} // OK\n\ntype DefaultType = {}\nexport default DefaultType; // error\nexport default type DefaultType; // error\n\nexport default type {} // error\n\n```", "```ts\ntype DefaultType = {}\nexport {\n type DefaultType as default,\n}\n\n```", "```ts\n\"compilerOptions\": {\n // Only allowed if `declaration` or `composite` are true\n \"isolatedDeclarations\": true,\n}\n\n```", "```ts\n// OK: return type stated explicitly\nexport function f1(): string {\n return 123..toString();\n}\n// Error: return type requires inference\nexport function f2() {\n return 123..toString();\n}\n// OK: return type trivial to determine\nexport function f3() {\n return 123;\n}\n\n```", "```ts\n// OK: type trivial to determine\nexport const value1 = 123;\n// Error: type requires inference\nexport const value2 = 123..toString();\n// OK: type stated explicitly\nexport const value3: string = 123..toString();\n\n```", "```ts\nexport class C {\n str: string; // required\n constructor(str: string) {\n this.str = str;\n }\n}\n\n```", "```ts\njavascript.preferences.importModuleSpecifierEnding\ntypescript.preferences.importModuleSpecifierEnding\n\n```", "```ts\n{\n \"include\": [\"src/**/*\"],\n \"compilerOptions\": {\n // Specified explicitly (not derived from source file paths)\n \"rootDir\": \"src\",\n \"outDir\": \"dist\",\n\n //========== Target and module ==========\n // Nothing is ever transpiled\n \"target\": \"ESNext\", // sets up \"lib\" accordingly\n \"module\": \"NodeNext\", // sets up \"moduleResolution\"\n // Don’t check .d.ts files\n \"skipLibCheck\": true,\n // Emptily imported modules must exist\n \"noUncheckedSideEffectImports\": true,\n // Allow importing JSON\n \"resolveJsonModule\": true,\n\n //========== Type checking ==========\n // Essential: activates several useful options\n \"strict\": true,\n // Beyond \"strict\": less important\n \"exactOptionalPropertyTypes\": true,\n \"noFallthroughCasesInSwitch\": true,\n \"noImplicitOverride\": true,\n \"noImplicitReturns\": true,\n \"noPropertyAccessFromIndexSignature\": true,\n \"noUncheckedIndexedAccess\": true,\n\n //========== Only JS at non-type level (type stripping etc.) ==========\n // Forbid non-JavaScript language constructs such as:\n // JSX, enums, constructor parameter properties, namespaces\n \"erasableSyntaxOnly\": true,\n // Enforce keyword `type` for type imports etc.\n \"verbatimModuleSyntax\": true, // implies \"isolatedModules\"\n\n //========== Use filename extension .ts in imports ==========\n \"allowImportingTsExtensions\": true,\n // Only needed if compiling to JavaScript\n \"rewriteRelativeImportExtensions\": true, // from .ts to .js\n\n //========== Emitted files ==========\n // tsc only type-checks, doesn’t emit any files\n \"noEmit\": true,\n //----- Output: .js -----\n \"sourceMap\": true, // .js.map files\n //----- Output: .d.ts -----\n \"declaration\": true, // .d.ts files\n // “Go to definition” jumps to TS source etc.\n \"declarationMap\": true, // .d.ts.map files\n // - Enforces constraints that enable efficient .d.ts generation:\n //   no inferred return types for exported functions etc.\n // - Even though this option would be generally useful, it requires\n //   that `declaration` and/or `composite` are true.\n \"isolatedDeclarations\": true,\n }\n}\n\n```", "```ts\n\"compilerOptions\": {\n // Transpile new JavaScript to old JavaScript\n \"target\": \"ES20YY\", // sets up \"lib\" accordingly\n}\n\n```"]