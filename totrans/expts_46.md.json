["```ts\ntype Song<Num extends number, Bev extends string> = // (A)\n `${Num} bottles of ${Bev}`\n;\ntype _ = Assert<Equal<\n Song<99, 'juice'>, // (B)\n '99 bottles of juice'\n>>;\n\n```", "```ts\ntype Modules = 'fs' | 'os' | 'path';\ntype Prefixed = `node:${Modules}`;\ntype _ = Assert<Equal<\n Prefixed, 'node:fs' | 'node:os' | 'node:path'\n>>;\n\n```", "```ts\ntype Words = `${ 'd' | 'l' }${ 'i' | 'o' }ve`;\ntype _ = Assert<Equal<\n Words, 'dive' | 'dove' | 'live' | 'love'\n>>;\n\n```", "```ts\ntype Digit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;\n// @ts-expect-error: Expression produces a union type\n// that is too complex to represent.\ntype Zip = `${Digit}${Digit}${Digit}${Digit}${Digit}`;\n\n```", "```ts\ntype Hex =\n | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\n | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'\n ;\n// @ts-expect-error: Expression produces a union type\n// that is too complex to represent.\ntype CssColor = `#${Hex}${Hex}${Hex}${Hex}${Hex}${Hex}`;\n\n```", "```ts\ntype ParseSemver<Str extends string> =\n Str extends `${infer Major}.${infer Minor}.${infer Patch}`\n ? [ Major, Minor, Patch ]\n : never\n;\ntype _ = Assert<Equal<\n ParseSemver<'1.2.3'>, ['1', '2', '3']\n>>;\n\n```", "```ts\ntype _ = Assert<Equal<\n '¡Hola!' extends `¡${infer S}!` ? S : never,\n 'Hola'\n>>;\n\n```", "```ts\ntype _ = [\n Assert<Equal<\n 'true' extends `${infer B extends boolean}` ? B : never,\n true\n >>,\n Assert<Equal<\n '256' extends `${infer N extends number}` ? N : never,\n 256\n >>,\n];\n\n```", "```ts\ntype StrToNum<T> =\n T extends `${infer N extends number}` ? N : never\n;\ntype _ = [\n Assert<Equal<\n StrToNum<'123'>, 123\n >>,\n Assert<Equal<\n StrToNum<'-123'>, -123\n >>,\n Assert<Equal<\n StrToNum<'1.0'>, number\n >>,\n Assert<Equal<\n StrToNum<'1e2'>, number\n >>,\n Assert<Equal<\n StrToNum<'abc'>, never\n >>,\n];\n\n```", "```ts\ntype Version = `v${number}.${number}`;\n\n// @ts-expect-error: Type '\"\"' is not assignable to\n// type '`v${number}.${number}`'.\nconst version0: Version = '';\n\nconst version1: Version = 'v1.0'; // OK\n\n// @ts-expect-error: Type '\"v2.zero\"' is not assignable to\n// type '`v${number}.${number}`'.\nconst version2: Version = 'v2.zero';\n\n```", "```ts\nconst undefinedValue: `${undefined}` = 'undefined';\nconst nullValue: `${null}` = 'null';\nconst booleanValue: `${boolean}` = 'true';\nconst numberValue: `${number}` = '123';\nconst bigintValue: `${bigint}` = '123';\nconst stringValue: `${string}` = 'abc';\n\n// @ts-expect-error: Type 'symbol' is not assignable to type\n// 'string | number | bigint | boolean | null | undefined'.\nconst symbolValue: `${symbol}` = 'symbol';\n\n```", "```ts\ntype Properties = '0' | '2' | 'length' | 'toString';\ntype _ = Assert<Equal<\n Properties & `${number}`, // (A)\n '0' | '2'\n>>;\n\n```", "```ts\ntype _ = Assert<Equal<\n Exclude<'apple' | 'apricot' | 'banana', `a${string}`>,\n 'banana'\n>>;\n\n```", "```ts\n    type _ = Assert<Equal<\n     Uppercase<'hello'>, 'HELLO'\n    >>;\n\n    ```", "```ts\n    type _ = Assert<Equal<\n     Lowercase<'HELLO'>, 'hello'\n    >>;\n\n    ```", "```ts\n    type _ = Assert<Equal<\n     Capitalize<'hello'>, 'Hello'\n    >>;\n\n    ```", "```ts\n    type _ = Assert<Equal<\n     Uncapitalize<'HELLO'>, 'hELLO'\n    >>;\n\n    ```", "```ts\nstr.toUpperCase() // Uppercase\nstr.toLowerCase() // Lowercase\nstr.charAt(0).toUpperCase() + str.slice(1) // Capitalize\nstr.charAt(0).toLowerCase() + str.slice(1) // Uncapitalize\n\n```", "```ts\ntype IsUppercase<Str extends string> = Str extends Uppercase<Str>\n ? true\n : false;\n\ntype _ = [\n Assert<Equal<\n IsUppercase<'SUNSHINE'>, true\n >>,\n Assert<Equal<\n IsUppercase<'SUNSHINe'>, false\n >>,\n];\n\n```", "```ts\ntype ToString<\n T extends string | number | bigint | boolean | null | undefined\n> = `${T}`\n;\n\ntype _ = Assert<Equal<\n ToString<'abc' | 123 | -456n | false | null | undefined>,\n 'abc' | '123' | '-456' | 'false' | 'null' | 'undefined'\n>>;\n\n```", "```ts\ntype TrimStart<Str extends string> =\n Str extends ` ${infer Rest}`\n ? TrimStart<Rest> // (A)\n : Str\ntype TrimEnd<Str extends string> =\n Str extends `${infer Rest} `\n ? TrimEnd<Rest> // (B)\n : Str\n;\ntype Trim<Str extends string> = TrimStart<TrimEnd<Str>>;\n\n```", "```ts\ntype _ = [\n Assert<Equal<\n TrimStart<'  text  '>,\n 'text  '\n >>,\n Assert<Equal<\n TrimEnd<'  text  '>,\n '  text'\n >>,\n Assert<Equal<\n Trim<'  text  '>,\n 'text'\n >>,\n];\n\n```", "```ts\ntype Join<Strs extends string[], Sep extends string = ','> =\n Strs extends [\n infer First extends string,\n ...infer Rest extends string[]\n ]\n ? Rest['length'] extends 0\n ? First\n : `${First}${Sep}${Join<Rest, Sep>}`\n : ''\n;\ntype _ = Assert<Equal<\n Join<['Hello', 'How', 'Are', 'You'], ' '>,\n 'Hello How Are You'\n>>;\n\n```", "```ts\ntype Split<Str extends string, Sep extends string> =\n Str extends `${infer First}${Sep}${infer Rest}`\n ? [First, ...Split<Rest, Sep>] // (A)\n : [Str] // (B)\n;\n\n```", "```ts\ntype _ = Assert<Equal<\n Split<'How | are|you', '|'>,\n ['How ', ' are', 'you']\n>>;\n\n```", "```ts\ntype StringToUnion<Str extends string> =\n Trim<TupleToUnion<Split<Str, '|'>>>;\ntype TupleToUnion<Tup extends readonly unknown[]> = Tup[number]; \n\ntype _ = Assert<Equal<\n StringToUnion<'A | B | C'>,\n 'A' | 'C' | 'B'\n>>;\n\n```", "```ts\ntype SplitCodeUnits<Str extends string> =\n Str extends `${infer First}${infer Rest}`\n // `First` is not empty\n ? [First, ...SplitCodeUnits<Rest>]\n // `First` (and therefore `Str`) is empty\n : []\n;\ntype _ = [\n Assert<Equal<\n SplitCodeUnits<'rainbow'>,\n ['r', 'a', 'i', 'n', 'b', 'o', 'w']\n >>,\n Assert<Equal<\n SplitCodeUnits<''>,\n []\n >>,\n];\n\n```", "```ts\ntype PrependDollarSign<Obj> = {\n [Key in (keyof Obj & string) as `$${Key}`]: Obj[Key]\n};\n\ntype Items = {\n count: number,\n item: string,\n [Symbol.toStringTag]: string,\n};\ntype _ = Assert<Equal<\n PrependDollarSign<Items>,\n {\n $count: number,\n $item: string,\n // Omitted: [Symbol.toStringTag]\n }\n>>;\n\n```", "```ts\nconsole.log(\n util.styleText(['bold', 'underline', 'red'], 'Hello!')\n);\n\n```", "```ts\nObject.keys(util.inspect.colors)\n\n```", "```ts\nconst styles = [\n 'bold',\n 'italic',\n 'underline',\n 'red',\n 'green',\n 'blue',\n // ...\n] as const; // `as const` enables us to derive a type\ntype StyleUnion = TupleToUnion<typeof styles>;\ntype TupleToUnion<Tup extends readonly unknown[]> = Tup[number]; \n\ntype StyleTextFormat =\n| `${StyleUnion}`\n| `${StyleUnion}+${StyleUnion}`\n| `${StyleUnion}+${StyleUnion}+${StyleUnion}`\n;\n\nfunction styleText(format: StyleTextFormat, text: string): string {\n return util.styleText(format.split('+'), text);\n}\n\nstyleText('bold+underline+red', 'Hello!'); // OK\n// @ts-expect-error: Argument of type '\"bol+underline+red\"' is not\n// assignable to parameter of type 'StyleTextFormat'.\nstyleText('bol+underline+red', 'Hello!'); // typo: 'bol'\n\n```", "```ts\ntype PropType<T, Path extends string> =\n Path extends keyof T\n // `Path` is already a key of `T`\n ? T[Path]\n // Otherwise: extract first dot-separated key\n : Path extends `${infer First}.${infer Rest}`\n ? First extends keyof T\n // Use key `First` and compute PropType for result\n ? PropType<T[First], Rest>\n : unknown\n : unknown;\n\nfunction getPropValue\n <T, P extends string>\n (value: T, path: P): PropType<T, P>\n{\n // Not implemented yet...\n return null as PropType<T, P>;\n}\n\nconst obj = { a: { b: ['x', 'y']}} as const;\n\nassertType<\n { readonly b: readonly ['x', 'y'] }\n>(getPropValue(obj, 'a'));\n\nassertType<\n readonly ['x', 'y']\n>(getPropValue(obj, 'a.b'));\n\nassertType<\n 'y'\n>(getPropValue(obj, 'a.b.1'));\n\nassertType<\n unknown\n>(getPropValue(obj, 'a.b.p'));\n\nfunction myFunc(str: string) {\n // If the second argument is not a literal,\n // we can’t infer a return type.\n assertType<\n unknown\n >(getPropValue(obj, str));\n}\n\n```", "```ts\ntype PropKeysAtToUnderscore<Obj> = {\n [Key in keyof Obj as AtToUnderscore<Key>]: Obj[Key];\n};\ntype AtToUnderscore<Key> =\n // Remove prefix '@', add prefix '_'\n Key extends `@${infer Rest}` ? `_${Rest}` : Key // (A)\n;\n\ntype JsonLd = {\n '@context': string,\n '@type': string,\n datePublished: string,\n};\ntype _ = Assert<Equal<\n PropKeysAtToUnderscore<JsonLd>,\n {\n _context: string,\n _type: string,\n datePublished: string,\n }\n>>;\n\n```", "```ts\nAtToUnderscore<Key extends string>\n\n```", "```ts\ntype SplitCamelCase<\n Str extends string,\n Word extends string = '',\n Words extends string[] = []\n> = Str extends `${infer Char}${infer Rest}`\n ? IsUppercase<Char> extends true\n // `Word` is empty if initial `Str` starts with capital letter\n ? SplitCamelCase<Rest, Char, Append<Words, Word>>\n : SplitCamelCase<Rest, `${Word}${Char}`, Words>\n // We have reached the end of `Str`:\n // `Word` is only empty if initial `Str` was empty.\n : [...Words, Word]\n;\ntype IsUppercase<Str extends string> = Str extends Uppercase<Str>\n ? true\n : false\n;\n// Only append `Str` to `Arr` if `Str` isn’t empty\ntype Append<Arr extends string[], Str extends string> =\n Str extends ''\n ? Arr\n : [...Arr, Str]\n;\n\ntype _1 = [\n Assert<Equal<\n SplitCamelCase<'howAreYou'>,\n ['how', 'Are', 'You']\n >>,\n Assert<Equal<\n SplitCamelCase<'PascalCase'>,\n ['Pascal', 'Case']\n >>,\n Assert<Equal<\n SplitCamelCase<'CAPS'>,\n ['C', 'A', 'P', 'S']\n >>,\n];\n\n```", "```ts\ntype ToHyphenCase<Str extends string> =\n HyphenateWords<SplitCamelCase<Str>>\n;\ntype HyphenateWords<Words extends string[]> =\n Words extends [\n infer First extends string,\n ...infer Rest extends string[]\n ]\n ? Rest['length'] extends 0\n ? Lowercase<First>\n : `${Lowercase<First>}-${HyphenateWords<Rest>}`\n : ''\n;\n\ntype _2 = [\n Assert<Equal<\n ToHyphenCase<'howAreYou'>,\n 'how-are-you'\n >>,\n Assert<Equal<\n ToHyphenCase<'PascalCase'>,\n 'pascal-case'\n >>,\n];\n\n```", "```ts\ntype ToLowerCamelCase<Str extends string> =\n Uncapitalize<ToUpperCamelCase<Str>>\n;\n// Upper camel case (Pascal case) is easier to compute\ntype ToUpperCamelCase<Str extends string> =\n camelizeWords<Split<Str, '-'>>\n;\n\ntype camelizeWords<Words extends string[]> =\n Words extends [\n infer First extends string,\n ...infer Rest extends string[]\n ]\n ? Rest['length'] extends 0\n ? Capitalize<First>\n : `${Capitalize<First>}${camelizeWords<Rest>}`\n : ''\n;\n\ntype _ = [\n Assert<Equal<\n ToLowerCamelCase<'how-are-you'>,\n 'howAreYou'\n >>,\n Assert<Equal<\n ToUpperCamelCase<'how-are-you'>,\n 'HowAreYou'\n >>,\n];\n\n```", "```ts\ntype UUID = `${string}-${string}-${string}-${string}-${string}`;\n\n```", "```ts\nconst opts = program\n .option(\"-e, --episode <num>\", \"Download episode No. <num>\")\n .option(\"--keep\", \"Keeps temporary files\")\n .option(\"--ratio [ratio]\", \"Either 16:9, or a custom ratio\")\n .opts();\n\n```", "```ts\n{\n episode: string;\n} & {\n keep: boolean;\n} & {\n ratio: string | boolean;\n}\n\n```", "```ts\nconst a = querySelector('div.banner > a.call-to-action');\n // HTMLAnchorElement\nconst b = querySelector('input, div');\n // HTMLInputElement | HTMLDivElement\nconst c = querySelector('circle[cx=\"150\"]');\n // SVGCircleElement\nconst d = querySelector('button#buy-now');\n // HTMLButtonElement\nconst e = querySelector('section p:first-of-type');\n // HTMLParagraphElement\n\n```", "```ts\nconst AppRoutes = routes(\n {\n path: '' as const,\n },\n {\n path: 'book/:id' as const,\n children: routes(\n {\n path: 'author/:id' as const,\n },\n ),\n },\n);\n\n// `AppRoutes` determines (statically!) what arguments can be\n// passed to `buildPath()`:\n\nconst buildPath = createPathBuilder(AppRoutes);\nbuildPath(); // OK\nbuildPath('book', 12); // OK\nbuildPath('book', '123', 'author', 976); // OK\n\nbuildPath('book', null);\n // Error: argument not assignable to parameter\nbuildPath('fake', 'route');\n // Error: argument not assignable to parameter\n\n```", "```ts\nhandleGet(\n '/posts/:postId/:commentId',\n ({postId, commentId}) => {\n console.log(postId, commentId);\n }\n);\n\n```", "```ts\ntype BaseColor =\n 'gray' | 'red' | 'yellow' | 'green' |\n 'blue' | 'indigo' | 'purple' | 'pink';\ntype Variant =\n 50 | 100 | 200 | 300 | 400\n 500 | 600 | 700 | 800 | 900;\ntype TailwindColor = `${BaseColor}-${Variant}`;\n\n```", "```ts\nconst currentTsSyntax = type({\n keyword: \"null\",\n stringLiteral: \"'TS'\",\n numberLiteral: \"5\",\n bigintLiteral: \"5n\",\n union: \"string|number\",\n intersection: \"boolean&true\",\n array: \"Date[]\",\n grouping: \"(0|1)[]\",\n objectLiteral: {\n nested: \"string\",\n \"optional?\": \"number\"\n },\n tuple: [\"number\", \"number\"]\n});\n\n```"]