["```ts\nconst obj = {prop: 'yes'};\n\n// We can’t assign a different value:\nassert.throws(\n () => obj = {},\n /^TypeError: Assignment to constant variable./\n);\n\n// But we can modify the assigned value:\nobj.prop = 'no'; // OK\n\n```", "```ts\ntype ReadonlyProp = {\n readonly prop: { str: string },\n};\nconst obj: ReadonlyProp = {\n prop: { str: 'a' },\n};\n\n```", "```ts\n// The property is immutable:\n// @ts-expect-error: Cannot assign to 'prop' because it is\n// a read-only property.\nobj.prop = { str: 'x' };\n\n// But not the property value:\nobj.prop.str += 'b';\n\n```", "```ts\ntype Counter = {\n readonly count: number,\n};\n\nfunction createCounter(): Counter {\n return { count: 0 };\n}\nfunction toIncremented(counter: Counter): Counter {\n return { // (A)\n count: counter.count + 1,\n };\n}\n\n```", "```ts\nfunction increment(counter: Counter): void {\n // @ts-expect-error: Cannot assign to 'count' because it is\n // a read-only property.\n counter.count++;\n}\n\n```", "```ts\ntype Obj = { prop: number };\ntype ReadonlyObj = { readonly prop: number };\n\nfunction func(_obj: Obj) { }\nfunction readonlyFunc(_readonlyObj: ReadonlyObj) { }\n\nconst obj: Obj = { prop: 123 };\nfunc(obj);\nreadonlyFunc(obj);\n\nconst readonlyObj: ReadonlyObj = { prop: 123 };\nfunc(readonlyObj);\nreadonlyFunc(readonlyObj);\n\n```", "```ts\ntype _ = Assert<Not<Equal<\n { readonly prop: number },\n { prop: number }\n>>>;\n\n```", "```ts\ninterface ArrayLike<T> {\n readonly length: number;\n readonly [n: number]: T; // (A)\n}\n\n```", "```ts\ninterface ArrayConstructor {\n from<T>(iterable: Iterable<T> | ArrayLike<T>): T[];\n // ···\n}\n\n```", "```ts\nconst arrayLike: ArrayLike<string> = {\n length: 2,\n 0: 'a',\n 1: 'b',\n};\nassert.deepEqual(\n Array.from(arrayLike), ['a', 'b']\n);\nassert.equal(\n // Reading is allowed:\n arrayLike[0], 'a'\n);\n// Writing is not allowed:\n// @ts-expect-error: Index signature in type 'ArrayLike<string>'\n// only permits reading.\narrayLike[0] = 'x';\n\n```", "```ts\ntype Point = {\n x: number,\n y: number,\n dist(): number,\n};\ntype ReadonlyPoint = Readonly<Point>;\n\ntype _ = Assert<Equal<\n ReadonlyPoint,\n {\n readonly x: number,\n readonly y: number,\n readonly dist: () => number,\n }\n>>;\n\n```", "```ts\nclass Counter {\n readonly count: number;\n constructor(count: number) {\n this.count = count;\n }\n inc(): Counter {\n return new Counter(this.count + 1);\n }\n incMut(): void {\n // @ts-expect-error: Cannot assign to 'count' because\n // it is a read-only property.\n this.count++;\n }\n}\n\n```", "```ts\nReadonlyArray<string>\nreadonly string[]\n\n```", "```ts\nconst arr: ReadonlyArray<string> = ['a', 'b'];\n\n// @ts-expect-error: Index signature in type 'readonly string[]'\n// only permits reading.\narr[0] = 'x';\n\n// @ts-expect-error: Cannot assign to 'length' because it is\n// a read-only property.\narr.length = 1;\n\n// @ts-expect-error: Property 'push' does not exist on\n// type 'readonly string[]'.\narr.push('x');\n\n```", "```ts\ninterface ReadonlyArray<T> {\n readonly length: number;\n readonly [n: number]: T;\n\n // Included: non-destructive methods such as .map(), .filter(), etc.\n // Excluded: destructive methods such as .push(), .sort(), etc.\n // ···\n}\n\n```", "```ts\nclass ImmutableArray<T> {\n #arr: Array<T>;\n constructor(arr: Array<T>) {\n this.#arr = arr;\n }\n get length(): number {\n return this.#arr.length;\n }\n at(index: number): T | undefined {\n return this.#arr.at(index);\n }\n map<U>(\n callbackfn: (value: T, index: number, array: readonly T[]) => U,\n thisArg?: any\n ): U[] {\n return this.#arr.map(callbackfn, thisArg);\n }\n // (Many omitted methods)\n}\n\n```", "```ts\nconst tuple: [string, number] = ['a', 1];\ntuple[0] = 'x'; // OK\n\ntuple.length = 2; // OK\n// @ts-expect-error: Type '1' is not assignable to type '2'.\ntuple.length = 1;\n// The type of `.length` is 2 (not `number`)\ntype _ = Assert<Equal<\n (typeof tuple)['length'], 2\n>>;\n\n// Interestingly, `.push()` is allowed:\ntuple.push('x'); // OK\n\n```", "```ts\nconst tuple: readonly [string, number] = ['a', 1];\n\n// @ts-expect-error: Cannot assign to '0' because it is\n// a read-only property.\ntuple[0] = 'x';\n\n// @ts-expect-error: Cannot assign to 'length' because it is\n// a read-only property.\ntuple.length = 2;\n\n// @ts-expect-error: Property 'push' does not exist on\n// type 'readonly [string, number]'.\ntuple.push('x');\n\n```", "```ts\ntype _ = Assert<Extends<\n typeof tuple, ReadonlyArray<string | number>\n>>;\n\n```", "```ts\n// Not included here: methods defined in lib.es2015.iterable.d.ts\n// such as: .keys() and .[Symbol.iterator]()\n\ninterface ReadonlySet<T> {\n forEach(\n callbackfn: (value: T, value2: T, set: ReadonlySet<T>) => void,\n thisArg?: any\n ): void;\n has(value: T): boolean;\n readonly size: number;\n}\ninterface ReadonlyMap<K, V> {\n forEach(\n callbackfn: (value: V, key: K, map: ReadonlyMap<K, V>) => void,\n thisArg?: any\n ): void;\n get(key: K): V | undefined;\n has(key: K): boolean;\n readonly size: number;\n}\n\n```", "```ts\nconst COLORS: ReadonlySet<string> = new Set(['red', 'green']);\n\n```", "```ts\nclass ImmutableSet<T> implements ReadonlySet<T> {\n #set: Set<T>;\n constructor(set: Set<T>) {\n this.#set = set;\n }\n get size(): number {\n return this.#set.size;\n }\n forEach(\n callbackfn: (value: T, value2: T, set: ReadonlySet<T>) => void,\n thisArg?: any\n ): void {\n return this.#set.forEach(callbackfn, thisArg);\n }\n // Etc.\n}\n\n```", "```ts\nconst obj = { prop: 123 };\ntype _1 = Assert<Equal<\n typeof obj, { prop: number }\n>>;\n\nconst constObj = { prop: 123 } as const;\ntype _2 = Assert<Equal<\n typeof constObj, { readonly prop: 123 }\n>>;\n\n```", "```ts\nconst arr = ['a', 'b'];\ntype _1 = Assert<Equal<\n typeof arr, string[]\n>>;\n\nconst constTuple = ['a', 'b'] as const;\ntype _2 = Assert<Equal<\n typeof constTuple, readonly [\"a\", \"b\"]\n>>;\n\n```", "```ts\nlet str1 = 'abc';\ntype _1 = Assert<Equal<\n typeof str1, string\n>>;\n\nlet str2 = 'abc' as const;\ntype _2 = Assert<Equal<\n typeof str2, 'abc'\n>>;\n\n```", "```ts\nconst str3 = 'abc';\ntype _3 = Assert<Equal<\n typeof str3, 'abc'\n>>;\n\n```", "```ts\nfunction sum(numbers: Array<number>): number {\n return numbers.reduce((acc, x) => acc + x, 0);\n}\n\nsum([1, 2, 3]); // OK\n\nconst readonlyTuple = [1, 2, 3] as const;\n// @ts-expect-error: Argument of type 'readonly [1, 2, 3]'\n// is not assignable to parameter of type 'number[]'.\nsum(readonlyTuple);\n\n```", "```ts\nfunction sum(numbers: ReadonlyArray<number>): number {\n return numbers.reduce((acc, x) => acc + x, 0);\n}\n\nconst readonlyTuple = [1, 2, 3] as const;\nsum(readonlyTuple); // OK\n\n```", "```ts\ntype Wrap<T extends Array<unknown>> = Promise<T>;\nconst arr = ['a', 'b'] as const;\n// @ts-expect-error: Type 'readonly [\"a\", \"b\"]' does not satisfy\n// the constraint 'unknown[]'.\ntype _ = Wrap<typeof arr>;\n\n```", "```ts\ntype Wrap<T extends ReadonlyArray<unknown>> = Promise<T>;\nconst arr = ['a', 'b'] as const;\ntype Result = Wrap<typeof arr>;\ntype _ = Assert<Equal<\n Result, Promise<readonly [\"a\", \"b\"]>\n>>;\n\n```", "```ts\nfunction appFunc(arr: ReadonlyArray<string>): void {\n // @ts-expect-error: Argument of type 'readonly string[]'\n // is not assignable to parameter of type 'string[]'.\n libFunc(arr);\n}\n\nfunction libFunc(arr: Array<string>): void {}\n\n```"]