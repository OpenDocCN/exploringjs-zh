- en: 45 Asynchronous iteration ES2018
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 45 异步迭代 ES2018
- en: 原文：[https://exploringjs.com/js/book/ch_async-iteration.html](https://exploringjs.com/js/book/ch_async-iteration.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/js/book/ch_async-iteration.html](https://exploringjs.com/js/book/ch_async-iteration.html)
- en: '[45.1 Basic asynchronous iteration](#basic-asynchronous-iteration)'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[45.1 基本异步迭代](#basic-asynchronous-iteration)'
- en: '[45.1.1 Protocol: async iteration](#async-iteration-protocol)'
  id: totrans-3
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[45.1.1 协议：异步迭代](#async-iteration-protocol)'
- en: '[45.1.2 Using async iteration directly](#using-async-iteration-directly)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[45.1.2 直接使用异步迭代](#using-async-iteration-directly)'
- en: '[45.1.3 Using async iteration via `for-await-of`](#for-await-of)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[45.1.3 通过`for-await-of`使用异步迭代](#for-await-of)'
- en: '[45.2 Asynchronous generators](#async-generators)'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[45.2 异步生成器](#async-generators)'
- en: '[45.2.1 Example: creating an async iterable via an async generator](#example-creating-an-async-iterable-via-an-async-generator)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[45.2.1 示例：通过异步生成器创建异步可迭代对象](#example-creating-an-async-iterable-via-an-async-generator)'
- en: '[45.2.2 Example: converting a sync iterable to an async iterable](#example-converting-a-sync-iterable-to-an-async-iterable)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[45.2.2 示例：将同步可迭代对象转换为异步可迭代对象](#example-converting-a-sync-iterable-to-an-async-iterable)'
- en: '[45.2.3 Example: converting an async iterable to an Array](#asyncIterableToArray)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[45.2.3 示例：将异步可迭代对象转换为数组](#asyncIterableToArray)'
- en: '[45.2.4 Example: transforming an async iterable](#example-transforming-an-async-iterable)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[45.2.4 示例：转换异步可迭代对象](#example-transforming-an-async-iterable)'
- en: '[45.2.5 Example: mapping over asynchronous iterables](#example-mapping-over-asynchronous-iterables)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[45.2.5 示例：映射异步可迭代对象](#example-mapping-over-asynchronous-iterables)'
- en: '[45.3 Async iteration over Node.js streams](#async-iteration-over-nodejs-streams)'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[45.3 Node.js流的异步迭代](#async-iteration-over-nodejs-streams)'
- en: '[45.3.1 Node.js streams: async via callbacks (push)](#nodejs-streams-async-via-callbacks-push)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[45.3.1 Node.js流：通过回调（推送）进行异步操作](#nodejs-streams-async-via-callbacks-push)'
- en: '[45.3.2 Node.js streams: async via async iteration (pull)](#nodejs-streams-async-via-async-iteration-pull)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[45.3.2 Node.js流：通过异步迭代（拉取）进行异步操作](#nodejs-streams-async-via-async-iteration-pull)'
- en: '[45.3.3 Example: from chunks to lines](#example-from-chunks-to-lines)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[45.3.3 示例：从块到行](#example-from-chunks-to-lines)'
- en: '![Icon “reading”](../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png) **Required
    knowledge**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![阅读图标](../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png) **所需知识**'
- en: 'For this chapter, you should be familiar with:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你应该熟悉：
- en: '[Promises](ch_promises.html#ch_promises)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Promise](ch_promises.html#ch_promises)'
- en: '[Async functions](ch_async-functions.html#ch_async-functions)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[异步函数](ch_async-functions.html#ch_async-functions)'
- en: '[45.1 Basic asynchronous iteration](#basic-asynchronous-iteration)'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[45.1 基本异步迭代](#basic-asynchronous-iteration)'
- en: '[45.1.1 Protocol: async iteration](#async-iteration-protocol)'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[45.1.1 协议：异步迭代](#async-iteration-protocol)'
- en: 'To understand how asynchronous iteration works, let’s first revisit [synchronous
    iteration](ch_sync-iteration.html#ch_sync-iteration). It comprises the following
    interfaces:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解异步迭代是如何工作的，让我们首先回顾一下[同步迭代](ch_sync-iteration.html#ch_sync-iteration)。它包括以下接口：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An `Iterable` is a data structure whose contents can be accessed via iteration.
    It is a factory for iterators.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iterable`是一个可以通过迭代访问其内容的数据结构。它是一个迭代器的工厂。'
- en: An `Iterator` is a factory for iteration results that we retrieve by calling
    the method `.next()`.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iterator`是一个迭代结果的工厂，我们通过调用`.next()`方法来检索它。'
- en: Each `IterationResult` contains the iterated `.value` and a boolean `.done`
    that is `true` after the last element and `false` before.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个`IterationResult`包含迭代的`.value`和一个布尔值`.done`，在最后一个元素之后为`true`，在之前为`false`。
- en: 'For the protocol for asynchronous iteration, we only want to change one thing:
    the values produced by `.next()` should be delivered asynchronously. There are
    two conceivable options:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于异步迭代的协议，我们只想改变一件事：`.next()`产生的值应该异步传递。有两种可行的选择：
- en: The `.value` could contain a `Promise<T>`.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.value`可能包含一个`Promise<T>`。'
- en: '`.next()` could return `Promise<IteratorResult<T>>`.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.next()`可能返回`Promise<IteratorResult<T>>`。'
- en: In other words, the question is whether to wrap just values or whole iterator
    results in Promises.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，问题在于是否将值或整个迭代器结果包裹在Promise中。
- en: It has to be the latter because when `.next()` returns a result, it starts an
    asynchronous computation. Whether or not that computation produces a value or
    signals the end of the iteration can only be determined after it is finished.
    Therefore, both `.done` and `.value` need to be wrapped in a Promise.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 必须是后者，因为当`.next()`返回一个结果时，它开始一个异步计算。该计算是否产生值或指示迭代结束，只能在计算完成后确定。因此，`.done`和`.value`都需要被包裹在一个Promise中。
- en: The interfaces for async iteration look as follows.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 异步迭代的接口如下所示。
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The only difference to the synchronous interfaces is the return type of `.next()`
    (line A).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与同步接口的唯一区别是 `.next()` 的返回类型（行 A）。
- en: '[45.1.2 Using async iteration directly](#using-async-iteration-directly)'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[45.1.2 直接使用异步迭代](#using-async-iteration-directly)'
- en: 'The following code uses the asynchronous iteration protocol directly:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码直接使用异步迭代协议：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In line A, we create an asynchronous iterable over the value `'a'` and `'b'`.
    We’ll see an implementation of `syncToAsyncIterable()` later.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 A 中，我们创建了一个异步可迭代对象，它遍历值 `'a'` 和 `'b'`。我们将在后面看到 `syncToAsyncIterable()` 的实现。
- en: We call `.next()` in line B, line C and line D. Each time, we use `.then()`
    to unwrap the Promise and `assert.deepEqual()` to check the unwrapped value.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在行 B、行 C 和行 D 中调用 `.next()`。每次，我们使用 `.then()` 来解包 Promise 并使用 `assert.deepEqual()`
    来检查解包的值。
- en: 'We can simplify this code if we use an async function. Now we unwrap Promises
    via `await` and the code looks almost like we are doing synchronous iteration:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用异步函数，我们可以简化此代码。现在我们通过 `await` 解包 Promise，代码看起来几乎就像我们正在进行同步迭代：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[45.1.3 Using async iteration via `for-await-of`](#for-await-of)'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[45.1.3 通过 `for-await-of` 使用异步迭代](#for-await-of)'
- en: 'The asynchronous iteration protocol is not meant to be used directly. One of
    the language constructs that supports it is the `for-await-of` loop, which is
    an asynchronous version of the `for-of` loop. It can be used in async functions
    and *async generators* (which are introduced later in this chapter). This is an
    example of `for-await-of` in use:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 异步迭代协议不打算直接使用。支持它的语言结构之一是 `for-await-of` 循环，它是 `for-of` 循环的异步版本。它可以在异步函数和 *异步生成器*（在本章后面介绍）中使用。以下是一个
    `for-await-of` 的使用示例：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Output:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`for-await-of` is relatively flexible. In addition to asynchronous iterables,
    it also supports synchronous iterables:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-await-of` 相对灵活。除了异步可迭代对象外，它还支持同步可迭代对象：'
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And it supports synchronous iterables over values that are wrapped in Promises:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 它还支持在 Promise 中包装的值上的同步可迭代对象：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercises:
    Asynchronous iteration**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![练习图标“exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：异步迭代**'
- en: 'Converting an async iterable to an Array: `exercises/async-iteration/async_iterable_to_array_test.mjs`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将异步可迭代对象转换为数组：`exercises/async-iteration/async_iterable_to_array_test.mjs`
- en: 'Warning: We’ll soon see the solution for this exercise in this chapter.'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警告：我们将在本章中很快看到这个练习的解决方案。
- en: 'Implementing an asynchronously iterable queue: `exercises/async-iteration/async-iter-queue_test.mjs`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现异步可迭代队列：`exercises/async-iteration/async-iter-queue_test.mjs`
- en: '[45.2 Asynchronous generators](#async-generators)'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[45.2 异步生成器](#async-generators)'
- en: Asynchronous generators are very similar to synchronous generators; especially
    the operators `yield` and `yield*`. Therefore, those are not explained here. See
    [the chapter on synchronous generators](ch_sync-generators.html#ch_sync-generators)
    for more information.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 异步生成器与同步生成器非常相似；特别是 `yield` 和 `yield*` 操作符。因此，这里不再解释。有关更多信息，请参阅[同步生成器章节](ch_sync-generators.html#ch_sync-generators)。
- en: 'An asynchronous generator is two things at the same time:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 异步生成器同时是两件事：
- en: 'An async function (input): We can use `await` and `for-await-of` to retrieve
    data.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步函数（输入）：我们可以使用 `await` 和 `for-await-of` 来检索数据。
- en: 'A generator that returns an asynchronous iterable (output): We can use `yield`
    and `yield*` to produce data.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回异步可迭代对象的生成器（输出）：我们可以使用 `yield` 和 `yield*` 来产生数据。
- en: 'Therefore, the input and output of an asynchronous generator are:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，异步生成器的输入和输出是：
- en: 'The input can be:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入可以是：
- en: synchronous (single values, sync iterables)
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步（单个值，同步可迭代对象）
- en: asynchronous (Promises, async iterables)
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步（Promise，异步可迭代对象）
- en: The output is an asynchronous iterator (that is also iterable).
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出是一个异步迭代器（也是可迭代的）。
- en: 'This looks as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来如下所示：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[45.2.1 Example: creating an async iterable via an async generator](#example-creating-an-async-iterable-via-an-async-generator)'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[45.2.1 示例：通过异步生成器创建异步可迭代对象](#example-creating-an-async-iterable-via-an-async-generator)'
- en: 'Let’s look at an example. The following code creates an async iterable with
    three numbers:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。以下代码创建了一个包含三个数字的异步可迭代对象：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Does the result of `yield123()` conform to the async iteration protocol?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield123()` 的结果是否符合异步迭代协议？'
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[45.2.2 Example: converting a sync iterable to an async iterable](#example-converting-a-sync-iterable-to-an-async-iterable)'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[45.2.2 示例：将同步可迭代对象转换为异步可迭代对象](#example-converting-a-sync-iterable-to-an-async-iterable)'
- en: The following asynchronous generator converts a synchronous iterable to an asynchronous
    iterable. It implements the function `syncToAsyncIterable()` that we have used
    previously.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的异步生成器将同步迭代器转换为异步迭代器。它实现了我们之前使用的`syncToAsyncIterable()`函数。
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note: The input is synchronous in this case (no `await` is needed).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在这种情况下，输入是同步的（不需要`await`）。
- en: '[45.2.3 Example: converting an async iterable to an Array](#asyncIterableToArray)'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[45.2.3 示例：将异步迭代器转换为数组](#asyncIterableToArray)'
- en: The following function is a solution to a previous exercise. It converts an
    async iterable to an Array (think spreading, but for async iterables instead of
    sync iterables).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的函数是之前一个练习的解决方案。它将异步迭代器转换为数组（想象一下展开，但用于异步迭代器而不是同步迭代器）。
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that we can’t use an async generator in this case: We get our input via
    `for-await-of` and return an Array wrapped in a Promise. The latter requirement
    rules out async generators.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下我们不能使用异步生成器：我们通过`for-await-of`获取输入，并返回一个被Promise包装的数组。后者的要求排除了异步生成器。
- en: 'This is a test for `asyncIterableToArray()`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个对`asyncIterableToArray()`的测试：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note the `await` in line A, which is needed to unwrap the Promise returned by
    `asyncIterableToArray()`. In order for `await` to work, this code fragment must
    be run inside an async function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意行A中的`await`，这是展开`asyncIterableToArray()`返回的Promise所必需的。为了使`await`能够工作，这段代码必须在一个异步函数内部运行。
- en: '[45.2.4 Example: transforming an async iterable](#example-transforming-an-async-iterable)'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[45.2.4 示例：转换异步迭代器](#example-transforming-an-async-iterable)'
- en: Let’s implement an async generator that produces a new async iterable by transforming
    an existing async iterable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个异步生成器，它通过转换现有的异步迭代器来生成一个新的异步迭代器。
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To test this function, we use `asyncIterableToArray()` from the previous section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个函数，我们使用上一节中的`asyncIterableToArray()`。
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Async generators**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“练习”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：异步生成器**'
- en: 'Warning: We’ll soon see the solution for this exercise in this chapter.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：我们很快将在本章中看到这个练习的解决方案。
- en: '`exercises/async-iteration/number_lines_test.mjs`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exercises/async-iteration/number_lines_test.mjs`'
- en: '[45.2.5 Example: mapping over asynchronous iterables](#example-mapping-over-asynchronous-iterables)'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[45.2.5 示例：异步迭代器上的映射](#example-mapping-over-asynchronous-iterables)'
- en: 'As a reminder, this is how to map over synchronous iterables:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，这是如何在同步迭代器上映射：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The asynchronous version looks as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 异步版本如下所示：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note how similar the sync implementation and the async implementation are. The
    only two differences are the `async` in line A and the `await` in line B. That
    is comparable to going from a synchronous function to an asynchronous function
    – we only need to add the keyword `async` and the occasional `await`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意同步实现和异步实现是多么相似。唯一的两个区别是行A中的`async`和行B中的`await`。这相当于从同步函数到异步函数的转变——我们只需要添加关键字`async`和偶尔的`await`。
- en: 'To test `mapAsync()`, we use the helper function `asyncIterableToArray()` [(shown
    earlier in this chapter)](#asyncIterableToArray):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`mapAsync()`，我们使用辅助函数`asyncIterableToArray()` [(本章前面展示)](#asyncIterableToArray)：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once again, we `await` to unwrap a Promise (line A) and this code fragment must
    run inside an async function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们使用`await`来展开Promise（行A），并且这段代码必须在一个异步函数内部运行。
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    `filterAsyncIter()`**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“练习”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：`filterAsyncIter()`**'
- en: '`exercises/async-iteration/filter_async_iter_test.mjs`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/async-iteration/filter_async_iter_test.mjs`'
- en: '[45.3 Async iteration over Node.js streams](#async-iteration-over-nodejs-streams)'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[45.3 Node.js流上的异步迭代](#async-iteration-over-nodejs-streams)'
- en: Due to the asynchronous nature of data streams, asynchronous iteration works
    well as an abstraction for them. In particular, async generators are an elegant
    tool for *transforming* data streams (where both input and output are streams).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据流的异步特性，异步迭代很好地作为它们的抽象。特别是，异步生成器是转换数据流（输入和输出都是流）的一个优雅工具。
- en: '[45.3.1 Node.js streams: async via callbacks (push)](#nodejs-streams-async-via-callbacks-push)'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[45.3.1 Node.js流：通过回调的异步（推送）](#nodejs-streams-async-via-callbacks-push)'
- en: 'Traditionally, reading asynchronously from Node.js streams is done via callbacks:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，从Node.js流异步读取是通过回调完成的：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That is, the stream is in control and pushes data to the reader.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，流控制着并推动数据到读取器。
- en: '[45.3.2 Node.js streams: async via async iteration (pull)](#nodejs-streams-async-via-async-iteration-pull)'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[45.3.2 Node.js 流：通过异步迭代（拉取）](#nodejs-streams-async-via-async-iteration-pull)'
- en: 'Starting with Node.js 10, we can also use asynchronous iteration to read from
    streams:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Node.js 10 开始，我们也可以使用异步迭代从流中读取：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This time, the reader is in control and pulls data from the stream.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，读取器处于控制地位，并从流中拉取数据。
- en: '[45.3.3 Example: from chunks to lines](#example-from-chunks-to-lines)'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[45.3.3 示例：从数据块到行](#example-from-chunks-to-lines)'
- en: 'Node.js streams contain *chunks* (arbitrarily long pieces) of data. The following
    asynchronous generator converts an async iterable over chunks to an async iterable
    over lines:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 流包含 *数据块*（任意长度的数据片段）。以下异步生成器将异步可迭代的数据块转换为异步可迭代的行：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let’s apply `chunksToLines()` to an async iterable over chunks (as produced
    by `chunkIterable()`):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 `chunksToLines()` 应用到一个异步可迭代的数据块上（由 `chunkIterable()` 生成）：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that we have an asynchronous iterable over lines, we can use the solution
    of a previous exercise, `numberLines()`, to number those lines:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了异步可迭代的行，我们可以使用之前练习中的解决方案 `numberLines()` 来编号这些行：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
