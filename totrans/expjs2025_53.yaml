- en: 45 Asynchronous iteration ES2018
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_async-iteration.html](https://exploringjs.com/js/book/ch_async-iteration.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[45.1 Basic asynchronous iteration](#basic-asynchronous-iteration)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[45.1.1 Protocol: async iteration](#async-iteration-protocol)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[45.1.2 Using async iteration directly](#using-async-iteration-directly)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[45.1.3 Using async iteration via `for-await-of`](#for-await-of)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[45.2 Asynchronous generators](#async-generators)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[45.2.1 Example: creating an async iterable via an async generator](#example-creating-an-async-iterable-via-an-async-generator)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[45.2.2 Example: converting a sync iterable to an async iterable](#example-converting-a-sync-iterable-to-an-async-iterable)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[45.2.3 Example: converting an async iterable to an Array](#asyncIterableToArray)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[45.2.4 Example: transforming an async iterable](#example-transforming-an-async-iterable)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[45.2.5 Example: mapping over asynchronous iterables](#example-mapping-over-asynchronous-iterables)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[45.3 Async iteration over Node.js streams](#async-iteration-over-nodejs-streams)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[45.3.1 Node.js streams: async via callbacks (push)](#nodejs-streams-async-via-callbacks-push)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[45.3.2 Node.js streams: async via async iteration (pull)](#nodejs-streams-async-via-async-iteration-pull)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[45.3.3 Example: from chunks to lines](#example-from-chunks-to-lines)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Icon “reading”](../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png) **Required
    knowledge**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this chapter, you should be familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Promises](ch_promises.html#ch_promises)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Async functions](ch_async-functions.html#ch_async-functions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[45.1 Basic asynchronous iteration](#basic-asynchronous-iteration)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[45.1.1 Protocol: async iteration](#async-iteration-protocol)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To understand how asynchronous iteration works, let’s first revisit [synchronous
    iteration](ch_sync-iteration.html#ch_sync-iteration). It comprises the following
    interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: An `Iterable` is a data structure whose contents can be accessed via iteration.
    It is a factory for iterators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `Iterator` is a factory for iteration results that we retrieve by calling
    the method `.next()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each `IterationResult` contains the iterated `.value` and a boolean `.done`
    that is `true` after the last element and `false` before.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the protocol for asynchronous iteration, we only want to change one thing:
    the values produced by `.next()` should be delivered asynchronously. There are
    two conceivable options:'
  prefs: []
  type: TYPE_NORMAL
- en: The `.value` could contain a `Promise<T>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.next()` could return `Promise<IteratorResult<T>>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, the question is whether to wrap just values or whole iterator
    results in Promises.
  prefs: []
  type: TYPE_NORMAL
- en: It has to be the latter because when `.next()` returns a result, it starts an
    asynchronous computation. Whether or not that computation produces a value or
    signals the end of the iteration can only be determined after it is finished.
    Therefore, both `.done` and `.value` need to be wrapped in a Promise.
  prefs: []
  type: TYPE_NORMAL
- en: The interfaces for async iteration look as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The only difference to the synchronous interfaces is the return type of `.next()`
    (line A).
  prefs: []
  type: TYPE_NORMAL
- en: '[45.1.2 Using async iteration directly](#using-async-iteration-directly)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following code uses the asynchronous iteration protocol directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In line A, we create an asynchronous iterable over the value `'a'` and `'b'`.
    We’ll see an implementation of `syncToAsyncIterable()` later.
  prefs: []
  type: TYPE_NORMAL
- en: We call `.next()` in line B, line C and line D. Each time, we use `.then()`
    to unwrap the Promise and `assert.deepEqual()` to check the unwrapped value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simplify this code if we use an async function. Now we unwrap Promises
    via `await` and the code looks almost like we are doing synchronous iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[45.1.3 Using async iteration via `for-await-of`](#for-await-of)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The asynchronous iteration protocol is not meant to be used directly. One of
    the language constructs that supports it is the `for-await-of` loop, which is
    an asynchronous version of the `for-of` loop. It can be used in async functions
    and *async generators* (which are introduced later in this chapter). This is an
    example of `for-await-of` in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`for-await-of` is relatively flexible. In addition to asynchronous iterables,
    it also supports synchronous iterables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And it supports synchronous iterables over values that are wrapped in Promises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercises:
    Asynchronous iteration**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Converting an async iterable to an Array: `exercises/async-iteration/async_iterable_to_array_test.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Warning: We’ll soon see the solution for this exercise in this chapter.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implementing an asynchronously iterable queue: `exercises/async-iteration/async-iter-queue_test.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[45.2 Asynchronous generators](#async-generators)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Asynchronous generators are very similar to synchronous generators; especially
    the operators `yield` and `yield*`. Therefore, those are not explained here. See
    [the chapter on synchronous generators](ch_sync-generators.html#ch_sync-generators)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'An asynchronous generator is two things at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An async function (input): We can use `await` and `for-await-of` to retrieve
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A generator that returns an asynchronous iterable (output): We can use `yield`
    and `yield*` to produce data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore, the input and output of an asynchronous generator are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The input can be:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: synchronous (single values, sync iterables)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: asynchronous (Promises, async iterables)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The output is an asynchronous iterator (that is also iterable).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[45.2.1 Example: creating an async iterable via an async generator](#example-creating-an-async-iterable-via-an-async-generator)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example. The following code creates an async iterable with
    three numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Does the result of `yield123()` conform to the async iteration protocol?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[45.2.2 Example: converting a sync iterable to an async iterable](#example-converting-a-sync-iterable-to-an-async-iterable)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following asynchronous generator converts a synchronous iterable to an asynchronous
    iterable. It implements the function `syncToAsyncIterable()` that we have used
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: The input is synchronous in this case (no `await` is needed).'
  prefs: []
  type: TYPE_NORMAL
- en: '[45.2.3 Example: converting an async iterable to an Array](#asyncIterableToArray)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following function is a solution to a previous exercise. It converts an
    async iterable to an Array (think spreading, but for async iterables instead of
    sync iterables).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we can’t use an async generator in this case: We get our input via
    `for-await-of` and return an Array wrapped in a Promise. The latter requirement
    rules out async generators.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a test for `asyncIterableToArray()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note the `await` in line A, which is needed to unwrap the Promise returned by
    `asyncIterableToArray()`. In order for `await` to work, this code fragment must
    be run inside an async function.
  prefs: []
  type: TYPE_NORMAL
- en: '[45.2.4 Example: transforming an async iterable](#example-transforming-an-async-iterable)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s implement an async generator that produces a new async iterable by transforming
    an existing async iterable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To test this function, we use `asyncIterableToArray()` from the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Async generators**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Warning: We’ll soon see the solution for this exercise in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/async-iteration/number_lines_test.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[45.2.5 Example: mapping over asynchronous iterables](#example-mapping-over-asynchronous-iterables)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As a reminder, this is how to map over synchronous iterables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The asynchronous version looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note how similar the sync implementation and the async implementation are. The
    only two differences are the `async` in line A and the `await` in line B. That
    is comparable to going from a synchronous function to an asynchronous function
    – we only need to add the keyword `async` and the occasional `await`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test `mapAsync()`, we use the helper function `asyncIterableToArray()` [(shown
    earlier in this chapter)](#asyncIterableToArray):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we `await` to unwrap a Promise (line A) and this code fragment must
    run inside an async function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    `filterAsyncIter()`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/async-iteration/filter_async_iter_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[45.3 Async iteration over Node.js streams](#async-iteration-over-nodejs-streams)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to the asynchronous nature of data streams, asynchronous iteration works
    well as an abstraction for them. In particular, async generators are an elegant
    tool for *transforming* data streams (where both input and output are streams).
  prefs: []
  type: TYPE_NORMAL
- en: '[45.3.1 Node.js streams: async via callbacks (push)](#nodejs-streams-async-via-callbacks-push)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Traditionally, reading asynchronously from Node.js streams is done via callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That is, the stream is in control and pushes data to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: '[45.3.2 Node.js streams: async via async iteration (pull)](#nodejs-streams-async-via-async-iteration-pull)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Starting with Node.js 10, we can also use asynchronous iteration to read from
    streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This time, the reader is in control and pulls data from the stream.
  prefs: []
  type: TYPE_NORMAL
- en: '[45.3.3 Example: from chunks to lines](#example-from-chunks-to-lines)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Node.js streams contain *chunks* (arbitrarily long pieces) of data. The following
    asynchronous generator converts an async iterable over chunks to an async iterable
    over lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s apply `chunksToLines()` to an async iterable over chunks (as produced
    by `chunkIterable()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have an asynchronous iterable over lines, we can use the solution
    of a previous exercise, `numberLines()`, to number those lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
