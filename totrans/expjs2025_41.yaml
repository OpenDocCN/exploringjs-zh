- en: 34 Arrays (Array)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_arrays.html](https://exploringjs.com/js/book/ch_arrays.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[34.1 Cheat sheet: Arrays](#cheat-sheet-arrays)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.1.1 Using Arrays](#using-arrays)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.1.2 The most commonly used Array methods](#the-most-commonly-used-array-methods)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.2 Ways of using Arrays: fixed layout vs. sequence](#arrays-fixed-layout-vs-sequence)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.3 Basic Array operations](#basic-array-operations)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.3.1 Creating, reading, writing Arrays](#array-literals)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.3.2 The `.length` of an Array](#array-length)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.3.3 Referring to elements via negative indices](#referring-to-elements-via-negative-indices)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.3.4 Clearing Arrays](#clearing-arrays)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.3.5 Spreading into Array literals](#spreading-into-array-literals)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.3.6 Arrays: listing indices and entries](#arrays-listing-indices-and-entries)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.3.7 Checking if a value is an Array: `Array.isArray()`](#checking-if-a-value-is-an-array-arrayisarray)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.4 `for-of` and Arrays](#for-of-arrays)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.4.1 `for-of`: iterating over elements](#forof-iterating-over-elements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.4.2 `for-of`: iterating over indices](#forof-iterating-over-indices)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.4.3 `for-of`: iterating over [index, element] pairs](#forof-iterating-over-index-element-pairs)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.5 Array-like objects](#array-like-objects)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.6 Converting iterables, iterators and Array-like values to Arrays](#converting-to-array)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.6.1 Converting iterables to Arrays via spreading (`...`)](#converting-iterables-to-arrays-via-spreading-)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.6.2 Converting iterators to Arrays via `.toArray()` ^(ES2025)](#converting-iterators-to-arrays-via-toarray-es2025)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.6.3 Converting iterables and Array-like objects to Arrays via `Array.from()`](#Array.from)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.7 Copying Arrays](#copying-arrays)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.8 Creating and filling Arrays with arbitrary lengths](#filling-arrays)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.8.1 Creating an Array and adding elements later](#creating-array-adding-elements-later)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.8.2 Creating an Array filled with a primitive value](#creating-array-with-primitives)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.8.3 Creating an Array filled with objects](#creating-array-with-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.8.4 Creating an Array with a range of integers](#creating-array-with-range-of-integers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.8.5 Typed Arrays work well if the elements are all integers or all floats](#typed-arrays-work-well-if-the-elements-are-all-integers-or-all-floats)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.9 Multidimensional Arrays](#multidimensional-arrays)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.10 Arrays are actually dictionaries (advanced)](#arrays-are-dictionaries)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.10.1 Array indices are (slightly special) property keys](#array-indices)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.10.2 Arrays can have holes](#array-holes)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.11 Destructive vs. non-destructive Array operations](#array-operations-destructive-vs-non-destructive)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.11.1 How to make destructive Array methods non-destructive](#how-to-make-destructive-array-methods-nondestructive)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.11.2 Non-destructive versions of `.reverse()`, `.sort()`, `.splice()` ^(ES2023)](#nondestructive-versions-of-reverse-sort-splice-es2023)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.12 Adding and removing elements at either end of an Array](#adding-and-removing-elements-at-either-end-of-an-array)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.12.1 Destructively adding and removing elements at either end of an Array](#array-push-pop-shift-unshift)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.12.2 Non-destructively prepending and appending elements](#nondestructively-prepending-and-appending-elements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.13 Array methods that accept element callbacks](#array-element-callbacks)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.14 Transforming with element callbacks: `.map()`, `.filter()`, `.flatMap()`](#transforming-with-element-callbacks-map-filter-flatmap)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.14.1 `.map()`: Each output element is derived from its input element](#map-each-output-element-is-derived-from-its-input-element)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.14.2 `.filter()`: Only keep some of the elements](#filter-only-keep-some-of-the-elements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.14.3 `.flatMap()`: Each input element produces zero or more output elements
    ^(ES2019)](#Array.prototype.flatMap)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.15 `.reduce()`: computing a summary for an Array](#Array.prototype.reduce)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.15.1 An overview of how `.reduce()` works](#an-overview-of-how-reduce-works)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.15.2 What happens if we omit `init`?](#what-happens-if-we-omit-init)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.15.3 `.reduceRight()`: the end-to-start version of `.reduce()`](#Array.prototype.reduceRight)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.16 `.sort()`: sorting Arrays](#Array.prototype.sort)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.16.1 Customizing the sort order](#customizing-array-sorting)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.16.2 Sorting numbers](#sorting-arrays-with-numbers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.16.3 Sorting human-language strings](#sorting-humanlanguage-strings)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.16.4 Sorting objects](#sorting-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.17 Grouping Array elements](#grouping-array-elements)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18 Quick reference: `Array`](#quickref-Array)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.1 `new Array()`](#new-array)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.2 `Array.*`](#array)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.3 `Array.prototype.*`: getting, setting and visiting single elements](#arrayprototype-getting-setting-and-visiting-single-elements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.4 `Array.prototype.*`: keys and values](#arrayprototype-keys-and-values)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.5 `Array.prototype.*`: destructively adding or removing elements at
    either end of an Array](#arrayprototype-destructively-adding-or-removing-elements-at-either-end-of-an-array)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.6 `Array.prototype.*`: combining, extracting and changing sequences
    of elements](#arrayprototype-combining-extracting-and-changing-sequences-of-elements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.7 `Array.prototype.*`: searching for elements](#arrayprototype-searching-for-elements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.8 `Array.prototype.*`: filtering and mapping](#arrayprototype-filtering-and-mapping)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.9 `Array.prototype.*`: computing summaries](#arrayprototype-computing-summaries)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.10 `Array.prototype.*`: converting to string](#arrayprototype-converting-to-string)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.11 `Array.prototype.*`: sorting and reversing](#arrayprototype-sorting-and-reversing)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.12 Sources of the quick reference](#sources-of-the-quick-reference)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.1 Cheat sheet: Arrays](#cheat-sheet-arrays)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript Arrays are a very flexible data structure and used as lists, stacks,
    queues, tuples (e.g. pairs), and more.
  prefs: []
  type: TYPE_NORMAL
- en: Some Array-related operations destructively change Arrays. Others non-destructively
    produce new Arrays with the changes applied to a copy of the original content.
  prefs: []
  type: TYPE_NORMAL
- en: '[34.1.1 Using Arrays](#using-arrays)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Creating an Array, reading and writing elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The length of an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding elements destructively via `.push()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding elements non-destructively via spreading (`...`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Looping over elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Looping over index-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[34.1.2 The most commonly used Array methods](#the-most-commonly-used-array-methods)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This section demonstrates a few common Array methods. There is [a more comprehensive
    quick reference](#quickref-Array) at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Destructively adding or removing an Array element at the start or the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finding Array elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Transforming Arrays (creating new ones without changing the originals):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Copying parts of an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Concatenating the strings in an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`.sort()` sorts its receiver and returns it (if we don’t want to change the
    receiver, we can use [`.toSorted()`](#qref-Array.prototype.toSorted)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[34.2 Ways of using Arrays: fixed layout vs. sequence](#arrays-fixed-layout-vs-sequence)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These are the two most common ways of using Arrays in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixed-layout Arrays: Used this way, Arrays have a fixed number of indexed elements.
    Each of those elements can have a different type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sequence Arrays: Used this way, Arrays have a variable number of indexed elements.
    Each of those elements has the same type. Sequence Arrays are very flexible; we
    can use them as (traditional) arrays, stacks, and queues. We’ll see how later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example of the difference between the two ways, consider the Array returned
    by `Object.entries()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It is a sequence of *pairs* – fixed-layout Arrays with a length of two.
  prefs: []
  type: TYPE_NORMAL
- en: '[34.3 Basic Array operations](#basic-array-operations)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[34.3.1 Creating, reading, writing Arrays](#array-literals)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The best way to create an Array is via an *Array literal*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The Array literal starts and ends with square brackets `[]`. It creates an
    Array with three *elements*: `''a''`, `''b''`, and `''c''`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A comma after the last element is allowed and ignored in an Array literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To read an Array element, we put an index in square brackets (indices start
    at zero):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To change an Array element, we assign to an Array with an index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The range of Array indices is 32 bits (excluding the maximum length): [0, 2^(32)−1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[34.3.2 The `.length` of an Array](#array-length)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Every Array has a property `.length` that can be used to both read and change(!)
    the number of elements in an Array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The length of an Array is always the highest index plus one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we write to the Array at the index of the length, we append an element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we set `.length`, we prune the Array and remove elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To (destructively) append an element, we can also use the Array method `.push()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Removing empty lines via `.push()`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/arrays/remove_empty_lines_push_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[34.3.3 Referring to elements via negative indices](#referring-to-elements-via-negative-indices)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Most Array methods support negative indices. If an index is negative, it is
    added to the length of an Array to produce a usable index. Therefore, the following
    two invocations of `.slice()` are equivalent: They both copy `arr` starting at
    the last element.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[34.3.3.1 `.at()`: reading single elements (supports negative indices) ^(ES2022)](#Array.prototype.at)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The Array method `.at()` returns the element at a given index. It supports
    positive and negative indices (`-1` refers to the last element, `-2` refers to
    the second-last element, etc.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, the bracket operator `[]` does not support negative indices (and
    can’t be changed because that would break existing code). It interprets them as
    keys of non-element properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[34.3.4 Clearing Arrays](#clearing-arrays)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can clear an Array by setting its `.length` to zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also assign a new empty Array to the variable storing the Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The latter approach has the advantage of not affecting other locations that
    point to the same Array. If, however, we do want to reset a shared Array for everyone,
    then we need the former approach.
  prefs: []
  type: TYPE_NORMAL
- en: '[34.3.5 Spreading into Array literals](#spreading-into-array-literals)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside an Array literal, a *spread element* consists of three dots (`...`)
    followed by an expression. It results in the expression being evaluated and then
    iterated over. Each iterated value becomes an additional Array element – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'That means we can convert any iterable to an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Arrays are iterable, we can use spreading to copy them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Spreading is also convenient for concatenating Arrays (and other iterables)
    into Arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to spreading using iteration, it only works if the value is iterable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[34.3.6 Arrays: listing indices and entries](#arrays-listing-indices-and-entries)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Method `.keys()` lists the indices of an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`.keys()` returns an iterator. In line A, we convert that iterator to an Array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing Array indices is different from listing properties. The former produces
    numbers; the latter produces stringified numbers (in addition to non-index property
    keys):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the object property `arr.prop` shows up in the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Method `.entries()` lists the contents of an Array as [index, element] pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`Object.entries()` lists [property key, property value] pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Once again we see `arr.prop` in the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[34.3.7 Checking if a value is an Array: `Array.isArray()`](#checking-if-a-value-is-an-array-arrayisarray)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Array.isArray()` checks if a value is an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use `instanceof`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `instanceof` has one downside: It doesn’t work if a value comes from
    another *realm*. Roughly, a realm is an instance of JavaScript’s global scope.
    Some realms are isolated from each other (e.g., [Web Workers](ch_async-js.html#web-workers)
    in browsers), but there are also realms between which we can move data – for example,
    same-origin iframes in browsers. `x instanceof Array` checks the prototype chain
    of `x` and therefore returns `false` if `x` is an Array from another realm.'
  prefs: []
  type: TYPE_NORMAL
- en: '`typeof` considers Arrays to be objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[34.4 `for-of` and Arrays](#for-of-arrays)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already encountered the `for-of` loop earlier in this book. This section
    briefly recaps how to use it for Arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[34.4.1 `for-of`: iterating over elements](#forof-iterating-over-elements)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following `for-of` loop iterates over the elements of an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[34.4.2 `for-of`: iterating over indices](#forof-iterating-over-indices)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This `for-of` loop iterates over the indices of an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[34.4.3 `for-of`: iterating over [index, element] pairs](#forof-iterating-over-index-element-pairs)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following `for-of` loop iterates over [index, element] pairs. Destructuring
    (described [later](ch_destructuring.html#ch_destructuring)), gives us convenient
    syntax for setting up `index` and `element` in the head of `for-of`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[34.5 Array-like objects](#array-like-objects)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some operations that work with Arrays require only the bare minimum: values
    must only be *Array-like*. An Array-like value is an object with the following
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.length`: holds the length of the Array-like object. If this property is missing,
    the value `0` is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[0]`: holds the element at index 0 (etc.). Note that if we use numbers as
    property names, they are always coerced to strings. Therefore, `[0]` retrieves
    the value of the property whose key is `''0''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, `Array.from()` accepts Array-like objects and converts them to
    Arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The TypeScript interface for Array-like objects is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **Array-like
    objects are relatively rare in modern JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: Array-like objects used to be more common before ES6; now we don’t see them
    very often.
  prefs: []
  type: TYPE_NORMAL
- en: '[34.6 Converting iterables, iterators and Array-like values to Arrays](#converting-to-array)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section we explore how we can convert various values to Array:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting iterables to Arrays via spreading (`...`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting iterators to Arrays via `.toArray()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting iterables and Array-like objects to Arrays via `Array.from()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[34.6.1 Converting iterables to Arrays via spreading (`...`)](#converting-iterables-to-arrays-via-spreading-)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside an Array literal, spreading via `...` converts any iterable object into
    a series of Array elements. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[34.6.2 Converting iterators to Arrays via `.toArray()` ^(ES2025)](#converting-iterators-to-arrays-via-toarray-es2025)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we have an iterator, we can use method `.toArray()` to store its values
    in an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of `Iterator.from()` we can also use a method that returns an iterator
    (such as `.keys()`, `.values()` and `.entries()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[34.6.3 Converting iterables and Array-like objects to Arrays via `Array.from()`](#Array.from)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Array.from()` can be used in two modes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[34.6.3.1 Mode 1 of `Array.from()`: converting](#mode-1-of-arrayfrom-converting)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The first mode has the following type signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Interface `Iterable` is shown [in the chapter on synchronous iteration](ch_sync-iteration.html#iterable-iterator-iteratorresult).
    Interface `ArrayLike` appeared [earlier in this chapter](#array-like-objects).
  prefs: []
  type: TYPE_NORMAL
- en: 'With a single parameter, `Array.from()` converts anything iterable or Array-like
    to an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[34.6.3.2 Mode 2 of `Array.from()`: converting and mapping](#mode-2-of-arrayfrom-converting-and-mapping)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The second mode of `Array.from()` involves two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In this mode, `Array.from()` does several things:'
  prefs: []
  type: TYPE_NORMAL
- en: It iterates over `iterable`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It calls `mapFunc` with each iterated value. The optional parameter `thisArg`
    specifies a `this` for `mapFunc`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It applies `mapFunc` to each iterated value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It collects the results in a new Array and returns it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In other words: we are going from an iterable with elements of type `T` to
    an Array with elements of type `U`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[34.7 Copying Arrays](#copying-arrays)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code shows five ways of copying the Array `arr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Only `structuredClone()` produces a *deep copy*. In each other case, the copy
    is *shallow*: It contains copies of the [index, element] entries but the elements
    themselves are shared with the original Array. For more information, including
    the limitations of `structuredClone()`, see [“Copying objects: spreading vs. `Object.assign()`
    vs. `structuredClone()`” (§30.5)](ch_objects.html#copying-objects).'
  prefs: []
  type: TYPE_NORMAL
- en: '[34.8 Creating and filling Arrays with arbitrary lengths](#filling-arrays)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The best way of creating an Array is via an Array literal. However, we can’t
    always use one: The Array may be too large, we may not know its length during
    development, or we may want to keep its length flexible. Then I recommend the
    following techniques for creating, and possibly filling, Arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: '[34.8.1 Creating an Array and adding elements later](#creating-array-adding-elements-later)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The most common technique for creating an Array and adding elements later,
    is to start with an empty Array and push values into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[34.8.2 Creating an Array filled with a primitive value](#creating-array-with-primitives)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following code creates an Array that is filled with a primitive value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`.fill()` replaces each Array element or hole with a given value. We use it
    to fill an Array that has 3 holes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note that the result has [three *holes* (empty slots)](#array-holes) – the last
    comma in an Array literal is always ignored.
  prefs: []
  type: TYPE_NORMAL
- en: '[34.8.3 Creating an Array filled with objects](#creating-array-with-objects)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we use `.fill()` with an object, then each Array element will refer to this
    same single object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'How can we fix this? We can use [`Array.from()`](#Array.from):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `Array.from()` with two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: extracts the elements of the first argument (which must be iterable or Array-like),
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: maps them via the callback in the second argument and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: returns the result in an Array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In contrast to `.fill()`, which reuses the same object multiple times, the previous
    code creates a new object for each element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we have used `.map()` in this case? Unfortunately not because `.map()`
    ignores but preserves holes (whereas `Array.from()` treats them as `undefined`
    elements):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'For large sizes, the temporary Array in the first argument can consume quite
    a bit of memory. The following approach doesn’t have this downside but is less
    self-descriptive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Instead of a temporary Array, we are using a temporary [Array-like object](#array-like-objects).
  prefs: []
  type: TYPE_NORMAL
- en: '[34.8.4 Creating an Array with a range of integers](#creating-array-with-range-of-integers)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To create an Array with a range of integers, we use `Array.from()` similarly
    to how we did in the previous subsection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an alternative, slightly hacky technique for creating integer ranges
    that start at zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This works because `.keys()` treats [*holes*](#array-holes) like `undefined`
    elements and lists their indices.
  prefs: []
  type: TYPE_NORMAL
- en: '[34.8.5 Typed Arrays work well if the elements are all integers or all floats](#typed-arrays-work-well-if-the-elements-are-all-integers-or-all-floats)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When dealing with Arrays of integers or floats, we should consider [*Typed Arrays*](ch_typed-arrays.html#ch_typed-arrays),
    which were created for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '[34.9 Multidimensional Arrays](#multidimensional-arrays)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript does not have real multidimensional Arrays; we need to resort to
    Arrays whose elements are Arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[34.10 Arrays are actually dictionaries (advanced)](#arrays-are-dictionaries)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we examine how exactly Arrays store their elements: in properties.
    We usually don’t need to know that but it helps with understanding a few rarer
    Array phenomena.'
  prefs: []
  type: TYPE_NORMAL
- en: '[34.10.1 Array indices are (slightly special) property keys](#array-indices)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’d think that Array elements are special because we are accessing them via
    numbers. But the square brackets operator `[]` for doing so is the same operator
    that is used for accessing properties. It coerces any non-symbol value to a string.
    Therefore, Array elements are (almost) normal properties (line A) and it doesn’t
    matter if we use numbers or strings as indices (line B and line C):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Property keys (strings!) that are used for Array elements are called [*indices*](https://tc39.es/ecma262/#integer-index).
    A string `str` is an index if converting it to a 32-bit unsigned integer and back
    results in the original value. Written as a formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[34.10.1.1 Internally, JavaScript engines optimize how Arrays are managed](#internally-javascript-engines-optimize-how-arrays-are-managed)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When using JavaScript and in the ECMAScript specification, Array elements are
    properties and Array indices are string-valued property keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, internally, virtually all JavaScript engines optimize how Arrays are
    managed: They store their elements sequentially and used indices as numeric offsets.
    Engines may switch to a more dictionary-like representation if the elements of
    an Array are not contiguous – if there are holes between them. More on holes in
    Arrays soon.'
  prefs: []
  type: TYPE_NORMAL
- en: '[34.10.1.2 Listing indices](#listing-indices)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When listing property keys, [indices are treated specially](ch_objects.html#order-of-properties)
    – they always come first and are sorted like numbers (`''2''` comes before `''10''`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `.keys()` and `.entries()` treat Array indices as numbers and ignore
    non-index properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We used [`Array.from()`](#Array.from) to convert the iterables returned by `.keys()`
    and `.entries()` to Arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[34.10.2 Arrays can have holes](#array-holes)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We distinguish two kinds of Arrays in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: An Array `arr` is *dense* if all indices `i`, with 0 ≤ `i` < `arr.length`, exist.
    That is, the indices form a contiguous range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Array is *sparse* if the range of indices has *holes* in it. That is, some
    indices are missing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays can be sparse in JavaScript because Arrays are actually dictionaries
    from indices to values.
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Recommendation:
    avoid holes**'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have only seen dense Arrays and it’s indeed recommended to avoid
    holes: They make our code more complicated and are not handled consistently by
    Array methods. Additionally, JavaScript engines optimize dense Arrays, making
    them faster.'
  prefs: []
  type: TYPE_NORMAL
- en: '[34.10.2.1 Creating Array holes](#creating-array-holes)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can create holes by skipping indices when assigning elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In line A, we are using `Object.keys()` because `arr.keys()` treats holes as
    if they were `undefined` elements and does not reveal them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of creating holes is to skip elements in Array literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add holes at the end by increasing `.length`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Deleting Array elements creates holes, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[34.10.2.2 How do Array operations treat holes?](#how-do-array-operations-treat-holes)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Alas, there are many different ways in which Array operations treat holes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some Array operations remove holes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Some Array operations ignore holes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Some Array operations ignore but preserve holes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Some Array operations treat holes as `undefined` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '`Object.keys()` works differently than `.keys()` (strings vs. numbers, holes
    don’t have keys):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: There is no common rule to remember here. If it ever matters how an Array operation
    treats holes, the best approach is to do a quick test in a console.
  prefs: []
  type: TYPE_NORMAL
- en: '[34.11 Destructive vs. non-destructive Array operations](#array-operations-destructive-vs-non-destructive)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some Array operations are *destructive*: They change the Array they operate
    on – e.g., setting an element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Other Array operations are *non-destructive*: They produce new Arrays that
    contain the desired changes and don’t touch the originals – e.g., method `.with()`
    is the non-destructive version of setting elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[34.11.1 How to make destructive Array methods non-destructive](#how-to-make-destructive-array-methods-nondestructive)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These are three common destructive Array methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.reverse()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.sort()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.splice()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll get to [`.sort()`](#Array.prototype.sort) and [`.splice()`](#qref-Array.prototype.splice)
    later in this chapter. `.reverse()` rearranges an Array so that the order of its
    elements is reversed: The element that was previously last now comes first; the
    second-last element comes second; etc.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'To prevent a destructive method from changing an Array, we can make a copy
    before using it – e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Another option is to use the non-destructive version of a destructive method.
    That’s what we’ll explore next.
  prefs: []
  type: TYPE_NORMAL
- en: '[34.11.2 Non-destructive versions of `.reverse()`, `.sort()`, `.splice()` ^(ES2023)](#nondestructive-versions-of-reverse-sort-splice-es2023)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These are the non-destructive versions of the destructive Array methods `.reverse()`,
    `.sort()` and `.splice()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.toReversed(): Array`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.toSorted(compareFn): Array`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.toSpliced(start, deleteCount, ...items): Array`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have used `.reverse()` in the previous subsection. Its non-destructive version
    is used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[34.12 Adding and removing elements at either end of an Array](#adding-and-removing-elements-at-either-end-of-an-array)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[34.12.1 Destructively adding and removing elements at either end of an Array](#array-push-pop-shift-unshift)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: JavaScript’s `Array` is quite flexible and more like a combination of array,
    stack, and queue. Let’s explore ways of destructively adding and removing Array
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: '`.push()` adds elements at the end of an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[Spread arguments (`...`)](ch_callables.html#spread-arguments) are a feature
    of function calls. In line A, we used it to push an Array.'
  prefs: []
  type: TYPE_NORMAL
- en: '`.pop()` is the inverse of `.push()` and removes elements at the end of an
    Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '`.shift()` removes elements at the beginning of an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '`.unshift()` is the inverse of `.shift()` and adds element at the beginning
    of an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Tip: remembering
    the functionality of `push`, `pop`, `shift` and `unshift`**'
  prefs: []
  type: TYPE_NORMAL
- en: 'My recommendation is to focus on remembering the following two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.push()` is the most frequently used of the four methods. One common use case
    is to assemble an output Array: We first push the element at index 0; then the
    element at index 1; etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.shift()` can be used to consume the elements of an Array: The first time
    we shift, we get the element at index 0; then the element at index 1; etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remaining two methods, `pop` and `unshift`, are inverses of these two methods.
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Implementing a queue via an Array**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/arrays/queue_via_array_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[34.12.2 Non-destructively prepending and appending elements](#nondestructively-prepending-and-appending-elements)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Spread elements (`...`)](#spreading-into-array-literals) are a feature of
    Array literals. In this section, we’ll use it to non-destructively prepend and
    append elements to Arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Non-destructive prepending:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Non-destructive appending:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[34.13 Array methods that accept element callbacks](#array-element-callbacks)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following Array methods accept callbacks to which they feed Array elements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.find`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.findLast`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.findIndex`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.findLastIndex`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transforming:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.map`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.flatMap`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.filter`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Computing summaries of Arrays:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.every`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.some`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.reduce`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.reduceRight`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Looping over Arrays:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.forEach`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Element callbacks have type signatures that look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, the callback gets three parameters (it is free to ignore any of them):'
  prefs: []
  type: TYPE_NORMAL
- en: '`value` is the most important one. This parameter holds the Array element that
    is currently being processed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index` can additionally tell the callback what the index of the element is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array` points to the current Array (the receiver of the method call). Some
    algorithms need to refer to the whole Array – e.g., to search elsewhere additional
    data. This parameter lets us write reusable callbacks for such algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What the callback is expected to return depends on the method it is passed
    to. Possibilities include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.map()` fills its result with the values returned by its callback:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.find()` returns the first Array element for which its callback returns `true`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[34.14 Transforming with element callbacks: `.map()`, `.filter()`, `.flatMap()`](#transforming-with-element-callbacks-map-filter-flatmap)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we explore methods that accept [element callbacks](#array-element-callbacks)
    which tell them how to transform an input Array into an output Array.
  prefs: []
  type: TYPE_NORMAL
- en: '[34.14.1 `.map()`: Each output element is derived from its input element](#map-each-output-element-is-derived-from-its-input-element)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Each element of the output Array is the result of applying the callback to
    the corresponding input element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '`.map()` can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Numbering lines via `.map()`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/arrays/number_lines_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[34.14.2 `.filter()`: Only keep some of the elements](#filter-only-keep-some-of-the-elements)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Array method `.filter()` returns an Array collecting all elements for which
    the callback returns a truthy value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '`.filter()` can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Removing empty lines via `.filter()`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/arrays/remove_empty_lines_filter_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[34.14.3 `.flatMap()`: Each input element produces zero or more output elements
    ^(ES2019)](#Array.prototype.flatMap)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The type signature of `Array<T>.prototype.flatMap()` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `.map()` and `.flatMap()` take a function `callback` as a parameter that
    controls how an input Array is translated to an output Array:'
  prefs: []
  type: TYPE_NORMAL
- en: With `.map()`, each input Array element is translated to exactly one output
    element. That is, `callback` returns a single value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `.flatMap()`, each input Array element is translated to zero or more output
    elements. That is, `callback` returns an Array of values (it can also return non-Array
    values, but that is rare).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is `.flatMap()` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: We’ll consider use cases next, before exploring how this method could be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '[34.14.3.1 Use case: filtering and mapping at the same time](#use-case-filtering-and-mapping-at-the-same-time)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The result of the Array method `.map()` always has the same length as the Array
    it is invoked on. That is, its callback can’t skip Array elements it isn’t interested
    in. The ability of `.flatMap()` to do so is useful in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say, we got the following result from [`Promise.allSettled()`](ch_promises.html#Promise.allSettled):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `.flatMap()` to extract just the values or just the errors from
    `results`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[34.14.3.2 Use case: mapping single input values to multiple output values](#use-case-mapping-single-input-values-to-multiple-output-values)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Array method `.map()` maps each input Array element to one output element.
    But what if we want to map it to multiple output elements?
  prefs: []
  type: TYPE_NORMAL
- en: 'That becomes necessary in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to convert an Array of strings to an Array of Unicode characters (code
    points). The following function achieves that via `.flatMap()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[34.14.3.3 A simple implementation](#a-simple-implementation)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can implement `.flatMap()` as follows. Note: This implementation is simpler
    than the built-in version, which, for example, performs more checks.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercises:
    `.flatMap()`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/arrays/convert_to_numbers_test.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exercises/arrays/replace_objects_test.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[34.15 `.reduce()`: computing a summary for an Array](#Array.prototype.reduce)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Method `.reduce()` is a powerful tool for computing a “summary” of an Array
    `arr`. A summary can be any kind of value:'
  prefs: []
  type: TYPE_NORMAL
- en: A number. For example, the sum of all elements of `arr`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Array. For example, a copy of `arr`, where each element is twice the original
    element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduce` is also known as `foldl` (“fold left”) in functional programming and
    popular there. One caveat is that it can make code difficult to understand.'
  prefs: []
  type: TYPE_NORMAL
- en: '[34.15.1 An overview of how `.reduce()` works](#an-overview-of-how-reduce-works)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll start with an overview of how `.reduce()` works. If you find the overview
    difficult to understand, you can skip ahead to the example and come back here
    later.
  prefs: []
  type: TYPE_NORMAL
- en: '`.reduce()` has the following type signature (inside an `Array<T>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '`T` is the type of the Array elements, `U` is the type of the summary. The
    two may or may not be different. `accumulator` is just another name for “summary”.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute the summary of an Array `arr`, `.reduce()` feeds all Array elements
    to its callback one at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '`init` provides the initial value for `accumulator`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The accumulator contains the preliminary result of the reduction. When the callback
    is invoked, it combines the accumulator with the current Array element and returns
    the result. That result becomes the next accumulator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result of `.reduce()` is the final accumulator – the last result of `callback`
    after it has visited all elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In other words: `callback` does most of the work; `.reduce()` just invokes
    it in a useful manner.'
  prefs: []
  type: TYPE_NORMAL
- en: We could say that the callback folds Array elements into the accumulator. That’s
    why this operation is called “fold” in functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example: applying a binary operator to a whole Array](#example-applying-a-binary-operator-to-a-whole-array)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of `.reduce()` in action: function `addAll()` computes
    the sum of all numbers in an Array `arr`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the accumulator holds the sum of all Array elements that `callback`
    has already visited.
  prefs: []
  type: TYPE_NORMAL
- en: 'How was the result `6` derived from the Array in line A? Via the following
    invocations of `callback`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Notes:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameters are the current accumulators (starting with parameter `init`
    of `.reduce()`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameters are the current Array elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The results are the next accumulators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last result of `callback` is also the result of `.reduce()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alternatively, we could have implemented `addAll()` via a `for-of` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s hard to say which of the two implementations is “better”: the one based
    on `.reduce()` is a little more concise, while the one based on `for-of` may be
    a little easier to understand – especially if someone is not familiar with functional
    programming.'
  prefs: []
  type: TYPE_NORMAL
- en: '[34.15.2 What happens if we omit `init`?](#what-happens-if-we-omit-init)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we pass the parameter `init` to `.reduce()`, it is the initial value of
    the accumulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: If the Array is empty, the result of `.reduce()` is `init`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we omit `init` then `.reduce()` initializes the accumulator with the first
    Array element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: If the Array only has one element, the result of `.reduce()` is that element.
    If the Array is empty, `.reduce()` doesn’t have a value to return and throws an
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following interaction demonstrates the initial value of the `accumulator`
    with and without `init`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[Example: finding indices via `.reduce()`](#example-finding-indices-via-reduce)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following function is an implementation of the Array method `.indexOf()`.
    It returns the first index at which the given `searchValue` appears inside the
    Array `arr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: One limitation of `.reduce()` is that we can’t finish early. In a `for-of` loop,
    we can immediately return the result once we have found it.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example: doubling Array elements](#example-doubling-array-elements)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Function `double(arr)` returns a copy of `inArr` whose elements are all multiplied
    by 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'We modify the initial value `[]` by pushing into it. A non-destructive, more
    functional version of `double()` looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: This version is more elegant but also slower and uses more memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercises:
    `.reduce()`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`map()` via `.reduce()`: `exercises/arrays/map_via_reduce_test.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter()` via `.reduce()`: `exercises/arrays/filter_via_reduce_test.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`countMatches()` via `.reduce()`: `exercises/arrays/count_matches_via_reduce_test.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[34.15.3 `.reduceRight()`: the end-to-start version of `.reduce()`](#Array.prototype.reduceRight)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`.reduce()` visits elements from start to end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '`.reduceRight()` has the same functionality but visits elements from end to
    start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[34.16 `.sort()`: sorting Arrays](#Array.prototype.sort)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`.sort()` has the following type definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: By default, `.sort()` sorts string representations of the elements. These representations
    are compared via `<`. This operator compares code unit values (char codes) *lexicographically*
    (the first characters are most significant).
  prefs: []
  type: TYPE_NORMAL
- en: '`.sort()` sorts *in place*; it changes and returns its receiver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **`.sort()`
    is stable**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since ECMAScript 2019, sorting is guaranteed to be *stable*: If elements are
    considered equal by sorting, then sorting does not change the order of those elements
    (relative to each other).'
  prefs: []
  type: TYPE_NORMAL
- en: '[34.16.1 Customizing the sort order](#customizing-array-sorting)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can customize the sort order via the parameter `compareFunc`, which must
    return a number that is:'
  prefs: []
  type: TYPE_NORMAL
- en: negative if `a` is less than `b`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: zero if `a` is equal to `b`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: positive if `a` is greater than `b`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll see an example of a compare function in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Tip for remembering
    these rules**'
  prefs: []
  type: TYPE_NORMAL
- en: A negative number is *less than* zero (etc.).
  prefs: []
  type: TYPE_NORMAL
- en: '[34.16.2 Sorting numbers](#sorting-arrays-with-numbers)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Lexicographical sorting doesn’t work well for numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'We can fix this by writing a compare function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “question”](../Images/3decb3ca67c240d2bb04742c1f28af18.png) **Why doesn’t
    `.sort()` automatically pick the right sorting approach for numbers?**'
  prefs: []
  type: TYPE_NORMAL
- en: It would have to examine all Array elements and make sure that they are numbers
    before switching from lexicographical sorting to numeric sorting.
  prefs: []
  type: TYPE_NORMAL
- en: '[34.16.2.1 A trick for sorting numbers](#a-trick-for-sorting-numbers)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following trick uses the fact that (e.g.) the result for “less than” can
    be any negative number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we call the parameters `a` and `z` because that enables a mnemonic:
    The callback sorts ascendingly, “from `a` to `z`” (`a - z`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A downside of this trick is that we might get an arithmetic overflow if a large
    positive and a large negative number are compared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[34.16.3 Sorting human-language strings](#sorting-humanlanguage-strings)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When sorting human-language strings, we need to be aware that they are compared
    according to their code unit values (char codes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'All unaccented uppercase letters come before all unaccented lowercase letters,
    which come before all accented letters. We can use `Intl`, [the JavaScript internationalization
    API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl)
    if we want proper sorting for human languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[34.16.4 Sorting objects](#sorting-objects)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We also need to use a compare function if we want to sort objects. As an example,
    the following code shows how to sort objects by age.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Sorting objects by name**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/arrays/sort_objects_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[34.17 Grouping Array elements](#grouping-array-elements)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Grouping via `Object.groupBy()` and `Map.groupBy()` works for any iterable
    object and therefore for Arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'More information: [“Grouping iterables ^(ES2024)” (§32.8)](ch_sync-iteration.html#grouping-sync-iterables)'
  prefs: []
  type: TYPE_NORMAL
- en: '[34.18 Quick reference: `Array`](#quickref-Array)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Legend:'
  prefs: []
  type: TYPE_NORMAL
- en: '`R`: method does not change the Array (non-destructive).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`W`: method changes the Array (destructive).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Negative indices:** If a method supports negative indices that means that
    such indices are added to `.length` before they are used: `-1` becomes `this.length-1`,
    etc. In other words: `-1` refers to the last element, `-2` to the second-last
    element, etc. `.at()` is one method that supports negative indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[34.18.1 `new Array()`](#new-array)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`new Array(len = 0)` ES1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creates an Array of length `len` that only contains holes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[34.18.2 `Array.*`](#array)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Array.from(iterableOrArrayLike, mapFunc?)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Converts an iterable or [an Array-like object](#array-like-objects) to an Array.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, the input values can be translated via `mapFunc` before they are
    added to the output Array.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.of(...items)` ES6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This static method is mainly useful for subclasses of `Array`, where it serves
    as a custom Array literal:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[34.18.3 `Array.prototype.*`: getting, setting and visiting single elements](#arrayprototype-getting-setting-and-visiting-single-elements)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Array.prototype.at(index)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES2022 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Returns the Array element at `index`. If there is no such element, it returns
    `undefined`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This method is mostly equivalent to getting elements via square brackets:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'One reason for using `.at()` is that it supports [negative indices](#negative-array-indices):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.prototype.with(index, value)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES2023 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Returns the receiver of the method call, with one different element: At `index`,
    there is now `value`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This method is the non-destructive version of setting elements via square brackets.
    It supports negative indices:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.prototype.forEach(callback)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES5 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Calls `callback` for each element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A `for-of` loop is usually a better choice: it’s faster, supports `break` and
    can iterate over arbitrary iterables.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[34.18.4 `Array.prototype.*`: keys and values](#arrayprototype-keys-and-values)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Array.prototype.keys()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES6 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Returns an iterable over the keys of the receiver.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.prototype.values()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES6 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Returns an iterable over the values of the receiver.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.prototype.entries()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES6 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Returns an iterable over [index, element] pairs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[34.18.5 `Array.prototype.*`: destructively adding or removing elements at
    either end of an Array](#arrayprototype-destructively-adding-or-removing-elements-at-either-end-of-an-array)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Array.prototype.pop()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES3 | Mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Removes and returns the last element of the receiver. That is, it treats the
    end of the receiver as a stack. The opposite of `.push()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.prototype.push(...items)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES3 | Mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Adds zero or more `items` to the end of the receiver. That is, it treats the
    end of the receiver as a stack. The return value is the length of the receiver
    after the change. The opposite of `.pop()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can push an Array by spreading (`...`) it into arguments:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.prototype.shift()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES3 | Mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Removes and returns the first element of the receiver. The inverse of `.unshift()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.prototype.unshift(...items)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES3 | Mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Inserts the `items` at the beginning of the receiver and returns its length
    after this modification.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can push an Array by spreading (`...`) it into arguments:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[34.18.6 `Array.prototype.*`: combining, extracting and changing sequences
    of elements](#arrayprototype-combining-extracting-and-changing-sequences-of-elements)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Tip: telling
    `.slice()` and `.splice()` apart**'
  prefs: []
  type: TYPE_NORMAL
- en: '`.slice()` is much more commonly used. The verb “slice” is also much more common
    than the verb “splice”.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using `.splice()` is rare: Elements are more commonly (non-destructively) removed
    via `.filter()`. “Splice” has one letter more than “slice” and the method also
    does more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.concat(...items)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES3 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Returns a new Array that is the concatenation of the receiver and all `items`.
    Non-Array parameters (such as `'b'` in the following example) are treated as if
    they were Arrays with single elements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.prototype.slice(start?, end?)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES3 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Returns a new Array containing the elements of the receiver whose indices are
    between (including) `start` and (excluding) `end`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.slice()` supports [negative indices](#negative-array-indices):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It can be used to (shallowly) copy Arrays:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.prototype.splice(start?, deleteCount?, ...items)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES3 | Mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At index `start`,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'removes `deleteCount` elements (default: all remaining elements) and'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: replaces them with `items`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It returns the deleted elements.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The non-destructive version of this method is [`.toSpliced()`](#qref-Array.prototype.toSpliced).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If `deleteCount` is missing, `.splice()` deletes until the end of the Array:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`start` can be [negative](#negative-array-indices):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.prototype.toSpliced(start?, deleteCount?, ...items)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES2023 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creates a new Array where, starting at index `start`, `deleteCount` elements
    are replaced with `items`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If `deleteCount` is missing, all elements from `start` until the end are deleted.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The destructive version of this method is [`.splice()`](#qref-Array.prototype.splice).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`start` can be [negative](#negative-array-indices):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.prototype.fill(start=0, end=this.length)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES6 | Mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Returns `this`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigns `value` to every index between (including) `start` and (excluding) `end`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Caveat: Don’t use this method to fill an Array with an object `obj`; then each
    element will refer to the same value (sharing it). In this case, it’s better to
    [use `Array.from()`](#filling-arrays).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Array.prototype.copyWithin(target, start, end=this.length)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES6 | Mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Returns `this`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Copies the elements whose indices range from (including) `start` to (excluding)
    `end` to indices starting with `target`. Overlapping is handled correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`start` or `end` can be [negative](#negative-array-indices).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[34.18.7 `Array.prototype.*`: searching for elements](#arrayprototype-searching-for-elements)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Array.prototype.includes(searchElement, fromIndex)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES2016 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Returns `true` if the receiver has an element whose value is `searchElement`
    and `false`, otherwise. Searching starts at index `fromIndex`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.prototype.indexOf(searchElement, fromIndex)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES5 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Returns the index of the first element that is strictly equal to `searchElement`.
    Returns `-1` if there is no such element. Starts searching at index `fromIndex`,
    visiting higher indices next.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.prototype.lastIndexOf(searchElement, fromIndex)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES5 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Returns the index of the last element that is strictly equal to `searchElement`.
    Returns `-1` if there is no such element. Starts searching at index `fromIndex`,
    visiting lower indices next.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.prototype.find(predicate, thisArg?)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES6 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Traverses an Array from start to end.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the value of the first element for which `predicate` returns a truthy
    value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is no such element, it returns `undefined`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.prototype.findLast(predicate, thisArg?)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES2023 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Traverses an Array from end to start.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the value of the first element for which `predicate` returns a truthy
    value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is no such element, it returns `undefined`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.prototype.findIndex(predicate, thisArg?)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES6 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Traverses an Array from start to end.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the index of the first element for which `predicate` returns a truthy
    value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is no such element, it returns `-1`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.prototype.findLastIndex(predicate, thisArg?)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES2023 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Traverses an Array from end to start.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the index of the first element for which `predicate` returns a truthy
    value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is no such element, it returns `-1`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[34.18.8 `Array.prototype.*`: filtering and mapping](#arrayprototype-filtering-and-mapping)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Array.prototype.filter(predicate, thisArg?)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES5 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Returns an Array with only those elements for which `predicate` returns a truthy
    value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.prototype.map(callback, thisArg?)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES5 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Returns a new Array, in which every element is the result of `mapFunc` being
    applied to the corresponding element of the receiver.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.prototype.flatMap(callback, thisArg?)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES2019 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result is produced by invoking `callback()` for each element of the original
    Array and concatenating the Arrays it returns.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.prototype.flat(depth = 1)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES2019 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '“Flattens” an Array: It descends into the Arrays that are nested inside the
    input Array and creates a copy where all values it finds at level `depth` or lower
    are moved to the top level.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[34.18.9 `Array.prototype.*`: computing summaries](#arrayprototype-computing-summaries)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Array.prototype.every(predicate, thisArg?)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES5 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Returns `true` if `predicate` returns a truthy value for every element. Otherwise,
    it returns `false`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Stops traversing an Array if the predicate returns a falsy value (because then
    the result is guaranteed to be `false`).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Corresponds to universal quantification (“for all”, ∀) in mathematics.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Related method: [`.some()`](#qref-Array.prototype.some) (“exists”).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.some(predicate, thisArg?)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES5 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Returns `true` if `predicate` returns a truthy value for at least one element.
    Otherwise, it returns `false`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Stops traversing an Array if the predicate returns a truthy value (because then
    the result is guaranteed to be `true`).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Corresponds to existential quantification (“exists”, ∃) in mathematics.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Related method: [`.every()`](#qref-Array.prototype.every) (“for all”).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.reduce(callback, initialValue?)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES5 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method produces a summary of the receiver: it feeds all Array elements
    to `callback`, which combines a current summary (in parameter `accumulator`) with
    the current Array element and returns the next `accumulator`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result of `.reduce()` is the last result of `callback` after it has visited
    all Array elements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If no `initialValue` is provided, the Array element at index 0 is used and the
    element at index 1 is visited first. Therefore, the Array must have at least length
    1.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Array.prototype.reduceRight(callback, initialValue?)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES5 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Works like `.reduce()`, but visits the Array elements backward, starting with
    the last element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[34.18.10 `Array.prototype.*`: converting to string](#arrayprototype-converting-to-string)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Array.prototype.join(separator = '','')`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES1 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creates a string by concatenating string representations of all elements, separating
    them with `separator`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.prototype.toString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES1 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Converts all elements to strings via `String()`, concatenates them while separating
    them with commas, and returns the result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.prototype.toLocaleString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES3 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Works like [`.toString()`](#qref-Array.prototype.toString) but converts its
    elements to strings via `.toLocaleString()` (not via `.toString()`) before separating
    them via commas and concatenating them to a single string – that it returns.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[34.18.11 `Array.prototype.*`: sorting and reversing](#arrayprototype-sorting-and-reversing)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Array.prototype.sort(compareFunc?)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES1 | Mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sorts the receiver and returns it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The non-destructive version of this method is [`.toSorted()`](#qref-Array.prototype.toSorted).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorts string representations of the elements lexicographically.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sorting numbers:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sorting strings: By default, strings are sorted by code unit values (char codes),
    where, e.g., all unaccented uppercase letters come before all unaccented lowercase
    letters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For human languages, we can use [`Intl.Collator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Collator):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Array.prototype.toSorted(compareFunc?)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES2023 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Returns a sorted copy of the current Array.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The destructive version of this method is [`.sort()`](#qref-Array.prototype.sort).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See the description of [`.sort()`](#qref-Array.prototype.sort) for more information
    on how to use this method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Array.prototype.reverse()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES1 | Mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Rearranges the elements of the receiver so that they are in reverse order and
    then returns the receiver.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The non-destructive version of this method is [`.toReversed()`](#qref-Array.prototype.toReversed).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Array.prototype.toReversed()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES2023 | Non-mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Returns a reversed copy of the current Array.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The destructive version of this method is [`.reverse()`](#qref-Array.prototype.reverse).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[34.18.12 Sources of the quick reference](#sources-of-the-quick-reference)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[ECMAScript language specification](https://tc39.es/ecma262/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[TypeScript’s built-in typings](https://github.com/microsoft/TypeScript/tree/main/src/lib/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MDN web docs for JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
