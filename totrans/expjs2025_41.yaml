- en: 34 Arrays (Array)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_arrays.html](https://exploringjs.com/js/book/ch_arrays.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[34.1 Cheat sheet: Arrays](#cheat-sheet-arrays)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.1.1 Using Arrays](#using-arrays)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.1.2 The most commonly used Array methods](#the-most-commonly-used-array-methods)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.2 Ways of using Arrays: fixed layout vs. sequence](#arrays-fixed-layout-vs-sequence)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.3 Basic Array operations](#basic-array-operations)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.3.1 Creating, reading, writing Arrays](#array-literals)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.3.2 The `.length` of an Array](#array-length)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.3.3 Referring to elements via negative indices](#referring-to-elements-via-negative-indices)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.3.4 Clearing Arrays](#clearing-arrays)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.3.5 Spreading into Array literals](#spreading-into-array-literals)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.3.6 Arrays: listing indices and entries](#arrays-listing-indices-and-entries)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.3.7 Checking if a value is an Array: `Array.isArray()`](#checking-if-a-value-is-an-array-arrayisarray)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.4 `for-of` and Arrays](#for-of-arrays)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.4.1 `for-of`: iterating over elements](#forof-iterating-over-elements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.4.2 `for-of`: iterating over indices](#forof-iterating-over-indices)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.4.3 `for-of`: iterating over [index, element] pairs](#forof-iterating-over-index-element-pairs)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.5 Array-like objects](#array-like-objects)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.6 Converting iterables, iterators and Array-like values to Arrays](#converting-to-array)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.6.1 Converting iterables to Arrays via spreading (`...`)](#converting-iterables-to-arrays-via-spreading-)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.6.2 Converting iterators to Arrays via `.toArray()` ^(ES2025)](#converting-iterators-to-arrays-via-toarray-es2025)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.6.3 Converting iterables and Array-like objects to Arrays via `Array.from()`](#Array.from)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.7 Copying Arrays](#copying-arrays)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.8 Creating and filling Arrays with arbitrary lengths](#filling-arrays)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.8.1 Creating an Array and adding elements later](#creating-array-adding-elements-later)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.8.2 Creating an Array filled with a primitive value](#creating-array-with-primitives)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.8.3 Creating an Array filled with objects](#creating-array-with-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.8.4 Creating an Array with a range of integers](#creating-array-with-range-of-integers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.8.5 Typed Arrays work well if the elements are all integers or all floats](#typed-arrays-work-well-if-the-elements-are-all-integers-or-all-floats)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.9 Multidimensional Arrays](#multidimensional-arrays)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.10 Arrays are actually dictionaries (advanced)](#arrays-are-dictionaries)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.10.1 Array indices are (slightly special) property keys](#array-indices)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.10.2 Arrays can have holes](#array-holes)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.11 Destructive vs. non-destructive Array operations](#array-operations-destructive-vs-non-destructive)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.11.1 How to make destructive Array methods non-destructive](#how-to-make-destructive-array-methods-nondestructive)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.11.2 Non-destructive versions of `.reverse()`, `.sort()`, `.splice()` ^(ES2023)](#nondestructive-versions-of-reverse-sort-splice-es2023)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.12 Adding and removing elements at either end of an Array](#adding-and-removing-elements-at-either-end-of-an-array)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.12.1 Destructively adding and removing elements at either end of an Array](#array-push-pop-shift-unshift)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.12.2 Non-destructively prepending and appending elements](#nondestructively-prepending-and-appending-elements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.13 Array methods that accept element callbacks](#array-element-callbacks)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.14 Transforming with element callbacks: `.map()`, `.filter()`, `.flatMap()`](#transforming-with-element-callbacks-map-filter-flatmap)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.14.1 `.map()`: Each output element is derived from its input element](#map-each-output-element-is-derived-from-its-input-element)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.14.2 `.filter()`: Only keep some of the elements](#filter-only-keep-some-of-the-elements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.14.3 `.flatMap()`: Each input element produces zero or more output elements
    ^(ES2019)](#Array.prototype.flatMap)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.15 `.reduce()`: computing a summary for an Array](#Array.prototype.reduce)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.15.1 An overview of how `.reduce()` works](#an-overview-of-how-reduce-works)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.15.2 What happens if we omit `init`?](#what-happens-if-we-omit-init)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.15.3 `.reduceRight()`: the end-to-start version of `.reduce()`](#Array.prototype.reduceRight)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.16 `.sort()`: sorting Arrays](#Array.prototype.sort)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.16.1 Customizing the sort order](#customizing-array-sorting)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.16.2 Sorting numbers](#sorting-arrays-with-numbers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.16.3 Sorting human-language strings](#sorting-humanlanguage-strings)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.16.4 Sorting objects](#sorting-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.17 Grouping Array elements](#grouping-array-elements)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18 Quick reference: `Array`](#quickref-Array)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.1 `new Array()`](#new-array)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.2 `Array.*`](#array)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.3 `Array.prototype.*`: getting, setting and visiting single elements](#arrayprototype-getting-setting-and-visiting-single-elements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.4 `Array.prototype.*`: keys and values](#arrayprototype-keys-and-values)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.5 `Array.prototype.*`: destructively adding or removing elements at
    either end of an Array](#arrayprototype-destructively-adding-or-removing-elements-at-either-end-of-an-array)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.6 `Array.prototype.*`: combining, extracting and changing sequences
    of elements](#arrayprototype-combining-extracting-and-changing-sequences-of-elements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.7 `Array.prototype.*`: searching for elements](#arrayprototype-searching-for-elements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.8 `Array.prototype.*`: filtering and mapping](#arrayprototype-filtering-and-mapping)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.9 `Array.prototype.*`: computing summaries](#arrayprototype-computing-summaries)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.10 `Array.prototype.*`: converting to string](#arrayprototype-converting-to-string)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.11 `Array.prototype.*`: sorting and reversing](#arrayprototype-sorting-and-reversing)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.18.12 Sources of the quick reference](#sources-of-the-quick-reference)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[34.1 Cheat sheet: Arrays](#cheat-sheet-arrays)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript Arrays are a very flexible data structure and used as lists, stacks,
    queues, tuples (e.g. pairs), and more.
  prefs: []
  type: TYPE_NORMAL
- en: Some Array-related operations destructively change Arrays. Others non-destructively
    produce new Arrays with the changes applied to a copy of the original content.
  prefs: []
  type: TYPE_NORMAL
- en: '[34.1.1 Using Arrays](#using-arrays)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Creating an Array, reading and writing elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1][PRE2][PRE3][PRE4][PRE5]`` [PRE6][PRE7][PRE8][PRE9][PRE10]` The length
    of an Array:    [PRE11]    Adding elements destructively via `.push()`:    [PRE12]   [PRE13][PRE14][PRE15][PRE16][PRE17]
    [PRE18]`js[PRE19]js[PRE20]`js[PRE21]js[PRE22]js[PRE23]js[PRE24][PRE25][PRE26][PRE27][PRE28]js[PRE29]js[PRE30]js[PRE31]js[PRE32][PRE33][PRE34][PRE35]
    `.keys()` returns an iterator. In line A, we convert that iterator to an Array.    Listing
    Array indices is different from listing properties. The former produces numbers;
    the latter produces stringified numbers (in addition to non-index property keys):    [PRE36]js    Notice
    that the object property `arr.prop` shows up in the result.    Method `.entries()`
    lists the contents of an Array as [index, element] pairs:    [PRE37]js    `Object.entries()`
    lists [property key, property value] pairs:    [PRE38]js    Once again we see
    `arr.prop` in the result.    #### [34.3.7 Checking if a value is an Array: `Array.isArray()`](#checking-if-a-value-is-an-array-arrayisarray)    `Array.isArray()`
    checks if a value is an Array:    [PRE39]js    We can also use `instanceof`:    [PRE40]js    However,
    `instanceof` has one downside: It doesn’t work if a value comes from another *realm*.
    Roughly, a realm is an instance of JavaScript’s global scope. Some realms are
    isolated from each other (e.g., [Web Workers](ch_async-js.html#web-workers) in
    browsers), but there are also realms between which we can move data – for example,
    same-origin iframes in browsers. `x instanceof Array` checks the prototype chain
    of `x` and therefore returns `false` if `x` is an Array from another realm.    `typeof`
    considers Arrays to be objects:    [PRE41]js    ### [34.4 `for-of` and Arrays](#for-of-arrays)    We
    have already encountered the `for-of` loop earlier in this book. This section
    briefly recaps how to use it for Arrays.    #### [34.4.1 `for-of`: iterating over
    elements](#forof-iterating-over-elements)    The following `for-of` loop iterates
    over the elements of an Array:    [PRE42]js    Output:    [PRE43]js    #### [34.4.2 `for-of`:
    iterating over indices](#forof-iterating-over-indices)    This `for-of` loop iterates
    over the indices of an Array:    [PRE44]js    Output:    [PRE45]js    #### [34.4.3 `for-of`:
    iterating over [index, element] pairs](#forof-iterating-over-index-element-pairs)    The
    following `for-of` loop iterates over [index, element] pairs. Destructuring (described
    [later](ch_destructuring.html#ch_destructuring)), gives us convenient syntax for
    setting up `index` and `element` in the head of `for-of`.    [PRE46]js    Output:    [PRE47]js    ###
    [34.5 Array-like objects](#array-like-objects)    Some operations that work with
    Arrays require only the bare minimum: values must only be *Array-like*. An Array-like
    value is an object with the following properties:    *   `.length`: holds the
    length of the Array-like object. If this property is missing, the value `0` is
    used. *   `[0]`: holds the element at index 0 (etc.). Note that if we use numbers
    as property names, they are always coerced to strings. Therefore, `[0]` retrieves
    the value of the property whose key is `''0''`.    For example, `Array.from()`
    accepts Array-like objects and converts them to Arrays:    [PRE48]js   [PRE49]`js[PRE50]js[PRE51]js`
    [PRE52]`js[PRE53]js[PRE54]js[PRE55]js[PRE56]js[PRE57]js[PRE58]`js[PRE59]js[PRE60][PRE61][PRE62]js
    const original = [''a'', ''b'', ''c'']; const reversed = original.reverse();  `assert.deepEqual(reversed,
    [''c'', ''b'', ''a'']);` `` assert.ok(reversed === original); // .reverse() returned
    `this` `` `assert.deepEqual(original, [''c'', ''b'', ''a'']);`  [PRE63]js[PRE64]js[PRE65][PRE66]
    Another option is to use the non-destructive version of a destructive method.
    That’s what we’ll explore next.    #### [34.11.2 Non-destructive versions of `.reverse()`,
    `.sort()`, `.splice()` ^(ES2023)](#nondestructive-versions-of-reverse-sort-splice-es2023)    These
    are the non-destructive versions of the destructive Array methods `.reverse()`,
    `.sort()` and `.splice()`:    *   `.toReversed(): Array` *   `.toSorted(compareFn):
    Array` *   `.toSpliced(start, deleteCount, ...items): Array`    We have used `.reverse()`
    in the previous subsection. Its non-destructive version is used like this:    [PRE67]js   [PRE68]
    ### [34.12 Adding and removing elements at either end of an Array](#adding-and-removing-elements-at-either-end-of-an-array)    ####
    [34.12.1 Destructively adding and removing elements at either end of an Array](#array-push-pop-shift-unshift)    JavaScript’s
    `Array` is quite flexible and more like a combination of array, stack, and queue.
    Let’s explore ways of destructively adding and removing Array elements.    `.push()`
    adds elements at the end of an Array:    [PRE69]   [PRE70][PRE71]``js[PRE72]``
    Non-destructive appending:    [PRE73]   [PRE74]`` ### [34.13 Array methods that
    accept element callbacks](#array-element-callbacks)    The following Array methods
    accept callbacks to which they feed Array elements:    *   Finding:     *   `.find`     *   `.findLast`     *   `.findIndex`     *   `.findLastIndex`
    *   Transforming:     *   `.map`     *   `.flatMap`     *   `.filter` *   Computing
    summaries of Arrays:     *   `.every`     *   `.some`     *   `.reduce`     *   `.reduceRight`
    *   Looping over Arrays:     *   `.forEach`    Element callbacks have type signatures
    that look as follows:    [PRE75]    That is, the callback gets three parameters
    (it is free to ignore any of them):    *   `value` is the most important one.
    This parameter holds the Array element that is currently being processed. *   `index`
    can additionally tell the callback what the index of the element is. *   `array`
    points to the current Array (the receiver of the method call). Some algorithms
    need to refer to the whole Array – e.g., to search elsewhere additional data.
    This parameter lets us write reusable callbacks for such algorithms.    What the
    callback is expected to return depends on the method it is passed to. Possibilities
    include:    *   `.map()` fills its result with the values returned by its callback:                    [PRE76]           *   `.find()`
    returns the first Array element for which its callback returns `true`:                    [PRE77]              ###
    [34.14 Transforming with element callbacks: `.map()`, `.filter()`, `.flatMap()`](#transforming-with-element-callbacks-map-filter-flatmap)    In
    this section, we explore methods that accept [element callbacks](#array-element-callbacks)
    which tell them how to transform an input Array into an output Array.    ####
    [34.14.1 `.map()`: Each output element is derived from its input element](#map-each-output-element-is-derived-from-its-input-element)    Each
    element of the output Array is the result of applying the callback to the corresponding
    input element:    [PRE78]    `.map()` can be implemented as follows:    [PRE79]    ![Icon
    “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Numbering
    lines via `.map()`**    `exercises/arrays/number_lines_test.mjs`    #### [34.14.2 `.filter()`:
    Only keep some of the elements](#filter-only-keep-some-of-the-elements)    The
    Array method `.filter()` returns an Array collecting all elements for which the
    callback returns a truthy value.    For example:    [PRE80]    `.filter()` can
    be implemented as follows:    [PRE81]    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Removing empty lines via `.filter()`**    `exercises/arrays/remove_empty_lines_filter_test.mjs`    ####
    [34.14.3 `.flatMap()`: Each input element produces zero or more output elements
    ^(ES2019)](#Array.prototype.flatMap)    The type signature of `Array<T>.prototype.flatMap()`
    is:    [PRE82]    Both `.map()` and `.flatMap()` take a function `callback` as
    a parameter that controls how an input Array is translated to an output Array:    *   With
    `.map()`, each input Array element is translated to exactly one output element.
    That is, `callback` returns a single value. *   With `.flatMap()`, each input
    Array element is translated to zero or more output elements. That is, `callback`
    returns an Array of values (it can also return non-Array values, but that is rare).    This
    is `.flatMap()` in action:    [PRE83]    We’ll consider use cases next, before
    exploring how this method could be implemented.    ##### [34.14.3.1 Use case:
    filtering and mapping at the same time](#use-case-filtering-and-mapping-at-the-same-time)    The
    result of the Array method `.map()` always has the same length as the Array it
    is invoked on. That is, its callback can’t skip Array elements it isn’t interested
    in. The ability of `.flatMap()` to do so is useful in the next example.    Let’s
    say, we got the following result from [`Promise.allSettled()`](ch_promises.html#Promise.allSettled):    [PRE84]    We
    can use `.flatMap()` to extract just the values or just the errors from `results`:    [PRE85]    #####
    [34.14.3.2 Use case: mapping single input values to multiple output values](#use-case-mapping-single-input-values-to-multiple-output-values)    The
    Array method `.map()` maps each input Array element to one output element. But
    what if we want to map it to multiple output elements?    That becomes necessary
    in the following example:    [PRE86]    We want to convert an Array of strings
    to an Array of Unicode characters (code points). The following function achieves
    that via `.flatMap()`:    [PRE87]    ##### [34.14.3.3 A simple implementation](#a-simple-implementation)    We
    can implement `.flatMap()` as follows. Note: This implementation is simpler than
    the built-in version, which, for example, performs more checks.    [PRE88]    ![Icon
    “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercises: `.flatMap()`**    *   `exercises/arrays/convert_to_numbers_test.mjs`
    *   `exercises/arrays/replace_objects_test.mjs`    ### [34.15 `.reduce()`: computing
    a summary for an Array](#Array.prototype.reduce)    Method `.reduce()` is a powerful
    tool for computing a “summary” of an Array `arr`. A summary can be any kind of
    value:    *   A number. For example, the sum of all elements of `arr`. *   An
    Array. For example, a copy of `arr`, where each element is twice the original
    element. *   Etc.    `reduce` is also known as `foldl` (“fold left”) in functional
    programming and popular there. One caveat is that it can make code difficult to
    understand.    #### [34.15.1 An overview of how `.reduce()` works](#an-overview-of-how-reduce-works)    We’ll
    start with an overview of how `.reduce()` works. If you find the overview difficult
    to understand, you can skip ahead to the example and come back here later.    `.reduce()`
    has the following type signature (inside an `Array<T>`):    [PRE89]    `T` is
    the type of the Array elements, `U` is the type of the summary. The two may or
    may not be different. `accumulator` is just another name for “summary”.    To
    compute the summary of an Array `arr`, `.reduce()` feeds all Array elements to
    its callback one at a time:    [PRE90]    *   `init` provides the initial value
    for `accumulator`. *   The accumulator contains the preliminary result of the
    reduction. When the callback is invoked, it combines the accumulator with the
    current Array element and returns the result. That result becomes the next accumulator.
    *   The result of `.reduce()` is the final accumulator – the last result of `callback`
    after it has visited all elements.    In other words: `callback` does most of
    the work; `.reduce()` just invokes it in a useful manner.    We could say that
    the callback folds Array elements into the accumulator. That’s why this operation
    is called “fold” in functional programming.    #### [Example: applying a binary
    operator to a whole Array](#example-applying-a-binary-operator-to-a-whole-array)    Let’s
    look at an example of `.reduce()` in action: function `addAll()` computes the
    sum of all numbers in an Array `arr`.    [PRE91]    In this case, the accumulator
    holds the sum of all Array elements that `callback` has already visited.    How
    was the result `6` derived from the Array in line A? Via the following invocations
    of `callback`:    [PRE92]    Notes:    *   The first parameters are the current
    accumulators (starting with parameter `init` of `.reduce()`). *   The second parameters
    are the current Array elements. *   The results are the next accumulators. *   The
    last result of `callback` is also the result of `.reduce()`.    Alternatively,
    we could have implemented `addAll()` via a `for-of` loop:    [PRE93]    It’s hard
    to say which of the two implementations is “better”: the one based on `.reduce()`
    is a little more concise, while the one based on `for-of` may be a little easier
    to understand – especially if someone is not familiar with functional programming.    ####
    [34.15.2 What happens if we omit `init`?](#what-happens-if-we-omit-init)    If
    we pass the parameter `init` to `.reduce()`, it is the initial value of the accumulator:    [PRE94]    If
    the Array is empty, the result of `.reduce()` is `init`.    If we omit `init`
    then `.reduce()` initializes the accumulator with the first Array element:    [PRE95]    If
    the Array only has one element, the result of `.reduce()` is that element. If
    the Array is empty, `.reduce()` doesn’t have a value to return and throws an exception.    The
    following interaction demonstrates the initial value of the `accumulator` with
    and without `init`:    [PRE96]    #### [Example: finding indices via `.reduce()`](#example-finding-indices-via-reduce)    The
    following function is an implementation of the Array method `.indexOf()`. It returns
    the first index at which the given `searchValue` appears inside the Array `arr`:    [PRE97]    One
    limitation of `.reduce()` is that we can’t finish early. In a `for-of` loop, we
    can immediately return the result once we have found it.    #### [Example: doubling
    Array elements](#example-doubling-array-elements)    Function `double(arr)` returns
    a copy of `inArr` whose elements are all multiplied by 2:    [PRE98]    We modify
    the initial value `[]` by pushing into it. A non-destructive, more functional
    version of `double()` looks as follows:    [PRE99]    This version is more elegant
    but also slower and uses more memory.    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercises:
    `.reduce()`**    *   `map()` via `.reduce()`: `exercises/arrays/map_via_reduce_test.mjs`
    *   `filter()` via `.reduce()`: `exercises/arrays/filter_via_reduce_test.mjs`
    *   `countMatches()` via `.reduce()`: `exercises/arrays/count_matches_via_reduce_test.mjs`    ####
    [34.15.3 `.reduceRight()`: the end-to-start version of `.reduce()`](#Array.prototype.reduceRight)    `.reduce()`
    visits elements from start to end:    [PRE100]    `.reduceRight()` has the same
    functionality but visits elements from end to start:    [PRE101]    ### [34.16 `.sort()`:
    sorting Arrays](#Array.prototype.sort)    `.sort()` has the following type definition:    [PRE102]    By
    default, `.sort()` sorts string representations of the elements. These representations
    are compared via `<`. This operator compares code unit values (char codes) *lexicographically*
    (the first characters are most significant).    `.sort()` sorts *in place*; it
    changes and returns its receiver:    [PRE103]    ![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **`.sort()`
    is stable**    Since ECMAScript 2019, sorting is guaranteed to be *stable*: If
    elements are considered equal by sorting, then sorting does not change the order
    of those elements (relative to each other).    #### [34.16.1 Customizing the sort
    order](#customizing-array-sorting)    We can customize the sort order via the
    parameter `compareFunc`, which must return a number that is:    *   negative if
    `a` is less than `b` *   zero if `a` is equal to `b` *   positive if `a` is greater
    than `b`    We’ll see an example of a compare function in the next subsection.    ![Icon
    “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Tip for remembering these
    rules**    A negative number is *less than* zero (etc.).    #### [34.16.2 Sorting
    numbers](#sorting-arrays-with-numbers)    Lexicographical sorting doesn’t work
    well for numbers:    [PRE104]    We can fix this by writing a compare function:    [PRE105]    ![Icon
    “question”](../Images/3decb3ca67c240d2bb04742c1f28af18.png) **Why doesn’t `.sort()`
    automatically pick the right sorting approach for numbers?**    It would have
    to examine all Array elements and make sure that they are numbers before switching
    from lexicographical sorting to numeric sorting.    ##### [34.16.2.1 A trick for
    sorting numbers](#a-trick-for-sorting-numbers)    The following trick uses the
    fact that (e.g.) the result for “less than” can be any negative number:    [PRE106]    *   This
    time, we call the parameters `a` and `z` because that enables a mnemonic: The
    callback sorts ascendingly, “from `a` to `z`” (`a - z`). *   A downside of this
    trick is that we might get an arithmetic overflow if a large positive and a large
    negative number are compared.    #### [34.16.3 Sorting human-language strings](#sorting-humanlanguage-strings)    When
    sorting human-language strings, we need to be aware that they are compared according
    to their code unit values (char codes):    [PRE107]    All unaccented uppercase
    letters come before all unaccented lowercase letters, which come before all accented
    letters. We can use `Intl`, [the JavaScript internationalization API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl)
    if we want proper sorting for human languages:    [PRE108]    #### [34.16.4 Sorting
    objects](#sorting-objects)    We also need to use a compare function if we want
    to sort objects. As an example, the following code shows how to sort objects by
    age.    [PRE109]    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Sorting objects by name**    `exercises/arrays/sort_objects_test.mjs`    ### [34.17 Grouping
    Array elements](#grouping-array-elements)    Grouping via `Object.groupBy()` and
    `Map.groupBy()` works for any iterable object and therefore for Arrays:    [PRE110]    More
    information: [“Grouping iterables ^(ES2024)” (§32.8)](ch_sync-iteration.html#grouping-sync-iterables)    ###
    [34.18 Quick reference: `Array`](#quickref-Array)    Legend:    *   `R`: method
    does not change the Array (non-destructive). *   `W`: method changes the Array
    (destructive).    **Negative indices:** If a method supports negative indices
    that means that such indices are added to `.length` before they are used: `-1`
    becomes `this.length-1`, etc. In other words: `-1` refers to the last element,
    `-2` to the second-last element, etc. `.at()` is one method that supports negative
    indices:    [PRE111]    #### [34.18.1 `new Array()`](#new-array)    *   `new Array(len
    = 0)` ES1                    Creates an Array of length `len` that only contains
    holes:                    [PRE112]              #### [34.18.2 `Array.*`](#array)    *   `Array.from(iterableOrArrayLike,
    mapFunc?)` ES6                    [PRE113]               *   Converts an iterable
    or [an Array-like object](#array-like-objects) to an Array.     *   Optionally,
    the input values can be translated via `mapFunc` before they are added to the
    output Array.          Examples:                    [PRE114]           *   `Array.of(...items)`
    ES6                    [PRE115]                    This static method is mainly
    useful for subclasses of `Array`, where it serves as a custom Array literal:                    [PRE116]              [PRE117]`
    #### [34.18.3 `Array.prototype.*`: getting, setting and visiting single elements](#arrayprototype-getting-setting-and-visiting-single-elements)    *   `Array.prototype.at(index)`     ES2022
    | Non-mutating               *   Returns the Array element at `index`. If there
    is no such element, it returns `undefined`.          This method is mostly equivalent
    to getting elements via square brackets:                    [PRE118]                    One
    reason for using `.at()` is that it supports [negative indices](#negative-array-indices):                    [PRE119]           *   `Array.prototype.with(index,
    value)`     ES2023 | Non-mutating               *   Returns the receiver of the
    method call, with one different element: At `index`, there is now `value`.          This
    method is the non-destructive version of setting elements via square brackets.
    It supports negative indices:                    [PRE120]           *   `Array.prototype.forEach(callback)`     ES5
    | Non-mutating                    [PRE121]                    Calls `callback`
    for each element.                    [PRE122]                    Output:                    [PRE123]                    A
    `for-of` loop is usually a better choice: it’s faster, supports `break` and can
    iterate over arbitrary iterables.              #### [34.18.4 `Array.prototype.*`:
    keys and values](#arrayprototype-keys-and-values)    *   `Array.prototype.keys()`     ES6
    | Non-mutating                    Returns an iterable over the keys of the receiver.                    [PRE124]           *   `Array.prototype.values()`     ES6
    | Non-mutating                    Returns an iterable over the values of the receiver.                    [PRE125]           *   `Array.prototype.entries()`     ES6
    | Non-mutating                    Returns an iterable over [index, element] pairs.                    [PRE126]              ####
    [34.18.5 `Array.prototype.*`: destructively adding or removing elements at either
    end of an Array](#arrayprototype-destructively-adding-or-removing-elements-at-either-end-of-an-array)    *   `Array.prototype.pop()`     ES3
    | Mutating                    Removes and returns the last element of the receiver.
    That is, it treats the end of the receiver as a stack. The opposite of `.push()`.                    [PRE127]           *   `Array.prototype.push(...items)`     ES3
    | Mutating                    Adds zero or more `items` to the end of the receiver.
    That is, it treats the end of the receiver as a stack. The return value is the
    length of the receiver after the change. The opposite of `.pop()`.                    [PRE128]                    We
    can push an Array by spreading (`...`) it into arguments:                    [PRE129]           *   `Array.prototype.shift()`     ES3
    | Mutating                    Removes and returns the first element of the receiver.
    The inverse of `.unshift()`.                    [PRE130]           *   `Array.prototype.unshift(...items)`     ES3
    | Mutating                    Inserts the `items` at the beginning of the receiver
    and returns its length after this modification.                    [PRE131]                    We
    can push an Array by spreading (`...`) it into arguments:                    [PRE132]              ####
    [34.18.6 `Array.prototype.*`: combining, extracting and changing sequences of
    elements](#arrayprototype-combining-extracting-and-changing-sequences-of-elements)    ![Icon
    “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Tip: telling `.slice()`
    and `.splice()` apart**    *   `.slice()` is much more commonly used. The verb
    “slice” is also much more common than the verb “splice”. *   Using `.splice()`
    is rare: Elements are more commonly (non-destructively) removed via `.filter()`.
    “Splice” has one letter more than “slice” and the method also does more.    *   `Array.prototype.concat(...items)`     ES3
    | Non-mutating                    Returns a new Array that is the concatenation
    of the receiver and all `items`. Non-Array parameters (such as `''b''` in the
    following example) are treated as if they were Arrays with single elements.                    [PRE133]           *   `Array.prototype.slice(start?,
    end?)`     ES3 | Non-mutating                    Returns a new Array containing
    the elements of the receiver whose indices are between (including) `start` and
    (excluding) `end`.                    [PRE134]                    `.slice()` supports
    [negative indices](#negative-array-indices):                    [PRE135]                    It
    can be used to (shallowly) copy Arrays:                    [PRE136]           *   `Array.prototype.splice(start?,
    deleteCount?, ...items)`     ES3 | Mutating               *   At index `start`,     *   removes
    `deleteCount` elements (default: all remaining elements) and     *   replaces
    them with `items`.     *   It returns the deleted elements.     *   The non-destructive
    version of this method is [`.toSpliced()`](#qref-Array.prototype.toSpliced).          [PRE137]                    If
    `deleteCount` is missing, `.splice()` deletes until the end of the Array:                    [PRE138]                    `start`
    can be [negative](#negative-array-indices):                    [PRE139]           *   `Array.prototype.toSpliced(start?,
    deleteCount?, ...items)`     ES2023 | Non-mutating               *   Creates a
    new Array where, starting at index `start`, `deleteCount` elements are replaced
    with `items`.     *   If `deleteCount` is missing, all elements from `start` until
    the end are deleted.     *   The destructive version of this method is [`.splice()`](#qref-Array.prototype.splice).          [PRE140]                    `start`
    can be [negative](#negative-array-indices):                    [PRE141]           *   `Array.prototype.fill(start=0,
    end=this.length)`     ES6 | Mutating               *   Returns `this`.     *   Assigns
    `value` to every index between (including) `start` and (excluding) `end`.          [PRE142]                    Caveat:
    Don’t use this method to fill an Array with an object `obj`; then each element
    will refer to the same value (sharing it). In this case, it’s better to [use `Array.from()`](#filling-arrays).           *   `Array.prototype.copyWithin(target,
    start, end=this.length)`     ES6 | Mutating               *   Returns `this`.          Copies
    the elements whose indices range from (including) `start` to (excluding) `end`
    to indices starting with `target`. Overlapping is handled correctly.                    [PRE143]                    `start`
    or `end` can be [negative](#negative-array-indices).              #### [34.18.7 `Array.prototype.*`:
    searching for elements](#arrayprototype-searching-for-elements)    *   `Array.prototype.includes(searchElement,
    fromIndex)`     ES2016 | Non-mutating                    Returns `true` if the
    receiver has an element whose value is `searchElement` and `false`, otherwise.
    Searching starts at index `fromIndex`.                    [PRE144]           *   `Array.prototype.indexOf(searchElement,
    fromIndex)`     ES5 | Non-mutating                    Returns the index of the
    first element that is strictly equal to `searchElement`. Returns `-1` if there
    is no such element. Starts searching at index `fromIndex`, visiting higher indices
    next.                    [PRE145]           *   `Array.prototype.lastIndexOf(searchElement,
    fromIndex)`     ES5 | Non-mutating                    Returns the index of the
    last element that is strictly equal to `searchElement`. Returns `-1` if there
    is no such element. Starts searching at index `fromIndex`, visiting lower indices
    next.                    [PRE146]           *   `Array.prototype.find(predicate,
    thisArg?)`     ES6 | Non-mutating                    [PRE147]               *   Traverses
    an Array from start to end.     *   Returns the value of the first element for
    which `predicate` returns a truthy value.     *   If there is no such element,
    it returns `undefined`.          [PRE148]           *   `Array.prototype.findLast(predicate,
    thisArg?)`     ES2023 | Non-mutating                    [PRE149]               *   Traverses
    an Array from end to start.     *   Returns the value of the first element for
    which `predicate` returns a truthy value.     *   If there is no such element,
    it returns `undefined`.          [PRE150]           *   `Array.prototype.findIndex(predicate,
    thisArg?)`     ES6 | Non-mutating                    [PRE151]               *   Traverses
    an Array from start to end.     *   Returns the index of the first element for
    which `predicate` returns a truthy value.     *   If there is no such element,
    it returns `-1`.          [PRE152]           *   `Array.prototype.findLastIndex(predicate,
    thisArg?)`     ES2023 | Non-mutating                    [PRE153]               *   Traverses
    an Array from end to start.     *   Returns the index of the first element for
    which `predicate` returns a truthy value.     *   If there is no such element,
    it returns `-1`.          [PRE154]              #### [34.18.8 `Array.prototype.*`:
    filtering and mapping](#arrayprototype-filtering-and-mapping)    *   `Array.prototype.filter(predicate,
    thisArg?)`     ES5 | Non-mutating                    [PRE155]                    Returns
    an Array with only those elements for which `predicate` returns a truthy value.                    [PRE156]           *   `Array.prototype.map(callback,
    thisArg?)`     ES5 | Non-mutating                    [PRE157]                    Returns
    a new Array, in which every element is the result of `mapFunc` being applied to
    the corresponding element of the receiver.                    [PRE158]           *   `Array.prototype.flatMap(callback,
    thisArg?)`     ES2019 | Non-mutating                    [PRE159]                    The
    result is produced by invoking `callback()` for each element of the original Array
    and concatenating the Arrays it returns.                    [PRE160]           *   `Array.prototype.flat(depth
    = 1)`     ES2019 | Non-mutating                    “Flattens” an Array: It descends
    into the Arrays that are nested inside the input Array and creates a copy where
    all values it finds at level `depth` or lower are moved to the top level.                    [PRE161]              [PRE162]
    [PRE163]`js [PRE164]js`` [PRE165]js[PRE166][PRE167][PRE168][PRE169]js[PRE170]js`
    [PRE171]`js`` [PRE172]`js[PRE173][PRE174][PRE175] [PRE176][PRE177][PRE178][PRE179][PRE180]``
    [PRE181][PRE182][PRE183] [PRE184]`js[PRE185]js[PRE186]js[PRE187]js[PRE188]js[PRE189]js`
    [PRE190]`js[PRE191]js[PRE192]js[PRE193][PRE194][PRE195][PRE196][PRE197]``js[PRE198]js[PRE199]js[PRE200]js[PRE201][PRE202][PRE203][PRE204][PRE205]
    [PRE206][PRE207][PRE208][PRE209][PRE210][PRE211][PRE212][PRE213][PRE214]`` [PRE215][PRE216][PRE217][PRE218][PRE219]
    [PRE220]`js[PRE221]js[PRE222]js[PRE223]js[PRE224]'
  prefs: []
  type: TYPE_NORMAL
