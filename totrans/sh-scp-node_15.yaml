- en: 12 Running shell commands in child processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/nodejs-shell-scripting/ch_nodejs-child-process.html](https://exploringjs.com/nodejs-shell-scripting/ch_nodejs-child-process.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 12.1 [Overview of this chapter](ch_nodejs-child-process.html#overview-of-this-chapter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.1.1 [Windows vs. Unix](ch_nodejs-child-process.html#windows-vs.-unix)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.1.2 [Functionality we often use in the examples](ch_nodejs-child-process.html#functionality-we-often-use-in-the-examples)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '12.2 [Spawning processes asynchronously: `spawn()`](ch_nodejs-child-process.html#spawn)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.2.1 [How `spawn()` works](ch_nodejs-child-process.html#how-spawn-works)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.2.2 [When is the shell command executed?](ch_nodejs-child-process.html#when-is-the-shell-command-executed)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.2.3 [Command-only mode vs. args mode](ch_nodejs-child-process.html#spawn-argument-modes)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.2.4 [Sending data to the stdin of the child process](ch_nodejs-child-process.html#sending-data-to-the-stdin-of-the-child-process)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.2.5 [Piping manually](ch_nodejs-child-process.html#piping-manually)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.2.6 [Handling unsuccessful exits (including errors)](ch_nodejs-child-process.html#handling-unsuccessful-exits-including-errors)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.2.7 [Waiting for the exit of a child process](ch_nodejs-child-process.html#waiting-for-the-exit-of-a-child-process)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.2.8 [Terminating child processes](ch_nodejs-child-process.html#terminating-child-processes)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '12.3 [Spawning processes synchronously: `spawnSync()`](ch_nodejs-child-process.html#spawning-processes-synchronously-spawnsync)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.3.1 [When is the shell command executed?](ch_nodejs-child-process.html#when-is-the-shell-command-executed-1)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.3.2 [Reading from stdout](ch_nodejs-child-process.html#reading-from-stdout)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.3.3 [Sending data to the stdin of the child process](ch_nodejs-child-process.html#sending-data-to-the-stdin-of-the-child-process-1)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.3.4 [Handling unsuccessful exits (including errors)](ch_nodejs-child-process.html#handling-unsuccessful-exits-including-errors-1)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.4 [Asynchronous helper functions based on `spawn()`](ch_nodejs-child-process.html#asynchronous-helper-functions-based-on-spawn)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.4.1 [`exec()`](ch_nodejs-child-process.html#exec)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.4.2 [`execFile()`](ch_nodejs-child-process.html#execfile)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.5 [Synchronous helper functions based on `spawnAsync()`](ch_nodejs-child-process.html#synchronous-helper-functions-based-on-spawnasync)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.5.1 [`execSync()`](ch_nodejs-child-process.html#execsync)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.5.2 [`execFileSync()`](ch_nodejs-child-process.html#execfilesync)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.6 [Useful libraries](ch_nodejs-child-process.html#useful-libraries)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '12.6.1 [tinysh: a helper for spawning shell commands](ch_nodejs-child-process.html#tinysh-a-helper-for-spawning-shell-commands)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '12.6.2 [node-powershell: executing Windows PowerShell commands via Node.js](ch_nodejs-child-process.html#node-powershell-executing-windows-powershell-commands-via-node.js)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.7 [Choosing between the functions of module `'node:child_process'`](ch_nodejs-child-process.html#choosing-between-the-functions-of-module-nodechild_process)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore how we can execute shell commands from Node.js,
    via module `'node:child_process'`.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1 Overview of this chapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Module `''node:child_process''` has a function for executing shell commands
    (in *spawned* child processes) that comes in two versions:'
  prefs: []
  type: TYPE_NORMAL
- en: An asynchronous version `spawn()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A synchronous version `spawnSync()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll first explore `spawn()` and then `spawnSync()`. We’ll conclude by looking
    at the following functions that are based on them and relatively similar:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on `spawn()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exec()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`execFile()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on `spawnSync()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`execSync()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`execFileSync()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.1.1 Windows vs. Unix
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code shown in this chapter runs on Unix, but I have also tested it on Windows
    – where most of it works with minor changes (such as ending lines with `'\r\n'`
    instead of `'\n'`).
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.2 Functionality we often use in the examples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following functionality shows up often in the examples. That’s why it’s
    explained here, once:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assertions: `assert.equal()` for primitive values and `assert.deepEqual()`
    for objects. The necessary import is never shown in the examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Function `Readable.toWeb()` converts Node’s native `stream.Readable` to a web
    stream (an instance of `ReadableStream`). It is explained in [§10 “Using web streams
    on Node.js”](ch_web-streams.html). `Readable` is always imported in the examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The asynchronous function `readableStreamToString()` consumes a readable web
    stream and returns a string (wrapped in a Promise). It is explained in [the chapter
    on web streams](ch_web-streams.html#readableStreamToString). This function is
    assumed to available in the examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '12.2 Spawning processes asynchronously: `spawn()`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 12.2.1 How `spawn()` works
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[`spawn()`](https://nodejs.org/api/child_process.html#child_processspawncommand-args-options)
    asynchronously executes a command in a new process: The process runs concurrently
    to Node’s main JavaScript process and we can communicate with it in various ways
    (often via streams).'
  prefs: []
  type: TYPE_NORMAL
- en: Next, there is documentation for the parameters and the result of `spawn()`.
    If you prefer to learn by example, you can skip that content and continue with
    the subsections that follow.
  prefs: []
  type: TYPE_NORMAL
- en: '12.2.1.1 Parameter: `command`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`command` is a string with the shell command. There are two modes of using
    this parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Command-only mode: `args` is omitted and `command` contains the whole shell
    command. We can even use shell features such as piping between multiple executables,
    redirecting I/O into files, variables, and wildcards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`options.shell` must be `true` because we need an shell to handle the shell
    features.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Args mode: `command` contains only the name of the command and `args` contains
    its arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `options.shell` is `true`, many meta-characters inside arguments are interpreted
    and features such as wildcards and variable names work.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If `options.shell` is `false`, strings are used verbatim and we never have to
    escape meta-characters.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Both modes are demonstrated [later in this chapter](ch_nodejs-child-process.html#spawn-argument-modes).
  prefs: []
  type: TYPE_NORMAL
- en: '12.2.1.2 Parameter: `options`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following `options` are most interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.shell: boolean|string` (default: `false`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should a shell be used to execute the command?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On Windows, this option should almost always be `true`. For example, `.bat`
    and `.cmd` files cannot be executed otherwise.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On Unix, only core shell features (e.g. piping, I/O redirection, filename wildcards,
    and variables) are not available if `.shell` is `false`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If `.shell` is `true`, we have to be careful with user input and sanitize it
    because it’s easy to execute arbitrary code. We also have to escape meta-characters
    if we want to use them as non-meta-characters.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also set `.shell` to the path of a shell executable. Then Node.js uses
    that executable to execute the command. If we set `.shell` to `true`, Node.js
    uses:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unix: `''/bin/sh''`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows: `process.env.ComSpec`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.cwd: string | URL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifies the *current working directory* (CWD) to use while executing the command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.stdio: Array<string|Stream>|string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configures how standard I/O is set up. This is explained below.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.env: Object` (default: `process.env`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lets us specify shell variables for the child process. Tips:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Look at `process.env` (e.g. in the Node.js REPL) to see what variables exist.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use spreading to non-destructively override an existing variable – or
    create it if it doesn’t exist yet:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`.signal: AbortSignal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we create an AbortController `ac`, we can pass `ac.signal` to `spawn()` and
    abort the child process via `ac.abort()`. That is demonstrated [later in this
    chapter](ch_nodejs-child-process.html#terminating-child-process-abortcontroller).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.timeout: number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the child process takes longer than `.timeout` milliseconds, it is killed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 12.2.1.3 `options.stdio`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Each of the standard I/O streams of the child process has a numeric ID, a so-called
    *file descriptor*:'
  prefs: []
  type: TYPE_NORMAL
- en: Standard input (stdin) has the file descriptor 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard output (stdout) has the file descriptor 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard error (stderr) has the file descriptor 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There can be more file descriptors, but that’s rare.
  prefs: []
  type: TYPE_NORMAL
- en: '`options.stdio` configures if and how the streams of the child process are
    piped to streams in the parent process. It can be an Array where each element
    configures the file descriptor that is equal to its index. The following values
    can be used as Array elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''pipe''`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Index 0: Pipe `childProcess.stdin` to the child’s stdin. Note that, despite
    its name, the former is a stream that belongs to the parent process.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Index 1: Pipe the child’s stdout to `childProcess.stdout`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Index 2: Pipe the child’s stderr to `childProcess.stderr`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''ignore''`: Ignore the child’s stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''inherit''`: Pipe the child’s stream to the corresponding stream of the parent
    process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, if we want the child’s stderr to be logged to the console, we can
    use `'inherit'` at index 2.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Native Node.js stream: Pipe to or from that stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other values are supported, too, but that’s beyond the scope of this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead of specifying `options.stdio` via an Array, we can also abbreviate:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''pipe''` is equivalent to `[''pipe'', ''pipe'', ''pipe'']` (the default for
    `options.stdio`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''ignore''` is equivalent to `[''ignore'', ''ignore'', ''ignore'']`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''inherit''` is equivalent to `[''inherit'', ''inherit'', ''inherit'']`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '12.2.1.4 Result: instance of `ChildProcess`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`spawn()` returns instances of [`ChildProcess`](https://nodejs.org/api/child_process.html#class-childprocess).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interesting data properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.exitCode: number | null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contains the code with which the child process exited:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 0 (zero) means normal exit.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A number greater than zero means an error happened.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null` means the process hasn’t exited yet.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.signalCode: string | null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The POSIX signal with which a child process was killed or `null` if it wasn’t.
    See the description of method `.kill()` below for more information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Streams: Depending on how standard I/O is configured (see previous subsection),
    the following streams become available:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.stdin`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.stdout`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.stderr`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.pid: number | undefined`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *process identifier* (PID) of the child process. If spawning fails, `.pid`
    is `undefined`. This value is available immediately after calling `spawn()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Interesting methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.kill(signalCode?: number | string = ''SIGTERM''): boolean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sends a POSIX signal to the child process (which usually results in the termination
    of the process):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[The man page for `signal`](https://man7.org/linux/man-pages/man7/signal.7.html)
    contains a list of values.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows does not support signals, but Node.js emulates some of them – e.g.:
    `SIGINT`, `SIGTERM`, and `SIGKILL`. For more information, see [the Node.js documentation](https://nodejs.org/api/process.html#signal-events).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This method is demonstrated [later in this chapter](ch_nodejs-child-process.html#terminating-child-process-kill).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Interesting events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.on(''exit'', (exitCode: number|null, signalCode: string|null) => {})`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This event is emitted after the child process ends:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The callback parameters provide us with either the exit code or the signal
    code: One of them will always be non-null.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of its standard I/O streams might still be open because multiple processes
    might share the same streams. Event `'close'` notifies us when all stdio streams
    are closed after the exit of a child process.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.on(''error'', (err: Error) => {})`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This event is most commonly emitted if a process could not be spawned (see [example](ch_nodejs-child-process.html#spawning-fails)
    later) or the child process could not be killed. An `'exit'` event may or may
    not be emitted after this event.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We’ll see later [how events can be turned into Promises that can be awaited](ch_nodejs-child-process.html#wait-for-child-process-exit-via-promise).
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.2 When is the shell command executed?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When using the asynchronous `spawn()`, the child process for the command is
    started asynchronously. The following code demonstrates that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 12.2.3 Command-only mode vs. args mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this section, we specify the same command invocation in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Command-only mode: We provide the whole invocation via the first parameter
    `command`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Args mode: We provide the command via the first parameter `command` and its
    arguments via the second parameter `args`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.2.3.1 Command-only mode
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Each command-only spawning with arguments requires `.shell` to be `true` (line
    A) – even if it’s as simple as this one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In line B, we tell `spawn()` how to handle standard I/O:'
  prefs: []
  type: TYPE_NORMAL
- en: Ignore standard input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipe the child process stdout to `childProcess.stdout` (a stream that belongs
    to the parent process).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipe child process stderr to parent process stderr.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, we are only interested in the output of the child process. Therefore,
    we are done once we have processed the output. In other cases, we might have to
    wait until the child exits. How to do that, is demonstrated later.
  prefs: []
  type: TYPE_NORMAL
- en: In command-only mode, we see more pecularities of shells – for example, the
    Windows Command shell output includes double quotes (last line).
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.3.2 Args mode
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 12.2.3.3 Meta-characters in `args`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s explore what happens if there are meta-characters in `args`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If we don’t use a shell, meta-characters such as the dollar sign (`$`) have
    no effect (line A).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a shell, `$USER` is interpreted as a variable (line B).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we don’t want that, we have to escape the dollar sign via a backslash (line
    C).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar effects occur with other meta-characters such as asterisks (`*`).
  prefs: []
  type: TYPE_NORMAL
- en: These were two examples of Unix shell meta-characters. Windows shells have their
    own meta-characters and their own ways of escaping.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.3.4 A more complicated shell command
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s use more shell features (which requires command-only mode):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 12.2.4 Sending data to the stdin of the child process
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far, we have only read the standard output of a child process. But we can
    also send data to standard input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We use the shell command `sort` (line A) to sort lines of text for us.
  prefs: []
  type: TYPE_NORMAL
- en: In line B, we use `Writable.toWeb()` to convert a native Node.js stream to a
    web stream (for more information, see [§10 “Using web streams on Node.js”](ch_web-streams.html)).
  prefs: []
  type: TYPE_NORMAL
- en: How to write to a WritableStream via a writer (line C) is also explained in
    [the chapter on web streams](ch_web-streams.html#writing-to-WritableStream).
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.5 Piping manually
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We previously let a shell execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we do the piping manually, from the echoes (line
    A) to the sorting (line B):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: ReadableStreams such as `echoOut` are asynchronously iterable. That’s why we
    can use a `for-await-of` loop to read their *chunks* (the fragments of the streamed
    data). For more information, see [§10 “Using web streams on Node.js”](ch_web-streams.html).
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.6 Handling unsuccessful exits (including errors)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are three main kinds of unsuccessful exits:'
  prefs: []
  type: TYPE_NORMAL
- en: The child process can’t be spawned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An error happens in the shell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A process is killed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.2.6.1 The child process can’t be spawned
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The following code demonstrates what happens if a child process can’t be spawned.
    In this case, the cause is that the shell’s path doesn’t point to an executable
    (line A).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the first time that we use events to work with child processes. In
    line B, we register an event listener for the `''error''` event. The child process
    starts after the current code fragment is finished. That helps prevent race conditions:
    When we start listening we can be sure that the event hasn’t been emitted yet.'
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.6.2 An error happens in the shell
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If the shell code contains an error, we don’t get an `''error''` event (line
    B), we get an `''exit''` event with a non-zero exit code (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 12.2.6.3 A process is killed
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If a process is killed on Unix, the exit code is `null` (line C) and the signal
    code is a string (line D):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is no error output (line E).
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the child process killing itself (line A), we could have also paused
    it for a longer time and killed it manually via the process ID that we logged
    in line B.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we kill a child process on Windows?
  prefs: []
  type: TYPE_NORMAL
- en: '`exitCode` is `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`signalCode` is `null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.2.7 Waiting for the exit of a child process
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes we only want to wait until a command is finished. That can be achieved
    via events and via Promises.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.7.1 Waiting via events
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We are using the standard Node.js event pattern and register a listener for
    the `'exit'` event (line A).
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.7.2 Waiting via Promises
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The helper function `onExit()` that we use in line A, returns a Promise that
    is fulfilled if an `''exit''` event is emitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If `eventEmitter` fails, the returned Promise is rejected and `await` throws
    an exception in line A. `onExit()` handles two kinds of failures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`exitCode` isn’t zero (line B). That happens:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is a shell error. Then `exitCode` is greater than zero.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the child process is killed on Unix. Then `exitCode` is `null` and `signalCode`
    is non-null.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Killing child process on Windows produces a shell error.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An `'error'` event is emitted (line C). That happens if the child process can’t
    be spawned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.2.8 Terminating child processes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 12.2.8.1 Terminating a child process via an AbortController
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In this example, we use an AbortController to terminate a shell command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We create an AbortController (line A), pass its signal to `spawn()` (line B),
    and terminate the shell command via the AbortController (line C).
  prefs: []
  type: TYPE_NORMAL
- en: The child process starts asynchronously (after the current code fragment is
    executed). That’s why we can abort before the process has even started and why
    we don’t see any output in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.8.2 Terminating a child process via `.kill()`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the next example, we terminate a child process via the method `.kill()`
    (last line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we kill the child process before it has started (asynchronously!)
    and there is no output.
  prefs: []
  type: TYPE_NORMAL
- en: '12.3 Spawning processes synchronously: `spawnSync()`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[`spawnSync()`](https://nodejs.org/api/child_process.html#child_processspawnsynccommand-args-options)
    is the synchronous version of `spawn()` – it waits until the child process exits
    before it synchronously(!) returns an object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters are mostly the same as [those of `spawn()`](ch_nodejs-child-process.html#spawn).
    `options` has a few additional properties – e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.input: string | TypedArray | DataView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this property exists, its value is sent to the standard input of the child
    process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.encoding: string` (default: `''buffer''`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifies the encoding that is used for all standard I/O streams.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The function returns an object. Its most interesting properties are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.stdout: Buffer | string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contains whatever was written to the standard output stream of the child process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.stderr: Buffer | string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contains whatever was written to the standard error stream of the child process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.status: number | null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contains the exit code of the child process or `null`. Either the exit code
    or the signal code are non-null.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.signal: string | null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contains the signal code of the child process or `null`. Either the exit code
    or the signal code are non-null.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.error?: Error`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This property is only created if spawning didn’t work and then contains an Error
    object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the asynchronous `spawn()`, the child process ran concurrently and we could
    read standard I/O via streams. In contrast, the synchronous `spawnSync()` collects
    the contents of the streams and returns them to us synchronously (see next subsection).
  prefs: []
  type: TYPE_NORMAL
- en: 12.3.1 When is the shell command executed?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When using the synchronous `spawnSync()`, the child process for the command
    is started synchronously. The following code demonstrates that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 12.3.2 Reading from stdout
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following code demonstrates how to read standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In line A, we use `options.stdio` to tell `spawnSync()` that we are only interested
    in standard output. We ignore standard input and pipe standard error to the parent
    process.
  prefs: []
  type: TYPE_NORMAL
- en: As a consequence, we only get a result property for standard output (line C)
    and the property for standard error is `null` (line D).
  prefs: []
  type: TYPE_NORMAL
- en: Since we can’t access the streams that `spawnSync()` uses internally to handle
    the standard I/O of the child process, we tell it which encoding to use, via `options.encoding`
    (line B).
  prefs: []
  type: TYPE_NORMAL
- en: 12.3.3 Sending data to the stdin of the child process
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can send data to the standard input stream of a child process via the options
    property `.input` (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 12.3.4 Handling unsuccessful exits (including errors)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are three main kinds of unsuccessful exits (when the exit code isn’t
    zero):'
  prefs: []
  type: TYPE_NORMAL
- en: The child process can’t be spawned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An error happens in the shell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A process is killed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.3.4.1 The child process can’t be spawned
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If spawning fails, `spawn()` emits an `''error''` event. In contrast, `spawnSync()`
    sets `result.error` to an error object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 12.3.4.2 An error happens in the shell
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If an error happens in the shell, the exit code `result.status` is greater
    than zero and `result.signal` is `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 12.3.4.3 A process is killed
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If the child process is killed on Unix, `result.signal` contains the name of
    the signal and `result.status` is `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that no output was sent to the standard error stream (line A).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we kill a child process on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`result.status` is 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`result.signal` is `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`result.stderr` is `''''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.4 Asynchronous helper functions based on `spawn()`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we look at two asynchronous functions in module `node:child_process`
    that are based on `spawn()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`exec()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`execFile()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We ignore [`fork()`](https://nodejs.org/api/child_process.html#child_processforkmodulepath-args-options)
    in this chapter. Quoting [the Node.js documentation](https://nodejs.org/api/child_process.html#child-process):'
  prefs: []
  type: TYPE_NORMAL
- en: '`fork()` spawns a new Node.js process and invokes a specified module with an
    IPC communication channel established that allows sending messages between parent
    and child.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 12.4.1 `exec()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[`exec()`](https://nodejs.org/api/child_process.html#child_processexeccommand-options-callback)
    runs a command in a newly spawned shell. The main differences with `spawn()` are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to returning a ChildProcess, `exec()` also delivers a result via
    a callback: Either an error object or the contents of stdout and stderr.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Causes of errors: child process can’t be spawned, shell error, child process
    killed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In contrast, `spawn()` only emits `'error'` events if the child process can’t
    be spawned. The other two failures are handled via exit codes and (on Unix) signal
    codes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no parameter `args`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default for `options.shell` is `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`exec()` can be converted to a Promise-based function via [`util.promisify()`](https://nodejs.org/api/util.html#utilpromisifyoriginal):'
  prefs: []
  type: TYPE_NORMAL
- en: The ChildProcess becomes a property of the returned Promise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Promise is settled as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fulfillment value: `{stdout, stderr}`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rejection value: same value as parameter `error` of the callback but with two
    additional properties: `.stdout` and `.stderr`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 12.4.2 `execFile()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[`execFile(file, args?, options?, callback?): ChildProcess`](https://nodejs.org/api/child_process.html#child_processexecfilefile-args-options-callback)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Works similarly to `exec()`, with the following differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The parameter `args` is supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default for `options.shell` is `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like `exec()`, `execFile()` can be converted to a Promise-based function via
    `util.promisify()`.
  prefs: []
  type: TYPE_NORMAL
- en: 12.5 Synchronous helper functions based on `spawnAsync()`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 12.5.1 `execSync()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[`execSync()`](https://nodejs.org/api/child_process.html#child_processexecsynccommand-options)
    runs a command in a new child process and waits synchronously until that process
    exits. The main differences with `spawnSync()` are:'
  prefs: []
  type: TYPE_NORMAL
- en: Only returns the contents of stdout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Three kinds of failures are reported via exceptions: child process can’t be
    spawned, shell error, child process killed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In contrast, the result of `spawnSync()` only has an `.error` property if the
    child process can’t be spawned. The other two failures are handled via exit codes
    and (on Unix) signal codes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no parameter `args`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default for `options.shell` is `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 12.5.2 `execFileSync()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[`execFileSync(file, args?, options?): Buffer | string`](https://nodejs.org/api/child_process.html#child_processexecfilesyncfile-args-options)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Works similarly to `execSync()`, with the following differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The parameter `args` is supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default for `options.shell` is `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.6 Useful libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '12.6.1 tinysh: a helper for spawning shell commands'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[tinysh](https://github.com/antonmedv/tinysh) by Anton Medvedev is a small
    library that helps with spawning shell commands – e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can override the default options by using `.call()` to pass an object as
    `this`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use any property name and tinysh executes the shell command with that
    name. It achieves that feat via [a Proxy](https://exploringjs.com/deep-js/ch_proxies.html).
    This is a slightly modified version of the actual library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In line A, we can see that if we get a property whose name is `bin` from `sh`,
    a function is returned that invokes `execFileSync()` and uses `bin` as the first
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: Spreading `this` in line B enables us to specify options via `.call()`. The
    defaults come first, so that they can be overridden via `this`.
  prefs: []
  type: TYPE_NORMAL
- en: '12.6.2 node-powershell: executing Windows PowerShell commands via Node.js'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Using [the library node-powershell](https://github.com/rannn505/child-shell/tree/master/packages/node-powershell)
    on Windows, looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 12.7 Choosing between the functions of module `'node:child_process'`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'General constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: Should other asynchronous tasks run while the command is executed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use any asynchronous function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you only execute one command at a time (without async tasks in the background)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use any synchronous function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you want to access stdin or stdout of the child process via a stream?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Only asynchronous functions give you access to streams: `spawn()` is simpler
    in this case because it doesn’t have a callback that delivers errors and standard
    I/O content.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you want to capture stdout or stderr in a string?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Asynchronous options: `exec()` and `execFile()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Synchronous options: `spawnSync()`, `execSync()`, `execFileSync()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Asynchronous functions – choosing between `spawn()` and `exec()` or `execFile()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`exec()` and `execFile()` have two benefits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failures are easier to handle because they are all reported in the same manner
    – via the first callback parameter.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting stdout and stderr as strings is easier - due to the callback.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can pick `spawn()` if those benefits don’t matter to you. Its signature
    is simpler without the (optional) callback.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Synchronous functions – choosing between `spawnSync()` and `execSync()` or
    `execFileSync()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`execSync()` and `execFileSync()` have two specialties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They return a string with the content of stdout.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Failures are easier to handle because they are all reported in the same manner
    – via exceptions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Pick `spawnSync()` if you need more information than `execSync()` and `execFileSync()`
    provide via their return values and exceptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Choosing between `exec()` and `execFile()` (the same arguments apply to choosing
    between `execSync()` and `execFileSync()`):'
  prefs: []
  type: TYPE_NORMAL
- en: The default for `options.shell` is `true` in `exec()` but `false` in `execFile()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`execFile()` supports `args`, `exec()` doesn’t.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/nodejs-shell-scripting/issues/12)'
  prefs: []
  type: TYPE_NORMAL
