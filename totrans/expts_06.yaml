- en: 4 The basics of TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/ts/book/ch_typescript-essentials.html](https://exploringjs.com/ts/book/ch_typescript-essentials.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Ad, please don’t block.)
  prefs: []
  type: TYPE_NORMAL
- en: '[4.1 What you’ll learn](#what-you-ll-learn)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.2 How to play with code while reading this chapter](#how-to-play-with-code-while-reading-this-chapter)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.3 What is a type?](#what-is-a-type)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.4 TypeScript’s two language levels](#language-levels)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.4.1 Dynamic types vs. static types](#dynamic-types-vs-static-types)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.4.2 JavaScript’s dynamic types](#javascript-s-dynamic-types)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.4.3 TypeScript’s static types](#types-in-typescript)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.4.4 Revisiting the two language levels](#revisiting-the-two-language-levels)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.5 Primitive literal types](#primitive-literal-types)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.6 The types `any`, `unknown` and `never`](#the-types-any-unknown-and-never)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.6.1 The wildcard type `any`](#the-wildcard-type-any)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.7 Type inference](#type-inference)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.7.1 The rules of type inference](#the-rules-of-type-inference)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.8 Type aliases](#type-aliases)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.9 Compound types](#compound-types)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.10 Typing Arrays](#typing-arrays)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.10.1 Array types: `T[]` and `Array<T>`](#array-types-t-and-array-t)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.10.2 Tuple types: `[T0, T1, ···]`](#tuple-types-t0-t1)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.11 Function types](#function-types)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.11.1 Inferring function types](#inferring-function-types)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.11.2 Example: a function whose parameter is a function](#example-a-function-whose-parameter-is-a-function)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.11.3 Inferring the return types of functions](#inferring-the-return-types-of-functions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.11.4 The special return type `void`](#the-special-return-type-void)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.11.5 Optional parameters](#optional-parameters)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.11.6 Parameter default values](#parameter-default-values)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.11.7 Rest parameters](#rest-parameters)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.12 Typing objects](#typing-objects)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.12.1 Typing fixed-layout objects via object literal types](#typing-fixed-layout-objects-via-object-literal-types)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.12.2 Interfaces as an alternative to object literal types](#interfaces-as-an-alternative-to-object-literal-types)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.12.3 TypeScript’s structural typing vs. nominal typing](#typescript-s-structural-typing-vs-nominal-typing)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.12.4 Optional properties](#optional-properties)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.12.5 Methods](#methods)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.13 Union types](#union-types)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.13.1 Adding `undefined` and `null` to types](#adding-undefined-and-null-to-types)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.13.2 Unions of string literal types](#unions-of-string-literal-types)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.14 Intersection types](#intersection-types)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.15 Type guards and narrowing](#type-guards-and-narrowing)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.16 Type variables and generic types](#type-variables-and-generic-types)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.16.1 Example: a container for values](#example-a-container-for-values)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.16.2 Example: a generic class](#example-a-generic-class)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.16.3 Example: Maps](#example-maps)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.16.4 Functions and methods with type parameters](#functions-and-methods-with-type-parameters)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.17 Conclusion: understanding the initial example](#conclusion-understanding-the-initial-example)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.18 Next steps](#next-steps)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.18.1 Tip: Use `strict` type checking whenever you can](#tip-use-strict-type-checking-whenever-you-can)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: This chapter explains the basics of TypeScript. After reading it, you should
    be able to write your first TypeScript code. My hope is that that shouldn’t take
    you longer than a day. [I’d love to hear](https://dr-axel.de/#contact) how long
    it actually took you – my guess may be off.
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “reading”](../Images/00b0d6029a045810b908b88d1a6733d2.png) **Start reading
    here**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start reading this book with this chapter: No prior knowledge is required
    other than JavaScript. Alternatively, if you first want to get a better understanding
    of how TypeScript fits into development workflows as a tool, you can check out
    [“How TypeScript is used: workflows, tools, etc.” (§6)](ch_typescript-workflows.html#ch_typescript-workflows).'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.1 What you’ll learn](#what-you-ll-learn)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After reading this chapter, you should be able to understand the following
    TypeScript code (which we’ll get back to at the end):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You may think that this is cryptic. And I agree with you! But (as I hope to
    prove) this syntax is relatively easy to learn. And once you understand it, it
    gives you immediate, precise and comprehensive summaries of how code behaves –
    without having to read long descriptions in English.
  prefs: []
  type: TYPE_NORMAL
- en: '[4.2 How to play with code while reading this chapter](#how-to-play-with-code-while-reading-this-chapter)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This chapter is meant to be consumed passively: Everything you need to see
    is shown here, including explorations of what a piece of code does.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you may still want to play with TypeScript code. The following chapter
    explains how to do that: [“Trying out TypeScript without installing it” (§7)](ch_trying-out-typescript.html#ch_trying-out-typescript).'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.3 What is a type?](#what-is-a-type)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A type is a set of values. For example, the type `boolean` is a set whose elements
    are `false` and `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`S` being a subtype of `T` means that `S` is a subset of `T`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4.4 TypeScript’s two language levels](#language-levels)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'TypeScript is JavaScript plus syntax for adding static type information. Therefore,
    TypeScript has two *language levels* – two ways of using source code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *program level* (JavaScript): At this level, using TypeScript source code
    means running it: We have to remove the type information and feed it to a JavaScript
    engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *type level* (TypeScript): At this level, using TypeScript source code
    means type-checking it: We analyze the source code to make sure types are used
    consistently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  | Program level | Type level |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Programming language is | JavaScript | TypeScript |'
  prefs: []
  type: TYPE_TB
- en: '| Source code is | executed | type-checked |'
  prefs: []
  type: TYPE_TB
- en: '| Types are | dynamic | static |'
  prefs: []
  type: TYPE_TB
- en: '| Types exist at | runtime | compile time |'
  prefs: []
  type: TYPE_TB
- en: '[4.4.1 Dynamic types vs. static types](#dynamic-types-vs-static-types)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far, we have only talked about TypeScript’s (static) types. But JavaScript
    also has types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Its types are called *dynamic*. Why is that? We have to run code to see if
    they are used correctly – e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, TypeScript’s types are *static*: We check them by analyzing the
    syntax – without running the code. That happens during editing (for individual
    files) or when running the TypeScript compiler `tsc` (for the whole code base).
    In the following code, TypeScript detects the error via type checking (note that
    it doesn’t even need explicit type information in this case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “details”](../Images/837806d7ec89826c3784b2e685feb762.png) **`@ts-expect-error`
    shows type checking errors**'
  prefs: []
  type: TYPE_NORMAL
- en: In this book, type checking errors are shown via `@ts-expect-error` directives
    ([more information](ch_book-notation.html#notation-ts-expect-error)).
  prefs: []
  type: TYPE_NORMAL
- en: '[4.4.2 JavaScript’s dynamic types](#javascript-s-dynamic-types)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The JavaScript language (not TypeScript!) has only eight types. In the ECMAScript
    specification, they have names that start with capital letters. Here, I’m going
    with the values returned by `typeof` – e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript’s eight types are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined`: the set with the only element `undefined`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`null`: the set with the only element `null`. Due to a historical bad decision,
    `typeof` returns `''object''` for the value `null` and not `''null''`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`boolean`: the set with the two elements `false` and `true`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`number`: the set of all numbers'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bigint`: the set of all arbitrary-precision integers'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`string`: the set of all strings'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`symbol`: the set of all symbols'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`object`: the set of all objects (which includes functions and Arrays)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`typeof` additionally has a separate “type” for functions but that is not how
    ECMAScript sees things internally.'
  prefs: []
  type: TYPE_NORMAL
- en: All of these types are dynamic. They can also be used at the type level in TypeScript
    (see next section).
  prefs: []
  type: TYPE_NORMAL
- en: '[4.4.3 TypeScript’s static types](#types-in-typescript)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'TypeScript brings an additional layer to JavaScript: *static types*. In source
    code, there are:'
  prefs: []
  type: TYPE_NORMAL
- en: Sources of data – e.g. values created via literals such as `128`, `true` or
    `['a', 'b']`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sinks of data – e.g. storage locations such as variables, properties and parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage locations can also become data sources when we read from them.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both have static types in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of a data source describes what dynamic values it can be.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of a data sink describes what dynamic values can be written to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One way in which a storage location such as a variable can receive a static
    type is via a *type annotation* – e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The colon (`:`) plus the type `number` is the type annotation. It states that
    the static type of the variable `count` is `number`. The type annotation helps
    with type checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What does the error message mean? The (implicit) static type `string` of the
    data source `'yes'` is incompatible with the (explicitly specified) static type
    `number` of the data sink `count`.
  prefs: []
  type: TYPE_NORMAL
- en: '[4.4.3.1 A function with type annotations](#a-function-with-type-annotations)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The next example shows a function with type annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two type annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: The parameter `num` has the type `number`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return type of the function is `string`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4.4.4 Revisiting the two language levels](#revisiting-the-two-language-levels)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s briefly revisit the two language levels. It’s interesting to see how
    they show up in TypeScript’s syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: At the dynamic level, we use JavaScript to declare a variable `noValue` and
    initialize it with the value `undefined`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the static level, we use TypeScript to specify that variable `noValue` has
    the static type `undefined`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same syntax, `undefined`, is used at the JavaScript level and at the type
    level and means different things – depending on where it is used.
  prefs: []
  type: TYPE_NORMAL
- en: '[4.5 Primitive literal types](#primitive-literal-types)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Several primitive types have so-called *literal types*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `1000` after the colon is a type, a *number literal type*: It is a set
    whose only element is the value `1000` and it is a subtype of `number`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On one hand, any value we assign to `thousand` must be `1000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, we can assign `thousand` to any variable whose type is `number`
    because its type is a subtype of `number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Except for `symbol`, all primitive types have literal types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Especially string literal types will become useful later (when we get to union
    types).
  prefs: []
  type: TYPE_NORMAL
- en: '[4.6 The types `any`, `unknown` and `never`](#the-types-any-unknown-and-never)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'TypeScript has several types that are specific to the type level:'
  prefs: []
  type: TYPE_NORMAL
- en: '`any` is a wildcard type and accepts any value (see below).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unknown` is similar to `any` but less flexible: If a variable or parameter
    has that type, we can also write any value to it. However, we can’t do anything
    with its content unless we perform further type checks. Being less flexible is
    a good thing: I recommend avoiding `any` and instead using `unknown` whenever
    possible. For more information see [“The top types `any` and `unknown`” (§14)](ch_any-unknown.html#ch_any-unknown).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`never` the empty set as a type. Among other things, it is used for locations
    that are never reached when a program is executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4.6.1 The wildcard type `any`](#the-wildcard-type-any)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If the type of a storage location is neither explicitly specified nor inferrable,
    TypeScript uses the type `any` for it. `any` is the type of all values and a wildcard
    type: If a value has that type, TypeScript does not limit us in any way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If `strict` type checking is enabled, we can only use `any` explicitly: Every
    location must have an explicit or inferred static type. That is safer because
    there are no holes in type checking, no unintended blind spots.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at examples – the type of parameters can usually not be inferred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For `func3`, TypeScript can infer that `arg` has the type `boolean` because
    it has the default value `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[4.7 Type inference](#type-inference)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In many cases, TypeScript can automatically derive the types of data sources
    or data sinks, without us having to annotate anything. That is called *type inference*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of type inference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “details”](../Images/837806d7ec89826c3784b2e685feb762.png) **`assertType<T>(v)`
    shows the type `T` of a value `v`**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, `assertType<T>(v)` is used to show that a value `v` has the type
    `T` – which was either inferred or explicitly assigned. For more information see
    [“Type level: `assertType<T>(v)`” (§5.2)](ch_book-notation.html#notation-assertType).'
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript infers that the type of `count` is `14`. It can do so because it
    knows that the value `14` has the type `14`. Interestingly, TypeScript infers
    a more general type when we use `let`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Why is that? The assumption is that the value of `count` is preliminary and
    that we want to assign other (similar!) values later on. If `count` had the type
    `14` then we wouldn’t be able to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of type inference: In this case TypeScript infers that function
    `toString()` has the return type `string`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[4.7.1 The rules of type inference](#the-rules-of-type-inference)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Type inference is not guesswork: It follows clear rules (similar to arithmetic)
    for deriving types where they haven’t been specified explicitly. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The inferred type of `strValue` is `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1:** The inferred type of `32` is `32`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2:** `String` used as a function has the following type (simplified):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This type notation is used for functions and means:'
  prefs: []
  type: TYPE_NORMAL
- en: The function has one parameter, `value`. That parameter has the type `any`.
    If a parameter has that type, it accepts any kind of value. (More on `any` soon.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function returns values of type `string`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step 3:** By combining the results of step 1 and step 2, TypeScript can infer
    that `strValue` has the type `string`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.8 Type aliases](#type-aliases)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With `type` we can create a new name (an alias) for an existing type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[4.9 Compound types](#compound-types)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Compound types have other types inside them – which makes them very expressive.
    These are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’ll explore all of these compound types and more.
  prefs: []
  type: TYPE_NORMAL
- en: '[4.10 Typing Arrays](#typing-arrays)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'TypeScript has two different ways of typing Arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: An *Array type* `T[]` or `Array<T>` is used if an Array is a collection of values
    that all have the same type `T`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *tuple type* `[T0, T1, ···]` is used if the index of an Array element determines
    its type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4.10.1 Array types: `T[]` and `Array<T>`](#array-types-t-and-array-t)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For historical reasons, there are two equivalent ways of expressing the fact
    that `arr` is an Array, used to manage a sequence of numbers (think list, stack,
    queue, etc.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Normally, TypeScript can infer the type of a variable if there is an assignment.
    In this case, we have to help it because with an empty Array, it can’t determine
    the type of the elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll explore the angle brackets notation of `Array<number>` in more detail
    later (spoiler: `Array` is a *generic type* and `number` is a *type parameter*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript’s standard library, `Object.keys()` returns an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[4.10.2 Tuple types: `[T0, T1, ···]`](#tuple-types-t0-t1)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following variable `entry` has a tuple type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use it to create an object via `Object.fromEntries()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'What is the nature of `entry`? At the JavaScript level, it’s also an Array,
    but it is used differently:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The length is fixed: `2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The index of an element determines its meaning and its type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At index 0, there are keys whose type is `string`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: At index 1, there are values whose type is `number`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4.11 Function types](#function-types)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is an example of a function type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This type comprises every function that accepts a single parameter of type
    number and returns a string. Let’s use this type in a type annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Because TypeScript knows that `toString` has the type `NumToStr`, we do not
    need type annotations inside the arrow function.
  prefs: []
  type: TYPE_NORMAL
- en: '[4.11.1 Inferring function types](#inferring-function-types)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can also define `toString` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we specified both a type for the parameter `num` and a return type.
    The inferred type of `toString` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[4.11.2 Example: a function whose parameter is a function](#example-a-function-whose-parameter-is-a-function)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following function has a parameter `callback` whose type is a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to the type of the parameter `callback`, TypeScript rejects the following
    function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'But it accepts this function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use an arrow function to implement `stringify123()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[4.11.3 Inferring the return types of functions](#inferring-the-return-types-of-functions)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'TypeScript is good at inferring the return types of functions, but specifying
    them explicitly is recommended: It makes intentions clearer, enables additional
    consistency checks and helps external tools with generating declaration files
    (those tools usually can’t infer return types).'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.11.4 The special return type `void`](#the-special-return-type-void)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`void` is a special return type for a function: It tells TypeScript that the
    function always returns `undefined`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It may do so explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Or it may do so implicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'However, such a function cannot explicitly return values other than `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[4.11.5 Optional parameters](#optional-parameters)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A question mark after an identifier means that the parameter is optional. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript only lets us make the function call in line A if we make sure that
    `callback` isn’t `undefined` (which it is if the parameter was omitted).
  prefs: []
  type: TYPE_NORMAL
- en: '[4.11.6 Parameter default values](#parameter-default-values)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'TypeScript supports [parameter default values](https://exploringjs.com/js/book/ch_callables.html#parameter-default-values):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Default values make parameters optional. We can usually omit type annotations,
    because TypeScript can infer the types. For example, it can infer that `x` and
    `y` both have the type `number`.
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to add type annotations, that would look as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[4.11.7 Rest parameters](#rest-parameters)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can also use [rest parameters](https://exploringjs.com/js/book/ch_callables.html#rest-parameters)
    in TypeScript parameter definitions. Their static types must be Arrays or tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[4.12 Typing objects](#typing-objects)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similarly to Arrays, objects can be used in two ways in JavaScript (that are
    occasionally mixed):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixed-layout object: A fixed number of properties that are known at development
    time. Each property can have a different type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dictionary object: An arbitrary number of properties whose names are not known
    at development time. All properties have the same type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are ignoring dictionary objects in this chapter – they are covered in [“Index
    signatures: objects as dictionaries” (§18.7)](ch_typing-objects.html#index-signatures).
    As an aside, Maps are usually a better choice for dictionaries, anyway.'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.12.1 Typing fixed-layout objects via object literal types](#typing-fixed-layout-objects-via-object-literal-types)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Object literal types describe fixed-layout objects – e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We can also use semicolons instead of commas to separate members, but the latter
    are more common.
  prefs: []
  type: TYPE_NORMAL
- en: The members can also be separated by semicolons instead of commas but since
    the syntax of object literals types is related to the syntax of object literals
    (where members must be separated by commas), commas are used more often.
  prefs: []
  type: TYPE_NORMAL
- en: '[4.12.2 Interfaces as an alternative to object literal types](#interfaces-as-an-alternative-to-object-literal-types)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Interfaces are mostly equivalent to object literal types but have become less
    popular over time. This is what an interface looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The members can also be separated by commas instead of semicolons but since
    the syntax of interfaces is related to the syntax of classes (where members must
    be separated by semicolons), semicolons are used more often.
  prefs: []
  type: TYPE_NORMAL
- en: '[4.12.3 TypeScript’s structural typing vs. nominal typing](#typescript-s-structural-typing-vs-nominal-typing)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One big advantage of TypeScript’s type system is that it works *structurally*,
    not *nominally*. That is, the type `Point` matches all objects that have the appropriate
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Conversely, in Java’s nominal type system, we must explicitly declare with each
    class which interfaces it implements. Therefore, a class can only implement interfaces
    that exist at its creation time.
  prefs: []
  type: TYPE_NORMAL
- en: '[4.12.4 Optional properties](#optional-properties)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a property can be omitted, we put a question mark after its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, both `john` and `jane` match the type `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[4.12.5 Methods](#methods)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Object literal types can also contain methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As far as TypeScript’s type system is concerned, method definitions and properties
    whose values are functions, are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: My recommendation is to use whichever syntax best expresses how a property should
    be set up.
  prefs: []
  type: TYPE_NORMAL
- en: '[4.13 Union types](#union-types)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The values that are held by a variable (one value at a time) may be members
    of different types. In that case, we need a *union type*. For example, in the
    following code, `stringOrNumber` is either of type `string` or of type `number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`stringOrNumber` has the type `string|number`. The result of the type expression
    `s|t` is the set-theoretic union of the types `s` and `t` (interpreted as sets).'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.13.1 Adding `undefined` and `null` to types](#adding-undefined-and-null-to-types)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In TypeScript, the values `undefined` and `null` are not included in any type
    (other than the types `undefined`, `null`, `any` and `unknown`). That is common
    in statically type languages (with one notable exception being Java). We need
    union types such as `undefined|string` and `null|string` if we want to allow those
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that TypeScript does not force us to initialize immediately (as long as
    we don’t read from the variable before initializing it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[4.13.2 Unions of string literal types](#unions-of-string-literal-types)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Unions of string literals provide a quick way of defining a type with a limited
    set of values. For example, this is how the Node.js types define the buffer encoding
    that you can use (e.g.) with `fs.readFileSync()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: It’s neat that we get auto-completion for such unions ([figure 4.1](#fig:buffer-encoding-auto-completion)).
    We can also rename the elements of the union everywhere they are used – via the
    same refactoring that also changes function names.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e83419228addc1b19a19dd9cd54dc537.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: The auto-completion for `BufferEncoding` shows all elements of
    the union type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.14 Intersection types](#intersection-types)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Where a union type computes the union of two types, viewed as sets, an intersection
    type computes the intersection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “details”](../Images/837806d7ec89826c3784b2e685feb762.png) **The generic
    type `Assert<B>` is for comparing types**'
  prefs: []
  type: TYPE_NORMAL
- en: In this book, types are compared via the generic type `Assert<B>` ([more information](ch_book-notation.html#notation-generic-type-Assert)).
  prefs: []
  type: TYPE_NORMAL
- en: One key use case for intersection types is combining object types ([more information](ch_intersections-object-types.html#ch_intersections-object-types)).
  prefs: []
  type: TYPE_NORMAL
- en: '[4.15 Type guards and narrowing](#type-guards-and-narrowing)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes we are faced with types that are overly general. Then we need to use
    conditions with so-called *type guards* to make them small enough so that we can
    use them. That process is called *narrowing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we narrow the type of `value` via the type guard `typeof`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s interesting to see how the type of `value` changes, due to us using `typeof`
    in the condition of an `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: Initially, the type of `value` is `string | number` (line A).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s why we can’t access property `.length` in line B.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the true branch of the `if` statement, the type of `value` is `string`
    (line C).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we can access property `.length` (line D).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Because we return from inside the true branch, TypeScript knows that `value`
    has type `number` in line E.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4.16 Type variables and generic types](#type-variables-and-generic-types)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recall [the two language levels of TypeScript](#language-levels):'
  prefs: []
  type: TYPE_NORMAL
- en: Values exist at the *dynamic level*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types exist at the *static level*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Normal functions exist at the dynamic level, are factories for values and have
    parameters representing values. Parameters are declared between parentheses:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Generic types* exist at the static level, are factories for types and have
    parameters representing types. Parameters are declared between angle brackets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Icon “tip”](../Images/0873709827ba4924e4afbb757e47a4df.png) **Naming type
    parameters**'
  prefs: []
  type: TYPE_NORMAL
- en: In TypeScript, it is common to use a single uppercase character (such as `T`,
    `I`, and `O`) for a type parameter. However, any legal JavaScript identifier is
    allowed and longer names often make code easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: '[4.16.1 Example: a container for values](#example-a-container-for-values)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '`Value` is a *type variable*. One or more type variables can be introduced
    between angle brackets.'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.16.2 Example: a generic class](#example-a-generic-class)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Classes can have type parameters, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Class `SimpleStack` has the type parameter `Elem`. When we instantiate the
    class, we also provide a value for the type parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[4.16.3 Example: Maps](#example-maps)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Maps are typed generically in TypeScript. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to type inference (based on the argument of `new Map()`), we can omit
    the type parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[4.16.4 Functions and methods with type parameters](#functions-and-methods-with-type-parameters)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Function definitions can introduce type variables like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to type inference, we can once again omit the type parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The type of `num2` is the number literal type `123`.
  prefs: []
  type: TYPE_NORMAL
- en: '[4.16.4.1 Arrow functions with type parameters](#arrow-functions-with-type-parameters)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Arrow functions can also have type parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[4.16.4.2 Methods with type parameters](#methods-with-type-parameters)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This is the type parameter syntax for methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[4.16.4.3 A more complicated function example](#a-more-complicated-function-example)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The type variable `T` appears four times in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: It is introduced via `fillArray<T>`. Therefore, its scope is the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is used for the first time in the type annotation for the parameter `elem`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is used for the second time to specify the return type of `fillArray()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also used as a type argument for the constructor `Array()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can omit the type parameter when calling `fillArray()` (line A) because
    TypeScript can infer `T` from the parameter `elem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[4.17 Conclusion: understanding the initial example](#conclusion-understanding-the-initial-example)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s use what we have learned to understand the piece of code we have seen
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an interface for Arrays whose elements are of type `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'method `.concat()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has zero or more parameters (defined via a rest parameter). Each of those parameters
    has the type `T[]|T`. That is, it is either an Array of `T` values or a single
    `T` value. That means that the values in `items` have the same type `T` as the
    values in `this` (the receiver of the method call).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns an Array whose elements also have the type `T`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'method `.reduce()` introduces its own type variable `U`. `U` is used to express
    the fact that the following entities all have the same type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameter `state` of `callback()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Result of `callback()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional parameter `firstState` of `.reduce()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Result of `.reduce()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to `state`, `callback()` has the following parameters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`element`: which has the same type `T` as the Array elements'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index`: a number'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4.18 Next steps](#next-steps)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, you’ll probably want to read [“How TypeScript is used: workflows, tools,
    etc.” (§6)](ch_typescript-workflows.html#ch_typescript-workflows) – which gives
    you a better understanding of how TypeScript is used in practice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then you can move on to the rest of the book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While using TypeScript, keep the following tip in mind.
  prefs: []
  type: TYPE_NORMAL
- en: '[4.18.1 Tip: Use `strict` type checking whenever you can](#tip-use-strict-type-checking-whenever-you-can)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are many ways in which the TypeScript compiler can be configured. One
    important group of options controls how strictly the compiler checks TypeScript
    code. My recommendation is:'
  prefs: []
  type: TYPE_NORMAL
- en: Option `strict` should always be enabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a few additional settings that increase strictness even further:
    I’d start with all of them and deactivate those whose errors you don’t like or
    don’t want to deal with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may be tempted to use settings that produce fewer compiler errors. However,
    without `strict` checking, TypeScript simply doesn’t work as well and will detect
    far fewer problems in your code.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on configuring TypeScript, see [“Guide to `tsconfig.json`”
    (§8)](ch_tsconfig-json.html#ch_tsconfig-json).
  prefs: []
  type: TYPE_NORMAL
