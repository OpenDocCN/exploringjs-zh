<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>44 Async functions ES2017</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>44 Async functions ES2017</h1>
<blockquote>原文：<a href="https://exploringjs.com/js/book/ch_async-functions.html">https://exploringjs.com/js/book/ch_async-functions.html</a></blockquote>

        
    
    
    
<p><span id="index-entry-async-function"/><span id="index-entry-async-await"/></p>
<nav class="local-toc">
  <ol>
    <li>
      <a href="#async-functions-the-basics">44.1 Async functions: the basics</a>
      <ol>
        <li>
          <a href="#await-operator">44.1.1 The <code>await</code> operator makes Promises synchronous</a>
        </li>
        <li>
          <a href="#async-function-return">44.1.2 Returning a value from an async function resolves the function’s result</a>
        </li>
        <li>
          <a href="#async-callables">44.1.3 Asynchronous callable entities</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#what-values-can-be-used-with-await">44.2 What values can be used with <code>await</code>?</a>
      <ol>
        <li>
          <a href="#awaiting-fulfilled-promises">44.2.1 Awaiting fulfilled Promises</a>
        </li>
        <li>
          <a href="#awaiting-rejected-promises">44.2.2 Awaiting rejected Promises</a>
        </li>
        <li>
          <a href="#awaiting-nonpromise-values">44.2.3 Awaiting non-Promise values</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#where-can-await-be-used">44.3 Where can <code>await</code> be used?</a>
      <ol>
        <li>
          <a href="#using-await-at-the-top-levels-of-modules-es2022">44.3.1 Using <code>await</code> at the top levels of modules<span> <sup>ES2022</sup></span></a>
        </li>
        <li>
          <a href="#awaiting-is-shallow">44.3.2 Awaiting is shallow</a>
        </li>
        <li>
          <a href="#map-with-async-callback">44.3.3 Example: <code>.map()</code> with an async function as a callback</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#return-in-async-functions">44.4 <code>return</code> in async functions</a>
      <ol>
        <li>
          <a href="#the-result-of-an-async-function-is-always-a-promise">44.4.1 The result of an async function is always a Promise</a>
        </li>
        <li>
          <a href="#returning-a-promise-resolves-the-result-promise">44.4.2 Returning a Promise resolves the result Promise</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#async-funcs-start-sync-settle-async">44.5 Async functions start synchronously, settle asynchronously</a>
    </li>
    <li>
      <a href="#tips-for-using-async-functions">44.6 Tips for using async functions</a>
      <ol>
        <li>
          <a href="#fire-and-forget-await">44.6.1 We don’t need <code>await</code> if we “fire and forget”</a>
        </li>
        <li>
          <a href="#it-can-make-sense-to-await-and-ignore-the-result">44.6.2 It can make sense to <code>await</code> and ignore the result</a>
        </li>
        <li>
          <a href="#return-await">44.6.3 The pros and cons of <code>return await</code></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#concurrency-and-await">44.7 Concurrency and <code>await</code><span> (advanced)</span></a>
      <ol>
        <li>
          <a href="#await-sequentially">44.7.1 <code>await</code>: running Promise-based functions sequentially</a>
        </li>
        <li>
          <a href="#await-concurrently">44.7.2 <code>await</code>: running Promise-based functions concurrently</a>
        </li>
      </ol>
    </li>
  </ol>
</nav>
<p><em>Async functions</em> provide better syntax for code that uses Promises. Promises are therefore required knowledge for understanding async functions. They are explained in <a href="ch_promises.html#ch_promises">the previous chapter</a>.</p>
<h3 id="async-functions-the-basics"><a class="heading-id-link" href="#async-functions-the-basics">44.1 Async functions: the basics</a></h3>
<p>Consider the following async function:</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchJsonAsync</span>(<span class="hljs-params">url</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> request = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url); <span class="hljs-comment">// async</span>
    <span class="hljs-keyword">const</span> text = <span class="hljs-keyword">await</span> request.<span class="hljs-title function_">text</span>(); <span class="hljs-comment">// async</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(text); <span class="hljs-comment">// sync</span>
  }
  <span class="hljs-keyword">catch</span> (error) {
    assert.<span class="hljs-title function_">fail</span>(error);
  }
}
</pre>
<p>Two keywords are important:</p>
<ul>
  <li>
    The keyword <code>async</code> before <code>function</code> means that this is an async function.
  </li>
  <li>
    The <code>await</code> operator is applied to Promises and either extracts fulfillment values or throws rejection values. More on it soon.
  </li>
</ul>
<p>The previous, rather synchronous-looking code is equivalent to the following code that uses Promises directly:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchJsonViaPromises</span>(<span class="hljs-params">url</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(url) <span class="hljs-comment">// async</span>
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">request</span> =&gt;</span> request.<span class="hljs-title function_">text</span>()) <span class="hljs-comment">// async</span>
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">text</span> =&gt;</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(text)) <span class="hljs-comment">// sync</span>
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    assert.<span class="hljs-title function_">fail</span>(error);
  });
}
</pre>
<p>Both <code>fetchJsonAsync()</code> and <code>fetchJsonViaPromises()</code> are called in exactly the same way – e.g., like this:</p>
<pre class="language-js">
<span class="hljs-title function_">fetchJsonAsync</span>(<span class="hljs-string">'http://example.com/person.json'</span>)
.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> {
  assert.<span class="hljs-title function_">deepEqual</span>(obj, {
    <span class="hljs-attr">first</span>: <span class="hljs-string">'Jane'</span>,
    <span class="hljs-attr">last</span>: <span class="hljs-string">'Doe'</span>,
  });
});
</pre>
<div class="boxout">
  <p><img src="../Images/38ba63de820aae6f94a019538ae0f222.png" class="boxout-icon" height="24" alt="Icon “details”" data-original-src="https://exploringjs.com/js/book/icon/details.svg"/> <strong>Async functions are as Promise-based as functions that use Promises directly</strong></p>
  <div class="boxout-vspace"/>
  <p>From the outside, it is virtually impossible to tell the difference between an async function and a function that returns a Promise.</p>
</div>
<h4 id="await-operator"><a class="heading-id-link" href="#await-operator">44.1.1 The <code>await</code> operator makes Promises synchronous</a></h4>
<p>Inside the body of an async function, we write Promise-based code as if it were synchronous. We only need to apply the <code>await</code> operator whenever a value is a Promise. That operator pauses the async function and resumes it once the Promise is settled:</p>
<ul>
  <li>
    <p>If the Promise is fulfilled, <code>await</code> returns the fulfillment value.</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'fulfilled'</span>),</span>
<span class="hljs-params">    <span class="hljs-string">'fulfilled'</span></span>
<span class="hljs-params">  );</span>
<span class="hljs-params">}</span>
</pre>
  </li>
  <li>
    <p>If the Promise is rejected, <code>await</code> throws the rejection value.</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-keyword">try</span> {</span>
<span class="hljs-params">    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">'rejected'</span>);</span>
<span class="hljs-params">  } <span class="hljs-keyword">catch</span> (err) {</span>
<span class="hljs-params">    assert.<span class="hljs-title function_">equal</span>(err, <span class="hljs-string">'rejected'</span>);</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
</pre>
  </li>
</ul>
<h4 id="async-function-return"><a class="heading-id-link" href="#async-function-return">44.1.2 Returning a value from an async function resolves the function’s result</a></h4>
<p>The result of an async function is always a Promise:</p>
<ul>
  <li>
    <p>Any value that is returned (explicitly or implicitly) is used to resolve that Promise:</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params">) { <span class="hljs-keyword">return</span> <span class="hljs-string">'fulfilled'</span> }</span>
<span class="hljs-params"><span class="hljs-title function_">f1</span>().<span class="hljs-title function_">then</span>(</span>
<span class="hljs-params">  <span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> assert.<span class="hljs-title function_">equal</span>(result, <span class="hljs-string">'fulfilled'</span>)</span>
<span class="hljs-params">);</span>
</pre>
  </li>
  <li>
    <p>Any exception that is thrown is used to reject the Promise:</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">) { <span class="hljs-keyword">throw</span> <span class="hljs-string">'rejected'</span> }</span>
<span class="hljs-params"><span class="hljs-title function_">f</span>().<span class="hljs-title function_">catch</span>(</span>
<span class="hljs-params">  <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> assert.<span class="hljs-title function_">equal</span>(error, <span class="hljs-string">'rejected'</span>)</span>
<span class="hljs-params">);</span>
</pre>
  </li>
</ul>
<h4 id="async-callables"><a class="heading-id-link" href="#async-callables">44.1.3 Asynchronous callable entities</a></h4>
<p><span id="index-entry-async"/></p>
<p>JavaScript has the following async versions of synchronous callable entities. Their roles are always either real function or method.</p>
<pre class="language-js">
<span class="hljs-comment">// Async function declaration</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params">) {}</span>
<code/>
<span class="hljs-params"><span class="hljs-comment">// Async function expression</span></span>
<span class="hljs-params"><span class="hljs-keyword">const</span> func2 = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {};</span>
<code/>
<span class="hljs-params"><span class="hljs-comment">// Async arrow function</span></span>
<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-title function_">func3</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {};</span>
<code/>
<span class="hljs-params"><span class="hljs-comment">// Async method definition in an object literal</span></span>
<span class="hljs-params"><span class="hljs-keyword">const</span> obj = { <span class="hljs-keyword">async</span> <span class="hljs-title function_">m</span>(<span class="hljs-params"/>) {} };</span>
<code/>
<span class="hljs-params"><span class="hljs-comment">// Async method definition in a class definition</span></span>
<span class="hljs-params"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> { <span class="hljs-keyword">async</span> <span class="hljs-title function_">m</span>(<span class="hljs-params"/>) {} }</span>
</pre>
<div class="boxout">
  <p><img src="../Images/38ba63de820aae6f94a019538ae0f222.png" class="boxout-icon" height="24" alt="Icon “details”" data-original-src="https://exploringjs.com/js/book/icon/details.svg"/> <strong>Asynchronous functions vs. async functions</strong></p>
  <div class="boxout-vspace"/>
  <p>The difference between the terms <em>asynchronous function</em> and <em>async function</em> is subtle, but important:</p>
  <ul>
    <li>
      <p>An <em>asynchronous function</em> is any function that delivers its result asynchronously – for example, a callback-based function or a Promise-based function.</p>
    </li>
    <li>
      <p>An <em>async function</em> is defined via special syntax, involving the keywords <code>async</code> and <code>await</code>. It is also called async/await due to these two keywords. Async functions are based on Promises and therefore also asynchronous functions (which is somewhat confusing).</p>
    </li>
  </ul>
  <p>That being said: These two terms are also often used interchangeably.</p>
</div>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Fetch API via async functions</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/async-functions/fetch_json2_test.mjs</code></p>
</div>
<h3 id="what-values-can-be-used-with-await"><a class="heading-id-link" href="#what-values-can-be-used-with-await">44.2 What values can be used with <code>await</code>?</a></h3>
<p><span id="index-entry-await--async-function-"/></p>
<p>The <code>await</code> operator can only be used inside async functions and async generators (which are explained in <a href="ch_async-iteration.html#async-generators">“Asynchronous generators” (§45.2)</a>). Its operand is usually a Promise and leads to the following steps being performed:</p>
<ul>
  <li>
    The current async function is paused.
  </li>
  <li>
    When and if the Promise is settled, the async function is resumed:
    <ul>
      <li>
        If the Promise is fulfilled, <code>await</code> returns the fulfillment value.
      </li>
      <li>
        If the Promise is rejected, <code>await</code> throws the rejection value.
      </li>
    </ul>
  </li>
</ul>
<p>For more information on what exactly pausing and resuming means, see <a href="#async-funcs-start-sync-settle-async">“Async functions start synchronously, settle asynchronously” (§44.5)</a>.</p>
<p>Read on to find out how <code>await</code> handles various values.</p>
<h4 id="awaiting-fulfilled-promises"><a class="heading-id-link" href="#awaiting-fulfilled-promises">44.2.1 Awaiting fulfilled Promises</a></h4>
<p>If its operand is a fulfilled Promise, <code>await</code> returns its fulfillment value:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'fulfilled'</span>), <span class="hljs-string">'fulfilled'</span>
);
</pre>
<p>The value of <code>await</code> is delivered asynchronously:</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">awaitPromise</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-title function_">queueMicrotask</span>( <span class="hljs-comment">// (A)</span></span>
<span class="hljs-params">    <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'OTHER TASK'</span>)</span>
<span class="hljs-params">  );</span>
<span class="hljs-params">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'before'</span>);</span>
<span class="hljs-params">  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'fulfilled'</span>);</span>
<span class="hljs-params">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'after'</span>);</span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-keyword">await</span> <span class="hljs-title function_">awaitPromise</span>();</span>
</pre>
<p>Output:</p>
<pre>
before
OTHER TASK
after
</pre>
<p>In line A, we can’t use <code>setTimeout()</code>. We have to use <code>queueMicrotask()</code> because Promise-related tasks are so-called <em>microtasks</em> which are different from normal tasks and always handled before them (via a <em>microtask queue</em>). For more information, see the MDN article <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth">“In depth: Microtasks and the JavaScript runtime environment”</a>.</p>
<h4 id="awaiting-rejected-promises"><a class="heading-id-link" href="#awaiting-rejected-promises">44.2.2 Awaiting rejected Promises</a></h4>
<p>If its operand is a rejected Promise, then <code>await</code> throws the rejection value:</p>
<pre class="language-js">
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Problem!'</span>)
  );
  assert.<span class="hljs-title function_">fail</span>(); <span class="hljs-comment">// we never get here</span>
} <span class="hljs-keyword">catch</span> (err) {
  assert.<span class="hljs-title function_">deepEqual</span>(err, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Problem!'</span>));
}
</pre>
<h4 id="awaiting-nonpromise-values"><a class="heading-id-link" href="#awaiting-nonpromise-values">44.2.3 Awaiting non-Promise values</a></h4>
<p>Non-Promise values can also be awaited and are simply passed on:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-keyword">await</span> <span class="hljs-string">'non-Promise value'</span>, <span class="hljs-string">'non-Promise value'</span>
);
</pre>
<p>Even in this case, the result of <code>await</code> is delivered asynchronously:</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">awaitNonPromiseValue</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'OTHER TASK'</span>));</span>
<span class="hljs-params">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'before'</span>);</span>
<span class="hljs-params">  <span class="hljs-keyword">await</span> <span class="hljs-string">'non-Promise value'</span>;</span>
<span class="hljs-params">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'after'</span>);</span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-keyword">await</span> <span class="hljs-title function_">awaitNonPromiseValue</span>();</span>
</pre>
<p>Output:</p>
<pre>
before
OTHER TASK
after
</pre>
<h3 id="where-can-await-be-used"><a class="heading-id-link" href="#where-can-await-be-used">44.3 Where can <code>await</code> be used?</a></h3>
<h4 id="using-await-at-the-top-levels-of-modules-es2022"><a class="heading-id-link" href="#using-await-at-the-top-levels-of-modules-es2022">44.3.1 Using <code>await</code> at the top levels of modules<span> <sup>ES2022</sup></span></a></h4>
<p>We can use <code>await</code> at the top levels of modules – for example:</p>
<pre class="language-js">
<span class="hljs-keyword">let</span> mylib;
<span class="hljs-keyword">try</span> {
  mylib = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'https://primary.example.com/mylib'</span>);
} <span class="hljs-keyword">catch</span> {
  mylib = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'https://secondary.example.com/mylib'</span>);
}
</pre>
<p>For more information on this feature, see <a href="ch_modules.html#top-level-await">“Top-level <code>await</code> in modules<span> <sup>ES2022</sup> (advanced)</span>” (§29.15)</a>.</p>
<h4 id="awaiting-is-shallow"><a class="heading-id-link" href="#awaiting-is-shallow">44.3.2 Awaiting is shallow</a></h4>
<p>If we are inside an async function and want to pause it via <code>await</code>, we must do so directly within that function; we can’t use it inside a nested function, such as a callback. That is, pausing is <em>shallow</em>.</p>
<p>Let’s examine what that means. In the following code, we try to await inside a nested function:</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">nestedFunc</span> = (<span class="hljs-params"/>) =&gt; {</span>
<span class="hljs-params">    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'abc'</span>); <span class="hljs-comment">// SyntaxError!</span></span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">'RESULT: '</span> + result;</span>
<span class="hljs-params">  };</span>
<span class="hljs-params">  <span class="hljs-keyword">return</span> [ <span class="hljs-title function_">nestedFunc</span>() ];</span>
<span class="hljs-params">}</span>
</pre>
<p>However, that isn’t even valid syntax because <code>await</code> is not allowed inside synchronous functions such as <code>nestedFunc()</code>. What happens if we make <code>nestedFunc()</code> an async function?</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">nestedFunc</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {</span>
<span class="hljs-params">    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'abc'</span>); <span class="hljs-comment">// (A)</span></span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">'RESULT: '</span> + result;</span>
<span class="hljs-params">  };</span>
<span class="hljs-params">  <span class="hljs-keyword">return</span> [ <span class="hljs-title function_">nestedFunc</span>() ]; <span class="hljs-comment">// (B)</span></span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">await</span> <span class="hljs-title function_">f</span>(); <span class="hljs-comment">// (C)</span></span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">  arr[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>, <span class="hljs-literal">true</span></span>
<span class="hljs-params">);</span>
</pre>
<p>This time, the <code>await</code> in line A pauses <code>nestedFunc()</code>, not <code>f()</code>. <code>nestedFunc()</code> returns a Promise, which is wrapped in an Array in line B. Note <a href="ch_modules.html#top-level-await">the top-level <code>await</code></a> in line C.</p>
<p>To make this code work, we must await the result of <code>nestedFunc()</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">nestedFunc</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {</span>
<span class="hljs-params">    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'abc'</span>);</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">'RESULT: '</span> + result;</span>
<span class="hljs-params">  };</span>
<span class="hljs-params">  <span class="hljs-keyword">return</span> [ <span class="hljs-keyword">await</span> <span class="hljs-title function_">nestedFunc</span>() ];</span>
<span class="hljs-params">}</span>
<span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span>
<span class="hljs-params">  <span class="hljs-keyword">await</span> <span class="hljs-title function_">f</span>(), [<span class="hljs-string">'RESULT: abc'</span>]</span>
<span class="hljs-params">);</span>
</pre>
<p>To summarize: <code>await</code> only affects the immediately surrounding function (which must be an async function).</p>
<h4 id="map-with-async-callback"><a class="heading-id-link" href="#map-with-async-callback">44.3.3 Example: <code>.map()</code> with an async function as a callback</a></h4>
<p>What happens if we use an async function as a callback for <code>.map()</code>? Then the result is an Array of Promises:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arrayOfPromises = arr.<span class="hljs-title function_">map</span>(
  <span class="hljs-keyword">async</span> (x) =&gt; { <span class="hljs-comment">/*···*/</span> }
);
</pre>
<p>We can use <a href="ch_promises.html#Promise.all"><code>Promise.all()</code></a> to convert that Array of Promises to a Promise for an Array and await that Promise:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> array = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(
  arr.<span class="hljs-title function_">map</span>(
    <span class="hljs-keyword">async</span> (x) =&gt; { <span class="hljs-comment">/*···*/</span> }
  )
);
</pre>
<p>We use that technique in the following code, which downloads files via <a href="ch_promises.html#fetch-api"><code>fetch()</code></a>. The content of each file is its filename.</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> urls = [
  <span class="hljs-string">'http://example.com/file1.txt'</span>,
  <span class="hljs-string">'http://example.com/file2.txt'</span>,
];
<span class="hljs-keyword">const</span> uppercaseTexts = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>( <span class="hljs-comment">// (A)</span>
  urls.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">async</span> (url) =&gt; {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);
    <span class="hljs-keyword">const</span> text = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">text</span>();
    <span class="hljs-keyword">return</span> text.<span class="hljs-title function_">toUpperCase</span>();
  })
);
assert.<span class="hljs-title function_">deepEqual</span>(
  uppercaseTexts,
  [<span class="hljs-string">'FILE1.TXT'</span>, <span class="hljs-string">'FILE2.TXT'</span>]
);
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Mapping and filtering asynchronously</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/async-functions/map_async_test.mjs</code></p>
</div>
<h3 id="return-in-async-functions"><a class="heading-id-link" href="#return-in-async-functions">44.4 <code>return</code> in async functions</a></h3>
<h4 id="the-result-of-an-async-function-is-always-a-promise"><a class="heading-id-link" href="#the-result-of-an-async-function-is-always-a-promise">44.4.1 The result of an async function is always a Promise</a></h4>
<p>If we call an async function, the result is always a Promise – even if the async function throws an exception. Inside the async function, we can fulfill the result Promise by returning non-Promise values (line A):</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFunc</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>; <span class="hljs-comment">// (A)</span></span>
<span class="hljs-params">}</span>
<code/>
<span class="hljs-params"><span class="hljs-title function_">asyncFunc</span>()</span>
<span class="hljs-params">.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> {</span>
<span class="hljs-params">  assert.<span class="hljs-title function_">equal</span>(result, <span class="hljs-number">123</span>);</span>
<span class="hljs-params">});</span>
</pre>
<p>As usual, if we don’t explicitly return anything, <code>undefined</code> is returned for us:</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFunc</span>(<span class="hljs-params">) {}</span>
<code/>
<span class="hljs-params"><span class="hljs-title function_">asyncFunc</span>()</span>
<span class="hljs-params">.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> {</span>
<span class="hljs-params">  assert.<span class="hljs-title function_">equal</span>(result, <span class="hljs-literal">undefined</span>);</span>
<span class="hljs-params">});</span>
</pre>
<p>We reject the result Promise via <code>throw</code> (line A):</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFunc</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Problem!'</span>); <span class="hljs-comment">// (A)</span></span>
<span class="hljs-params">}</span>
<code/>
<span class="hljs-params"><span class="hljs-title function_">asyncFunc</span>()</span>
<span class="hljs-params">.<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {</span>
<span class="hljs-params">  assert.<span class="hljs-title function_">deepEqual</span>(err, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Problem!'</span>));</span>
<span class="hljs-params">});</span>
</pre>
<h4 id="returning-a-promise-resolves-the-result-promise"><a class="heading-id-link" href="#returning-a-promise-resolves-the-result-promise">44.4.2 Returning a Promise resolves the result Promise</a></h4>
<p>If we return a Promise <code>q</code> then it resolves the result Promise <code>p</code> of the async function: <code>p</code> adopts the state of <code>q</code> (<code>q</code> basically replaces <code>p</code>). Resolving never nests Promises.</p>
<p>Returning a fulfilled Promise fulfills the result Promise:</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFunc1</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'fulfilled'</span>);</span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-keyword">const</span> p1 = <span class="hljs-title function_">asyncFunc1</span>();</span>
<span class="hljs-params">p1.<span class="hljs-title function_">then</span>(</span>
<span class="hljs-params">  <span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> assert.<span class="hljs-title function_">equal</span>(result, <span class="hljs-string">'fulfilled'</span>)</span>
<span class="hljs-params">);</span>
</pre>
<p>Returning a rejected Promise has the same effect as throwing an exception:</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFunc2</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">'rejected'</span>);</span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-keyword">const</span> p2 = <span class="hljs-title function_">asyncFunc2</span>();</span>
<span class="hljs-params">p2.<span class="hljs-title function_">catch</span>(</span>
<span class="hljs-params">  <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> assert.<span class="hljs-title function_">equal</span>(error, <span class="hljs-string">'rejected'</span>)</span>
<span class="hljs-params">);</span>
</pre>
<p>The behavior of <code>return</code> is similar to how a Promise <code>q</code> is treated in the following situations:</p>
<ul>
  <li>
    <code>return q</code> inside <code>promise.then((result) =&gt; { ··· })</code>
  </li>
  <li>
    <code>return q</code> inside <code>promise.catch((err) =&gt; { ··· })</code>
  </li>
  <li>
    <code>resolve(q)</code> inside <code>new Promise((resolve, reject) =&gt; { ··· })</code>
  </li>
</ul>
<h3 id="async-funcs-start-sync-settle-async"><a class="heading-id-link" href="#async-funcs-start-sync-settle-async">44.5 Async functions start synchronously, settle asynchronously</a></h3>
<p>Async functions are executed as follows:</p>
<ul>
  <li>
    The Promise <code>resultPromise</code> for the result is created when the async function is started.
  </li>
  <li>
    Then the body is executed. There are two ways in which execution can leave the body:
    <ul>
      <li>
        <strong>A permanent exit</strong> happens when <code>resultPromise</code> is settled:
        <ul>
          <li>
            <code>return</code> resolves <code>resultPromise</code>.
          </li>
          <li>
            <code>throw</code> rejects <code>resultPromise</code>.
          </li>
        </ul>
      </li>
      <li>
        <strong>A temporary exit</strong> happens when there is an <code>await</code> whose operand is a Promise <code>p</code>:
        <ul>
          <li>
            The async function is paused and execution leaves it (similarly to how <code>yield</code> works in <a href="ch_sync-generators.html#ch_sync-generators">sync generators</a>).
          </li>
          <li>
            It is resumed asynchronously (in a new task) once <code>p</code> is settled.
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    Promise <code>resultPromise</code> is returned after the first (permanent or temporary) exit.
  </li>
</ul>
<p>Note that the notification of the settlement of <code>resultPromise</code> happens asynchronously, as is always the case with Promises.</p>
<p>The following code demonstrates that an async function is started synchronously (line A), then the current task finishes (line C), then the result Promise is settled – asynchronously (line B).</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFunc</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'asyncFunc() starts'</span>); <span class="hljs-comment">// (A)</span></span>
<span class="hljs-params">  <span class="hljs-keyword">return</span> <span class="hljs-string">'abc'</span>;</span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-title function_">asyncFunc</span>().</span>
<span class="hljs-params"><span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> { <span class="hljs-comment">// (B)</span></span>
<span class="hljs-params">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Resolved: <span class="hljs-subst">${x}</span>`</span>);</span>
<span class="hljs-params">});</span>
<span class="hljs-params"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Task ends'</span>); <span class="hljs-comment">// (C)</span></span>
</pre>
<p>Output:</p>
<pre>
asyncFunc() starts
Task ends
Resolved: abc
</pre>
<h3 id="tips-for-using-async-functions"><a class="heading-id-link" href="#tips-for-using-async-functions">44.6 Tips for using async functions</a></h3>
<h4 id="fire-and-forget-await"><a class="heading-id-link" href="#fire-and-forget-await">44.6.1 We don’t need <code>await</code> if we “fire and forget”</a></h4>
<p><code>await</code> is not required when working with a Promise-based function; we only need it if we want to pause and wait until the returned Promise is settled. If we only want to start an asynchronous operation, then we don’t need it:</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFunc</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-keyword">const</span> writer = <span class="hljs-title function_">openFile</span>(<span class="hljs-string">'someFile.txt'</span>);</span>
<span class="hljs-params">  writer.<span class="hljs-title function_">write</span>(<span class="hljs-string">'hello'</span>); <span class="hljs-comment">// don’t wait</span></span>
<span class="hljs-params">  writer.<span class="hljs-title function_">write</span>(<span class="hljs-string">'world'</span>); <span class="hljs-comment">// don’t wait</span></span>
<span class="hljs-params">  <span class="hljs-keyword">await</span> writer.<span class="hljs-title function_">close</span>(); <span class="hljs-comment">// wait for file to close</span></span>
<span class="hljs-params">}</span>
</pre>
<p>In this code, we don’t await <code>.write()</code> because we don’t care when it is finished. We do, however, want to wait until <code>.close()</code> is done.</p>
<p>Note: Each invocation of <code>.write()</code> starts synchronously. That prevents race conditions.</p>
<h4 id="it-can-make-sense-to-await-and-ignore-the-result"><a class="heading-id-link" href="#it-can-make-sense-to-await-and-ignore-the-result">44.6.2 It can make sense to <code>await</code> and ignore the result</a></h4>
<p>It can occasionally make sense to use <code>await</code>, even if we ignore its result – for example:</p>
<pre class="language-js">
<span class="hljs-keyword">await</span> <span class="hljs-title function_">longRunningAsyncOperation</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Done!'</span>);
</pre>
<p>Here, we are using <code>await</code> to join a long-running asynchronous operation. That ensures that the logging really happens <em>after</em> that operation is done.</p>
<h4 id="return-await"><a class="heading-id-link" href="#return-await">44.6.3 The pros and cons of <code>return await</code></a></h4>
<p>If we await a Promise before returning it, we unwrap it before immediately wrapping it again:</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'result'</span>);</span>
<span class="hljs-params">}</span>
</pre>
<p>Since <code>return</code> resolves the result Promise of <code>f()</code>, the following code is simpler and equivalent:</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'result'</span>);</span>
<span class="hljs-params">}</span>
</pre>
<p>There are, however, three reasons to stick with <code>return await</code>:</p>
<ul>
  <li>
    The code fragment is easier to move around.
  </li>
  <li>
    We don’t depend on a feature of Promises that is slightly obscure: resolving unwraps Promises.
  </li>
  <li>
    It behaves better inside a <code>try-catch</code> statement (see below).
  </li>
</ul>
<p>Let’s explore the last reason. If we await the rejected Promise in line A before returning it, it causes an exception:</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-keyword">try</span> {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">'error'</span>); <span class="hljs-comment">// (A)</span></span>
<span class="hljs-params">  } <span class="hljs-keyword">catch</span> (err) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">'Caught an error: '</span> + err;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-title function_">f</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> {</span>
<span class="hljs-params">  assert.<span class="hljs-title function_">equal</span>(result, <span class="hljs-string">'Caught an error: error'</span>);</span>
<span class="hljs-params">});</span>
</pre>
<p>If, on the other hand, we return without <code>await</code>, no exception is thrown and the result Promise of <code>f()</code> adopts the state of the rejected Promise:</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-keyword">try</span> {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">'error'</span>);</span>
<span class="hljs-params">  } <span class="hljs-keyword">catch</span> (err) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">'Caught an error: '</span> + err;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-title function_">f</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> {</span>
<span class="hljs-params">  assert.<span class="hljs-title function_">equal</span>(reason, <span class="hljs-string">'error'</span>);</span>
<span class="hljs-params">});</span>
</pre>
<h3 id="concurrency-and-await"><a class="heading-id-link" href="#concurrency-and-await">44.7 Concurrency and <code>await</code><span> (advanced)</span></a></h3>
<p>In <span refcheck="#await-sequentially #await-concurrently">the next two subsections</span>, we’ll use the helper function <code>returnAfterPause()</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">returnAfterPause</span>(<span class="hljs-params">id</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'START '</span> + id);
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">delay</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// pause</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'END '</span> + id);
  <span class="hljs-keyword">return</span> id;
}
<code/>
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Resolves after `ms` milliseconds</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">delay</span>(<span class="hljs-params">ms</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, _reject</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(resolve, ms);
  });
}
</pre>
<h4 id="await-sequentially"><a class="heading-id-link" href="#await-sequentially">44.7.1 <code>await</code>: running Promise-based functions sequentially</a></h4>
<p>If we prefix the invocations of multiple Promise-based functions with <code>await</code>, then those functions are executed sequentially:</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sequentialAwait</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-keyword">const</span> result1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">returnAfterPause</span>(<span class="hljs-string">'first'</span>);</span>
<span class="hljs-params">  assert.<span class="hljs-title function_">equal</span>(result1, <span class="hljs-string">'first'</span>);</span>
<span class="hljs-params">  </span>
<span class="hljs-params">  <span class="hljs-keyword">const</span> result2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">returnAfterPause</span>(<span class="hljs-string">'second'</span>);</span>
<span class="hljs-params">  assert.<span class="hljs-title function_">equal</span>(result2, <span class="hljs-string">'second'</span>);</span>
<span class="hljs-params">}</span>
</pre>
<p>Output:</p>
<pre>
START first
END first
START second
END second
</pre>
<p>That is, <code>returnAfterPause('second')</code> is only started after <code>returnAfterPause('first')</code> is completely finished.</p>
<h4 id="await-concurrently"><a class="heading-id-link" href="#await-concurrently">44.7.2 <code>await</code>: running Promise-based functions concurrently</a></h4>
<p>If we want to run multiple Promise-based functions concurrently, we can use the utility method <code>Promise.all()</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">concurrentPromiseAll</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([</span>
<span class="hljs-params">    <span class="hljs-title function_">returnAfterPause</span>(<span class="hljs-string">'first'</span>),</span>
<span class="hljs-params">    <span class="hljs-title function_">returnAfterPause</span>(<span class="hljs-string">'second'</span>),</span>
<span class="hljs-params">  ]);</span>
<span class="hljs-params">  assert.<span class="hljs-title function_">deepEqual</span>(result, [<span class="hljs-string">'first'</span>, <span class="hljs-string">'second'</span>]);</span>
<span class="hljs-params">}</span>
</pre>
<p>Output:</p>
<pre>
START first
START second
END first
END second
</pre>
<p>Here, both asynchronous functions are started at the same time. Once both are settled, <code>await</code> gives us either an Array of fulfillment values or – if at least one Promise is rejected – an exception.</p>
<p>Recall from <a href="ch_promises.html#focus-on-async-start">earlier</a> that what counts is when we start a Promise-based computation; not how we process its result. Therefore, the following code is as “concurrent” as the previous one:</p>
<pre class="language-js">
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">concurrentAwait</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-keyword">const</span> resultPromise1 = <span class="hljs-title function_">returnAfterPause</span>(<span class="hljs-string">'first'</span>);</span>
<span class="hljs-params">  <span class="hljs-keyword">const</span> resultPromise2 = <span class="hljs-title function_">returnAfterPause</span>(<span class="hljs-string">'second'</span>);</span>
<span class="hljs-params">  </span>
<span class="hljs-params">  assert.<span class="hljs-title function_">equal</span>(<span class="hljs-keyword">await</span> resultPromise1, <span class="hljs-string">'first'</span>);</span>
<span class="hljs-params">  assert.<span class="hljs-title function_">equal</span>(<span class="hljs-keyword">await</span> resultPromise2, <span class="hljs-string">'second'</span>);</span>
<span class="hljs-params">}</span>
</pre>
<p>Output:</p>
<pre>
START first
START second
END first
END second
</pre>

    
      
</body>
</html>