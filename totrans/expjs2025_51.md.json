["```js\nconst promise = addAsync(3, 4);\npromise.then((result) => { // success\n assert.equal(result, 7);\n })\n .catch((error) => { // failure\n assert.fail(error);\n })\n;\n\n```", "```js\nfunction addAsync(x, y) {\n return new Promise( // (A)\n (resolve, reject) => { // (B)\n if (x === undefined || y === undefined) {\n reject(new Error('Must provide two parameters'));\n } else {\n resolve(x + y);\n }\n }\n );\n}\n\n```", "```js\nconst promise = new Promise(\n (resolve, reject) => {\n // ···\n }\n);\n\n```", "```js\n> doThingsWith(p);\n> \n> ```", "```js\nnew Promise(() => {})\n\n```", "```js\nPromise.resolve(123)\n .then((x) => {\n assert.equal(x, 123);\n });\n\n```", "```js\nconst abcPromise = Promise.resolve('abc');\nassert.equal(\n Promise.resolve(abcPromise), abcPromise\n);\n\n```", "```js\nconst myError = new Error('My error!');\nPromise.reject(myError)\n .catch((err) => {\n assert.equal(err, myError);\n });\n\n```", "```js\nfunction convertToNumber(stringOrNumber) {\n if (typeof stringOrNumber === 'number') {\n return Promise.resolve(stringOrNumber);\n } else if (typeof stringOrNumber === 'string') {\n return stringToNumberAsync(stringOrNumber);\n } else {\n return Promise.reject(new TypeError());\n }\n}\n\n```", "```js\nPromise.resolve('abc')\n .then((str) => {\n return str + str; // (A)\n })\n .then((str2) => {\n assert.equal(str2, 'abcabc'); // (B)\n });\n\n```", "```js\nPromise.resolve('abc')\n .then((str) => {\n return Promise.resolve(123); // (A)\n })\n .then((num) => {\n assert.equal(num, 123);\n });\n\n```", "```js\n// Flat\nasyncFunc1()\n .then((result1) => {\n /*···*/\n return asyncFunc2();\n })\n .then((result2) => {\n /*···*/\n });\n `// Nested`\n`asyncFunc1()`\n `.then((result1) => {`\n `/*···*/`\n `asyncFunc2()`\n `.then((result2) => {`\n `/*···*/`\n `});`\n `});` \n```", "```js```", "````js````", "```js```", "````js````", "```js const myError = new Error('My error!'); Promise.resolve('abc')  .then((str) => {  throw myError;  })  .catch((err) => {  assert.equal(err, myError);  });  ```", "```js const err = new Error();  `Promise.reject(err)`  `.catch((e) => {`  `assert.equal(e, err);`  `// Something went wrong, use a default value`  `return 'default value'; // (A)`  `})`  `.then((str) => {`  `assert.equal(str, 'default value');`  `});`  ```", "```js```", "````js````", "```js```", "````js``` #### [43.1.8 Chaining method calls](#chaining-method-calls)    `.then()` and `.catch()` always returning Promises enables us to create arbitrary long chains of method calls:    ``` function myAsyncFunc() {  return asyncFunc1() // (A)  .then((result1) => {  // ···  return asyncFunc2(); // a Promise  })  .then((result2) => {  // ···  return result2 ?? '(Empty)'; // not a Promise  })  .then((result3) => {  // ···  return asyncFunc4(); // a Promise  }); }  ```js    Due to chaining, the `return` in line A returns the result of the last `.then()`.    In a way, `.then()` is the asynchronous version of the synchronous semicolon:    *   `asyncFunc1().then(asyncFunc2)`     executes the asynchronous operations `asyncFunc1` and `asyncFunc2` sequentially. *   `syncFunc1(); syncFunc2()`     executes the synchronous operations `syncFunc1` and `syncFunc2` sequentially.    We can also add `.catch()` into the mix and let it handle multiple error sources at the same time:    ``` asyncFunc1()  .then((result1) => {  // ···  return asyncFunc2();  })  .then((result2) => {  // ···  })  .catch((error) => {  // Failure: handle errors of asyncFunc1(), asyncFunc2()  // and any (sync) exceptions thrown in previous callbacks  });  ```js    #### [43.1.9 `Promise.try()`: starting a Promise chain ^(ES2025)](#Promise.try)    Where the Promise method `.then(cb)` continues a Promise chain, `Promise.try(cb)` starts a Promise chain – while treating the callback `cb` similarly:    *   It calls `cb`. *   If `cb` throws an exception, `Promise.try()` returns a rejection with that exception. *   If `cb` returns a value, `Promise.try()` resolves that value into a Promise (without nesting if the value already is a Promise).    ##### [43.1.9.1 Use case for `Promise.try()`: starting a Promise chain with code that is not purely asynchronous](#use-case-for-promisetry-starting-a-promise-chain-with-code-that-is-not-purely-asynchronous)    We need `Promise.try()` to start a Promise chain with code that is a mix of synchronous and asynchronous functionality:    *   Why a mix? If code is purely asynchronous, we can use it to start a Promise chain. If code is purely synchronous, there is no need for Promises. *   Why at the start? Later in a Promise chain, Promise functions such as `.then()` are good tools for dealing with mixed code.    Let’s look at an example:    ``` function computeAsync() {  return Promise.try(() => {  const value = syncFuncMightThrow(); // (A)  return asyncFunc(value); // (B)  }); }  ```js    We have a mix of synchronous functionality (line A) and asynchronous functionality (line B).    Why wrap the code inside the callback at all? It helps if the synchronous function we call in line A throws an exception: Then `Promise.try()` catches that exception and converts it into a rejected Promise for us. Therefore, the previous code is mostly equivalent to:    ``` function computeAsync() {  try {  const value = syncFuncMightThrow();  return asyncFunc(value);  } catch (err) {  return Promise.reject(err);  } }  ```js    ##### [43.1.9.2 Why not use an async function?](#why-not-use-an-async-function)    `Promise.try()` is only needed if we work directly with Promises. Async functions (which are explained in [the next chapter](ch_async-functions.html#ch_async-functions)) already provide good support for dealing with a mix of sync and async code (anywhere).    ##### [43.1.9.3 Alternative to `Promise.try()`](#alternative-to-promisetry)    This following code is an alternative to `Promise.try()`:    ``` function countPlusOneAsync() {  return Promise.resolve().then(  () => countSyncOrAsync() // (A)  )  .then((result) => {  return result + 1;  }); }  ```js    `Promise.resolve()` creates a Promise that is fulfilled with `undefined`. That result does not matter to us. What does matter is that we have just started a Promise chain and can put the code to try into the callback in line A.    The main downside compared to `Promise.try()` is that this pattern executes the code in line A on the next tick (and not immediately).    #### [43.1.10 `Promise.prototype.finally()` ^(ES2018)](#Promise.prototype.finally)    The Promise method `.finally()` is often used as follows:    ``` somePromise  .then((result) => {  // ···  })  .catch((error) => {  // ···  })  .finally(() => {  // ···  }) ;  ```js    The `.finally()` callback is always executed – independently of `somePromise` and the values returned by `.then()` and/or `.catch()`. In contrast:    *   The `.then()` callback is only executed if `somePromise` is fulfilled. *   The `.catch()` callback is only executed if:     *   either `somePromise` is rejected,     *   or the `.then()` callback returns a rejected Promise,     *   or the `.then()` callback throws an exception.    If the callback returns a non-Promise value or a fulfilled Promise, `.finally()` ignores that result and simply passes on the settlement that existed before it was called:    ``` Promise.resolve(123)  .finally(() => {})  .then((result) => {  assert.equal(result, 123);  });  `Promise.reject('error')`  `.finally(() => {})`  `.catch((error) => {`  `assert.equal(error, 'error');`  `});`  ```js   ````", "```````js```````", "`````` If however, the `.finally()` callback throws an exception or returns a rejected Promise, the Promise returned by `.finally()` is rejected:    ```js Promise.reject('error (previously)')  .finally(() => {  throw 'error (finally)';  })  .catch((error) => {  assert.equal(error, 'error (finally)');  });  `Promise.reject('error (previously)')`  `.finally(() => {`  `return Promise.reject('error (finally)');`  `})`  `.catch((error) => {`  `assert.equal(error, 'error (finally)');`  `});`  ```   ```js``````", "```````js```````", "``` let connection; db.open() .then((conn) => {  connection = conn;  return connection.select({ name: 'Jane' }); }) .then((result) => {  // Process result  // Use `connection` to make more queries }) // ··· .catch((error) => {  // handle errors }) .finally(() => {  connection.close(); });  ```", "``` function handleAsyncResult(promise) {  return promise  .finally(() => {  console.log('finally');  })  .then((result) => {  console.log('then ' + result);  })  .catch((error) => {  console.log('catch ' + error);  })  ; }  ```", "``` handleAsyncResult(Promise.resolve('fulfilled'));  ```", "``` finally then fulfilled  ```", "``` handleAsyncResult(Promise.reject('rejected'));  ```", "``` finally catch rejected  ```", "``` new Promise(  (resolve, reject) => { ··· } );  ```", "``` const { promise, resolve, reject } = Promise.withResolvers();  ```", "``` {  const { promise, resolve, reject } = Promise.withResolvers();  resolve('fulfilled');  assert.equal(  await promise,  'fulfilled'  ); } {  const { promise, resolve, reject } = Promise.withResolvers();  reject('rejected');  try {  await promise;  } catch (err) {  assert.equal(err, 'rejected');  } }  ```", "``` function promiseWithResolvers() {  let resolve;  let reject;  const promise = new Promise(  (res, rej) => {  // Executed synchronously!  resolve = res;  reject = rej;  });  return {promise, resolve, reject}; }  ```", "``` class OneElementQueue {  #promise = null;  #resolve = null;  constructor() {  const { promise, resolve } = Promise.withResolvers();  this.#promise = promise;  this.#resolve = resolve;  }  get() {  return this.#promise;  }  put(value) {  this.#resolve(value);  } }  `{ // Putting before getting`  `const queue = new OneElementQueue();`  `queue.put('one');`  `assert.equal(`  `await queue.get(),`  `'one'`  `);` `}` `{ // Getting before putting`  `const queue = new OneElementQueue();`  `setTimeout(`  ``// Runs after `await` pauses the current execution context``  `() => queue.put('two'),`  `0`  `);`  `assert.equal(`  `await queue.get(),`  `'two'`  `);` `}`  ```", "``````js``````", "```````js```` #### [43.1.12 Advantages of promises over plain callbacks](#promises-vs-callbacks)    These are some of the advantages of Promises over plain callbacks when it comes to handling one-off results:    *   The type signatures of Promise-based functions and methods are cleaner: if a function is callback-based, some parameters are about input, while the one or two callbacks at the end are about output. With Promises, everything output-related is handled via the returned value.           *   Chaining asynchronous processing steps is more convenient.           *   Promises handle both asynchronous errors (via rejections) and synchronous errors: Inside the callbacks for `new Promise()`, `.then()`, and `.catch()`, exceptions are converted to rejections. In contrast, if we use callbacks for asynchronicity, exceptions are normally not handled for us; we have to do it ourselves.           *   Promises are a single standard that is slowly replacing several, mutually incompatible alternatives. For example, in Node.js, many functions are now available in Promise-based versions. And new asynchronous browser APIs are usually Promise-based.              One of the biggest advantages of Promises involves not working with them directly: they are the foundation of *async functions*, a synchronous-looking syntax for performing asynchronous computations. Asynchronous functions are covered in [the next chapter](ch_async-functions.html#ch_async-functions).    ### [43.2 Examples](#examples)    Seeing Promises in action helps with understanding them. Let’s look at examples.    #### [43.2.1 Node.js: Reading a file asynchronously](#nodejs-reading-a-file-asynchronously)    Consider the following text file `person.json` with [JSON data](ch_json.html#ch_json) in it:    ```js {  \"first\": \"Jane\",  \"last\": \"Doe\" }  ```    Let’s look at two versions of code that reads this file and parses it into an object. First, a callback-based version. Second, a Promise-based version.    ##### [43.2.1.1 The callback-based version](#the-callbackbased-version)    The following code reads the contents of this file and converts it to a JavaScript object. It is based on Node.js-style callbacks:    ```js import * as fs from 'node:fs'; fs.readFile('person.json',  (error, text) => {  if (error) { // (A)  // Failure  assert.fail(error);  } else {  // Success  try { // (B)  const obj = JSON.parse(text); // (C)  assert.deepEqual(obj, {  first: 'Jane',  last: 'Doe',  });  } catch (e) {  // Invalid JSON  assert.fail(e);  }  }  });  ```    `fs` is a built-in Node.js module for file system operations. We use the callback-based function `fs.readFile()` to read a file whose name is `person.json`. If we succeed, the content is delivered via the parameter `text` as a string. In line C, we convert that string from the text-based data format JSON into a JavaScript object. `JSON` is an object with methods for consuming and producing JSON. It is part of JavaScript’s standard library and documented [later in this book](ch_json.html#ch_json).    Note that there are two error-handling mechanisms: the `if` in line A takes care of asynchronous errors reported by `fs.readFile()`, while the `try` in line B takes care of synchronous errors reported by `JSON.parse()`.    ##### [43.2.1.2 The Promise-based version](#the-promisebased-version)    The following code uses `readFile()` from `node:fs/promises`, the Promise-based version of `fs.readFile()`:    ```js import {readFile} from 'node:fs/promises'; readFile('person.json')  .then((text) => { // (A)  // Success  const obj = JSON.parse(text);  assert.deepEqual(obj, {  first: 'Jane',  last: 'Doe',  });  })  .catch((err) => { // (B)  // Failure: file I/O error or JSON syntax error  assert.fail(err);  });  ```    Function `readFile()` returns a Promise. In line A, we specify a success callback via method `.then()` of that Promise. The remaining code in `then`’s callback is synchronous.    `.then()` returns a Promise, which enables the invocation of the Promise method `.catch()` in line B. We use it to specify a failure callback.    Note that `.catch()` lets us handle both the asynchronous errors of `readFile()` and the synchronous errors of `JSON.parse()` because exceptions inside a `.then()` callback become rejections.    #### [43.2.2 Browsers: Promisifying `XMLHttpRequest`](#promisifying-xmlhttprequest)    We have previously seen the event-based `XMLHttpRequest` API for downloading data in web browsers. The following function promisifies that API:    ```js function httpGet(url) {  return new Promise(  (resolve, reject) => {  const xhr = new XMLHttpRequest();  xhr.onload = () => {  if (xhr.status === 200) {  resolve(xhr.responseText); // (A)  } else {  // Something went wrong (404, etc.)  reject(new Error(xhr.statusText)); // (B)  }  }  xhr.onerror = () => {  reject(new Error('Network error')); // (C)  };  xhr.open('GET', url);  xhr.send();  }); }  ```    Note how the results and errors of `XMLHttpRequest` are handled via `resolve()` and `reject()`:    *   A successful outcome leads to the returned Promise being fullfilled with it (line A). *   An error leads to the Promise being rejected (lines B and C).    This is how to use `httpGet()`:    ```js httpGet('http://example.com/textfile.txt')  .then((content) => {  assert.equal(content, 'Content of textfile.txt\\n');  })  .catch((error) => {  assert.fail(error);  });  ```    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Timing out a Promise**    `exercises/promises/promise_timeout_test.mjs`    #### [43.2.3 Fetch API](#fetch-api)    Most JavaScript platforms support Fetch, a Promise-based API for downloading data. Think of it as a Promise-based version of `XMLHttpRequest`. The following is an excerpt of [the API](https://fetch.spec.whatwg.org/#fetch-api):    ```js interface Body {  text() : Promise<string>;  ··· } interface Response extends Body {  ··· } declare function fetch(str) : Promise<Response>;  ```    That means we can use `fetch()` as follows:    ```js fetch('http://example.com/textfile.txt')  .then(response => response.text())  .then((text) => {  assert.equal(text, 'Content of textfile.txt');  });  ```    `fetch()` is also used here: [“Example: `.map()` with an async function as a callback” (§44.3.3)](ch_async-functions.html#map-with-async-callback).    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Using the fetch API**    `exercises/promises/fetch_json_test.mjs`    ### [43.3 Tip for error handling: don’t mix rejections and exceptions](#tip-for-error-handling-dont-mix-rejections-and-exceptions)    Tip for implementing functions and methods:    > Don’t mix (asynchronous) rejections and (synchronous) exceptions.    This makes our synchronous and asynchronous code more predictable and simpler because we can always focus on a single error-handling mechanism.    For Promise-based functions and methods, the rule means that they should never throw exceptions. Alas, it is easy to accidentally get this wrong – for example:    ```js // Don’t do this function asyncFunc() {  doSomethingSync(); // (A)  return doSomethingAsync()  .then((result) => {  // ···  }); }  ```    The problem is that if an exception is thrown in line A, then `asyncFunc()` will throw an exception. Callers of that function only expect rejections and are not prepared for an exception. There are three ways in which we can fix this issue.    We can wrap the whole body of the function in a `try-catch` statement and return a rejected Promise if an exception is thrown:    ```js // Solution 1 function asyncFunc() {  try {  doSomethingSync();  return doSomethingAsync()  .then((result) => {  // ···  });  } catch (err) {  return Promise.reject(err);  } }  ```    Given that `.then()` converts exceptions to rejections, we can execute `doSomethingSync()` inside a `.then()` callback. To do so, we start a Promise chain via `Promise.resolve()`. We ignore the fulfillment value `undefined` of that initial Promise.    ```js // Solution 2 function asyncFunc() {  return Promise.resolve()  .then(() => {  doSomethingSync();  return doSomethingAsync();  })  .then((result) => {  // ···  }); }  ```    Lastly, `new Promise()` also converts exceptions to rejections. Using this constructor is therefore similar to the previous solution:    ```js // Solution 3 function asyncFunc() {  return new Promise((resolve, reject) => {  doSomethingSync();  resolve(doSomethingAsync());  })  .then((result) => {  // ···  }); }  ```    ### [43.4 Promise-based functions start synchronously, settle asynchronously](#promise-based-functions-start-sync-settle-async)    Most Promise-based functions are executed as follows:    *   Their execution starts right away, synchronously (in the current task). *   But the Promise they return is guaranteed to be settled asynchronously (in a later task) – if ever.    The following code demonstrates that:    ```js function asyncFunc() {  console.log('asyncFunc');  return new Promise(  (resolve, _reject) => {  console.log('new Promise()');  resolve();  }  ); } console.log('START'); asyncFunc()  .then(() => {  console.log('.then()'); // (A)  }); console.log('END');  ```    Output:    ```js START asyncFunc new Promise() END .then()  ```    We can see that the callback of `new Promise()` is executed before the end of the code, while the result is delivered later (line A).    Benefits of this approach:    *   Starting synchronously helps avoid race conditions because we can rely on the order in which Promise-based functions begin. There is an example [in the next chapter](ch_async-functions.html#fire-and-forget-await), where text is written to a file and race conditions are avoided.           *   Chaining Promises won’t starve other tasks of processing time because before a Promise is settled, there will always be a break, during which the event loop can run.           *   Promise-based functions always return results asynchronously; we can be sure that there is never a synchronous return. This kind of predictability makes code easier to work with.              ![Icon “external”](../Images/38e6ff55e8d602659f3cdb8893e63f62.png) **More information on this approach**    [“Designing APIs for Asynchrony”](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony) by Isaac Z. Schlueter    ### [43.5 Promise combinator functions: working with Arrays of Promises](#promise-combinators)    #### [43.5.1 What is a Promise combinator function?](#what-is-a-promise-combinator-function)    The [*combinator pattern*](https://wiki.haskell.org/Combinator_pattern) is a pattern in functional programming for building structures. It is based on two kinds of functions:    *   *Primitive functions* (short: *primitives*) create atomic pieces. *   *Combinator functions* (short: *combinators*) combine atomic and/or compound pieces to create compound pieces.    When it comes to JavaScript Promises:    *   Primitive functions include: `Promise.resolve()`, `Promise.reject()`           *   Combinators include: `Promise.all()`, `Promise.race()`, `Promise.any()`, `Promise.allSettled()`. In each of these cases:               *   Input is an iterable over zero or more Promises.     *   Output is a single Promise.    Next, we’ll take a closer look at the mentioned Promise combinators.    #### [43.5.2 `Promise.all()`](#Promise.all)    This is the type signature of `Promise.all()`:    ```js Promise.all<T>(promises: Iterable<Promise<T>>): Promise<Array<T>>  ```    `Promise.all()` returns a Promise which is:    *   Fulfilled if all `promises` are fulfilled.     *   Then its fulfillment value is an Array with the fulfillment values of `promises`. *   Rejected if at least one Promise is rejected.     *   Then its rejection value is the rejection value of that Promise.    This is a quick demo of the output Promise being fulfilled:    ```js const promises = [  Promise.resolve('result a'),  Promise.resolve('result b'),  Promise.resolve('result c'), ]; Promise.all(promises)  .then((arr) => assert.deepEqual(  arr, ['result a', 'result b', 'result c']  ));  ```    The following example demonstrates what happens if at least one of the input Promises is rejected:    ```js const promises = [  Promise.resolve('result a'),  Promise.resolve('result b'),  Promise.reject('ERROR'), ]; Promise.all(promises)  .catch((err) => assert.equal(  err, 'ERROR'  ));  ```    [Figure 43.2](#fig:combinator-promise-all) illustrates how `Promise.all()` works.    ![](../Images/304b67c9d82e5f471ff49a4f60ee10e2.png)      Figure 43.2: The Promise combinator `Promise.all()`.      ##### [43.5.2.1 Asynchronous `.map()` via `Promise.all()`](#asynchronous-map-via-promiseall)    Array transformation methods such as `.map()`, `.filter()`, etc., are made for synchronous computations. For example:    ```js function timesTwoSync(x) {  return 2 * x; } const arr = [1, 2, 3]; const result = arr.map(timesTwoSync); assert.deepEqual(result, [2, 4, 6]);  ```    What happens if the callback of `.map()` is a Promise-based function (a function that maps normal values to Promises)? Then the result of `.map()` is an Array of Promises. Alas, that is not data that normal code can work with. Thankfully, we can fix that via `Promise.all()`: It converts an Array of Promises into a Promise that is fulfilled with an Array of normal values.    ```js function timesTwoAsync(x) {  return new Promise(resolve => resolve(x * 2)); } const arr = [1, 2, 3]; const promiseArr = arr.map(timesTwoAsync); Promise.all(promiseArr)  .then((result) => {  assert.deepEqual(result, [2, 4, 6]);  });  ```    ##### [43.5.2.2 A more realistic `.map()` example](#promise-all-download-text)    Next, we’ll use `.map()` and `Promise.all()` to downlooad text files from the web. For that, we need the following tool function:    ```js function downloadText(url) {  return fetch(url)  .then((response) => { // (A)  if (!response.ok) { // (B)  throw new Error(response.statusText);  }  return response.text(); // (C)  }); }  ```    `downloadText()` uses the Promise-based [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) to download a text file as a string:    *   First, it asynchronously retrieves a `response` (line A). *   `response.ok` (line B) checks if there were errors such as “file not found”. *   If there weren’t any, we use `.text()` (line C) to retrieve the content of the file as a string.    In the following example, we download two text files:    ```js const urls = [  'http://example.com/first.txt',  'http://example.com/second.txt', ];  `const promises = urls.map(`  `url => downloadText(url));`  `` `Promise.all(promises)`  `.then(`  `(arr) => assert.deepEqual(`  `arr, ['First!', 'Second!']`  `));` ``  ```   ```js```````", "```````js`````` ```js```````", "```````js````` ##### [43.5.2.3 A simple implementation of `Promise.all()`](#a-simple-implementation-of-promiseall)    This is a simplified implementation of `Promise.all()` (e.g., it performs no safety checks):    ```js function all(iterable) {  return new Promise((resolve, reject) => {  let elementCount = 0;  let result;  `let index = 0;`  `for (const promise of iterable) {`  `` // Preserve the current value of `index` ``  `const currentIndex = index;`  `promise.then(`  `(value) => {`  `result[currentIndex] = value;`  `elementCount++;`  `if (elementCount === result.length) {`  `resolve(result); // (A)`  `}`  `},`  `(err) => {`  `reject(err); // (B)`  `});`  `index++;`  `}`  `if (index === 0) {`  `// Resolution is normally done in line A`  `resolve([]);`  `return;`  `}`  ``// Now we know how many Promises there are in `iterable`.``  ``// We can wait until now with initializing `result` because``  `// the callbacks of .then() are executed asynchronously.`  `result = new Array(index);`  `});` `}`  ```   ```js```````", "```````js```` The two main locations where the result Promise is settled are line A and line B. After one of them settled, the other can’t change the settlement value anymore because a Promise can only be settled once.    #### [43.5.3 `Promise.race()`](#Promise.race)    This is the type signature of `Promise.race()`:    ```js Promise.race<T>(promises: Iterable<Promise<T>>): Promise<T>  ```    `Promise.race()` returns a Promise `q` which is settled as soon as the first Promise `p` among `promises` is settled. `q` has the same settlement value as `p`.    In the following demo, the settlement of the fulfilled Promise (line A) happens before the settlement of the rejected Promise (line B). Therefore, the result is also fulfilled (line C).    ```js const promises = [  new Promise((resolve, reject) =>  setTimeout(() => resolve('result'), 100)), // (A)  new Promise((resolve, reject) =>  setTimeout(() => reject('ERROR'), 200)), // (B) ]; Promise.race(promises)  .then((result) => assert.equal( // (C)  result, 'result'));  ```    In the next demo, the rejection happens first:    ```js const promises = [  new Promise((resolve, reject) =>  setTimeout(() => resolve('result'), 200)),  new Promise((resolve, reject) =>  setTimeout(() => reject('ERROR'), 100)), ]; Promise.race(promises)  .then(  (result) => assert.fail(),  (err) => assert.equal(  err, 'ERROR'));  ```    Note that the Promise returned by `Promise.race()` is settled as soon as the first among its input Promises is settled. That means that the result of `Promise.race([])` is never settled.    [Figure 43.3](#fig:combinator-promise-race) illustrates how `Promise.race()` works.    ![](../Images/3728be0c72a2536ecd233d4e9ef7d204.png)      Figure 43.3: The Promise combinator `Promise.race()`.      ##### [43.5.3.1 Using `Promise.race()` to time out a Promise](#timing-out-via-race)    In this section, we are going to use `Promise.race()` to time out Promises. We will be using the following helper functions:    ```js /**  * Returns a Promise that is resolved with `value`  * after `ms` milliseconds.  */ function resolveAfter(ms, value=undefined) {  return new Promise((resolve, _reject) => {  setTimeout(() => resolve(value), ms);  }); }  `/**`  `` * Returns a Promise that is rejected with `reason` ``  ``* after `ms` milliseconds.``  `*/` `function rejectAfter(ms, reason=undefined) {`  `return new Promise((_resolve, reject) => {`  `setTimeout(() => reject(reason), ms);`  `});` `}`  ```   ```js```````", "```````js``` This function times out a Promise:    ``` function timeout(timeoutInMs, promise) {  return Promise.race([  promise,  rejectAfter(timeoutInMs,  new Error('Operation timed out')  ),  ]); }  ```js    `timeout()` returns a Promise whose settlement is the same as the one of whichever Promise settles first among the following two:    1.  The parameter `promise` 2.  A Promise that is rejected after `timeoutInMs` milliseconds    To produce the second Promise, `timeout()` uses the fact that resolving a pending Promise with a rejected Promise leads to the former being rejected.    Let’s see `timeout()` in action. Here, the input Promise is fulfilled before the timeout. Therefore, the output Promise is fulfilled.    ``` timeout(200, resolveAfter(100, 'Result!'))  .then(result => assert.equal(result, 'Result!'));  ```js    Here, the timeout happens before the input Promise is fulfilled. Therefore, the output Promise is rejected.    ``` timeout(100, resolveAfter(200, 'Result!'))  .catch(err => assert.deepEqual(err, new Error('Operation timed out')));  ```js    It is important to understand what “timing out a Promise” really means:    *   If the input Promise is settled quickly enough, its settlement is passed on to the output Promise. *   If it isn’t settled quickly enough, the output Promise is rejected.    That is, timing out only prevents the input Promise from affecting the output (since a Promise can only be settled once). But it does not stop the asynchronous operation that produced the input Promise.    ##### [43.5.3.2 A simple implementation of `Promise.race()`](#a-simple-implementation-of-promiserace)    This is a simplified implementation of `Promise.race()` (e.g., it performs no safety checks):    ``` function race(iterable) {  return new Promise((resolve, reject) => {  for (const promise of iterable) {  promise.then(  (value) => {  resolve(value); // (A)  },  (err) => {  reject(err); // (B)  });  }  }); }  ```js    The result Promise is settled in either line A or line B. Once it is, the settlement value can’t be changed anymore.    #### [43.5.4 `Promise.any()` ^(ES2021)](#Promise.any)    This is the type signature of `Promise.any()`:    ``` Promise.any<T>(promises: Iterable<Promise<T>>): Promise<T>  ```js    `Promise.any()` returns a Promise `p`. How it is settled, depends on the parameter `promises` (which refers to an iterable over Promises):    *   If and when the first Promise is fulfilled, `p` is resolved with that Promise. *   If all Promises are rejected, `p` is rejected with an instance of `AggregateError` that contains all rejection values.    [Figure 43.4](#fig:combinator-promise-any) illustrates how `Promise.any()` works.    ![](../Images/e8a5def71f107f982eeb0cdeee8e7f86.png)      Figure 43.4: The Promise combinator `Promise.any()`.      ##### [43.5.4.1 `AggregateError` ^(ES2021)](#AggregateError)    This is the type signature of `AggregateError` (a subclass of [`Error`](ch_exception-handling.html#class-Error)):    ``` class AggregateError extends Error {  // Instance properties (complementing the ones of Error)  errors: Array<any>;  `constructor(`  `errors: Iterable<any>,`  `message: string = '',`  `options?: ErrorOptions // ES2022`  `);` `}` `interface ErrorOptions {`  `cause?: any; // ES2022` `}`  ```js   ``````js```````", "`````` ##### [43.5.4.2 Two first examples](#two-first-examples)    This is what happens if one Promise is fulfilled:    ```js const promises = [  Promise.reject('ERROR A'),  Promise.reject('ERROR B'),  Promise.resolve('result'), ]; Promise.any(promises)  .then((result) => assert.equal(  result, 'result'  ));  ```    This is what happens if all Promises are rejected:    ```js const promises = [  Promise.reject('ERROR A'),  Promise.reject('ERROR B'),  Promise.reject('ERROR C'), ]; Promise.any(promises)  .catch((aggregateError) => assert.deepEqual(  aggregateError.errors,  ['ERROR A', 'ERROR B', 'ERROR C']  ));  ```    ##### [43.5.4.3 `Promise.any()` vs. `Promise.all()`](#promiseany-vs-promiseall)    There are two ways in which `Promise.any()` and `Promise.all()` can be compared:    *   They are inverses of each other:     *   `Promise.all()`: First input rejection rejects the result Promise or its fulfillment value is an Array with input fulfillment values.     *   `Promise.any()`: First input fulfillment fulfills the result Promise or its rejection value is an Array with input rejection values (inside an error object). *   They have different focuses:     *   `Promise.all()` is interested in *all* fulfillments. The opposite case (at least one rejection) leads to a rejection.     *   `Promise.any()` is interested in the first fulfillment. The opposite case (only rejections) leads to a rejection.    ##### [43.5.4.4 `Promise.any()` vs. `Promise.race()`](#promiseany-vs-promiserace)    `Promise.any()` and `Promise.race()` are also related, but interested in different things:    *   `Promise.race()` is interested in settlements. The Promise which is settled first, “wins”. In other words: We want to know about the asynchronous computation that terminates first. *   `Promise.any()` is interested in fulfillments. The Promise which is fulfilled first, “wins”. In other words: We want to know about the asynchronous computation that succeeds first.    The main – relatively rare – use case for `.race()` is timing out Promises. The use cases for `.any()` are broader. We’ll look at them next.    ##### [43.5.4.5 Use cases for `Promise.any()`](#use-cases-for-promiseany)    We use `Promise.any()` if we have multiple asynchronous computations and we are only interested in the first successful one. In a way, we let the computations compete with each other and use whichever one is fastest.    The following code demonstrates what that looks like when downloading resources:    ```js const resource = await Promise.any([  fetch('http://example.com/first.txt')  .then(response => response.text()),  fetch('http://example.com/second.txt')  .then(response => response.text()), ]);  ```    The same pattern enables us to use whichever module downloads more quickly:    ```js const mylib = await Promise.any([  import('https://primary.example.com/mylib'),  import('https://secondary.example.com/mylib'), ]);  ```    For comparison, this is the code we’d use if the secondary server is only a fallback – in case the primary server fails:    ```js let mylib; try {  mylib = await import('https://primary.example.com/mylib'); } catch {  mylib = await import('https://secondary.example.com/mylib'); }  ```    ##### [43.5.4.6 How would we implement `Promise.any()`?](#how-would-we-implement-promiseany)    A simple implementation of `Promise.any()` is basically a mirror version of the implementation of `Promise.all()`.    #### [43.5.5 `Promise.allSettled()` ^(ES2020)](#Promise.allSettled)    This time, the type signatures are a little more complicated. Feel free to skip ahead to the first demo, which should be easier to understand.    This is the type signature of `Promise.allSettled()`:    ```js Promise.allSettled<T>(promises: Iterable<Promise<T>>)  : Promise<Array<SettlementObject<T>>>  ```    It returns a Promise for an Array whose elements have the following type signature:    ```js type SettlementObject<T> = FulfillmentObject<T> | RejectionObject;  `interface FulfillmentObject<T> {`  `status: 'fulfilled';`  `value: T;` `}`  `` `interface RejectionObject {`  `status: 'rejected';`  `reason: unknown;` `}` ``  ```   ```js``````", "```````js` ``````js```````", "```` `Promise.allSettled()` returns a Promise `out`. Once all `promises` are settled, `out` is fulfilled with an Array. Each element `e` of that Array corresponds to one Promise `p` of `promises`:    *   If `p` is fulfilled with the fulfillment value `v`, then `e` is                    ```js     { status: 'fulfilled', value:  v }          ```           *   If `p` is rejected with the rejection value `r`, then `e` is                    ```js     { status: 'rejected',  reason: r }          ```              Unless there is an error when iterating over `promises`, the output Promise `out` is never rejected.    [Figure 43.5](#fig:combinator-promise-all-settled) illustrates how `Promise.allSettled()` works.    ![](../Images/3bb559e958e51edd426fc59d90d5a465.png)      Figure 43.5: The Promise combinator `Promise.allSettled()`.      ##### [43.5.5.1 A first demo of `Promise.allSettled()`](#a-first-demo-of-promiseallsettled)    This is a quick first demo of how `Promise.allSettled()` works:    ```js Promise.allSettled([  Promise.resolve('value'),  Promise.reject('ERROR'), ]) .then(arr => assert.deepEqual(arr, [  { status: 'fulfilled', value: 'value' },  { status: 'rejected',  reason: 'ERROR' }, ]));  ```    ##### [43.5.5.2 A longer example of `Promise.allSettled()`](#a-longer-example-of-promiseallsettled)    The next example is similar to [the `.map()` plus `Promise.all()` example](#promise-all-download-text) (from which we are borrowing the function `downloadText()`): We are downloading multiple text files whose URLs are stored in an Array. However, this time, we don’t want to stop when there is an error, we want to keep going. `Promise.allSettled()` allows us to do that:    ```js function downloadText(url) {  return fetch(url)  .then((response) => {  if (!response.ok) {  throw new Error(response.statusText);  }  return response.text();  }); }  `const urls = [`  `'http://example.com/exists.txt',`  `'http://example.com/missing.txt',` `];`  `` `const result = Promise.allSettled(`  `urls.map(url => downloadText(url))` `);` `result.then(`  `(arr) => {`  `assert.deepEqual(`  `arr,`  `[`  `{`  `status: 'fulfilled',`  `value: 'Hello!',`  `},`  `{`  `status: 'rejected',`  `reason: new Error('Not Found'),`  `},`  `]`  `)`  `}` `);` ``  ```   ```js````", "```js```", "``` ```", "```````js````` ##### [43.5.5.3 A simple implementation of `Promise.allSettled()`](#a-simple-implementation-of-promiseallsettled)    This is a simplified implementation of `Promise.allSettled()` (e.g., it performs no safety checks):    ```js function allSettled(iterable) {  return new Promise((resolve, reject) => {  let elementCount = 0;  let result;  `function addElementToResult(i, elem) {`  `result[i] = elem;`  `elementCount++;`  `if (elementCount === result.length) {`  `resolve(result);`  `}`  `}`  ``` `let index = 0;`  `for (const promise of iterable) {`  `` // Capture the current value of `index` ``  `const currentIndex = index;`  `promise.then(`  `(value) => addElementToResult(`  `currentIndex, {`  `status: 'fulfilled',`  `value`  `}`  `),`  `(reason) => addElementToResult(`  `currentIndex, {`  `status: 'rejected',`  `reason`  `}`  `)`  `);`  `index++;`  `}`  `if (index === 0) {`  `// Resolution is normally triggered by addElementToResult()`  `resolve([]);`  `return;`  `}`  ``// Now we know how many Promises there are in `iterable`.``  ``// We can wait until now with initializing `result` because``  `// the callbacks of .then() are executed asynchronously.`  `result = new Array(index);`  `});` `}` ```js  ```   ```js```````", "```` ```js````", "```js```", "``` const asyncFunc1 = () => Promise.resolve('one'); const asyncFunc2 = () => Promise.resolve('two');  `asyncFunc1()`  `.then((result1) => {`  `assert.equal(result1, 'one');`  `return asyncFunc2();`  `})`  `.then((result2) => {`  `assert.equal(result2, 'two');`  `});`  ```", "``````js``````", "```js Promise.all([asyncFunc1(), asyncFunc2()])  .then((arr) => {  assert.deepEqual(arr, ['one', 'two']);  });  ```", "```js function concurrentAll() {  return Promise.all([asyncFunc1(), asyncFunc2()]); }  `function concurrentThen() {`  `const p1 = asyncFunc1();`  `const p2 = asyncFunc2();`  `return p1.then(r1 => p2.then(r2 => [r1, r2]));` `}`  ```", "```js```", "````js` On the other hand, both of the following functions execute `asyncFunc1()` and `asyncFunc2()` sequentially: `asyncFunc2()` is only invoked after the Promise of `asyncFunc1()` is fulfilled.    ``` function sequentialThen() {  return asyncFunc1()  .then(r1 => asyncFunc2()  .then(r2 => [r1, r2])); }  `function sequentialAll() {`  `const p1 = asyncFunc1();`  `const p2 = p1.then(() => asyncFunc2());`  `return Promise.all([p1, p2]);` `}`  ```js   ````", "```` #### [43.6.3 `Promise.all()` is fork-join](#promise-all-is-fork-join)    `Promise.all()` is loosely related to the concurrency pattern “fork join”. Let’s revisit an example that we have encountered [previously](#promise-all-download-text):    ```js Promise.all([  // (A) fork  downloadText('http://example.com/first.txt'),  downloadText('http://example.com/second.txt'),  ])  // (B) join  .then(  (arr) => assert.deepEqual(  arr, ['First!', 'Second!']  ));  ```    *   Fork: In line A, we are forking two asynchronous computations and executing them concurrently. *   Join: In line B, we are joining these computations into a single “thread” which is started once all of them are done.    ### [43.7 Tips for chaining Promises](#tips-for-chaining-promises)    This section gives tips for chaining Promises.    #### [43.7.1 Chaining mistake: losing the tail](#chaining-mistake-losing-thetail)    Problem:    ```js // Don’t do this function foo() {  const promise = asyncFunc();  promise.then((result) => {  // ···  });  `return promise;` `}`  ```   ```js````", "```js function foo() {  const promise = asyncFunc();  return promise.then((result) => {  // ···  }); }  ```", "```js // Don’t do this asyncFunc1()  .then((result1) => {  return asyncFunc2()  .then((result2) => { // (A)  // ···  });  });  ```", "```js asyncFunc1()  .then((result1) => {  return asyncFunc2();  })  .then((result2) => {  // ···  });  ```", "```js // Don’t do this asyncFunc1()  .then((result1) => {  if (result1 < 0) {  return asyncFuncA()  .then(resultA => 'Result: ' + resultA);  } else {  return asyncFuncB()  .then(resultB => 'Result: ' + resultB);  }  });  ```", "```js asyncFunc1()  .then((result1) => {  return result1 < 0 ? asyncFuncA() : asyncFuncB();  })  .then((resultAB) => {  return 'Result: ' + resultAB;  });  ```", "```js db.open()  .then((connection) => { // (A)  return connection.select({ name: 'Jane' })  .then((result) => { // (B)  // Process result  // Use `connection` to make more queries  })  // ···  .finally(() => {  connection.close(); // (C)  });  })  ```", "```js // Don’t do this class Model {  insertInto(db) {  return new Promise((resolve, reject) => { // (A)  db.insert(this.fields)  .then((resultCode) => {  this.notifyObservers({event: 'created', model: this});  resolve(resultCode);  }).catch((err) => {  reject(err);  })  });  }  // ··· }  ```", "```js class Model {  insertInto(db) {  return db.insert(this.fields)  .then((resultCode) => {  this.notifyObservers({event: 'created', model: this});  return resultCode;  });  }  // ··· }  ```", "```js const promiseLikeObject = {  then(onFulfilled, onRejected) {  // ···  }, };  ```", "```js interface PromiseLike<T> {  then<TResult1, TResult2>(  onFulfilled?: (value: T) => TResult1 | PromiseLike<TResult1>,  onRejected?: (reason: any) => TResult2 | PromiseLike<TResult2>  ): PromiseLike<TResult1 | TResult2>; }  ```", "```js promise.catch(onRejected) promise.then(undefined, onRejected)  ```", "```js const fulfilledThenable = {  then(onFulfilled, onRejected) {  onFulfilled('Success!');  }, };  ```", "```js const promise = Promise.resolve(fulfilledThenable); assert.equal(  promise instanceof Promise, true );  ```", "```js Promise.resolve()  .then(() => fulfilledThenable)  .then((value) => {  assert.equal(value, 'Success!');  });  ```", "```js new Promise((resolve) => {  resolve(fulfilledThenable); }).then((value) => {  assert.equal(value, 'Success!'); });  ```", "```js const rejectedThenable = {  then(onFulfilled, onRejected) {  onRejected('Error!');  }, };  `Promise.resolve(rejectedThenable)`  `.catch((reason) => {`  `assert.equal(reason, 'Error!');`  `});`  ```", "```js  ```", "```js```", "```js```", "```js     new Promise<T>(      executor: (      resolve: (value: T | PromiseLike<T>) => void,      reject: (reason?: any) => void      ) => void     ): Promise<T>          ```", "```js     // Create a Promise and resolve it     new Promise((resolve, reject) => {      resolve('Result');     }).then((value) => {      assert.equal(value, 'Result');     });      `// Create a Promise and reject it`     `new Promise((resolve, reject) => {`      `reject('Error');`     `}).catch((reason) => {`      `assert.equal(reason, 'Error');`     `});`      ```", "```js```", "```     Promise.withResolvers<T>(): PromiseWithResolvers<T>;     interface PromiseWithResolvers<T> {      promise: Promise<T>;      resolve: (value: T | PromiseLike<T>) => void;      reject: (reason?: any) => void;     }          ```", "```     Promise.resolve('Yes')     .then((value) => {      assert.equal(value, 'Yes');     });          ```", "```     Promise.reject('No')     .catch((reason) => {      assert.equal(reason, 'No');     });          ```", "```     function computeAsync() {      return Promise.try(() => {      const value = syncFuncMightThrow();      return asyncFunc(value);      });     }          ```", "```     Promise.all<T>(      promises: Iterable<Promise<T>>     ): Promise<Array<T>>          ```", "```     Promise.race<T>(      promises: Iterable<Promise<T>>     ): Promise<T>          ```", "```     Promise.any<T>(      promises: Iterable<Promise<T>>     ): Promise<T>          ```", "```     class AggregateError {      constructor(errors: Iterable<any>, message: string);      get errors(): Array<any>;      get message(): string;     }          ```", "```     Promise.allSettled<T>(      promises: Iterable<Promise<T>>     ): Promise<Array<SettlementObject<T>>>          ```", "```     type SettlementObject<T> = FulfillmentObject<T> | RejectionObject;      `interface FulfillmentObject<T> {`      `status: 'fulfilled';`      `value: T;`     `}`      `` `interface RejectionObject {`  `status: 'rejected';`  `reason: unknown;` `}` ``      ```", "````` ```js`#### [43.9.5 `Promise.prototype.*`](#promiseprototype)    *   `Promise.prototype.then(onFulfilled?, onRejected?)` ES6                    ```     interface Promise<T> {      then<TResult1, TResult2>(      onFulfilled?: (value: T) => TResult1 | PromiseLike<TResult1>,      onRejected?: (reason: any) => TResult2 | PromiseLike<TResult2>      ): Promise<TResult1 | TResult2>;     }          ```js                    Registers callbacks for the fulfillment value and/or the rejection value of a Promise. Usually, only the first parameter `onFulfilled` is used. `.catch()` provides a more self-descriptive alternative to using the second parameter `onRejected`.                    ```     Promise.resolve('Yes')     .then((value) => {      assert.equal(value, 'Yes');     });          ```js           *   `Promise.prototype.catch(onRejected)` ES6                    ```     interface Promise<T> {      catch<TResult>(      onrejected?: (reason: any) => TResult2 | PromiseLike<TResult2>      ): Promise<T | TResult>;     }          ```js                    Registers a callback for the rejection value of a Promise. A more self-descriptive alternative to using `.then()` for that purpose – the following two invocations are equivalent:                    ```     promise.catch(onRejected)     promise.then(undefined, onRejected)          ```js                    Example:                    ```     Promise.reject('No')     .catch((reason) => {      assert.equal(reason, 'No');     });          ```js           *   `Promise.prototype.finally(onFinally)` ES2018                    ```     interface Promise<T> {      // Returning a rejected Promise from onFinally does have an effect!      finally(onFinally?: () => void);     }          ```js                    Often used as follows:                    ```     somePromise      .then((result) => {      // ···      })      .catch((error) => {      // ···      })      .finally(() => {      // ···      })     ;          ```js                    The `.finally()` callback is always executed – independently of `somePromise` and the values returned by `.then()` and/or `.catch()`. The callback only has an effect if it returns a rejected Promise or throws an exception. Then the final Promise is rejected with the rejection value or the exception.```` ```js`` `````", "``````js` ``````", "``````js``` ``````", "```` ```js````", "```js` ```", "```js```", "``` ```", "```````js``` ``````js```````", "``````js``````", "``````js``````", "``` ```", "```js```", "````js````", "```js```", "````js````", "```js` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "``````js``````", "```````js` ``````js```````", "```````js`` ``````js```````", "```````js``` ``````js```````", "```````js```` ```js```````", "```````js```````", "``````js``````", "```````js`````` ```js```````", "```````js```````", "``` ```", "```js```", "````js````", "```js```"]