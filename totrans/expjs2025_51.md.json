["```js\nconst promise = addAsync(3, 4);\npromise.then((result) => { // success\n    assert.equal(result, 7);\n  })\n  .catch((error) => { // failure\n    assert.fail(error);\n  })\n;\n\n```", "```js\nfunction addAsync(x, y) {\n  return new Promise( // (A)\n    (resolve, reject) => { // (B)\n      if (x === undefined || y === undefined) {\n        reject(new Error('Must provide two parameters'));\n      } else {\n        resolve(x + y);\n      }\n    }\n  );\n}\n\n```", "```js\nconst promise = new Promise(\n  (resolve, reject) => {\n    // ···\n  }\n);\n\n```", "```js\n> doThingsWith(p);\n> \n> ```", "```js\nnew Promise(() => {})\n\n```", "```js\nPromise.resolve(123)\n  .then((x) => {\n    assert.equal(x, 123);\n  });\n\n```", "```js\nconst abcPromise = Promise.resolve('abc');\nassert.equal(\n  Promise.resolve(abcPromise), abcPromise\n);\n\n```", "```js\nconst myError = new Error('My error!');\nPromise.reject(myError)\n  .catch((err) => {\n    assert.equal(err, myError);\n  });\n\n```", "```js\nfunction convertToNumber(stringOrNumber) {\n  if (typeof stringOrNumber === 'number') {\n    return Promise.resolve(stringOrNumber);\n  } else if (typeof stringOrNumber === 'string') {\n    return stringToNumberAsync(stringOrNumber);\n  } else {\n    return Promise.reject(new TypeError());\n  }\n}\n\n```", "```js\nPromise.resolve('abc')\n  .then((str) => {\n    return str + str; // (A)\n  })\n  .then((str2) => {\n    assert.equal(str2, 'abcabc'); // (B)\n  });\n\n```", "```js\nPromise.resolve('abc')\n  .then((str) => {\n    return Promise.resolve(123); // (A)\n  })\n  .then((num) => {\n    assert.equal(num, 123);\n  });\n\n```", "```js\n// Flat\nasyncFunc1()\n  .then((result1) => {\n    /*···*/\n    return asyncFunc2();\n  })\n  .then((result2) => {\n    /*···*/\n  });\n\n// Nested\nasyncFunc1()\n  .then((result1) => {\n    /*···*/\n    asyncFunc2()\n    .then((result2) => {\n      /*···*/\n    });\n  });\n\n```", "```js\nconst myError = new Error('My error!');\nPromise.resolve('abc')\n  .then((str) => {\n    throw myError;\n  })\n  .catch((err) => {\n    assert.equal(err, myError);\n  });\n\n```", "```js\nconst err = new Error();\n\nPromise.reject(err)\n  .catch((e) => {\n    assert.equal(e, err);\n    // Something went wrong, use a default value\n    return 'default value'; // (A)\n  })\n  .then((str) => {\n    assert.equal(str, 'default value');\n  });\n\n```", "```js\nfunction myAsyncFunc() {\n return asyncFunc1() // (A)\n .then((result1) => {\n // ···\n return asyncFunc2(); // a Promise\n })\n .then((result2) => {\n // ···\n return result2 ?? '(Empty)'; // not a Promise\n })\n .then((result3) => {\n // ···\n return asyncFunc4(); // a Promise\n });\n}\n\n```", "```js\nasyncFunc1()\n  .then((result1) => {\n    // ···\n    return asyncFunc2();\n  })\n  .then((result2) => {\n    // ···\n  })\n  .catch((error) => {\n    // Failure: handle errors of asyncFunc1(), asyncFunc2()\n    // and any (sync) exceptions thrown in previous callbacks\n  });\n\n```", "```js\nfunction computeAsync() {\n return Promise.try(() => {\n const value = syncFuncMightThrow(); // (A)\n return asyncFunc(value); // (B)\n });\n}\n\n```", "```js\nfunction computeAsync() {\n try {\n const value = syncFuncMightThrow();\n return asyncFunc(value);\n } catch (err) {\n return Promise.reject(err);\n }\n}\n\n```", "```js\nfunction countPlusOneAsync() {\n return Promise.resolve().then(\n () => countSyncOrAsync() // (A)\n )\n .then((result) => {\n return result + 1;\n });\n}\n\n```", "```js\nsomePromise\n  .then((result) => {\n    // ···\n  })\n  .catch((error) => {\n    // ···\n  })\n  .finally(() => {\n    // ···\n  })\n;\n\n```", "```js\nPromise.resolve(123)\n  .finally(() => {})\n  .then((result) => {\n    assert.equal(result, 123);\n  });\n\nPromise.reject('error')\n  .finally(() => {})\n  .catch((error) => {\n    assert.equal(error, 'error');\n  });\n\n```", "```js\nPromise.reject('error (previously)')\n  .finally(() => {\n    throw 'error (finally)';\n  })\n  .catch((error) => {\n    assert.equal(error, 'error (finally)');\n  });\n\nPromise.reject('error (previously)')\n  .finally(() => {\n    return Promise.reject('error (finally)');\n  })\n  .catch((error) => {\n    assert.equal(error, 'error (finally)');\n  });\n\n```", "```js\nlet connection;\ndb.open()\n.then((conn) => {\n  connection = conn;\n  return connection.select({ name: 'Jane' });\n})\n.then((result) => {\n  // Process result\n  // Use `connection` to make more queries\n})\n// ···\n.catch((error) => {\n  // handle errors\n})\n.finally(() => {\n  connection.close();\n});\n\n```", "```js\nfunction handleAsyncResult(promise) {\n  return promise\n    .finally(() => {\n      console.log('finally');\n    })\n    .then((result) => {\n      console.log('then ' + result);\n    })\n    .catch((error) => {\n      console.log('catch ' + error);\n    })\n  ;\n}\n\n```", "```js\nhandleAsyncResult(Promise.resolve('fulfilled'));\n\n```", "```js\nfinally\nthen fulfilled\n\n```", "```js\nhandleAsyncResult(Promise.reject('rejected'));\n\n```", "```js\nfinally\ncatch rejected\n\n```", "```js\nnew Promise(\n  (resolve, reject) => { ··· }\n);\n\n```", "```js\nconst { promise, resolve, reject } = Promise.withResolvers();\n\n```", "```js\n{\n  const { promise, resolve, reject } = Promise.withResolvers();\n  resolve('fulfilled');\n  assert.equal(\n    await promise,\n    'fulfilled'\n  );\n}\n{\n  const { promise, resolve, reject } = Promise.withResolvers();\n  reject('rejected');\n  try {\n    await promise;\n  } catch (err) {\n    assert.equal(err, 'rejected');\n  }\n}\n\n```", "```js\nfunction promiseWithResolvers() {\n let resolve;\n let reject;\n const promise = new Promise(\n (res, rej) => {\n // Executed synchronously!\n resolve = res;\n reject = rej;\n });\n return {promise, resolve, reject};\n}\n\n```", "```js\nclass OneElementQueue {\n  #promise = null;\n  #resolve = null;\n  constructor() {\n const { promise, resolve } = Promise.withResolvers();\n this.#promise = promise;\n this.#resolve = resolve;\n }\n get() {\n return this.#promise;\n }\n put(value) {\n this.#resolve(value);\n }\n}\n\n{ // Putting before getting\n const queue = new OneElementQueue();\n queue.put('one');\n assert.equal(\n await queue.get(),\n 'one'\n );\n}\n{ // Getting before putting\n const queue = new OneElementQueue();\n setTimeout(\n // Runs after `await` pauses the current execution context\n () => queue.put('two'),\n 0\n );\n assert.equal(\n await queue.get(),\n 'two'\n );\n} \n```", "```js\n{\n  \"first\": \"Jane\",\n  \"last\": \"Doe\"\n}\n\n```", "```js\nimport * as fs from 'node:fs';\nfs.readFile('person.json',\n  (error, text) => {\n    if (error) { // (A)\n      // Failure\n      assert.fail(error);\n    } else {\n      // Success\n      try { // (B)\n        const obj = JSON.parse(text); // (C)\n        assert.deepEqual(obj, {\n          first: 'Jane',\n          last: 'Doe',\n        });\n      } catch (e) {\n        // Invalid JSON\n        assert.fail(e);\n      }\n    }\n  });\n\n```", "```js\nimport {readFile} from 'node:fs/promises';\nreadFile('person.json')\n  .then((text) => { // (A)\n    // Success\n    const obj = JSON.parse(text);\n    assert.deepEqual(obj, {\n      first: 'Jane',\n      last: 'Doe',\n    });\n  })\n  .catch((err) => { // (B)\n    // Failure: file I/O error or JSON syntax error\n    assert.fail(err);\n  });\n\n```", "```js\nfunction httpGet(url) {\n  return new Promise(\n    (resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.onload = () => {\n        if (xhr.status === 200) {\n          resolve(xhr.responseText); // (A)\n        } else {\n          // Something went wrong (404, etc.)\n          reject(new Error(xhr.statusText)); // (B)\n        }\n      }\n      xhr.onerror = () => {\n        reject(new Error('Network error')); // (C)\n      };\n      xhr.open('GET', url);\n      xhr.send();\n    });\n}\n\n```", "```js\nhttpGet('http://example.com/textfile.txt')\n  .then((content) => {\n    assert.equal(content, 'Content of textfile.txt\\n');\n  })\n  .catch((error) => {\n    assert.fail(error);\n  });\n\n```", "```js\ninterface Body {\n  text() : Promise<string>;\n  ···\n}\ninterface Response extends Body {\n  ···\n}\ndeclare function fetch(str) : Promise<Response>;\n\n```", "```js\nfetch('http://example.com/textfile.txt')\n  .then(response => response.text())\n  .then((text) => {\n    assert.equal(text, 'Content of textfile.txt');\n  });\n\n```", "```js\n// Don’t do this\nfunction asyncFunc() {\n doSomethingSync(); // (A)\n return doSomethingAsync()\n .then((result) => {\n // ···\n });\n}\n\n```", "```js\n// Solution 1\nfunction asyncFunc() {\n try {\n doSomethingSync();\n return doSomethingAsync()\n .then((result) => {\n // ···\n });\n } catch (err) {\n return Promise.reject(err);\n }\n}\n\n```", "```js\n// Solution 2\nfunction asyncFunc() {\n return Promise.resolve()\n .then(() => {\n doSomethingSync();\n return doSomethingAsync();\n })\n .then((result) => {\n // ···\n });\n}\n\n```", "```js\n// Solution 3\nfunction asyncFunc() {\n return new Promise((resolve, reject) => {\n doSomethingSync();\n resolve(doSomethingAsync());\n })\n .then((result) => {\n // ···\n });\n}\n\n```", "```js\nfunction asyncFunc() {\n console.log('asyncFunc');\n return new Promise(\n (resolve, _reject) => {\n console.log('new Promise()');\n resolve();\n }\n );\n}\nconsole.log('START');\nasyncFunc()\n .then(() => {\n console.log('.then()'); // (A)\n });\nconsole.log('END');\n\n```", "```js\nSTART\nasyncFunc\nnew Promise()\nEND\n.then()\n\n```", "```js\nPromise.all<T>(promises: Iterable<Promise<T>>): Promise<Array<T>>\n\n```", "```js\nconst promises = [\n  Promise.resolve('result a'),\n  Promise.resolve('result b'),\n  Promise.resolve('result c'),\n];\nPromise.all(promises)\n  .then((arr) => assert.deepEqual(\n    arr, ['result a', 'result b', 'result c']\n  ));\n\n```", "```js\nconst promises = [\n  Promise.resolve('result a'),\n  Promise.resolve('result b'),\n  Promise.reject('ERROR'),\n];\nPromise.all(promises)\n  .catch((err) => assert.equal(\n    err, 'ERROR'\n  ));\n\n```", "```js\nfunction timesTwoSync(x) {\n  return 2 * x;\n}\nconst arr = [1, 2, 3];\nconst result = arr.map(timesTwoSync);\nassert.deepEqual(result, [2, 4, 6]);\n\n```", "```js\nfunction timesTwoAsync(x) {\n  return new Promise(resolve => resolve(x * 2));\n}\nconst arr = [1, 2, 3];\nconst promiseArr = arr.map(timesTwoAsync);\nPromise.all(promiseArr)\n  .then((result) => {\n    assert.deepEqual(result, [2, 4, 6]);\n  });\n\n```", "```js\nfunction downloadText(url) {\n  return fetch(url)\n    .then((response) => { // (A)\n      if (!response.ok) { // (B)\n        throw new Error(response.statusText);\n      }\n      return response.text(); // (C)\n    });\n}\n\n```", "```js\nconst urls = [\n  'http://example.com/first.txt',\n  'http://example.com/second.txt',\n];\n\nconst promises = urls.map(\n  url => downloadText(url));\n\nPromise.all(promises)\n  .then(\n    (arr) => assert.deepEqual(\n      arr, ['First!', 'Second!']\n    ));\n\n```", "```js\nfunction all(iterable) {\n  return new Promise((resolve, reject) => {\n    let elementCount = 0;\n    let result;\n\n    let index = 0;\n    for (const promise of iterable) {\n      // Preserve the current value of `index`\n      const currentIndex = index;\n      promise.then(\n        (value) => {\n          result[currentIndex] = value;\n          elementCount++;\n          if (elementCount === result.length) {\n            resolve(result); // (A)\n          }\n        },\n        (err) => {\n          reject(err); // (B)\n        });\n      index++;\n    }\n    if (index === 0) {\n      // Resolution is normally done in line A\n      resolve([]);\n      return;\n    }\n    // Now we know how many Promises there are in `iterable`.\n    // We can wait until now with initializing `result` because\n    // the callbacks of .then() are executed asynchronously.\n    result = new Array(index);\n  });\n}\n\n```", "```js\nPromise.race<T>(promises: Iterable<Promise<T>>): Promise<T>\n\n```", "```js\nconst promises = [\n  new Promise((resolve, reject) =>\n    setTimeout(() => resolve('result'), 100)), // (A)\n  new Promise((resolve, reject) =>\n    setTimeout(() => reject('ERROR'), 200)), // (B)\n];\nPromise.race(promises)\n  .then((result) => assert.equal( // (C)\n    result, 'result'));\n\n```", "```js\nconst promises = [\n  new Promise((resolve, reject) =>\n    setTimeout(() => resolve('result'), 200)),\n  new Promise((resolve, reject) =>\n    setTimeout(() => reject('ERROR'), 100)),\n];\nPromise.race(promises)\n  .then(\n    (result) => assert.fail(),\n    (err) => assert.equal(\n      err, 'ERROR'));\n\n```", "```js\n/**\n * Returns a Promise that is resolved with `value`\n * after `ms` milliseconds.\n */\nfunction resolveAfter(ms, value=undefined) {\n  return new Promise((resolve, _reject) => {\n    setTimeout(() => resolve(value), ms);\n  });\n}\n\n/**\n * Returns a Promise that is rejected with `reason`\n * after `ms` milliseconds.\n */\nfunction rejectAfter(ms, reason=undefined) {\n  return new Promise((_resolve, reject) => {\n    setTimeout(() => reject(reason), ms);\n  });\n}\n\n```", "```js\nfunction timeout(timeoutInMs, promise) {\n  return Promise.race([\n    promise,\n    rejectAfter(timeoutInMs,\n      new Error('Operation timed out')\n    ),\n  ]);\n}\n\n```", "```js\ntimeout(200, resolveAfter(100, 'Result!'))\n  .then(result => assert.equal(result, 'Result!'));\n\n```", "```js\ntimeout(100, resolveAfter(200, 'Result!'))\n  .catch(err => assert.deepEqual(err, new Error('Operation timed out')));\n\n```", "```js\nfunction race(iterable) {\n  return new Promise((resolve, reject) => {\n    for (const promise of iterable) {\n      promise.then(\n        (value) => {\n          resolve(value); // (A)\n        },\n        (err) => {\n          reject(err); // (B)\n        });\n    }\n  });\n}\n\n```", "```js\nPromise.any<T>(promises: Iterable<Promise<T>>): Promise<T>\n\n```", "```js\nclass AggregateError extends Error {\n  // Instance properties (complementing the ones of Error)\n  errors: Array<any>;\n\n  constructor(\n errors: Iterable<any>,\n message: string = '',\n options?: ErrorOptions // ES2022\n  );\n}\ninterface ErrorOptions {\n  cause?: any; // ES2022\n}\n\n```", "```js\nconst promises = [\n  Promise.reject('ERROR A'),\n  Promise.reject('ERROR B'),\n  Promise.resolve('result'),\n];\nPromise.any(promises)\n  .then((result) => assert.equal(\n    result, 'result'\n  ));\n\n```", "```js\nconst promises = [\n  Promise.reject('ERROR A'),\n  Promise.reject('ERROR B'),\n  Promise.reject('ERROR C'),\n];\nPromise.any(promises)\n  .catch((aggregateError) => assert.deepEqual(\n    aggregateError.errors,\n    ['ERROR A', 'ERROR B', 'ERROR C']\n  ));\n\n```", "```js\nconst resource = await Promise.any([\n  fetch('http://example.com/first.txt')\n    .then(response => response.text()),\n  fetch('http://example.com/second.txt')\n    .then(response => response.text()),\n]);\n\n```", "```js\nconst mylib = await Promise.any([\n  import('https://primary.example.com/mylib'),\n  import('https://secondary.example.com/mylib'),\n]);\n\n```", "```js\nlet mylib;\ntry {\n  mylib = await import('https://primary.example.com/mylib');\n} catch {\n  mylib = await import('https://secondary.example.com/mylib');\n}\n\n```", "```js\nPromise.allSettled<T>(promises: Iterable<Promise<T>>)\n  : Promise<Array<SettlementObject<T>>>\n\n```", "```js\ntype SettlementObject<T> = FulfillmentObject<T> | RejectionObject;\n\ninterface FulfillmentObject<T> {\n  status: 'fulfilled';\n  value: T;\n}\n\ninterface RejectionObject {\n  status: 'rejected';\n  reason: unknown;\n}\n\n```", "```js\n    { status: 'fulfilled', value:  v }\n\n    ```", "```js\n    { status: 'rejected',  reason: r }\n\n    ```", "```js\nPromise.allSettled([\n  Promise.resolve('value'),\n  Promise.reject('ERROR'),\n])\n.then(arr => assert.deepEqual(arr, [\n  { status: 'fulfilled', value: 'value' },\n  { status: 'rejected',  reason: 'ERROR' },\n]));\n\n```", "```js\nfunction downloadText(url) {\n  return fetch(url)\n    .then((response) => {\n      if (!response.ok) {\n        throw new Error(response.statusText);\n      }\n      return response.text();\n    });\n}\n\nconst urls = [\n  'http://example.com/exists.txt',\n  'http://example.com/missing.txt',\n];\n\nconst result = Promise.allSettled(\n  urls.map(url => downloadText(url))\n);\nresult.then(\n  (arr) => {\n    assert.deepEqual(\n      arr,\n      [\n        {\n          status: 'fulfilled',\n          value: 'Hello!',\n        },\n        {\n          status: 'rejected',\n          reason: new Error('Not Found'),\n        },\n      ]\n    )\n  }\n);\n\n```", "```js\nfunction allSettled(iterable) {\n  return new Promise((resolve, reject) => {\n    let elementCount = 0;\n    let result;\n\n    function addElementToResult(i, elem) {\n      result[i] = elem;\n      elementCount++;\n      if (elementCount === result.length) {\n        resolve(result);\n      }\n    }\n\n    let index = 0;\n    for (const promise of iterable) {\n      // Capture the current value of `index`\n      const currentIndex = index;\n      promise.then(\n        (value) => addElementToResult(\n          currentIndex, {\n            status: 'fulfilled',\n            value\n          }\n        ),\n        (reason) => addElementToResult(\n          currentIndex, {\n            status: 'rejected',\n            reason\n          }\n        )\n      );\n      index++;\n    }\n    if (index === 0) {\n      // Resolution is normally triggered by addElementToResult()\n      resolve([]);\n      return;\n    }\n    // Now we know how many Promises there are in `iterable`.\n    // We can wait until now with initializing `result` because\n    // the callbacks of .then() are executed asynchronously.\n    result = new Array(index);\n  });\n}\n\n```", "```js\nconst asyncFunc1 = () => Promise.resolve('one');\nconst asyncFunc2 = () => Promise.resolve('two');\n\nasyncFunc1()\n .then((result1) => {\n assert.equal(result1, 'one');\n return asyncFunc2();\n })\n .then((result2) => {\n assert.equal(result2, 'two');\n }); \n```", "```js\nPromise.all([asyncFunc1(), asyncFunc2()])\n  .then((arr) => {\n    assert.deepEqual(arr, ['one', 'two']);\n  });\n\n```", "```js\nfunction concurrentAll() {\n return Promise.all([asyncFunc1(), asyncFunc2()]);\n}\n\nfunction concurrentThen() {\n const p1 = asyncFunc1();\n const p2 = asyncFunc2();\n return p1.then(r1 => p2.then(r2 => [r1, r2]));\n} \n```", "```js\nfunction sequentialThen() {\n return asyncFunc1()\n .then(r1 => asyncFunc2()\n .then(r2 => [r1, r2]));\n}\n\nfunction sequentialAll() {\n const p1 = asyncFunc1();\n const p2 = p1.then(() => asyncFunc2());\n return Promise.all([p1, p2]);\n} \n```", "```js\nPromise.all([\n    // (A) fork\n    downloadText('http://example.com/first.txt'),\n    downloadText('http://example.com/second.txt'),\n  ])\n  // (B) join\n  .then(\n    (arr) => assert.deepEqual(\n      arr, ['First!', 'Second!']\n    ));\n\n```", "```js\n// Don’t do this\nfunction foo() {\n const promise = asyncFunc();\n promise.then((result) => {\n // ···\n });\n\n return promise;\n}\n\n```", "```js\nfunction foo() {\n const promise = asyncFunc();\n return promise.then((result) => {\n // ···\n });\n}\n\n```", "```js\n// Don’t do this\nasyncFunc1()\n  .then((result1) => {\n    return asyncFunc2()\n    .then((result2) => { // (A)\n      // ···\n    });\n  });\n\n```", "```js\nasyncFunc1()\n  .then((result1) => {\n    return asyncFunc2();\n  })\n  .then((result2) => {\n    // ···\n  });\n\n```", "```js\n// Don’t do this\nasyncFunc1()\n  .then((result1) => {\n    if (result1 < 0) {\n      return asyncFuncA()\n      .then(resultA => 'Result: ' + resultA);\n    } else {\n      return asyncFuncB()\n      .then(resultB => 'Result: ' + resultB);\n    }\n  });\n\n```", "```js\nasyncFunc1()\n  .then((result1) => {\n    return result1 < 0 ? asyncFuncA() : asyncFuncB();\n  })\n  .then((resultAB) => {\n    return 'Result: ' + resultAB;\n  });\n\n```", "```js\ndb.open()\n  .then((connection) => { // (A)\n    return connection.select({ name: 'Jane' })\n      .then((result) => { // (B)\n        // Process result\n        // Use `connection` to make more queries\n      })\n      // ···\n      .finally(() => {\n        connection.close(); // (C)\n      });\n  })\n\n```", "```js\n// Don’t do this\nclass Model {\n  insertInto(db) {\n    return new Promise((resolve, reject) => { // (A)\n      db.insert(this.fields)\n        .then((resultCode) => {\n          this.notifyObservers({event: 'created', model: this});\n          resolve(resultCode);\n        }).catch((err) => {\n          reject(err);\n        })\n    });\n  }\n  // ···\n}\n\n```", "```js\nclass Model {\n  insertInto(db) {\n    return db.insert(this.fields)\n      .then((resultCode) => {\n        this.notifyObservers({event: 'created', model: this});\n        return resultCode;\n      });\n  }\n  // ···\n}\n\n```", "```js\nconst promiseLikeObject = {\n  then(onFulfilled, onRejected) {\n    // ···\n  },\n};\n\n```", "```js\ninterface PromiseLike<T> {\n  then<TResult1, TResult2>(\n    onFulfilled?: (value: T) => TResult1 | PromiseLike<TResult1>,\n    onRejected?: (reason: any) => TResult2 | PromiseLike<TResult2>\n  ): PromiseLike<TResult1 | TResult2>;\n}\n\n```", "```js\npromise.catch(onRejected)\npromise.then(undefined, onRejected)\n\n```", "```js\nconst fulfilledThenable = {\n  then(onFulfilled, onRejected) {\n    onFulfilled('Success!');\n  },\n};\n\n```", "```js\nconst promise = Promise.resolve(fulfilledThenable);\nassert.equal(\n  promise instanceof Promise, true\n);\n\n```", "```js\nPromise.resolve()\n  .then(() => fulfilledThenable)\n  .then((value) => {\n    assert.equal(value, 'Success!');\n  });\n\n```", "```js\nnew Promise((resolve) => {\n  resolve(fulfilledThenable);\n}).then((value) => {\n  assert.equal(value, 'Success!');\n});\n\n```", "```js\nconst rejectedThenable = {\n  then(onFulfilled, onRejected) {\n    onRejected('Error!');\n  },\n};\n\nPromise.resolve(rejectedThenable)\n  .catch((reason) => {\n    assert.equal(reason, 'Error!');\n  });\n\nPromise.resolve()\n  .then(() => rejectedThenable)\n  .catch((reason) => {\n    assert.equal(reason, 'Error!');\n  });\n\nnew Promise((resolve) => {\n  resolve(rejectedThenable);\n}).catch((reason) => {\n  assert.equal(reason, 'Error!');\n});\n\n```", "```js\n    new Promise<T>(\n      executor: (\n     resolve: (value: T | PromiseLike<T>) => void,\n     reject: (reason?: any) => void\n     ) => void\n    ): Promise<T>\n\n    ```", "```js\n    // Create a Promise and resolve it\n    new Promise((resolve, reject) => {\n      resolve('Result');\n    }).then((value) => {\n      assert.equal(value, 'Result');\n    });\n\n    // Create a Promise and reject it\n    new Promise((resolve, reject) => {\n      reject('Error');\n    }).catch((reason) => {\n      assert.equal(reason, 'Error');\n    });\n\n    ```", "```js\n    Promise.withResolvers<T>(): PromiseWithResolvers<T>;\n    interface PromiseWithResolvers<T> {\n      promise: Promise<T>;\n      resolve: (value: T | PromiseLike<T>) => void;\n      reject: (reason?: any) => void;\n    }\n\n    ```", "```js\n    Promise.resolve('Yes')\n    .then((value) => {\n      assert.equal(value, 'Yes');\n    });\n\n    ```", "```js\n    Promise.reject('No')\n    .catch((reason) => {\n      assert.equal(reason, 'No');\n    });\n\n    ```", "```js\n    function computeAsync() {\n     return Promise.try(() => {\n     const value = syncFuncMightThrow();\n     return asyncFunc(value);\n     });\n    }\n\n    ```", "```js\n    Promise.all<T>(\n      promises: Iterable<Promise<T>>\n    ): Promise<Array<T>>\n\n    ```", "```js\n    Promise.race<T>(\n      promises: Iterable<Promise<T>>\n    ): Promise<T>\n\n    ```", "```js\n    Promise.any<T>(\n      promises: Iterable<Promise<T>>\n    ): Promise<T>\n\n    ```", "```js\n    class AggregateError {\n      constructor(errors: Iterable<any>, message: string);\n      get errors(): Array<any>;\n      get message(): string;\n    }\n\n    ```", "```js\n    Promise.allSettled<T>(\n      promises: Iterable<Promise<T>>\n    ): Promise<Array<SettlementObject<T>>>\n\n    ```", "```js\n    type SettlementObject<T> = FulfillmentObject<T> | RejectionObject;\n\n    interface FulfillmentObject<T> {\n      status: 'fulfilled';\n      value: T;\n    }\n\n    interface RejectionObject {\n      status: 'rejected';\n      reason: unknown;\n    }\n\n    ```", "```js\n    interface Promise<T> {\n      then<TResult1, TResult2>(\n        onFulfilled?: (value: T) => TResult1 | PromiseLike<TResult1>,\n        onRejected?: (reason: any) => TResult2 | PromiseLike<TResult2>\n      ): Promise<TResult1 | TResult2>;\n    }\n\n    ```", "```js\n    Promise.resolve('Yes')\n    .then((value) => {\n      assert.equal(value, 'Yes');\n    });\n\n    ```", "```js\n    interface Promise<T> {\n      catch<TResult>(\n        onrejected?: (reason: any) => TResult2 | PromiseLike<TResult2>\n      ): Promise<T | TResult>;\n    }\n\n    ```", "```js\n    promise.catch(onRejected)\n    promise.then(undefined, onRejected)\n\n    ```", "```js\n    Promise.reject('No')\n    .catch((reason) => {\n      assert.equal(reason, 'No');\n    });\n\n    ```", "```js\n    interface Promise<T> {\n      // Returning a rejected Promise from onFinally does have an effect!\n      finally(onFinally?: () => void);\n    }\n\n    ```", "```js\n    somePromise\n      .then((result) => {\n        // ···\n      })\n      .catch((error) => {\n        // ···\n      })\n      .finally(() => {\n        // ···\n      })\n    ;\n\n    ```"]