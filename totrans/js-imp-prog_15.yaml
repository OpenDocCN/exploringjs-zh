- en: 12 Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/impatient-js/ch_values.html](https://exploringjs.com/impatient-js/ch_values.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 12.1 [What’s a type?](ch_values.html#whats-a-type)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.2 [JavaScript’s type hierarchy](ch_values.html#javascripts-type-hierarchy)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.3 [The types of the language specification](ch_values.html#the-types-of-the-language-specification)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.4 [Primitive values vs. objects](ch_values.html#primitive-values-vs.-objects)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '12.4.1 [Primitive values (short: primitives)](ch_values.html#primitive-values-short-primitives)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.4.2 [Objects](ch_values.html#objects)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '12.5 [The operators `typeof` and `instanceof`: what’s the type of a value?](ch_values.html#the-operators-typeof-and-instanceof-whats-the-type-of-a-value)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.5.1 [`typeof`](ch_values.html#typeof)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.5.2 [`instanceof`](ch_values.html#instanceof)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.6 [Classes and constructor functions](ch_values.html#classes-and-constructor-functions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.6.1 [Constructor functions associated with primitive types](ch_values.html#constructor-functions-associated-with-primitive-types)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.7 [Converting between types](ch_values.html#converting-between-types)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.7.1 [Explicit conversion between types](ch_values.html#explicit-conversion-between-types)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.7.2 [Coercion (automatic conversion between types)](ch_values.html#coercion-automatic-conversion-between-types)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll examine what kinds of values JavaScript has.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ec8e6930fbe484fc519f3aa7b812c3fd.png)  **Supporting tool: `===`**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll occasionally use the strict equality operator. `a ===
    b` evaluates to `true` if `a` and `b` are equal. What exactly that means is explained
    in [§13.4.2 “Strict equality (`===` and `!==`)”](ch_operators.html#strict-equality).
  prefs: []
  type: TYPE_NORMAL
- en: 12.1 What’s a type?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this chapter, I consider types to be sets of values – for example, the type
    `boolean` is the set { `false`, `true` }.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2 JavaScript’s type hierarchy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Figure 6: A partial hierarchy of JavaScript’s types. Missing are the classes
    for errors, the classes associated with primitive types, and more. The diagram
    hints at the fact that not all objects are instances of Object.](../Images/2368843b86b1f2ca6ddd0254e1bf1dab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: A partial hierarchy of JavaScript’s types. Missing are the classes
    for errors, the classes associated with primitive types, and more. The diagram
    hints at the fact that not all objects are instances of `Object`.'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. [6](#fig:type_hierarchy) shows JavaScript’s type hierarchy. What do we
    learn from that diagram?
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript distinguishes two kinds of values: primitive values and objects.
    We’ll see soon what the difference is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The diagram differentiates objects and instances of class `Object`. Each instance
    of `Object` is also an object, but not vice versa. However, virtually all objects
    that you’ll encounter in practice are instances of `Object` – for example, objects
    created via object literals. More details on this topic are explained in [§29.7.3
    “Not all objects are instances of `Object`”](ch_classes.html#non-instances-of-object).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.3 The types of the language specification
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ECMAScript specification only knows a total of eight types. The names of
    those types are (I’m using TypeScript’s names, not the spec’s names):'
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined` with the only element `undefined`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null` with the only element `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean` with the elements `false` and `true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number` the type of all numbers (e.g., `-123`, `3.141`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bigint` the type of all big integers (e.g., `-123n`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string` the type of all strings (e.g., `''abc''`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symbol` the type of all symbols (e.g., `Symbol(''My Symbol'')`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object` the type of all objects (different from `Object`, the type of all
    instances of class `Object` and its subclasses)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.4 Primitive values vs. objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The specification makes an important distinction between values:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Primitive values* are the elements of the types `undefined`, `null`, `boolean`,
    `number`, `bigint`, `string`, `symbol`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All other values are *objects*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In contrast to Java (that inspired JavaScript here), primitive values are not
    second-class citizens. The difference between them and objects is more subtle.
    In a nutshell:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Primitive values: are atomic building blocks of data in JavaScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They are *passed by value*: when primitive values are assigned to variables
    or passed to functions, their contents are copied.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They are *compared by value*: when comparing two primitive values, their contents
    are compared.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Objects: are compound pieces of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They are *passed by identity* (my term): when objects are assigned to variables
    or passed to functions, their *identities* (think pointers) are copied.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They are *compared by identity* (my term): when comparing two objects, their
    identities are compared.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other than that, primitive values and objects are quite similar: they both
    have *properties* (key-value entries) and can be used in the same locations.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at primitive values and objects in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: '12.4.1 Primitive values (short: primitives)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 12.4.1.1 Primitives are immutable
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can’t change, add, or remove properties of primitives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 12.4.1.2 Primitives are *passed by value*
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Primitives are *passed by value*: variables (including parameters) store the
    contents of the primitives. When assigning a primitive value to a variable or
    passing it as an argument to a function, its content is copied.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **Observing the difference
    between passing by value and passing by reference**'
  prefs: []
  type: TYPE_NORMAL
- en: Due to primitive values being immutable and compared by value (see next subsection),
    there is no way to observe the difference between passing by value and passing
    by identity (as used for objects in JavaScript).
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.1.3 Primitives are *compared by value*
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Primitives are *compared by value*: when comparing two primitive values, we
    compare their contents.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To see what’s so special about this way of comparing, read on and find out how
    objects are compared.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.2 Objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Objects are covered in detail in [§28 “Objects”](ch_objects.html) and the following
    chapter. Here, we mainly focus on how they differ from primitive values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first explore two common ways of creating objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Object literal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The object literal starts and ends with curly braces `{}`. It creates an object
    with two properties. The first property has the key `''first''` (a string) and
    the value `''Jane''`. The second property has the key `''last''` and the value
    `''Doe''`. For more information on object literals, consult [§28.3.1 “Object literals:
    properties”](ch_objects.html#object-literals).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Array literal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Array literal starts and ends with square brackets `[]`. It creates an
    Array with two *elements*: `''strawberry''` and `''apple''`. For more information
    on Array literals, consult [§31.3.1 “Creating, reading, writing Arrays”](ch_arrays.html#array-literals).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 12.4.2.1 Objects are mutable by default
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'By default, you can freely change, add, and remove the properties of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 12.4.2.2 Objects are *passed by identity*
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Objects are *passed by identity* (my term): variables (including parameters)
    store the *identities* of objects.'
  prefs: []
  type: TYPE_NORMAL
- en: The identity of an object is like a pointer (or a transparent reference) to
    the object’s actual data on the *heap* (think shared main memory of a JavaScript
    engine).
  prefs: []
  type: TYPE_NORMAL
- en: When assigning an object to a variable or passing it as an argument to a function,
    its identity is copied. Each object literal creates a fresh object on the heap
    and returns its identity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript uses *garbage collection* to automatically manage memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the old value `{ prop: ''value'' }` of `obj` is *garbage* (not used anymore).
    JavaScript will automatically *garbage-collect* it (remove it from memory), at
    some point in time (possibly never if there is enough free memory).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **Details: passing by
    identity**'
  prefs: []
  type: TYPE_NORMAL
- en: “Passing by identity” means that the identity of an object (a transparent reference)
    is passed by value. This approach is also called [“passing by sharing”](https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing).
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.2.3 Objects are *compared by identity*
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Objects are *compared by identity* (my term): two variables are only equal
    if they contain the same object identity. They are not equal if they refer to
    different objects with the same content.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '12.5 The operators `typeof` and `instanceof`: what’s the type of a value?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The two operators `typeof` and `instanceof` let you determine what type a given
    value `x` has:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How do they differ?
  prefs: []
  type: TYPE_NORMAL
- en: '`typeof` distinguishes the 7 types of the specification (minus one omission,
    plus one addition).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`instanceof` tests which class created a given value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png)  **Rule of thumb: `typeof`
    is for primitive values; `instanceof` is for objects**'
  prefs: []
  type: TYPE_NORMAL
- en: 12.5.1 `typeof`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Table 2: The results of the `typeof` operator.'
  prefs: []
  type: TYPE_NORMAL
- en: '| `x` | `typeof x` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `undefined` | `''undefined''` |'
  prefs: []
  type: TYPE_TB
- en: '| `null` | `''object''` |'
  prefs: []
  type: TYPE_TB
- en: '| Boolean | `''boolean''` |'
  prefs: []
  type: TYPE_TB
- en: '| Number | `''number''` |'
  prefs: []
  type: TYPE_TB
- en: '| Bigint | `''bigint''` |'
  prefs: []
  type: TYPE_TB
- en: '| String | `''string''` |'
  prefs: []
  type: TYPE_TB
- en: '| Symbol | `''symbol''` |'
  prefs: []
  type: TYPE_TB
- en: '| Function | `''function''` |'
  prefs: []
  type: TYPE_TB
- en: '| All other objects | `''object''` |'
  prefs: []
  type: TYPE_TB
- en: 'Tbl. [2](#tbl:typeof-results) lists all results of `typeof`. They roughly correspond
    to the 7 types of the language specification. Alas, there are two differences,
    and they are language quirks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`typeof null` returns `''object''` and not `''null''`. That’s a bug. Unfortunately,
    it can’t be fixed. TC39 tried to do that, but it broke too much code on the web.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`typeof` of a function should be `''object''` (functions are objects). Introducing
    a separate category for functions is confusing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are a few examples of using `typeof`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercises: Two exercises
    on `typeof`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/values/typeof_exrc.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bonus: `exercises/values/is_object_test.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.5.2 `instanceof`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This operator answers the question: has a value `x` been created by a class
    `C`?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Primitive values are not instances of anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: `instanceof`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/values/instanceof_exrc.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: 12.6 Classes and constructor functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript’s original factories for objects are *constructor functions*: ordinary
    functions that return “instances” of themselves if you invoke them via the `new`
    operator.'
  prefs: []
  type: TYPE_NORMAL
- en: ES6 introduced *classes*, which are mainly better syntax for constructor functions.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, I’m using the terms *constructor function* and *class* interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: Classes can be seen as partitioning the single type `object` of the specification
    into subtypes – they give us more types than the limited 7 ones of the specification.
    Each class is the type of the objects that were created by it.
  prefs: []
  type: TYPE_NORMAL
- en: 12.6.1 Constructor functions associated with primitive types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Each primitive type (except for the spec-internal types for `undefined` and
    `null`) has an associated *constructor function* (think class):'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor function `Boolean` is associated with booleans.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor function `Number` is associated with numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor function `String` is associated with strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor function `Symbol` is associated with symbols.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these functions plays several roles – for example, `Number`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use it as a function and convert values to numbers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Number.prototype` provides the properties for numbers – for example, method
    `.toString()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Number` is a namespace/container object for tool functions for numbers – for
    example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, you can also use `Number` as a class and create number objects. These
    objects are different from real numbers and should be avoided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 12.6.1.1 Wrapping primitive values
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The constructor functions related to primitive types are also called *wrapper
    types* because they provide the canonical way of converting primitive values to
    objects. In the process, primitive values are “wrapped” in objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Wrapping rarely matters in practice, but it is used internally in the language
    specification, to give primitives properties.
  prefs: []
  type: TYPE_NORMAL
- en: 12.7 Converting between types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two ways in which values are converted to other types in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicit conversion: via functions such as `String()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Coercion* (automatic conversion): happens when an operation receives operands/parameters
    that it can’t work with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.7.1 Explicit conversion between types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The function associated with a primitive type explicitly converts values to
    that type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `Object()` to convert values to objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table describes in more detail how this conversion works:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `x` | `Object(x)` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `undefined` | `{}` |'
  prefs: []
  type: TYPE_TB
- en: '| `null` | `{}` |'
  prefs: []
  type: TYPE_TB
- en: '| boolean | `new Boolean(x)` |'
  prefs: []
  type: TYPE_TB
- en: '| number | `new Number(x)` |'
  prefs: []
  type: TYPE_TB
- en: '| bigint | An instance of `BigInt` (`new` throws `TypeError`) |'
  prefs: []
  type: TYPE_TB
- en: '| string | `new String(x)` |'
  prefs: []
  type: TYPE_TB
- en: '| symbol | An instance of `Symbol` (`new` throws `TypeError`) |'
  prefs: []
  type: TYPE_TB
- en: '| object | `x` |'
  prefs: []
  type: TYPE_TB
- en: 12.7.2 Coercion (automatic conversion between types)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For many operations, JavaScript automatically converts the operands/parameters
    if their types don’t fit. This kind of automatic conversion is called *coercion*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the multiplication operator coerces its operands to numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Many built-in functions coerce, too. For example, `Number.parseInt()` coerces
    its parameter to a string before parsing it. That explains the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The number `123.45` is converted to the string `'123.45'` before it is parsed.
    Parsing stops before the first non-digit character, which is why the result is
    `123`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Converting
    values to primitives**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/values/conversion_exrc.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz**'
  prefs: []
  type: TYPE_NORMAL
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  prefs: []
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/7)'
  prefs: []
  type: TYPE_NORMAL
