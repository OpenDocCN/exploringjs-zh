- en: 14 The non-values undefined and null
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/impatient-js/ch_undefined-null.html](https://exploringjs.com/impatient-js/ch_undefined-null.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 14.1 [`undefined` vs. `null`](ch_undefined-null.html#undefined-vs.-null)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.2 [Occurrences of `undefined` and `null`](ch_undefined-null.html#occurrences-of-undefined-and-null)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.2.1 [Occurrences of `undefined`](ch_undefined-null.html#occurrences-of-undefined)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.2.2 [Occurrences of `null`](ch_undefined-null.html#occurrences-of-null)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.3 [Checking for `undefined` or `null`](ch_undefined-null.html#checking-for-undefined-or-null)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.4 [The nullish coalescing operator (`??`) for default values [ES2020]](ch_undefined-null.html#nullish-coalescing-operator)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '14.4.1 [Example: counting matches](ch_undefined-null.html#example-counting-matches)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '14.4.2 [Example: specifying a default value for a property](ch_undefined-null.html#example-specifying-a-default-value-for-a-property)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.4.3 [Using destructuring for default values](ch_undefined-null.html#using-destructuring-for-default-values)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '14.4.4 [Legacy approach: using logical Or (`||`) for default values](ch_undefined-null.html#legacy-approach-using-logical-or-for-default-values)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.4.5 [The nullish coalescing assignment operator (`??=`) [ES2021]](ch_undefined-null.html#nullish-coalescing-assignment-operator)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.5 [`undefined` and `null` don’t have properties](ch_undefined-null.html#undefined-and-null-dont-have-properties)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.6 [The history of `undefined` and `null`](ch_undefined-null.html#the-history-of-undefined-and-null)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Many programming languages have one “non-value” called `null`. It indicates
    that a variable does not currently point to an object – for example, when it hasn’t
    been initialized yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, JavaScript has two of them: `undefined` and `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: 14.1 `undefined` vs. `null`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both values are very similar and often used interchangeably. How they differ
    is therefore subtle. The language itself makes the following distinction:'
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined` means “not initialized” (e.g., a variable) or “not existing” (e.g.,
    a property of an object).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null` means “the intentional absence of any object value” (a quote from [the
    language specification](https://tc39.github.io/ecma262/#sec-null-value)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Programmers may make the following distinction:'
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined` is the non-value used by the language (when something is uninitialized,
    etc.).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null` means “explicitly switched off”. That is, it helps implement a type
    that comprises both meaningful values and a meta-value that stands for “no meaningful
    value”. Such a type is called [*option type* or *maybe type*](https://en.wikipedia.org/wiki/Option_type)
    in functional programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.2 Occurrences of `undefined` and `null`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following subsections describe where `undefined` and `null` appear in the
    language. We’ll encounter several mechanisms that are explained in more detail
    later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 14.2.1 Occurrences of `undefined`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Uninitialized variable `myVar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameter `x` is not provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Property `.unknownProp` is missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don’t explicitly specify the result of a function via a `return` statement,
    JavaScript returns `undefined` for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 14.2.2 Occurrences of `null`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The prototype of an object is either an object or, at the end of a chain of
    prototypes, `null`. `Object.prototype` does not have a prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we match a regular expression (such as `/a/`) against a string (such as
    `''x''`), we either get an object with matching data (if matching was successful)
    or `null` (if matching failed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The [JSON data format](ch_json.html) does not support `undefined`, only `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 14.3 Checking for `undefined` or `null`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Checking for either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Does `x` have a value?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Is `x` either `undefined` or `null`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Truthy* means “is `true` if coerced to boolean”. *Falsy* means “is `false`
    if coerced to boolean”. Both concepts are explained properly in [§15.2 “Falsy
    and truthy values”](ch_booleans.html#falsiness-truthiness).'
  prefs: []
  type: TYPE_NORMAL
- en: 14.4 The nullish coalescing operator (`??`) for default values [ES2020]
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes we receive a value and only want to use it if it isn’t either `null`
    or `undefined`. Otherwise, we’d like to use a default value, as a fallback. We
    can do that via the *nullish coalescing operator* (`??`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following two expressions are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '14.4.1 Example: counting matches'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following code shows a real-world example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If there are one or more matches for `regex` inside `str`, then `.match()` returns
    an Array. If there are no matches, it unfortunately returns `null` (and not the
    empty Array). We fix that via the `??` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also could have used [optional chaining](ch_objects.html#optional-chaining):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '14.4.2 Example: specifying a default value for a property'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 14.4.3 Using destructuring for default values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In some cases, destructuring can also be used for default values – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '14.4.4 Legacy approach: using logical Or (`||`) for default values'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before ECMAScript 2020 and the nullish coalescing operator, logical Or was used
    for default values. That has a downside.
  prefs: []
  type: TYPE_NORMAL
- en: '`||` works as expected for `undefined` and `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'But it also returns the default for all other falsy values – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare that to how `??` works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 14.4.5 The nullish coalescing assignment operator (`??=`) [ES2021]
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`??=` is a [logical assignment operator](ch_operators.html#logical-assignment-operators).
    The following two expressions are roughly equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'That means that `??=` is [short-circuiting](ch_booleans.html#short-circuiting):
    The assignment is only made if `a` is `undefined` or `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: '14.4.5.1 Example: using `??=` to add missing properties'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 14.5 `undefined` and `null` don’t have properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`undefined` and `null` are the only two JavaScript values where we get an exception
    if we try to read a property. To explore this phenomenon, let’s use the following
    function, which reads (“gets”) property `.foo` and returns the result.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we apply `getFoo()` to various values, we can see that it only fails for
    `undefined` and `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 14.6 The history of `undefined` and `null`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Java (which inspired many aspects of JavaScript), initialization values
    depend on the static type of a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: Variables with object types are initialized with `null`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each primitive type has its own initialization value. For example, `int` variables
    are initialized with `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In JavaScript, each variable can hold both object values and primitive values.
    Therefore, if `null` means “not an object”, JavaScript also needs an initialization
    value that means “neither an object nor a primitive value”. That initialization
    value is `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz**'
  prefs: []
  type: TYPE_NORMAL
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  prefs: []
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/9)'
  prefs: []
  type: TYPE_NORMAL
