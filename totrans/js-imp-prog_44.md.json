["```js\nconst arr = ['a', 'b', 'c'];\nconst x = arr[0]; // extract\nconst y = arr[1]; // extract\n```", "```js\nconst arr = ['a', 'b', 'c'];\nconst [x, y] = arr; // (A)\nassert.equal(x, 'a');\nassert.equal(y, 'b');\n```", "```js\n// Constructing: one property at a time\nconst jane1 = {};\njane1.first = 'Jane';\njane1.last = 'Doe';\n\n// Constructing: multiple properties\nconst jane2 = {\n first: 'Jane',\n last: 'Doe',\n};\n\nassert.deepEqual(jane1, jane2);\n```", "```js\nconst jane = {\n first: 'Jane',\n last: 'Doe',\n};\n\n// Extracting: one property at a time\nconst f1 = jane.first;\nconst l1 = jane.last;\nassert.equal(f1, 'Jane');\nassert.equal(l1, 'Doe');\n\n// Extracting: multiple properties (NEW!)\nconst {first: f2, last: l2} = jane; // (A)\nassert.equal(f2, 'Jane');\nassert.equal(l2, 'Doe');\n```", "```js\n{first: f2, last: l2}\n```", "```js\n    const [a] = ['x'];\n    assert.equal(a, 'x');\n\n    let [b] = ['y'];\n    assert.equal(b, 'y');\n    ```", "```js\n    let b;\n    [b] = ['z'];\n    assert.equal(b, 'z');\n    ```", "```js\n    const f = ([x]) => x;\n    assert.equal(f(['a']), 'a');\n    ```", "```js\nconst arr = ['a', 'b'];\nfor (const [index, element] of arr.entries()) {\n console.log(index, element);\n}\n// Output:\n// 0, 'a'\n// 1, 'b'\n```", "```js\nconst address = {\n street: 'Evergreen Terrace',\n number: '742',\n city: 'Springfield',\n state: 'NT',\n zip: '49007',\n};\n\nconst { street: s, city: c } = address;\nassert.equal(s, 'Evergreen Terrace');\nassert.equal(c, 'Springfield');\n```", "```js\nconst {length: len} = 'abc';\nassert.equal(len, 3);\n```", "```js\nconst {0:x, 2:y} = ['a', 'b', 'c'];\nassert.equal(x, 'a');\nassert.equal(y, 'c');\n```", "```js\nconst { street, city } = address;\nassert.equal(street, 'Evergreen Terrace');\nassert.equal(city, 'Springfield');\n```", "```js\nconst obj = { a: 1, b: 2, c: 3 };\nconst { a: propValue, ...remaining } = obj; // (A)\n\nassert.equal(propValue, 1);\nassert.deepEqual(remaining, {b:2, c:3});\n```", "```js\nlet prop;\nassert.throws(\n () => eval(\"{prop} = { prop: 'hello' };\"),\n {\n name: 'SyntaxError',\n message: \"Unexpected token '='\",\n });\n```", "```js\nlet prop;\n({prop} = { prop: 'hello' });\nassert.equal(prop, 'hello');\n```", "```js\nconst [x, y] = ['a', 'b'];\nassert.equal(x, 'a');\nassert.equal(y, 'b');\n```", "```js\nconst [, x, y] = ['a', 'b', 'c']; // (A)\nassert.equal(x, 'b');\nassert.equal(y, 'c');\n```", "```js\n// Sets are iterable\nconst mySet = new Set().add('a').add('b').add('c');\nconst [first, second] = mySet;\nassert.equal(first, 'a');\nassert.equal(second, 'b');\n\n// Strings are iterable\nconst [a, b] = 'xyz';\nassert.equal(a, 'x');\nassert.equal(b, 'y');\n```", "```js\nconst [x, y, ...remaining] = ['a', 'b', 'c', 'd']; // (A)\n\nassert.equal(x, 'a');\nassert.equal(y, 'b');\nassert.deepEqual(remaining, ['c', 'd']);\n```", "```js\nlet x = 'a';\nlet y = 'b';\n\n[x,y] = [y,x]; // swap\n\nassert.equal(x, 'b');\nassert.equal(y, 'a');\n```", "```js\n// Skip the element at index 0 (the whole match):\nconst [, year, month, day] =\n /^([0-9]{4})-([0-9]{2})-([0-9]{2})$/\n .exec('2999-12-31');\n\nassert.equal(year, '2999');\nassert.equal(month, '12');\nassert.equal(day, '31');\n```", "```js\nfindElement(array, (value, index) => \u00abboolean expression\u00bb)\n```", "```js\nfunction findElement(arr, predicate) {\n for (let index=0; index < arr.length; index++) {\n const value = arr[index];\n if (predicate(value)) {\n // We found something:\n return { value, index };\n }\n }\n // We didn\u2019t find anything:\n return { value: undefined, index: -1 };\n}\n```", "```js\nconst arr = [7, 8, 6];\n\nconst {value, index} = findElement(arr, x => x % 2 === 0);\nassert.equal(value, 8);\nassert.equal(index, 1);\n```", "```js\nconst {index, value} = findElement(arr, x => x % 2 === 0);\n```", "```js\nconst arr = [7, 8, 6];\n\nconst {value} = findElement(arr, x => x % 2 === 0);\nassert.equal(value, 8);\n\nconst {index} = findElement(arr, x => x % 2 === 0);\nassert.equal(index, 1);\n```", "```js\nconst {prop: p} = {};\nassert.equal(p, undefined);\n```", "```js\nconst [x] = [];\nassert.equal(x, undefined);\n```", "```js\n> const {prop} = undefined\nTypeError: Cannot destructure property 'prop' of 'undefined'\nas it is undefined.\n\n> const {prop} = null\nTypeError: Cannot destructure property 'prop' of 'null'\nas it is null.\n```", "```js\n> const [x] = {}\nTypeError: {} is not iterable\n```", "```js\nconst {prop: p} = {};\nassert.equal(p, undefined);\n```", "```js\nconst {prop: p = 123} = {}; // (A)\nassert.equal(p, 123);\n```", "```js\nconst [x=1, y=2] = [];\n\nassert.equal(x, 1);\nassert.equal(y, 2);\n```", "```js\nconst {first: f='', last: l=''} = {};\nassert.equal(f, '');\nassert.equal(l, '');\n```", "```js\nconst {first='', last=''} = {};\nassert.equal(first, '');\nassert.equal(last, '');\n```", "```js\nfunction f1(\u00abpattern1\u00bb, \u00abpattern2\u00bb) {\n // \u00b7\u00b7\u00b7\n}\n\nfunction f2(...args) {\n const [\u00abpattern1\u00bb, \u00abpattern2\u00bb] = args;\n // \u00b7\u00b7\u00b7\n}\n```", "```js\nconst arr = [\n { first: 'Jane', last: 'Bond' },\n { first: 'Lars', last: 'Croft' },\n];\nconst [, {first}] = arr; // (A)\nassert.equal(first, 'Lars');\n```"]