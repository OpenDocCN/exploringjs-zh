["```ts\nconst Color_Red = '#FF0000';\nconst Color_Green = '#00FF00';\nconst Color_Blue = '#0000FF';\n\n```", "```ts\nconst Status_Pending = 'Pending';\nconst Status_Ongoing = 'Ongoing';\nconst Status_Finished = 'Finished';\ntype Status =\n | typeof Status_Pending\n | typeof Status_Ongoing\n | typeof Status_Finished\n;\n\n```", "```ts\nfunction describeStatus(status: Status): string {\n switch (status) {\n case Status_Pending:\n return 'Not yet';\n case Status_Ongoing:\n return 'Working on it...';\n case Status_Finished:\n return 'We are done';\n default:\n throw new UnexpectedValueError(status);\n }\n}\n\n```", "```ts\nclass UnexpectedValueError extends Error {\n constructor(value: never) {\n // Only solution that can stringify undefined, null, symbols, and\n // objects without prototypes\n super('Unexpected value: ' + {}.toString.call(value));\n }\n}\n\n```", "```ts\nconst TextStyle_Bold = {\n key: 'Bold',\n html: 'b',\n latex: 'textbf',\n};\nconst TextStyle_Italics = {\n key: 'Italics',\n html: 'i',\n latex: 'textit',\n};\n\n```", "```ts\n    type TextStyle = typeof TextStyle_Bold | typeof TextStyle_Italics;\n\n    ```", "```ts\nenum NoYes {\n No = 0,\n Yes = 1, // trailing comma\n}\n\nassert.equal(NoYes.No, 0);\nassert.equal(NoYes.Yes, 1);\n\n```", "```ts\n    assert.equal(NoYes.No, 0);\n    assert.equal(NoYes.Yes, 1);\n\n    ```", "```ts\nfunction toGerman(value: NoYes) {\n switch (value) {\n case NoYes.No:\n return 'Nein';\n case NoYes.Yes:\n return 'Ja';\n }\n}\nassert.equal(toGerman(NoYes.No), 'Nein');\nassert.equal(toGerman(NoYes.Yes), 'Ja');\n\n```", "```ts\nenum NoYes {\n No = 'No',\n Yes = 'Yes',\n}\n\nassert.equal(NoYes.No, 'No');\nassert.equal(NoYes.Yes, 'Yes');\n\n```", "```ts\nenum Enum {\n One = 'One',\n Two = 'Two',\n Three = 3,\n Four = 4,\n}\nassert.deepEqual(\n [Enum.One, Enum.Two, Enum.Three, Enum.Four],\n ['One', 'Two', 3, 4]\n);\n\n```", "```ts\nenum NoYes {\n No,\n Yes,\n}\nassert.equal(NoYes.No, 0);\nassert.equal(NoYes.Yes, 1);\n\n```", "```ts\nenum Omissions {\n A,\n B,\n C = 'C',\n D = 'D',\n E = 8,\n // We can only omit the initializer\n // at the beginning or after a number\n F,\n}\nassert.equal(Omissions.A, 0);\nassert.equal(Omissions.B, 1);\nassert.equal(Omissions.C, 'C');\nassert.equal(Omissions.D, 'D');\nassert.equal(Omissions.E, 8);\nassert.equal(Omissions.F, 9);\n\n```", "```ts\nenum HttpRequestField {\n 'Accept',\n 'Accept-Charset',\n 'Accept-Datetime',\n 'Accept-Encoding',\n 'Accept-Language',\n}\nassert.equal(HttpRequestField['Accept-Charset'], 1);\n\n```", "```ts\nenum ShapeKind { Circle, Rectangle }\n\n```", "```ts\nconst value = ShapeKind.Circle;\nassert.equal(value, 0);\n\n```", "```ts\ntype _ = [\n // Type `ShapeKind` is assignable to and from\n // a union of number literal types\n Assert<Assignable<\n 0 | 1, ShapeKind\n >>,\n Assert<Assignable<\n ShapeKind, 0 | 1\n >>,\n // Accordingly, the keys of type `ShapeKind` are\n // equal to the keys of type `number`\n Assert<Equal<\n keyof ShapeKind,\n keyof number\n >>,\n];\n\n```", "```ts\ntype _ = [\n Assert<Assignable<\n 0, ShapeKind.Circle\n >>,\n Assert<Assignable<\n ShapeKind.Circle, 0\n >>,\n];\n\n```", "```ts\nfunction describeCircle(circle: ShapeKind.Circle): string {\n // ···\n}\n\n```", "```ts\ntype Shape =\n | {\n kind: ShapeKind.Circle,\n center: Point,\n }\n | {\n kind: ShapeKind.Rectangle,\n corner1: Point,\n corner2: Point,\n }\n;\ntype Point = {\n x: number,\n y: number,\n}\n\n```", "```ts\nenum Fruit { Apple, Strawberry }\nfunction check(_animal: Fruit) {}\n\ncheck(Fruit.Apple);\ncheck(0);\n\n```", "```ts\n// @ts-expect-error: Argument of type '2' is not assignable to parameter of type 'Fruit'.\ncheck(2);\n\n```", "```ts\nenum Fruit { Apple='Apple', Strawberry='Strawberry' }\nfunction check(_animal: Fruit) {}\n\ncheck(Fruit.Apple);\n// @ts-expect-error: Argument of type '\"Apple\"' is not assignable to parameter of type 'Fruit'.\ncheck('Apple');\n\n```", "```ts\nenum Animal { Dog, Cat }\n\n```", "```ts\nvar Animal;\n(function (Animal) {\n Animal[Animal[\"Dog\"] = 0] = \"Dog\";\n Animal[Animal[\"Cat\"] = 1] = \"Cat\";\n})(Animal || (Animal = {}));\n\n```", "```ts\nAnimal[\"Dog\"] = 0;\nAnimal[\"Cat\"] = 1;\n\nAnimal[0] = \"Dog\";\nAnimal[1] = \"Cat\";\n\n```", "```ts\nenum Animal { Dog, Cat }\nassert.equal(\n Animal[0], 'Dog'\n);\n\n```", "```ts\nenum Animal {\n Dog = 'DOG!',\n Cat = 'CAT!',\n}\n\n```", "```ts\nvar Animal;\n(function (Animal) {\n Animal[\"Dog\"] = \"DOG!\";\n Animal[\"Cat\"] = \"CAT!\";\n})(Animal || (Animal = {}));\n\n```", "```ts\nenum Color {\n Red = '#FF0000',\n Green = '#00FF00',\n Blue = '#0000FF',\n}\n\n```", "```ts\nenum Status {\n Pending = 'Pending',\n Ongoing = 'Ongoing',\n Finished = 'Finished',\n}\n\n```", "```ts\nfunction describeStatus(status: Status): string {\n switch (status) {\n case Status.Pending:\n return 'Not yet';\n case Status.Ongoing:\n return 'Working on it...';\n case Status.Finished:\n return 'We are done';\n default:\n throw new UnexpectedValueError(status);\n }\n}\nassert.equal(\n describeStatus(Status.Pending),\n 'Not yet'\n);\n\n```", "```ts\nconst enum Vegetable {\n Carrot = 'Carrot',\n Onion = 'Onion',\n}\n\nfunction toGerman(vegetable: Vegetable) {\n switch (vegetable) {\n case Vegetable.Carrot:\n return 'Karotte';\n case Vegetable.Onion:\n return 'Zwiebel';\n }\n}\n\n```", "```ts\nfunction toGerman(vegetable) {\n switch (vegetable) {\n case \"Carrot\" /* Vegetable.Carrot */:\n return 'Karotte';\n case \"Onion\" /* Vegetable.Onion */:\n return 'Zwiebel';\n }\n}\n\n```", "```ts\nvar Vegetable;\n(function (Vegetable) {\n Vegetable[\"Carrot\"] = \"Carrot\";\n Vegetable[\"Onion\"] = \"Onion\";\n})(Vegetable || (Vegetable = {}));\nfunction toGerman(vegetable) {\n switch (vegetable) {\n case Vegetable.Carrot:\n return 'Karotte';\n case Vegetable.Onion:\n return 'Zwiebel';\n }\n}\n\n```", "```ts\nconst Tree = {\n Maple: 'MAPLE',\n Oak: 'OAK',\n};\n\n```", "```ts\nconst Tree = {\n Maple: 'MAPLE',\n Oak: 'OAK',\n};\ntype _1 = Assert<Equal<\n typeof Tree,\n {\n Maple: string,\n Oak: string,\n }\n>>;\n\nconst TreeAsConst = {\n Maple: 'MAPLE',\n Oak: 'OAK',\n} as const;\ntype _2 = Assert<Equal<\n typeof TreeAsConst,\n {\n readonly Maple: 'MAPLE',\n readonly Oak: 'OAK',\n }\n>>;\n\n```", "```ts\ntype _ = [\n Assert<Equal<\n ValueOf<typeof Tree>,\n string\n >>,\n Assert<Equal<\n ValueOf<typeof TreeAsConst>,\n 'MAPLE' | 'OAK'\n >>,\n];\n\n```", "```ts\ntype ValueOf<Obj> = Obj[keyof Obj];\n\n```", "```ts\ntype _3 = Assert<Equal<\n keyof (typeof Tree),\n 'Maple' | 'Oak'\n>>;\ntype _4 = Assert<Equal<\n keyof (typeof TreeAsConst),\n 'Maple' | 'Oak'\n>>;\n\n```", "```ts\nconst TreeFrozen = Object.freeze({\n Maple: 'MAPLE',\n Oak: 'OAK',\n});\n\n```", "```ts\nassert.throws(\n () => TreeFrozen.newProp = true,\n /^TypeError: Cannot add property newProp, object is not extensible$/\n);\nassert.throws(\n () => TreeFrozen.Maple = 'Ash',\n /^TypeError: Cannot assign to read only property 'Maple'/\n);\n\n```", "```ts\nconst frozenObject = Object.freeze({\n prop: 123\n});\ntype _ = Assert<Equal<\n typeof frozenObject,\n {\n readonly prop: 123,\n }\n>>;\n\n```", "```ts\nconst Tree = {\n Maple: 'MAPLE',\n Oak: 'OAK',\n};\nconst TreeProtoNull = {\n __proto__: null,\n Maple: 'MAPLE',\n Oak: 'OAK',\n};\n\n```", "```ts\nassert.equal(\n 'toString' in Tree,\n true\n);\nassert.equal(\n 'toString' in TreeProtoNull,\n false\n);\n\n```", "```ts\nassert.equal(\n typeof Tree.toString,\n 'function'\n);\nassert.equal(\n TreeProtoNull.toString,\n undefined\n);\n\n```", "```ts\nassert.deepEqual(\n Object.keys(Tree),\n ['Maple', 'Oak']\n);\nassert.deepEqual(\n Object.keys(TreeProtoNull),\n ['Maple', 'Oak']\n);\n\nassert.deepEqual(\n Object.values(Tree),\n ['MAPLE', 'OAK']\n);\nassert.deepEqual(\n Object.values(TreeProtoNull),\n ['MAPLE', 'OAK']\n);\n\n```", "```ts\nconst TreeProtoNull = {\n __proto__: null,\n Maple: 'MAPLE',\n Oak: 'OAK',\n} as const;\ntype _ = Assert<Equal<\n typeof TreeProtoNull,\n {\n readonly __proto__: null;\n readonly Maple: 'MAPLE';\n readonly Oak: 'OAK';\n }\n>>;\n\n```", "```ts\ntype TreeProtoNullType = ValueOf<typeof TreeProtoNull>;\n// 123 | null\n\ntype _Y = [\n Assert<Equal<\n ValueOf<typeof TreeProtoNull>,\n 'MAPLE' | 'OAK' | null\n >>,\n Assert<Equal<\n ValueOf<Omit<typeof TreeProtoNull, '__proto__'>>, // (A)\n 'MAPLE' | 'OAK'\n >>,\n];\n\n```", "```ts\nconst Tree = Object.freeze({\n __proto__: null,\n Maple: 'MAPLE',\n Oak: 'OAK',\n});\n\n```", "```ts\nconst Tree = createEnum({\n Maple: 'MAPLE',\n Oak: 'OAK',\n});\ntype _ = Assert<Equal<\n typeof Tree,\n {\n readonly Maple: 'MAPLE';\n readonly Oak: 'OAK';\n }\n>>;\n\n```", "```ts\n/**\n * Returns an enum object. Adds the following improvements:\n * - Sets the prototype to `null`.\n * - Freezes the object.\n * - The result has the same type as if `as const` had been applied.\n */\nfunction createEnum<\n // The two type variables are necessary so that the result has specific\n // property value types.\n T extends { [idx: string]: V },\n V extends\n | undefined | null | boolean | number | bigint | string | symbol \n | object\n>(enumObj: T): Readonly<T> {\n // Copying `enumObj` is better for performance than Object.setPrototypeOf()\n return Object.freeze({\n __proto__: null,\n ...enumObj,\n });\n}\n\n```", "```ts\nconst Color = {\n Red: '#FF0000',\n Green: '#00FF00',\n Blue: '#0000FF',\n};\n\n```", "```ts\nconst Status = {\n Pending: 'Pending',\n Ongoing: 'Ongoing',\n Finished: 'Finished',\n} as const; // (A)\n\n```", "```ts\ntype StatusType = ValueOf<typeof Status>;\ntype _ = Assert<Equal<\n StatusType, 'Pending' | 'Ongoing' | 'Finished'\n>>;\n\n```", "```ts\nfunction describeStatus(status: StatusType): string { // (A)\n switch (status) {\n case Status.Pending:\n return 'Not yet';\n case Status.Ongoing:\n return 'Working on it...';\n case Status.Finished:\n return 'We are done';\n default:\n throw new UnexpectedValueError(status);\n }\n}\nassert.equal(\n describeStatus(Status.Pending),\n 'Not yet'\n);\n\n```", "```ts\nconst ShapeKind = {\n Circle: 0,\n Rectangle: 1,\n} as const;\n\n```", "```ts\n// @ts-expect-error: Cannot find namespace 'ShapeKind'.\ntype _ = ShapeKind.Circle;\n\n```", "```ts\ntype Shape =\n | {\n key: typeof ShapeKind.Circle, // (A)\n center: Point,\n }\n | {\n key: typeof ShapeKind.Rectangle, // (B)\n corner1: Point,\n corner2: Point,\n }\n;\ntype Point = {\n x: number,\n y: number,\n}\n\n```", "```ts\nconst Pending = Symbol('Pending');\nconst Ongoing = Symbol('Ongoing');\nconst Finished = Symbol('Finished');\n\nconst Status = {\n Pending,\n Ongoing,\n Finished,\n} as const;\n\nassertType<typeof Pending>(Status.Pending);\n\ntype StatusType = ValueOf<typeof Status>;\ntype _ = Assert<Equal<\n StatusType,\n typeof Pending | typeof Ongoing | typeof Finished\n>>;\n\n```", "```ts\nconst Status = {\n Pending: Symbol('Pending'),\n Ongoing: Symbol('Ongoing'),\n Finished: Symbol('Finished'),\n} as const;\n\n// Alas, the type of Status.Pending is not `typeof Pending`\nassertType<symbol>(Status.Pending);\n\n// The derived type is `symbol`, not a union type\ntype StatusType = ValueOf<typeof Status>;\ntype _ = Assert<Equal<\n StatusType,\n symbol\n>>;\n\n```", "```ts\n// This type is optional: It constrains the property values\n// of `TextStyle` but has no other use.\ntype TextStyleProp = {\n key: string,\n html: string,\n latex: string,\n};\nconst TextStyle = {\n Bold: {\n key: 'Bold',\n html: 'b',\n latex: 'textbf',\n },\n Italics: {\n key: 'Italics',\n html: 'i',\n latex: 'textit',\n },\n} as const satisfies Record<string, TextStyleProp>;\n\ntype TextStyleType = ValueOf<typeof TextStyle>;\ntype ValueOf<Obj> = Obj[keyof Obj];\n\n```", "```ts\nfunction describeTextStyle(textStyle: TextStyleType): string {\n switch (textStyle.key) {\n case TextStyle.Bold.key:\n return 'Bold text';\n case TextStyle.Italics.key:\n return 'Text in italics';\n default:\n throw new UnexpectedValueError(textStyle); // No `.key`!\n }\n}\n\n```", "```ts\nclass TextStyle {\n static Bold = new TextStyle({\n html: 'b',\n latex: 'textbf',\n });\n static Italics = new TextStyle({\n html: 'i',\n latex: 'textit',\n });\n html: string;\n latex: string;\n constructor(props: TextStyleProps) {\n this.html = props.html;\n this.latex = props.latex;\n }\n wrapHtml(html: string): string {\n return `<${this.html}>${html}</${this.html}>`;\n }\n}\ntype TextStyleProps = {\n html: string,\n latex: string,\n};\nassert.equal(\n TextStyle.Bold.wrapHtml('Hello!'),\n '<b>Hello!</b>'\n);\n\n```", "```ts\ntype TextStyleKeys = EnumKeys<typeof TextStyle>;\ntype _1 = Assert<Equal<\n TextStyleKeys, 'Bold' | 'Italics'\n>>;\n\ntype EnumKeys<T> = Exclude<keyof T, 'prototype'>;\n\n// Why exclude 'prototype'?\ntype _2 = Assert<Equal<\n keyof typeof TextStyle,\n 'prototype' | 'Bold' | 'Italics'\n>>;\n\n```", "```ts\nassert.deepEqual(\n // TextStyle.prototype is non-enumerable\n Object.keys(TextStyle),\n ['Bold', 'Italics']\n);\n\n```", "```ts\ntype Activation = 'Active' | 'Inactive';\n\n```", "```ts\nconst activation = new Set([\n 'Active',\n 'Inactive',\n] as const);\nassertType<Set<'Active' | 'Inactive'>>(activation);\n\n// @ts-expect-error: Argument of type '\"abc\"' is not assignable to\n// parameter of type '\"Active\" | \"Inactive\"'.\nactivation.has('abc');\n // Auto-completion works for arguments of .has(), .delete() etc.\n\n// Let’s turn the Set into a string literal union\ntype Activation = SetElementType<typeof activation>;\ntype _ = Assert<Equal<\n Activation, 'Active' | 'Inactive'\n>>;\n\ntype SetElementType<S extends Set<any>> =\n S extends Set<infer Elem> ? Elem : never;\n\n```", "```ts\nconst activation = [\n 'Active',\n 'Inactive',\n] as const;\ntype Activation = (typeof activation)[number];\ntype _ = Assert<Equal<\n Activation,\n 'Active' | 'Inactive'\n>>;\n\n```", "```ts\nconst Pending = Symbol('Pending');\nconst Ongoing = Symbol('Ongoing');\nconst Finished = Symbol('Finished');\nconst Status = {\n Pending,\n Ongoing,\n Finished,\n} as const;\ntype StatusType = ValueOf<typeof Status>;\n\n```", "```ts\nconst statusPairs = [\n [Status.Pending, 'not yet'],\n [Status.Ongoing, 'working on it'],\n [Status.Finished, 'finished'],\n] as const;\n\ntype StatusMapKey = (typeof statusPairs)[number][0];\nconst statusMap = new Map<StatusMapKey, string>(statusPairs);\nassertType<\n Map<\n typeof Pending | typeof Ongoing | typeof Finished,\n string\n >\n>(statusMap);\n\n```", "```ts\nconst statusMap2 = new Map([ // no type parameters!\n ['Pending', 'not yet'],\n ['Ongoing', 'working on it'],\n ['Finished', 'finished'],\n] as const);\nassertType<\n Map<\n 'Pending' | 'Ongoing' | 'Finished',\n 'not yet' | 'working on it' | 'finished'\n >\n>(statusMap2);\n\n```", "```ts\ntype _ = Assert<Equal<\n MapKey<typeof statusMap>, StatusType // (A)\n>>;\ntype MapKey<M extends Map<any, any>> =\n M extends Map<infer K, any> ? K : never;\n\n```", "```ts\nRecord<UnionType, T>\n\n```", "```ts\ntype Status = 'Pending' | 'Ongoing' | 'Finished';\nconst statusMap = {\n 'Pending': 'not yet',\n 'Ongoing': 'working on it',\n // @ts-expect-error: Type '{ Pending: string; Ongoing: string; }' does\n // not satisfy the expected type 'Record<Status, string>'. Property\n // 'Finished' is missing in type '{ Pending: string; Ongoing: string; }'\n // but required in type 'Record<Status, string>'.\n} satisfies Record<Status, string>;\n\n```", "```ts\nconst Pending = Symbol('Pending');\nconst Ongoing = Symbol('Ongoing');\nconst Finished = Symbol('Finished');\nconst Status = {\n Pending,\n Ongoing,\n Finished,\n} as const;\n\n```", "```ts\nfunction parseEnumKey<\n E extends Record<string, unknown>\n>(enumObject: E, enumKey: string): E[keyof E] {\n if (!Object.hasOwn(enumObject, enumKey)) {\n throw new TypeError('Unknown key: ' + {}.toString.call(enumKey));\n }\n return enumObject[enumKey] as any;\n}\nassert.equal(\n parseEnumKey(Status, 'Ongoing'),\n Status.Ongoing\n);\n\n```", "```ts\nfunction stringifyEnumValue<\n E extends object,\n V extends E[keyof E]\n>(enumObject: E, enumValue: V): keyof E {\n for (const [key, value] of Object.entries(enumObject)) {\n if (enumValue === value) {\n return key as any;\n }\n }\n throw new TypeError('Unknown value: ' + {}.toString.call(enumValue));\n}\nassert.equal(\n stringifyEnumValue(Status, Status.Ongoing),\n 'Ongoing'\n);\n\n```", "```ts\nconst Permission = {\n Read:    1 << 2, // bit 2\n Write:   1 << 1, // bit 1\n Execute: 1 << 0, // bit 0\n}\nfunction setPermission(filePath: string, permission: number): void {\n // ···\n}\nsetPermission(\n 'read-and-write.txt',\n Permission.Read | Permission.Write\n);\n\n```", "```ts\nconst Read = Symbol('Read');\nconst Write = Symbol('Write');\nconst Execute = Symbol('Execute');\nconst Permission = {\n Read, Write, Execute\n} as const;\ntype PermissionType = (typeof Permission)[keyof typeof Permission];\n\nfunction setPermission(filePath: string, permission: Set<PermissionType>): void {\n // ···\n}\nsetPermission(\n 'read-and-write.txt',\n new Set([Permission.Read, Permission.Write])\n);\n\n```", "```ts\nimport { z } from 'zod';\n\nconst ActivationSchema = z.enum(['Active', 'Inactive']);\n\n// Derive a type from the schema\ntype Activation = z.infer<typeof ActivationSchema>;\ntype _ = Assert<Equal<\n Activation,\n 'Active' | 'Inactive'\n>>;\n\n// Use the schema to “parse” data at runtime\n// (check that it has the correct type)\nconst activation = ActivationSchema.parse('Inactive');\nassertType<Activation>(activation);\nassert.throws(\n () => ActivationSchema.parse('HELLO')\n);\n\n```"]