["```ts\nfunction repeat1(str: string, times: number): string { // (A)\n return str.repeat(times);\n}\nassert.equal(\n repeat1('*', 5), '*****');\n```", "```ts\nconst repeat2 = (str: string, times: number): string => {\n return str.repeat(times);\n};\n```", "```ts\nconst repeat3 = (str: string, times: number): string =>\n str.repeat(times);\n```", "```ts\ntype Repeat = (str: string, times: number) => string;\n```", "```ts\ninterface Repeat {\n (str: string, times: number): string; // (A)\n}\n```", "```ts\ninterface Incrementor1 {\n (x: number): number;\n increment: number;\n}\n```", "```ts\ntype Incrementor2 =\n (x: number) => number\n & { increment: number }\n;\n```", "```ts\ntype StringPredicate = (str: string) => boolean;\n```", "```ts\nconst pred1: StringPredicate = (str) => str.length > 0;\n```", "```ts\nfunction pred2(str: string): boolean {\n return str.length > 0;\n}\n\n// Assign the function to a type-annotated variable\nconst pred2ImplementsStringPredicate: StringPredicate = pred2;\n```", "```ts\nfunction pred3(...[str]: Parameters<StringPredicate>)\n : ReturnType<StringPredicate> {\n return str.length > 0;\n }\n```", "```ts\nfunction twice(str: string) {\n return str + str;\n}\n```", "```ts\ntype StringMapFunction = (str: string) => string;\nconst twice: StringMapFunction = (str) => str + str; // (A)\n```", "```ts\nassert.deepEqual(\n ['a', 'b', 'c'].map((str) => str + str),\n ['aa', 'bb', 'cc']);\n```", "```ts\ninterface Array<T> {\n map<U>(\n callbackfn: (value: T, index: number, array: T[]) => U,\n thisArg?: any\n ): U[];\n // \u00b7\u00b7\u00b7\n}\n```", "```ts\nfunction trim1(str?: string): string {\n // Internal type of str:\n // %inferred-type: string | undefined\n str;\n\n if (str === undefined) {\n return '';\n }\n return str.trim();\n}\n\n// External type of trim1:\n// %inferred-type: (str?: string | undefined) => string\ntrim1;\n```", "```ts\nassert.equal(\n trim1('\\n abc \\t'), 'abc');\n\nassert.equal(\n trim1(), '');\n\n// `undefined` is equivalent to omitting the parameter\nassert.equal(\n trim1(undefined), '');\n```", "```ts\nfunction trim2(str: undefined|string): string {\n // Internal type of str:\n // %inferred-type: string | undefined\n str;\n\n if (str === undefined) {\n return '';\n }\n return str.trim();\n}\n\n// External type of trim2:\n// %inferred-type: (str: string | undefined) => string\ntrim2;\n```", "```ts\nassert.equal(\n trim2('\\n abc \\t'), 'abc');\n\n// @ts-expect-error: Expected 1 arguments, but got 0\\. (2554)\ntrim2(); // (A)\n\nassert.equal(\n trim2(undefined), ''); // OK!\n```", "```ts\nfunction trim3(str = ''): string {\n // Internal type of str:\n // %inferred-type: string\n str;\n\n return str.trim();\n}\n\n// External type of trim2:\n// %inferred-type: (str?: string) => string\ntrim3;\n```", "```ts\nassert.equal(\n trim3('\\n abc \\t'), 'abc');\n\n// Omitting the parameter triggers the parameter default value:\nassert.equal(\n trim3(), '');\n\n// `undefined` is allowed and triggers the parameter default value:\nassert.equal(\n trim3(undefined), '');\n```", "```ts\nfunction trim4(str: string = ''): string {\n return str.trim();\n}\n```", "```ts\nfunction join(separator: string, ...parts: string[]) {\n return parts.join(separator);\n}\nassert.equal(\n join('-', 'state', 'of', 'the', 'art'),\n 'state-of-the-art');\n```", "```ts\nfunction repeat1(...[str, times]: [string, number]): string {\n return str.repeat(times);\n}\n```", "```ts\nfunction repeat2(str: string, times: number): string {\n return str.repeat(times);\n}\n```", "```ts\nassert.equal(\n padStart({str: '7', len: 3, fillStr: '0'}),\n '007');\n```", "```ts\nfunction padStart({ str, len, fillStr = ' ' } // (A)\n : { str: string, len: number, fillStr: string }) { // (B)\n return str.padStart(len, fillStr);\n}\n```", "```ts\ninterface EventSource {\n addEventListener(\n type: string,\n listener: (this: EventSource, ev: Event) => any,\n options?: boolean | AddEventListenerOptions\n ): void;\n // \u00b7\u00b7\u00b7\n}\n```", "```ts\nfunction toIsoString(this: Date): string {\n return this.toISOString();\n}\n\n// @ts-expect-error: Argument of type '\"abc\"' is not assignable to\n// parameter of type 'Date'. (2345)\nassert.throws(() => toIsoString.call('abc')); // (A) error\n\ntoIsoString.call(new Date()); // (B) OK\n```", "```ts\nconst obj = { toIsoString };\n// @ts-expect-error: The 'this' context of type\n// '{ toIsoString: (this: Date) => string; }' is not assignable to\n// method's 'this' of type 'Date'. [...]\nassert.throws(() => obj.toIsoString()); // error\nobj.toIsoString.call(new Date()); // OK\n```", "```ts\ninterface Customer {\n id: string;\n fullName: string;\n}\nconst jane = {id: '1234', fullName: 'Jane Bond'};\nconst lars = {id: '5678', fullName: 'Lars Croft'};\nconst idToCustomer = new Map<string, Customer>([\n ['1234', jane],\n ['5678', lars],\n]);\n\nassert.equal(\n getFullName(idToCustomer, '1234'), 'Jane Bond'); // (A)\n\nassert.equal(\n getFullName(lars), 'Lars Croft'); // (B)\n```", "```ts\nfunction getFullName(\n customerOrMap: Customer | Map<string, Customer>,\n id?: string\n): string {\n if (customerOrMap instanceof Map) {\n if (id === undefined) throw new Error();\n const customer = customerOrMap.get(id);\n if (customer === undefined) {\n throw new Error('Unknown ID: ' + id);\n }\n customerOrMap = customer;\n } else {\n if (id !== undefined) throw new Error();\n }\n return customerOrMap.fullName;\n}\n```", "```ts\nassert.throws(() => getFullName(idToCustomer)); // missing ID\nassert.throws(() => getFullName(lars, '5678')); // ID not allowed\n```", "```ts\nfunction getFullName(customerOrMap: Customer): string; // (A)\nfunction getFullName( // (B)\n customerOrMap: Map<string, Customer>, id: string): string;\nfunction getFullName( // (C)\n customerOrMap: Customer | Map<string, Customer>,\n id?: string\n): string {\n // \u00b7\u00b7\u00b7\n}\n\n// @ts-expect-error: Argument of type 'Map<string, Customer>' is not\n// assignable to parameter of type 'Customer'. [...]\ngetFullName(idToCustomer); // missing ID\n\n// @ts-expect-error: Argument of type '{ id: string; fullName: string; }'\n// is not assignable to parameter of type 'Map<string, Customer>'.\n// [...]\ngetFullName(lars, '5678'); // ID not allowed\n```", "```ts\ninterface GetFullName {\n (customerOrMap: Customer): string;\n (customerOrMap: Map<string, Customer>, id: string): string;\n}\n\nconst getFullName: GetFullName = (\n customerOrMap: Customer | Map<string, Customer>,\n id?: string\n): string => {\n if (customerOrMap instanceof Map) {\n if (id === undefined) throw new Error();\n const customer = customerOrMap.get(id);\n if (customer === undefined) {\n throw new Error('Unknown ID: ' + id);\n }\n customerOrMap = customer;\n } else {\n if (id !== undefined) throw new Error();\n }\n return customerOrMap.fullName;\n}\n```", "```ts\nfunction addEventListener(elem: HTMLElement, type: 'click',\n listener: (event: MouseEvent) => void): void;\nfunction addEventListener(elem: HTMLElement, type: 'keypress',\n listener: (event: KeyboardEvent) => void): void;\nfunction addEventListener(elem: HTMLElement, type: string,  // (A)\n listener: (event: any) => void): void {\n elem.addEventListener(type, listener); // (B)\n }\n```", "```ts\nclass StringBuilder {\n #data = '';\n\n add(num: number): this;\n add(bool: boolean): this;\n add(str: string): this;\n add(value: any): this {\n this.#data += String(value);\n return this;\n }\n\n toString() {\n return this.#data;\n }\n}\n\nconst sb = new StringBuilder();\nsb\n .add('I can see ')\n .add(3)\n .add(' monkeys!')\n;\nassert.equal(\n sb.toString(), 'I can see 3 monkeys!')\n```", "```ts\ninterface ArrayConstructor {\n from<T>(arrayLike: ArrayLike<T>): T[];\n from<T, U>(\n arrayLike: ArrayLike<T>,\n mapfn: (v: T, k: number) => U,\n thisArg?: any\n ): U[];\n}\n```", "```ts\nconst targetFunc: Trg = sourceFunc;\n```", "```ts\nconst trg1: (x: RegExp) => Object = (x: Object) => /abc/;\n```", "```ts\nconst trg2: () => void = () => new Date();\n```", "```ts\n// @ts-expect-error: Type '(x: string) => string' is not assignable to\n// type '() => string'. (2322)\nconst trg3: () => string = (x: string) => 'abc';\n```", "```ts\nconst trg4: (x: string) => string = () => 'abc';\n```", "```ts\n['a', 'b'].map(x => x + x)\n```", "```ts\nmap<U>(\n callback: (value: T, index: number, array: T[]) => U,\n thisArg?: any\n): U[];\n```"]