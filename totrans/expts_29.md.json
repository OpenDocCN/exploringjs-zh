["```ts\n// Each Array element has the type `string`:\nconst myStringArray: string[] = ['fee', 'fi', 'fo', 'fum'];\n\n```", "```ts\nconst myStringArray: Array<string> = ['fee', 'fi', 'fo', 'fum'];\n\n```", "```ts\n(number|string)[]\n(() => boolean)[]\n\n```", "```ts\nArray<number|string>\nArray<() => boolean>\n\n```", "```ts\nconst yes: [string, string, boolean] = ['oui', 's√≠', true];\n\n```", "```ts\ninterface StringArray {\n [index: number]: string;\n}\nconst strArr: StringArray = ['Huey', 'Dewey', 'Louie'];\n\n```", "```ts\ninterface FirstNamesAndLastName {\n [index: number]: string;\n lastName: string;\n}\n\nconst ducks: FirstNamesAndLastName = {\n 0: 'Huey',\n 1: 'Dewey',\n 2: 'Louie',\n lastName: 'Duck',\n};\n\n```", "```ts\nconst fields: Fields = [\n ['first', 'string', true],\n ['last', 'string', true],\n ['age', 'number', false],\n];\n\n```", "```ts\ntype Fields = Array<[string, string, boolean]>;\n\n```", "```ts\ntype Fields = Array<[string, ('string'|'number'), boolean]>;\n\n```", "```ts\ntype Fields = Array<Array<string|boolean>>;\n\n```", "```ts\ntype Fields = [\n [string, string, boolean],\n [string, string, boolean],\n [string, string, boolean],\n];\n\n```", "```ts\ntype Fields = [\n [string, 'string', boolean],\n [string, 'string', boolean],\n [string, 'number', boolean],\n];\n\n```", "```ts\ntype Fields = [\n Array<string|boolean>,\n Array<string|boolean>,\n Array<string|boolean>,\n];\n\n```", "```ts\nconst arr = [123, 'abc'];\nassertType<(string | number)[]>(arr);\n\n```", "```ts\nfunction func(p: readonly [number, number]) { // (A)\n return p;\n}\nconst pair1 = [1, 2];\nassertType<number[]>(pair1);\n\n// @ts-expect-error: Argument of type 'number[]' is not assignable to\n// parameter of type 'readonly [number, number]'. [...]\nfunc(pair1); // (B)\n\n```", "```ts\nconst pair2: [number, number] = [1, 2];\nfunc(pair2); // OK\n\n```", "```ts\nconst pair3 = [1, 2] as const;\nfunc(pair3); // OK\n\n```", "```ts\n// @ts-expect-error: Variable 'arr' implicitly has type 'any[]' in some\n// locations where its type cannot be determined.\nconst arr = []; // (A)\n// @ts-expect-error: Variable 'arr' implicitly has an 'any[]' type.\nassertType<any[]>(arr); // (B)\n\narr.push(123);\nassertType<number[]>(arr);\n\narr.push('abc');\nassertType<(string | number)[]>(arr);\n\n```", "```ts\n// @ts-expect-error: Variable 'arr' implicitly has type 'any[]' in some\n// locations where its type cannot be determined.\nconst arr = [];\n// @ts-expect-error: Variable 'arr' implicitly has an 'any[]' type.\nassertType<any[]>(arr);\n\narr[0] = 123;\nassertType<number[]>(arr);\n\narr[1] = 'abc';\nassertType<(string | number)[]>(arr);\n\n```", "```ts\nconst arr = [123];\nassertType<number[]>(arr);\n\n// @ts-expect-error: Argument of type 'string' is not assignable to\n// parameter of type 'number'.\narr.push('abc');\n\n```", "```ts\nconst rockCategories =\n ['igneous', 'metamorphic', 'sedimentary'] as const;\nassertType<\n readonly ['igneous', 'metamorphic', 'sedimentary']\n>(rockCategories);\n\n```", "```ts\n    // @ts-expect-error: Property 'push' does not exist on type\n    // 'readonly [\"igneous\", \"metamorphic\", \"sedimentary\"]'.\n    rockCategories.push('sand');\n\n    ```", "```ts\n    const rockCategories2 = ['igneous', 'metamorphic', 'sedimentary'];\n    assertType<string[]>(rockCategories2);\n\n    ```", "```ts\nconst numbers1 = [1, 2, 3, 4] as const;\nassertType<readonly [1, 2, 3, 4]>(numbers1);\nconst numbers2 = [1, 2, 3, 4];\nassertType<number[]>(numbers2);\n\nconst booleanAndString1 = [true, 'abc'] as const;\nassertType<readonly [true, 'abc']>(booleanAndString1);\nconst booleanAndString2 = [true, 'abc'];\nassertType<(string | boolean)[]>(booleanAndString2);\n\n```", "```ts\nfunction argIsArray(arg: Array<string>) {}\nfunction argIsReadonlyArray(arg: ReadonlyArray<string>) {}\nfunction argIsTuple(arg: [string, string]) {}\nfunction argIsReadonlyTuple(arg: readonly [string, string]) {}\n\nconst constTuple = ['a', 'b'] as const;\n// @ts-expect-error: Argument of type 'readonly [\"a\", \"b\"]' is not\n// assignable to parameter of type '[string, string]'. The type 'readonly\n// [\"a\", \"b\"]' is 'readonly' and cannot be assigned to the mutable type\n// '[string, string]'.\nargIsTuple(constTuple);\nargIsReadonlyTuple(constTuple);\n// @ts-expect-error: Argument of type 'readonly [\"a\", \"b\"]' is not\n// assignable to parameter of type 'string[]'. The type 'readonly\n// [\"a\", \"b\"]' is 'readonly' and cannot be assigned to the mutable type\n// 'string[]'.\nargIsArray(constTuple);\nargIsReadonlyArray(constTuple);\n\n```", "```ts\nconst mutableTuple: [string, string] = ['a', 'b'];\nargIsTuple(mutableTuple);\nargIsReadonlyTuple(mutableTuple);\nargIsArray(mutableTuple);\nargIsReadonlyArray(mutableTuple);\n\n```", "```ts\nlet arr = [1, 2] as const;\n\narr = [1, 2]; // OK\n\n// @ts-expect-error: Type '3' is not assignable to type '2'.\narr = [1, 3];\n\n```", "```ts\nfunction f(arr: Array<string>): void {\n if (arr.length > 0) { // (A)\n const elem = arr[0];\n assertType<string | undefined>(elem);\n }\n}\n\n```", "```ts\nfunction f(arr: Array<string>): void {\n if (0 in arr) {\n const elem = arr[0];\n assertType<string>(elem);\n }\n}\n\n```", "```ts\nfunction f(arr: Array<string>): void {\n const elem = arr[0];\n if (elem !== undefined) {\n assertType<string>(elem);\n }\n}\n\n```", "```ts\n    // Not possible in .tsx files:\n    const value1 = <DesiredType>valueWithWrongType;\n\n    // Can be used everywhere:\n    const value2 = valueWithWrongType as DesiredType;\n\n    ```", "```ts\n// Array of tuples\ntype AT1 = Array<[string, number]>;\ntype AT2 = [string, number][];\n\n// Array of union elements\ntype AU1 = Array<number | string>;\ntype AU2 = (number | string)[];\n\n// Inferring type variables\ntype ExtractElem1<A> = A extends Array<infer Elem> ? Elem : never;\ntype ExtractElem2<A> = A extends (infer Elem)[] ? Elem : never;\n\n// Readonly types\ntype RO1 = ReadonlyArray<unknown>;\ntype RO2 = readonly unknown[];\n // `readonly` applies to `[]` not to `unknown`!\n\n```", "```ts\n    const strArr = new Array<string>();\n\n    ```", "```ts\ntype ArrayOfStringOrNumber = (string | number)[]; // (A)\n\nconst Activation = {\n Active: 'Active',\n Inactive: 'Inactive',\n} as const;\ntype ActivationKeys = (keyof typeof Activation)[]; // (B)\n // (\"Active\" | \"Inactive\")[]\n\n```"]