["```js\nconst arr = ['a', 'b', 'c'];\nconst x = arr[0]; // extract\nconst y = arr[1]; // extract\n\n```", "```js\nconst arr = ['a', 'b', 'c'];\nconst [x, y] = arr; // (A)\nassert.equal(x, 'a');\nassert.equal(y, 'b');\n\n```", "```js\n// Constructing: one property at a time\nconst jane1 = {};\njane1.first = 'Jane';\njane1.last = 'Doe';\n\n// Constructing: multiple properties\nconst jane2 = {\n  first: 'Jane',\n  last: 'Doe',\n};\n\nassert.deepEqual(jane1, jane2);\n\n```", "```js\nconst jane = {\n  first: 'Jane',\n  last: 'Doe',\n};\n\n// Extracting: one property at a time\nconst f1 = jane.first;\nconst l1 = jane.last;\nassert.equal(f1, 'Jane');\nassert.equal(l1, 'Doe');\n\n// Extracting: multiple properties (NEW!)\nconst {first: f2, last: l2} = jane; // (A)\nassert.equal(f2, 'Jane');\nassert.equal(l2, 'Doe');\n\n```", "```js\n{first: f2, last: l2}\n\n```", "```js\n    const [a] = ['x'];\n    assert.equal(a, 'x');\n\n    let [b] = ['y'];\n    assert.equal(b, 'y');\n\n    ```", "```js\n    let b;\n    [b] = ['z'];\n    assert.equal(b, 'z');\n\n    ```", "```js\n    const f = ([x]) => x;\n    assert.equal(f(['a']), 'a');\n\n    ```", "```js\nconst arr = ['a', 'b'];\nfor (const [index, element] of arr.entries()) {\n    console.log(index, element);\n}\n\n```", "```js\n0 a\n1 b\n\n```", "```js\nconst address = {\n  street: 'Evergreen Terrace',\n  number: '742',\n  city: 'Springfield',\n  state: 'NT',\n  zip: '49007',\n};\n\nconst { street: s, city: c } = address;\nassert.equal(s, 'Evergreen Terrace');\nassert.equal(c, 'Springfield');\n\n```", "```js\nconst {length: len} = 'abc';\nassert.equal(len, 3);\n\n```", "```js\nconst {0:x, 2:y} = ['a', 'b', 'c'];\nassert.equal(x, 'a');\nassert.equal(y, 'c');\n\n```", "```js\nconst { street, city } = address;\nassert.equal(street, 'Evergreen Terrace');\nassert.equal(city, 'Springfield');\n\n```", "```js\nconst obj = { a: 1, b: 2, c: 3 };\nconst { a: propValue, ...remaining } = obj; // (A)\n\nassert.equal(propValue, 1);\nassert.deepEqual(remaining, {b:2, c:3});\n\n```", "```js\nlet prop;\nassert.throws(\n  () => eval(\"{prop} = { prop: 'hello' };\"),\n  {\n    name: 'SyntaxError',\n    message: \"Unexpected token '='\",\n  });\n\n```", "```js\nlet prop;\n({prop} = { prop: 'hello' });\nassert.equal(prop, 'hello');\n\n```", "```js\nconst [x, y] = ['a', 'b'];\nassert.equal(x, 'a');\nassert.equal(y, 'b');\n\n```", "```js\nconst [, x, y] = ['a', 'b', 'c']; // (A)\nassert.equal(x, 'b');\nassert.equal(y, 'c');\n\n```", "```js\n{ // Sets are iterable\n  const [a, b] = new Set().add('fee').add('fi').add('fo');\n  assert.equal(a, 'fee');\n  assert.equal(b, 'fi');\n}\n\n{ // Maps are iterable\n  const [a, b] = new Map().set('one', 1).set('two', 2);\n  assert.deepEqual(\n    a, ['one',1]\n  );\n  assert.deepEqual(\n    b, ['two',2]\n  );\n}\n\n{ // Strings are iterable\n  const [a, b] = 'hello';\n  assert.equal(a, 'h');\n  assert.equal(b, 'e');\n}\n\n```", "```js\nconst [x, y, ...remaining] = ['a', 'b', 'c', 'd']; // (A)\n\nassert.equal(x, 'a');\nassert.equal(y, 'b');\nassert.deepEqual(remaining, ['c', 'd']);\n\n```", "```js\nlet x = 'a';\nlet y = 'b';\n\n[x,y] = [y,x]; // swap\n\nassert.equal(x, 'b');\nassert.equal(y, 'a');\n\n```", "```js\n// Skip the element at index 0 (the whole match):\nconst [, year, month, day] =\n  /^([0-9]{4})-([0-9]{2})-([0-9]{2})$/\n  .exec('2999-12-31');\n\nassert.equal(year, '2999');\nassert.equal(month, '12');\nassert.equal(day, '31');\n\n```", "```js\nfindElement(array, (value, index) => «boolean expression»)\n\n```", "```js\nfunction findElement(arr, predicate) {\n  for (let index=0; index < arr.length; index++) {\n    const value = arr[index];\n    if (predicate(value)) {\n      // We found something:\n      return { value, index };\n    }\n  }\n  // We didn’t find anything:\n  return { value: undefined, index: -1 };\n}\n\n```", "```js\nconst arr = [7, 8, 6];\n\nconst {value, index} = findElement(arr, x => x % 2 === 0);\nassert.equal(value, 8);\nassert.equal(index, 1);\n\n```", "```js\nconst {index, value} = findElement(arr, x => x % 2 === 0);\n\n```", "```js\nconst arr = [7, 8, 6];\n\nconst {value} = findElement(arr, x => x % 2 === 0);\nassert.equal(value, 8);\n\nconst {index} = findElement(arr, x => x % 2 === 0);\nassert.equal(index, 1);\n\n```", "```js\nconst {prop: p} = {};\nassert.equal(p, undefined);\n\n```", "```js\nconst [x] = [];\nassert.equal(x, undefined);\n\n```", "```js\n> const {prop} = undefined\nTypeError: Cannot destructure property 'prop' of 'undefined'\nas it is undefined.\n\n> const {prop} = null\nTypeError: Cannot destructure property 'prop' of 'null'\nas it is null.\n\n```", "```js\nfunction throwIfUndefinedOrNull(value) {\n  const {} = value;\n}\nassert.throws(\n  () => throwIfUndefinedOrNull(undefined),\n  TypeError\n);\nthrowIfUndefinedOrNull(123); // OK\n\n```", "```js\n> const [x] = 123\nTypeError: 123 is not iterable\n> const [y] = {}\nTypeError: {} is not iterable\n\n```", "```js\nfunction throwIfNotIterable(value) {\n  const [] = value;\n}\nassert.throws(\n  () => throwIfNotIterable(null),\n  TypeError\n);\nassert.throws(\n  () => throwIfNotIterable(true),\n  TypeError\n);\nthrowIfNotIterable('abc'); // OK: iterable primitive\nthrowIfNotIterable([]); // OK: iterable object\n\n```", "```js\nconst {prop: p} = {};\nassert.equal(p, undefined);\n\n```", "```js\nconst {prop: p = 123} = {}; // (A)\nassert.equal(p, 123);\n\n```", "```js\nconst [x=1, y=2] = [];\n\nassert.equal(x, 1);\nassert.equal(y, 2);\n\n```", "```js\nconst {first: f='', last: l=''} = {};\nassert.equal(f, '');\nassert.equal(l, '');\n\n```", "```js\nconst {first='', last=''} = {};\nassert.equal(first, '');\nassert.equal(last, '');\n\n```", "```js\nfunction f1(«pattern1», «pattern2») {\n  // ···\n}\n\nfunction f2(...args) {\n  const [«pattern1», «pattern2»] = args;\n  // ···\n}\n\n```", "```js\nconst arr = [\n  { first: 'Jane', last: 'Bond' },\n  { first: 'Lars', last: 'Croft' },\n];\nconst [, {first}] = arr; // (A)\nassert.equal(first, 'Lars');\n\n```"]