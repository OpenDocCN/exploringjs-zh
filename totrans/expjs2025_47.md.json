["```js\nconst arr = ['a', 'b', 'c'];\nconst x = arr[0]; // extract\nconst y = arr[1]; // extract\n\n```", "```js\nconst arr = ['a', 'b', 'c'];\nconst [x, y] = arr; // (A)\nassert.equal(x, 'a');\nassert.equal(y, 'b');\n\n```", "```js\n// Constructing: one property at a time\nconst jane1 = {};\njane1.first = 'Jane';\njane1.last = 'Doe';\n `// Constructing: multiple properties`\n`const jane2 = {`\n `first: 'Jane',`\n `last: 'Doe',`\n`};`\n `` `assert.deepEqual(jane1, jane2);` `` \n```", "```js```", "````js````", "```js```", "```js```", "````js````", "```js```", "```js const jane = {  first: 'Jane',  last: 'Doe', };  `// Extracting: one property at a time` `const f1 = jane.first;` `const l1 = jane.last;` `assert.equal(f1, 'Jane');` `assert.equal(l1, 'Doe');`  `` `// Extracting: multiple properties (NEW!)` `const {first: f2, last: l2} = jane; // (A)` `assert.equal(f2, 'Jane');` `assert.equal(l2, 'Doe');` ``  ```", "```js```", "````js````", "```js```", "``````js``````", "`````` The operation in line A is new: we declare two variables `f2` and `l2` and initialize them via *destructuring* (multivalue extraction).    The following part of line A is a *destructuring pattern*:    ```js {first: f2, last: l2}  ```    Destructuring patterns are syntactically similar to the literals that are used for multivalue construction. But they appear where data is received (e.g., at the left-hand sides of assignments), not where data is created (e.g., at the right-hand sides of assignments).    ### [40.3 Where can we destructure?](#destructuring-locations)    Destructuring patterns can be used at “data sink locations” such as:    *   Variable declarations:                    ```js     const [a] = ['x'];     assert.equal(a, 'x');      `let [b] = ['y'];`     `assert.equal(b, 'y');`      ```           ```js` *   Assignments:                    ```     let b;     [b] = ['z'];     assert.equal(b, 'z');          ```js          *   Parameter definitions:                    ```     const f = ([x]) => x;     assert.equal(f(['a']), 'a');          ```js ````    ```js``````", "```````js` Note that variable declarations include `const` and `let` declarations in `for-of` loops:    ``` const arr = ['a', 'b']; for (const [index, element] of arr.entries()) {  console.log(index, element); }  ```js    Output:    ``` 0 a 1 b  ```js    In the next two sections, we’ll look deeper into the two kinds of destructuring: object-destructuring and Array-destructuring.    ### [40.4 Object-destructuring](#object-destructuring)    *Object-destructuring* lets us batch-extract values of properties via patterns that look like object literals:    ``` const address = {  street: 'Evergreen Terrace',  number: '742',  city: 'Springfield',  state: 'NT',  zip: '49007', };  `const { street: s, city: c } = address;` `assert.equal(s, 'Evergreen Terrace');` `assert.equal(c, 'Springfield');`  ```js   ``````js```````", "```` We can think of the pattern as a transparent sheet that we place over the data: the pattern key `'street'` has a match in the data. Therefore, the data value `'Evergreen Terrace'` is assigned to the pattern variable `s`.    We can also object-destructure primitive values:    ```js const {length: len} = 'abc'; assert.equal(len, 3);  ```    And we can object-destructure Arrays:    ```js const {0:x, 2:y} = ['a', 'b', 'c']; assert.equal(x, 'a'); assert.equal(y, 'c');  ```    Why does that work? [Array indices are also properties](ch_arrays.html#array-indices).    #### [40.4.1 Property value shorthands](#property-value-shorthands)    Object literals support property value shorthands and so do object patterns:    ```js const { street, city } = address; assert.equal(street, 'Evergreen Terrace'); assert.equal(city, 'Springfield');  ```    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Object-destructuring**    `exercises/destructuring/object_destructuring_exrc.mjs`    #### [40.4.2 Rest properties](#rest-properties)    In object literals, we can have spread properties. In object patterns, we can have rest properties (which must come last):    ```js const obj = { a: 1, b: 2, c: 3 }; const { a: propValue, ...remaining } = obj; // (A)  `assert.equal(propValue, 1);` `assert.deepEqual(remaining, {b:2, c:3});`  ```   ```js````", "```js```", "``` A rest property variable, such as `remaining` (line A), is assigned an object with all data properties whose keys are not mentioned in the pattern.    `remaining` can also be viewed as the result of non-destructively removing property `a` from `obj`.    #### [40.4.3 Syntax pitfall: assigning via object destructuring](#assigning-via-object-destructuring)    If we object-destructure in an assignment, we are facing a pitfall caused by [syntactic ambiguity](ch_syntax.html#ambiguous-syntax) – we can’t start a statement with a curly brace because then JavaScript thinks we are starting a block:    ```", "```    ![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **Why `eval()`?**    [`eval()`](ch_dynamic-code-evaluation.html#eval) delays parsing (and therefore the `SyntaxError`) until the callback of `assert.throws()` is executed. If we didn’t use it, we’d already get an error when this code is parsed and `assert.throws()` wouldn’t even be executed.    The workaround is to put the whole assignment in parentheses:    ```", "```    ### [40.5 Array-destructuring](#array-destructuring)    *Array-destructuring* lets us batch-extract values of Array elements via patterns that look like Array literals:    ```", "```    We can skip elements by putting holes in Array patterns:    ```", "```    The Array pattern in line A starts with a hole, which is why the Array element at index 0 is ignored.    #### [40.5.1 Array-destructuring works with any iterable](#arraydestructuring-works-with-any-iterable)    Array-destructuring can be applied to any value that is iterable, not just to Arrays:    ```", "```   ```", "```````js````` ```js```````", "```` #### [40.5.2 Rest elements](#rest-elements)    In Array literals, we can have spread elements. In Array patterns, we can have rest elements (which must come last):    ```js const [x, y, ...remaining] = ['a', 'b', 'c', 'd']; // (A)  `assert.equal(x, 'a');` `assert.equal(y, 'b');` `assert.deepEqual(remaining, ['c', 'd']);`  ```   ```js````", "```js```", "``` let x = 'a'; let y = 'b';  `[x,y] = [y,x]; // swap`  `` `assert.equal(x, 'b');` `assert.equal(y, 'a');` ``  ```", "``````js``````", "```js```", "````js` #### [40.6.2 Array-destructuring: operations that return Arrays](#arraydestructuring-operations-that-return-arrays)    Array-destructuring is useful when operations return Arrays, as does, for example, the regular expression method `.exec()`:    ``` // Skip the element at index 0 (the whole match): const [, year, month, day] =  /^([0-9]{4})-([0-9]{2})-([0-9]{2})$/  .exec('2999-12-31');  `assert.equal(year, '2999');` `assert.equal(month, '12');` `assert.equal(day, '31');`  ```js   ````", "```` #### [40.6.3 Object-destructuring: multiple return values](#objectdestructuring-multiple-return-values)    Destructuring is very useful if a function returns multiple values – either packaged as an Array or packaged as an object.    Consider a function `findElement()` that finds elements in an Array:    ```js findElement(array, (value, index) => «boolean expression»)  ```    Its second parameter is a function that receives the value and index of an element and returns a boolean indicating if this is the element the caller is looking for.    We are now faced with a dilemma: Should `findElement()` return the value of the element it found or the index? One solution would be to create two separate functions, but that would result in duplicated code because both functions would be very similar.    The following implementation avoids duplication by returning an object that contains both index and value of the element that is found:    ```js function findElement(arr, predicate) {  for (let index=0; index < arr.length; index++) {  const value = arr[index];  if (predicate(value)) {  // We found something:  return { value, index };  }  }  // We didn’t find anything:  return { value: undefined, index: -1 }; }  ```    Destructuring helps us with processing the result of `findElement()`:    ```js const arr = [7, 8, 6];  `const {value, index} = findElement(arr, x => x % 2 === 0);` `assert.equal(value, 8);` `assert.equal(index, 1);`  ```   ```js````", "```js const {index, value} = findElement(arr, x => x % 2 === 0);  ```", "```js const arr = [7, 8, 6];  `const {value} = findElement(arr, x => x % 2 === 0);` `assert.equal(value, 8);`  `` `const {index} = findElement(arr, x => x % 2 === 0);` `assert.equal(index, 1);` ``  ```", "```js```", "```js```", "```js const {prop: p} = {}; assert.equal(p, undefined);  ```", "```js const [x] = []; assert.equal(x, undefined);  ```", "```js > const {prop} = undefined TypeError: Cannot destructure property 'prop' of 'undefined' as it is undefined.  `> const {prop} = null` `TypeError: Cannot destructure property 'prop' of 'null'` `as it is null.`  ```", "```js```", "``` function throwIfUndefinedOrNull(value) {  const {} = value; } assert.throws(  () => throwIfUndefinedOrNull(undefined),  TypeError ); throwIfUndefinedOrNull(123); // OK  ```", "``` > const [x] = 123 TypeError: 123 is not iterable > const [y] = {} TypeError: {} is not iterable  ```", "``` function throwIfNotIterable(value) {  const [] = value; } assert.throws(  () => throwIfNotIterable(null),  TypeError ); assert.throws(  () => throwIfNotIterable(true),  TypeError ); throwIfNotIterable('abc'); // OK: iterable primitive throwIfNotIterable([]); // OK: iterable object  ```", "``` const {prop: p} = {}; assert.equal(p, undefined);  ```", "``` const {prop: p = 123} = {}; // (A) assert.equal(p, 123);  ```", "``` const [x=1, y=2] = [];  `assert.equal(x, 1);` `assert.equal(y, 2);`  ```", "````` The default value for the first element of the Array pattern is `1`; the default value for the second element is `2`.    #### [40.10.2 Default values in object-destructuring](#default-values-in-objectdestructuring)    We can also specify default values for object-destructuring:    ```js const {first: f='', last: l=''} = {}; assert.equal(f, ''); assert.equal(l, '');  ```    Neither property key `first` nor property key `last` exist in the object that is destructured. Therefore, the default values are used.    With property value shorthands, this code becomes simpler:    ```js const {first='', last=''} = {}; assert.equal(first, ''); assert.equal(last, '');  ```    ### [40.11 Parameter definitions are similar to destructuring](#parameter-definitions-are-similar-to-destructuring)    Considering what we have learned in this chapter, parameter definitions have much in common with an Array pattern (rest elements, default values, etc.). In fact, the following two function declarations are equivalent:    ```js function f1(«pattern1», «pattern2») {  // ··· }  `function f2(...args) {`  `const [«pattern1», «pattern2»] = args;`  `// ···` `}`  ```   ```js`### [40.12 Nested destructuring](#nested-destructuring)    Until now, we have only used variables as *assignment targets* (data sinks) inside destructuring patterns. But we can also use patterns as assignment targets, which enables us to nest patterns to arbitrary depths:    ``` const arr = [  { first: 'Jane', last: 'Bond' },  { first: 'Lars', last: 'Croft' }, ]; const [, {first}] = arr; // (A) assert.equal(first, 'Lars');  ```js    Inside the Array pattern in line A, there is a nested object pattern at index 1.    Nested patterns can become difficult to understand, so they are best used in moderation.```` ```js`` `````", "``````js` ``````", "``````js``` ``````", "```` ```js````", "```js` ```", "```js```", "``` ```", "```````js``` ``````js```````", "``````js``````", "``````js``````", "``` ```", "```js```", "````js````", "```js```", "````js````", "```js` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "``````js``````", "```````js` ``````js```````", "`````````"]