["```js\nconst copyOfObject = {...originalObject};\nconst copyOfArray = [...originalArray];\n```", "```js\nclass MyClass {}\n\nconst original = new MyClass();\nassert.equal(original instanceof MyClass, true);\n\nconst copy = {...original};\nassert.equal(copy instanceof MyClass, false);\n```", "```js\nobj instanceof SomeClass\nSomeClass.prototype.isPrototypeOf(obj)\n```", "```js\nclass MyClass {}\n\nconst original = new MyClass();\n\nconst copy = {\n __proto__: Object.getPrototypeOf(original),\n ...original,\n};\nassert.equal(copy instanceof MyClass, true);\n```", "```js\nconst proto = { inheritedProp: 'a' };\nconst original = {__proto__: proto, ownProp: 'b' };\nassert.equal(original.inheritedProp, 'a');\nassert.equal(original.ownProp, 'b');\n\nconst copy = {...original};\nassert.equal(copy.inheritedProp, undefined);\nassert.equal(copy.ownProp, 'b');\n```", "```js\nconst arr = ['a', 'b'];\nassert.equal(arr.length, 2);\nassert.equal({}.hasOwnProperty.call(arr, 'length'), true);\n\nconst copy = {...arr}; // (A)\nassert.equal({}.hasOwnProperty.call(copy, 'length'), false);\n```", "```js\nconst original = Object.defineProperties(\n {}, {\n prop: {\n value: 1,\n writable: false,\n configurable: false,\n enumerable: true,\n },\n });\nassert.deepEqual(original, {prop: 1});\n```", "```js\nconst copy = {...original};\n// Attributes `writable` and `configurable` of copy are different:\nassert.deepEqual(\n Object.getOwnPropertyDescriptors(copy),\n {\n prop: {\n value: 1,\n writable: true,\n configurable: true,\n enumerable: true,\n },\n });\n```", "```js\nconst original = {\n get myGetter() { return 123 },\n set mySetter(x) {},\n};\nassert.deepEqual({...original}, {\n myGetter: 123, // not a getter anymore!\n mySetter: undefined,\n});\n```", "```js\nconst original = {name: 'Jane', work: {employer: 'Acme'}};\nconst copy = {...original};\n\n// Property .name is a copy: changing the copy\n// does not affect the original\ncopy.name = 'John';\nassert.deepEqual(original,\n {name: 'Jane', work: {employer: 'Acme'}});\nassert.deepEqual(copy,\n {name: 'John', work: {employer: 'Acme'}});\n\n// The value of .work is shared: changing the copy\n// affects the original\ncopy.work.employer = 'Spectre';\nassert.deepEqual(\n original, {name: 'Jane', work: {employer: 'Spectre'}});\nassert.deepEqual(\n copy, {name: 'John', work: {employer: 'Spectre'}});\n```", "```js\nconst copy1 = {...original};\nconst copy2 = Object.assign({}, original);\n```", "```js\nconst original = {['__proto__']: null}; // (A)\nconst copy1 = {...original};\n// copy1 has the own property '__proto__'\nassert.deepEqual(\n Object.keys(copy1), ['__proto__']);\n\nconst copy2 = Object.assign({}, original);\n// copy2 has the prototype null\nassert.equal(Object.getPrototypeOf(copy2), null);\n```", "```js\nfunction copyAllOwnProperties(original) {\n return Object.defineProperties(\n {}, Object.getOwnPropertyDescriptors(original));\n}\n```", "```js\nconst original = {\n get myGetter() { return 123 },\n set mySetter(x) {},\n};\nassert.deepEqual(copyAllOwnProperties(original), original);\n```", "```js\nconst arr = ['a', 'b'];\nassert.equal(arr.length, 2);\nassert.equal({}.hasOwnProperty.call(arr, 'length'), true);\n\nconst copy = copyAllOwnProperties(arr);\nassert.equal({}.hasOwnProperty.call(copy, 'length'), true);\n```", "```js\nconst original = {name: 'Jane', work: {employer: 'Acme'}};\nconst copy = {name: original.name, work: {...original.work}};\n\n// We copied successfully:\nassert.deepEqual(original, copy);\n// The copy is deep:\nassert.ok(original.work !== copy.work);\n```", "```js\nfunction jsonDeepCopy(original) {\n return JSON.parse(JSON.stringify(original));\n}\nconst original = {name: 'Jane', work: {employer: 'Acme'}};\nconst copy = jsonDeepCopy(original);\nassert.deepEqual(original, copy);\n```", "```js\nassert.deepEqual(\n jsonDeepCopy({\n // Symbols are not supported as keys\n [Symbol('a')]: 'abc',\n // Unsupported value\n b: function () {},\n // Unsupported value\n c: undefined,\n }),\n {} // empty object\n);\n```", "```js\nassert.throws(\n () => jsonDeepCopy({a: 123n}),\n /^TypeError: Do not know how to serialize a BigInt$/);\n```", "```js\nfunction deepCopy(original) {\n if (Array.isArray(original)) {\n const copy = [];\n for (const [index, value] of original.entries()) {\n copy[index] = deepCopy(value);\n }\n return copy;\n } else if (typeof original === 'object' && original !== null) {\n const copy = {};\n for (const [key, value] of Object.entries(original)) {\n copy[key] = deepCopy(value);\n }\n return copy;\n } else {\n // Primitive value: atomic, no need to copy\n return original;\n }\n}\n```", "```js\nconst original = {a: 1, b: {c: 2, d: {e: 3}}};\nconst copy = deepCopy(original);\n\n// Are copy and original deeply equal?\nassert.deepEqual(copy, original);\n\n// Did we really copy all levels\n// (equal content, but different objects)?\nassert.ok(copy     !== original);\nassert.ok(copy.b   !== original.b);\nassert.ok(copy.b.d !== original.b.d);\n```", "```js\nfunction deepCopy(original) {\n if (Array.isArray(original)) {\n return original.map(elem => deepCopy(elem));\n } else if (typeof original === 'object' && original !== null) {\n return Object.fromEntries(\n Object.entries(original)\n .map(([k, v]) => [k, deepCopy(v)]));\n } else {\n // Primitive value: atomic, no need to copy\n return original;\n }\n}\n```"]