- en: 9 Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_syntax.html](https://exploringjs.com/js/book/ch_syntax.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[9.1 An overview of JavaScript’s syntax](#an-overview-of-javascripts-syntax)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.1.1 Basic constructs](#basic-constructs)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.1.2 Modules](#modules)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.1.3 Classes](#classes-1)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.1.4 Exception handling](#exception-handling)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.1.5 Legal variable and property names](#legal-variable-and-property-names)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.1.6 Casing styles](#casing-styles)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.1.7 Capitalization of names](#capitalization-of-names)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.1.8 More naming conventions](#more-naming-conventions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.1.9 Where to put semicolons?](#where-to-put-semicolons)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.2 (Advanced)](#advanced)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.3 Hashbang lines (Unix shell scripts)](#hashbang-lines)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.4 Identifiers](#identifiers)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.4.1 Valid identifiers (variable names, etc.)](#valid-identifiers-variable-names-etc)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.4.2 Reserved words](#reserved-words)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.5 Statement vs. expression](#statement-vs-expression)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.5.1 Statements](#statements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.5.2 Expressions](#expressions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.5.3 What is allowed where?](#what-is-allowed-where)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.6 Ambiguous syntax](#ambiguous-syntax)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.6.1 Same syntax: function declaration and function expression](#same-syntax-function-declaration-and-function-expression)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.6.2 Same syntax: object literal and block](#same-syntax-object-literal-and-block)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.6.3 Disambiguation](#disambiguation)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.7 Semicolons](#semicolons)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.7.1 Rule of thumb for semicolons](#rule-of-thumb-for-semicolons)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.7.2 Semicolons: control statements](#semicolons-control-statements)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.8 Automatic semicolon insertion (ASI)](#automatic-semicolon-insertion-asi)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.8.1 ASI triggered unexpectedly](#asi-triggered-unexpectedly)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.8.2 ASI unexpectedly not triggered](#asi-unexpectedly-not-triggered)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.9 Semicolons: best practices](#semicolons-best-practices)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.10 Strict mode vs. sloppy mode](#strict-mode)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.10.1 Switching on strict mode](#switching-on-strict-mode)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.10.2 Improvements in strict mode](#improvements-in-strict-mode)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[9.1 An overview of JavaScript’s syntax](#an-overview-of-javascripts-syntax)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a very first look at JavaScript’s syntax. Don’t worry if some things
    don’t make sense, yet. They will all be explained in more detail later in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: This overview is not exhaustive, either. It focuses on the essentials.
  prefs: []
  type: TYPE_NORMAL
- en: '[9.1.1 Basic constructs](#basic-constructs)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[9.1.1.1 Comments](#comments)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[9.1.1.2 *Primitive* (atomic) values](#primitive-atomic-values)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Booleans:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Numbers:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The basic number type is used for both floating point numbers (doubles) and
    integers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bigints:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The basic number type can only properly represent integers within a range of
    53 bits plus sign. Bigints can grow arbitrarily large in size.
  prefs: []
  type: TYPE_NORMAL
- en: '**Strings:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript has no extra type for characters. It uses strings to represent them.
  prefs: []
  type: TYPE_NORMAL
- en: '[9.1.1.3 Assertions](#assertions)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An *assertion* describes what the result of a computation is expected to look
    like and throws an exception if those expectations aren’t correct. For example,
    the following assertion states that the result of the computation 7 plus 1 must
    be 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`assert.equal()` is a method call (the object is `assert`, the method is `.equal()`)
    with two arguments: the actual result and the expected result. It is part of a
    Node.js assertion API that is explained [later in this book](ch_assertion-api.html#ch_assertion-api).'
  prefs: []
  type: TYPE_NORMAL
- en: There is also `assert.deepEqual()` that compares objects deeply.
  prefs: []
  type: TYPE_NORMAL
- en: '[9.1.1.4 Logging to the console](#logging-to-the-console)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Logging to [the console](ch_console.html#browser-consoles) of a browser or
    Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[9.1.1.5 Operators](#operators)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript also has a `==` comparison operator. I recommend to avoid it – why
    is explained in [“Recommendation: always use strict equality” (§15.5.3)](ch_operators.html#recommendation-always-strict-equality).'
  prefs: []
  type: TYPE_NORMAL
- en: '[9.1.1.6 Declaring variables](#declaring-variables)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`const` creates *immutable variable bindings*: Each variable must be initialized
    immediately and we can’t assign a different value later. However, the value itself
    may be mutable and we may be able to change its contents. In other words: `const`
    does not make values immutable.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`let` creates *mutable variable bindings*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[9.1.1.7 Ordinary function declarations](#ordinary-function-declarations)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[9.1.1.8 Arrow function expressions](#arrow-function-expressions)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Arrow function expressions are used especially as arguments of function calls
    and method calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code contains the following two arrow functions (the terms *expression*
    and *statement* are explained [later in this chapter](#statement-vs-expression)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[9.1.1.9 Plain objects](#plain-objects)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[9.1.1.10 Arrays](#arrays)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[9.1.1.11 Control flow statements](#control-flow-statements)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Conditional statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`for-of` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[9.1.2 Modules](#modules)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Each module is a single file. Consider, for example, the following two files
    with modules in them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The module in `file-tools.mjs` exports its function `isTextFilePath()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The module in `main.mjs` imports the whole module `path` and the function `isTextFilePath()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[9.1.3 Classes](#classes-1)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[9.1.4 Exception handling](#exception-handling)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note:'
  prefs: []
  type: TYPE_NORMAL
- en: '`try-finally` and `try-catch-finally` are also supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can throw any value, but features such as stack traces are only supported
    by `Error` and its subclasses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[9.1.5 Legal variable and property names](#legal-variable-and-property-names)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The grammatical category of variable names and property names is called *identifier*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Identifiers are allowed to have the following characters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unicode letters: `A`–`Z`, `a`–`z` (etc.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$`, `_`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unicode digits: `0`–`9` (etc.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable names can’t start with a digit
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some words have special meaning in JavaScript and are called *reserved*. Examples
    include: `if`, `true`, `const`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reserved words can’t be used as variable names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'But they are allowed as names of properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[9.1.6 Casing styles](#casing-styles)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Common casing styles for concatenating words are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Camel case: `threeConcatenatedWords`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Underscore case (also called *snake case*): `three_concatenated_words`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dash case (also called *kebab case*): `three-concatenated-words`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[9.1.7 Capitalization of names](#capitalization-of-names)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In general, JavaScript uses camel case, except for constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions, variables: `myFunction`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods: `obj.myMethod`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CSS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CSS names: `my-utility-class` (dash case)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Corresponding JavaScript names: `myUtilityClass`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Module file names are usually dash-cased:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes: `MyClass`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All-caps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constants (as shared between modules etc.): `MY_CONSTANT` (underscore case)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[9.1.8 More naming conventions](#more-naming-conventions)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following naming conventions are popular in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the name of a parameter starts with an underscore (or is an underscore)
    it means that this parameter is not used – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If the name of a property of an object starts with an underscore then that
    property is considered private:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[9.1.9 Where to put semicolons?](#where-to-put-semicolons)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At the end of a statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'But not if that statement ends with a curly brace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'However, adding a semicolon after such a statement is not a syntax error –
    it is interpreted as an empty statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[9.2 (Advanced)](#advanced)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All remaining sections of this chapter are advanced.
  prefs: []
  type: TYPE_NORMAL
- en: '[9.3 Hashbang lines (Unix shell scripts)](#hashbang-lines)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a Unix shell script, we can add a first line that starts with `#!` to tell
    Unix which executable should be used to run the script. These two characters have
    several names, including *hashbang*, *sharp-exclamation*, *sha-bang* (“sha” as
    in “sharp”) and *shebang*. Otherwise, hashbang lines are treated as comments by
    most shell scripting languages and JavaScript does so, too. This is a common hashbang
    line for Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to pass arguments to `node`, we have to use the `env` option `-S`
    (to be safe, some Unixes don’t need it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[9.4 Identifiers](#identifiers)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[9.4.1 Valid identifiers (variable names, etc.)](#valid-identifiers-variable-names-etc)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First character:'
  prefs: []
  type: TYPE_NORMAL
- en: Unicode letter (including accented characters such as `é` and `ü` and characters
    from non-latin alphabets, such as `α`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subsequent characters:'
  prefs: []
  type: TYPE_NORMAL
- en: Legal first characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unicode digits (including Eastern Arabic numerals)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some other Unicode marks and punctuations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[9.4.2 Reserved words](#reserved-words)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Reserved words can’t be variable names, but they can be property names.
  prefs: []
  type: TYPE_NORMAL
- en: 'All JavaScript *keywords* are reserved words:'
  prefs: []
  type: TYPE_NORMAL
- en: '`await` `break` `case` `catch` `class` `const` `continue` `debugger` `default`
    `delete` `do` `else` `export` `extends` `finally` `for` `function` `if` `import`
    `in` `instanceof` `let` `new` `return` `static` `super` `switch` `this` `throw`
    `try` `typeof` `var` `void` `while` `with` `yield`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following tokens are also keywords, but currently not used in the language:'
  prefs: []
  type: TYPE_NORMAL
- en: '`enum` `implements` `package` `protected` `interface` `private` `public`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following literals are reserved words:'
  prefs: []
  type: TYPE_NORMAL
- en: '`true` `false` `null`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Technically, these words are not reserved, but you should avoid them, too,
    because they effectively are keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Infinity` `NaN` `undefined` `async`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You shouldn’t use the names of global variables (`String`, `Math`, etc.) for
    your own variables and parameters, either.
  prefs: []
  type: TYPE_NORMAL
- en: '[9.5 Statement vs. expression](#statement-vs-expression)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we explore how JavaScript distinguishes two kinds of syntactic
    constructs: *statements* and *expressions*. Afterward, we’ll see that that can
    cause problems because the same syntax can mean different things, depending on
    where it is used.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **We pretend
    there are only statements and expressions**'
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, we pretend that there are only statements and expressions
    in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '[9.5.1 Statements](#statements)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *statement* is a piece of code that can be executed and performs some kind
    of action. For example, `if` is a statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'One more example of a statement: a function declaration.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[9.5.2 Expressions](#expressions)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An *expression* is a piece of code that can be *evaluated* to produce a value.
    For example, the code between the parentheses is an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The operator `_?_:_` used between the parentheses is called the *ternary operator*.
    It is the expression version of the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at more examples of expressions. We enter expressions and the REPL
    evaluates them for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[9.5.3 What is allowed where?](#what-is-allowed-where)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The current location within JavaScript source code determines which kind of
    syntactic constructs you are allowed to use:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of a function must be a sequence of statements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The arguments of a function call or a method call must be expressions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, expressions can be used as statements. Then they are called *expression
    statements*. The opposite is not true: when the context requires an expression,
    you can’t use a statement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates that any expression `bar()` can be either expression
    or statement – it depends on the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[9.6 Ambiguous syntax](#ambiguous-syntax)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript has several programming constructs that are syntactically ambiguous:
    the same syntax is interpreted differently, depending on whether it is used in
    statement context or in expression context. This section explores the phenomenon
    and the pitfalls it causes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[9.6.1 Same syntax: function declaration and function expression](#same-syntax-function-declaration-and-function-expression)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *function declaration* is a statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'A *function expression* is an expression (right-hand side of `=`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[9.6.2 Same syntax: object literal and block](#same-syntax-object-literal-and-block)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the following code, `{}` is an *object literal*: an expression that creates
    an empty object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an empty code block (a statement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[9.6.3 Disambiguation](#disambiguation)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The ambiguities are only a problem in statement context: If the JavaScript
    parser encounters ambiguous syntax, it doesn’t know if it’s a plain statement
    or an expression statement. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a statement starts with `function`: Is it a function declaration or a function
    expression?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If a statement starts with `{`: Is it an object literal or a code block?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To resolve the ambiguity, statements starting with `function` or `{` are never
    interpreted as expressions. If you want an expression statement to start with
    either one of these tokens, you must wrap it in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first create a function via a function expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we invoke that function: `(''abc'')`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code fragment shown in (1) is only interpreted as an expression because
    we wrap it in parentheses. If we didn’t, we would get a syntax error because then
    JavaScript expects a function declaration and complains about the missing function
    name. Additionally, you can’t put a function call immediately after a function
    declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later in this book, we’ll see more examples of pitfalls caused by syntactic
    ambiguity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Assigning via object destructuring](ch_destructuring.html#assigning-via-object-destructuring)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Returning an object literal from an arrow function](ch_callables.html#returning-object-literal-from-arrow-function)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[9.7 Semicolons](#semicolons)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[9.7.1 Rule of thumb for semicolons](#rule-of-thumb-for-semicolons)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Each statement is terminated by a semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'except statements ending with blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following case is slightly tricky:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The whole `const` declaration (a statement) ends with a semicolon, but inside
    it, there is an arrow function expression. That is, it’s not the statement per
    se that ends with a curly brace; it’s the embedded arrow function expression.
    That’s why there is a semicolon at the end.
  prefs: []
  type: TYPE_NORMAL
- en: '[9.7.2 Semicolons: control statements](#semicolons-control-statements)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The body of a control statement is itself a statement. For example, this is
    the syntax of the `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The body can be a single statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'But blocks are also statements and therefore legal bodies of control statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want a loop to have an empty body, your first option is an empty statement
    (which is just a semicolon):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Your second option is an empty block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[9.8 Automatic semicolon insertion (ASI)](#automatic-semicolon-insertion-asi)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While I recommend to always write semicolons, most of them are optional in JavaScript.
    The mechanism that makes this possible is called *automatic semicolon insertion*
    (ASI). In a way, it corrects syntax errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASI works as follows. Parsing of a statement continues until there is either:'
  prefs: []
  type: TYPE_NORMAL
- en: A semicolon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line terminator followed by an illegal token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, ASI can be seen as inserting semicolons at line breaks. The
    next subsections cover the pitfalls of ASI.
  prefs: []
  type: TYPE_NORMAL
- en: '[9.8.1 ASI triggered unexpectedly](#asi-triggered-unexpectedly)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The good news about ASI is that – if you don’t rely on it and always write semicolons
    – there is only one pitfall that you need to be aware of. It is that JavaScript
    forbids line breaks after some tokens. If you do insert a line break, a semicolon
    will be inserted, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The token where this is most practically relevant is `return`. Consider, for
    example, the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is parsed as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'That is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return statement without operand: `return;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start of code block: `{`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expression statement `'jane';` with [label](ch_control-flow.html#labels) `first:`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'End of code block: `}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Empty statement: `;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why does JavaScript do this? It protects against accidentally returning a value
    in a line after a `return`.
  prefs: []
  type: TYPE_NORMAL
- en: '[9.8.2 ASI unexpectedly not triggered](#asi-unexpectedly-not-triggered)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In some cases, ASI is *not* triggered when you think it should be. That makes
    life more complicated for people who don’t like semicolons because they need to
    be aware of those cases. The following are three examples. There are more.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 1:** Unintended function call.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Parsed as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '**Example 2:** Unintended division.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Parsed as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '**Example 3:** Unintended property access.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Executed as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[9.9 Semicolons: best practices](#semicolons-best-practices)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I recommend that you always write semicolons:'
  prefs: []
  type: TYPE_NORMAL
- en: I like the visual structure it gives code – you clearly see where a statement
    ends.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are fewer rules to keep in mind.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The majority of JavaScript programmers use semicolons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, there are also many people who don’t like the added visual clutter
    of semicolons. If you are one of them: Code without them *is* legal. I recommend
    that you use tools to help you avoid mistakes. The following are two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The automatic code formatter [Prettier](https://prettier.io) can be configured
    to not use semicolons. It then automatically fixes problems. For example, if it
    encounters a line that starts with a square bracket, it prefixes that line with
    a semicolon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The static checker [ESLint](https://eslint.org) has [a rule](https://eslint.org/docs/rules/semi)
    that you tell your preferred style (always semicolons or as few semicolons as
    possible) and that warns you about critical issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[9.10 Strict mode vs. sloppy mode](#strict-mode)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Starting with ECMAScript 5, JavaScript has two *modes* in which JavaScript
    can be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: Normal “sloppy” mode is the default in scripts (code fragments that are a precursor
    to modules and supported by browsers).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strict mode is the default in modules and classes, and can be switched on in
    scripts (how is explained later). In this mode, several pitfalls of normal mode
    are removed and more exceptions are thrown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll rarely encounter sloppy mode in modern JavaScript code, which is almost
    always located in modules. In this book, I assume that strict mode is always switched
    on.
  prefs: []
  type: TYPE_NORMAL
- en: '[9.10.1 Switching on strict mode](#switching-on-strict-mode)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In script files and CommonJS modules, you switch on strict mode for a complete
    file, by putting the following code in the first line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The neat thing about this “directive” is that ECMAScript versions before 5
    simply ignore it: it’s an expression statement that does nothing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also switch on strict mode for just a single function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[9.10.2 Improvements in strict mode](#improvements-in-strict-mode)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s look at three things that strict mode does better than sloppy mode. Just
    in this one section, all code fragments are executed in sloppy mode.
  prefs: []
  type: TYPE_NORMAL
- en: '[9.10.2.1 Sloppy mode pitfall: changing an undeclared variable creates a global
    variable](#sloppy-mode-pitfall-changing-an-undeclared-variable-creates-a-global-variable)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In non-strict mode, changing an undeclared variable creates a global variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Strict mode does it better and throws a `ReferenceError`. That makes it easier
    to detect typos.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The `assert.throws()` states that its first argument, a function, throws a `ReferenceError`
    when it is called.
  prefs: []
  type: TYPE_NORMAL
- en: '[9.10.2.2 Function declarations are block-scoped in strict mode, function-scoped
    in sloppy mode](#function-declarations-are-blockscoped-in-strict-mode-functionscoped-in-sloppy-mode)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In strict mode, a variable created via a function declaration only exists within
    the innermost enclosing block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In sloppy mode, function declarations are function-scoped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[9.10.2.3 Sloppy mode doesn’t throw exceptions when changing immutable data](#sloppy-mode-doesnt-throw-exceptions-when-changing-immutable-data)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In strict mode, you get an exception if you try to change immutable data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In sloppy mode, the assignment fails silently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “external”](../Images/38e6ff55e8d602659f3cdb8893e63f62.png) **Further
    reading: sloppy mode**'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on how sloppy mode differs from strict mode, see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).
  prefs: []
  type: TYPE_NORMAL
