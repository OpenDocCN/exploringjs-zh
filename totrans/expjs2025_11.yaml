- en: 9 Syntax
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 语法
- en: 原文：[https://exploringjs.com/js/book/ch_syntax.html](https://exploringjs.com/js/book/ch_syntax.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://exploringjs.com/js/book/ch_syntax.html](https://exploringjs.com/js/book/ch_syntax.html)'
- en: '[9.1 An overview of JavaScript’s syntax](#an-overview-of-javascripts-syntax)'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.1 JavaScript语法的概述](#an-overview-of-javascripts-syntax)'
- en: '[9.1.1 Basic constructs](#basic-constructs)'
  id: totrans-3
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.1.1 基本结构](#basic-constructs)'
- en: '[9.1.2 Modules](#modules)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.1.2 模块](#modules)'
- en: '[9.1.3 Classes](#classes-1)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.1.3 类](#classes-1)'
- en: '[9.1.4 Exception handling](#exception-handling)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.1.4 异常处理](#exception-handling)'
- en: '[9.1.5 Legal variable and property names](#legal-variable-and-property-names)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.1.5 合法的变量和属性名](#legal-variable-and-property-names)'
- en: '[9.1.6 Casing styles](#casing-styles)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.1.6 命名风格](#casing-styles)'
- en: '[9.1.7 Capitalization of names](#capitalization-of-names)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.1.7 名称的大小写](#capitalization-of-names)'
- en: '[9.1.8 More naming conventions](#more-naming-conventions)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.1.8 更多的命名约定](#more-naming-conventions)'
- en: '[9.1.9 Where to put semicolons?](#where-to-put-semicolons)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.1.9 分号应该放在哪里？](#where-to-put-semicolons)'
- en: '[9.2 (Advanced)](#advanced)'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.2 （高级）](#advanced)'
- en: '[9.3 Hashbang lines (Unix shell scripts)](#hashbang-lines)'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.3 哈希行（Unix shell脚本）](#hashbang-lines)'
- en: '[9.4 Identifiers](#identifiers)'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.4 标识符](#identifiers)'
- en: '[9.4.1 Valid identifiers (variable names, etc.)](#valid-identifiers-variable-names-etc)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.4.1 有效的标识符（变量名等）](#valid-identifiers-variable-names-etc)'
- en: '[9.4.2 Reserved words](#reserved-words)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.4.2 保留字](#reserved-words)'
- en: '[9.5 Statement vs. expression](#statement-vs-expression)'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.5 语句与表达式](#statement-vs-expression)'
- en: '[9.5.1 Statements](#statements)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.5.1 语句](#statements)'
- en: '[9.5.2 Expressions](#expressions)'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.5.2 表达式](#expressions)'
- en: '[9.5.3 What is allowed where?](#what-is-allowed-where)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.5.3 在哪里允许什么？](#what-is-allowed-where)'
- en: '[9.6 Ambiguous syntax](#ambiguous-syntax)'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.6 模糊语法](#ambiguous-syntax)'
- en: '[9.6.1 Same syntax: function declaration and function expression](#same-syntax-function-declaration-and-function-expression)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.6.1 相同的语法：函数声明和函数表达式](#same-syntax-function-declaration-and-function-expression)'
- en: '[9.6.2 Same syntax: object literal and block](#same-syntax-object-literal-and-block)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.6.2 相同的语法：对象字面量和代码块](#same-syntax-object-literal-and-block)'
- en: '[9.6.3 Disambiguation](#disambiguation)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.6.3 消除歧义](#disambiguation)'
- en: '[9.7 Semicolons](#semicolons)'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.7 分号](#semicolons)'
- en: '[9.7.1 Rule of thumb for semicolons](#rule-of-thumb-for-semicolons)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.7.1 分号规则](#rule-of-thumb-for-semicolons)'
- en: '[9.7.2 Semicolons: control statements](#semicolons-control-statements)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.7.2 分号：控制语句](#semicolons-control-statements)'
- en: '[9.8 Automatic semicolon insertion (ASI)](#automatic-semicolon-insertion-asi)'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.8 自动分号插入（ASI）](#automatic-semicolon-insertion-asi)'
- en: '[9.8.1 ASI triggered unexpectedly](#asi-triggered-unexpectedly)'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.8.1 自动分号插入意外触发](#asi-triggered-unexpectedly)'
- en: '[9.8.2 ASI unexpectedly not triggered](#asi-unexpectedly-not-triggered)'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.8.2 自动分号插入（ASI）意外未触发](#asi-unexpectedly-not-triggered)'
- en: '[9.9 Semicolons: best practices](#semicolons-best-practices)'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.9 分号：最佳实践](#semicolons-best-practices)'
- en: '[9.10 Strict mode vs. sloppy mode](#strict-mode)'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.10 严格模式与宽松模式](#strict-mode)'
- en: '[9.10.1 Switching on strict mode](#switching-on-strict-mode)'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.10.1 开启严格模式](#switching-on-strict-mode)'
- en: '[9.10.2 Improvements in strict mode](#improvements-in-strict-mode)'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9.10.2 严格模式中的改进](#improvements-in-strict-mode)'
- en: '[9.1 An overview of JavaScript’s syntax](#an-overview-of-javascripts-syntax)'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[9.1 JavaScript语法的概述](#an-overview-of-javascripts-syntax)'
- en: This is a very first look at JavaScript’s syntax. Don’t worry if some things
    don’t make sense, yet. They will all be explained in more detail later in this
    book.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是JavaScript语法的第一次全面了解。如果有些东西现在还不明白，不用担心。它们将在本书的后面部分详细解释。
- en: This overview is not exhaustive, either. It focuses on the essentials.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概述也不是详尽的。它专注于基本内容。
- en: '[9.1.1 Basic constructs](#basic-constructs)'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[9.1.1 基本结构](#basic-constructs)'
- en: '[9.1.1.1 Comments](#comments)'
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[9.1.1.1 注释](#comments)'
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[9.1.1.2 *Primitive* (atomic) values](#primitive-atomic-values)'
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[9.1.1.2 *原始*（原子）值](#primitive-atomic-values)'
- en: '**Booleans:**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**布尔值：**'
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Numbers:**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**数字：**'
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The basic number type is used for both floating point numbers (doubles) and
    integers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 基本数字类型用于浮点数（双精度）和整数。
- en: '**Bigints:**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**大整数：**'
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The basic number type can only properly represent integers within a range of
    53 bits plus sign. Bigints can grow arbitrarily large in size.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 基本数字类型只能正确表示53位加符号范围内的整数。大整数可以任意增长大小。
- en: '**Strings:**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符串：**'
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: JavaScript has no extra type for characters. It uses strings to represent them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript没有额外的字符类型。它使用字符串来表示它们。
- en: '[9.1.1.3 Assertions](#assertions)'
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[9.1.1.3 断言](#assertions)'
- en: 'An *assertion* describes what the result of a computation is expected to look
    like and throws an exception if those expectations aren’t correct. For example,
    the following assertion states that the result of the computation 7 plus 1 must
    be 8:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*断言*描述了计算结果预期应该是什么样子，如果那些期望不正确，则会抛出异常。例如，以下断言指出，计算7加1的结果必须是8：'
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`assert.equal()` is a method call (the object is `assert`, the method is `.equal()`)
    with two arguments: the actual result and the expected result. It is part of a
    Node.js assertion API that is explained [later in this book](ch_assertion-api.html#ch_assertion-api).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert.equal()`是一个方法调用（对象是`assert`，方法是`.equal()`），带有两个参数：实际结果和预期结果。它是Node.js断言API的一部分，该API将在本书[后面解释](ch_assertion-api.html#ch_assertion-api)。'
- en: There is also `assert.deepEqual()` that compares objects deeply.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`assert.deepEqual()`，它可以深度比较对象。
- en: '[9.1.1.4 Logging to the console](#logging-to-the-console)'
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[9.1.1.4 记录到控制台](#logging-to-the-console)'
- en: 'Logging to [the console](ch_console.html#browser-consoles) of a browser or
    Node.js:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将日志记录到浏览器的[控制台](ch_console.html#browser-consoles)或Node.js：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[9.1.1.5 Operators](#operators)'
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[9.1.1.5 运算符](#operators)'
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'JavaScript also has a `==` comparison operator. I recommend to avoid it – why
    is explained in [“Recommendation: always use strict equality” (§15.5.3)](ch_operators.html#recommendation-always-strict-equality).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript还有一个`==`比较运算符。我建议避免使用它——原因在[“建议：始终使用严格相等”（§15.5.3）](ch_operators.html#recommendation-always-strict-equality)中解释。
- en: '[9.1.1.6 Declaring variables](#declaring-variables)'
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[9.1.1.6 声明变量](#declaring-variables)'
- en: '`const` creates *immutable variable bindings*: Each variable must be initialized
    immediately and we can’t assign a different value later. However, the value itself
    may be mutable and we may be able to change its contents. In other words: `const`
    does not make values immutable.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`创建*不可变变量绑定*：每个变量必须立即初始化，以后不能分配不同的值。然而，值本身可能是可变的，我们可能能够更改其内容。换句话说：`const`并不使值不可变。'
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`let` creates *mutable variable bindings*:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`创建*可变变量绑定*：'
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[9.1.1.7 Ordinary function declarations](#ordinary-function-declarations)'
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[9.1.1.7 普通函数声明](#ordinary-function-declarations)'
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[9.1.1.8 Arrow function expressions](#arrow-function-expressions)'
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[9.1.1.8 箭头函数表达式](#arrow-function-expressions)'
- en: 'Arrow function expressions are used especially as arguments of function calls
    and method calls:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数表达式特别用于函数调用和方法调用的参数：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The previous code contains the following two arrow functions (the terms *expression*
    and *statement* are explained [later in this chapter](#statement-vs-expression)):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码包含以下两个箭头函数（术语*表达式*和*语句*将在本章[后面解释](#statement-vs-expression)）：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[9.1.1.9 Plain objects](#plain-objects)'
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[9.1.1.9 普通对象](#plain-objects)'
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[9.1.1.10 Arrays](#arrays)'
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[9.1.1.10 数组](#arrays)'
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[9.1.1.11 Control flow statements](#control-flow-statements)'
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[9.1.1.11 控制流语句](#control-flow-statements)'
- en: 'Conditional statement:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`for-of` loop:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-of`循环：'
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[9.1.2 Modules](#modules)'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[9.1.2 模块](#modules)'
- en: 'Each module is a single file. Consider, for example, the following two files
    with modules in them:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都是一个单独的文件。例如，考虑以下包含模块的两个文件：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The module in `file-tools.mjs` exports its function `isTextFilePath()`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`file-tools.mjs`中的模块导出其函数`isTextFilePath()`：'
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The module in `main.mjs` imports the whole module `path` and the function `isTextFilePath()`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.mjs`中的模块导入了整个模块`path`和函数`isTextFilePath()`：'
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[9.1.3 Classes](#classes-1)'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[9.1.3 类](#classes-1)'
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[9.1.4 Exception handling](#exception-handling)'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[9.1.4 异常处理](#exception-handling)'
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: '`try-finally` and `try-catch-finally` are also supported.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持`try-finally`和`try-catch-finally`。
- en: We can throw any value, but features such as stack traces are only supported
    by `Error` and its subclasses.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以抛出任何值，但只有`Error`及其子类支持堆栈跟踪等特性。
- en: '[9.1.5 Legal variable and property names](#legal-variable-and-property-names)'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[9.1.5 合法变量和属性名称](#legal-variable-and-property-names)'
- en: The grammatical category of variable names and property names is called *identifier*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名和属性名的语法类别称为*标识符*。
- en: 'Identifiers are allowed to have the following characters:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符允许包含以下字符：
- en: 'Unicode letters: `A`–`Z`, `a`–`z` (etc.)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unicode字母：`A`–`Z`、`a`–`z`（等等）
- en: '`$`, `_`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`, `_`'
- en: 'Unicode digits: `0`–`9` (etc.)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unicode数字：`0`–`9`（等等）
- en: Variable names can’t start with a digit
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名不能以数字开头
- en: 'Some words have special meaning in JavaScript and are called *reserved*. Examples
    include: `if`, `true`, `const`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一些单词在JavaScript中有特殊含义，被称为*保留字*。例如：`if`、`true`、`const`。
- en: 'Reserved words can’t be used as variable names:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 保留字不能用作变量名：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'But they are allowed as names of properties:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但它们可以用作属性名：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[9.1.6 Casing styles](#casing-styles)'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[9.1.6 大小写风格](#casing-styles)'
- en: 'Common casing styles for concatenating words are:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 拼接单词的常见大小写风格有：
- en: 'Camel case: `threeConcatenatedWords`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驼峰式：`threeConcatenatedWords`
- en: 'Underscore case (also called *snake case*): `three_concatenated_words`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下划线大小写（也称为 *snake case*）：`three_concatenated_words`
- en: 'Dash case (also called *kebab case*): `three-concatenated-words`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破折号大小写（也称为 *kebab case*）：`three-concatenated-words`
- en: '[9.1.7 Capitalization of names](#capitalization-of-names)'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[9.1.7 名称的资本化](#capitalization-of-names)'
- en: In general, JavaScript uses camel case, except for constants.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，JavaScript 使用驼峰式，但常量除外。
- en: 'Lowercase:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 小写：
- en: 'Functions, variables: `myFunction`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数、变量：`myFunction`
- en: 'Methods: `obj.myMethod`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法：`obj.myMethod`
- en: 'CSS:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS：
- en: 'CSS names: `my-utility-class` (dash case)'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS 名称：`my-utility-class`（破折号大小写）
- en: 'Corresponding JavaScript names: `myUtilityClass`'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对应的 JavaScript 名称：`myUtilityClass`
- en: 'Module file names are usually dash-cased:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块文件名通常是破折号大小写：
- en: '[PRE25]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Uppercase:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 大写：
- en: 'Classes: `MyClass`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类：`MyClass`
- en: 'All-caps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 全大写：
- en: 'Constants (as shared between modules etc.): `MY_CONSTANT` (underscore case)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量（如模块之间的共享等）：`MY_CONSTANT`（下划线大小写）
- en: '[9.1.8 More naming conventions](#more-naming-conventions)'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[9.1.8 更多命名约定](#more-naming-conventions)'
- en: The following naming conventions are popular in JavaScript.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命名约定在 JavaScript 中很流行。
- en: 'If the name of a parameter starts with an underscore (or is an underscore)
    it means that this parameter is not used – for example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数的名称以下划线开头（或本身就是下划线），则表示该参数未使用——例如：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If the name of a property of an object starts with an underscore then that
    property is considered private:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象的属性名称以下划线开头，则该属性被认为是私有的：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[9.1.9 Where to put semicolons?](#where-to-put-semicolons)'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[9.1.9 分号放置的位置？](#where-to-put-semicolons)'
- en: 'At the end of a statement:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在语句的末尾：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'But not if that statement ends with a curly brace:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果该语句以花括号结尾，则不是这样：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'However, adding a semicolon after such a statement is not a syntax error –
    it is interpreted as an empty statement:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这样一个语句后添加分号并不是语法错误——它被解释为一个空语句：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[9.2 (Advanced)](#advanced)'
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[9.2 （高级）](#advanced)'
- en: All remaining sections of this chapter are advanced.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分都是高级内容。
- en: '[9.3 Hashbang lines (Unix shell scripts)](#hashbang-lines)'
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[9.3 Hashbang 行（Unix shell 脚本）](#hashbang-lines)'
- en: 'In a Unix shell script, we can add a first line that starts with `#!` to tell
    Unix which executable should be used to run the script. These two characters have
    several names, including *hashbang*, *sharp-exclamation*, *sha-bang* (“sha” as
    in “sharp”) and *shebang*. Otherwise, hashbang lines are treated as comments by
    most shell scripting languages and JavaScript does so, too. This is a common hashbang
    line for Node.js:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unix shell 脚本中，我们可以添加一个以 `#!` 开头的第一行，以告诉 Unix 应使用哪个可执行文件来运行脚本。这两个字符有几个名字，包括
    *hashbang*、*sharp-exclamation*、*sha-bang*（“sha”就像“sharp”）和 *shebang*。否则，大多数 shell
    脚本语言和 JavaScript 都将其视为注释。这是 Node.js 的常见 hashbang 行：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we want to pass arguments to `node`, we have to use the `env` option `-S`
    (to be safe, some Unixes don’t need it):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要向 `node` 传递参数，我们必须使用 `env` 选项 `-S`（为了安全起见，某些 Unix 系统可能不需要它）：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[9.4 Identifiers](#identifiers)'
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[9.4 标识符](#identifiers)'
- en: '[9.4.1 Valid identifiers (variable names, etc.)](#valid-identifiers-variable-names-etc)'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[9.4.1 有效标识符（变量名等）](#valid-identifiers-variable-names-etc)'
- en: 'First character:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字符：
- en: Unicode letter (including accented characters such as `é` and `ü` and characters
    from non-latin alphabets, such as `α`)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unicode 字母（包括带重音的字符，如 `é` 和 `ü` 以及来自非拉丁字母表的字符，如 `α`）
- en: '`$`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`'
- en: '`_`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_`'
- en: 'Subsequent characters:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 后续字符：
- en: Legal first characters
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合法的第一个字符
- en: Unicode digits (including Eastern Arabic numerals)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unicode 数字（包括东阿拉伯数字）
- en: Some other Unicode marks and punctuations
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些其他的 Unicode 标记和标点符号
- en: 'Examples:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例子：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[9.4.2 Reserved words](#reserved-words)'
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[9.4.2 保留字](#reserved-words)'
- en: Reserved words can’t be variable names, but they can be property names.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 保留字不能是变量名，但可以是属性名。
- en: 'All JavaScript *keywords* are reserved words:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 JavaScript *关键字* 都是保留字：
- en: '`await` `break` `case` `catch` `class` `const` `continue` `debugger` `default`
    `delete` `do` `else` `export` `extends` `finally` `for` `function` `if` `import`
    `in` `instanceof` `let` `new` `return` `static` `super` `switch` `this` `throw`
    `try` `typeof` `var` `void` `while` `with` `yield`'
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`await` `break` `case` `catch` `class` `const` `continue` `debugger` `default`
    `delete` `do` `else` `export` `extends` `finally` `for` `function` `if` `import`
    `in` `instanceof` `let` `new` `return` `static` `super` `switch` `this` `throw`
    `try` `typeof` `var` `void` `while` `with` `yield`'
- en: 'The following tokens are also keywords, but currently not used in the language:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标记也是关键字，但目前未在语言中使用：
- en: '`enum` `implements` `package` `protected` `interface` `private` `public`'
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`enum` `implements` `package` `protected` `interface` `private` `public`'
- en: 'The following literals are reserved words:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下字面量是保留字：
- en: '`true` `false` `null`'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`true` `false` `null`'
- en: 'Technically, these words are not reserved, but you should avoid them, too,
    because they effectively are keywords:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这些词不是保留的，但你应该避免使用它们，因为它们实际上也是关键字：
- en: '`Infinity` `NaN` `undefined` `async`'
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Infinity` `NaN` `undefined` `async`'
- en: You shouldn’t use the names of global variables (`String`, `Math`, etc.) for
    your own variables and parameters, either.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你也不应该使用全局变量的名称（`String`、`Math`等）来为自己的变量和参数命名。
- en: '[9.5 Statement vs. expression](#statement-vs-expression)'
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[9.5 语句与表达式](#statement-vs-expression)'
- en: 'In this section, we explore how JavaScript distinguishes two kinds of syntactic
    constructs: *statements* and *expressions*. Afterward, we’ll see that that can
    cause problems because the same syntax can mean different things, depending on
    where it is used.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨JavaScript如何区分两种语法结构：*语句*和*表达式*。之后，我们将看到这可能会引起问题，因为相同的语法在不同的上下文中可能意味着不同的事情。
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **We pretend
    there are only statements and expressions**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“详情”](../Images/38ba63de820aae6f94a019538ae0f222.png) **我们假装只有语句和表达式**'
- en: For the sake of simplicity, we pretend that there are only statements and expressions
    in JavaScript.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，我们假装JavaScript中只有语句和表达式。
- en: '[9.5.1 Statements](#statements)'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[9.5.1 语句](#statements)'
- en: 'A *statement* is a piece of code that can be executed and performs some kind
    of action. For example, `if` is a statement:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*语句*是一段可以执行并执行某种动作的代码。例如，`if`是一个语句：'
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'One more example of a statement: a function declaration.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个语句的例子：函数声明。
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[9.5.2 Expressions](#expressions)'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[9.5.2 表达式](#expressions)'
- en: 'An *expression* is a piece of code that can be *evaluated* to produce a value.
    For example, the code between the parentheses is an expression:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*表达式*是一段可以*评估*以产生值的代码。例如，括号之间的代码是一个表达式：'
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The operator `_?_:_` used between the parentheses is called the *ternary operator*.
    It is the expression version of the `if` statement.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在括号之间使用的操作符`_?_:_`被称为*三元操作符*。它是`if`语句的表达式版本。
- en: 'Let’s look at more examples of expressions. We enter expressions and the REPL
    evaluates them for us:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看更多表达式的例子。我们输入表达式，REPL会为我们评估它们：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[9.5.3 What is allowed where?](#what-is-allowed-where)'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[9.5.3 允许在哪里？](#what-is-allowed-where)'
- en: 'The current location within JavaScript source code determines which kind of
    syntactic constructs you are allowed to use:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript源代码中的当前位置决定了你可以使用哪种语法结构：
- en: 'The body of a function must be a sequence of statements:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数体必须是一系列语句：
- en: '[PRE38]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The arguments of a function call or a method call must be expressions:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数调用或方法调用的参数必须是表达式：
- en: '[PRE39]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'However, expressions can be used as statements. Then they are called *expression
    statements*. The opposite is not true: when the context requires an expression,
    you can’t use a statement.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，表达式可以用作语句。这时，它们被称为*表达式语句*。相反的情况不成立：当上下文需要表达式时，你不能使用语句。
- en: 'The following code demonstrates that any expression `bar()` can be either expression
    or statement – it depends on the context:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了任何表达式`bar()`可以是表达式或语句——这取决于上下文：
- en: '[PRE40]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[9.6 Ambiguous syntax](#ambiguous-syntax)'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[9.6 混淆的语法](#ambiguous-syntax)'
- en: 'JavaScript has several programming constructs that are syntactically ambiguous:
    the same syntax is interpreted differently, depending on whether it is used in
    statement context or in expression context. This section explores the phenomenon
    and the pitfalls it causes.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有几个在语法上模糊的编程结构：相同的语法在不同的上下文中被解释为不同，这节将探讨这种现象及其带来的问题。
- en: '[9.6.1 Same syntax: function declaration and function expression](#same-syntax-function-declaration-and-function-expression)'
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[9.6.1 同样的语法：函数声明和函数表达式](#same-syntax-function-declaration-and-function-expression)'
- en: 'A *function declaration* is a statement:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数声明*是一个语句：'
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'A *function expression* is an expression (right-hand side of `=`):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数表达式*是一个表达式（等号的右侧）：'
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[9.6.2 Same syntax: object literal and block](#same-syntax-object-literal-and-block)'
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[9.6.2 同样的语法：对象字面量和代码块](#same-syntax-object-literal-and-block)'
- en: 'In the following code, `{}` is an *object literal*: an expression that creates
    an empty object.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，`{}`是一个*对象字面量*：一个创建空对象的表达式。
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is an empty code block (a statement):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个空的代码块（一个语句）：
- en: '[PRE44]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[9.6.3 Disambiguation](#disambiguation)'
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[9.6.3 消歧义](#disambiguation)'
- en: 'The ambiguities are only a problem in statement context: If the JavaScript
    parser encounters ambiguous syntax, it doesn’t know if it’s a plain statement
    or an expression statement. For example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些歧义仅在语句上下文中是问题：如果JavaScript解析器遇到歧义性语法，它不知道它是一个普通语句还是一个表达式语句。例如：
- en: 'If a statement starts with `function`: Is it a function declaration or a function
    expression?'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个语句以 `function` 开头：它是函数声明还是函数表达式？
- en: 'If a statement starts with `{`: Is it an object literal or a code block?'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个语句以 `{` 开头：它是对象字面量还是代码块？
- en: 'To resolve the ambiguity, statements starting with `function` or `{` are never
    interpreted as expressions. If you want an expression statement to start with
    either one of these tokens, you must wrap it in parentheses:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决歧义，以 `function` 或 `{` 开头的语句永远不会被解释为表达式。如果你想使一个表达式语句以这两个标记之一开始，你必须将其括在括号中：
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Output:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In this code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中：
- en: 'We first create a function via a function expression:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先通过函数表达式创建一个函数：
- en: '[PRE47]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then we invoke that function: `(''abc'')`'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们调用该函数：`('abc')`
- en: The code fragment shown in (1) is only interpreted as an expression because
    we wrap it in parentheses. If we didn’t, we would get a syntax error because then
    JavaScript expects a function declaration and complains about the missing function
    name. Additionally, you can’t put a function call immediately after a function
    declaration.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在（1）中显示的代码片段仅被解释为表达式，因为我们将其括在括号中。如果我们没有这样做，我们会得到一个语法错误，因为那时JavaScript期望一个函数声明并抱怨缺少函数名。此外，你不能在函数声明后立即放置一个函数调用。
- en: 'Later in this book, we’ll see more examples of pitfalls caused by syntactic
    ambiguity:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，我们将看到更多由语法歧义引起的陷阱示例：
- en: '[Assigning via object destructuring](ch_destructuring.html#assigning-via-object-destructuring)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[通过对象解构赋值](ch_destructuring.html#assigning-via-object-destructuring)'
- en: '[Returning an object literal from an arrow function](ch_callables.html#returning-object-literal-from-arrow-function)'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[从箭头函数返回对象字面量](ch_callables.html#returning-object-literal-from-arrow-function)'
- en: '[9.7 Semicolons](#semicolons)'
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[9.7 分号](#semicolons)'
- en: '[9.7.1 Rule of thumb for semicolons](#rule-of-thumb-for-semicolons)'
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[9.7.1 分号的经验法则](#rule-of-thumb-for-semicolons)'
- en: 'Each statement is terminated by a semicolon:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 每个语句都以分号结束：
- en: '[PRE48]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'except statements ending with blocks:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 除了以块结尾的语句：
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following case is slightly tricky:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下情况稍微有些棘手：
- en: '[PRE50]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The whole `const` declaration (a statement) ends with a semicolon, but inside
    it, there is an arrow function expression. That is, it’s not the statement per
    se that ends with a curly brace; it’s the embedded arrow function expression.
    That’s why there is a semicolon at the end.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 整个 `const` 声明（一个语句）以分号结束，但其中包含一个箭头函数表达式。也就是说，结束于花括号的不是语句本身，而是嵌入的箭头函数表达式。这就是为什么在末尾有一个分号的原因。
- en: '[9.7.2 Semicolons: control statements](#semicolons-control-statements)'
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[9.7.2 分号：控制语句](#semicolons-control-statements)'
- en: 'The body of a control statement is itself a statement. For example, this is
    the syntax of the `while` loop:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 控制语句的主体本身就是一个语句。例如，这是 `while` 循环的语法：
- en: '[PRE51]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The body can be a single statement:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 主体可以是一个单独的语句：
- en: '[PRE52]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'But blocks are also statements and therefore legal bodies of control statements:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 但块也是语句，因此是控制语句的有效主体：
- en: '[PRE53]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If you want a loop to have an empty body, your first option is an empty statement
    (which is just a semicolon):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让循环有一个空的主体，你的第一个选项是一个空语句（它只是一个分号）：
- en: '[PRE54]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Your second option is an empty block:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你的第二个选项是一个空块：
- en: '[PRE55]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[9.8 Automatic semicolon insertion (ASI)](#automatic-semicolon-insertion-asi)'
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[9.8 自动分号插入（ASI）](#automatic-semicolon-insertion-asi)'
- en: While I recommend to always write semicolons, most of them are optional in JavaScript.
    The mechanism that makes this possible is called *automatic semicolon insertion*
    (ASI). In a way, it corrects syntax errors.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我建议始终写分号，但在JavaScript中大多数情况下它们是可选的。使这成为可能的是称为 *自动分号插入*（ASI）的机制。从某种意义上说，它纠正了语法错误。
- en: 'ASI works as follows. Parsing of a statement continues until there is either:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ASI的工作原理如下。语句的解析继续进行，直到以下情况之一：
- en: A semicolon
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个分号
- en: A line terminator followed by an illegal token
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个行终止符后面跟着一个非法标记
- en: In other words, ASI can be seen as inserting semicolons at line breaks. The
    next subsections cover the pitfalls of ASI.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，自动分号插入（ASI）可以看作是在行尾插入分号。接下来的小节将介绍ASI的陷阱。
- en: '[9.8.1 ASI triggered unexpectedly](#asi-triggered-unexpectedly)'
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[9.8.1 意外触发的ASI](#asi-triggered-unexpectedly)'
- en: The good news about ASI is that – if you don’t rely on it and always write semicolons
    – there is only one pitfall that you need to be aware of. It is that JavaScript
    forbids line breaks after some tokens. If you do insert a line break, a semicolon
    will be inserted, too.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 关于自动分号插入（ASI）的好消息是——如果你不依赖它并且总是写分号——你只需要注意一个陷阱。那就是JavaScript禁止在某些标记后换行。如果你插入换行，也会插入分号。
- en: 'The token where this is most practically relevant is `return`. Consider, for
    example, the following code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这在`return`标记中最为实用。例如，考虑以下代码：
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This code is parsed as:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码被解析为：
- en: '[PRE57]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'That is:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是：
- en: 'Return statement without operand: `return;`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有操作数的返回语句：`return;`
- en: 'Start of code block: `{`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码块开始：`{`
- en: Expression statement `'jane';` with [label](ch_control-flow.html#labels) `first:`
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式语句`'jane';`带有[标签](ch_control-flow.html#labels) `first:`
- en: 'End of code block: `}`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码块结束：`}`
- en: 'Empty statement: `;`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空语句：`;`
- en: Why does JavaScript do this? It protects against accidentally returning a value
    in a line after a `return`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么JavaScript要这样做？它是为了防止在`return`语句之后的行中意外返回一个值。
- en: '[9.8.2 ASI unexpectedly not triggered](#asi-unexpectedly-not-triggered)'
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[9.8.2 ASI意外未触发](#asi-unexpectedly-not-triggered)'
- en: In some cases, ASI is *not* triggered when you think it should be. That makes
    life more complicated for people who don’t like semicolons because they need to
    be aware of those cases. The following are three examples. There are more.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，当你认为应该触发ASI时，它并没有触发。这使得不喜欢分号的人的生活更加复杂，因为他们需要意识到这些情况。以下有三个例子。还有更多。
- en: '**Example 1:** Unintended function call.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例 1**：意外的函数调用。'
- en: '[PRE58]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Parsed as:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 解析为：
- en: '[PRE59]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**Example 2:** Unintended division.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例 2**：意外的除法。'
- en: '[PRE60]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Parsed as:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 解析为：
- en: '[PRE61]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**Example 3:** Unintended property access.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例 3**：意外的属性访问。'
- en: '[PRE62]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Executed as:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 执行为：
- en: '[PRE63]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[9.9 Semicolons: best practices](#semicolons-best-practices)'
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[9.9 分号：最佳实践](#semicolons-best-practices)'
- en: 'I recommend that you always write semicolons:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你总是写分号：
- en: I like the visual structure it gives code – you clearly see where a statement
    ends.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我喜欢它给代码带来的视觉结构——你可以清楚地看到一个语句在哪里结束。
- en: There are fewer rules to keep in mind.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要记住的规则更少。
- en: The majority of JavaScript programmers use semicolons.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数JavaScript程序员使用分号。
- en: 'However, there are also many people who don’t like the added visual clutter
    of semicolons. If you are one of them: Code without them *is* legal. I recommend
    that you use tools to help you avoid mistakes. The following are two examples:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有很多人不喜欢分号带来的额外视觉混乱。如果你是其中之一：没有分号的代码*是合法的*。我建议你使用工具来帮助你避免错误。以下有两个例子：
- en: The automatic code formatter [Prettier](https://prettier.io) can be configured
    to not use semicolons. It then automatically fixes problems. For example, if it
    encounters a line that starts with a square bracket, it prefixes that line with
    a semicolon.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动代码格式化工具[Prettier](https://prettier.io)可以配置为不使用分号。然后它会自动修复问题。例如，如果它遇到以方括号开头的行，它会在该行前加上分号。
- en: The static checker [ESLint](https://eslint.org) has [a rule](https://eslint.org/docs/rules/semi)
    that you tell your preferred style (always semicolons or as few semicolons as
    possible) and that warns you about critical issues.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态检查器[ESLint](https://eslint.org)有一个[规则](https://eslint.org/docs/rules/semi)，你可以告诉你的首选样式（总是分号或尽可能少的分号），并且会警告你关于关键问题。
- en: '[9.10 Strict mode vs. sloppy mode](#strict-mode)'
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[9.10 strict模式与宽松模式](#strict-mode)'
- en: 'Starting with ECMAScript 5, JavaScript has two *modes* in which JavaScript
    can be executed:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 从ECMAScript 5开始，JavaScript有两种*模式*，JavaScript可以在其中执行：
- en: Normal “sloppy” mode is the default in scripts (code fragments that are a precursor
    to modules and supported by browsers).
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常的“宽松”模式在脚本中是默认的（模块的前身，由浏览器支持）。
- en: Strict mode is the default in modules and classes, and can be switched on in
    scripts (how is explained later). In this mode, several pitfalls of normal mode
    are removed and more exceptions are thrown.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模块和类中，strict模式是默认的，可以在脚本中打开（如何操作将在后面解释）。在这种模式下，消除了正常模式的一些陷阱，并抛出了更多异常。
- en: You’ll rarely encounter sloppy mode in modern JavaScript code, which is almost
    always located in modules. In this book, I assume that strict mode is always switched
    on.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代JavaScript代码中，你很少会遇到宽松模式，它几乎总是位于模块中。在这本书中，我假设始终打开strict模式。
- en: '[9.10.1 Switching on strict mode](#switching-on-strict-mode)'
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[9.10.1 打开strict模式](#switching-on-strict-mode)'
- en: 'In script files and CommonJS modules, you switch on strict mode for a complete
    file, by putting the following code in the first line:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本文件和CommonJS模块中，你通过在第一行放置以下代码来为一个完整的文件打开strict模式：
- en: '[PRE64]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The neat thing about this “directive” is that ECMAScript versions before 5
    simply ignore it: it’s an expression statement that does nothing.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这个“指令”的妙处在于，ECMAScript 5之前的版本简单地忽略它：它是一个什么也不做的表达式语句。
- en: 'You can also switch on strict mode for just a single function:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以只为单个函数切换到严格模式：
- en: '[PRE65]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[9.10.2 Improvements in strict mode](#improvements-in-strict-mode)'
  id: totrans-299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[9.10.2 严格模式中的改进](#improvements-in-strict-mode)'
- en: Let’s look at three things that strict mode does better than sloppy mode. Just
    in this one section, all code fragments are executed in sloppy mode.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看严格模式比宽松模式做得更好的三个方面。仅仅在这一节中，所有代码片段都是在宽松模式下执行的。
- en: '[9.10.2.1 Sloppy mode pitfall: changing an undeclared variable creates a global
    variable](#sloppy-mode-pitfall-changing-an-undeclared-variable-creates-a-global-variable)'
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[9.10.2.1 宽松模式陷阱：更改未声明的变量会创建全局变量](#sloppy-mode-pitfall-changing-an-undeclared-variable-creates-a-global-variable)'
- en: In non-strict mode, changing an undeclared variable creates a global variable.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在非严格模式下，更改未声明的变量会创建一个全局变量。
- en: '[PRE66]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Strict mode does it better and throws a `ReferenceError`. That makes it easier
    to detect typos.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式做得更好，并抛出一个`ReferenceError`。这使得检测拼写错误变得更容易。
- en: '[PRE67]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `assert.throws()` states that its first argument, a function, throws a `ReferenceError`
    when it is called.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert.throws()`表明其第一个参数，一个函数，在调用时会抛出一个`ReferenceError`。'
- en: '[9.10.2.2 Function declarations are block-scoped in strict mode, function-scoped
    in sloppy mode](#function-declarations-are-blockscoped-in-strict-mode-functionscoped-in-sloppy-mode)'
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[9.10.2.2 严格模式中函数声明是块作用域的，宽松模式中是函数作用域的](#function-declarations-are-blockscoped-in-strict-mode-functionscoped-in-sloppy-mode)'
- en: 'In strict mode, a variable created via a function declaration only exists within
    the innermost enclosing block:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，通过函数声明创建的变量仅存在于最内层的封装块中：
- en: '[PRE68]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In sloppy mode, function declarations are function-scoped:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在宽松模式下，函数声明是函数作用域的：
- en: '[PRE69]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[9.10.2.3 Sloppy mode doesn’t throw exceptions when changing immutable data](#sloppy-mode-doesnt-throw-exceptions-when-changing-immutable-data)'
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[9.10.2.3 宽松模式在更改不可变数据时不会抛出异常](#sloppy-mode-doesnt-throw-exceptions-when-changing-immutable-data)'
- en: 'In strict mode, you get an exception if you try to change immutable data:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，如果你尝试更改不可变数据，你会得到一个异常：
- en: '[PRE70]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In sloppy mode, the assignment fails silently:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在宽松模式下，赋值操作会静默失败：
- en: '[PRE71]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '![Icon “external”](../Images/38e6ff55e8d602659f3cdb8893e63f62.png) **Further
    reading: sloppy mode**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“外部”](../Images/38e6ff55e8d602659f3cdb8893e63f62.png) **进一步阅读：宽松模式**'
- en: For more information on how sloppy mode differs from strict mode, see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于宽松模式与严格模式差异的信息，请参阅[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)。
