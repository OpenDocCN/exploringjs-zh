- en: 16 Numbers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/impatient-js/ch_numbers.html](https://exploringjs.com/impatient-js/ch_numbers.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 16.1 [Numbers are used for both floating point numbers and integers](ch_numbers.html#numbers-are-used-for-both-floating-point-numbers-and-integers)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.2 [Number literals](ch_numbers.html#number-literals)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.2.1 [Integer literals](ch_numbers.html#integer-literals)
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.2.2 [Floating point literals](ch_numbers.html#floating-point-literals)
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.2.3 [Syntactic pitfall: properties of integer literals](ch_numbers.html#syntactic-pitfall-properties-of-integer-literals)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.2.4 [Underscores (`_`) as separators in number literals [ES2021]](ch_numbers.html#numeric-separator-number-literals)
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.3 [Arithmetic operators](ch_numbers.html#arithmetic-operators)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.3.1 [Binary arithmetic operators](ch_numbers.html#binary-arithmetic-operators)
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.3.2 [Unary plus (`+`) and negation (`-`)](ch_numbers.html#unary-plus-and-negation--)
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.3.3 [Incrementing (`++`) and decrementing (`--`)](ch_numbers.html#incrementing-and-decrementing---)
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.4 [Converting to number](ch_numbers.html#converting-to-number)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.5 [Error values](ch_numbers.html#error-values)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.5.1 [Error value: `NaN`](ch_numbers.html#nan)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.5.2 [Error value: `Infinity`](ch_numbers.html#error-value-infinity)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.6 [The precision of numbers: careful with decimal fractions](ch_numbers.html#the-precision-of-numbers-careful-with-decimal-fractions)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.7 [(Advanced)](ch_numbers.html#advanced-2)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.8 [Background: floating point precision](ch_numbers.html#background-floating-point-precision)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.8.1 [A simplified representation of floating point numbers](ch_numbers.html#a-simplified-representation-of-floating-point-numbers)
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.9 [Integer numbers in JavaScript](ch_numbers.html#integer-numbers-in-javascript)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.9.1 [Converting to integer](ch_numbers.html#converting-to-integer)
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.9.2 [Ranges of integer numbers in JavaScript](ch_numbers.html#ranges-of-integer-numbers-in-javascript)
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.9.3 [Safe integers](ch_numbers.html#safe-integers)
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.10 [Bitwise operators](ch_numbers.html#bitwise-operators)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.10.1 [Internally, bitwise operators work with 32-bit integers](ch_numbers.html#internally-bitwise-operators-work-with-32-bit-integers)
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.10.2 [Bitwise Not](ch_numbers.html#bitwise-not)
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.10.3 [Binary bitwise operators](ch_numbers.html#binary-bitwise-operators)
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.10.4 [Bitwise shift operators](ch_numbers.html#bitwise-shift-operators)
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.10.5 [`b32()`: displaying unsigned 32-bit integers in binary notation](ch_numbers.html#b32)'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.11 [Quick reference: numbers](ch_numbers.html#quick-reference-numbers)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.11.1 [Global functions for numbers](ch_numbers.html#global-functions-for-numbers)
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.11.2 [Static properties of `Number`](ch_numbers.html#static-properties-of-number)
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.11.3 [Static methods of `Number`](ch_numbers.html#static-methods-of-number)
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.11.4 [Methods of `Number.prototype`](ch_numbers.html#methods-of-number.prototype)
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.11.5 [Sources](ch_numbers.html#sources)
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript has two kinds of numeric values:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '*Numbers* are 64-bit floating point numbers and are also used for smaller integers
    (within a range of plus/minus 53 bits).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bigints* represent integers with an arbitrary precision.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter covers numbers. Bigints are covered [later in this book](ch_bigints.html).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 16.1 Numbers are used for both floating point numbers and integers
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The type `number` is used for both integers and floating point numbers in JavaScript:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, all numbers are *doubles*, 64-bit floating point numbers implemented
    according to the *IEEE Standard for Floating-Point Arithmetic* (IEEE 754).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Integer numbers are simply floating point numbers without a decimal fraction:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that, under the hood, most JavaScript engines are often able to use real
    integers, with all associated performance and storage size benefits.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 16.2 Number literals
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s examine literals for numbers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 16.2.1 Integer literals
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Several *integer literals* let us express integers with various bases:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 16.2.2 Floating point literals
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Floating point numbers can only be expressed in base 10.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Fractions:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Exponent: `eN` means ×10^N'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '16.2.3 Syntactic pitfall: properties of integer literals'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Accessing a property of an integer literal entails a pitfall: If the integer
    literal is immediately followed by a dot, then that dot is interpreted as a decimal
    dot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are four ways to work around this pitfall:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 16.2.4 Underscores (`_`) as separators in number literals [ES2021]
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Grouping digits to make long numbers more readable has a long tradition. For
    example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: In 1825, London had 1,335,000 inhabitants.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The distance between Earth and Sun is 149,600,000 km.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since ES2021, we can use underscores as separators in number literals:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With other bases, grouping is important, too:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can also use the separator in fractions and exponents:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 16.2.4.1 Where can we put separators?
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The locations of separators are restricted in two ways:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'We can only put underscores between two digits. Therefore, all of the following
    number literals are illegal:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can’t use more than one underscore in a row:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The motivation behind these restrictions is to keep parsing simple and to avoid
    strange edge cases.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 16.2.4.2 Parsing numbers with separators
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following functions for parsing numbers do not support separators:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '`Number()`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.parseInt()`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.parseFloat()`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The rationale is that numeric separators are for code. Other kinds of input
    should be processed differently.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 16.3 Arithmetic operators
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 16.3.1 Binary arithmetic operators
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Tbl. [5](#tbl:binary-arithmetic-operators) lists JavaScript’s binary arithmetic
    operators.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5: Binary arithmetic operators.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Name |  | Example |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '| `n + m` | Addition | ES1 | `3 + 4` `→` `7` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: '| `n - m` | Subtraction | ES1 | `9 - 1` `→` `8` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: '| `n * m` | Multiplication | ES1 | `3 * 2.25` `→` `6.75` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| `n / m` | Division | ES1 | `5.625 / 5` `→` `1.125` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| `n % m` | Remainder | ES1 | `8 % 5` `→` `3` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '|  |  |  | `-8 % 5` `→` `-3` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| `n ** m` | Exponentiation | ES2016 | `4 ** 2` `→` `16` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: 16.3.1.1 `%` is a remainder operator
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`%` is a remainder operator, not a modulo operator. Its result has the sign
    of the first operand:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For more information on the difference between remainder and modulo, see the
    blog post [“Remainder operator vs. modulo operator (with JavaScript code)”](https://2ality.com/2019/08/remainder-vs-modulo.html)
    on 2ality.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 16.3.2 Unary plus (`+`) and negation (`-`)
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Tbl. [6](#tbl:unary-plus-negation) summarizes the two operators *unary plus*
    (`+`) and *negation* (`-`).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6: The operators unary plus (`+`) and negation (`-`).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Name |  | Example |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| `+n` | Unary plus | ES1 | `+(-7)` `→` `-7` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| `-n` | Unary negation | ES1 | `-(-7)` `→` `7` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: 'Both operators coerce their operands to numbers:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Thus, unary plus lets us convert arbitrary values to numbers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 16.3.3 Incrementing (`++`) and decrementing (`--`)
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The incrementation operator `++` exists in a prefix version and a suffix version.
    In both versions, it destructively adds one to its operand. Therefore, its operand
    must be a storage location that can be changed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: The decrementation operator `--` works the same, but subtracts one from its
    operand. The next two examples explain the difference between the prefix and the
    suffix version.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Tbl. [7](#tbl:incrementing-decrementing) summarizes the incrementation and decrementation
    operators.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 7: Incrementation operators and decrementation operators.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Name |  | Example |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| `v++` | Increment | ES1 | `let v=0; [v++, v]` `→` `[0, 1]` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| `++v` | Increment | ES1 | `let v=0; [++v, v]` `→` `[1, 1]` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| `v--` | Decrement | ES1 | `let v=1; [v--, v]` `→` `[1, 0]` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| `--v` | Decrement | ES1 | `let v=1; [--v, v]` `→` `[0, 0]` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: Next, we’ll look at examples of these operators in use.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Prefix `++` and prefix `--` change their operands and then return them.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Suffix `++` and suffix `--` return their operands and then change them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '16.3.3.1 Operands: not just variables'
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 16.3.3.1 操作数：不仅仅是变量
- en: 'We can also apply these operators to property values:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将这些运算符应用于属性值：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And to Array elements:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以及数组元素：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Number operators**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **练习：数字运算符**'
- en: '`exercises/numbers-math/is_odd_test.mjs`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/numbers-math/is_odd_test.mjs`'
- en: 16.4 Converting to number
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4 转换为数字
- en: 'These are three ways of converting values to numbers:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是将值转换为数字的三种方法：
- en: '`Number(value)`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number(value)`'
- en: '`+value`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+value`'
- en: '`parseFloat(value)` (avoid; different than the other two!)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parseFloat(value)`（避免；与其他两种方法不同！）'
- en: 'Recommendation: use the descriptive `Number()`. Tbl. [8](#tbl:converting-values-to-numbers)
    summarizes how it works.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 建议：使用描述性的`Number()`。Tbl. [8](#tbl:converting-values-to-numbers)总结了它的工作原理。
- en: 'Table 8: Converting values to numbers.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 表8：将值转换为数字。
- en: '| `x` | `Number(x)` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `x` | `Number(x)` |'
- en: '| --- | --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `undefined` | `NaN` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `未定义` | `NaN` |'
- en: '| `null` | `0` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `null` | `0` |'
- en: '| boolean | `false` `→` `0`, `true` `→` `1` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 布尔值 | `false` `→` `0`，`true` `→` `1` |'
- en: '| number | `x` (no change) |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 数字 | `x`（无变化） |'
- en: '| bigint | `-1n` `→` `-1`, `1n` `→` `1`, etc. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 大整数 | `-1n` `→` `-1`，`1n` `→` `1`，等等。|'
- en: '| string | `''''` `→` `0` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | `''''` `→` `0` |'
- en: '|  | Other `→` parsed number, ignoring leading/trailing whitespace |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|  | 其他`→`解析的数字，忽略前导/尾随空格 |'
- en: '| symbol | Throws `TypeError` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | 抛出`TypeError` |'
- en: '| object | Configurable (e.g. via `.valueOf()`) |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: 对象 | 可配置的（例如通过`.valueOf()`）
- en: 'Examples:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 例子：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'How objects are converted to numbers can be configured – for example, by overriding
    `.valueOf()`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对象如何转换为数字可以进行配置-例如，通过覆盖`.valueOf()`：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Converting
    to number**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **练习：转换为数字**'
- en: '`exercises/numbers-math/parse_number_test.mjs`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/numbers-math/parse_number_test.mjs`'
- en: 16.5 Error values
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.5 错误值
- en: 'Two number values are returned when errors happen:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生错误时，会返回两个数字值：
- en: '`NaN`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NaN`'
- en: '`Infinity`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Infinity`'
- en: '16.5.1 Error value: `NaN`'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.5.1 错误值：`NaN`
- en: '`NaN` is an abbreviation of “not a number”. Ironically, JavaScript considers
    it to be a number:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`NaN`是“不是一个数字”的缩写。讽刺的是，JavaScript认为它是一个数字：'
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When is `NaN` returned?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 何时返回`NaN`？
- en: '`NaN` is returned if a number can’t be parsed:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法解析数字，则返回`NaN`：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`NaN` is returned if an operation can’t be performed:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法执行操作，则返回`NaN`：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`NaN` is returned if an operand or argument is `NaN` (to propagate errors):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作数或参数是`NaN`，则返回`NaN`（以传播错误）：
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 16.5.1.1 Checking for `NaN`
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 16.5.1.1 检查`NaN`
- en: '`NaN` is the only JavaScript value that is not strictly equal to itself:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`NaN`是唯一一个不严格等于自身的JavaScript值：'
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'These are several ways of checking if a value `x` is `NaN`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是检查值`x`是否为`NaN`的几种方法：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the last line, we use the comparison quirk to detect `NaN`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，我们使用比较技巧来检测`NaN`。
- en: 16.5.1.2 Finding `NaN` in Arrays
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 16.5.1.2 在数组中查找`NaN`
- en: 'Some Array methods can’t find `NaN`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数组方法无法找到`NaN`：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Others can:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可以：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Alas, there is no simple rule of thumb. We have to check for each method how
    it handles `NaN`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，没有简单的经验法则。我们必须检查每种方法如何处理`NaN`。
- en: '16.5.2 Error value: `Infinity`'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.5.2 错误值：`Infinity`
- en: When is the error value `Infinity` returned?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 何时返回错误值`Infinity`？
- en: 'Infinity is returned if a number is too large:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数字太大，则返回无穷大：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Infinity is returned if there is a division by zero:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果除以零，则返回无穷大：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 16.5.2.1 `Infinity` as a default value
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 16.5.2.1 `Infinity`作为默认值
- en: '`Infinity` is larger than all other numbers (except `NaN`), making it a good
    default value:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Infinity`大于所有其他数字（除了`NaN`），使其成为一个很好的默认值：'
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 16.5.2.2 Checking for `Infinity`
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 16.5.2.2 检查`Infinity`
- en: 'These are two common ways of checking if a value `x` is `Infinity`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是检查值`x`是否为`Infinity`的两种常见方法：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Comparing
    numbers**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **练习：比较数字**'
- en: '`exercises/numbers-math/find_max_test.mjs`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/numbers-math/find_max_test.mjs`'
- en: '16.6 The precision of numbers: careful with decimal fractions'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.6 数字的精度：小心处理小数
- en: 'Internally, JavaScript floating point numbers are represented with base 2 (according
    to the IEEE 754 standard). That means that decimal fractions (base 10) can’t always
    be represented precisely:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，JavaScript浮点数使用基数2来表示（根据IEEE 754标准）。这意味着十进制小数（基数10）不能总是精确表示：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We therefore need to take rounding errors into consideration when performing
    arithmetic in JavaScript.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在JavaScript中进行算术运算时，我们需要考虑舍入误差。
- en: Read on for an explanation of this phenomenon.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 继续阅读对这一现象的解释。
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz: basic**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **测验：基础**'
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[测验应用程序](ch_quizzes-exercises.html#quizzes)的解释。
- en: 16.7 (Advanced)
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.7 （高级）
- en: All remaining sections of this chapter are advanced.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有其余部分都是高级的。
- en: '16.8 Background: floating point precision'
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.8 背景：浮点精度
- en: 'In JavaScript, computations with numbers don’t always produce correct results
    – for example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，使用数字进行计算并不总是产生正确的结果-例如：
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To understand why, we need to explore how JavaScript represents floating point
    numbers internally. It uses three integers to do so, which take up a total of
    64 bits of storage (double precision):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么，我们需要探索JavaScript如何在内部表示浮点数。它使用三个整数来表示，总共占用64位存储空间（双精度）：
- en: '| Component | Size | Integer range |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | 大小 | 整数范围 |'
- en: '| --- | --- | --- |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Sign | 1 bit | [0, 1] |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | 1位 | [0, 1] |'
- en: '| Fraction | 52 bits | [0, 2^(52)−1] |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 分数 | 52位 | [0, 2^(52)−1] |'
- en: '| Exponent | 11 bits | [−1023, 1024] |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 指数 | 11位 | [−1023, 1024] |'
- en: 'The floating point number represented by these integers is computed as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由这些整数表示的浮点数计算如下：
- en: (–1)^(sign) × 0b1.fraction × 2^(exponent)
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: （-1）^（符号）× 0b1.fraction × 2^(exponent)
- en: This representation can’t encode a zero because its second component (involving
    the fraction) always has a leading 1\. Therefore, a zero is encoded via the special
    exponent −1023 and a fraction 0.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示无法编码零，因为它的第二个组件（涉及分数）总是有一个前导1。因此，零通过特殊指数-1023和分数0来编码。
- en: 16.8.1 A simplified representation of floating point numbers
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.8.1 浮点数的简化表示
- en: 'To make further discussions easier, we simplify the previous representation:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使进一步讨论更容易，我们简化了先前的表示：
- en: Instead of base 2 (binary), we use base 10 (decimal) because that’s what most
    people are more familiar with.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用基数10（十进制）而不是基数2（二进制），因为大多数人更熟悉十进制。
- en: The *fraction* is a natural number that is interpreted as a fraction (digits
    after a point). We switch to a *mantissa*, an integer that is interpreted as itself.
    As a consequence, the exponent is used differently, but its fundamental role doesn’t
    change.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分数*是一个被解释为分数的自然数（小数点后的数字）。我们切换到*尾数*，一个被解释为自身的整数。因此，指数的使用方式不同，但其基本作用并未改变。'
- en: As the mantissa is an integer (with its own sign), we don’t need a separate
    sign, anymore.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于尾数是一个整数（带有自己的符号），我们不再需要单独的符号。
- en: 'The new representation works like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 新的表示方法如下：
- en: mantissa × 10^(exponent)
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尾数 × 10^(指数)
- en: Let’s try out this representation for a few floating point numbers.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下这种表示方法来表示一些浮点数。
- en: 'For the integer −123, we mainly need the mantissa:'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于整数−123，我们主要需要尾数：
- en: '[PRE35]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For the number 1.5, we imagine there being a point after the mantissa. We use
    a negative exponent to move that point one digit to the left:'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于数字1.5，我们想象尾数后有一个点。我们使用负指数将该点向左移动一位：
- en: '[PRE36]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For the number 0.25, we move the point two digits to the left:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于数字0.25，我们将小数点向左移动两位：
- en: '[PRE37]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Representations with negative exponents can also be written as fractions with
    positive exponents in the denominators:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 具有负指数的表示也可以写成分母中具有正指数的分数：
- en: '[PRE38]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'These fractions help with understanding why there are numbers that our encoding
    cannot represent:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分数有助于理解为什么有些数字我们的编码无法表示：
- en: '`1/10` can be represented. It already has the required format: a power of 10
    in the denominator.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1/10` 可以表示。它已经具有所需的格式：分母中的10的幂。'
- en: '`1/2` can be represented as `5/10`. We turned the 2 in the denominator into
    a power of 10 by multiplying the numerator and denominator by 5.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1/2` 可以表示为`5/10`。我们通过将分子和分母乘以5，将分母中的2转换为10的幂。'
- en: '`1/4` can be represented as `25/100`. We turned the 4 in the denominator into
    a power of 10 by multiplying the numerator and denominator by 25.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1/4` 可以表示为`25/100`。我们通过将分子和分母乘以25，将分母中的4转换为10的幂。'
- en: '`1/3` cannot be represented. There is no way to turn the denominator into a
    power of 10\. (The prime factors of 10 are 2 and 5\. Therefore, any denominator
    that only has these prime factors can be converted to a power of 10, by multiplying
    both the numerator and denominator by enough twos and fives. If a denominator
    has a different prime factor, then there’s nothing we can do.)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1/3` 无法表示。没有办法将分母转换为10的幂。（10的质因数是2和5。因此，任何只有这些质因数的分母都可以通过乘以足够多的2和5来转换为10的幂。如果分母有其他质因数，那么我们就无能为力了。）'
- en: 'To conclude our excursion, we switch back to base 2:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束我们的探讨，我们再次切换到基数2：
- en: '`0.5 = 1/2` can be represented with base 2 because the denominator is already
    a power of 2.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.5 = 1/2` 可以用基数2表示，因为分母已经是2的幂。'
- en: '`0.25 = 1/4` can be represented with base 2 because the denominator is already
    a power of 2.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.25 = 1/4` 可以用基数2表示，因为分母已经是2的幂。'
- en: '`0.1 = 1/10` cannot be represented because the denominator cannot be converted
    to a power of 2.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.1 = 1/10` 无法表示，因为分母无法转换为2的幂。'
- en: '`0.2 = 2/10` cannot be represented because the denominator cannot be converted
    to a power of 2.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.2 = 2/10` 无法表示，因为分母无法转换为2的幂。'
- en: 'Now we can see why `0.1 + 0.2` doesn’t produce a correct result: internally,
    neither of the two operands can be represented precisely.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到为什么`0.1 + 0.2`不能产生正确的结果：在内部，这两个操作数都无法精确表示。
- en: 'The only way to compute precisely with decimal fractions is by internally switching
    to base 10\. For many programming languages, base 2 is the default and base 10
    an option. For example, Java has the class [`BigDecimal`](https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html)
    and Python has the module [`decimal`](https://docs.python.org/3/library/decimal.html).
    There are plans to add something similar to JavaScript: [the ECMAScript proposal
    “Decimal”](https://github.com/tc39/proposal-decimal).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 精确计算小数部分的唯一方法是在内部切换到基数10。对于许多编程语言，基数2是默认值，基数10是一个选项。例如，Java有类[`BigDecimal`](https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html)，Python有模块[`decimal`](https://docs.python.org/3/library/decimal.html)。有计划向JavaScript添加类似的功能：[ECMAScript提案“Decimal”](https://github.com/tc39/proposal-decimal)。
- en: 16.9 Integer numbers in JavaScript
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.9 JavaScript中的整数
- en: 'Integer numbers are normal (floating point) numbers without decimal fractions:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 整数是没有小数部分的正常（浮点）数：
- en: '[PRE39]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this section, we’ll look at a few tools for working with these pseudo-integers.
    JavaScript also supports [*bigints*](ch_bigints.html), which are real integers.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一些处理这些伪整数的工具。JavaScript还支持[*bigints*](ch_bigints.html)，这些是真正的整数。
- en: 16.9.1 Converting to integer
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.9.1 转换为整数
- en: 'The recommended way of converting numbers to integers is to use one of the
    rounding methods of the `Math` object:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字转换为整数的推荐方法是使用`Math`对象的其中一种四舍五入方法：
- en: '`Math.floor(n)`: returns the largest integer `i` ≤ `n`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Math.floor(n)`: 返回最大的整数`i` ≤ `n`'
- en: '[PRE40]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`Math.ceil(n)`: returns the smallest integer `i` ≥ `n`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Math.ceil(n)`: 返回最小的整数`i` ≥ `n`'
- en: '[PRE41]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`Math.round(n)`: returns the integer that is “closest” to `n` with `__.5` being
    rounded up – for example:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Math.round(n)`: 返回与`n`“最接近”的整数，其中`__.5`四舍五入为上述整数，例如：'
- en: '[PRE42]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`Math.trunc(n)`: removes any decimal fraction (after the point) that `n` has,
    therefore turning it into an integer.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Math.trunc(n)`: 移除`n`的任何小数部分（小数点后），因此将其转换为整数。'
- en: '[PRE43]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For more information on rounding, consult [§17.3 “Rounding”](ch_math.html#math-rounding).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 有关四舍五入的更多信息，请参阅[§17.3 “Rounding”](ch_math.html#math-rounding)。
- en: 16.9.2 Ranges of integer numbers in JavaScript
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.9.2 JavaScript中整数的范围
- en: 'These are important ranges of integer numbers in JavaScript:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是JavaScript中整数的重要范围：
- en: '**Safe integers:** can be represented “safely” by JavaScript (more on what
    that means in the next subsection)'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全整数：**可以被JavaScript“安全”表示（在下一小节中会详细介绍）'
- en: 'Precision: 53 bits plus sign'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精度：53位加符号
- en: 'Range: (−2^(53), 2^(53))'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围：（−2^(53), 2^(53)）
- en: '**Array indices**'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组索引**'
- en: 'Precision: 32 bits, unsigned'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精度：32位，无符号
- en: 'Range: [0, 2^(32)−1) (excluding the maximum length)'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围：[0, 2^(32)−1)（不包括最大长度）
- en: Typed Arrays have a larger range of 53 bits (safe and unsigned)
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型化数组具有53位的更大范围（安全且无符号）
- en: '**Bitwise operators** (bitwise Or, etc.)'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按位运算符**（按位或等）'
- en: 'Precision: 32 bits'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精度：32位
- en: 'Range of unsigned right shift (`>>>`): unsigned, [0, 2^(32))'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无符号右移（`>>>`）的范围：无符号，[0, 2^(32))
- en: 'Range of all other bitwise operators: signed, [−2^(31), 2^(31))'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他按位运算符的范围：有符号，[−2^(31), 2^(31))
- en: 16.9.3 Safe integers
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.9.3 安全整数
- en: 'This is the range of integer numbers that are *safe* in JavaScript (53 bits
    plus a sign):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是JavaScript中*安全*的整数范围（53位加上符号）：
- en: '[–(2^(53))+1, 2^(53)–1]'
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[–(2^(53))+1, 2^(53)–1]'
- en: An integer is *safe* if it is represented by exactly one JavaScript number.
    Given that JavaScript numbers are encoded as a fraction multiplied by 2 to the
    power of an exponent, higher integers can also be represented, but then there
    are gaps between them.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个整数由一个JavaScript数字精确表示，则该整数是*安全*的。鉴于JavaScript数字被编码为乘以2的指数幂的分数，更高的整数也可以表示，但它们之间存在间隙。
- en: 'For example (18014398509481984 is 2^(54)):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 例如（18014398509481984是2^(54)）：
- en: '[PRE44]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following properties of `Number` help determine if an integer is safe:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number`的以下属性有助于确定整数是否安全：'
- en: '[PRE45]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Detecting
    safe integers**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **练习：检测安全整数**'
- en: '`exercises/numbers-math/is_safe_integer_test.mjs`'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/numbers-math/is_safe_integer_test.mjs`'
- en: 16.9.3.1 Safe computations
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 16.9.3.1 安全计算
- en: Let’s look at computations involving unsafe integers.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看涉及不安全整数的计算。
- en: 'The following result is incorrect and unsafe, even though both of its operands
    are safe:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是不正确和不安全的，即使它的操作数都是安全的：
- en: '[PRE46]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following result is safe, but incorrect. The first operand is unsafe; the
    second operand is safe:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是安全的，但不正确。第一个操作数是不安全的；第二个操作数是安全的：
- en: '[PRE47]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Therefore, the result of an expression `a op b` is correct if and only if:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，表达式`a op b`的结果是正确的当且仅当：
- en: '[PRE48]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: That is, both operands and the result must be safe.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，操作数和结果都必须是安全的。
- en: 16.10 Bitwise operators
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.10 按位运算符
- en: 16.10.1 Internally, bitwise operators work with 32-bit integers
  id: totrans-301
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.10.1 按位运算符在内部使用32位整数
- en: 'Internally, JavaScript’s bitwise operators work with 32-bit integers. They
    produce their results in the following steps:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，JavaScript的按位运算符使用32位整数。它们通过以下步骤产生结果：
- en: 'Input (JavaScript numbers): The 1–2 operands are first converted to JavaScript
    numbers (64-bit floating point numbers) and then to 32-bit integers.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入（JavaScript数字）：首先将1-2个操作数转换为JavaScript数字（64位浮点数），然后转换为32位整数。
- en: 'Computation (32-bit integers): The actual operation processes 32-bit integers
    and produces a 32-bit integer.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算（32位整数）：实际操作处理32位整数并产生32位整数。
- en: 'Output (JavaScript number): Before returning the result, it is converted back
    to a JavaScript number.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出（JavaScript数字）：在返回结果之前，它被转换回JavaScript数字。
- en: 16.10.1.1 The types of operands and results
  id: totrans-306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 16.10.1.1 操作数和结果的类型
- en: 'For each bitwise operator, this book mentions the types of its operands and
    its result. Each type is always one of the following two:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个按位运算符，本书提到了它的操作数和结果的类型。每种类型总是以下两种之一：
- en: '| Type | Description | Size | Range |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 | 大小 | 范围 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Int32 | signed 32-bit integer | 32 bits incl. sign | [−2^(31), 2^(31)) |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| Int32 | 有符号32位整数 | 32位包括符号 | [−2^(31), 2^(31)) |'
- en: '| Uint32 | unsigned 32-bit integer | 32 bits | [0, 2^(32)) |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| Uint32 | 无符号32位整数 | 32位 | [0, 2^(32)) |'
- en: Considering the previously mentioned steps, I recommend to pretend that bitwise
    operators internally work with unsigned 32-bit integers (step “computation”) and
    that Int32 and Uint32 only affect how JavaScript numbers are converted to and
    from integers (steps “input” and “output”).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到前面提到的步骤，我建议假装按位运算符在内部使用无符号32位整数（步骤“计算”），而Int32和Uint32只影响JavaScript数字如何转换为整数和从整数转换为（步骤“输入”和“输出”）。
- en: 16.10.1.2 Displaying JavaScript numbers as unsigned 32-bit integers
  id: totrans-313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 16.10.1.2 将JavaScript数字显示为无符号32位整数
- en: 'While exploring the bitwise operators, it occasionally helps to display JavaScript
    numbers as unsigned 32-bit integers in binary notation. That’s what `b32()` does
    (whose implementation is shown later):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索按位运算符时，有时将JavaScript数字显示为二进制表示的无符号32位整数会有所帮助。这就是`b32()`的作用（其实现稍后会显示）：
- en: '[PRE49]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 16.10.2 Bitwise Not
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.10.2 按位非
- en: 'Table 9: The bitwise Not operator.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 表9：按位非运算符。
- en: '| Operation | Name | Type signature |  |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 名称 | 类型签名 |  |'
- en: '| --- | --- | --- | --- |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `~num` | Bitwise Not, *ones’ complement* | Int32 `→` Int32 | ES1 |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `~num` | 按位非，*补码* | Int32 `→` Int32 | ES1 |'
- en: 'The bitwise Not operator (tbl. [9](#tbl:bitwise-not)) inverts each binary digit
    of its operand:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 按位非运算符（tbl. [9](#tbl:bitwise-not)）反转其操作数的每个二进制位：
- en: '[PRE50]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This so-called *ones’ complement* is similar to a negative for some arithmetic
    operations. For example, adding an integer to its ones’ complement is always `-1`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 所谓的*补码*对于某些算术运算类似于负数。例如，将整数加上它的补码总是`-1`：
- en: '[PRE51]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 16.10.3 Binary bitwise operators
  id: totrans-325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.10.3 二进制按位运算符
- en: 'Table 10: Binary bitwise operators.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 表10：二进制按位运算符。
- en: '| Operation | Name | Type signature |  |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 名称 | 类型签名 |  |'
- en: '| --- | --- | --- | --- |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `num1 & num2` | Bitwise And | Int32 × Int32 `→` Int32 | ES1 |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| `num1 & num2` | 按位与 | Int32 × Int32 `→` Int32 | ES1 |'
- en: '| `num1 ¦ num2` | Bitwise Or | Int32 × Int32 `→` Int32 | ES1 |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| `num1 ¦ num2` | 按位或 | Int32 × Int32 `→` Int32 | ES1 |'
- en: '| `num1 ^ num2` | Bitwise Xor | Int32 × Int32 `→` Int32 | ES1 |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| `num1 ^ num2` | 按位异或 | Int32 × Int32 `→` Int32 | ES1 |'
- en: 'The binary bitwise operators (tbl. [10](#tbl:binary-bitwise-operators)) combine
    the bits of their operands to produce their results:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制按位运算符（tbl. [10](#tbl:binary-bitwise-operators)）将它们的操作数的位组合起来产生它们的结果：
- en: '[PRE52]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 16.10.4 Bitwise shift operators
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.10.4 按位移动运算符
- en: 'Table 11: Bitwise shift operators.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 表11：位移运算符。
- en: '| Operation | Name | Type signature |  |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 名称 | 类型签名 |  |'
- en: '| --- | --- | --- | --- |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `num << count` | Left shift | Int32 × Uint32 `→` Int32 | ES1 |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| `num << count` | 左移 | Int32 × Uint32 `→` Int32 | ES1 |'
- en: '| `num >> count` | Signed right shift | Int32 × Uint32 `→` Int32 | ES1 |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| `num >> count` | 有符号右移 | Int32 × Uint32 `→` Int32 | ES1 |'
- en: '| `num >>> count` | Unsigned right shift | Uint32 × Uint32 `→` Uint32 | ES1
    |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| `num >>> count` | 无符号右移 | Uint32 × Uint32 `→` Uint32 | ES1 |'
- en: 'The shift operators (tbl. [11](#tbl:bitwise-shift-operators-short)) move binary
    digits to the left or to the right:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 位移运算符（见表[11](#tbl:bitwise-shift-operators-short)）将二进制数字向左或向右移动：
- en: '[PRE53]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`>>` preserves highest bit, `>>>` doesn’t:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>`保留最高位，`>>>`不保留：'
- en: '[PRE54]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '16.10.5 `b32()`: displaying unsigned 32-bit integers in binary notation'
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '16.10.5 `b32()`: 以二进制表示无符号32位整数'
- en: 'We have now used `b32()` a few times. The following code is an implementation
    of it:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经使用了`b32()`几次。以下代码是它的一个实现：
- en: '[PRE55]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`n >>> 0` means that we are shifting `n` zero bits to the right. Therefore,
    in principle, the `>>>` operator does nothing, but it still coerces `n` to an
    unsigned 32-bit integer:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`n >>> 0`表示我们将`n`向右移动零位。因此，原则上，`>>>`运算符什么也不做，但它仍然将`n`强制转换为无符号32位整数：'
- en: '[PRE56]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '16.11 Quick reference: numbers'
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.11 快速参考：数字
- en: 16.11.1 Global functions for numbers
  id: totrans-351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.11.1 用于数字的全局函数
- en: 'JavaScript has the following four global functions for numbers:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有以下四个用于数字的全局函数：
- en: '`isFinite()`'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isFinite()`'
- en: '`isNaN()`'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isNaN()`'
- en: '`parseFloat()`'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parseFloat()`'
- en: '`parseInt()`'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parseInt()`'
- en: However, it is better to use the corresponding methods of `Number` (`Number.isFinite()`,
    etc.), which have fewer pitfalls. They were introduced with ES6 and are discussed
    below.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最好使用`Number`的相应方法（`Number.isFinite()`等），它们有更少的陷阱。它们是在ES6中引入的，并在下面讨论。
- en: 16.11.2 Static properties of `Number`
  id: totrans-358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.11.2 `Number`的静态属性
- en: '`.EPSILON: number` ^([ES6])'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.EPSILON: number` ^([ES6])'
- en: The difference between 1 and the next representable floating point number. In
    general, [a machine epsilon](https://en.wikipedia.org/wiki/Machine_epsilon) provides
    an upper bound for rounding errors in floating point arithmetic.
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1和下一个可表示的浮点数之间的差异。一般来说，[机器epsilon](https://en.wikipedia.org/wiki/Machine_epsilon)提供了浮点运算中舍入误差的上限。
- en: 'Approximately: 2.2204460492503130808472633361816 × 10^(-16)'
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大约为：2.2204460492503130808472633361816 × 10^(-16)
- en: '`.MAX_SAFE_INTEGER: number` ^([ES6])'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.MAX_SAFE_INTEGER: number` ^([ES6])'
- en: The largest integer that JavaScript can represent unambiguously (2^(53)−1).
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JavaScript可以明确表示的最大整数（2^(53)−1）。
- en: '`.MAX_VALUE: number` ^([ES1])'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.MAX_VALUE: number` ^([ES1])'
- en: The largest positive finite JavaScript number.
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最大的正有限JavaScript数字。
- en: 'Approximately: 1.7976931348623157 × 10^(308)'
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大约为：1.7976931348623157 × 10^(308)
- en: '`.MIN_SAFE_INTEGER: number` ^([ES6])'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.MIN_SAFE_INTEGER: number` ^([ES6])'
- en: The smallest integer that JavaScript can represent unambiguously (−2^(53)+1).
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JavaScript可以明确表示的最小整数（−2^(53)+1）。
- en: '`.MIN_VALUE: number` ^([ES1])'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.MIN_VALUE: number` ^([ES1])'
- en: The smallest positive JavaScript number. Approximately 5 × 10^(−324).
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最小的正JavaScript数字。大约为5 × 10^(−324)。
- en: '`.NaN: number` ^([ES1])'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.NaN: number` ^([ES1])'
- en: The same as the global variable `NaN`.
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与全局变量`NaN`相同。
- en: '`.NEGATIVE_INFINITY: number` ^([ES1])'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.NEGATIVE_INFINITY: number` ^([ES1])'
- en: The same as `-Number.POSITIVE_INFINITY`.
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与`-Number.POSITIVE_INFINITY`相同。
- en: '`.POSITIVE_INFINITY: number` ^([ES1])'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.POSITIVE_INFINITY: number` ^([ES1])'
- en: The same as the global variable `Infinity`.
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与全局变量`Infinity`相同。
- en: 16.11.3 Static methods of `Number`
  id: totrans-377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.11.3 `Number`的静态方法
- en: '`.isFinite(num: number): boolean` ^([ES6])'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.isFinite(num: number): boolean` ^([ES6])'
- en: Returns `true` if `num` is an actual number (neither `Infinity` nor `-Infinity`
    nor `NaN`).
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`num`是一个实际数字（既不是`Infinity`也不是`-Infinity`也不是`NaN`），则返回`true`。
- en: '[PRE57]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`.isInteger(num: number): boolean` ^([ES6])'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.isInteger(num: number): boolean` ^([ES6])'
- en: Returns `true` if `num` is a number and does not have a decimal fraction.
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`num`是一个数字并且没有小数部分，则返回`true`。
- en: '[PRE58]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '`.isNaN(num: number): boolean` ^([ES6])'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.isNaN(num: number): boolean` ^([ES6])'
- en: 'Returns `true` if `num` is the value `NaN`:'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`num`是值`NaN`，则返回`true`：
- en: '[PRE59]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`.isSafeInteger(num: number): boolean` ^([ES6])'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.isSafeInteger(num: number): boolean` ^([ES6])'
- en: Returns `true` if `num` is a number and unambiguously represents an integer.
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`num`是一个数字并且明确表示一个整数，则返回`true`。
- en: '`.parseFloat(str: string): number` ^([ES6])'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.parseFloat(str: string): number` ^([ES6])'
- en: Coerces its parameter to string and parses it as a floating point number. For
    converting strings to numbers, `Number()` (which ignores leading and trailing
    whitespace) is usually a better choice than `Number.parseFloat()` (which ignores
    leading whitespace and illegal trailing characters and can hide problems).
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将其参数强制转换为字符串并将其解析为浮点数。对于将字符串转换为数字，通常使用`Number()`（它忽略前导和尾随空格）比使用`Number.parseFloat()`（它忽略前导空格和非法的尾随字符，并且可能隐藏问题）更好。
- en: '[PRE60]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`.parseInt(str: string, radix=10): number` ^([ES6])'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.parseInt(str: string, radix=10): number` ^([ES6])'
- en: 'Coerces its parameter to string and parses it as an integer, ignoring leading
    whitespace and illegal trailing characters:'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将其参数强制转换为字符串并将其解析为整数，忽略前导空格和非法的尾随字符：
- en: '[PRE61]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The parameter `radix` specifies the base of the number to be parsed:'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数`radix`指定要解析的数字的基数：
- en: '[PRE62]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Do not use this method to convert numbers to integers: coercing to string is
    inefficient. And stopping before the first non-digit is not a good algorithm for
    removing the fraction of a number. Here is an example where it goes wrong:'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要使用此方法将数字转换为整数：强制转换为字符串是低效的。在第一个非数字之前停止不是去除数字的小数部分的好算法。这里有一个它出错的例子：
- en: '[PRE63]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'It is better to use one of the rounding functions of `Math` to convert a number
    to an integer:'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最好使用`Math`的一个舍入函数将数字转换为整数：
- en: '[PRE64]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 16.11.4 Methods of `Number.prototype`
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.11.4 `Number.prototype`的方法
- en: (`Number.prototype` is where the methods of numbers are stored.)
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: （`Number.prototype`是存储数字方法的地方。）
- en: '`.toExponential(fractionDigits?: number): string` ^([ES3])'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.toExponential(fractionDigits?: number): string` ^([ES3])'
- en: Returns a string that represents the number via exponential notation. With `fractionDigits`,
    we can specify, how many digits should be shown of the number that is multiplied
    with the exponent (the default is to show as many digits as necessary).
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回表示数字的指数表示的字符串。使用`fractionDigits`，我们可以指定应显示与指数相乘的数字的位数（默认情况下，显示所需的位数）。
- en: 'Example: number too small to get a positive exponent via `.toString()`.'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例：数字太小，无法通过`.toString()`获得正指数。
- en: '[PRE65]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Example: fraction not small enough to get a negative exponent via `.toString()`.'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例：小数部分不够小，无法通过`.toString()`获得负指数。
- en: '[PRE66]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`.toFixed(fractionDigits=0): string` ^([ES3])'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.toFixed(fractionDigits=0): string` ^([ES3])'
- en: Returns an exponent-free representation of the number, rounded to `fractionDigits`
    digits.
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回不带指数的数字表示，四舍五入到`fractionDigits`位数。
- en: '[PRE67]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If the number is 10^(21) or greater, even `.toFixed()` uses an exponent:'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果数字大于或等于10^(21)，甚至`.toFixed()`也会使用指数：
- en: '[PRE68]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`.toPrecision(precision?: number): string` ^([ES3])'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.toPrecision(precision?: number): string` ^([ES3])'
- en: Works like `.toString()`, but `precision` specifies how many digits should be
    shown. If `precision` is missing, `.toString()` is used.
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似于`.toString()`，但`precision`指定应显示多少位数字。如果缺少`precision`，则使用`.toString()`。
- en: '[PRE69]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`.toString(radix=10): string` ^([ES1])'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.toString(radix=10): string` ^([ES1])'
- en: Returns a string representation of the number.
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回数字的字符串表示。
- en: 'By default, we get a base 10 numeral as a result:'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，我们得到一个以10为底的数字作为结果：
- en: '[PRE70]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'If we want the numeral to have a different base, we can specify it via `radix`:'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们希望数字以不同的基数表示，可以通过`radix`指定：
- en: '[PRE71]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`Number.parseInt()` provides the inverse operation: it converts a string that
    contains an integer (no fraction!) numeral with a given base, to a number.'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Number.parseInt()`提供了反向操作：它将包含给定基数的整数（无小数部分！）数字的字符串转换为数字。'
- en: '[PRE72]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 16.11.5 Sources
  id: totrans-425
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.11.5 来源
- en: Wikipedia
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科
- en: '[TypeScript’s built-in typings](https://github.com/Microsoft/TypeScript/blob/master/lib/)'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[TypeScript的内置类型](https://github.com/Microsoft/TypeScript/blob/master/lib/)'
- en: '[MDN web docs for JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[JavaScript的MDN网页文档](https://developer.mozilla.org/en-US/docs/Web/JavaScript)'
- en: '[ECMAScript language specification](https://tc39.github.io/ecma262/)'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ECMAScript语言规范](https://tc39.github.io/ecma262/)'
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz: advanced**'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **测验：高级**'
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[测验应用程序](ch_quizzes-exercises.html#quizzes)。
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/11)'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '[评论](https://github.com/rauschma/impatient-js/issues/11)'
