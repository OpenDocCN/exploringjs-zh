- en: 16 Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/impatient-js/ch_numbers.html](https://exploringjs.com/impatient-js/ch_numbers.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 16.1 [Numbers are used for both floating point numbers and integers](ch_numbers.html#numbers-are-used-for-both-floating-point-numbers-and-integers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.2 [Number literals](ch_numbers.html#number-literals)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.2.1 [Integer literals](ch_numbers.html#integer-literals)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.2.2 [Floating point literals](ch_numbers.html#floating-point-literals)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.2.3 [Syntactic pitfall: properties of integer literals](ch_numbers.html#syntactic-pitfall-properties-of-integer-literals)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.2.4 [Underscores (`_`) as separators in number literals [ES2021]](ch_numbers.html#numeric-separator-number-literals)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.3 [Arithmetic operators](ch_numbers.html#arithmetic-operators)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.3.1 [Binary arithmetic operators](ch_numbers.html#binary-arithmetic-operators)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.3.2 [Unary plus (`+`) and negation (`-`)](ch_numbers.html#unary-plus-and-negation--)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.3.3 [Incrementing (`++`) and decrementing (`--`)](ch_numbers.html#incrementing-and-decrementing---)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.4 [Converting to number](ch_numbers.html#converting-to-number)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.5 [Error values](ch_numbers.html#error-values)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.5.1 [Error value: `NaN`](ch_numbers.html#nan)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.5.2 [Error value: `Infinity`](ch_numbers.html#error-value-infinity)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.6 [The precision of numbers: careful with decimal fractions](ch_numbers.html#the-precision-of-numbers-careful-with-decimal-fractions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.7 [(Advanced)](ch_numbers.html#advanced-2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.8 [Background: floating point precision](ch_numbers.html#background-floating-point-precision)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.8.1 [A simplified representation of floating point numbers](ch_numbers.html#a-simplified-representation-of-floating-point-numbers)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.9 [Integer numbers in JavaScript](ch_numbers.html#integer-numbers-in-javascript)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.9.1 [Converting to integer](ch_numbers.html#converting-to-integer)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.9.2 [Ranges of integer numbers in JavaScript](ch_numbers.html#ranges-of-integer-numbers-in-javascript)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.9.3 [Safe integers](ch_numbers.html#safe-integers)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.10 [Bitwise operators](ch_numbers.html#bitwise-operators)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.10.1 [Internally, bitwise operators work with 32-bit integers](ch_numbers.html#internally-bitwise-operators-work-with-32-bit-integers)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.10.2 [Bitwise Not](ch_numbers.html#bitwise-not)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.10.3 [Binary bitwise operators](ch_numbers.html#binary-bitwise-operators)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.10.4 [Bitwise shift operators](ch_numbers.html#bitwise-shift-operators)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.10.5 [`b32()`: displaying unsigned 32-bit integers in binary notation](ch_numbers.html#b32)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.11 [Quick reference: numbers](ch_numbers.html#quick-reference-numbers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.11.1 [Global functions for numbers](ch_numbers.html#global-functions-for-numbers)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.11.2 [Static properties of `Number`](ch_numbers.html#static-properties-of-number)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.11.3 [Static methods of `Number`](ch_numbers.html#static-methods-of-number)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.11.4 [Methods of `Number.prototype`](ch_numbers.html#methods-of-number.prototype)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.11.5 [Sources](ch_numbers.html#sources)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript has two kinds of numeric values:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Numbers* are 64-bit floating point numbers and are also used for smaller integers
    (within a range of plus/minus 53 bits).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bigints* represent integers with an arbitrary precision.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter covers numbers. Bigints are covered [later in this book](ch_bigints.html).
  prefs: []
  type: TYPE_NORMAL
- en: 16.1 Numbers are used for both floating point numbers and integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The type `number` is used for both integers and floating point numbers in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: However, all numbers are *doubles*, 64-bit floating point numbers implemented
    according to the *IEEE Standard for Floating-Point Arithmetic* (IEEE 754).
  prefs: []
  type: TYPE_NORMAL
- en: 'Integer numbers are simply floating point numbers without a decimal fraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that, under the hood, most JavaScript engines are often able to use real
    integers, with all associated performance and storage size benefits.
  prefs: []
  type: TYPE_NORMAL
- en: 16.2 Number literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s examine literals for numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 16.2.1 Integer literals
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Several *integer literals* let us express integers with various bases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 16.2.2 Floating point literals
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Floating point numbers can only be expressed in base 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fractions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Exponent: `eN` means ×10^N'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '16.2.3 Syntactic pitfall: properties of integer literals'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Accessing a property of an integer literal entails a pitfall: If the integer
    literal is immediately followed by a dot, then that dot is interpreted as a decimal
    dot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There are four ways to work around this pitfall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 16.2.4 Underscores (`_`) as separators in number literals [ES2021]
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Grouping digits to make long numbers more readable has a long tradition. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: In 1825, London had 1,335,000 inhabitants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The distance between Earth and Sun is 149,600,000 km.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since ES2021, we can use underscores as separators in number literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With other bases, grouping is important, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the separator in fractions and exponents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 16.2.4.1 Where can we put separators?
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The locations of separators are restricted in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can only put underscores between two digits. Therefore, all of the following
    number literals are illegal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can’t use more than one underscore in a row:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The motivation behind these restrictions is to keep parsing simple and to avoid
    strange edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: 16.2.4.2 Parsing numbers with separators
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following functions for parsing numbers do not support separators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Number()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.parseInt()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.parseFloat()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The rationale is that numeric separators are for code. Other kinds of input
    should be processed differently.
  prefs: []
  type: TYPE_NORMAL
- en: 16.3 Arithmetic operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 16.3.1 Binary arithmetic operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Tbl. [5](#tbl:binary-arithmetic-operators) lists JavaScript’s binary arithmetic
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5: Binary arithmetic operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Name |  | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `n + m` | Addition | ES1 | `3 + 4` `→` `7` |'
  prefs: []
  type: TYPE_TB
- en: '| `n - m` | Subtraction | ES1 | `9 - 1` `→` `8` |'
  prefs: []
  type: TYPE_TB
- en: '| `n * m` | Multiplication | ES1 | `3 * 2.25` `→` `6.75` |'
  prefs: []
  type: TYPE_TB
- en: '| `n / m` | Division | ES1 | `5.625 / 5` `→` `1.125` |'
  prefs: []
  type: TYPE_TB
- en: '| `n % m` | Remainder | ES1 | `8 % 5` `→` `3` |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  | `-8 % 5` `→` `-3` |'
  prefs: []
  type: TYPE_TB
- en: '| `n ** m` | Exponentiation | ES2016 | `4 ** 2` `→` `16` |'
  prefs: []
  type: TYPE_TB
- en: 16.3.1.1 `%` is a remainder operator
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`%` is a remainder operator, not a modulo operator. Its result has the sign
    of the first operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For more information on the difference between remainder and modulo, see the
    blog post [“Remainder operator vs. modulo operator (with JavaScript code)”](https://2ality.com/2019/08/remainder-vs-modulo.html)
    on 2ality.
  prefs: []
  type: TYPE_NORMAL
- en: 16.3.2 Unary plus (`+`) and negation (`-`)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Tbl. [6](#tbl:unary-plus-negation) summarizes the two operators *unary plus*
    (`+`) and *negation* (`-`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6: The operators unary plus (`+`) and negation (`-`).'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Name |  | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `+n` | Unary plus | ES1 | `+(-7)` `→` `-7` |'
  prefs: []
  type: TYPE_TB
- en: '| `-n` | Unary negation | ES1 | `-(-7)` `→` `7` |'
  prefs: []
  type: TYPE_TB
- en: 'Both operators coerce their operands to numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Thus, unary plus lets us convert arbitrary values to numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 16.3.3 Incrementing (`++`) and decrementing (`--`)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The incrementation operator `++` exists in a prefix version and a suffix version.
    In both versions, it destructively adds one to its operand. Therefore, its operand
    must be a storage location that can be changed.
  prefs: []
  type: TYPE_NORMAL
- en: The decrementation operator `--` works the same, but subtracts one from its
    operand. The next two examples explain the difference between the prefix and the
    suffix version.
  prefs: []
  type: TYPE_NORMAL
- en: Tbl. [7](#tbl:incrementing-decrementing) summarizes the incrementation and decrementation
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 7: Incrementation operators and decrementation operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Name |  | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `v++` | Increment | ES1 | `let v=0; [v++, v]` `→` `[0, 1]` |'
  prefs: []
  type: TYPE_TB
- en: '| `++v` | Increment | ES1 | `let v=0; [++v, v]` `→` `[1, 1]` |'
  prefs: []
  type: TYPE_TB
- en: '| `v--` | Decrement | ES1 | `let v=1; [v--, v]` `→` `[1, 0]` |'
  prefs: []
  type: TYPE_TB
- en: '| `--v` | Decrement | ES1 | `let v=1; [--v, v]` `→` `[0, 0]` |'
  prefs: []
  type: TYPE_TB
- en: Next, we’ll look at examples of these operators in use.
  prefs: []
  type: TYPE_NORMAL
- en: Prefix `++` and prefix `--` change their operands and then return them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Suffix `++` and suffix `--` return their operands and then change them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '16.3.3.1 Operands: not just variables'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can also apply these operators to property values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And to Array elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Number operators**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/numbers-math/is_odd_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: 16.4 Converting to number
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These are three ways of converting values to numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Number(value)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+value`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parseFloat(value)` (avoid; different than the other two!)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Recommendation: use the descriptive `Number()`. Tbl. [8](#tbl:converting-values-to-numbers)
    summarizes how it works.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8: Converting values to numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '| `x` | `Number(x)` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `undefined` | `NaN` |'
  prefs: []
  type: TYPE_TB
- en: '| `null` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| boolean | `false` `→` `0`, `true` `→` `1` |'
  prefs: []
  type: TYPE_TB
- en: '| number | `x` (no change) |'
  prefs: []
  type: TYPE_TB
- en: '| bigint | `-1n` `→` `-1`, `1n` `→` `1`, etc. |'
  prefs: []
  type: TYPE_TB
- en: '| string | `''''` `→` `0` |'
  prefs: []
  type: TYPE_TB
- en: '|  | Other `→` parsed number, ignoring leading/trailing whitespace |'
  prefs: []
  type: TYPE_TB
- en: '| symbol | Throws `TypeError` |'
  prefs: []
  type: TYPE_TB
- en: '| object | Configurable (e.g. via `.valueOf()`) |'
  prefs: []
  type: TYPE_TB
- en: 'Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'How objects are converted to numbers can be configured – for example, by overriding
    `.valueOf()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Converting
    to number**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/numbers-math/parse_number_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: 16.5 Error values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Two number values are returned when errors happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NaN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Infinity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.5.1 Error value: `NaN`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`NaN` is an abbreviation of “not a number”. Ironically, JavaScript considers
    it to be a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When is `NaN` returned?
  prefs: []
  type: TYPE_NORMAL
- en: '`NaN` is returned if a number can’t be parsed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`NaN` is returned if an operation can’t be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`NaN` is returned if an operand or argument is `NaN` (to propagate errors):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 16.5.1.1 Checking for `NaN`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`NaN` is the only JavaScript value that is not strictly equal to itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'These are several ways of checking if a value `x` is `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the last line, we use the comparison quirk to detect `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: 16.5.1.2 Finding `NaN` in Arrays
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Some Array methods can’t find `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Others can:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Alas, there is no simple rule of thumb. We have to check for each method how
    it handles `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: '16.5.2 Error value: `Infinity`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When is the error value `Infinity` returned?
  prefs: []
  type: TYPE_NORMAL
- en: 'Infinity is returned if a number is too large:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Infinity is returned if there is a division by zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 16.5.2.1 `Infinity` as a default value
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`Infinity` is larger than all other numbers (except `NaN`), making it a good
    default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 16.5.2.2 Checking for `Infinity`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'These are two common ways of checking if a value `x` is `Infinity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Comparing
    numbers**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/numbers-math/find_max_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '16.6 The precision of numbers: careful with decimal fractions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Internally, JavaScript floating point numbers are represented with base 2 (according
    to the IEEE 754 standard). That means that decimal fractions (base 10) can’t always
    be represented precisely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We therefore need to take rounding errors into consideration when performing
    arithmetic in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Read on for an explanation of this phenomenon.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz: basic**'
  prefs: []
  type: TYPE_NORMAL
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  prefs: []
  type: TYPE_NORMAL
- en: 16.7 (Advanced)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All remaining sections of this chapter are advanced.
  prefs: []
  type: TYPE_NORMAL
- en: '16.8 Background: floating point precision'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In JavaScript, computations with numbers don’t always produce correct results
    – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand why, we need to explore how JavaScript represents floating point
    numbers internally. It uses three integers to do so, which take up a total of
    64 bits of storage (double precision):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Component | Size | Integer range |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Sign | 1 bit | [0, 1] |'
  prefs: []
  type: TYPE_TB
- en: '| Fraction | 52 bits | [0, 2^(52)−1] |'
  prefs: []
  type: TYPE_TB
- en: '| Exponent | 11 bits | [−1023, 1024] |'
  prefs: []
  type: TYPE_TB
- en: 'The floating point number represented by these integers is computed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: (–1)^(sign) × 0b1.fraction × 2^(exponent)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This representation can’t encode a zero because its second component (involving
    the fraction) always has a leading 1\. Therefore, a zero is encoded via the special
    exponent −1023 and a fraction 0.
  prefs: []
  type: TYPE_NORMAL
- en: 16.8.1 A simplified representation of floating point numbers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make further discussions easier, we simplify the previous representation:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of base 2 (binary), we use base 10 (decimal) because that’s what most
    people are more familiar with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *fraction* is a natural number that is interpreted as a fraction (digits
    after a point). We switch to a *mantissa*, an integer that is interpreted as itself.
    As a consequence, the exponent is used differently, but its fundamental role doesn’t
    change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the mantissa is an integer (with its own sign), we don’t need a separate
    sign, anymore.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The new representation works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: mantissa × 10^(exponent)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s try out this representation for a few floating point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the integer −123, we mainly need the mantissa:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the number 1.5, we imagine there being a point after the mantissa. We use
    a negative exponent to move that point one digit to the left:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the number 0.25, we move the point two digits to the left:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Representations with negative exponents can also be written as fractions with
    positive exponents in the denominators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'These fractions help with understanding why there are numbers that our encoding
    cannot represent:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1/10` can be represented. It already has the required format: a power of 10
    in the denominator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1/2` can be represented as `5/10`. We turned the 2 in the denominator into
    a power of 10 by multiplying the numerator and denominator by 5.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1/4` can be represented as `25/100`. We turned the 4 in the denominator into
    a power of 10 by multiplying the numerator and denominator by 25.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1/3` cannot be represented. There is no way to turn the denominator into a
    power of 10\. (The prime factors of 10 are 2 and 5\. Therefore, any denominator
    that only has these prime factors can be converted to a power of 10, by multiplying
    both the numerator and denominator by enough twos and fives. If a denominator
    has a different prime factor, then there’s nothing we can do.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To conclude our excursion, we switch back to base 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0.5 = 1/2` can be represented with base 2 because the denominator is already
    a power of 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0.25 = 1/4` can be represented with base 2 because the denominator is already
    a power of 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0.1 = 1/10` cannot be represented because the denominator cannot be converted
    to a power of 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0.2 = 2/10` cannot be represented because the denominator cannot be converted
    to a power of 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we can see why `0.1 + 0.2` doesn’t produce a correct result: internally,
    neither of the two operands can be represented precisely.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only way to compute precisely with decimal fractions is by internally switching
    to base 10\. For many programming languages, base 2 is the default and base 10
    an option. For example, Java has the class [`BigDecimal`](https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html)
    and Python has the module [`decimal`](https://docs.python.org/3/library/decimal.html).
    There are plans to add something similar to JavaScript: [the ECMAScript proposal
    “Decimal”](https://github.com/tc39/proposal-decimal).'
  prefs: []
  type: TYPE_NORMAL
- en: 16.9 Integer numbers in JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Integer numbers are normal (floating point) numbers without decimal fractions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we’ll look at a few tools for working with these pseudo-integers.
    JavaScript also supports [*bigints*](ch_bigints.html), which are real integers.
  prefs: []
  type: TYPE_NORMAL
- en: 16.9.1 Converting to integer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The recommended way of converting numbers to integers is to use one of the
    rounding methods of the `Math` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.floor(n)`: returns the largest integer `i` ≤ `n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Math.ceil(n)`: returns the smallest integer `i` ≥ `n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Math.round(n)`: returns the integer that is “closest” to `n` with `__.5` being
    rounded up – for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Math.trunc(n)`: removes any decimal fraction (after the point) that `n` has,
    therefore turning it into an integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For more information on rounding, consult [§17.3 “Rounding”](ch_math.html#math-rounding).
  prefs: []
  type: TYPE_NORMAL
- en: 16.9.2 Ranges of integer numbers in JavaScript
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These are important ranges of integer numbers in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Safe integers:** can be represented “safely” by JavaScript (more on what
    that means in the next subsection)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Precision: 53 bits plus sign'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Range: (−2^(53), 2^(53))'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Array indices**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Precision: 32 bits, unsigned'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Range: [0, 2^(32)−1) (excluding the maximum length)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Typed Arrays have a larger range of 53 bits (safe and unsigned)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bitwise operators** (bitwise Or, etc.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Precision: 32 bits'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Range of unsigned right shift (`>>>`): unsigned, [0, 2^(32))'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Range of all other bitwise operators: signed, [−2^(31), 2^(31))'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.9.3 Safe integers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is the range of integer numbers that are *safe* in JavaScript (53 bits
    plus a sign):'
  prefs: []
  type: TYPE_NORMAL
- en: '[–(2^(53))+1, 2^(53)–1]'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An integer is *safe* if it is represented by exactly one JavaScript number.
    Given that JavaScript numbers are encoded as a fraction multiplied by 2 to the
    power of an exponent, higher integers can also be represented, but then there
    are gaps between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example (18014398509481984 is 2^(54)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The following properties of `Number` help determine if an integer is safe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Detecting
    safe integers**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/numbers-math/is_safe_integer_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: 16.9.3.1 Safe computations
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s look at computations involving unsafe integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following result is incorrect and unsafe, even though both of its operands
    are safe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The following result is safe, but incorrect. The first operand is unsafe; the
    second operand is safe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, the result of an expression `a op b` is correct if and only if:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: That is, both operands and the result must be safe.
  prefs: []
  type: TYPE_NORMAL
- en: 16.10 Bitwise operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 16.10.1 Internally, bitwise operators work with 32-bit integers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Internally, JavaScript’s bitwise operators work with 32-bit integers. They
    produce their results in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input (JavaScript numbers): The 1–2 operands are first converted to JavaScript
    numbers (64-bit floating point numbers) and then to 32-bit integers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Computation (32-bit integers): The actual operation processes 32-bit integers
    and produces a 32-bit integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Output (JavaScript number): Before returning the result, it is converted back
    to a JavaScript number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.10.1.1 The types of operands and results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For each bitwise operator, this book mentions the types of its operands and
    its result. Each type is always one of the following two:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description | Size | Range |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Int32 | signed 32-bit integer | 32 bits incl. sign | [−2^(31), 2^(31)) |'
  prefs: []
  type: TYPE_TB
- en: '| Uint32 | unsigned 32-bit integer | 32 bits | [0, 2^(32)) |'
  prefs: []
  type: TYPE_TB
- en: Considering the previously mentioned steps, I recommend to pretend that bitwise
    operators internally work with unsigned 32-bit integers (step “computation”) and
    that Int32 and Uint32 only affect how JavaScript numbers are converted to and
    from integers (steps “input” and “output”).
  prefs: []
  type: TYPE_NORMAL
- en: 16.10.1.2 Displaying JavaScript numbers as unsigned 32-bit integers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'While exploring the bitwise operators, it occasionally helps to display JavaScript
    numbers as unsigned 32-bit integers in binary notation. That’s what `b32()` does
    (whose implementation is shown later):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 16.10.2 Bitwise Not
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Table 9: The bitwise Not operator.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Name | Type signature |  |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `~num` | Bitwise Not, *ones’ complement* | Int32 `→` Int32 | ES1 |'
  prefs: []
  type: TYPE_TB
- en: 'The bitwise Not operator (tbl. [9](#tbl:bitwise-not)) inverts each binary digit
    of its operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This so-called *ones’ complement* is similar to a negative for some arithmetic
    operations. For example, adding an integer to its ones’ complement is always `-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 16.10.3 Binary bitwise operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Table 10: Binary bitwise operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Name | Type signature |  |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `num1 & num2` | Bitwise And | Int32 × Int32 `→` Int32 | ES1 |'
  prefs: []
  type: TYPE_TB
- en: '| `num1 ¦ num2` | Bitwise Or | Int32 × Int32 `→` Int32 | ES1 |'
  prefs: []
  type: TYPE_TB
- en: '| `num1 ^ num2` | Bitwise Xor | Int32 × Int32 `→` Int32 | ES1 |'
  prefs: []
  type: TYPE_TB
- en: 'The binary bitwise operators (tbl. [10](#tbl:binary-bitwise-operators)) combine
    the bits of their operands to produce their results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 16.10.4 Bitwise shift operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Table 11: Bitwise shift operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Name | Type signature |  |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `num << count` | Left shift | Int32 × Uint32 `→` Int32 | ES1 |'
  prefs: []
  type: TYPE_TB
- en: '| `num >> count` | Signed right shift | Int32 × Uint32 `→` Int32 | ES1 |'
  prefs: []
  type: TYPE_TB
- en: '| `num >>> count` | Unsigned right shift | Uint32 × Uint32 `→` Uint32 | ES1
    |'
  prefs: []
  type: TYPE_TB
- en: 'The shift operators (tbl. [11](#tbl:bitwise-shift-operators-short)) move binary
    digits to the left or to the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`>>` preserves highest bit, `>>>` doesn’t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '16.10.5 `b32()`: displaying unsigned 32-bit integers in binary notation'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have now used `b32()` a few times. The following code is an implementation
    of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`n >>> 0` means that we are shifting `n` zero bits to the right. Therefore,
    in principle, the `>>>` operator does nothing, but it still coerces `n` to an
    unsigned 32-bit integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '16.11 Quick reference: numbers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 16.11.1 Global functions for numbers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'JavaScript has the following four global functions for numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isFinite()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isNaN()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parseFloat()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parseInt()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, it is better to use the corresponding methods of `Number` (`Number.isFinite()`,
    etc.), which have fewer pitfalls. They were introduced with ES6 and are discussed
    below.
  prefs: []
  type: TYPE_NORMAL
- en: 16.11.2 Static properties of `Number`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`.EPSILON: number` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between 1 and the next representable floating point number. In
    general, [a machine epsilon](https://en.wikipedia.org/wiki/Machine_epsilon) provides
    an upper bound for rounding errors in floating point arithmetic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Approximately: 2.2204460492503130808472633361816 × 10^(-16)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.MAX_SAFE_INTEGER: number` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The largest integer that JavaScript can represent unambiguously (2^(53)−1).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.MAX_VALUE: number` ^([ES1])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The largest positive finite JavaScript number.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Approximately: 1.7976931348623157 × 10^(308)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.MIN_SAFE_INTEGER: number` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The smallest integer that JavaScript can represent unambiguously (−2^(53)+1).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.MIN_VALUE: number` ^([ES1])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The smallest positive JavaScript number. Approximately 5 × 10^(−324).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.NaN: number` ^([ES1])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same as the global variable `NaN`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.NEGATIVE_INFINITY: number` ^([ES1])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same as `-Number.POSITIVE_INFINITY`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.POSITIVE_INFINITY: number` ^([ES1])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same as the global variable `Infinity`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 16.11.3 Static methods of `Number`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`.isFinite(num: number): boolean` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if `num` is an actual number (neither `Infinity` nor `-Infinity`
    nor `NaN`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.isInteger(num: number): boolean` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if `num` is a number and does not have a decimal fraction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.isNaN(num: number): boolean` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns `true` if `num` is the value `NaN`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.isSafeInteger(num: number): boolean` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if `num` is a number and unambiguously represents an integer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.parseFloat(str: string): number` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coerces its parameter to string and parses it as a floating point number. For
    converting strings to numbers, `Number()` (which ignores leading and trailing
    whitespace) is usually a better choice than `Number.parseFloat()` (which ignores
    leading whitespace and illegal trailing characters and can hide problems).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.parseInt(str: string, radix=10): number` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Coerces its parameter to string and parses it as an integer, ignoring leading
    whitespace and illegal trailing characters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter `radix` specifies the base of the number to be parsed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Do not use this method to convert numbers to integers: coercing to string is
    inefficient. And stopping before the first non-digit is not a good algorithm for
    removing the fraction of a number. Here is an example where it goes wrong:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is better to use one of the rounding functions of `Math` to convert a number
    to an integer:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 16.11.4 Methods of `Number.prototype`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: (`Number.prototype` is where the methods of numbers are stored.)
  prefs: []
  type: TYPE_NORMAL
- en: '`.toExponential(fractionDigits?: number): string` ^([ES3])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a string that represents the number via exponential notation. With `fractionDigits`,
    we can specify, how many digits should be shown of the number that is multiplied
    with the exponent (the default is to show as many digits as necessary).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Example: number too small to get a positive exponent via `.toString()`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Example: fraction not small enough to get a negative exponent via `.toString()`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.toFixed(fractionDigits=0): string` ^([ES3])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns an exponent-free representation of the number, rounded to `fractionDigits`
    digits.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the number is 10^(21) or greater, even `.toFixed()` uses an exponent:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.toPrecision(precision?: number): string` ^([ES3])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Works like `.toString()`, but `precision` specifies how many digits should be
    shown. If `precision` is missing, `.toString()` is used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.toString(radix=10): string` ^([ES1])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a string representation of the number.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'By default, we get a base 10 numeral as a result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we want the numeral to have a different base, we can specify it via `radix`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Number.parseInt()` provides the inverse operation: it converts a string that
    contains an integer (no fraction!) numeral with a given base, to a number.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 16.11.5 Sources
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Wikipedia
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[TypeScript’s built-in typings](https://github.com/Microsoft/TypeScript/blob/master/lib/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MDN web docs for JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ECMAScript language specification](https://tc39.github.io/ecma262/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz: advanced**'
  prefs: []
  type: TYPE_NORMAL
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  prefs: []
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/11)'
  prefs: []
  type: TYPE_NORMAL
