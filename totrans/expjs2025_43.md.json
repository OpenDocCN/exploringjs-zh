["```js\nconst emptyMap = new Map();\nassert.equal(emptyMap.size, 0);\n\n```", "```js\nconst map = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'], // trailing comma is ignored\n]);\n\n```", "```js\nconst map = new Map()\n  .set(1, 'one')\n  .set(2, 'two')\n  .set(3, 'three')\n;\n\n```", "```js\nconst map = new Map();\n\nmap.set('foo', 123);\n\nassert.equal(map.get('foo'), 123);\n// Unknown key:\nassert.equal(map.get('bar'), undefined);\n// Use the default value '' if an entry is missing:\nassert.equal(map.get('bar') ?? '', '');\n\n```", "```js\nconst map = new Map([['foo', 123]]);\n\nassert.equal(map.has('foo'), true);\nassert.equal(map.delete('foo'), true)\nassert.equal(map.has('foo'), false)\n\n```", "```js\nconst map = new Map()\n  .set('foo', true)\n  .set('bar', false)\n;\nassert.equal(map.size, 2)\nmap.clear();\nassert.equal(map.size, 0)\n\n```", "```js\nfunction countChars(chars) {\n  const charCounts = new Map();\n  for (let ch of chars) {\n    ch = ch.toLowerCase();\n    const prevCount = charCounts.get(ch) ?? 0;\n    charCounts.set(ch, prevCount+1);\n  }\n  return charCounts;\n}\n\nconst result = countChars('AaBccc');\nassert.deepEqual(\n  countChars('AaBccc'),\n  new Map([\n    ['a', 2],\n    ['b', 1],\n    ['c', 3],\n  ])\n);\n\n```", "```js\nconst map = new Map()\n  .set(false, 'no')\n  .set(true, 'yes')\n;\nfor (const [key, value] of map) { // (A)\n  console.log(JSON.stringify(key) + ' = ' + JSON.stringify(value));\n}\n\n```", "```js\nfalse = \"no\"\ntrue = \"yes\"\n\n```", "```js\nfor (const key of map.keys()) {\n  console.log(JSON.stringify(key));\n}\n\n```", "```js\nfalse\ntrue\n\n```", "```js\nconst map1 = new Map([\n  ['a', 1],\n  ['b', 2],\n]);\nfor (const key of map1.keys()) {\n  console.log(JSON.stringify(key));\n}\n\n```", "```js\n\"a\"\n\"b\"\n\n```", "```js\nconst map2 = new Map([\n  ['b', 2],\n  ['a', 1],\n]);\nfor (const key of map2.keys()) {\n  console.log(JSON.stringify(key));\n}\n\n```", "```js\n\"b\"\n\"a\"\n\n```", "```js\nconst map = new Map()\n  .set(false, 'no')\n  .set(true, 'yes')\n;\n\nassert.deepEqual(\n  Array.from(map.keys()),\n  [false, true]\n);\nassert.deepEqual(\n  Array.from(map.values()),\n  ['no', 'yes']\n);\nassert.deepEqual(\n  Array.from(map.entries()),\n  [\n    [false, 'no'],\n    [true, 'yes'],\n  ]\n);\n\n```", "```js\nconst map = new Map()\n  .set(false, 'no')\n  .set(true, 'yes')\n;\n\nassert.deepEqual(\n  map.keys().toArray(),\n  [false, true]\n);\nassert.deepEqual(\n  map.values().toArray(),\n  ['no', 'yes']\n);\nassert.deepEqual(\n  map.entries().toArray(),\n  [\n    [false, 'no'],\n    [true, 'yes'],\n  ]\n);\n\n```", "```js\nconst map = new Map([\n  ['a', 1],\n  ['b', 2],\n]);\nconst obj = Object.fromEntries(map);\nassert.deepEqual(\n  obj, {a: 1, b: 2}\n);\n\n```", "```js\nconst obj = {\n  a: 1,\n  b: 2,\n};\nconst map = new Map(Object.entries(obj));\nassert.deepEqual(\n  map, new Map([['a', 1], ['b', 2]])\n);\n\n```", "```js\nconst original = new Map()\n  .set(false, 'no')\n  .set(true, 'yes')\n;\nconst copy = new Map(original);\nassert.deepEqual(original, copy);\n\n```", "```js\nconst map1 = new Map()\n  .set(1, '1a')\n  .set(2, '1b')\n  .set(3, '1c')\n;\n\nconst map2 = new Map()\n  .set(2, '2b')\n  .set(3, '2c')\n  .set(4, '2d')\n;\n\n```", "```js\nconst combinedMap = new Map([...map1, ...map2]); // (A)\nassert.deepEqual(\n  Array.from(combinedMap), // convert to Array for comparison\n  [\n    [ 1, '1a' ],\n    [ 2, '2b' ],\n    [ 3, '2c' ],\n    [ 4, '2d' ],\n  ]\n);\n\n```", "```js\nconst originalMap = new Map()\n  .set(1, 'a')\n  .set(2, 'b')\n  .set(3, 'c')\n;\n\n```", "```js\nconst mappedMap = new Map( // step 3\n  originalMap.entries() // step 1\n  .map(([k, v]) => [k * 2, '_' + v]) // step 2\n);\nassert.deepEqual(\n  mappedMap,\n  new Map([[2,'_a'], [4,'_b'], [6,'_c']])\n);\n\n```", "```js\nconst filteredMap = new Map( // step 3\n  originalMap.entries() // step 1\n  .filter(([k, v]) => k < 3) // step 2\n);\nassert.deepEqual(\n  filteredMap,\n  new Map([[1,'a'], [2,'b']])\n);\n\n```", "```js\nconst map = new Map();\n\nconst KEY1 = {};\nconst KEY2 = {};\n\nmap.set(KEY1, 'hello');\nmap.set(KEY2, 'world');\n\nassert.equal(map.get(KEY1), 'hello');\nassert.equal(map.get(KEY2), 'world');\n\n```", "```js\n> const map = new Map();\n\n> map.set(NaN, 123);\n> map.get(NaN)\n123\n\n```", "```js\n> new Map().set({}, 1).set({}, 2).size\n2\n\n```", "```js\n    new Map<K, V>(\n      entries?: Iterable<[K, V]>\n    )\n\n    ```", "```js\n    const map = new Map([\n      [ 1, 'one' ],\n      [ 2, 'two' ],\n      [ 3, 'three' ], // trailing comma is ignored\n    ]);\n\n    ```", "```js\n    Map.groupBy<K, T>(\n      items: Iterable<T>,\n      computeGroupKey: (item: T, index: number) => K,\n    ): Map<K, Array<T>>;\n\n    ```", "```js\n    assert.deepEqual(\n      Map.groupBy(\n        ['orange', 'apricot', 'banana', 'apple', 'blueberry'],\n        (str) => str[0] // compute group key\n      ),\n      new Map()\n        .set('o', ['orange'])\n        .set('a', ['apricot', 'apple'])\n        .set('b', ['banana', 'blueberry'])\n    );\n\n    ```", "```js\n    const map = new Map([[1, 'one'], [2, 'two']]);\n    assert.equal(map.get(1), 'one');\n    assert.equal(map.get(5), undefined);\n\n    ```", "```js\n    const map = new Map([[1, 'one'], [2, 'two']]);\n    map.set(1, 'ONE!') // update an existing entry\n       .set(3, 'THREE!') // create a new entry\n    ;\n    assert.deepEqual(\n      Array.from(map.entries()),\n      [[1, 'ONE!'], [2, 'two'], [3, 'THREE!']]\n    );\n\n    ```", "```js\n    const map = new Map([[1, 'one'], [2, 'two']]);\n    assert.equal(map.has(1), true); // key exists\n    assert.equal(map.has(5), false); // key does not exist\n\n    ```", "```js\n    const map = new Map([[1, 'one'], [2, 'two']]);\n    assert.equal(map.delete(1), true);\n    assert.equal(map.delete(5), false); // nothing happens\n    assert.deepEqual(\n      Array.from(map.entries()),\n      [[2, 'two']]\n    );\n\n    ```", "```js\n    const map = new Map([[1, 'one'], [2, 'two']]);\n    assert.equal(map.size, 2);\n\n    ```", "```js\n    const map = new Map([[1, 'one'], [2, 'two']]);\n    assert.equal(map.size, 2);\n    map.clear();\n    assert.equal(map.size, 0);\n\n    ```", "```js\n    const map = new Map([[1, 'one'], [2, 'two']]);\n    for (const entry of map.entries()) {\n      console.log(entry);\n    }\n\n    ```", "```js\n    [ 1, 'one' ]\n    [ 2, 'two' ]\n\n    ```", "```js\n    Map.prototype.forEach(\n      callback: (value: V, key: K, theMap: Map<K,V>) => void,\n      thisArg?: any\n    ): void\n\n    ```", "```js\n    const map = new Map([[1, 'one'], [2, 'two']]);\n    map.forEach((value, key) => console.log(value, key));\n\n    ```", "```js\n    one 1\n    two 2\n\n    ```", "```js\n    const map = new Map([[1, 'one'], [2, 'two']]);\n    for (const key of map.keys()) {\n      console.log(key);\n    }\n\n    ```", "```js\n    1\n    2\n\n    ```", "```js\n    const map = new Map([[1, 'one'], [2, 'two']]);\n    for (const value of map.values()) {\n      console.log(value);\n    }\n\n    ```", "```js\n    one\n    two\n\n    ```", "```js\n    const map = new Map([[1, 'one'], [2, 'two']]);\n    for (const [key, value] of map) {\n      console.log(key, value);\n    }\n\n    ```", "```js\n    1 one\n    2 two\n\n    ```", "```js\n    const value = obj.key;\n\n    ```", "```js\n    const theKey = 123;\n    map.get(theKey);\n\n    ```"]