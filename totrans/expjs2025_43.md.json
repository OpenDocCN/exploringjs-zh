["```js\nconst emptyMap = new Map();\nassert.equal(emptyMap.size, 0);\n\n```", "```js\nconst map = new Map([\n [1, 'one'],\n [2, 'two'],\n [3, 'three'], // trailing comma is ignored\n]);\n\n```", "```js\nconst map = new Map()\n .set(1, 'one')\n .set(2, 'two')\n .set(3, 'three')\n;\n\n```", "```js\nconst map = new Map();\n `map.set('foo', 123);`\n `` `assert.equal(map.get('foo'), 123);` `// Unknown key:` `assert.equal(map.get('bar'), undefined);` `// Use the default value '' if an entry is missing:` `assert.equal(map.get('bar') ?? '', '');` `` \n```", "```js```", "````js``` ````", "`````` `map.has()` checks if a Map has an entry with a given key. `map.delete()` removes entries.    ```js const map = new Map([['foo', 123]]);  `assert.equal(map.has('foo'), true);` `assert.equal(map.delete('foo'), true)` `assert.equal(map.has('foo'), false)`  ```   ```js``````", "``` const map = new Map()  .set('foo', true)  .set('bar', false) ; assert.equal(map.size, 2) map.clear(); assert.equal(map.size, 0)  ```", "``` function countChars(chars) {  const charCounts = new Map();  for (let ch of chars) {  ch = ch.toLowerCase();  const prevCount = charCounts.get(ch) ?? 0;  charCounts.set(ch, prevCount+1);  }  return charCounts; }  `const result = countChars('AaBccc');` `assert.deepEqual(`  `countChars('AaBccc'),`  `new Map([`  `['a', 2],`  `['b', 1],`  `['c', 3],`  `])` `);`  ```", "``````js```` ### [36.2 Iterating over Maps](#iterating-over-maps)    This is how Maps support iteration:    *   `new Map()` accepts an iterable over key-value pairs. That will be useful later when we look at processing Maps and at converting from and to Maps. *   The following methods return iterable iterators – whose methods will be useful later when we look at processing Maps.     *   `map.keys()`: keys of `map`     *   `map.values()`: values of `map`     *   `map.entries()`: entries (key-value pairs) of `map`     *   `map[Symbol.iterator]()`: same as `map.entries()`         *   This method makes instances of `Map` iterable.    #### [36.2.1 Looping over Maps](#looping-over-maps)    Maps are iterables over key-value pairs. This is a common way of iterating over them:    ```js const map = new Map()  .set(false, 'no')  .set(true, 'yes') ; for (const [key, value] of map) { // (A)  console.log(JSON.stringify(key) + ' = ' + JSON.stringify(value)); }  ```    In line A, we use destructuring to access the components of the key-value pairs returned by the iterator.    Output:    ```js false = \"no\" true = \"yes\"  ```    The following example loops over the iterable iterator returned by method `.keys()`:    ```js for (const key of map.keys()) {  console.log(JSON.stringify(key)); }  ```    Output:    ```js false true  ```    #### [36.2.2 Listed in insertion order: entries, keys, values](#maps-insertion-order-entries)    Maps record in which order entries were created and honor that order when listing keys, values or entries:    ```js const map1 = new Map([  ['a', 1],  ['b', 2], ]); for (const key of map1.keys()) {  console.log(JSON.stringify(key)); }  ```    Output:    ```js \"a\" \"b\"  ```    ```js const map2 = new Map([  ['b', 2],  ['a', 1], ]); for (const key of map2.keys()) {  console.log(JSON.stringify(key)); }  ```    Output:    ```js \"b\" \"a\"  ```    Maps listing their contents in insertion order has two benefits:    *   We can use a Map when we have a use case where insertion order matters. *   In testing, results become more deterministic and easier to check.    ### [36.3 Converting from and to Maps](#converting-from-and-to-maps)    #### [36.3.1 Converting keys, values, entries to Arrays](#converting-map-entries-to-arrays)    On one hand, the values returned by `.keys()`, `.values()` and `.entries()` are iterables – which enables us to use `Array.from()`:    ```js const map = new Map()  .set(false, 'no')  .set(true, 'yes') ;  `assert.deepEqual(`  `Array.from(map.keys()),`  `[false, true]` `);` `assert.deepEqual(`  `Array.from(map.values()),`  `['no', 'yes']` `);` `assert.deepEqual(`  `Array.from(map.entries()),`  `[`  `[false, 'no'],`  `[true, 'yes'],`  `]` `);`  ```   ```js``````", "```js const map = new Map()  .set(false, 'no')  .set(true, 'yes') ;  `assert.deepEqual(`  `map.keys().toArray(),`  `[false, true]` `);` `assert.deepEqual(`  `map.values().toArray(),`  `['no', 'yes']` `);` `assert.deepEqual(`  `map.entries().toArray(),`  `[`  `[false, 'no'],`  `[true, 'yes'],`  `]` `);`  ```", "```js```", "```js const map = new Map([  ['a', 1],  ['b', 2], ]); const obj = Object.fromEntries(map); assert.deepEqual(  obj, {a: 1, b: 2} );  ```", "```js const obj = {  a: 1,  b: 2, }; const map = new Map(Object.entries(obj)); assert.deepEqual(  map, new Map([['a', 1], ['b', 2]]) );  ```", "```js const original = new Map()  .set(false, 'no')  .set(true, 'yes') ; const copy = new Map(original); assert.deepEqual(original, copy);  ```", "```js const map1 = new Map()  .set(1, '1a')  .set(2, '1b')  .set(3, '1c') ;  `const map2 = new Map()`  `.set(2, '2b')`  `.set(3, '2c')`  `.set(4, '2d')` `;`  ```", "```js```", "```js const combinedMap = new Map([...map1, ...map2]); // (A) assert.deepEqual(  Array.from(combinedMap), // convert to Array for comparison  [  [ 1, '1a' ],  [ 2, '2b' ],  [ 3, '2c' ],  [ 4, '2d' ],  ] );  ```", "```js const originalMap = new Map()  .set(1, 'a')  .set(2, 'b')  .set(3, 'c') ;  ```", "```js const mappedMap = new Map( // step 3  originalMap.entries() // step 1  .map(([k, v]) => [k * 2, '_' + v]) // step 2 ); assert.deepEqual(  mappedMap,  new Map([[2,'_a'], [4,'_b'], [6,'_c']]) );  ```", "```js const filteredMap = new Map( // step 3  originalMap.entries() // step 1  .filter(([k, v]) => k < 3) // step 2 ); assert.deepEqual(  filteredMap,  new Map([[1,'a'], [2,'b']]) );  ```", "```js const map = new Map();  `const KEY1 = {};` `const KEY2 = {};`  ```", "```js  ```", "```js```", "````` #### [36.5.1 What keys are considered equal?](#map-key-equality)    Most Map operations need to check whether a value is equal to one of the keys. They do so via the internal operation [SameValueZero](https://tc39.es/ecma262/#sec-samevaluezero), which works like `===` but considers `NaN` to be equal to itself.    As a consequence, we can use `NaN` as a key in Maps, just like any other value:    ```js > const map = new Map();  `> map.set(NaN, 123);` `> map.get(NaN)` `123`  ```   ```js`Different objects are always considered to be different. That is something that can’t be changed (yet – configuring key equality is on TC39’s long-term roadmap).    ``` > new Map().set({}, 1).set({}, 2).size 2  ```js    ### [36.6 Quick reference: `Map`](#quickref-maps)    Note: For the sake of conciseness, I’m pretending that all keys have the same type `K` and that all values have the same type `V`.    #### [36.6.1 `new Map()`](#new-map)    *   `new Map(entries?)` ES6                    ```     new Map<K, V>(      entries?: Iterable<[K, V]>     )          ```js                    If we don’t provide the parameter `entries`, then an empty Map is created. If we do provide an iterable over [key, value] pairs, then those pairs are added as entries to the Map. For example:                    ```     const map = new Map([      [ 1, 'one' ],      [ 2, 'two' ],      [ 3, 'three' ], // trailing comma is ignored     ]);          ```js              #### [36.6.2 `Map.*`](#map)    *   `Map.groupBy(items, computeGroupKey)` ES2024                    ```     Map.groupBy<K, T>(      items: Iterable<T>,      computeGroupKey: (item: T, index: number) => K,     ): Map<K, Array<T>>;          ```js               *   The callback `computeGroupKey` returns a *group key* for each of the `items`.     *   The result of `Map.groupBy()` is a Map where:         *   The key of each entry is a group key and         *   its value is an Array with all items that have that group key.          ```     assert.deepEqual(      Map.groupBy(      ['orange', 'apricot', 'banana', 'apple', 'blueberry'],      (str) => str[0] // compute group key      ),      new Map()      .set('o', ['orange'])      .set('a', ['apricot', 'apple'])      .set('b', ['banana', 'blueberry'])     );          ```js              #### [36.6.3 `Map.prototype.*`: handling single entries](#mapprototype-handling-single-entries)    *   `Map.prototype.get(key)` ES6                    Returns the `value` that `key` is mapped to in this Map. If there is no key `key` in this Map, `undefined` is returned.                    ```     const map = new Map([[1, 'one'], [2, 'two']]);     assert.equal(map.get(1), 'one');     assert.equal(map.get(5), undefined);          ```js           *   `Map.prototype.set(key, value)` ES6               *   Maps the given key to the given value.     *   If there is already an entry whose key is `key`, it is updated. Otherwise, a new entry is created.     *   This method returns `this`, which means that we can chain it.          ```     const map = new Map([[1, 'one'], [2, 'two']]);     map.set(1, 'ONE!') // update an existing entry      .set(3, 'THREE!') // create a new entry     ;     assert.deepEqual(      Array.from(map.entries()),      [[1, 'ONE!'], [2, 'two'], [3, 'THREE!']]     );          ```js           *   `Map.prototype.has(key)` ES6                    Returns whether the given key exists in this Map.                    ```     const map = new Map([[1, 'one'], [2, 'two']]);     assert.equal(map.has(1), true); // key exists     assert.equal(map.has(5), false); // key does not exist          ```js           *   `Map.prototype.delete(key)` ES6                    If there is an entry whose key is `key`, it is removed and `true` is returned. Otherwise, nothing happens and `false` is returned.                    ```     const map = new Map([[1, 'one'], [2, 'two']]);     assert.equal(map.delete(1), true);     assert.equal(map.delete(5), false); // nothing happens     assert.deepEqual(      Array.from(map.entries()),      [[2, 'two']]     );          ```js              #### [36.6.4 `Map.prototype`: handling all entries](#mapprototype-handling-all-entries)    *   `get Map.prototype.size` ES6                    Returns how many entries this Map has.                    ```     const map = new Map([[1, 'one'], [2, 'two']]);     assert.equal(map.size, 2);          ```js           *   `Map.prototype.clear()` ES6                    Removes all entries from this Map.                    ```     const map = new Map([[1, 'one'], [2, 'two']]);     assert.equal(map.size, 2);     map.clear();     assert.equal(map.size, 0);          ```js              #### [36.6.5 `Map.prototype`: iterating and looping](#mapprototype-iterating-and-looping)    Both iterating and looping happen in the order in which entries were added to a Map.    *   `Map.prototype.entries()` ES6                    Returns an iterable with one [key, value] pair for each entry in this Map. The pairs are Arrays of length 2.                    ```     const map = new Map([[1, 'one'], [2, 'two']]);     for (const entry of map.entries()) {      console.log(entry);     }          ```js                    Output:                    ```     [ 1, 'one' ]     [ 2, 'two' ]          ```js           *   `Map.prototype.forEach(callback, thisArg?)` ES6                    ```     Map.prototype.forEach(      callback: (value: V, key: K, theMap: Map<K,V>) => void,      thisArg?: any     ): void          ```js               *   The first parameter is a callback that is invoked once for each entry in this Map.     *   If `thisArg` is provided, `this` is set to it for each invocation. Otherwise, `this` is set to `undefined`.          ```     const map = new Map([[1, 'one'], [2, 'two']]);     map.forEach((value, key) => console.log(value, key));          ```js                    Output:                    ```     one 1     two 2          ```js           *   `Map.prototype.keys()` ES6                    Returns an iterable over all keys in this Map.                    ```     const map = new Map([[1, 'one'], [2, 'two']]);     for (const key of map.keys()) {      console.log(key);     }          ```js                    Output:                    ```     1     2          ```js           *   `Map.prototype.values()` ES6                    Returns an iterable over all values in this Map.                    ```     const map = new Map([[1, 'one'], [2, 'two']]);     for (const value of map.values()) {      console.log(value);     }          ```js                    Output:                    ```     one     two          ```js           *   `Map.prototype[Symbol.iterator]()` ES6                    The default way of iterating over Maps. Same as `map.entries()`.                    ```     const map = new Map([[1, 'one'], [2, 'two']]);     for (const [key, value] of map) {      console.log(key, value);     }          ```js                    Output:                    ```     1 one     2 two          ```js              ### [36.7 FAQ: Maps](#faq-maps)    #### [36.7.1 When should I use a Map, and when should I use an object?](#when-should-i-use-a-map-and-when-should-i-use-an-object)    If we need a dictionary-like data structure with keys that are neither strings nor symbols, we have no choice: we must use a Map.    If, however, our keys are either strings or symbols, we must decide whether or not to use an object. A rough general guideline is:    *   Is there a fixed set of keys (known at development time)?                    Then use an object `obj` and access the values via fixed keys:                    ```     const value = obj.key;          ```js           *   Can the set of keys change at runtime?                    Then use a Map `map` and access the values via keys stored in variables:                    ```     const theKey = 123;     map.get(theKey);          ```js              #### [36.7.2 When would I use an object as a key in a Map?](#when-would-i-use-an-object-as-a-key-in-a-map)    We normally want Map keys to be compared by value (two keys are considered equal if they have the same content). That excludes objects. However, there is one use case for objects as keys: externally attaching data to objects. But that use case is served better by WeakMaps, where entries don’t prevent keys from being garbage-collected (for details, see [the next chapter](ch_weakmaps.html#ch_weakmaps)).    #### [36.7.3 Why do Maps preserve the insertion order of entries?](#why-do-maps-preserve-the-insertion-order-of-entries)    In principle, Maps entries are unordered. The main reason for ordering entries is so that operations that list entries, keys, or values are deterministic. That helps, for example, with testing.    #### [36.7.4 Why do Maps have a `.size`, while Arrays have a `.length`?](#collection-size-vs-length)    In JavaScript, indexable sequences (such as Arrays and strings) have a `.length`, while unindexed collections (such as Maps and Sets) have a `.size`:    *   `.length` is based on indices; it is always the highest index plus one. *   `.size` counts the number of elements in a collection.```` ```js`` `````", "``````js` ``````", "``````js``` ``````", "```` ```js````", "```js` ```", "```js```", "``` ```", "`````````"]