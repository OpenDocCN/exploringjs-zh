["```js\n123n\n```", "```js\n> 123n * 456n\n56088n\n```", "```js\n> typeof 123n\n'bigint'\n```", "```js\n> 2**53 - 2 // safe\n9007199254740990\n> 2**53 - 1 // safe\n9007199254740991\n\n> 2**53 // unsafe, same as next integer\n9007199254740992\n> 2**53 + 1\n9007199254740992\n> 2**53 + 2\n9007199254740994\n> 2**53 + 3\n9007199254740996\n> 2**53 + 4\n9007199254740996\n> 2**53 + 5\n9007199254740996\n```", "```js\n> 2n**53n\n9007199254740992n\n> 2n**53n + 1n\n9007199254740993n\n> 2n**53n + 2n\n9007199254740994n\n```", "```js\n/**\n * Takes a bigint as an argument and returns a bigint\n */\nfunction nthPrime(nth) {\n if (typeof nth !== 'bigint') {\n throw new TypeError();\n }\n function isPrime(p) {\n for (let i = 2n; i < p; i++) {\n if (p % i === 0n) return false;\n }\n return true;\n }\n for (let i = 2n; ; i++) {\n if (isPrime(i)) {\n if (--nth === 0n) return i;\n }\n }\n}\n\nassert.deepEqual(\n [1n, 2n, 3n, 4n, 5n].map(nth => nthPrime(nth)),\n [2n, 3n, 5n, 7n, 11n]\n);\n```", "```js\nconst massOfEarthInKg = 6_000_000_000_000_000_000_000_000n;\n```", "```js\nconst priceInCents = 123_000_00n; // 123 thousand dollars\n```", "```js\n> 2n + 1\nTypeError: Cannot mix BigInt and other types, use explicit conversions\n```", "```js\n2**53 + 1n\n```", "```js\n2n**53n * 3.3\n```", "```js\n> 7n * 3n\n21n\n```", "```js\n> 6n + ' apples'\n'6 apples'\n```", "```js\n> 1n / 2n\n0n\n```", "```js\n> -(-64n)\n64n\n```", "```js\n> +23n\nTypeError: Cannot convert a BigInt value to a number\n```", "```js\n> 17n <= 17n\ntrue\n> 3n > -1n\ntrue\n```", "```js\n> 3n > -1\ntrue\n```", "```js\n> 2**32-1 >> 0\n-1\n```", "```js\n> 2**31 >> 0 // highest bit is 1\n-2147483648\n> 2**31 - 1 >> 0 // highest bit is 0\n2147483647\n```", "```js\n> ~0b10n\n-3n\n> ~0n\n-1n\n> ~-2n\n1n\n```", "```js\n> (0b1010n |  0b0111n).toString(2)\n'1111'\n> (0b1010n &  0b0111n).toString(2)\n'10'\n\n> (0b1010n | -1n).toString(2)\n'-1'\n> (0b1010n & -1n).toString(2)\n'1010'\n```", "```js\n> 2n << 1n\n4n\n> -2n << 1n\n-4n\n\n> 2n >> 1n\n1n\n> -2n >> 1n\n-1n\n```", "```js\n> -1n >> 20n\n-1n\n```", "```js\n> 2n >>> 1n\nTypeError: BigInts have no unsigned right shift, use >> instead\n```", "```js\n> 0n == false\ntrue\n> 1n == true\ntrue\n\n> 123n == 123\ntrue\n\n> 123n == '123'\ntrue\n```", "```js\n> 123n === 123\nfalse\n> 123n === 123n\ntrue\n```", "```js\n> BigInt(undefined)\nTypeError: Cannot convert undefined to a BigInt\n> BigInt(null)\nTypeError: Cannot convert null to a BigInt\n```", "```js\n> BigInt('abc')\nSyntaxError: Cannot convert abc to a BigInt\n```", "```js\n> BigInt('123n')\nSyntaxError: Cannot convert 123n to a BigInt\n```", "```js\n> BigInt('123')\n123n\n> BigInt('0xFF')\n255n\n> BigInt('0b1101')\n13n\n> BigInt('0o777')\n511n\n```", "```js\n> BigInt(123.45)\nRangeError: The number 123.45 cannot be converted to a BigInt because\nit is not an integer\n> BigInt(123)\n123n\n```", "```js\n> BigInt({valueOf() {return 123n}})\n123n\n```", "```js\nconst uint64a = BigInt.asUintN(64, 12345n);\nconst uint64b = BigInt.asUintN(64, 67890n);\nconst result = BigInt.asUintN(64, uint64a * uint64b);\n```", "```js\n> JSON.stringify(123n)\nTypeError: Do not know how to serialize a BigInt\n> JSON.stringify([123n])\nTypeError: Do not know how to serialize a BigInt\n```", "```js\nconst bigintPrefix = '[[bigint]]';\n\nfunction bigintReplacer(_key, value) {\n if (typeof value === 'bigint') {\n return bigintPrefix + value;\n }\n return value;\n}\n\nconst data = { value: 9007199254740993n };\nassert.equal(\n JSON.stringify(data, bigintReplacer),\n '{\"value\":\"[[bigint]]9007199254740993\"}'\n);\n```", "```js\nfunction bigintReviver(_key, value) {\n if (typeof value === 'string' && value.startsWith(bigintPrefix)) {\n return BigInt(value.slice(bigintPrefix.length));\n }\n return value;\n}\n\nconst str = '{\"value\":\"[[bigint]]9007199254740993\"}';\nassert.deepEqual(\n JSON.parse(str, bigintReviver),\n { value: 9007199254740993n }\n);\n```"]