["```js\n//===== lib.mjs =====\n// Named exports\nexport const one = 1, two = 2;\nexport function myFunc() {\n return 3;\n}\n\n```", "```js\n//===== main.mjs =====\n// Named imports\nimport {one, myFunc as f} from './lib.mjs';\nassert.equal(one, 1);\nassert.equal(f(), 3);\n `// Namespace import`\n`import * as lib from './lib.mjs';`\n`assert.equal(lib.one, 1);`\n`assert.equal(lib.myFunc(), 3);` \n```", "```js```", "````js````", "```js```", "````js` The string after `from` is called a *module specifier*. It identifies from which module we want to import.    #### [29.1.2 Dynamic imports via `import()` ^(ES2020)](#dynamic-imports-via-import-es2020)    So far, all imports we have seen were *static*, with the following constraints:    *   They have to appear at the top level of a module. *   The module specifier is fixed.    Dynamic imports via `import()` don’t have those constraints:    ``` //===== lib.mjs ===== // Named exports export const one = 1, two = 2; export function myFunc() {  return 3; }  ```js    ``` //===== main.mjs ===== function importLibrary(moduleSpecifier) {  return import(moduleSpecifier)  .then((lib) => {  assert.equal(lib.one, 1);  assert.equal(lib.myFunc(), 3);  }); } await importLibrary('./lib.mjs');  ```js    #### [29.1.3 Default exports and imports](#default-exports-and-imports)    A *default export* is most often used when a module only contains a single entity (even though it can be combined with named exports):    ``` //===== lib1.mjs ===== export default function getHello() {  return 'hello'; }  ```js    There can be at most one default export. That’s why `const` or `let` can’t be default-exported (line A):    ``` //===== lib2.mjs ===== export default 123; // (A) instead of `const`  ```js    This is the syntax for importing default exports:    ``` //===== main.mjs ===== import lib1 from './lib1.mjs'; assert.equal(lib1(), 'hello');  `import lib2 from './lib2.mjs';` `assert.equal(lib2, 123);`  ```js   ````", "```````js```````", "```` #### [29.1.4 Kinds of module specifiers](#kinds-of-module-specifiers)    Module specifiers identify modules. There are three kinds of them:    *   *Absolute specifiers* are full URLs – for example:                    ```js     'https://www.unpkg.com/browse/yargs@17.3.1/browser.mjs'     'file:///opt/nodejs/config.mjs'          ```                    Absolute specifiers are mostly used to access libraries that are directly hosted on the web.           *   *Relative specifiers* are relative URLs (starting with `'/'`, `'./'` or `'../'`) – for example:                    ```js     './sibling-module.js'     '../module-in-parent-dir.mjs'     '../../dir/other-module.js'          ```                    Every module has a URL whose protocol depends on its location (`file:`, `https:`, etc.). If it uses a relative specifier, JavaScript turns that specifier into a full URL by resolving it against the module’s URL.                    Relative specifiers are mostly used to access other modules within the same code base.           *   *Bare specifiers* are paths (without protocol and domain) that start with neither slashes nor dots. They begin with the names of packages. Those names can optionally be followed by *subpaths*:                    ```js     'some-package'     'some-package/sync'     'some-package/util/files/path-tools.js'          ```                    Bare specifiers can also refer to packages with scoped names:                    ```js     '@some-scope/scoped-name'     '@some-scope/scoped-name/async'     '@some-scope/scoped-name/dir/some-module.mjs'          ```                    Each bare specifier refers to exactly one module inside a package; if it has no subpath, it refers to the designated “main” module of its package.                    A bare specifier is never used directly but always *resolved* – translated to an absolute specifier. How resolution works depends on the platform.              ### [29.2 JavaScript’s source code units: scripts and modules](#source-code-units)    What does “source code unit” mean in the world of JavaScript?    *   A chunk of JavaScript source code (text) *   Often one unit is stored in a single file. *   We can also embed multiple units in a single HTML file.    JavaScript has a rich history of source code units: ES6 brought built-in modules, but older formats are still around, too. Understanding the latter helps understand the former, so let’s investigate. The next sections describe the following ways of delivering JavaScript source code:    *   *Scripts* are code fragments that browsers run in global scope. They are precursors of modules. *   *CommonJS modules* are a module format designed for servers (e.g., via Node.js). *   *AMD modules* are a module format designed for browsers. *   *ECMAScript modules* are JavaScript’s built-in module format. It supersedes all previous formats.    [Table 29.1](#tbl:source-code-units) gives an overview of these source code units. Note that we can choose between two filename extensions for CommonJS modules and ECMAScript modules. Which choice to make depends on how we want to use a file. Details are given later in this chapter.     |  | Usage | Runs on | Loaded | Filename ext. | | --- | --- | --- | --- | --- | | Script | Legacy | browsers | async | `.js` | | CommonJS module | Decreasing | servers | sync | `.js .cjs` | | AMD module | Legacy | browsers | async | `.js` | | ECMAScript module | Modern | browsers, servers | async | `.js .mjs` |      Table 29.1: Ways of delivering JavaScript source code.      #### [29.2.1 Code before built-in modules was written in ECMAScript 5](#code-before-builtin-modules-was-written-in-ecmascript-5)    Before we get to built-in modules (which were introduced with ES6), all code that we’ll see, will be written in ES5\\. Among other things:    *   ES5 did not have `const` and `let`; only `var`. *   ES5 did not have arrow functions; only function expressions.    ### [29.3 Before we had modules, we had scripts](#scripts)    Initially, browsers only had *scripts* – pieces of code that were executed in global scope. As an example, consider an HTML file that loads script files via the following HTML:    ```js <script src=\"other-module1.js\"></script> <script src=\"other-module2.js\"></script> <script src=\"my-module.js\"></script>  ```    The main file is `my-module.js`, where we simulate a module:    ```js var myModule = (function () { // Open IIFE  // Imports (via global variables)  var importedFunc1 = otherModule1.importedFunc1;  var importedFunc2 = otherModule2.importedFunc2;  `// Body`  `function internalFunc() {`  `// ···`  `}`  `function exportedFunc() {`  `importedFunc1();`  `importedFunc2();`  `internalFunc();`  `}`  ``` ``// Exports (assigned to global variable `myModule`)``  `return {`  `exportedFunc: exportedFunc,`  `};` `})(); // Close IIFE` ```js  ```   ```js````", "```js```", "````js````", "```js```", "````js````", "```js```", "```js // Imports var importedFunc1 = require('./other-module1.js').importedFunc1; var importedFunc2 = require('./other-module2.js').importedFunc2;  `// Body` `function internalFunc() {`  `// ···` `}` `function exportedFunc() {`  `importedFunc1();`  `importedFunc2();`  `internalFunc();` `}`  `` `// Exports` `module.exports = {`  `exportedFunc: exportedFunc,` `};` ``  ```", "```js```", "````js````", "```js```", "```js```", "````js````", "```js```", "``` define(['./other-module1.js', './other-module2.js'],  function (otherModule1, otherModule2) {  var importedFunc1 = otherModule1.importedFunc1;  var importedFunc2 = otherModule2.importedFunc2;  `function internalFunc() {`  `// ···`  `}`  `function exportedFunc() {`  `importedFunc1();`  `importedFunc2();`  `internalFunc();`  `}`   `return {`  `exportedFunc: exportedFunc,`  `};`  `});`  ```", "``````js``````", "`````` AMD can be characterized as follows:    *   Designed for browsers. *   Modules are meant to be loaded *asynchronously*. That’s a crucial requirement for browsers, where code can’t wait until a module has finished downloading. It has to be notified once the module is available. *   The syntax is slightly more complicated.    Benefit of AMD modules (and the reason why they work well for browsers): They can be executed directly. In contrast, CommonJS modules must either be compiled before deployment or custom source code must be generated and evaluated dynamically [(think `eval()`)](ch_dynamic-code-evaluation.html#eval). That isn’t always permitted on the web.    #### [29.4.3 Characteristics of JavaScript modules](#characteristics-of-javascript-modules)    Looking at CommonJS and AMD, similarities between JavaScript module systems emerge:    *   There is one module per file. *   Such a file is basically a piece of code that is executed:     *   Local scope: The code is executed in a local “module scope”. Therefore, by default, all of the variables, functions, and classes declared in it are internal and not global.     *   Exports: If we want any declared entity to be exported, we must explicitly mark it as an export.     *   Imports: Each module can import exported entities from other modules. Those other modules are identified via *module specifiers* (usually paths, occasionally full URLs). *   Modules are *singletons*: Even if a module is imported multiple times, only a single “instance” of it exists. *   No global variables are used. Instead, module specifiers serve as global IDs.    ### [29.5 ECMAScript modules](#ecmascript-modules)    *ECMAScript modules* (*ES modules* or *ESM*) were introduced with ES6\\. They continue the tradition of JavaScript modules and have all of their aforementioned characteristics. Additionally:    *   With CommonJS, ES modules share the compact syntax and support for cyclic dependencies. *   With AMD, ES modules share being designed for asynchronous loading.    ES modules also have new benefits:    *   The syntax is even more compact than CommonJS’s. *   Modules have *static* structures (which can’t be changed at runtime). That helps with static checking, optimized access of imports, dead code elimination, and more. *   Support for cyclic imports is completely transparent.    This is an example of ES module syntax:    ```js import {importedFunc1} from './other-module1.mjs'; import {importedFunc2} from './other-module2.mjs';  `function internalFunc() {`  `···` `}`  `` `export function exportedFunc() {`  `importedFunc1();`  `importedFunc2();`  `internalFunc();` `}` ``  ```   ```js``````", "```````js` ``````js```````", "```` From now on, “module” means “ECMAScript module”.    #### [29.5.1 ES modules: syntax, semantics, loader API](#es-modules-syntax-semantics-loader-api)    The full standard of ES modules comprises the following parts:    1.  Syntax (how code is written): What is a module? How are imports and exports declared? Etc. 2.  Semantics (how code is executed): How are variable bindings exported? How are imports connected with exports? Etc. 3.  A programmatic loader API for configuring module loading.    Parts 1 and 2 were introduced with ES6\\. Work on part 3 is ongoing.    ### [29.6 Named exports and imports](#named-exports-and-imports)    #### [29.6.1 Named exports](#named-exports)    Each module can have zero or more *named exports*.    As an example, consider the following two files:    ```js lib/my-math.mjs main.mjs  ```    Module `my-math.mjs` has two named exports: `square` and `LIGHT_SPEED`.    ```js // Not exported, private to module function times(a, b) {  return a * b; } export function square(x) {  return times(x, x); } export const LIGHT_SPEED = 299792458;  ```    To export something, we put the keyword `export` in front of a declaration. Entities that are not exported are private to a module and can’t be accessed from outside.    #### [29.6.2 Named imports](#named-imports)    Module `main.mjs` has a single named import, `square`:    ```js import {square} from './lib/my-math.mjs'; assert.equal(square(3), 9);  ```    It can also rename its import:    ```js import {square as sq} from './lib/my-math.mjs'; assert.equal(sq(3), 9);  ```    ##### [29.6.2.1 Syntactic pitfall: named importing is not destructuring](#syntactic-pitfall-named-importing-is-not-destructuring)    Both named importing and destructuring look similar:    ```js import {func} from './util.mjs'; // import const {func} = require('./util.mjs'); // destructuring  ```    But they are quite different:    *   Imports remain connected with their exports.           *   We can destructure again inside a destructuring pattern, but the `{}` in an import statement can’t be nested.           *   The syntax for renaming is different:                    ```js     import {func as f} from './util.mjs'; // importing     const {func: f} = require('./util.mjs'); // destructuring          ```                    Rationale: Destructuring is reminiscent of an object literal (including nesting), while importing evokes the idea of renaming.              ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Named exports**    `exercises/modules/export_named_test.mjs`    #### [29.6.3 Namespace imports](#namespace-imports)    *Namespace imports* are an alternative to named imports. If we namespace-import a module, it becomes an object whose properties are the named exports. This is what `main.mjs` looks like if we use a namespace import:    ```js import * as myMath from './lib/my-math.mjs'; assert.equal(myMath.square(3), 9);  `assert.deepEqual(`  `Object.keys(myMath), ['LIGHT_SPEED', 'square']` `);`  ```   ```js````", "```js```", "``` #### [29.6.4 Named exporting styles: inline versus clause (advanced)](#named-exporting-styles-inline-versus-clause-advanced)    The named export style we have seen so far was *inline*: We exported entities by prefixing them with the keyword `export`.    But we can also use separate *export clauses*. For example, this is what `lib/my-math.mjs` looks like with an export clause:    ```", "```   ```", "```````js````` With an export clause, we can rename before exporting and use different names internally:    ```js function times(a, b) {  return a * b; } function sq(x) {  return times(x, x); } const LS = 299792458;  `export {`  `sq as square,`  `LS as LIGHT_SPEED, // trailing comma is optional` `};`  ```   ```js```````", "```` ### [29.7 Default exports and default imports](#default-exports-and-default-imports)    Each module can have at most one *default export*. The idea is that the module *is* the default-exported value.    As an example of default exports, consider the following two files:    ```js my-func.mjs main.mjs  ```    Module `my-func.mjs` has a default export:    ```js const GREETING = 'Hello!'; export default function () {  return GREETING; }  ```    Module `main.mjs` default-imports the exported function:    ```js import myFunc from './my-func.mjs'; assert.equal(myFunc(), 'Hello!');  ```    Note the syntactic difference: the curly braces around named imports indicate that we are reaching *into* the module, while a default import *is* the module.    ![Icon “question”](../Images/3decb3ca67c240d2bb04742c1f28af18.png) **What are use cases for default exports?**    The most common use case for a default export is a module that contains a single function or a single class.    #### [29.7.1 The two styles of default-exporting](#the-two-styles-of-defaultexporting)    There are two styles of doing default exports.    First, we can label existing declarations with `export default`:    ```js export default function myFunc() {} // no semicolon! export default class MyClass {} // no semicolon!  ```    Second, we can directly default-export values. This style of `export default` is much like a declaration.    ```js export default myFunc; // defined elsewhere export default MyClass; // defined previously export default Math.sqrt(2); // result of invocation is default-exported export default 'abc' + 'def'; export default { no: false, yes: true };  ```    ##### [29.7.1.1 Why are there two default export styles?](#why-are-there-two-default-export-styles)    The reason is that `export default` can’t be used to label `const`: `const` may define multiple values, but `export default` needs exactly one value. Consider the following hypothetical code:    ```js // Not legal JavaScript! export default const a = 1, b = 2, c = 3;  ```    With this code, we don’t know which one of the three values is the default export.    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Default exports**    `exercises/modules/export_default_test.mjs`    #### [29.7.2 The default export as a named export (advanced)](#the-default-export-as-a-named-export-advanced)    Internally, a default export is simply a named export whose name is `default`. As an example, consider the previous module `my-func.mjs` with a default export:    ```js const GREETING = 'Hello!'; export default function () {  return GREETING; }  ```    The following module `my-func2.mjs` is equivalent to that module:    ```js const GREETING = 'Hello!'; function greet() {  return GREETING; }  `export {`  `greet as default,` `};`  ```   ```js````", "```js```", "``` import myFunc from './my-func2.mjs'; assert.equal(myFunc(), 'Hello!');  ```", "``` import {default as myFunc} from './my-func2.mjs'; assert.equal(myFunc(), 'Hello!');  ```", "``` import * as mf from './my-func2.mjs'; assert.equal(mf.default(), 'Hello!');  ```", "``` const obj = {  default: 123, }; assert.equal(obj.default, 123);  ```", "``` //===== internal.mjs ===== export function internalFunc() {} export const INTERNAL_DEF = 'hello'; export default 123;  ```", "``` //===== library.mjs ===== // Named re-export [ES6] export {internalFunc as func, INTERNAL_DEF as DEF} from './internal.mjs'; // Wildcard re-export [ES6] export * from './internal.mjs'; // Namespace re-export [ES2020] export * as ns from './internal.mjs';  ```", "``` //===== main.mjs ===== import * as library from './library.mjs';  `assert.deepEqual(`  `Object.keys(library),`  `['DEF', 'INTERNAL_DEF', 'func', 'internalFunc', 'ns']` `);` `assert.deepEqual(`  `Object.keys(library.ns),`  `['INTERNAL_DEF', 'default', 'internalFunc']` `);`  ```", "``````js``````", "```js counter.mjs main.mjs  ```", "```js export let counter = 3; export function incCounter() {  counter++; }  ```", "```js import { counter, incCounter } from './counter.mjs';  ``// The imported value `counter` is live`` `assert.equal(counter, 3);` `incCounter();` `assert.equal(counter, 4);`  ```", "```js```", "````js` Note that while the connection is live and we can read `counter`, we cannot change this variable (e.g., via `counter++`).    There are two benefits to handling imports this way:    *   It is easier to split modules because previously shared variables can become exports. *   This behavior is crucial for supporting transparent cyclic imports. Read on for more information.    #### [29.9.2 ESM’s transparent support for cyclic imports (advanced)](#esms-transparent-support-for-cyclic-imports-advanced)    ESM supports cyclic imports transparently. To understand how that is achieved, consider the following example: [figure 29.1](#fig:module-imports) shows a directed graph of modules importing other modules. P importing M is the cycle in this case.    ![](../Images/e021933bd9279348226080408fab73a2.png)      Figure 29.1: A directed graph of modules importing modules: M imports N and O, N imports P and Q, etc.      After parsing, these modules are set up in two phases:    *   Instantiation: Every module is visited and its imports are connected to its exports. Before a parent can be instantiated, all of its children must be instantiated. *   Evaluation: The bodies of the modules are executed. Once again, children are evaluated before parents.    This approach handles cyclic imports correctly, due to two features of ES modules:    *   Due to the static structure of ES modules, the exports are already known after parsing. That makes it possible to instantiate P before its child M: P can already look up M’s exports.           *   When P is evaluated, M hasn’t been evaluated, yet. However, entities in P can already mention imports from M. They just can’t use them, yet, because the imported values are filled in later. For example, a function in P can access an import from M. The only limitation is that we must wait until after the evaluation of M, before calling that function.                    Imports being filled in later is enabled by them being “live immutable views” on exports.              ### [29.10 Packages: JavaScript’s units for software distribution](#javascript-packages)    In the JavaScripte ecosystem, a *package* is a way of organizing software projects: It is a directory with a standardized layout. A package can contain all kinds of files - for example:    *   A web application written in JavaScript, to be deployed on a server *   JavaScript libraries (for Node.js, for browsers, for all JavaScript platforms, etc.) *   Libraries for programming languages other than JavaScript: TypeScript, Rust, etc. *   Unit tests (e.g. for the libraries in the package) *   Node.js-based shell scripts – e.g., development tools such as compilers, test runners, and documentation generators *   Many other kinds of artifacts    A package can *depend on* other packages (which are called its *dependencies*):    *   Libraries needed by the package’s JavaScript code *   Shell scripts used during development *   Etc.    The dependencies of a package are installed inside that package (we’ll see how soon).    One common distinction between packages is:    *   *Published packages* can be installed by us:     *   Global installation: We can install them globally so that their shell scripts become available at the command line.     *   Local installation: We can install them as dependencies into our own packages. *   *Unpublished packages* never become dependencies of other packages, but do have dependencies themselves. Examples include web applications that are deployed to servers.    The next subsection explains how packages can be published.    #### [29.10.1 Publishing packages: package registries, package managers, package names](#publishing-packages)    The main way of publishing a package is to upload it to a package registry – an online software repository. Two popular public registries are:    *   [The *npm registry*](https://www.npmjs.com) is most widely used and the default when using Node.js. *   [The open-source package registry JSR](https://jsr.io) has special support for TypeScript and was created by the makers of the JavaScript runtime Deno.    Companies can also host their own private registries.    A *package manager* is a command line tool that downloads packages from a registry (or other sources) and installs them as shell scripts and/or as dependencies. The most popular package manager is called *npm* and comes bundled with Node.js. Its name originally stood for “Node Package Manager”. Later, when npm and the npm registry were used not only for Node.js packages, that meaning was changed to “npm is not a package manager” ([source]([https://en.wikipedia.org/wiki/Npm_(software)#Acronym)).](https://en.wikipedia.org/wiki/Npm_(software)#Acronym)).) There are other popular package managers such as jsr, vlt, pnpm and yarn. All of these package managers support either or both of the npm registry and JSR.    Let’s explore how the npm registry works. Each package has a name. There are two kinds of names:    *   *Global names* are unique across the whole registry. These are two examples:                    ```     minimatch     mocha          ```js           *   *Scoped names* consist of two parts: A scope and a name. Scopes are globally unique, names are unique per scope. These are two examples:                    ```     @babel/core     @rauschma/iterable          ```js                    The scope starts with an `@` symbol and is separated from the name with a slash.              #### [29.10.2 The file system layout of a package](#package-file-system-layout)    Once a package `my-package` is fully installed, it almost always looks like this:    ``` my-package/  package.json  node_modules/  [More files]  ```js    What are the purposes of these file system entries?    *   `package.json` is a file every package must have:               *   It contains metadata describing the package (its name, its version, its author, etc.).     *   It lists the dependencies of the package: other packages that it needs, such as libraries and tools. Per dependency, we record:         *   A range of version numbers. Not specifying a specific version allows for upgrades and for code sharing between dependencies.         *   By default, dependencies come from the npm registry. But we can also specify other sources: a local directory, a GZIP file, a URL pointing to a GZIP file, a registry other than npm’s, a git repository, etc. *   `node_modules/` is a directory into which the dependencies of the package are installed. Each dependency also has a `node_modules` folder with its dependencies, etc. The result is a tree of dependencies.              Most packages also have the file `package-lock.json` that sits next to `package.json`: It records the exact versions of the dependencies that were installed and is kept up to date if we add more dependencies via npm.    #### [29.10.3 `package.json`](#packagejson)    This is a starter `package.json` that can be created via npm:    ``` {  \"name\": \"my-package\",  \"version\": \"1.0.0\",  \"description\": \"\",  \"main\": \"index.js\",  \"scripts\": {  \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"  },  \"keywords\": [],  \"author\": \"\",  \"license\": \"ISC\" }  ```js    What are the purposes of these properties?    *   Some properties are required for public packages (published on the npm registry):               *   `name` specifies the name of this package.     *   `version` is used for version management and follows [semantic versioning](https://semver.org) with three dot-separated numbers:         *   The *major version* is incremented when incompatible API changes are made.         *   The *minor version* is incremented when functionality is added in a backward compatible manner.         *   The *patch version* is incremented when small changes are made that don’t really change the functionality. *   Other properties for public packages are optional:               *   `description`, `keywords`, `author` are optional and make it easier to find packages.     *   `license` clarifies how this package can be used. It makes sense to provide this value if the package is public in any way. [“Choose an open source license”](https://choosealicense.com) can help with making this choice. *   `main` is a legacy property and has been superseded by `exports`. It points to the code of a library package.           *   `scripts` is a property for setting up abbreviations for development-time shell commands. These can be executed via `npm run`. For example, the script `test` can be executed via `npm run test`.              More useful properties:    *   Normally, the properties `name` and `version` are required and npm warns us if they are missing. However, we can change that via the following setting:                    ```     \"private\": true          ```js                    That prevents the package from accidentally being published and allows us to omit name and version.           *   `exports` is for *package exports* – which specify how importers see the content of this package. We’ll learn more about package exports [later](#package-exports).           *   `imports` is for *package imports* – which define aliases for module specifiers that packages can use internally. We’ll learn more about package imports [later](#package-imports).           *   `dependencies` lists the dependencies of a package.           *   `devDependencies` are dependencies that are only installed during development (not when a package is added as a dependency).           *   The following setting means that all files with the name extension `.js` are interpreted as ECMAScript modules. Unless we are dealing with legacy code, it makes sense to add it:                    ```     \"type\": \"module\"          ```js           *   `bin` lists modules within the package that are installed as shell scripts.              ![Icon “external”](../Images/38e6ff55e8d602659f3cdb8893e63f62.png) **More information on `package.json`**    See [the npm documentation](https://docs.npmjs.com/files/package.json).    #### [29.10.4 Package exports: controlling what other packages see](#package-exports)    [*Package exports*](https://nodejs.org/api/packages.html#packages_package_entry_points) are specified via property `\"exports\"` in `package.json` and support three important features:    *   Hiding the internals of a package:               *   Without property `\"exports\"`, every module in a package `my-lib` can be accessed via a relative path after the package name – e.g.:                                    ```         'my-lib/dist/src/internal/internal-module.js'                  ```js                       *   Once the property exists, only specifiers listed in it can be used. Everything else is hidden from the outside.                   *   Nicer module specifiers: Package exports let us change the bare specifier subpaths for importing the modules of a package: They can be shorter, extension-less, etc.           *   Conditional exports: The same module specifier exports different modules – depending on which JavaScript platform an importer uses (browser, Node.js, etc.).              Next, we’ll look at some example. For a more detailed explanation of how package exports work, see section [“Package exports: controlling what other packages see”](https://exploringjs.com/nodejs-shell-scripting/ch_packages.html#package-exports-controlling-what-other-packages-see) in “Shell scripting with Node.js”.    ##### [29.10.4.1 Examples: package exports](#examples-package-exports)    Example – specifying which module is imported via the bare specifier of a package (in the past, this was specified via property `main`):    ``` \"exports\": {  \".\": \"./dist/src/main.js\" }  ```js    Example – specifying a better path for a module:    ``` \"exports\": {  // With filename extension  \"./util/errors.js\": \"./dist/src/util/errors.js\",  `// Without filename extension`  `\"./util/errors\": \"./dist/src/util/errors.js\"` `}`  ```js   ````", "```` Example – specifying better paths for a tree of modules:    ```js \"exports\": {  // With filename extensions  \"./*\": \"./dist/src/*\",  `// Without filename extensions`  `\"./*\": \"./dist/src/*.js\"` `}`  ```   ```js````", "```js \"exports\": {  \".\": {  \"node\": \"./main-node.js\",  \"browser\": \"./main-browser.js\",  \"default\": \"./main-browser.js\"  } }  ```", "```js \"exports\": {  \".\": {  \"development\": \"./main-development.js\",  \"production\": \"./main-production.js\",  } }  ```", "```js node --conditions development app.mjs  ```", "```js {  \"imports\": {  \"#some-pkg\": {  \"node\": \"some-pkg-node-native\",  \"default\": \"./polyfills/some-pkg-polyfill.js\"  }  },  \"dependencies\": {  \"some-pkg-node-native\": \"^1.2.3\"  } }  ```", "```js \"imports\": {  \"#root/*\": \"./*\" },  ```", "```js import pkg from '#root/package.json' with { type: 'json' }; console.log(pkg.version);  ```", "```js \"imports\": {  \"#pkg\": \"./package.json\" },  ```", "```js import pkg from '#pkg' with { type: 'json' }; console.log(pkg.version);  ```", "```js     ./my-module.mjs     ./some-func.mjs          ```", "```js     import * as myModule from './my-module.mjs';          ```", "```js     import someFunc from './some-func.mjs';          ```", "```js     'https://www.unpkg.com/browse/yargs@17.3.1/browser.mjs'     'file:///opt/nodejs/config.mjs'          ```", "```js     './sibling-module.js'     '../module-in-parent-dir.mjs'     '../../dir/other-module.js'          ```", "```js     'some-package'     'some-package/sync'     'some-package/util/files/path-tools.js'          ```", "```js     '@some-scope/scoped-name'     '@some-scope/scoped-name/async'     '@some-scope/scoped-name/dir/some-module.mjs'          ```", "```js         'my-library'                  ```", "```js         'my-parser/sync'         'my-parser/async'          `'assertions'`         `'assertions/strict'`          ```", "```js` *   Style 3: a subpath with a filename extension. In this case, the package is seen as a collection of modules and the subpath points to one of them:                    ```", "```js ```", "```js```", "```js --input-type=module  ```", "```js <script type=\"module\">  // Inline module </script>  ```", "```js <!-- Absolute module specifier --> <script type=\"module\" src=\"https://unpkg.com/lodash\"></script>  `<!-- Relative module specifier -->` `<script type=\"module\" src=\"bundle.js\"></script>`  ```", "```js```", "```js https://unpkg.com/«package»@«version»/«file»  ```", "```js https://unpkg.com/lodash@4.17.21/lodash.js  ```", "```js my-web-app/  assets/  lodash-es.js  src/  main.js  ```", "```js import {pick} from '../assets/lodash-es.js';  ```", "```js <script type=\"importmap\"> {  \"imports\": {  \"lodash-es\": \"./assets/lodash-es.js\"  } } </script>  ```", "```js <script type=\"importmap\" src=\"imports.importmap\"></script>  ```", "```js import {pick} from 'lodash-es';  ```", "```js 'https://example.com/code/main.mjs'  ```", "```js new URL(input: string, base?: string|URL)  ```", "```js > new URL('other.mjs', 'https://example.com/code/main.mjs').href 'https://example.com/code/other.mjs' > new URL('../other.mjs', 'https://example.com/code/main.mjs').href 'https://example.com/other.mjs'  ```", "```js const urlOfData = new URL('data.txt', import.meta.url);  ```", "```js 'file:///Users/rauschma/my-module.mjs'  ```", "```js import * as fs from 'node:fs'; function readData() {  // data.txt sits next to current module  const urlOfData = new URL('data.txt', import.meta.url);  return fs.readFileSync(urlOfData, {encoding: 'UTF-8'}); }  ```", "```js assert.equal(  new URL('file:///tmp/with%20space.txt').pathname,  '/tmp/with%20space.txt');  ```", "```js import * as url from 'node:url'; assert.equal(  url.fileURLToPath('file:///tmp/with%20space.txt'),  '/tmp/with space.txt'); // result on Unix  ```", "```js const namespaceObject = await import(moduleSpecifierStr); console.log(namespaceObject.namedExport);  ```", "```js lib/my-math.mjs main1.mjs main2.mjs  ```", "```js // Not exported, private to module function times(a, b) {  return a * b; } export function square(x) {  return times(x, x); } export const LIGHT_SPEED = 299792458;  ```", "```js // main1.mjs const moduleSpecifier = './lib/my-math.mjs';  `async function getLightSpeedAsync() {`  `const myMath = await import(moduleSpecifier);`  `return myMath.LIGHT_SPEED;` `}`  `` `const result = await getLightSpeedAsync();` `assert.equal(result, 299792458);` ``  ```", "```js```", "````` Two things in this code can’t be done with `import` statements:    *   We are importing inside a function (not at the top level). *   The module specifier comes from a variable.    ![Icon “question”](../Images/3decb3ca67c240d2bb04742c1f28af18.png) **Why is `import()` an operator and not a function?**    `import()` looks like a function but couldn’t be implemented as a function:    *   It needs to know the URL of the current module in order to resolve relative module specifiers. *   If `import()` were a function, we’d have to explicitly pass this information to it (e.g. via an parameter). *   In contrast, an operator is a core language construct and has implicit access to more data, including the URL of the current module.    #### [29.14.3 Use cases for `import()`](#use-cases-for-import)    ##### [29.14.3.1 Loading code on demand](#loading-code-on-demand)    Some functionality of web apps doesn’t have to be present when they start, it can be loaded on demand. Then `import()` helps because we can put such functionality into modules – for example:    ```js button.addEventListener('click', async (event) => {  const dialogBox = await import('./dialogBox.mjs');  dialogBox.open(); });  ```    ##### [29.14.3.2 Conditional loading of modules](#conditional-loading-of-modules)    We may want to load a module depending on whether a condition is true. For example, a module with [a polyfill](#polyfills) that makes a new feature available on legacy platforms:    ```js if (isLegacyPlatform()) {  await import('./my-polyfill.mjs'); }  ```    ##### [29.14.3.3 Computed module specifiers](#computed-module-specifiers)    For applications such as internationalization, it helps if we can dynamically compute module specifiers:    ```js const message = await import(`messages_${getLocale()}.mjs`);  ```    ### [29.15 Top-level `await` in modules ^(ES2022) (advanced)](#top-level-await)    ![Icon “reading”](../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png) **`await` is a feature of async functions**    `await` is explained in [“Async functions ^(ES2017)” (§44)](ch_async-functions.html#ch_async-functions). It may make sense to postpone reading this section until you understand async functions.    We can use the `await` operator at the top level of a module. If we do that, the module becomes asynchronous and works differently. Thankfully, we don’t usually see that as programmers because it is handled transparently by the language.    #### [29.15.1 Use cases for top-level `await`](#use-cases-for-toplevel-await)    Why would we want to use the `await` operator at the top level of a module? It lets us initialize a module with asynchronously loaded data. The next three subsections show three examples of where that is useful.    ##### [29.15.1.1 Loading modules dynamically](#loading-modules-dynamically)    ```js const params = new URLSearchParams(location.search); const language = params.get('lang'); const messages = await import(`./messages-${language}.mjs`); // (A)  `console.log(messages.welcome);`  ```   ```js`In line A, we [dynamically import](#dynamic-imports) a module. Thanks to top-level `await`, that is almost as convenient as using a normal, static import.    ##### [29.15.1.2 Using a fallback if module loading fails](#using-a-fallback-if-module-loading-fails)    ``` let mylib; try {  mylib = await import('https://primary.example.com/mylib'); } catch {  mylib = await import('https://secondary.example.com/mylib'); }  ```js    ##### [29.15.1.3 Using whichever resource loads fastest](#using-whichever-resource-loads-fastest)    ``` const resource = await Promise.any([  fetch('http://example.com/first.txt')  .then(response => response.text()),  fetch('http://example.com/second.txt')  .then(response => response.text()), ]);  ```js    Due to [`Promise.any()`](ch_promises.html#Promise.any), variable `resource` is initialized via whichever download finishes first.    #### [29.15.2 How does top-level `await` work under the hood?](#how-does-toplevel-await-work-under-the-hood)    Consider the following two files.    `first.mjs`:    ``` const response = await fetch('http://example.com/first.txt'); export const first = await response.text();  ```js    `main.mjs`:    ``` import {first} from './first.mjs'; import {second} from './second.mjs'; assert.equal(first, 'First!'); assert.equal(second, 'Second!');  ```js    Both are roughly equivalent to the following code:    `first.mjs`:    ``` export let first; export const promise = (async () => { // (A)  const response = await fetch('http://example.com/first.txt');  first = await response.text(); })();  ```js    `main.mjs`:    ``` import {promise as firstPromise, first} from './first.mjs'; import {promise as secondPromise, second} from './second.mjs'; export const promise = (async () => { // (B)  await Promise.all([firstPromise, secondPromise]); // (C)  assert.equal(first, 'First!');  assert.equal(second, 'Second!'); })();  ```js    A module becomes asynchronous if:    1.  It directly uses top-level `await` (`first.mjs`). 2.  It imports one or more asynchronous modules (`main.mjs`).    Each asynchronous module exports a Promise (line A and line B) that is fulfilled after its body was executed. At that point, it is safe to access the exports of that module.    In case (2), the importing module waits until the Promises of all imported asynchronous modules are fulfilled, before it enters its body (line C). Synchronous modules are handled as usually.    Awaited rejections and synchronous exceptions are managed as in async functions.    #### [29.15.3 The pros and cons of top-level `await`](#the-pros-and-cons-of-toplevel-await)    What are the pros and cons of top-level `await`?    *   Pros:               *   It is convenient to have this operator available at the top level of a module, especially for dynamically imported modules.     *   It obviates the need for complicated techniques to ensure that importers don’t access data before it is ready.     *   Tt supports asynchronicity transparently: Importers do not need to know if an imported module is asynchronous or not. *   Cons:               *   Top-level `await` delays the initialization of importing modules. Therefore, it’s best used sparingly. Asynchronous tasks that take longer are better performed later, on demand. However, even modules without top-level `await` can block importers (e.g. via an infinite loop at the top level), so blocking per se is not an argument against it.     *   On Node.js, ESM modules that use top-level `await` cannot be required from CommonJS. That matters if you write an ESM-based package and want it to be usable from CommonJS code bases. For more information, see section [“Loading ECMAScript modules using `require()`”](https://nodejs.org/api/modules.html#loading-ecmascript-modules-using-require) in the Node.js documentation.    ### [29.16 Import attributes: importing non-JavaScript artifacts ^(ES2025)](#import-attributes)    #### [29.16.1 The history of importing non-JavaScript artifacts](#the-history-of-importing-nonjavascript-artifacts)    Importing artifacts that are not JavaScript code as modules, has a long tradition in the JavaScript ecosystem. For example, the JavaScript module loader RequireJS has support for so-called [*plugins*](https://requirejs.org/docs/plugins.html). To give you a feeling for how old RequireJS is: Version 1.0.0 was released in 2009\\. Specifiers of modules that are imported via a plugin look like this:    ``` '«specifier-of-plugin-module»!«specifier-of-artifact»'  ```js    For example, the following module specifier imports a file as JSON:    ``` 'json!./data/config.json'  ```js    Inspired by RequireJS, webpack supports the same module specifier syntax for its [*loaders*](https://webpack.js.org/loaders/).    #### [29.16.2 Use cases for importing non-JavaScript artifacts](#use-cases-for-importing-nonjavascript-artifacts)    These are a few use cases for importing non-JavaScript artifacts:    *   Importing JSON configuration data *   Importing WebAssembly code as if it were a JavaScript module *   Importing CSS to build user interfaces    For more use cases, you can take a look at [the list of webpack’s loaders](https://webpack.js.org/loaders/).    #### [29.16.3 Import attributes](#import-attributes-1)    The motivating use case for import attributes was importing JSON data as a module. That looks as follows:    ``` import configData from './config-data.json' with { type: 'json' };  ```js    `type` is an import attribute (more on the syntax soon).    You may wonder why a JavaScript engine can’t use the filename extension `.json` to determine that this is JSON data. However, a core architectural principle of the web is to never use the filename extension to determine what’s inside a file. Instead, content types are used.    If a server is set up correctly then why not do a normal import and omit the import attributes?    *   The server may be deliberately misconfigured – e.g., an external server not controlled by the people who wrote the code. It could swap an imported JSON file with code that would be executed by the importer. *   The server may be accidentally misconfigured. With import attributes, we get feedback more quickly. *   Given that the expected content type is not explicit in the code, the attributes also document the expectations of the programmer.    #### [29.16.4 The syntax of import attributes](#the-syntax-of-import-attributes)    Let’s examine in more detail what import attributes look like.    ##### [29.16.4.1 Static import statements](#static-import-statements)    We have already seen a normal (static) import statement:    ``` import configData from './config-data.json' with { type: 'json' };  ```js    The import attributes start with the keyword `with`. That keyword is followed by an object literal. For now, the following object literal features are supported:    *   Unquoted keys and quoted keys *   The values must be strings    There are no other syntactic restrictions placed on the keys and the values, but engines should throw an exception if they don’t support a key and/or a value:    *   Attributes change what is imported, so simply ignoring them is risky because that changes the runtime behavior of code. *   A side benefit is that this makes it easier to add more features in the future because no one will use keys and values in unexpected ways.    ##### [29.16.4.2 Dynamic imports](#dynamic-imports-1)    To support import attributes, [dynamic imports](import-operator) get a second parameter – an object with configuration data:    ``` const configData = await import(  './config-data.json', { with: { type: 'json' } } );  ```js    The import attributes don’t exist at the top level; they are specified via the property `with`. That makes it possible to add more configuration options in the future.    ##### [29.16.4.3 Re-export statements](#reexport-statements)    A re-export imports and exports in a single step. For the former, we need attributes:    ``` export { default as config } from './config-data.json' with { type: 'json' };  ```js    #### [29.16.5 JSON modules ^(ES2025)](#json-modules)    Import attributes are really just syntax. They lay the foundation for actual features that make use of that syntax. The first ECMAScript feature based on import attributes is JSON modules – which we’ve already seen in action:    This is a file `config-data.json`:    ``` {  \"version\": \"1.0.0\",  \"maxCount\": 20 }  ```js    It sits next to the following ECMAScript module `main.js`:    ``` import configData from './config-data.json' with { type: 'json' }; assert.deepEqual(  configData,  {  version: '1.0.0',  maxCount: 20  } );  ```js    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Importing JSON**    `exercises/modules/get-version_test.mjs`    ### [29.17 Polyfills: emulating native web platform features (advanced)](#polyfills)    ![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **Backends have polyfills, too**    This section is about frontend development and web browsers, but similar ideas apply to backend development.    *Polyfills* help with a conflict that we are facing when developing a web application in JavaScript:    *   On one hand, we want to use modern web platform features that make the app better and/or development easier. *   On the other hand, the app should run on as many browsers as possible.    Given a web platform feature X:    *   A *polyfill* for X is a piece of code. If it is executed on a platform that already has built-in support for X, it does nothing. Otherwise, it makes the feature available on the platform. In the latter case, the polyfilled feature is (mostly) indistinguishable from a native implementation. In order to achieve that, the polyfill usually makes global changes. For example, it may modify global data or configure a global module loader. Polyfills are often packaged as modules.               *   The term [*polyfill*](https://remysharp.com/2010/10/08/what-is-a-polyfill) was coined by Remy Sharp. *   A *speculative polyfill* is a polyfill for a proposed web platform feature (that is not standardized, yet).               *   Alternative term: *prollyfill* *   A *replica* of X is a library that reproduces the API and functionality of X locally. Such a library exists independently of a native (and global) implementation of X.               *   *Replica* is a new term introduced in this section. Alternative term: *ponyfill* *   There is also the term *shim*, but it doesn’t have a universally agreed upon definition. It often means roughly the same as *polyfill*.              Every time our web applications starts, it must first execute all polyfills for features that may not be available everywhere. Afterwards, we can be sure that those features are available natively.    #### [29.17.1 Sources of this section](#sources-of-this-section)    *   [“What is a Polyfill?”](https://remysharp.com/2010/10/08/what-is-a-polyfill) by Remy Sharp *   Inspiration for the term *replica*: [The Eiffel Tower in Las Vegas](https://en.wikipedia.org/wiki/Paris_Las_Vegas) *   Useful clarification of “polyfill” and related terms: [“Polyfills and the evolution of the Web”](https://www.w3.org/2001/tag/doc/polyfills/). Edited by Andrew Betts.```` ```js`` `````", "``````js` ``````", "``````js``` ``````", "```` ```js````", "```js` ```", "```js```", "``` ```", "```````js``` ``````js```````", "``````js``````", "``````js``````", "``` ```", "```js```", "````js````", "```js```", "````js````", "```js` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "``````js``````", "```````js` ``````js```````", "```````js`` ``````js```````", "```````js``` ``````js```````", "```````js```` ```js```````", "```````js```````"]