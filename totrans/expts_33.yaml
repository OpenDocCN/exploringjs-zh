- en: 27 Typing functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/ts/book/ch_typing-functions.html](https://exploringjs.com/ts/book/ch_typing-functions.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Ad, please don’t block.)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '[27.1 Defining statically typed functions](#defining-statically-typed-functions)'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.1.1 Function declarations](#function-declarations)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.1.2 Arrow functions](#arrow-functions)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.2 Types for functions](#types-for-functions)'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.2.1 Function type signatures](#function-type-signatures)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.2.2 Interfaces with call signatures](#call-signatures)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.2.3 Checking if a callable value matches a function type](#checking-if-a-callable-value-matches-a-function-type)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.3 Parameters](#parameters)'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.3.1 When do parameters have to be type-annotated?](#when-do-parameters-have-to-be-type-annotated)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.3.2 Optional parameters](#optional-parameters-1)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.3.3 Rest parameters](#rest-parameters-1)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.3.4 Named parameters](#named-parameters)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.3.5 `this` as a parameter (advanced)](#this-as-a-parameter-advanced)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.4 Return type `never`: functions that don’t return](#return-type-never)'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.4.1 Reasons against the return type `never | T`](#reasons-against-the-return-type-never-t)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.4.2 The return type `never` in `@types/node`](#the-return-type-never-in-types-node)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.5 Overloading (advanced)](#overloading-advanced)'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.5.1 Overloading function declarations](#overloading-function-declarations)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.5.2 Overloading functions via a union of tuple types](#overloading-functions-via-a-union-of-tuple-types)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.5.3 Overloading functions via interfaces](#overloading-functions-via-interfaces)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.5.4 Overloading on string parameters (event handling etc.)](#overloading-on-string-parameters)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.5.5 Overloading methods](#overloading-methods)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.6 Assignability (advanced)](#assignability)'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.6.1 The rules for assignability](#the-rules-for-assignability)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.6.2 Consequences of the assignment rules for functions](#consequences-of-the-assignment-rules-for-functions)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[27.7 Further reading and sources of this chapter](#further-reading-and-sources-of-this-chapter)'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This chapter explores static typing for functions in TypeScript.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “reading”](../Images/00b0d6029a045810b908b88d1a6733d2.png) **in this
    chapter, “function” means “function or method or constructor”**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, most things that are said about functions (especially w.r.t.
    parameter handling), also apply to methods and constructors.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[27.1 Defining statically typed functions](#defining-statically-typed-functions)'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[27.1.1 Function declarations](#function-declarations)'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is an example of a function declaration in TypeScript:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Parameters: If the compiler option `--noImplicitAny` is on (which it is if
    `--strict` is on), then the type of each parameter must be either inferrable or
    explicitly specified. (We’ll take a closer look at inference later.) For parameters,
    no inference is possible, which is why `str` and `times` have type annotations.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Return type: By default, the return type of functions is inferred. That is
    usually good enough. We opted to explicitly specify that `repeat1()` has the return
    type `string` (last type annotation in line A).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[27.1.2 Arrow functions](#arrow-functions)'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The arrow function version of `repeat1()` looks as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Arrow functions can also have expression bodies:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[27.2 Types for functions](#types-for-functions)'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[27.2.1 Function type signatures](#function-type-signatures)'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can define types for functions via function type signatures:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The name of this function type is `Repeat`. It has:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Two parameters whose types are `string` and `number`. We need to name parameters
    in function type signatures, but the names are ignored when checking if two function
    types are compatible.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return type `string`. Note that this time, the type is separated by an arrow
    and can’t be omitted.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which functions are assignable to this type? At least those that have the same
    parameter types and return type. But some others are assignable too. We’ll see
    which ones, when we explore the rules for [*assignability*](#assignability) later
    in this chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[27.2.2 Interfaces with call signatures](#call-signatures)'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can also use interfaces to define function types:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The interface member in line A is a *call signature*. It looks similar to a
    method signature, but doesn’t have a name.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of the result is separated by a colon (not an arrow) and can’t be omitted.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On one hand, interfaces are more verbose. On the other hand, they let us specify
    properties of functions (which is rare, but does happen):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can also specify properties via an intersection type (`&`) of a function
    signature type and an object literal type:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[27.2.3 Checking if a callable value matches a function type](#checking-if-a-callable-value-matches-a-function-type)'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As an example, consider this scenario: A library exports the following function
    type.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We want to define a function whose type is compatible with `StringPredicate`.
    And we want to check immediately if that’s indeed the case (vs. finding out later
    when we use it for the first time).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[27.2.3.1 Checking arrow functions](#checking-arrow-functions)'
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If we declare a variable via `const`, we can perform the check via a type annotation:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that we don’t need to specify the type of parameter `str` because TypeScript
    can use `StringPredicate` to infer it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[27.2.3.2 Checking function declarations (simple)](#checking-function-declarations-simple)'
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Checking function declarations is more complicated. Consider the following
    function declaration:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These are two built-in ways in which we can check assignability:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`satisfies` is explained in [“The `satisfies` operator” (§29)](ch_satisfies.html#ch_satisfies).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two checks require the library `asserttt`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that all checks but the last one produce unnecessary JavaScript code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[27.2.3.3 Checking function declarations (extravagant)](#checking-function-declarations-extravagant)'
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following solution is something you’d usually not do – so no worries if
    you don’t fully understand it. But it nicely demonstrates several advanced features:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Parameters: We use the utility type `Parameters<>` to extract a tuple with
    the parameter types. The three dots declare a rest parameter, which collects all
    parameters in a tuple/Array. `[str]` destructures that tuple. (More on rest parameters
    later in this chapter.)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Return value: We use the utility type `ReturnType<>` to extract the return
    type.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The built-in utility types `Parameters<>` and `ReturnType<>` are explained in
    [“Extracting parts of function types via `infer`” (§35.3.1)](ch_infer-keyword.html#extracting-parts-of-function-types).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[27.3 Parameters](#parameters)'
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[27.3.1 When do parameters have to be type-annotated?](#when-do-parameters-have-to-be-type-annotated)'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Recap: If `--noImplicitAny` is switched on (`--strict` switches it on), the
    type of each parameter must either be inferrable or explicitly specified.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, TypeScript can’t infer the type of `str` and we must
    specify it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In line A, TypeScript can use the type `StringMapFunction` to infer the type
    of `str` and we don’t need to add a type annotation:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, TypeScript can use the type of `.map()` to infer the type of `str`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is the type of `.map()`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[27.3.2 Optional parameters](#optional-parameters-1)'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, we look at several ways in which we can allow parameters to
    be omitted.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[27.3.2.1 Optional parameter: `str?: string`](#optional-parameter-str-string)'
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If we put a question mark after the name of a parameter, that parameter becomes
    optional and can be omitted when calling the function:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is how `trim1()` can be invoked:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As an aside, the following two types are equal (`Equal<>` is a strict check)
    because the optional modifier (`?`) implies the type `undefined`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[27.3.2.2 Union type: `str: string | undefined`](#union-type-str-string-undefined)'
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Externally, parameter `str` of `trim1()` has the type `string | undefined`.
    Therefore, `trim1()` is mostly equivalent to the following function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The only way in which `trim2()` is different from `trim1()` is that the parameter
    can’t be omitted in function calls (line A). In other words: We must be explicit
    when omitting a parameter whose type is `T|undefined`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[27.3.2.3 Parameter default value: `str = ''''`](#parameter-default-value-str)'
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If we specify a parameter default value for `str`, we don’t need to provide
    a type annotation because TypeScript can infer the type:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The internal type of `str` is `string` because the default value ensures that
    it is never `undefined`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s invoke `trim3()`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[27.3.2.4 Parameter default value plus type annotation](#parameter-default-value-plus-type-annotation)'
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can also specify both a type and a default value:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[27.3.3 Rest parameters](#rest-parameters-1)'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A rest parameter collects all remaining parameters in an Array. Therefore, its
    static type is an Array or a tuple.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[27.3.3.1 Rest parameters with Array types](#rest-parameters-with-array-types)'
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the following example, the rest parameter `parts` has an Array type:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[27.3.3.2 Rest parameters with tuple types](#rest-parameters-with-tuple-types)'
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The next example demonstrates two features:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: We use the tuple type `[string, number]` for a rest parameter.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We destructure the rest parameter – which is a JavaScript feature.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`repeat1()` is equivalent to the following function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[27.3.4 Named parameters](#named-parameters)'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[*Named parameters*](https://exploringjs.com/js/book/ch_callables.html#named-parameters)
    are a popular pattern in JavaScript where an object literal is used to give each
    parameter a name. That looks as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In plain JavaScript, functions can use destructuring to access named parameter
    values. Alas, in TypeScript, we additionally have to specify a type for the object
    literal and that leads to redundancies:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that the destructuring (incl. the default value for `fillStr`) all happens
    in line A, while line B is exclusively about TypeScript.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also define a separate type instead of the inlined object literal type
    that we used in line B:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: An upside is that the function declaration is less cluttered. A downside that
    we have to look elsewhere to see the types.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[27.3.5 `this` as a parameter (advanced)](#this-as-a-parameter-advanced)'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Each ordinary function always has the implicit parameter `this` – which enables
    it to be used as a method in objects. Sometimes we need to specify a type for
    `this`. There is TypeScript-only syntax for this use case: One of the parameters
    of an ordinary function can have the name `this`. Such a parameter only exists
    at compile time and disappears at runtime.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the following interface for DOM event sources (in a
    slightly simplified version):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `this` of the callback `listener` is always an instance of `EventSource`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example demonstrates that TypeScript uses the type information provided
    by the `this` parameter to check the first argument of `.call()` (line A and line
    B):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Additionally, we can’t invoke `toIsoString()` as a method of an object `obj`
    because then its receiver isn’t an instance of `Date`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[27.4 Return type `never`: functions that don’t return](#return-type-never)'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`never` also serves as a marker for functions that never return – e.g.:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: TypeScript’s type inference takes such functions into consideration. For example,
    the inferred return type of `returnStringIfTrue()` is `string` because we invoke
    `throwError()` in line A.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we omit line A then we get an error and the inferred return type is `''abc''
    | undefined`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[27.4.1 Reasons against the return type `never | T`](#reasons-against-the-return-type-never-t)'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In principle we could use the type `never | T` for a function that, in some
    cases, throws an exception and does not return normally. However there are two
    reasons against doing that:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Throwing an exception normally does not change the return type of a function.
    That’s why it’s called an *exception*.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`never | T` is the same as `T` (as we have seen previously in this chapter).'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[27.4.2 The return type `never` in `@types/node`](#the-return-type-never-in-types-node)'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In Node.js, the following functions have the return type `never`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '`process.exit()`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`process.abort()`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert.fail()`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[27.5 Overloading (advanced)](#overloading-advanced)'
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes a single type signature does not adequately describe how a function
    works.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[27.5.1 Overloading function declarations](#overloading-function-declarations)'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider function `getFullName()` which we are calling in the following example
    (line A and line B):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'How would we implement `getFullName()`? The following implementation works
    for the two function calls in the previous example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'However, with this type signature, function calls are legal at compile time
    that produce runtime errors:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following code fixes these issues:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'What is going on here? The type signature of `getFullName()` is overloaded:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'The function has two external *overload signatures*: type signatures without
    implementations (line A and line B).'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It also has one *implementation signature*: the type signature of the actual
    implementation, which is internal and must be compatible with both external signatures.
    Incidentally, it is the same as in the previous example.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'My advice is to only use overloading when it can’t be avoided. One alternative
    is to split an overloaded function into multiple functions with different names
    – for example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '`getFullName()`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getFullNameViaMap()`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[27.5.2 Overloading functions via a union of tuple types](#overloading-functions-via-a-union-of-tuple-types)'
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can also overload a function via a union of tuple types (line A):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Keep in mind that this kind of overloading only works if the return type is
    the same for all cases.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the labels for the elements of the tuple types:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'These labels are optional and mostly ignored, but may show up in auto-completions
    and type hints. In other words: They work more like comments. The previous two
    types are equivalent to:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For more information, see [“Labeled tuple elements” (§37.1.3)](ch_computing-with-tuple-types.html#labeled-tuple-elements).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[27.5.3 Overloading functions via interfaces](#overloading-functions-via-interfaces)'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In interfaces, we can have multiple, different call signatures. That enables
    us to use the interface `GetFullName` for overloading in the following example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[27.5.4 Overloading on string parameters (event handling etc.)](#overloading-on-string-parameters)'
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the next example, we overload and use string literal types (such as `''click''`).
    That allows us to change the type of parameter `listener` depending on the value
    of parameter `type`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this case, it is relatively difficult to get the types of the implementation
    (starting in line A) right, so that the statement in the body (line B) works.
    As a last resort, we used the type `any` for parameter `event` of `listener`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[27.5.5 Overloading methods](#overloading-methods)'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[27.5.5.1 Overloading concrete methods](#overloading-concrete-methods)'
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The next example demonstrates overloading of methods: Method `.add()` is overloaded.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[27.5.5.2 Overloading interface methods](#overloading-interface-methods)'
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The type definition for `Array.from()` is an example of an overloaded interface
    method:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the first signature, the returned Array has the same element type as the
    parameter.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second signature, the elements of the returned Array have the same type
    as the result of `mapfn`. This version of `Array.from()` is similar to `Array.prototype.map()`.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[27.6 Assignability (advanced)](#assignability)'
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section we look at the type compatibility rules for *assignability*:
    Can functions of type `Src` be transferred to storage locations (variables, object
    properties, parameters, etc.) of type `Trg`?'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding assignability helps us answer questions such as:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Given the function type signature of a formal parameter, which functions can
    be passed as actual parameters in function calls?
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given the function type signature of a property, which functions can be assigned
    to it?
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[27.6.1 The rules for assignability](#the-rules-for-assignability)'
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this subsection, we examine general rules for assignability (including the
    rules for functions). In the next subsection, we explore what those rules mean
    for functions.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'A type `Src` is *assignable* to a type `Trg` if one of the following conditions
    is true:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '`Src` and `Trg` are identical types.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Src` or `Trg` is the `any` type.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Src` is a string literal type and `Trg` is the primitive type String.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Src` is a union type and each constituent type of `Src` is assignable to `Trg`.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Src` and `Trg` are function types and:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Trg` has a rest parameter or the number of required parameters of `Src` is
    less than or equal to the total number of parameters of `Trg`.'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For parameters that are present in both signatures, each parameter type in `Trg`
    is assignable to the corresponding parameter type in `Src`.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The return type of `Trg` is `void` or the return type of `Src` is assignable
    to the return type of `Trg`.
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: (Remaining conditions omitted.)
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[27.6.2 Consequences of the assignment rules for functions](#consequences-of-the-assignment-rules-for-functions)'
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this subsection, we look at what the assignment rules mean for the following
    two functions `targetFunc` and `sourceFunc`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[27.6.2.1 Types of parameters and results](#types-of-parameters-and-results)'
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Target parameter types must be assignable to corresponding source parameter
    types.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why? Anything that the target accepts must also be accepted by the source.
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The source return type must be assignable to target return type.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why? Anything that the source returns must be compatible with the expectations
    set by the target.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么？源返回的任何内容都必须与目标设定的期望相兼容。
- en: 'Example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The following example demonstrates that if the target return type is `void`,
    then the source return type doesn’t matter. Why is that? `void` results are always
    ignored in TypeScript.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如果目标返回类型是 `void`，则源返回类型无关紧要。为什么是这样？TypeScript 中总是忽略 `void` 类型的结果。
- en: '[PRE50]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[27.6.2.2 Numbers of parameters](#numbers-of-parameters)'
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[27.6.2.2 参数数量](#numbers-of-parameters)'
- en: 'The source must not have more parameters than the target:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 源不能比目标有更多的参数：
- en: '[PRE51]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The source can have fewer parameters than the target:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 源可以比目标有更少的参数：
- en: '[PRE52]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Why is that? The target specifies the expectations for the source: It must
    accept the parameter `x`. Which it does (but it ignores it). This permissiveness
    enables:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是这样？目标指定了源期望：它必须接受参数 `x`。它确实做到了（但它忽略了它）。这种宽容性使得：
- en: '[PRE53]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The callback for `.map()` only has one of the three parameters that are mentioned
    in the type signature of `.map()`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`.map()` 的回调函数只包含 `.map()` 类型签名中提到的三个参数之一：'
- en: '[PRE54]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[27.7 Further reading and sources of this chapter](#further-reading-and-sources-of-this-chapter)'
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[27.7 进一步阅读和本章来源](#further-reading-and-sources-of-this-chapter)'
- en: '[TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/basic-types.html)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[TypeScript 手册](https://www.typescriptlang.org/docs/handbook/basic-types.html)'
- en: '[Chapter “Callable values”](https://exploringjs.com/js/book/ch_callables.html)
    in “Exploring JavaScript”'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“可调用值”章节](https://exploringjs.com/js/book/ch_callables.html) 在 “Exploring
    JavaScript”'
