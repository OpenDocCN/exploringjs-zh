<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>18 Typing objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>18 Typing objects</h1>
<blockquote>原文：<a href="https://exploringjs.com/ts/book/ch_typing-objects.html">https://exploringjs.com/ts/book/ch_typing-objects.html</a></blockquote>

    
        <div id="adbox">
      <div id="adbox-explain">(Ad, please don’t block.)</div>
              
          </div>
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#object-types">18.1 Object types</a>
      <ol>
        <li>
          <a href="#ways-of-using-objects">18.1.1 The two ways of using objects</a>
        </li>
        <li>
          <a href="#object-types-work-structurally-in-typescript">18.1.2 Object types work structurally in TypeScript</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#members-of-object-literal-types">18.2 Members of object literal types</a>
      <ol>
        <li>
          <a href="#method-signatures">18.2.1 Method signatures</a>
        </li>
        <li>
          <a href="#keys-of-object-type-members">18.2.2 Keys of object type members</a>
        </li>
        <li>
          <a href="#modifiers-of-object-type-members">18.2.3 Modifiers of object type members</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#excess-property-checks-when-are-extra-properties-allowed">18.3 Excess property checks: When are extra properties allowed?</a>
      <ol>
        <li>
          <a href="#why-are-excess-properties-forbidden-in-object-literals">18.3.1 Why are excess properties forbidden in object literals?</a>
        </li>
        <li>
          <a href="#why-are-excess-properties-allowed-if-an-object-comes-from-somewhere-else">18.3.2 Why are excess properties allowed if an object comes from somewhere else?</a>
        </li>
        <li>
          <a href="#empty-object-literal-types-allow-excess-properties">18.3.3 Empty object literal types allow excess properties</a>
        </li>
        <li>
          <a href="#matching-only-objects-without-properties">18.3.4 Matching only objects without properties</a>
        </li>
        <li>
          <a href="#allowing-excess-properties-in-object-literals">18.3.5 Allowing excess properties in object literals</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#object-types-and-inherited-properties">18.4 Object types and inherited properties</a>
      <ol>
        <li>
          <a href="#typescript-doesn-t-distinguish-own-and-inherited-properties">18.4.1 TypeScript doesn’t distinguish own and inherited properties</a>
        </li>
        <li>
          <a href="#object-literal-types-describe-instances-of-object">18.4.2 Object literal types describe instances of <code>Object</code></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#interfaces-vs-object-literal-types">18.5 Interfaces vs. object literal types</a>
      <ol>
        <li>
          <a href="#object-literal-types-can-be-inlined">18.5.1 Object literal types can be inlined</a>
        </li>
        <li>
          <a href="#interfaces-with-the-same-name-are-merged">18.5.2 Interfaces with the same name are merged</a>
        </li>
        <li>
          <a href="#mapped-types-look-like-object-literal-types">18.5.3 Mapped types look like object literal types</a>
        </li>
        <li>
          <a href="#only-interfaces-support-polymorphic-this-types">18.5.4 Only interfaces support polymorphic <code>this</code> types</a>
        </li>
        <li>
          <a href="#extending-interfaces">18.5.5 Only interfaces support <code>extends</code> – but type intersection (<code>&amp;</code>) is similar</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#forbidding-properties-via-never">18.6 Forbidding properties via <code>never</code></a>
      <ol>
        <li>
          <a href="#forbidding-properties-with-string-keys">18.6.1 Forbidding properties with string keys</a>
        </li>
        <li>
          <a href="#forbidding-index-properties-with-number-keys">18.6.2 Forbidding index properties (with number keys)</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#index-signatures">18.7 Index signatures: objects as dictionaries</a>
      <ol>
        <li>
          <a href="#typing-index-signature-keys">18.7.1 Typing index signature keys</a>
        </li>
        <li>
          <a href="#string-keys-vs-number-keys">18.7.2 String keys vs. number keys</a>
        </li>
        <li>
          <a href="#index-signatures-vs-property-signatures-and-method-signatures">18.7.3 Index signatures vs. property signatures and method signatures</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#record-for-dictionary-objects">18.8 <code>Record&lt;K, V&gt;</code> for dictionary objects</a>
      <ol>
        <li>
          <a href="#index-signatures-don-t-allow-key-unions">18.8.1 Index signatures don’t allow key unions</a>
        </li>
        <li>
          <a href="#record-enforces-exhaustiveness-for-key-unions">18.8.2 <code>Record</code> enforces exhaustiveness for key unions</a>
        </li>
        <li>
          <a href="#record-preventing-exhaustiveness-checks-for-key-unions">18.8.3 <code>Record</code>: preventing exhaustiveness checks for key unions</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#general-types-for-objects">18.9 <code>object</code> vs <code>Object</code> vs. <code>{}</code></a>
      <ol>
        <li>
          <a href="#plain-javascript-objects-vs-instances-of-object">18.9.1 Plain JavaScript: objects vs. instances of <code>Object</code></a>
        </li>
        <li>
          <a href="#object-uppercase-o-in-typescript-instances-of-class-object">18.9.2 <code>Object</code> (uppercase “O”) in TypeScript: instances of class <code>Object</code></a>
        </li>
        <li>
          <a href="#type-basically-means-not-nullish">18.9.3 Type <code>{}</code> basically means: not nullish</a>
        </li>
        <li>
          <a href="#inferred-types-for-various-objects">18.9.4 Inferred types for various objects</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#summary-object-vs-object-vs-vs-record">18.10 Summary: <code>object</code> vs <code>Object</code> vs. <code>{}</code> vs. <code>Record</code></a>
    </li>
    <li>
      <a href="#sources-of-this-chapter-2">18.11 Sources of this chapter</a>
    </li>
  </ol>
</nav>
<p>In this chapter, we will explore how objects and properties are typed statically in TypeScript.</p>
<h3 id="object-types"><a class="heading-id-link" href="#object-types">18.1 Object types</a></h3>
<h4 id="ways-of-using-objects"><a class="heading-id-link" href="#ways-of-using-objects">18.1.1 The two ways of using objects</a></h4>
<p>There are two ways of using objects in JavaScript:</p>
<ul>
  <li>
    <p>Fixed-layout object: Used this way, an object works like a record in a database. It has a fixed number of properties, whose keys are known at development time. Their values generally have different types.</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">fixedLayoutObject</span>: <span class="hljs-title class_">FixedLayoutObjectType</span> = {</code>
<code>  <span class="hljs-attr">product</span>: <span class="hljs-string">'carrot'</span>,</code>
<code>  <span class="hljs-attr">quantity</span>: <span class="hljs-number">4</span>,</code>
<code>};</code>
</pre>
  </li>
  <li>
    <p>Dictionary object: Used this way, an object works like a lookup table or a map. It has a variable number of properties, whose keys are not known at development time. All of their values have the same type.</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">dictionaryObject</span>: <span class="hljs-title class_">DictionaryObjectType</span> = {</code>
<code>  [<span class="hljs-string">'one'</span>]: <span class="hljs-number">1</span>,</code>
<code>  [<span class="hljs-string">'two'</span>]: <span class="hljs-number">2</span>,</code>
<code>};</code>
</pre>
  </li>
</ul>
<p>Note that the two ways can also be mixed: Some objects are both fixed-layout objects and dictionary objects.</p>
<p>The most common ways of typing these two kinds of objects are:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">FixedLayoutObjectType</span> = {</code>
<code>    <span class="hljs-attr">product</span>: <span class="hljs-built_in">string</span>,</code>
<code>    <span class="hljs-attr">quantity</span>: <span class="hljs-built_in">number</span>,</code>
<code>};</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">DictionaryObjectType</span> = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt;;</code>
</pre>
<ul>
  <li>
    <code>FixedLayoutObjectType</code> is an object literal type. The separators between properties can be either commas (<code>,</code>) or semicolons (<code>;</code>). I prefer the former because that’s what JavaScript object literals use.
  </li>
  <li>
    <code>DictionaryObjectType</code> uses the utility type <code>Record</code> to define a type for dictionary objects whose keys are strings and whose values are numbers.
  </li>
</ul>
<p>Next, we’ll look at fixed-layout object types in more detail before coming back to dictionary object types.</p>
<h4 id="object-types-work-structurally-in-typescript"><a class="heading-id-link" href="#object-types-work-structurally-in-typescript">18.1.2 Object types work structurally in TypeScript</a></h4>
<p>Object types work structurally in TypeScript: They match all values that have their structure. Therefore, a type can be defined after a given value and still match it – e.g.:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> myPoint = {<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>};</code>
<code/>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">logPoint</span>(<span class="hljs-params">point: {x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>}</span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(point);</code>
<code>}</code>
<code/>
<code><span class="hljs-title function_">logPoint</span>(myPoint); <span class="hljs-comment">// Works!</span></code>
</pre>
<p>For more information on this topic, see <a href="ch_what-is-a-type.html#nominal-vs-structural-type-systems">“Nominal type systems vs. structural type systems” (§13.4)</a>.</p>
<h3 id="members-of-object-literal-types"><a class="heading-id-link" href="#members-of-object-literal-types">18.2 Members of object literal types</a></h3>
<p>The constructs inside the bodies of object literal types are called their <em>members</em>. These are the most common members:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ExampleObjectType</span> = {</code>
<code>  <span class="hljs-comment">// Property signature</span></code>
<code>  <span class="hljs-attr">myProperty</span>: <span class="hljs-built_in">boolean</span>,</code>
<code/>
<code>  <span class="hljs-comment">// Method signature</span></code>
<code>  <span class="hljs-title function_">myMethod</span>(<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">number</span>,</code>
<code/>
<code>  <span class="hljs-comment">// Index signature</span></code>
<code>  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>,</code>
<code/>
<code>  <span class="hljs-comment">// Call signature</span></code>
<code>  (<span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>,</code>
<code/>
<code>  <span class="hljs-comment">// Construct signature</span></code>
<code>  <span class="hljs-title function_">new</span>(<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">ExampleInstanceType</span>, </code>
<code>};</code>
<code/>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ExampleInstanceType</span> = {};</code>
</pre>
<p>Let’s look at these members in more detail:</p>
<ul>
  <li>
    <p>Property signatures define properties and should be self-explanatory:</p>
<pre class="language-ts">
<code><span class="hljs-attr">myProperty</span>: <span class="hljs-built_in">boolean</span>;</code>
</pre>
  </li>
  <li>
    <p>Method signatures define methods and are described in the next subsection.</p>
<pre class="language-ts">
<code><span class="hljs-title function_">myMethod</span>(<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">number</span>;</code>
</pre>
    <p>Note: The names of parameters (in this case: <code>str</code>) help with documenting how things work but have no other purpose.</p>
  </li>
  <li>
    <p>Index signatures are needed to describe Arrays or objects that are used as dictionaries. They are described <a href="#index-signatures">later in this chapter</a>.</p>
<pre class="language-ts">
<code>[<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;</code>
</pre>
    <p>Note: The name <code>key</code> is only there for documentation purposes.</p>
  </li>
  <li>
    <p>Call signatures enable object literal types to describe functions. See <a href="ch_typing-functions.html#call-signatures">“Interfaces with call signatures” (§27.2.2)</a>.</p>
<pre class="language-ts">
<code>(<span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>;</code>
</pre>
  </li>
  <li>
    <p>Construct signatures enable object literal types to describe classes and constructor functions. See <a href="ch_classes-as-values.html#construct-signatures">“Object type literals with construct signatures” (§23.2.3)</a>.</p>
<pre class="language-ts">
<code><span class="hljs-title function_">new</span>(<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">ExampleInstanceType</span>; </code>
</pre>
  </li>
</ul>
<h4 id="method-signatures"><a class="heading-id-link" href="#method-signatures">18.2.1 Method signatures</a></h4>
<p>As far as TypeScript’s type system is concerned, method definitions and properties whose values are functions, are equivalent:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">HasMethodDef</span> = {</code>
<code>  <span class="hljs-title function_">simpleMethod</span>(<span class="hljs-attr">flag</span>: <span class="hljs-built_in">boolean</span>): <span class="hljs-built_in">void</span>,</code>
<code>};</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">HasFuncProp</span> = {</code>
<code>  <span class="hljs-attr">simpleMethod</span>: <span class="hljs-function">(<span class="hljs-params">flag: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>,</code>
<code>};</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">HasMethodDef</span>,</code>
<code>  <span class="hljs-title class_">HasFuncProp</span></code>
<code>&gt;&gt;;</code>
<code/>
<code><span class="hljs-keyword">const</span> objWithMethod = {</code>
<code>  <span class="hljs-title function_">simpleMethod</span>(<span class="hljs-attr">flag</span>: <span class="hljs-built_in">boolean</span>): <span class="hljs-built_in">void</span> {},</code>
<code>};</code>
<code>assertType&lt;<span class="hljs-title class_">HasMethodDef</span>&gt;(objWithMethod);</code>
<code>assertType&lt;<span class="hljs-title class_">HasFuncProp</span>&gt;(objWithMethod);</code>
<code/>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">objWithOrdinaryFunction</span>: <span class="hljs-title class_">HasMethodDef</span> = {</code>
<code>  <span class="hljs-attr">simpleMethod</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">flag: <span class="hljs-built_in">boolean</span></span>): <span class="hljs-built_in">void</span> {},</code>
<code>};</code>
<code>assertType&lt;<span class="hljs-title class_">HasMethodDef</span>&gt;(objWithOrdinaryFunction);</code>
<code>assertType&lt;<span class="hljs-title class_">HasFuncProp</span>&gt;(objWithOrdinaryFunction);</code>
<code/>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">objWithArrowFunction</span>: <span class="hljs-title class_">HasMethodDef</span> = {</code>
<code>  <span class="hljs-attr">simpleMethod</span>: (<span class="hljs-attr">flag</span>: <span class="hljs-built_in">boolean</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> {},</code>
<code>};</code>
<code>assertType&lt;<span class="hljs-title class_">HasMethodDef</span>&gt;(objWithArrowFunction);</code>
<code>assertType&lt;<span class="hljs-title class_">HasFuncProp</span>&gt;(objWithArrowFunction);</code>
</pre>
<p>My recommendation is to use whichever syntax best expresses how a property should be set up.</p>
<h4 id="keys-of-object-type-members"><a class="heading-id-link" href="#keys-of-object-type-members">18.2.2 Keys of object type members</a></h4>
<h5 id="quoted-keys"><a class="heading-id-link" href="#quoted-keys">18.2.2.1 Quoted keys</a></h5>
<p>Just like in JavaScript, property keys can be quoted:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Obj</span> = { <span class="hljs-string">'hello everyone!'</span>: <span class="hljs-built_in">string</span> };</code>
</pre>
<h5 id="unquoted-numbers-as-keys"><a class="heading-id-link" href="#unquoted-numbers-as-keys">18.2.2.2 Unquoted numbers as keys</a></h5>
<p>This rarely matters in practice, but as an aside: Just like in JavaScript, we can use unquoted numbers as keys. Unlike JavaScript, those keys are considered to be number literal types:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  keyof {<span class="hljs-number">0</span>: <span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>: <span class="hljs-string">'b'</span>},</code>
<code>  <span class="hljs-number">0</span> | <span class="hljs-number">1</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>For comparison, this is how JavaScript works:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>({<span class="hljs-number">0</span>: <span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>: <span class="hljs-string">'b'</span>}),</code>
<code>  [ <span class="hljs-string">'0'</span>, <span class="hljs-string">'1'</span> ]</code>
<code>);</code>
</pre>
<p>For more information see <a href="ch_computing-with-types-overview.html#number-keys-javascript-vs-typescript">$type</a>.</p>
<h5 id="computed-property-keys"><a class="heading-id-link" href="#computed-property-keys">18.2.2.3 Computed property keys</a></h5>
<p><a href="https://exploringjs.com/js/book/ch_objects.html#object-literals-computed-keys">Computed property keys</a> are a JavaScript feature. There is a similar feature at the type level:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ExampleObjectType</span> = {</code>
<code>  <span class="hljs-comment">// Property signature with computed key</span></code>
<code>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]: <span class="hljs-built_in">string</span>,</code>
<code/>
<code>  <span class="hljs-comment">// Method signature with computed key</span></code>
<code>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>](): <span class="hljs-title class_">IteratorObject</span>&lt;<span class="hljs-built_in">string</span>&gt;,</code>
<code>};</code>
</pre>
<p>Unexpectedly, computed property keys are values, not types. TypeScript internally applies <code>typeof</code> to create the type:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  { [<span class="hljs-string">'hello'</span>]: <span class="hljs-built_in">string</span> },</code>
<code>  { <span class="hljs-attr">hello</span>: <span class="hljs-built_in">string</span> }</code>
<code>&gt;&gt;;</code>
</pre>
<p>What kind of value is allowed as a computed property key? Its type must be:</p>
<ul>
  <li>
    A string literal type such as <code>'abc'</code>
  </li>
  <li>
    A number literal type such as <code>123</code>
  </li>
  <li>
    A unique symbol type
  </li>
  <li>
    <code>any</code>
  </li>
</ul>
<h4 id="modifiers-of-object-type-members"><a class="heading-id-link" href="#modifiers-of-object-type-members">18.2.3 Modifiers of object type members</a></h4>
<h5 id="optional-properties-1"><a class="heading-id-link" href="#optional-properties-1">18.2.3.1 Optional properties</a></h5>
<p>If we put a question mark (<code>?</code>) after the name of a property, that property is optional. The same syntax is used to mark parameters of functions, methods, and constructors as optional. In the following example, property <code>.middle</code> is optional:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Name</span> = {</code>
<code>  <span class="hljs-attr">first</span>: <span class="hljs-built_in">string</span>;</code>
<code>  middle?: <span class="hljs-built_in">string</span>;</code>
<code>  <span class="hljs-attr">last</span>: <span class="hljs-built_in">string</span>;</code>
<code>};</code>
</pre>
<p>Therefore, it’s OK to omit that property (line A):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">john</span>: <span class="hljs-title class_">Name</span> = {<span class="hljs-attr">first</span>: <span class="hljs-string">'Doe'</span>, <span class="hljs-attr">last</span>: <span class="hljs-string">'Doe'</span>}; <span class="hljs-comment">// (A)</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">jane</span>: <span class="hljs-title class_">Name</span> = {<span class="hljs-attr">first</span>: <span class="hljs-string">'Jane'</span>, <span class="hljs-attr">middle</span>: <span class="hljs-string">'Cecily'</span>, <span class="hljs-attr">last</span>: <span class="hljs-string">'Doe'</span>};</code>
</pre>
<h6 id="optional-vs-undefined-string-with-ex-act-op-tion-al-prop-er-ty-types"><a class="heading-id-link" href="#optional-vs-undefined-string-with-ex-act-op-tion-al-prop-er-ty-types">18.2.3.1.1 Optional vs. <code>undefined | string</code> with <code>exactOptionalPropertyTypes</code></a></h6>
<p>In this book, all code uses the compiler setting <a href="ch_tsconfig-json.html#exactOptionalPropertyTypes"><code>exactOptionalPropertyTypes</code></a>. With that setting, the difference an optional property and a property with type <code>undefined | string</code> is intuitive:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Obj</span> = {</code>
<code>  prop1?: <span class="hljs-built_in">string</span>;</code>
<code>  <span class="hljs-attr">prop2</span>: <span class="hljs-literal">undefined</span> | <span class="hljs-built_in">string</span>; </code>
<code>};</code>
<code/>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj1</span>: <span class="hljs-title class_">Obj</span> = { <span class="hljs-attr">prop1</span>: <span class="hljs-string">'a'</span>, <span class="hljs-attr">prop2</span>: <span class="hljs-string">'b'</span> };</code>
<code/>
<code><span class="hljs-comment">// .prop1 can be omitted; .prop2 can be `undefined`</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj2</span>: <span class="hljs-title class_">Obj</span> = { <span class="hljs-attr">prop2</span>: <span class="hljs-literal">undefined</span> };</code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Type '{ prop1: undefined; prop2: string; }' is not</span></code>
<code><span class="hljs-comment">// assignable to type 'Obj' with 'exactOptionalPropertyTypes: true'.</span></code>
<code><span class="hljs-comment">// Consider adding 'undefined' to the types of the target's properties.</span></code>
<code><span class="hljs-comment">// Types of property 'prop1' are incompatible. Type 'undefined' is not</span></code>
<code><span class="hljs-comment">// assignable to type 'string'.</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj3</span>: <span class="hljs-title class_">Obj</span> = { <span class="hljs-attr">prop1</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">prop2</span>: <span class="hljs-string">'b'</span> };</code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Property 'prop2' is missing in type '{ prop1: string;</span></code>
<code><span class="hljs-comment">// }' but required in type 'Obj'.</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj4</span>: <span class="hljs-title class_">Obj</span> = { <span class="hljs-attr">prop1</span>: <span class="hljs-string">'a'</span> };</code>
</pre>
<p>Types such as <code>undefined | string</code> and <code>null | string</code> are useful if we want to make omissions explicit. When people see such an explicitly omitted property, they know that it exists but was switched off.</p>
<h6 id="optional-vs-undefined-string-without-ex-act-op-tion-al-prop-er-ty-types"><a class="heading-id-link" href="#optional-vs-undefined-string-without-ex-act-op-tion-al-prop-er-ty-types">18.2.3.1.2 Optional vs. <code>undefined | string</code> without <code>exactOptionalPropertyTypes</code></a></h6>
<p>If <code>exactOptionalPropertyTypes</code> is <code>false</code> then one thing changes: <code>.prop1</code> can also be <code>undefined</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Obj</span> = {</code>
<code>  prop1?: <span class="hljs-built_in">string</span>;</code>
<code>  <span class="hljs-attr">prop2</span>: <span class="hljs-literal">undefined</span> | <span class="hljs-built_in">string</span>; </code>
<code>};</code>
<code/>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj1</span>: <span class="hljs-title class_">Obj</span> = { <span class="hljs-attr">prop1</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">prop2</span>: <span class="hljs-literal">undefined</span> };</code>
</pre>
<h5 id="read-only-properties"><a class="heading-id-link" href="#read-only-properties">18.2.3.2 Read-only properties</a></h5>
<p>In the following example, property <code>.prop</code> is read-only:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyObj</span> = {</code>
<code>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">prop</span>: <span class="hljs-built_in">number</span>;</code>
<code>};</code>
</pre>
<p>As a consequence, we can read it, but we can’t change it:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>: <span class="hljs-title class_">MyObj</span> = {</code>
<code>  <span class="hljs-attr">prop</span>: <span class="hljs-number">1</span>,</code>
<code>};</code>
<code/>
<code><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">prop</span>); <span class="hljs-comment">// OK</span></code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Cannot assign to 'prop' because it is a read-only</span></code>
<code><span class="hljs-comment">// property.</span></code>
<code>obj.<span class="hljs-property">prop</span> = <span class="hljs-number">2</span>;</code>
</pre>
<h3 id="excess-property-checks-when-are-extra-properties-allowed"><a class="heading-id-link" href="#excess-property-checks-when-are-extra-properties-allowed">18.3 Excess property checks: When are extra properties allowed?</a></h3>
<p>As an example, consider the following object literal type:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = {</code>
<code>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>,</code>
<code>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>,</code>
<code>};</code>
</pre>
<p>There are two ways (among others) in which this object literal type could be interpreted:</p>
<ul>
  <li>
    Closed interpretation: It could describe all objects that have <em>exactly</em> the properties <code>.x</code> and <code>.y</code> with the specified types. On other words: Those objects must not have <em>excess properties</em> (more than the required properties).
  </li>
  <li>
    Open interpretation: It could describe all objects that have <em>at least</em> the properties <code>.x</code> and <code>.y</code>. In other words: Excess properties are allowed.
  </li>
</ul>
<p>TypeScript uses both interpretations. To explore how that works, we will use the following function:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">computeDistance</span>(<span class="hljs-params">point: Point</span>) { <span class="hljs-comment">/*...*/</span> }</code>
</pre>
<p>The default is that the excess property <code>.z</code> is allowed:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">3</span> };</code>
<code><span class="hljs-title function_">computeDistance</span>(obj); <span class="hljs-comment">// OK</span></code>
</pre>
<p>However, if we use object literals directly, then excess properties are forbidden:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// @ts-expect-error: Object literal may only specify known properties, and</span></code>
<code><span class="hljs-comment">// 'z' does not exist in type 'Point'.</span></code>
<code><span class="hljs-title function_">computeDistance</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">3</span> }); <span class="hljs-comment">// error</span></code>
<code/>
<code><span class="hljs-title function_">computeDistance</span>({<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>}); <span class="hljs-comment">// OK</span></code>
</pre>
<h4 id="why-are-excess-properties-forbidden-in-object-literals"><a class="heading-id-link" href="#why-are-excess-properties-forbidden-in-object-literals">18.3.1 Why are excess properties forbidden in object literals?</a></h4>
<p>Why the stricter rules for object literals? They provide protection against typos in property keys. We will use the following object literal type to demonstrate what that means.</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Person</span> = {</code>
<code>  <span class="hljs-attr">first</span>: <span class="hljs-built_in">string</span>,</code>
<code>  middle?: <span class="hljs-built_in">string</span>,</code>
<code>  <span class="hljs-attr">last</span>: <span class="hljs-built_in">string</span>,</code>
<code>};</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">computeFullName</span>(<span class="hljs-params">person: Person</span>) { <span class="hljs-comment">/*...*/</span> }</code>
</pre>
<p>Property <code>.middle</code> is optional and can be omitted. To TypeScript, mistyping its name looks like omitting it and providing an excess property. However, it still catches the typo because excess properties are not allowed in this case:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// @ts-expect-error: Object literal may only specify known properties, but</span></code>
<code><span class="hljs-comment">// 'mdidle' does not exist in type 'Person'. Did you mean to write</span></code>
<code><span class="hljs-comment">// 'middle'?</span></code>
<code><span class="hljs-title function_">computeFullName</span>({<span class="hljs-attr">first</span>: <span class="hljs-string">'Jane'</span>, <span class="hljs-attr">mdidle</span>: <span class="hljs-string">'Cecily'</span>, <span class="hljs-attr">last</span>: <span class="hljs-string">'Doe'</span>});</code>
</pre>
<h4 id="why-are-excess-properties-allowed-if-an-object-comes-from-somewhere-else"><a class="heading-id-link" href="#why-are-excess-properties-allowed-if-an-object-comes-from-somewhere-else">18.3.2 Why are excess properties allowed if an object comes from somewhere else?</a></h4>
<p>The idea is that if an object comes from somewhere else, we can assume that it has already been vetted and will not have any typos. Then we can afford to be less careful.</p>
<p>If typos are not an issue, our goal should be maximizing flexibility. Consider the following function:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">HasYear</span> = {</code>
<code>  <span class="hljs-attr">year</span>: <span class="hljs-built_in">number</span>,</code>
<code>};</code>
<code/>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">getAge</span>(<span class="hljs-params">obj: HasYear</span>) {</code>
<code>  <span class="hljs-keyword">const</span> yearNow = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>();</code>
<code>  <span class="hljs-keyword">return</span> yearNow - obj.<span class="hljs-property">year</span>;</code>
<code>}</code>
</pre>
<p>Without allowing excess properties for values that are passed to <code>getAge()</code>, the usefulness of this function would be quite limited.</p>
<h4 id="empty-object-literal-types-allow-excess-properties"><a class="heading-id-link" href="#empty-object-literal-types-allow-excess-properties">18.3.3 Empty object literal types allow excess properties</a></h4>
<p>If an object literal type is empty, excess properties are always allowed:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Empty</span> = {};</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">OneProp</span> = {</code>
<code>  <span class="hljs-attr">myProp</span>: <span class="hljs-built_in">number</span>,</code>
<code>};</code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Object literal may only specify known properties, and</span></code>
<code><span class="hljs-comment">// 'anotherProp' does not exist in type 'OneProp'.</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>: <span class="hljs-title class_">OneProp</span> = { <span class="hljs-attr">myProp</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">anotherProp</span>: <span class="hljs-number">2</span> };</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">b</span>: <span class="hljs-title class_">Empty</span> = { <span class="hljs-attr">myProp</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">anotherProp</span>: <span class="hljs-number">2</span> }; <span class="hljs-comment">// OK</span></code>
</pre>
<h4 id="matching-only-objects-without-properties"><a class="heading-id-link" href="#matching-only-objects-without-properties">18.3.4 Matching only objects without properties</a></h4>
<p>If we want to enforce that an object has no properties, we can use the following trick (credit: <a href="https://twitter.com/filearts/status/1222502898552180737">Geoff Goodman</a>):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">WithoutProperties</span> = {</code>
<code>  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">never</span>,</code>
<code>};</code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Type 'number' is not assignable to type 'never'.</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>: <span class="hljs-title class_">WithoutProperties</span> = { <span class="hljs-attr">prop</span>: <span class="hljs-number">1</span> };</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">b</span>: <span class="hljs-title class_">WithoutProperties</span> = {}; <span class="hljs-comment">// OK</span></code>
</pre>
<h4 id="allowing-excess-properties-in-object-literals"><a class="heading-id-link" href="#allowing-excess-properties-in-object-literals">18.3.5 Allowing excess properties in object literals</a></h4>
<p>What if we want to allow excess properties in object literals? As an example, consider type <code>Point</code> and function <code>computeDistance1()</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = {</code>
<code>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>,</code>
<code>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>,</code>
<code>};</code>
<code/>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">computeDistance1</span>(<span class="hljs-params">point: Point</span>) { <span class="hljs-comment">/*...*/</span> }</code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Object literal may only specify known properties, and</span></code>
<code><span class="hljs-comment">// 'z' does not exist in type 'Point'.</span></code>
<code><span class="hljs-title function_">computeDistance1</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">3</span> });</code>
</pre>
<p>One option is to assign the object literal to an intermediate variable:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">3</span> };</code>
<code><span class="hljs-title function_">computeDistance1</span>(obj);</code>
</pre>
<p>A second option is to use a type assertion:</p>
<pre class="language-ts">
<code><span class="hljs-title function_">computeDistance1</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">3</span> } <span class="hljs-keyword">as</span> <span class="hljs-title class_">Point</span>); <span class="hljs-comment">// OK</span></code>
</pre>
<p>A third option is to rewrite <code>computeDistance1()</code> so that it uses a type parameter:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> computeDistance2&lt;P <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Point</span>&gt;(<span class="hljs-attr">point</span>: P) { <span class="hljs-comment">/*...*/</span> }</code>
<code><span class="hljs-title function_">computeDistance2</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">3</span> }); <span class="hljs-comment">// OK</span></code>
</pre>
<p>A fourth option is to extend <code>Point</code> so that it allows excess properties:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">PointEtc</span> = <span class="hljs-title class_">Point</span> &amp; {</code>
<code>  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;</code>
<code>};</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">computeDistance3</span>(<span class="hljs-params">point: PointEtc</span>) { <span class="hljs-comment">/*...*/</span> }</code>
<code/>
<code><span class="hljs-title function_">computeDistance3</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">3</span> }); <span class="hljs-comment">// OK</span></code>
</pre>
<p>We used an intersection type (<code>&amp;</code> operator) to define <code>PointEtc</code>. For more information, see <a href="ch_intersections-object-types.html#intersections-of-object-types">“Intersections of object types” (§20.1)</a>.</p>
<p>We’ll continue with two examples where TypeScript not allowing excess properties, is a problem.</p>
<h5 id="allowing-excess-properties-example-incrementor-factory"><a class="heading-id-link" href="#allowing-excess-properties-example-incrementor-factory">18.3.5.1 Allowing excess properties: example <code>Incrementor</code> factory</a></h5>
<p>In this example, we implement a factory for objects of type <code>Incrementor</code> and would like to return a subtype, but TypeScript doesn’t allow the extra property <code>.counter</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Incrementor</span> = {</code>
<code>  <span class="hljs-title function_">inc</span>(): <span class="hljs-built_in">number</span>,</code>
<code>};</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">createIncrementor</span>(<span class="hljs-params">): <span class="hljs-title class_">Incrementor</span> {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">return</span> {</span></code>
<code><span class="hljs-params">    <span class="hljs-comment">// @ts-expect-error: Object literal may only specify known properties, and</span></span></code>
<code><span class="hljs-params">    <span class="hljs-comment">// 'counter' does not exist in type 'Incrementor'.</span></span></code>
<code><span class="hljs-params">    <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span>,</span></code>
<code><span class="hljs-params">    <span class="hljs-title function_">inc</span>(<span class="hljs-params"/>) {</span></code>
<code><span class="hljs-params">      <span class="hljs-comment">// @ts-expect-error: Property 'counter' does not exist on type</span></span></code>
<code><span class="hljs-params">      <span class="hljs-comment">// 'Incrementor'.</span></span></code>
<code><span class="hljs-params">      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">counter</span>++;</span></code>
<code><span class="hljs-params">    },</span></code>
<code><span class="hljs-params">  };</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p>Alas, even with a type assertion, there is still one type error:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">createIncrementor2</span>(<span class="hljs-params">): <span class="hljs-title class_">Incrementor</span> {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">return</span> {</span></code>
<code><span class="hljs-params">    <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span>,</span></code>
<code><span class="hljs-params">    <span class="hljs-title function_">inc</span>(<span class="hljs-params"/>) {</span></code>
<code><span class="hljs-params">      <span class="hljs-comment">// @ts-expect-error: Property 'counter' does not exist on type</span></span></code>
<code><span class="hljs-params">      <span class="hljs-comment">// 'Incrementor'.</span></span></code>
<code><span class="hljs-params">      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">counter</span>++;</span></code>
<code><span class="hljs-params">    },</span></code>
<code><span class="hljs-params">  } <span class="hljs-keyword">as</span> <span class="hljs-title class_">Incrementor</span>;</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p>What does work is <code>as any</code> but then the type of the returned object is <code>any</code> and, e.g. inside <code>.inc()</code>, TypeScript doesn’t check if properties of <code>this</code> really exist.</p>
<p>A proper solution is to add an index signature to <code>Incrementor</code>. Or – especially if that is not possible – to introduce an intermediate variable:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">createIncrementor3</span>(<span class="hljs-params">): <span class="hljs-title class_">Incrementor</span> {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">const</span> incrementor = {</span></code>
<code><span class="hljs-params">    <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span>,</span></code>
<code><span class="hljs-params">    <span class="hljs-title function_">inc</span>(<span class="hljs-params"/>) {</span></code>
<code><span class="hljs-params">      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">counter</span>++;</span></code>
<code><span class="hljs-params">    },</span></code>
<code><span class="hljs-params">  };</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">return</span> incrementor;</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<h5 id="allowing-excess-properties-example-datestr"><a class="heading-id-link" href="#allowing-excess-properties-example-datestr">18.3.5.2 Allowing excess properties: example <code>.dateStr</code></a></h5>
<p>The following comparison function can be used to sort objects that have the property <code>.dateStr</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">compareDateStrings</span>(</code>
<code><span class="hljs-params">  a: {dateStr: <span class="hljs-built_in">string</span>}, b: {dateStr: <span class="hljs-built_in">string</span>}</span>) {</code>
<code>    <span class="hljs-keyword">if</span> (a.<span class="hljs-property">dateStr</span> &lt; b.<span class="hljs-property">dateStr</span>) {</code>
<code>      <span class="hljs-keyword">return</span> +<span class="hljs-number">1</span>;</code>
<code>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.<span class="hljs-property">dateStr</span> &gt; b.<span class="hljs-property">dateStr</span>) {</code>
<code>      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;</code>
<code>    } <span class="hljs-keyword">else</span> {</code>
<code>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code>
<code>    }</code>
<code>  }</code>
</pre>
<p>For example in unit tests, we may want to invoke this function directly with object literals. TypeScript doesn’t let us do this and we need to use one of the workarounds.</p>
<h3 id="object-types-and-inherited-properties"><a class="heading-id-link" href="#object-types-and-inherited-properties">18.4 Object types and inherited properties</a></h3>
<h4 id="typescript-doesn-t-distinguish-own-and-inherited-properties"><a class="heading-id-link" href="#typescript-doesn-t-distinguish-own-and-inherited-properties">18.4.1 TypeScript doesn’t distinguish own and inherited properties</a></h4>
<p>TypeScript doesn’t distinguish own and inherited properties. They are all simply considered to be properties.</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyType</span> = {</code>
<code>  <span class="hljs-title function_">toString</span>(): <span class="hljs-built_in">string</span>, <span class="hljs-comment">// inherited property</span></code>
<code>  <span class="hljs-attr">prop</span>: <span class="hljs-built_in">number</span>, <span class="hljs-comment">// own property</span></code>
<code>};</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>: <span class="hljs-title class_">MyType</span> = { <span class="hljs-comment">// OK</span></code>
<code>  <span class="hljs-attr">prop</span>: <span class="hljs-number">123</span>,</code>
<code>};</code>
</pre>
<p><code>obj</code> inherits <code>.toString()</code> from <code>Object.prototype</code>.</p>
<p>The downside of this approach is that some phenomena in JavaScript can’t be described via TypeScript’s type system. The upside is that the type system is simpler.</p>
<h4 id="object-literal-types-describe-instances-of-object"><a class="heading-id-link" href="#object-literal-types-describe-instances-of-object">18.4.2 Object literal types describe instances of <code>Object</code></a></h4>
<p>All object literal types describe objects that are instances of <code>Object</code> and inherit the properties of <code>Object.prototype</code>. In the following example, the parameter <code>x</code> of type <code>{}</code> is compatible with the return type <code>Object</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params">x: {}</span>): <span class="hljs-title class_">Object</span> {</code>
<code>  <span class="hljs-keyword">return</span> x;</code>
<code>}</code>
</pre>
<p>Similarly, <code>{}</code> has a method <code>.toString()</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params">x: {}</span>): { <span class="hljs-title function_">toString</span>(): <span class="hljs-built_in">string</span> } {</code>
<code>  <span class="hljs-keyword">return</span> x;</code>
<code>}</code>
</pre>
<h3 id="interfaces-vs-object-literal-types"><a class="heading-id-link" href="#interfaces-vs-object-literal-types">18.5 Interfaces vs. object literal types</a></h3>
<p>For historical reasons, object types can be defined in two ways:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// Object literal type</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ObjType1</span> = {</code>
<code>  <span class="hljs-attr">a</span>: <span class="hljs-built_in">boolean</span>,</code>
<code>  <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>,</code>
<code>  <span class="hljs-attr">c</span>: <span class="hljs-built_in">string</span>,</code>
<code>};</code>
<code/>
<code><span class="hljs-comment">// Interface</span></code>
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ObjType2</span> {</code>
<code>  <span class="hljs-attr">a</span>: <span class="hljs-built_in">boolean</span>;</code>
<code>  <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>;</code>
<code>  <span class="hljs-attr">c</span>: <span class="hljs-built_in">string</span>;</code>
<code>}</code>
</pre>
<ul>
  <li>
    In both cases, either semicolons or commas can be used as separators. I prefer commas for object literal types and semicolons for interfaces because that reflects what JavaScript looks like (object literals and classes).
  </li>
  <li>
    Trailing separators are allowed and optional.
  </li>
</ul>
<p>Both ways of defining an object type are more or less equivalent now. We’ll dive into the (minor) differences next.</p>
<h4 id="object-literal-types-can-be-inlined"><a class="heading-id-link" href="#object-literal-types-can-be-inlined">18.5.1 Object literal types can be inlined</a></h4>
<p>Object literal types can be inlined, while interfaces can’t be:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// The object literal type is inlined</span></code>
<code><span class="hljs-comment">// (mentioned inside the parameter definition)</span></code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params">x: {prop: <span class="hljs-built_in">number</span>}</span>) {}</code>
<code/>
<code><span class="hljs-comment">// We can’t mention the interface inside the parameter definition.</span></code>
<code><span class="hljs-comment">// We can only define it externally and refer to it.</span></code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params">x: ObjectInterface</span>) {} </code>
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ObjectInterface</span> {</code>
<code>  <span class="hljs-attr">prop</span>: <span class="hljs-built_in">number</span>;</code>
<code>}</code>
</pre>
<h4 id="interfaces-with-the-same-name-are-merged"><a class="heading-id-link" href="#interfaces-with-the-same-name-are-merged">18.5.2 Interfaces with the same name are merged</a></h4>
<p>Type aliases with duplicate names are illegal:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// @ts-expect-error: Duplicate identifier 'PersonAlias'.</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">PersonAlias</span> = {<span class="hljs-attr">first</span>: <span class="hljs-built_in">string</span>};</code>
<code><span class="hljs-comment">// @ts-expect-error: Duplicate identifier 'PersonAlias'.</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">PersonAlias</span> = {<span class="hljs-attr">last</span>: <span class="hljs-built_in">string</span>};</code>
</pre>
<p>Conversely, interfaces with duplicate names are merged:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PersonInterface</span> {</code>
<code>  <span class="hljs-attr">first</span>: <span class="hljs-built_in">string</span>;</code>
<code>}</code>
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PersonInterface</span> {</code>
<code>  <span class="hljs-attr">last</span>: <span class="hljs-built_in">string</span>;</code>
<code>}</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">jane</span>: <span class="hljs-title class_">PersonInterface</span> = {</code>
<code>  <span class="hljs-attr">first</span>: <span class="hljs-string">'Jane'</span>,</code>
<code>  <span class="hljs-attr">last</span>: <span class="hljs-string">'Doe'</span>,</code>
<code>};</code>
</pre>
<p>This is called <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html">declaration merging</a> and can be used to combine types from multiple sources – e.g., as long as <code>Array.fromAsync()</code> is a new method, it is not part of the core library declaration file, but provided via <code>lib.esnext.array.d.ts</code> – which adds it as an increment to <code>ArrayConstructor</code> (the type of <code>Array</code> as a class value):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ArrayConstructor</span> {</code>
<code>  fromAsync&lt;T&gt;(···): <span class="hljs-title class_">Promise</span>&lt;T[]&gt;;</code>
<code>}</code>
</pre>
<h4 id="mapped-types-look-like-object-literal-types"><a class="heading-id-link" href="#mapped-types-look-like-object-literal-types">18.5.3 Mapped types look like object literal types</a></h4>
<p>A mapped type (line A) looks like an object literal type:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = {</code>
<code>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>,</code>
<code>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>,</code>
<code>};</code>
<code/>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">PointCopy1</span> = {</code>
<code>  [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Point</span>]: <span class="hljs-title class_">Point</span>[<span class="hljs-title class_">Key</span>] <span class="hljs-comment">// (A)</span></code>
<code>};</code>
</pre>
<p>As an option, we can end line A with a semicolon. Alas, a comma is not allowed.</p>
<p>For more information on this topic, see <a href="ch_mapped-types.html#ch_mapped-types">“Mapped types <code>{[K in U]: X}</code>” (§36)</a>.</p>
<h4 id="only-interfaces-support-polymorphic-this-types"><a class="heading-id-link" href="#only-interfaces-support-polymorphic-this-types">18.5.4 Only interfaces support polymorphic <code>this</code> types</a></h4>
<p>Polymorphic <code>this</code> types can only be used in interfaces:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">AddsStrings</span> {</code>
<code>  <span class="hljs-title function_">add</span>(<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>): <span class="hljs-variable language_">this</span>;</code>
<code>};</code>
<code/>
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AddsStrings</span> {</code>
<code>  result = <span class="hljs-string">''</span>;</code>
<code>  <span class="hljs-title function_">add</span>(<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>): <span class="hljs-variable language_">this</span> {</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> += str;</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;</code>
<code>  }</code>
<code>}</code>
</pre>
<h4 id="extending-interfaces"><a class="heading-id-link" href="#extending-interfaces">18.5.5 Only interfaces support <code>extends</code> – but type intersection (<code>&amp;</code>) is similar</a></h4>
<p>An interface <code>B</code> can extend another interface <code>A</code> and is then interpreted as an increment of <code>A</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> A {</code>
<code>  <span class="hljs-attr">propA</span>: <span class="hljs-built_in">number</span>;</code>
<code>}</code>
<code><span class="hljs-keyword">interface</span> B <span class="hljs-keyword">extends</span> A {</code>
<code>  <span class="hljs-attr">propB</span>: <span class="hljs-built_in">number</span>;</code>
<code>}</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  B,</code>
<code>  {</code>
<code>    <span class="hljs-attr">propA</span>: <span class="hljs-built_in">number</span>,</code>
<code>    <span class="hljs-attr">propB</span>: <span class="hljs-built_in">number</span>,</code>
<code>  }</code>
<code>&gt;&gt;;</code>
</pre>
<p>Object literal types don’t support <code>extend</code> but an intersection type <code>&amp;</code> has a similar effect:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> A = {</code>
<code>  <span class="hljs-attr">propA</span>: <span class="hljs-built_in">number</span>,</code>
<code>};</code>
<code><span class="hljs-keyword">type</span> B = {</code>
<code>  <span class="hljs-attr">propB</span>: <span class="hljs-built_in">number</span>,</code>
<code>} &amp; A;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  B,</code>
<code>  {</code>
<code>    <span class="hljs-attr">propA</span>: <span class="hljs-built_in">number</span>,</code>
<code>    <span class="hljs-attr">propB</span>: <span class="hljs-built_in">number</span>,</code>
<code>  }</code>
<code>&gt;&gt;;</code>
</pre>
<p>Intersections of object types are described in more detail in <a href="ch_intersections-object-types.html#intersections-of-object-types">another chapter</a>. Here, we’ll explore how exactly they differ from <code>extends</code>.</p>
<h5 id="conflicts"><a class="heading-id-link" href="#conflicts">18.5.5.1 Conflicts</a></h5>
<p>If there is a conflict between an extending interface and an extended interface then that’s an error:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> A {</code>
<code>  <span class="hljs-attr">prop</span>: <span class="hljs-built_in">string</span>;</code>
<code>}</code>
<code><span class="hljs-comment">// @ts-expect-error: Interface 'B' incorrectly extends interface 'A'.</span></code>
<code><span class="hljs-comment">// Types of property 'prop' are incompatible.</span></code>
<code><span class="hljs-keyword">interface</span> B <span class="hljs-keyword">extends</span> A {</code>
<code>  <span class="hljs-attr">prop</span>: <span class="hljs-built_in">number</span>;</code>
<code>}</code>
</pre>
<p>In contrast, intersection types don’t complain about conflicts, but they may result in <code>never</code> in some locations:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> A = {</code>
<code>  <span class="hljs-attr">prop</span>: <span class="hljs-built_in">string</span>,</code>
<code>};</code>
<code><span class="hljs-keyword">type</span> B = {</code>
<code>  <span class="hljs-attr">prop</span>: <span class="hljs-built_in">number</span>,</code>
<code>} &amp; A;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  B,</code>
<code>  {</code>
<code>    <span class="hljs-attr">prop</span>: <span class="hljs-built_in">number</span> &amp; <span class="hljs-built_in">string</span>, <span class="hljs-comment">// never</span></code>
<code>  }</code>
<code>&gt;&gt;;</code>
</pre>
<h5 id="only-interfaces-support-overriding"><a class="heading-id-link" href="#only-interfaces-support-overriding">18.5.5.2 Only interfaces support overriding</a></h5>
<p>Overriding a method means replacing a method in a supertype with a <em>compatible</em> method – roughly:</p>
<ul>
  <li>
    The overriding method can return more specific values – e.g. invokers of the overridden method that expect an <code>Object</code> won’t mind if the overriding method returns a <code>RegExp</code>.
  </li>
  <li>
    The overriding method can expect less specific parameters – e.g. invokers of the overridden method that pass an argument of type <code>string</code> won’t mind if the overriding method accepts <code>string | number</code>.
  </li>
</ul>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> A {</code>
<code>  <span class="hljs-title function_">m</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Object</span>;</code>
<code>}</code>
<code><span class="hljs-keyword">interface</span> B <span class="hljs-keyword">extends</span> A {</code>
<code>  <span class="hljs-title function_">m</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>): <span class="hljs-title class_">RegExp</span>;</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  B,</code>
<code>  {</code>
<code>    <span class="hljs-title function_">m</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>): <span class="hljs-title class_">RegExp</span>,</code>
<code>  }</code>
<code>&gt;&gt;;</code>
<code/>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x: B</span>) {</code>
<code>  assertType&lt;<span class="hljs-title class_">RegExp</span>&gt;(x.<span class="hljs-title function_">m</span>(<span class="hljs-string">'abc'</span>));</code>
<code>}</code>
</pre>
<p>We can see that the overriding method “wins” and completely replaces the overridden method in <code>B</code>. In contrast, both methods exist in parallel in an intersection type:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> A = {</code>
<code>  <span class="hljs-title function_">m</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Object</span>,</code>
<code>};</code>
<code><span class="hljs-keyword">type</span> B = {</code>
<code>  <span class="hljs-title function_">m</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>): <span class="hljs-title class_">RegExp</span>,</code>
<code>};</code>
<code/>
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    A &amp; B,</code>
<code>    {</code>
<code>      <span class="hljs-attr">m</span>: (<span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-title class_">Object</span>) &amp; (<span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-title class_">RegExp</span>),</code>
<code>    }</code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    B &amp; A,</code>
<code>    {</code>
<code>      <span class="hljs-attr">m</span>: (<span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-title class_">RegExp</span>) &amp; (<span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-title class_">Object</span>),</code>
<code>    }</code>
<code>  &gt;&gt;,</code>
<code>];</code>
<code/>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params">x: A &amp; B</span>) {</code>
<code>  assertType&lt;<span class="hljs-title class_">Object</span>&gt;(x.<span class="hljs-title function_">m</span>(<span class="hljs-string">'abc'</span>)); <span class="hljs-comment">// (A)</span></code>
<code>}</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params">x: B &amp; A</span>) {</code>
<code>  assertType&lt;<span class="hljs-title class_">RegExp</span>&gt;(x.<span class="hljs-title function_">m</span>(<span class="hljs-string">'abc'</span>)); <span class="hljs-comment">// (B)</span></code>
<code>}</code>
</pre>
<p>When it comes to the return type (line A and line B), the earlier member of the intersection wins. That’s why <code>B &amp; A</code> (<code>B1</code>) is more similar to <code>B extends A</code>, even though <code>A &amp; B</code> (<code>B2</code>) looks nicer:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">B1</span> = {</code>
<code>  <span class="hljs-attr">prop</span>: <span class="hljs-built_in">number</span>,</code>
<code>} &amp; A;</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">B2</span> = A &amp; {</code>
<code>  <span class="hljs-attr">prop</span>: <span class="hljs-built_in">number</span>,</code>
<code>};</code>
</pre>
<h5 id="extends-or-which-one-to-use"><a class="heading-id-link" href="#extends-or-which-one-to-use">18.5.5.3 <code>extends</code> or <code>&amp;</code> – which one to use?</a></h5>
<p>Which one to use depends on the context. If inheritance is involved then an interface and <code>extends</code> is usually the better choice due to their support of overriding.</p>
<div class="boxout">
  <p><img src="../Images/c1f1e62c75044317fd354db81eaefed3.png" height="24" class="boxout-icon" alt="Icon “external”" data-original-src="https://exploringjs.com/ts/book/icon/external.svg"/> <strong>Source of this section</strong></p>
  <div class="boxout-vspace"/>
  <ul>
    <li>
      <a href="https://github.com/peerigon/eslint-config-peerigon/issues/64">GitHub issue “TypeScript: types vs. interfaces”</a> by <a href="https://github.com/jhnns">Johannes Ewald</a>
    </li>
  </ul>
</div>
<h3 id="forbidding-properties-via-never"><a class="heading-id-link" href="#forbidding-properties-via-never">18.6 Forbidding properties via <code>never</code></a></h3>
<p>Given that no other type is assignable to <code>never</code>, we can use it to forbid properties.</p>
<h4 id="forbidding-properties-with-string-keys"><a class="heading-id-link" href="#forbidding-properties-with-string-keys">18.6.1 Forbidding properties with string keys</a></h4>
<p>The type <code>EmptyObject</code> forbids string keys:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">EmptyObject</span> = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">never</span>&gt;;</code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Type 'number' is not assignable to type 'never'.</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj1</span>: <span class="hljs-title class_">EmptyObject</span> = { <span class="hljs-attr">prop</span>: <span class="hljs-number">123</span> };</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj2</span>: <span class="hljs-title class_">EmptyObject</span> = {}; <span class="hljs-comment">// OK</span></code>
</pre>
<p>In contrast, the type <code>{}</code> is assignable from all objects and not a type for empty objects:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj3</span>: {} = { <span class="hljs-attr">prop</span>: <span class="hljs-number">123</span> };</code>
</pre>
<h4 id="forbidding-index-properties-with-number-keys"><a class="heading-id-link" href="#forbidding-index-properties-with-number-keys">18.6.2 Forbidding index properties (with number keys)</a></h4>
<p>The type <code>NoIndices</code> forbids number keys but allows the string key <code>'prop'</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">NoIndices</span> = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">never</span>&gt; &amp; { prop?: <span class="hljs-built_in">boolean</span> };</code>
<code/>
<code><span class="hljs-comment">//===== Objects =====</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj1</span>: <span class="hljs-title class_">NoIndices</span> = {}; <span class="hljs-comment">// OK</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj2</span>: <span class="hljs-title class_">NoIndices</span> = { <span class="hljs-attr">prop</span>: <span class="hljs-literal">true</span> }; <span class="hljs-comment">// OK</span></code>
<code><span class="hljs-comment">// @ts-expect-error: Type 'string' is not assignable to type 'never'.</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj3</span>: <span class="hljs-title class_">NoIndices</span> = { <span class="hljs-number">0</span>: <span class="hljs-string">'a'</span> }; <span class="hljs-comment">// OK</span></code>
<code/>
<code><span class="hljs-comment">//===== Arrays =====</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">arr1</span>: <span class="hljs-title class_">NoIndices</span> = []; <span class="hljs-comment">// OK</span></code>
<code><span class="hljs-comment">// @ts-expect-error: Type 'string' is not assignable to type 'never'.</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">arr2</span>: <span class="hljs-title class_">NoIndices</span> = [<span class="hljs-string">'a'</span>];</code>
</pre>
<h3 id="index-signatures"><a class="heading-id-link" href="#index-signatures">18.7 Index signatures: objects as dictionaries</a></h3>
<p>So far, we have only used types for fixed-layout objects. How do we express the fact that an object is to be used as a dictionary? For example: What should <code>TranslationDict</code> be in the following code fragment?</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">translate</span>(<span class="hljs-params">dict: TranslationDict, english: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span> {</code>
<code>  <span class="hljs-keyword">const</span> translation = dict[english];</code>
<code>  <span class="hljs-keyword">if</span> (translation === <span class="hljs-literal">undefined</span>) {</code>
<code>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();</code>
<code>  }</code>
<code>  <span class="hljs-keyword">return</span> translation;</code>
<code>}</code>
</pre>
<p>One option is to use an index signature (line A) to express that <code>TranslationDict</code> is for objects that map string keys to string values (another option is <code>Record</code> – which we’ll get to <a href="#record-for-dictionary-objects">later</a>):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">TranslationDict</span> = {</code>
<code>  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>, <span class="hljs-comment">// (A)</span></code>
<code>};</code>
<code><span class="hljs-keyword">const</span> dict = {</code>
<code>  <span class="hljs-string">'yes'</span>: <span class="hljs-string">'sí'</span>,</code>
<code>  <span class="hljs-string">'no'</span>: <span class="hljs-string">'no'</span>,</code>
<code>  <span class="hljs-string">'maybe'</span>: <span class="hljs-string">'tal vez'</span>,</code>
<code>};</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">translate</span>(dict, <span class="hljs-string">'maybe'</span>),</code>
<code>  <span class="hljs-string">'tal vez'</span>);</code>
</pre>
<p>The name <code>key</code> doesn’t matter – it can be any identifier and is ignored (but can’t be omitted).</p>
<h4 id="typing-index-signature-keys"><a class="heading-id-link" href="#typing-index-signature-keys">18.7.1 Typing index signature keys</a></h4>
<p>An index signature represents an infinite set of properties; only the following types are allowed:</p>
<ul>
  <li>
    <code>string</code>
  </li>
  <li>
    <code>number</code>
  </li>
  <li>
    <code>symbol</code>
  </li>
  <li>
    A template string literal with an infinite primitive type – e.g.: <code>`${bigint}`</code>
  </li>
  <li>
    A union of any of the previous types
  </li>
</ul>
<p>Specifically <em>not</em> allowed are:</p>
<ul>
  <li>
    A single string literal type – e.g.: <code>'a'</code>, <code>1</code>, <code>false</code>
  </li>
  <li>
    A union of string literal types – e.g.:
    <ul>
      <li>
        <code>'a' | 'b'</code>
      </li>
      <li>
        <code>1 | 2</code>
      </li>
      <li>
        <code>boolean</code> (which is <code>false | true</code>)
      </li>
    </ul>
  </li>
  <li>
    A template string literal with one of the previous types – e.g.: <code>`${boolean}`</code>
  </li>
  <li>
    The types: <code>never</code>, <code>any</code>, <code>unknown</code>
  </li>
</ul>
<p>If you need more power then consider using <a href="ch_mapped-types.html#ch_mapped-types">a mapped types</a>.</p>
<p>These are examples of index signatures:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">IndexSignature1</span> = {</code>
<code>  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">boolean</span>,</code>
<code>};</code>
<code><span class="hljs-comment">// Template string literal with infinite primitive type</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">IndexSignature2</span> = {</code>
<code>  [<span class="hljs-attr">key</span>: <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">bigint</span>}</span>`</span>]: <span class="hljs-built_in">string</span>,</code>
<code>};</code>
<code><span class="hljs-comment">// Union of previous types</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">IndexSignature3</span> = {</code>
<code>  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span> | <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">bigint</span>}</span>`</span>]: <span class="hljs-built_in">string</span>,</code>
<code>};</code>
</pre>
<h4 id="string-keys-vs-number-keys"><a class="heading-id-link" href="#string-keys-vs-number-keys">18.7.2 String keys vs. number keys</a></h4>
<p>Just like in plain JavaScript, TypeScript’s number property keys are a subset of the string property keys (<a href="https://exploringjs.com/js/book/ch_arrays.html#array-indices">see “Exploring JavaScript”</a>). Accordingly, if we have both a string index signature and a number index signature, the property type of the former must be a supertype of the latter. The following example works because <code>Object</code> is a supertype of <code>RegExp</code> (<code>RegExp</code> is assignable to <code>Object</code>):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">StringAndNumberKeys</span> = {</code>
<code>  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">Object</span>,</code>
<code>  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-title class_">RegExp</span>,</code>
<code>};</code>
</pre>
<p>The following code demonstrates the effects of using strings and numbers as property keys:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x: StringAndNumberKeys</span>) {</code>
<code>  <span class="hljs-keyword">return</span> {</code>
<code>    <span class="hljs-attr">str</span>: x[<span class="hljs-string">'abc'</span>],</code>
<code>    <span class="hljs-attr">num</span>: x[<span class="hljs-number">123</span>],</code>
<code>  };</code>
<code>}</code>
<code>assertType&lt;</code>
<code>  <span class="hljs-function">(<span class="hljs-params">x: StringAndNumberKeys</span>) =&gt;</span> {</code>
<code>    <span class="hljs-attr">str</span>: <span class="hljs-title class_">Object</span> | <span class="hljs-literal">undefined</span>,</code>
<code>    <span class="hljs-attr">num</span>: <span class="hljs-title class_">RegExp</span> | <span class="hljs-literal">undefined</span>,</code>
<code>  }</code>
<code>&gt;(f);</code>
</pre>
<h4 id="index-signatures-vs-property-signatures-and-method-signatures"><a class="heading-id-link" href="#index-signatures-vs-property-signatures-and-method-signatures">18.7.3 Index signatures vs. property signatures and method signatures</a></h4>
<p>If there are both an index signature and property and/or method signatures in an object literal type, then the type of the index property value must also be a supertype of the type of the property value and/or method.</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = {</code>
<code>  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">boolean</span>,</code>
<code/>
<code>  <span class="hljs-comment">// @ts-expect-error: Property 'myProp' of type 'number' is not assignable</span></code>
<code>  <span class="hljs-comment">// to 'string' index type 'boolean'.</span></code>
<code>  <span class="hljs-attr">myProp</span>: <span class="hljs-built_in">number</span>,</code>
<code>  </code>
<code>  <span class="hljs-comment">// @ts-expect-error: Property 'myMethod' of type '() =&gt; string' is not</span></code>
<code>  <span class="hljs-comment">// assignable to 'string' index type 'boolean'.</span></code>
<code>  <span class="hljs-title function_">myMethod</span>(): <span class="hljs-built_in">string</span>,</code>
<code>};</code>
</pre>
<p>In contrast, the following two object literal types produce no errors:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = {</code>
<code>  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>,</code>
<code>  <span class="hljs-attr">myProp</span>: <span class="hljs-built_in">number</span>,</code>
<code>};</code>
<code/>
<code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T3</span> = {</code>
<code>  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>,</code>
<code>  <span class="hljs-title function_">myMethod</span>(): <span class="hljs-built_in">string</span>,</code>
<code>}</code>
</pre>
<h3 id="record-for-dictionary-objects"><a class="heading-id-link" href="#record-for-dictionary-objects">18.8 <code>Record&lt;K, V&gt;</code> for dictionary objects</a></h3>
<p>The built-in generic utility type <code>Record&lt;K, V&gt;</code> is for dictionary objects whose keys are of type <code>K</code> and whose values are of type <code>V</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">dict</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt; = {</code>
<code>  <span class="hljs-attr">one</span>: <span class="hljs-number">1</span>,</code>
<code>  <span class="hljs-attr">two</span>: <span class="hljs-number">2</span>,</code>
<code>  <span class="hljs-attr">three</span>: <span class="hljs-number">3</span>,</code>
<code>};</code>
</pre>
<p>If you are curious how <code>Record</code> is defined: <a href="ch_mapped-types.html#utility-type-record">“<code>Record</code> is a mapped type” (§36.6)</a>. This knowledge can help with remembering how it handles finite and infinite key types.</p>
<p><code>Record</code> supports unions of literal types as key types; index signatures don’t. More on that next.</p>
<h4 id="index-signatures-don-t-allow-key-unions"><a class="heading-id-link" href="#index-signatures-don-t-allow-key-unions">18.8.1 Index signatures don’t allow key unions</a></h4>
<p>The key type of an index signature must be infinite:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Key</span> = <span class="hljs-string">'A'</span> | <span class="hljs-string">'B'</span> | <span class="hljs-string">'C'</span>;</code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: An index signature parameter type cannot be a literal</span></code>
<code><span class="hljs-comment">// type or generic type. Consider using a mapped object type instead.</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">dict</span>: {[<span class="hljs-attr">key</span>: <span class="hljs-title class_">Key</span>]: <span class="hljs-literal">true</span>} = {</code>
<code>  <span class="hljs-attr">A</span>: <span class="hljs-literal">true</span>,</code>
<code>  <span class="hljs-attr">C</span>: <span class="hljs-literal">true</span>,</code>
<code>};</code>
</pre>
<h4 id="record-enforces-exhaustiveness-for-key-unions"><a class="heading-id-link" href="#record-enforces-exhaustiveness-for-key-unions">18.8.2 <code>Record</code> enforces exhaustiveness for key unions</a></h4>
<p><code>Record</code> enforces exhaustiveness if its key type is a union of literal types:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> T = <span class="hljs-string">'A'</span> | <span class="hljs-string">'B'</span> | <span class="hljs-string">'C'</span>;</code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Property 'C' is missing in type '{ A: true; B: true; }'</span></code>
<code><span class="hljs-comment">// but required in type 'Record&lt;T, true&gt;'.</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">nonExhaustiveKeys</span>: <span class="hljs-title class_">Record</span>&lt;T, <span class="hljs-literal">true</span>&gt; = {</code>
<code>  <span class="hljs-attr">A</span>: <span class="hljs-literal">true</span>,</code>
<code>  <span class="hljs-attr">B</span>: <span class="hljs-literal">true</span>,</code>
<code>};</code>
<code/>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">exhaustiveKeys</span>: <span class="hljs-title class_">Record</span>&lt;T, <span class="hljs-literal">true</span>&gt; = {</code>
<code>  <span class="hljs-attr">A</span>: <span class="hljs-literal">true</span>,</code>
<code>  <span class="hljs-attr">B</span>: <span class="hljs-literal">true</span>,</code>
<code>  <span class="hljs-attr">C</span>: <span class="hljs-literal">true</span>,</code>
<code>};</code>
</pre>
<p>Wrong keys also produce errors:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">wrongKey</span>: <span class="hljs-title class_">Record</span>&lt;T, <span class="hljs-literal">true</span>&gt; = {</code>
<code>  <span class="hljs-attr">A</span>: <span class="hljs-literal">true</span>,</code>
<code>  <span class="hljs-attr">B</span>: <span class="hljs-literal">true</span>,</code>
<code>  <span class="hljs-comment">// @ts-expect-error: Object literal may only specify known properties,</span></code>
<code>  <span class="hljs-comment">// and 'D' does not exist in type 'Record&lt;T, true&gt;'.</span></code>
<code>  <span class="hljs-attr">D</span>: <span class="hljs-literal">true</span>,</code>
<code>};</code>
</pre>
<h4 id="record-preventing-exhaustiveness-checks-for-key-unions"><a class="heading-id-link" href="#record-preventing-exhaustiveness-checks-for-key-unions">18.8.3 <code>Record</code>: preventing exhaustiveness checks for key unions</a></h4>
<p>If we want to prevent exhaustiveness checks for keys whose type is a union then we can use the utility type <code>Partial</code> (which makes all properties optional). Then we can omit some properties, but wrong keys still produce errors:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> T = <span class="hljs-string">'A'</span> | <span class="hljs-string">'B'</span> | <span class="hljs-string">'C'</span>;</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">nonExhaustiveKeys</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">Record</span>&lt;T, <span class="hljs-literal">true</span>&gt;&gt; = {</code>
<code>  <span class="hljs-attr">A</span>: <span class="hljs-literal">true</span>,</code>
<code>};</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">wrongKey</span>: <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">Record</span>&lt;T, <span class="hljs-literal">true</span>&gt;&gt; = {</code>
<code>  <span class="hljs-comment">// @ts-expect-error: Object literal may only specify known properties,</span></code>
<code>  <span class="hljs-comment">// and 'D' does not exist in type 'Partial&lt;Record&lt;T, true&gt;&gt;'.</span></code>
<code>  <span class="hljs-attr">D</span>: <span class="hljs-literal">true</span>,</code>
<code>};</code>
</pre>
<h3 id="general-types-for-objects"><a class="heading-id-link" href="#general-types-for-objects">18.9 <code>object</code> vs <code>Object</code> vs. <code>{}</code></a></h3>
<p>These are three similar general types for objects:</p>
<ul>
  <li>
    <p><code>object</code> with a lowercase “o” is the type of all non-primitive values. It’s loosely related to the value <code>'object'</code> returned by the JavaScript operator <code>typeof</code>.</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj1</span>: <span class="hljs-built_in">object</span> = {};</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj2</span>: <span class="hljs-built_in">object</span> = [];</code>
<code><span class="hljs-comment">// @ts-expect-error: Type 'number' is not assignable to type 'object'.</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj3</span>: <span class="hljs-built_in">object</span> = <span class="hljs-number">123</span>;</code>
</pre>
  </li>
  <li>
    <p><code>Object</code> with an uppercase “O” is the type of the instances of class <code>Object</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj1</span>: <span class="hljs-title class_">Object</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();</code>
</pre>
    <p>But it also accepts primitive values (except for <code>undefined</code> and <code>null</code>):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj2</span>: <span class="hljs-title class_">Object</span> = <span class="hljs-number">123</span>;</code>
</pre>
    <p>Note that non-nullish primitive values inherit the methods of <code>Object.prototype</code> via their wrapper types.</p>
  </li>
  <li>
    <p><code>{}</code> accepts all non-nullish values. Its only difference with <code>Object</code> is that it doesn’t mind if a property conflicts with <code>Object.prototype</code> properties:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj1</span>: {} = { <span class="hljs-attr">toString</span>: <span class="hljs-literal">true</span> }; <span class="hljs-comment">// OK</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj2</span>: <span class="hljs-title class_">Object</span> = {</code>
<code>  <span class="hljs-comment">// @ts-expect-error: Type 'boolean' is not assignable to</span></code>
<code>  <span class="hljs-comment">// type '() =&gt; string'.</span></code>
<code>  <span class="hljs-attr">toString</span>: <span class="hljs-literal">true</span>,</code>
<code>};</code>
</pre>
    <p>So the type <code>{}</code> basically means: “Value must not be null”.</p>
  </li>
</ul>
<div class="boxout">
  <p><img src="../Images/0873709827ba4924e4afbb757e47a4df.png" height="24" class="boxout-icon" alt="Icon “tip”" data-original-src="https://exploringjs.com/ts/book/icon/tip.svg"/> <strong>These types are not used that often</strong></p>
  <div class="boxout-vspace"/>
  <p>Given that we can’t access any properties if we use these types, they are not used that often. If a value does have that type, we usually narrow its type via a <a href="ch_type-guards.html#ch_type-guards">type guard</a> before doing anything with it.</p>
</div>
<h4 id="plain-javascript-objects-vs-instances-of-object"><a class="heading-id-link" href="#plain-javascript-objects-vs-instances-of-object">18.9.1 Plain JavaScript: objects vs. instances of <code>Object</code></a></h4>
<p>In plain JavaScript, there is an important distinction.</p>
<p>On one hand, most objects are <em>instances</em> of <code>Object</code>.</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> obj1 = {};</span></code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">obj1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span></span></code>
<code>true</code>
</pre>
<p>That means:</p>
<ul>
  <li>
    <p><code>Object.prototype</code> is in their prototype chains (that’s what <code>instanceof</code> checks):</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(obj1)</span></code>
<code>true</code>
</pre>
  </li>
  <li>
    <p>They inherit its properties.</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">obj1.<span class="hljs-property">toString</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span></span></code>
<code>true</code>
</pre>
  </li>
</ul>
<p>On the other hand, we can also create objects that don’t have <code>Object.prototype</code> in their prototype chains. For example, the following object does not have any prototype at all:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> obj2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);</span></code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj2)</span></code>
<code>null</code>
</pre>
<p><code>obj2</code> is an object that is not an instance of class <code>Object</code>:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">typeof</span> obj2</span></code>
<code>'object'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">obj2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span></span></code>
<code>false</code>
</pre>
<h4 id="object-uppercase-o-in-typescript-instances-of-class-object"><a class="heading-id-link" href="#object-uppercase-o-in-typescript-instances-of-class-object">18.9.2 <code>Object</code> (uppercase “O”) in TypeScript: instances of class <code>Object</code></a></h4>
<p>Recall that each class <code>C</code> creates two entities:</p>
<ul>
  <li>
    A constructor function <code>C</code>.
  </li>
  <li>
    An object type <code>C</code> that describes instances of the constructor function.
  </li>
</ul>
<p>Similarly, there are two object types for class <code>Object</code>:</p>
<ul>
  <li>
    <p>Type <code>Object</code> specifies the properties of instances of <code>Object</code>, including the properties inherited from <code>Object.prototype</code>.</p>
  </li>
  <li>
    <p>Type <code>ObjectConstructor</code> specifies the properties of class <code>Object</code> (an object with properties).</p>
  </li>
</ul>
<p>These are the types:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Object</span> { <span class="hljs-comment">// (A)</span></code>
<code>  <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Function</span>;</code>
<code>  <span class="hljs-title function_">toString</span>(): <span class="hljs-built_in">string</span>;</code>
<code>  <span class="hljs-title function_">toLocaleString</span>(): <span class="hljs-built_in">string</span>;</code>
<code>  <span class="hljs-comment">/** Returns the primitive value of the specified object. */</span></code>
<code>  <span class="hljs-title function_">valueOf</span>(): <span class="hljs-title class_">Object</span>; <span class="hljs-comment">// (B)</span></code>
<code>  <span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-attr">v</span>: <span class="hljs-title class_">PropertyKey</span>): <span class="hljs-built_in">boolean</span>;</code>
<code>  <span class="hljs-title function_">isPrototypeOf</span>(<span class="hljs-attr">v</span>: <span class="hljs-title class_">Object</span>): <span class="hljs-built_in">boolean</span>;</code>
<code>  <span class="hljs-title function_">propertyIsEnumerable</span>(<span class="hljs-attr">v</span>: <span class="hljs-title class_">PropertyKey</span>): <span class="hljs-built_in">boolean</span>;</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ObjectConstructor</span> {</code>
<code>  <span class="hljs-comment">/** Invocation via `new` */</span></code>
<code>  <span class="hljs-title function_">new</span>(value?: <span class="hljs-built_in">any</span>): <span class="hljs-title class_">Object</span>;</code>
<code>  <span class="hljs-comment">/** Invocation via function calls */</span></code>
<code>  (value?: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">any</span>;</code>
<code/>
<code>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">prototype</span>: <span class="hljs-title class_">Object</span>; <span class="hljs-comment">// (C)</span></code>
<code/>
<code>  <span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-attr">o</span>: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">any</span>;</code>
<code>  <span class="hljs-comment">// ···</span></code>
<code>}</code>
<code><span class="hljs-keyword">declare</span> <span class="hljs-keyword">var</span> <span class="hljs-title class_">Object</span>: <span class="hljs-title class_">ObjectConstructor</span>; <span class="hljs-comment">// (D)</span></code>
</pre>
<p>Observations:</p>
<ul>
  <li>
    We have both a variable whose name is <code>Object</code> (line D) and a type whose name is <code>Object</code> (line A).
  </li>
  <li>
    <code>Object.prototype</code> also has the type <code>Object</code> (line C). Given that any instance of <code>Object</code> inherits all of its properties, that makes sense.
  </li>
  <li>
    It’s interesting that, in line B, <code>.valueOf()</code> has the return type <code>Object</code> and is supposed to return primitive values.
  </li>
</ul>
<h4 id="type-basically-means-not-nullish"><a class="heading-id-link" href="#type-basically-means-not-nullish">18.9.3 Type <code>{}</code> basically means: not nullish</a></h4>
<p><code>{}</code> accepts all values other than <code>undefined</code> and <code>null</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">v1</span>: {} = <span class="hljs-number">123</span>;</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">v2</span>: {} = <span class="hljs-number">123</span>;</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">v3</span>: {} = {};</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">v4</span>: {} = { <span class="hljs-attr">prop</span>: <span class="hljs-literal">true</span> };</code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Type 'undefined' is not assignable to type '{}'.</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">v5</span>: {} = <span class="hljs-literal">undefined</span>;</code>
<code><span class="hljs-comment">// @ts-expect-error: Type 'null' is not assignable to type '{}'.</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">v6</span>: {} = <span class="hljs-literal">null</span>;</code>
</pre>
<p>The helper type <code>NonNullable</code> uses <code>{}</code>:</p>
<pre class="language-ts">
<code><span class="hljs-comment">/**</span></code>
<code><span class="hljs-comment"> * Exclude null and undefined from T</span></code>
<code><span class="hljs-comment"> */</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">NonNullable</span>&lt;T&gt; = T &amp; {};</code>
<code/>
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">NonNullable</span>&lt;<span class="hljs-literal">undefined</span> | <span class="hljs-built_in">string</span>&gt;,</code>
<code>    <span class="hljs-built_in">string</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">NonNullable</span>&lt;<span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span>&gt;,</code>
<code>    <span class="hljs-built_in">string</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">NonNullable</span>&lt;<span class="hljs-built_in">string</span>&gt;,</code>
<code>    <span class="hljs-built_in">string</span></code>
<code>  &gt;&gt;,</code>
<code>];</code>
</pre>
<p>The result of <code>NonNullable&lt;T&gt;</code> is a type that is the intersection of <code>T</code> and all non-nullish values.</p>
<h4 id="inferred-types-for-various-objects"><a class="heading-id-link" href="#inferred-types-for-various-objects">18.9.4 Inferred types for various objects</a></h4>
<p>These are the types that TypeScript infers for objects that are created via various means:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> obj1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();</code>
<code>assertType&lt;<span class="hljs-title class_">Object</span>&gt;(obj1);</code>
<code/>
<code><span class="hljs-keyword">const</span> obj2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);</code>
<code>assertType&lt;<span class="hljs-built_in">any</span>&gt;(obj2);</code>
<code/>
<code><span class="hljs-keyword">const</span> obj3 = {};</code>
<code>assertType&lt;{}&gt;(obj3);</code>
<code/>
<code><span class="hljs-keyword">const</span> obj4 = {<span class="hljs-attr">prop</span>: <span class="hljs-number">123</span>};</code>
<code>assertType&lt;{<span class="hljs-attr">prop</span>: <span class="hljs-built_in">number</span>}&gt;(obj4);</code>
<code/>
<code><span class="hljs-keyword">const</span> obj5 = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getPrototypeOf</span>({});</code>
<code>assertType&lt;<span class="hljs-built_in">object</span> | <span class="hljs-literal">null</span>&gt;(obj5);</code>
</pre>
<p>In principle, the return type of <code>Object.create()</code> could (and probably should) be <code>object</code> or a computed type. However, for historic reasons, it is <code>any</code>. That allows us to add and change properties of the result.</p>
<h3 id="summary-object-vs-object-vs-vs-record"><a class="heading-id-link" href="#summary-object-vs-object-vs-vs-record">18.10 Summary: <code>object</code> vs <code>Object</code> vs. <code>{}</code> vs. <code>Record</code></a></h3>
<p>The following table compares four types for objects:</p>
<table class="framed">
  <style>
    th:nth-child(1), td:nth-child(1) {
      text-align: left;
    }
    th:nth-child(2), td:nth-child(2) {
      text-align: left;
    }
    th:nth-child(3), td:nth-child(3) {
      text-align: left;
    }
    th:nth-child(4), td:nth-child(4) {
      text-align: left;
    }
    th:nth-child(5), td:nth-child(5) {
      text-align: left;
    }
  </style>
  <thead>
    <tr>
      <th/><th><code>object</code></th><th><code>Object</code></th><th><code>{}</code></th><th><code>Record</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Accepts <code>undefined</code> or <code>null</code></td><td>✘</td><td>✘</td><td>✘</td><td>✘</td>
    </tr>
    <tr>
      <td>Accepts primitive values</td><td>✘</td><td>✔</td><td>✔</td><td>✘</td>
    </tr>
    <tr>
      <td>Has <code>.toString()</code></td><td>✔</td><td>✔</td><td>✔</td><td>N/A</td>
    </tr>
    <tr>
      <td>Values can conflict with <code>Object</code></td><td>✔</td><td>✘</td><td>✔</td><td>N/A</td>
    </tr>
  </tbody>
</table>
<p>The last two table rows don’t really make sense for <code>Record</code> – which is why there is an “N/A” in its cells.</p>
<p><strong>Accepts <code>undefined</code> or <code>null</code>:</strong></p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Not</span>&lt;<span class="hljs-title class_">Assignable</span>&lt;</code>
<code>    <span class="hljs-built_in">object</span>, <span class="hljs-literal">undefined</span></code>
<code>  &gt;&gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Not</span>&lt;<span class="hljs-title class_">Assignable</span>&lt;</code>
<code>    <span class="hljs-title class_">Object</span>, <span class="hljs-literal">undefined</span></code>
<code>  &gt;&gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Not</span>&lt;<span class="hljs-title class_">Assignable</span>&lt;</code>
<code>    {}, <span class="hljs-literal">undefined</span></code>
<code>  &gt;&gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Not</span>&lt;<span class="hljs-title class_">Assignable</span>&lt;</code>
<code>    <span class="hljs-title class_">Record</span>&lt;keyof <span class="hljs-built_in">any</span>, <span class="hljs-built_in">any</span>&gt;, <span class="hljs-literal">undefined</span></code>
<code>  &gt;&gt;&gt;,</code>
<code>];</code>
</pre>
<p><strong>Accepts primitive values:</strong></p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Not</span>&lt;<span class="hljs-title class_">Assignable</span>&lt;</code>
<code>    <span class="hljs-built_in">object</span>, <span class="hljs-number">123</span></code>
<code>  &gt;&gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Assignable</span>&lt;</code>
<code>    <span class="hljs-title class_">Object</span>, <span class="hljs-number">123</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Assignable</span>&lt;</code>
<code>    {}, <span class="hljs-number">123</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Not</span>&lt;<span class="hljs-title class_">Assignable</span>&lt;</code>
<code>    <span class="hljs-title class_">Record</span>&lt;keyof <span class="hljs-built_in">any</span>, <span class="hljs-built_in">any</span>&gt;, <span class="hljs-number">123</span></code>
<code>  &gt;&gt;&gt;,</code>
<code>];</code>
</pre>
<p><strong>Has <code>.toString()</code>:</strong></p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Assignable</span>&lt;</code>
<code>    { <span class="hljs-title function_">toString</span>(): <span class="hljs-built_in">string</span> }, <span class="hljs-built_in">object</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Assignable</span>&lt;</code>
<code>    { <span class="hljs-title function_">toString</span>(): <span class="hljs-built_in">string</span> }, <span class="hljs-title class_">Object</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Assignable</span>&lt;</code>
<code>    { <span class="hljs-title function_">toString</span>(): <span class="hljs-built_in">string</span> }, {}</code>
<code>  &gt;&gt;,</code>
<code>];</code>
</pre>
<p><strong>Values can conflict with <code>Object</code>:</strong></p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Assignable</span>&lt;</code>
<code>    <span class="hljs-built_in">object</span>, { <span class="hljs-title function_">toString</span>(): <span class="hljs-built_in">number</span> }</code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Not</span>&lt;<span class="hljs-title class_">Assignable</span>&lt;</code>
<code>    <span class="hljs-title class_">Object</span>, { <span class="hljs-title function_">toString</span>(): <span class="hljs-built_in">number</span> }</code>
<code>  &gt;&gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Assignable</span>&lt;</code>
<code>    {}, { <span class="hljs-title function_">toString</span>(): <span class="hljs-built_in">number</span> }</code>
<code>  &gt;&gt;,</code>
<code>];</code>
</pre>
<h3 id="sources-of-this-chapter-2"><a class="heading-id-link" href="#sources-of-this-chapter-2">18.11 Sources of this chapter</a></h3>
<ul>
  <li>
    <a href="https://www.typescriptlang.org/docs/handbook/basic-types.html">TypeScript Handbook</a>
  </li>
</ul>

    
      
</body>
</html>