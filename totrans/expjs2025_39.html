<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>32 Synchronous iteration ES6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>32 Synchronous iteration ES6</h1>
<blockquote>原文：<a href="https://exploringjs.com/js/book/ch_sync-iteration.html">https://exploringjs.com/js/book/ch_sync-iteration.html</a></blockquote>

        
    
    
    
<p><span id="index-entry-synchronous-iteration"/><span id="index-entry-iteration--synchronous"/></p>
<nav class="local-toc">
  <ol>
    <li>
      <a href="#motivation-sync-iteration">32.1 What is synchronous iteration about?</a>
    </li>
    <li>
      <a href="#iterable-iterator-iteratorresult">32.2 Core iteration roles: iterables and iterators</a>
    </li>
    <li>
      <a href="#iterating-over-data">32.3 Iterating over data</a>
      <ol>
        <li>
          <a href="#manually-iterating-over-data">32.3.1 Manually iterating over data</a>
        </li>
        <li>
          <a href="#using-while-to-iterate-manually">32.3.2 Using <code>while</code> to iterate manually</a>
        </li>
        <li>
          <a href="#retrieving-an-iterator-via-iteratorfrom-es2024">32.3.3 Retrieving an iterator via <code>Iterator.from()</code><span> <sup>ES2024</sup></span></a>
        </li>
        <li>
          <a href="#iterating-via-iterationbased-language-constructs">32.3.4 Iterating via iteration-based language constructs</a>
        </li>
        <li>
          <a href="#converting-iterables-to-arrays-i-and-arrayfromi">32.3.5 Converting iterables to Arrays: <code>[...i]</code> and <code>Array.from(i)</code></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#processing-iterables-via-generators">32.4 Processing iterables via generators</a>
    </li>
    <li>
      <a href="#the-inheritance-of-the-iteration-api-advanced">32.5 The inheritance of the iteration API<span> (advanced)</span></a>
      <ol>
        <li>
          <a href="#array-iterators">32.5.1 Array iterators</a>
        </li>
        <li>
          <a href="#generator-objects">32.5.2 Generator objects</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#iterable-iterators">32.6 Iterable iterators</a>
      <ol>
        <li>
          <a href="#why-are-the-builtin-iterators-iterable">32.6.1 Why are the built-in iterators iterable?</a>
        </li>
        <li>
          <a href="#an-iterator-returns-itself-when-asked-for-an-iterator">32.6.2 An iterator returns itself when asked for an iterator</a>
        </li>
        <li>
          <a href="#one-time-iterable-vs-many-times-iterable">32.6.3 Iteration quirk: two kinds of iterables</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#class-iterator">32.7 Class <code>Iterator</code> and iterator helper methods<span> <sup>ES2025</sup></span></a>
      <ol>
        <li>
          <a href="#iteratorprototype-methods">32.7.1 <code>Iterator.prototype.*</code> methods</a>
        </li>
        <li>
          <a href="#benefits-of-iterator-helper-methods">32.7.2 The benefits of iterator helper methods</a>
        </li>
        <li>
          <a href="#Iterator.from">32.7.3 <code>Iterator.from()</code>: creating API iterators</a>
        </li>
        <li>
          <a href="#iterator-methods-change-how-we-use-iteration">32.7.4 Iterator methods change how we use iteration</a>
        </li>
        <li>
          <a href="#upgrading-a-legacy-iterable-to-the-iterator-api">32.7.5 Upgrading a legacy iterable to the <code>Iterator</code> API</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#grouping-sync-iterables">32.8 Grouping iterables<span> <sup>ES2024</sup></span></a>
      <ol>
        <li>
          <a href="#choosing-between-mapgroupby-and-objectgroupby">32.8.1 Choosing between <code>Map.groupBy()</code> and <code>Object.groupBy()</code></a>
        </li>
        <li>
          <a href="#example-handling-cases">32.8.2 Example: handling cases</a>
        </li>
        <li>
          <a href="#example-grouping-by-property-value">32.8.3 Example: grouping by property value</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#quickref-sync-iteration">32.9 Quick reference: synchronous iteration</a>
      <ol>
        <li>
          <a href="#synchronous-iteration-data-producers">32.9.1 Synchronous iteration: data producers</a>
        </li>
        <li>
          <a href="#synchronous-iteration-data-consumers">32.9.2 Synchronous iteration: data consumers</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#quickref-iterator">32.10 Quick reference: class <code>Iterator</code><span> <sup>ES2025</sup></span></a>
      <ol>
        <li>
          <a href="#creating-iterators">32.10.1 Creating iterators</a>
        </li>
        <li>
          <a href="#iterator">32.10.2 <code>Iterator.*</code></a>
        </li>
        <li>
          <a href="#iteratorprototype-methods-that-pass-indices-to-callbacks">32.10.3 <code>Iterator.prototype.*</code>: methods that pass indices to callbacks</a>
        </li>
        <li>
          <a href="#iteratorprototype-methods-that-return-iterators">32.10.4 <code>Iterator.prototype.*</code>: methods that return iterators</a>
        </li>
        <li>
          <a href="#iteratorprototype-methods-that-return-booleans">32.10.5 <code>Iterator.prototype.*</code>: methods that return booleans</a>
        </li>
        <li>
          <a href="#iteratorprototype-methods-that-return-other-kinds-of-values">32.10.6 <code>Iterator.prototype.*</code>: methods that return other kinds of values</a>
        </li>
        <li>
          <a href="#iteratorprototype-other-methods">32.10.7 <code>Iterator.prototype.*</code>: other methods</a>
        </li>
      </ol>
    </li>
  </ol>
</nav>
<h3 id="motivation-sync-iteration"><a class="heading-id-link" href="#motivation-sync-iteration">32.1 What is synchronous iteration about?</a></h3>
<p>Synchronous iteration is a <em>protocol</em> (interfaces plus rules for using them) that connects two groups of entities in JavaScript:</p>
<ul>
  <li>
    <p><strong>Data sources:</strong> On one hand, data comes in all shapes and sizes. In JavaScript’s standard library, we have the linear data structure Array, the ordered collection Set (elements are ordered by time of addition), the ordered dictionary Map (entries are ordered by time of addition), and more. In libraries, we may find tree-shaped data structures and more.</p>
  </li>
  <li>
    <p><strong>Data consumers:</strong> On the other hand, we have a whole class of constructs and algorithms that only need to access their input <em>sequentially</em>: one value at a time, until all values were visited. Examples include the <code>for-of</code> loop and spreading into Array literals (via <code>...</code>).</p>
  </li>
</ul>
<p>The iteration protocol connects these two groups via the interface <code>Iterable</code>: data sources deliver their contents sequentially “through it”; data consumers get their input from it.</p>
<figure id="fig:iterable-implementers-clients" class="float">
  <p><img src="../Images/52bbdbeebda7e97eed377dd5c6cf02df.png" width="309" height="104" alt="" data-original-src="https://exploringjs.com/js/book/img/sync-iteration/iterable-implementers-clients.svg"/></p>
  <figcaption>
    <p><span class="float-label">Figure 32.1:</span> Data consumers such as the <code>for-of</code> loop use the interface <code>Iterable</code>. Data sources such as <code>Arrays</code> implement that interface.</p>
  </figcaption>
</figure>
<p><a href="#fig:iterable-implementers-clients">Figure 32.1</a> illustrates how iteration works: data consumers use the interface <code>Iterable</code>; data sources implement it.</p>
<div class="boxout">
  <p><img src="../Images/38ba63de820aae6f94a019538ae0f222.png" class="boxout-icon" height="24" alt="Icon “details”" data-original-src="https://exploringjs.com/js/book/icon/details.svg"/> <strong>The JavaScript way of implementing interfaces</strong></p>
  <div class="boxout-vspace"/>
  <p>In JavaScript, an object <em>implements</em> an interface if it has all the methods that it describes. The interfaces mentioned in this chapter only exist in the ECMAScript specification.</p>
</div>
<p>Both sources and consumers of data profit from this arrangement:</p>
<ul>
  <li>
    <p>If we develop a new data structure, we only need to implement <code>Iterable</code> and a raft of tools can immediately be applied to it.</p>
  </li>
  <li>
    <p>If we write code that uses iteration, it automatically works with many sources of data.</p>
  </li>
</ul>
<h3 id="iterable-iterator-iteratorresult"><a class="heading-id-link" href="#iterable-iterator-iteratorresult">32.2 Core iteration roles: iterables and iterators</a></h3>
<p><span id="index-entry-synchronous-iterable"/><span id="index-entry-iterable--synchronous-"/>
<span id="index-entry-synchronous-iterator"/><span id="index-entry-iterator--synchronous-"/></p>
<p>Two roles (described by interfaces) form the core of iteration (<a href="#fig:iteration-protocol">figure 32.2</a>):</p>
<ul>
  <li>
    An <em>iterable</em> is an object whose contents can be traversed sequentially.
  </li>
  <li>
    An <em>iterator</em> is the pointer used for the traversal.
  </li>
</ul>
<figure id="fig:iteration-protocol" class="float">
  <p><img src="../Images/18a5343baba7051a9127cee5ee460844.png" alt="" style="width:395.5358px; height:79.499985px" data-original-src="https://exploringjs.com/js/book/img/sync-iteration/iteration-protocol.svg"/></p>
  <figcaption>
    <p><span class="float-label">Figure 32.2:</span> Iteration has two main interfaces: <code>Iterable</code> and <code>Iterator</code>. The former has a method that returns the latter.</p>
  </figcaption>
</figure>
<p>These are type definitions (in TypeScript’s notation) for the interfaces of the iteration protocol:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt; {</code>
<code>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() : <span class="hljs-title class_">Iterator</span>&lt;T&gt;;</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt; {</code>
<code>  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">next</span>() : <span class="hljs-title class_">IteratorResult</span>&lt;T&gt;;</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IteratorResult</span>&lt;T&gt; {</code>
<code>  <span class="hljs-attr">value</span>: T;</code>
<code>  <span class="hljs-attr">done</span>: <span class="hljs-built_in">boolean</span>;</code>
<code>}</code>
</pre>
<p>The interfaces are used as follows:</p>
<ul>
  <li>
    We ask an <code>Iterable</code> for an iterator via the method whose key is <code>Symbol.iterator</code>.
  </li>
  <li>
    An iterator extends the abstract class <code>Iterator</code> and returns the iterated values via its method <code>.next()</code>.
    <ul>
      <li>
        Note: Before ECMAScript 2025, <code>Iterator</code> was simply an interface. No globally accessible class <code>Iterator</code> existed.
      </li>
    </ul>
  </li>
  <li>
    The values are not returned directly, but wrapped in objects with two properties:
    <ul>
      <li>
        <code>.value</code> is the iterated value.
      </li>
      <li>
        <code>.done</code> indicates if the end of the iteration has been reached yet. It is <code>true</code> after the last iterated value and <code>false</code> beforehand.
      </li>
    </ul>
  </li>
</ul>
<h3 id="iterating-over-data"><a class="heading-id-link" href="#iterating-over-data">32.3 Iterating over data</a></h3>
<h4 id="manually-iterating-over-data"><a class="heading-id-link" href="#manually-iterating-over-data">32.3.1 Manually iterating over data</a></h4>
<p>This is an example of using the iteration protocol:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> iterable = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];</code>
<code/>
<code><span class="hljs-comment">// The iterable is a factory for iterators:</span></code>
<code><span class="hljs-keyword">const</span> iterator = iterable[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();</code>
<code/>
<code><span class="hljs-comment">// Call .next() until .done is true:</span></code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  iterator.<span class="hljs-title function_">next</span>(), { <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> }</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  iterator.<span class="hljs-title function_">next</span>(), { <span class="hljs-attr">value</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> }</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  iterator.<span class="hljs-title function_">next</span>(), { <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }</code>
<code>);</code>
</pre>
<h4 id="using-while-to-iterate-manually"><a class="heading-id-link" href="#using-while-to-iterate-manually">32.3.2 Using <code>while</code> to iterate manually</a></h4>
<p>The following code demonstrates how to use a <code>while</code> loop to iterate over an iterable:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">logAll</span>(<span class="hljs-params">iterable</span>) {</code>
<code>  <span class="hljs-keyword">const</span> iterator = iterable[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();</code>
<code>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {</code>
<code>    <span class="hljs-keyword">const</span> {value, done} = iterator.<span class="hljs-title function_">next</span>();</code>
<code>    <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">break</span>;</code>
<code>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);</code>
<code>  }</code>
<code>}</code>
<code><span class="hljs-title function_">logAll</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]);</code>
</pre>
<p>Output:</p>
<pre>
<code>a</code>
<code>b</code>
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Using sync iteration manually</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/sync-iteration/sync_iteration_manually_exrc.mjs</code></p>
</div>
<h4 id="retrieving-an-iterator-via-iteratorfrom-es2024"><a class="heading-id-link" href="#retrieving-an-iterator-via-iteratorfrom-es2024">32.3.3 Retrieving an iterator via <code>Iterator.from()</code><span> <sup>ES2024</sup></span></a></h4>
<p>The built-in static method <code>Iterator.from()</code> provides us with a more elegant way of retrieving iterators:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> iterable = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];</span></code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">iterable[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Iterator</span></span></code>
<code>true</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Iterator</span>.<span class="hljs-title function_">from</span>(iterable) <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Iterator</span></span></code>
<code>true</code>
</pre>
<h4 id="iterating-via-iterationbased-language-constructs"><a class="heading-id-link" href="#iterating-via-iterationbased-language-constructs">32.3.4 Iterating via iteration-based language constructs</a></h4>
<p>We have seen how to use the iteration protocol manually and it is relatively cumbersome. But the protocol is not meant to be used directly – it is meant to be used via higher-level language constructs built on top of it. We’ll notice that we never see iterators when we do so. They are only used internally.</p>
<h5 id="iterating-over-arrays"><a class="heading-id-link" href="#iterating-over-arrays">32.3.4.1 Iterating over Arrays</a></h5>
<p>The most important iteration-based language construct is the <code>for-of</code> loop:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> iterable = [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'beautiful'</span>, <span class="hljs-string">'world'</span>];</code>
<code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> iterable) {</code>
<code>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);</code>
<code>}</code>
</pre>
<p>Output:</p>
<pre>
<code>hello</code>
<code>beautiful</code>
<code>world</code>
</pre>
<p>Another iteration-based construct is spreading into Array literals:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  [<span class="hljs-string">'BEFORE'</span>, ...iterable, <span class="hljs-string">'AFTER'</span>],</code>
<code>  [<span class="hljs-string">'BEFORE'</span>, <span class="hljs-string">'hello'</span>, <span class="hljs-string">'beautiful'</span>, <span class="hljs-string">'world'</span>, <span class="hljs-string">'AFTER'</span>]</code>
<code>);</code>
</pre>
<p><a href="ch_destructuring.html#ch_destructuring">Destructuring</a> via Array patterns also uses iteration under the hood:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> [first, second] = iterable;</code>
<code>assert.<span class="hljs-title function_">equal</span>(first, <span class="hljs-string">'hello'</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(second, <span class="hljs-string">'beautiful'</span>);</code>
</pre>
<h5 id="iterating-over-sets"><a class="heading-id-link" href="#iterating-over-sets">32.3.4.2 Iterating over Sets</a></h5>
<p>Sets are also iterable. Note that the iterating code is the same: It sees neither Arrays nor Sets, only iterables.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> iterable = [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'beautiful'</span>, <span class="hljs-string">'world'</span>];</code>
<code/>
<code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> iterable) {</code>
<code>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);</code>
<code>}</code>
<code/>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  [<span class="hljs-string">'BEFORE'</span>, ...iterable, <span class="hljs-string">'AFTER'</span>],</code>
<code>  [<span class="hljs-string">'BEFORE'</span>, <span class="hljs-string">'hello'</span>, <span class="hljs-string">'beautiful'</span>, <span class="hljs-string">'world'</span>, <span class="hljs-string">'AFTER'</span>]</code>
<code>);</code>
<code/>
<code><span class="hljs-keyword">const</span> [first, second] = iterable;</code>
<code>assert.<span class="hljs-title function_">equal</span>(first, <span class="hljs-string">'hello'</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(second, <span class="hljs-string">'beautiful'</span>);</code>
</pre>
<h4 id="converting-iterables-to-arrays-i-and-arrayfromi"><a class="heading-id-link" href="#converting-iterables-to-arrays-i-and-arrayfromi">32.3.5 Converting iterables to Arrays: <code>[...i]</code> and <code>Array.from(i)</code></a></h4>
<p>These are ways of converting iterables to Arrays:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> iterable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>().<span class="hljs-title function_">add</span>(<span class="hljs-string">'a'</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">'b'</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">'c'</span>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  [...iterable],</code>
<code>  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(iterable),</code>
<code>  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]</code>
<code>);</code>
</pre>
<p>I tend to prefer <code>Array.from()</code> because it’s more self-descriptive.</p>
<p>More information: <a href="ch_arrays.html#converting-to-array">“Converting iterables, iterators and Array-like values to Arrays” (§34.6)</a></p>
<p>We can also create an iterator and use an iterator method to create an Array. Iterator methods are explained later.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Iterator</span>.<span class="hljs-title function_">from</span>(iterable).<span class="hljs-title function_">toArray</span>(),</code>
<code>  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]</code>
<code>);</code>
</pre>
<h3 id="processing-iterables-via-generators"><a class="heading-id-link" href="#processing-iterables-via-generators">32.4 Processing iterables via generators</a></h3>
<p>Synchronous generator functions and methods expose their yielded values via iterators (that are also iterable) that they return:</p>
<pre class="language-js">
<code><span class="hljs-comment">/** Synchronous generator function */</span></code>
<code><span class="hljs-keyword">function</span>* <span class="hljs-title function_">createSyncIterable</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> <span class="hljs-string">'a'</span>;</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> <span class="hljs-string">'b'</span>;</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> <span class="hljs-string">'c'</span>;</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p>Generators produce iterables, but they can also consume them. That makes them a versatile tool for transforming iterables:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span>* <span class="hljs-title function_">map</span>(<span class="hljs-params">iterable, callback</span>) {</code>
<code>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> iterable) {</code>
<code>    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">callback</span>(x);</code>
<code>  }</code>
<code>}</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(</code>
<code>    <span class="hljs-title function_">map</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x ** <span class="hljs-number">2</span>)</code>
<code>  ),</code>
<code>  [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>]</code>
<code>);</code>
<code/>
<code><span class="hljs-keyword">function</span>* <span class="hljs-title function_">filter</span>(<span class="hljs-params">iterable, callback</span>) {</code>
<code>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> iterable) {</code>
<code>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">callback</span>(x)) {</code>
<code>      <span class="hljs-keyword">yield</span> x;</code>
<code>    }</code>
<code>  }</code>
<code>}</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(</code>
<code>    <span class="hljs-title function_">filter</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> (x % <span class="hljs-number">2</span>) === <span class="hljs-number">0</span></code>
<code>  )),</code>
<code>  [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>]</code>
<code>);</code>
</pre>
<p>More information: <a href="ch_sync-generators.html#ch_sync-generators">“Synchronous generators<span> <sup>ES6</sup> (advanced)</span>” (§33)</a></p>
<h3 id="the-inheritance-of-the-iteration-api-advanced"><a class="heading-id-link" href="#the-inheritance-of-the-iteration-api-advanced">32.5 The inheritance of the iteration API<span> (advanced)</span></a></h3>
<p>All of the iterators created by JavaScript’s standard library have a common prototype which the ECMAScript specification calls <a href="https://tc39.es/ecma262/#sec-%iteratorprototype%-object"><code>%IteratorPrototype%</code></a> and uses internally. We can access it from JavaScript via <code>Iterator.prototype</code>.</p>
<h4 id="array-iterators"><a class="heading-id-link" href="#array-iterators">32.5.1 Array iterators</a></h4>
<p>We create an Array iterator like this:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> arrayIterator = [][<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();</code>
</pre>
<p>This object has a prototype with two properties. Let’s call it <code>ArrayIteratorPrototype</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> <span class="hljs-title class_">ArrayIteratorPrototype</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(arrayIterator);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(<span class="hljs-title class_">ArrayIteratorPrototype</span>),</code>
<code>  [ <span class="hljs-string">'next'</span>, <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span> ]</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">ArrayIteratorPrototype</span>[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>],</code>
<code>  <span class="hljs-string">'Array Iterator'</span></code>
<code>);</code>
</pre>
<p>The prototype of <code>ArrayIteratorPrototype</code> is <code>%IteratorPrototype%</code>. This object has a method whose key is <code>Symbol.iterator</code>. Therefore, all built-in iterators are iterable.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> <span class="hljs-title class_">IteratorPrototype</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-title class_">ArrayIteratorPrototype</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">IteratorPrototype</span>, <span class="hljs-title class_">Iterator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></code>
<code>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(<span class="hljs-title class_">Iterator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>),</code>
<code>  <span class="hljs-literal">true</span></code>
<code>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Iterator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>],</code>
<code>  <span class="hljs-string">'function'</span></code>
<code>);</code>
</pre>
<p>The prototype of <code>Iterator.prototype</code> is <code>Object.prototype</code>.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-title class_">Iterator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,</code>
<code>  <span class="hljs-literal">true</span></code>
<code>);</code>
</pre>
<p><a href="#fig:inheritance-array-iterator">Figure 32.3</a> contains a diagram for this chain of prototypes.</p>
<figure id="fig:inheritance-array-iterator" class="float">
  <p><img src="../Images/7114dc60cff41ea48eb99d0bb278db66.png" alt="" style="width:169.09055px; height:265.24016px" data-original-src="https://exploringjs.com/js/book/img/sync-iteration/inheritance-array-iterator.svg"/></p>
  <figcaption>
    <p><span class="float-label">Figure 32.3:</span> A chain of prototypes (from bottom to top):</p>
    <ul>
      <li>
        First the result of <code>[][Symbol.iterator]()</code> (an instance of <code>%ArrayIterator%</code>)
      </li>
      <li>
        Then <code>%ArrayIteratorPrototype%</code>
      </li>
      <li>
        Then <code>%IteratorPrototype%</code>
      </li>
      <li>
        Finally <code>Object.prototype</code>
      </li>
    </ul>
  </figcaption>
</figure>
<h4 id="generator-objects"><a class="heading-id-link" href="#generator-objects">32.5.2 Generator objects</a></h4>
<p>Roughly, a generator object is an iterator for the values yielded by a generator function <code>genFunc()</code>. We create it by calling <code>genFunc()</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span>* <span class="hljs-title function_">genFunc</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> <span class="hljs-string">'a'</span>;</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> <span class="hljs-string">'b'</span>;</span></code>
<code><span class="hljs-params">}</span></code>
<code><span class="hljs-params"><span class="hljs-keyword">const</span> genObj = <span class="hljs-title function_">genFunc</span>();</span></code>
</pre>
<p>A generator object is an iterator:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  genObj.<span class="hljs-title function_">next</span>(),</code>
<code>  { <span class="hljs-attr">value</span>: <span class="hljs-string">'a'</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> }</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  genObj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Iterator</span>,</code>
<code>  <span class="hljs-literal">true</span></code>
<code>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">Iterator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(genObj),</code>
<code>  <span class="hljs-literal">true</span></code>
<code>);</code>
</pre>
<h3 id="iterable-iterators"><a class="heading-id-link" href="#iterable-iterators">32.6 Iterable iterators</a></h3>
<h4 id="why-are-the-builtin-iterators-iterable"><a class="heading-id-link" href="#why-are-the-builtin-iterators-iterable">32.6.1 Why are the built-in iterators iterable?</a></h4>
<p>As we have seen, all built-in iterators are iterable:</p>
<pre class="language-js">
<code><span class="hljs-comment">// Array iterator</span></code>
<code><span class="hljs-keyword">const</span> arrayIterator = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>].<span class="hljs-title function_">values</span>();</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-comment">// arrayIterator is a built-in iterator</span></code>
<code>  arrayIterator <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Iterator</span>, <span class="hljs-literal">true</span></code>
<code>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-comment">// arrayIterator is iterable</span></code>
<code>  <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span> <span class="hljs-keyword">in</span> arrayIterator, <span class="hljs-literal">true</span></code>
<code>);</code>
<code/>
<code><span class="hljs-comment">// Generator object</span></code>
<code><span class="hljs-keyword">function</span>* <span class="hljs-title function_">gen</span>(<span class="hljs-params">) { <span class="hljs-keyword">yield</span> <span class="hljs-string">'hello'</span> }</span></code>
<code><span class="hljs-params"><span class="hljs-keyword">const</span> genObj = <span class="hljs-title function_">gen</span>();</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span></code>
<code><span class="hljs-params">  genObj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Iterator</span>, <span class="hljs-literal">true</span></span></code>
<code><span class="hljs-params">);</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span> <span class="hljs-keyword">in</span> genObj, <span class="hljs-literal">true</span></span></code>
<code><span class="hljs-params">);</span></code>
<code/>
<code><span class="hljs-params"><span class="hljs-comment">// Iterator returned by `Iterator` method</span></span></code>
<code><span class="hljs-params"><span class="hljs-keyword">const</span> iter = <span class="hljs-title class_">Iterator</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">2</span>);</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span></code>
<code><span class="hljs-params">  iter <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Iterator</span>, <span class="hljs-literal">true</span></span></code>
<code><span class="hljs-params">);</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span> <span class="hljs-keyword">in</span> iter, <span class="hljs-literal">true</span></span></code>
<code><span class="hljs-params">);</span></code>
</pre>
<p>That has the benefit of us being able to iterate over the iterator’s values – e.g., via <code>for-of</code> and <code>Array.from()</code>.</p>
<p>Another benefit is that generators become more versatile. On one hand, we can use them to implement iterators:</p>
<pre class="language-js">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyIterable</span> {</code>
<code>  <span class="hljs-comment">/** This method must return an iterator */</span></code>
<code>  * [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() {</code>
<code>    <span class="hljs-keyword">yield</span> <span class="hljs-string">'good'</span>;</code>
<code>    <span class="hljs-keyword">yield</span> <span class="hljs-string">'morning'</span>;</code>
<code>  }</code>
<code>}</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyIterable</span>()),</code>
<code>  [<span class="hljs-string">'good'</span>, <span class="hljs-string">'morning'</span>]</code>
<code>);</code>
</pre>
<p>On the other hand, we can use them to implement iterables:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span>* <span class="hljs-title function_">createIterable</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> <span class="hljs-string">'a'</span>;</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> <span class="hljs-string">'b'</span>;</span></code>
<code><span class="hljs-params">}</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-title function_">createIterable</span>()),</span></code>
<code><span class="hljs-params">  [<span class="hljs-string">'good'</span>, <span class="hljs-string">'morning'</span>]</span></code>
<code><span class="hljs-params">);</span></code>
</pre>
<h4 id="an-iterator-returns-itself-when-asked-for-an-iterator"><a class="heading-id-link" href="#an-iterator-returns-itself-when-asked-for-an-iterator">32.6.2 An iterator returns itself when asked for an iterator</a></h4>
<p>If an iterator is iterable: What are the iterators it produces? It simply returns itself when asked for an iterator:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> iterator = <span class="hljs-title class_">Iterator</span>.<span class="hljs-title function_">from</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>])</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  iterator[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>](),</code>
<code>  iterator</code>
<code>);</code>
</pre>
<h4 id="one-time-iterable-vs-many-times-iterable"><a class="heading-id-link" href="#one-time-iterable-vs-many-times-iterable">32.6.3 Iteration quirk: two kinds of iterables</a></h4>
<p>Alas, iterable iterators mean that there are two kinds of iterables:</p>
<ol>
  <li>
    <p>An iterable iterator is a <em>one-time iterable</em>: It always returns the same iterator (itself) when <code>[Symbol.iterator]()</code> is called (iteration continues).</p>
  </li>
  <li>
    <p>A normal iterable (an Array, a Set, etc.) is a <em>many-times iterable</em>: It always returns a fresh iterator (iteration restarts).</p>
  </li>
</ol>
<p>With a one-time iterable, each time we iterate, we remove more elements, until, eventually, no more are left:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> oneTime = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">values</span>();</code>
<code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> oneTime) {</code>
<code>  assert.<span class="hljs-title function_">equal</span>(</code>
<code>    x, <span class="hljs-string">'a'</span></code>
<code>  );</code>
<code>  <span class="hljs-keyword">break</span>;</code>
<code>}</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(oneTime),</code>
<code>  [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(oneTime),</code>
<code>  []</code>
<code>);</code>
</pre>
<p>With a many-times iterable, each iteration starts fresh:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> manyTimes = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];</code>
<code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> manyTimes) {</code>
<code>  assert.<span class="hljs-title function_">equal</span>(</code>
<code>    x, <span class="hljs-string">'a'</span></code>
<code>  );</code>
<code>  <span class="hljs-keyword">break</span>;</code>
<code>}</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(manyTimes),</code>
<code>  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(manyTimes),</code>
<code>  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]</code>
<code>);</code>
</pre>
<p>The following code is another demonstration of the difference:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> oneTime = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">values</span>();</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  [...oneTime, ...oneTime, ...oneTime],</code>
<code>  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]</code>
<code>);</code>
<code/>
<code><span class="hljs-keyword">const</span> manyTimes = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  [...manyTimes, ...manyTimes, ...manyTimes],</code>
<code>  [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>]</code>
<code>);</code>
</pre>
<h3 id="class-iterator"><a class="heading-id-link" href="#class-iterator">32.7 Class <code>Iterator</code> and iterator helper methods<span> <sup>ES2025</sup></span></a></h3>
<p>We have already seen that <code>%IteratorPrototype%</code> is the prototype of all built-in iterators. ECMAScript 2025 introduces a class <code>Iterator</code>:</p>
<ul>
  <li>
    <code>Iterator.prototype</code> refers to <code>%IteratorPrototype%</code>.
  </li>
  <li>
    <code>%IteratorPrototype%.constructor</code> refers to <code>Iterator</code>.
  </li>
</ul>
<p>The class provides the following functionality:</p>
<ul>
  <li>
    <code>Iterator.from(iterable)</code> returns an iterator for <code>iterable</code>. We’ll explore it in detail <a href="#Iterator.from">later</a>.
  </li>
  <li>
    <code>Iterator.prototype</code> contains various helper methods that are inherited by iterators.
  </li>
</ul>
<h4 id="iteratorprototype-methods"><a class="heading-id-link" href="#iteratorprototype-methods">32.7.1 <code>Iterator.prototype.*</code> methods</a></h4>
<p>The following iterator helper methods work like the Array methods with the same names:</p>
<ul>
  <li>
    Methods that return iterators:
    <ul>
      <li>
        <code>iterator.filter(filterFn)</code>
      </li>
      <li>
        <code>iterator.map(mapFn)</code>
      </li>
      <li>
        <code>iterator.flatMap(mapFn)</code>
      </li>
    </ul>
  </li>
  <li>
    Methods that return booleans:
    <ul>
      <li>
        <code>iterator.some(fn)</code>
      </li>
      <li>
        <code>iterator.every(fn)</code>
      </li>
    </ul>
  </li>
  <li>
    Methods that return other values:
    <ul>
      <li>
        <code>iterator.find(fn)</code>
      </li>
      <li>
        <code>iterator.reduce(reducer, initialValue?)</code>
      </li>
    </ul>
  </li>
  <li>
    Methods that return no values:
    <ul>
      <li>
        <code>iterator.forEach(fn)</code>
      </li>
    </ul>
  </li>
</ul>
<p>These helper methods are unique to iterators:</p>
<ul>
  <li>
    <code>iterator.drop(limit)</code>
    <ul>
      <li>
        Returns an iterator without the first <code>limit</code> elements of <code>iterator</code>.
      </li>
    </ul>
  </li>
  <li>
    <code>iterator.take(limit)</code>
    <ul>
      <li>
        Returns an iterator with the first <code>limit</code> elements of <code>iterator</code>.
      </li>
    </ul>
  </li>
  <li>
    <code>iterator.toArray()</code>
    <ul>
      <li>
        Collects all remaining elements of <code>iterator</code> in an Array and returns it.
      </li>
    </ul>
  </li>
</ul>
<p>For a brief description of each method, see <a href="#quickref-iterator">“Quick reference: class <code>Iterator</code><span> <sup>ES2025</sup></span>” (§32.10)</a>. These are examples of the methods in action:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">values</span>().<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-string">`=<span class="hljs-subst">${x}</span>=`</span>).<span class="hljs-title function_">toArray</span>(),</code>
<code>  [<span class="hljs-string">'=a='</span>, <span class="hljs-string">'=b='</span>, <span class="hljs-string">'=c='</span>]</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">values</span>().<span class="hljs-title function_">drop</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">toArray</span>(),</code>
<code>  [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">values</span>().<span class="hljs-title function_">take</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">toArray</span>(),</code>
<code>  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]</code>
<code>);</code>
</pre>
<p>The Array method <code>arr.values()</code> returns an iterator over the elements of <code>arr</code>.</p>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercises: Working with iterators</strong></p>
  <div class="boxout-vspace"/>
  <ul>
    <li>
      Implementing <code>.at()</code> for iterators: <code>exercises/sync-iteration/iterator-at_test.mjs</code>
    </li>
    <li>
      Implementing <code>.findIndex()</code> for iterators: <code>exercises/sync-iteration/iterator-find-index_test.mjs</code>
    </li>
    <li>
      Implementing <code>.slice()</code> for iterators: <code>exercises/sync-iteration/slice-iterator_test.mjs</code>
    </li>
    <li>
      Adding indices to iterator elements: <code>exercises/sync-iteration/add-index-to-iterator_test.mjs</code>
    </li>
    <li>
      Using <code>iterator.reduce()</code> to compute the length of an iterator: <code>exercises/sync-iteration/iterator-length_test.mjs</code>
    </li>
  </ul>
</div>
<h4 id="benefits-of-iterator-helper-methods"><a class="heading-id-link" href="#benefits-of-iterator-helper-methods">32.7.2 The benefits of iterator helper methods</a></h4>
<h5 id="benefit-more-operations-for-data-structures-that-support-iteration"><a class="heading-id-link" href="#benefit-more-operations-for-data-structures-that-support-iteration">32.7.2.1 Benefit: more operations for data structures that support iteration</a></h5>
<p>With iterator helper methods, any data structure that supports iteration automatically gains functionality.</p>
<p>For example, Sets don’t support the operations <code>filter</code> and <code>map</code>, but we can get them via iterator methods:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>( <span class="hljs-comment">// (A)</span></code>
<code>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([-<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, -<span class="hljs-number">3</span>]).<span class="hljs-title function_">values</span>().<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt;= <span class="hljs-number">0</span>)</code>
<code>  ),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">2</span>, <span class="hljs-number">6</span>])</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>( <span class="hljs-comment">// (B)</span></code>
<code>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([-<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, -<span class="hljs-number">3</span>]).<span class="hljs-title function_">values</span>().<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x / <span class="hljs-number">2</span>)</code>
<code>  ),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([-<span class="hljs-number">2.5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">1.5</span>])</code>
<code>);</code>
</pre>
<p>Note that <code>new Set()</code> accepts iterables and therefore iterable iterators (line A and line B).</p>
<p>DOM collections also don’t have the methods <code>.filter()</code> and <code>.map()</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> domCollection = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">'a'</span>);</code>
<code/>
<code><span class="hljs-comment">// Alas, the collection doesn’t have a method .map()</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-string">'map'</span> <span class="hljs-keyword">in</span> domCollection, <span class="hljs-literal">false</span>);</code>
<code/>
<code><span class="hljs-comment">// Solution: use an iterator</span></code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  domCollection.<span class="hljs-title function_">values</span>().<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.<span class="hljs-property">href</span>).<span class="hljs-title function_">toArray</span>(),</code>
<code>  [<span class="hljs-string">'https://2ality.com'</span>, <span class="hljs-string">'https://exploringjs.com'</span>]</code>
<code>);</code>
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Implementing <code>.filter()</code> and <code>.map()</code> for Sets via iterator methods</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/sync-iteration/set-operations-via-iterators_test.mjs</code></p>
</div>
<h5 id="benefit-no-intermediate-arrays-and-incremental-processing"><a class="heading-id-link" href="#benefit-no-intermediate-arrays-and-incremental-processing">32.7.2.2 Benefit: no intermediate Arrays and incremental processing</a></h5>
<p>If we chain operations that return Arrays (line A, line B, line C) then each operation produces a new Array:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">quoteNonEmptyLinesArray</span>(<span class="hljs-params">str</span>) {</code>
<code>  <span class="hljs-keyword">return</span> str</code>
<code>    .<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/(?&lt;=\r?\n)/</span>) <span class="hljs-comment">// (A)</span></code>
<code>    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">line</span> =&gt;</span> line.<span class="hljs-title function_">trim</span>().<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// (B)</span></code>
<code>    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">line</span> =&gt;</span> <span class="hljs-string">'&gt; '</span> + line) <span class="hljs-comment">// (C)</span></code>
<code>    ;</code>
<code>}</code>
</pre>
<p>The regular expression in line A contains <a href="ch_regexps.html#regexp-lookbehind-assertions">a lookbehind assertion</a> which ensures that the lines returned by <code>.split()</code> includes line terminators.</p>
<p>In contrast, each operation (line A, line B, line C) in the following code returns an iterator and no intermediate Arrays are created:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">quoteNonEmptyLinesIter</span>(<span class="hljs-params">str</span>) {</code>
<code>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">splitLinesIter</span>(str) <span class="hljs-comment">// (A)</span></code>
<code>    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">line</span> =&gt;</span> line.<span class="hljs-title function_">trim</span>().<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// (B)</span></code>
<code>    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">line</span> =&gt;</span> <span class="hljs-string">'&gt; '</span> + line) <span class="hljs-comment">// (C)</span></code>
<code>    ;</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">function</span>* <span class="hljs-title function_">splitLinesIter</span>(<span class="hljs-params">str</span>) {</code>
<code>  <span class="hljs-keyword">let</span> prevIndex = <span class="hljs-number">0</span>;</code>
<code>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {</code>
<code>    <span class="hljs-keyword">const</span> eolIndex = str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'\n'</span>, prevIndex);</code>
<code>    <span class="hljs-keyword">if</span> (eolIndex &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;</code>
<code>    <span class="hljs-comment">// Including EOL</span></code>
<code>    <span class="hljs-keyword">const</span> line = str.<span class="hljs-title function_">slice</span>(prevIndex, eolIndex + <span class="hljs-number">1</span>);</code>
<code>    <span class="hljs-keyword">yield</span> line;</code>
<code>    prevIndex = eolIndex + <span class="hljs-number">1</span>;</code>
<code>  }</code>
<code>  <span class="hljs-keyword">if</span> (prevIndex &lt; str.<span class="hljs-property">length</span>) {</code>
<code>    <span class="hljs-keyword">yield</span> str.<span class="hljs-title function_">slice</span>(prevIndex);</code>
<code>  }</code>
<code>}</code>
</pre>
<p>Example of using <code>quoteNonEmptyLinesIter()</code>:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-title function_">quoteNonEmptyLinesIter</span>(<span class="hljs-string">'have\n\na nice\n\nday'</span>)),</code>
<code>  [</code>
<code>    <span class="hljs-string">'&gt; have\n'</span>,</code>
<code>    <span class="hljs-string">'&gt; a nice\n'</span>,</code>
<code>    <span class="hljs-string">'&gt; day'</span>,</code>
<code>  ]</code>
<code>);</code>
</pre>
<p>Note that the empty lines between the three lines of text were filtered out.</p>
<p>In addition to no intermediate Arrays being created, iterators also give us incremental processing:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> iter = <span class="hljs-title function_">quoteNonEmptyLinesIter</span>(<span class="hljs-string">'have\n\na nice\n\nday'</span>);</span></code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">iter.<span class="hljs-title function_">next</span>()</span></code>
<code>{ value: '&gt; have\n', done: false }</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">iter.<span class="hljs-title function_">next</span>()</span></code>
<code>{ value: '&gt; a nice\n', done: false }</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">iter.<span class="hljs-title function_">next</span>()</span></code>
<code>{ value: '&gt; day', done: false }</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">iter.<span class="hljs-title function_">next</span>()</span></code>
<code>{ value: undefined, done: true }</code>
</pre>
<p>In contrast, <code>quoteNonEmptyLinesArray()</code> first splits all lines, then filters all lines and then maps all lines. Incremental processing matters when dealing with a large amount of data. Iterator helper methods complement generators as tools for incremental processing.</p>
<h4 id="Iterator.from"><a class="heading-id-link" href="#Iterator.from">32.7.3 <code>Iterator.from()</code>: creating API iterators</a></h4>
<p>All built-in iterables automatically support the new API because their iterators already have <code>Iterator.prototype</code> as a prototype (and are therefore instances of <code>Iterator</code>). However, that’s not the case for all iterables in libraries and user code.</p>
<p>Terminology:</p>
<ul>
  <li>
    Entities that support the <code>Iterator</code> API: <em>API iterators</em> and <em>API iterables</em>
  </li>
  <li>
    Entities that don’t: <em>legacy iterators</em> and <em>legacy iterables</em>
  </li>
</ul>
<p>How does <code>Iterator.from(obj)</code> work?</p>
<ul>
  <li>
    If <code>obj</code> is iterable, then it creates an iterator by calling <code>obj[Symbol.iterator]()</code>.
    <ul>
      <li>
        If the new iterator is an instance of <code>Iterator</code>, it is returned as is.
      </li>
      <li>
        Otherwise, it is wrapped so that it becomes an instance of <code>Iterator</code>.
      </li>
    </ul>
  </li>
  <li>
    If <code>obj</code> is an iterator, <code>Iterator.from()</code> ensures that it is an instance of <code>Iterator</code> and returns it.
  </li>
</ul>
<p>In the following example, we use <code>Iterator.from()</code> to convert a legacy iterator to an API iterator:</p>
<pre class="language-js">
<code><span class="hljs-comment">// Not an instance of `Iterator`</span></code>
<code><span class="hljs-keyword">const</span> legacyIterator = {</code>
<code>  <span class="hljs-title function_">next</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">    <span class="hljs-comment">// Infinite iterator (never done)</span></span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'#'</span> };</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">};</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-title class_">Iterator</span>.<span class="hljs-title function_">from</span>(legacyIterator) <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Iterator</span>,</span></code>
<code><span class="hljs-params">  <span class="hljs-literal">true</span></span></code>
<code><span class="hljs-params">);</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-title class_">Iterator</span>.<span class="hljs-title function_">from</span>(legacyIterator).<span class="hljs-title function_">take</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">toArray</span>(),</span></code>
<code><span class="hljs-params">  [<span class="hljs-string">'#'</span>, <span class="hljs-string">'#'</span>, <span class="hljs-string">'#'</span>]</span></code>
<code><span class="hljs-params">);</span></code>
</pre>
<h4 id="iterator-methods-change-how-we-use-iteration"><a class="heading-id-link" href="#iterator-methods-change-how-we-use-iteration">32.7.4 Iterator methods change how we use iteration</a></h4>
<p>The iterator methods change how we use iteration:</p>
<ul>
  <li>
    Previously, we never saw iterators and always worked with iterables, e.g. via <code>for-of</code> or <code>Array.from()</code>.
  </li>
  <li>
    Now, using iterators is useful, too, and we have to be aware of how to create them.
  </li>
</ul>
<p>It’s interesting how our focus shifts with methods such as <code>Array.prototype.keys()</code> that return iterable iterators: Before iterator methods, we used the result as an iterable. With iterator methods, we also use them as iterators:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>].<span class="hljs-title function_">keys</span>()) <span class="hljs-comment">// iterable</span></span></code>
<code>[ 0, 1 ]</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>].<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">toArray</span>() <span class="hljs-comment">// iterator</span></span></code>
<code>[ 0, 1 ]</code>
</pre>
<p>For more information, see <a href="#creating-iterators">“Creating iterators” (§32.10.1)</a>.</p>
<h4 id="upgrading-a-legacy-iterable-to-the-iterator-api"><a class="heading-id-link" href="#upgrading-a-legacy-iterable-to-the-iterator-api">32.7.5 Upgrading a legacy iterable to the <code>Iterator</code> API</a></h4>
<p>This is an example of a legacy iterable:</p>
<pre class="language-js">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">ValueIterable</span> {</code>
<code>  #values;</code>
<code>  #index = <span class="hljs-number">0</span>;</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">...values</span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.#values = values;</code>
<code>  }</code>
<code>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() {</code>
<code>    <span class="hljs-keyword">return</span> {</code>
<code>      <span class="hljs-comment">// Arrow function so that we can use the outer `this`</span></code>
<code>      <span class="hljs-attr">next</span>: <span class="hljs-function">() =&gt;</span> {</code>
<code>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.#index &gt;= <span class="hljs-variable language_">this</span>.#values.<span class="hljs-property">length</span>) {</code>
<code>          <span class="hljs-keyword">return</span> {<span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>};</code>
<code>        }</code>
<code>        <span class="hljs-keyword">const</span> value = <span class="hljs-variable language_">this</span>.#values[<span class="hljs-variable language_">this</span>.#index];</code>
<code>        <span class="hljs-variable language_">this</span>.#index++;</code>
<code>        <span class="hljs-keyword">return</span> {<span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, value};</code>
<code>      },</code>
<code>    };</code>
<code>  }</code>
<code>}</code>
<code/>
<code><span class="hljs-comment">// legacyIterable is an iterable</span></code>
<code><span class="hljs-keyword">const</span> legacyIterable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueIterable</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueIterable</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>)),</code>
<code>  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]</code>
<code>);</code>
<code/>
<code><span class="hljs-comment">// But its iterators are not instances of Iterator</span></code>
<code><span class="hljs-keyword">const</span> legacyIterator = legacyIterable[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  legacyIterator <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Iterator</span>, <span class="hljs-literal">false</span></code>
<code>);</code>
</pre>
<p>If we want <code>ValueIterable</code> to support the <code>Iterator</code> API, we have to make its iterators instances of <code>Iterator</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">ValueIterable</span> {</code>
<code>  <span class="hljs-comment">// ···</span></code>
<code>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() {</code>
<code>    <span class="hljs-keyword">return</span> {</code>
<code>      <span class="hljs-attr">__proto__</span>: <span class="hljs-title class_">Iterator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,</code>
<code>      <span class="hljs-attr">next</span>: <span class="hljs-function">() =&gt;</span> {</code>
<code>        <span class="hljs-comment">// ···</span></code>
<code>      },</code>
<code>    };</code>
<code>  }</code>
<code>}</code>
</pre>
<p>This is another option (albeit a less efficient one):</p>
<pre class="language-js">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">ValueIterable</span> {</code>
<code>  <span class="hljs-comment">// ···</span></code>
<code>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() {</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Iterator</span>.<span class="hljs-title function_">from</span>({</code>
<code>      <span class="hljs-attr">next</span>: <span class="hljs-function">() =&gt;</span> {</code>
<code>        <span class="hljs-comment">// ···</span></code>
<code>      },</code>
<code>    });</code>
<code>  }</code>
<code>}</code>
</pre>
<p>We can also create a class for iterators:</p>
<pre class="language-js">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">ValueIterable</span> {</code>
<code>  #values;</code>
<code>  #index = <span class="hljs-number">0</span>;</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">...values</span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.#values = values;</code>
<code>  }</code>
<code>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() {</code>
<code>    <span class="hljs-keyword">const</span> outerThis = <span class="hljs-variable language_">this</span>;</code>
<code>    <span class="hljs-comment">// Because ValueIterator is nested, it can access the private fields of</span></code>
<code>    <span class="hljs-comment">// ValueIterable</span></code>
<code>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValueIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Iterator</span> {</code>
<code>      <span class="hljs-title function_">next</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">        <span class="hljs-keyword">if</span> (outerThis.#index &gt;= outerThis.#values.<span class="hljs-property">length</span>) {</span></code>
<code><span class="hljs-params">          <span class="hljs-keyword">return</span> {<span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>};</span></code>
<code><span class="hljs-params">        }</span></code>
<code><span class="hljs-params">        <span class="hljs-keyword">const</span> value = outerThis.#values[outerThis.#index];</span></code>
<code><span class="hljs-params">        outerThis.#index++;</span></code>
<code><span class="hljs-params">        <span class="hljs-keyword">return</span> {<span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, value};</span></code>
<code><span class="hljs-params">      }</span></code>
<code><span class="hljs-params">    }</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueIterator</span>();</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<h3 id="grouping-sync-iterables"><a class="heading-id-link" href="#grouping-sync-iterables">32.8 Grouping iterables<span> <sup>ES2024</sup></span></a></h3>
<p><code>Map.groupBy()</code> groups the items of an iterable into Map entries whose keys are provided by a callback:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Map</span>.<span class="hljs-title function_">groupBy</span>([<span class="hljs-number">0</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sign</span>(x)),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>().<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, [<span class="hljs-number">0</span>]).<span class="hljs-title function_">set</span>(-<span class="hljs-number">1</span>, [-<span class="hljs-number">5</span>,-<span class="hljs-number">4</span>]).<span class="hljs-title function_">set</span>(<span class="hljs-number">1</span>, [<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>])</code>
<code>);</code>
</pre>
<p>The items to be grouped can come from any iterable:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generateNumbers</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> -<span class="hljs-number">7</span>;</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span>;</span></code>
<code><span class="hljs-params">}</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-title class_">Map</span>.<span class="hljs-title function_">groupBy</span>(<span class="hljs-title function_">generateNumbers</span>(), <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sign</span>(x)),</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>().<span class="hljs-title function_">set</span>(<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]).<span class="hljs-title function_">set</span>(-<span class="hljs-number">1</span>, [-<span class="hljs-number">7</span>])</span></code>
<code><span class="hljs-params">);</span></code>
</pre>
<p>There is also <code>Object.groupBy()</code> which produces an object instead of a Map:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">groupBy</span>([<span class="hljs-number">0</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sign</span>(x)),</code>
<code>  {<span class="hljs-string">'0'</span>: [<span class="hljs-number">0</span>], <span class="hljs-string">'-1'</span>: [-<span class="hljs-number">5</span>,-<span class="hljs-number">4</span>], <span class="hljs-string">'1'</span>: [<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>], <span class="hljs-attr">__proto__</span>: <span class="hljs-literal">null</span>}</code>
<code>);</code>
</pre>
<h4 id="choosing-between-mapgroupby-and-objectgroupby"><a class="heading-id-link" href="#choosing-between-mapgroupby-and-objectgroupby">32.8.1 Choosing between <code>Map.groupBy()</code> and <code>Object.groupBy()</code></a></h4>
<ul>
  <li>
    Do you want group keys other than strings and symbols?
    <ul>
      <li>
        Then you need a Map. Objects can only have strings and symbols as keys.
      </li>
    </ul>
  </li>
  <li>
    Do you want to destructure the result of <code>.groupBy()</code> (see example later in this section)?
    <ul>
      <li>
        Then you need an object.
      </li>
    </ul>
  </li>
  <li>
    Otherwise, you are free to choose what you prefer.
  </li>
</ul>
<h4 id="example-handling-cases"><a class="heading-id-link" href="#example-handling-cases">32.8.2 Example: handling cases</a></h4>
<p>The Promise combinator <a href="ch_promises.html#Promise.allSettled"><code>Promise.allSettled()</code></a> returns Arrays such as the following one:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> settled = [</code>
<code>  { <span class="hljs-attr">status</span>: <span class="hljs-string">'rejected'</span>, <span class="hljs-attr">reason</span>: <span class="hljs-string">'Jhon'</span> },</code>
<code>  { <span class="hljs-attr">status</span>: <span class="hljs-string">'fulfilled'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'Jane'</span> },</code>
<code>  { <span class="hljs-attr">status</span>: <span class="hljs-string">'fulfilled'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'John'</span> },</code>
<code>  { <span class="hljs-attr">status</span>: <span class="hljs-string">'rejected'</span>, <span class="hljs-attr">reason</span>: <span class="hljs-string">'Jaen'</span> },</code>
<code>  { <span class="hljs-attr">status</span>: <span class="hljs-string">'rejected'</span>, <span class="hljs-attr">reason</span>: <span class="hljs-string">'Jnoh'</span> },</code>
<code>];</code>
</pre>
<p>We can group the Array elements as follows:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> {fulfilled, rejected} = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">groupBy</span>(settled, <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.<span class="hljs-property">status</span>); <span class="hljs-comment">// (A)</span></code>
<code/>
<code><span class="hljs-comment">// Handle fulfilled results</span></code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  fulfilled,</code>
<code>  [</code>
<code>    { <span class="hljs-attr">status</span>: <span class="hljs-string">'fulfilled'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'Jane'</span> },</code>
<code>    { <span class="hljs-attr">status</span>: <span class="hljs-string">'fulfilled'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'John'</span> },</code>
<code>  ]</code>
<code>);</code>
<code/>
<code><span class="hljs-comment">// Handle rejected results</span></code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  rejected,</code>
<code>  [</code>
<code>    { <span class="hljs-attr">status</span>: <span class="hljs-string">'rejected'</span>, <span class="hljs-attr">reason</span>: <span class="hljs-string">'Jhon'</span> },</code>
<code>    { <span class="hljs-attr">status</span>: <span class="hljs-string">'rejected'</span>, <span class="hljs-attr">reason</span>: <span class="hljs-string">'Jaen'</span> },</code>
<code>    { <span class="hljs-attr">status</span>: <span class="hljs-string">'rejected'</span>, <span class="hljs-attr">reason</span>: <span class="hljs-string">'Jnoh'</span> },</code>
<code>  ]</code>
<code>);</code>
</pre>
<p>For this use case, <code>Object.groupBy()</code> works better because we can use destructuring (line A).</p>
<h4 id="example-grouping-by-property-value"><a class="heading-id-link" href="#example-grouping-by-property-value">32.8.3 Example: grouping by property value</a></h4>
<p>In the next example, we’d like to group persons by country:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> persons = [</code>
<code>  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Louise'</span>, <span class="hljs-attr">country</span>: <span class="hljs-string">'France'</span> },</code>
<code>  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Felix'</span>, <span class="hljs-attr">country</span>: <span class="hljs-string">'Germany'</span> },</code>
<code>  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Ava'</span>, <span class="hljs-attr">country</span>: <span class="hljs-string">'USA'</span> },</code>
<code>  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Léo'</span>, <span class="hljs-attr">country</span>: <span class="hljs-string">'France'</span> },</code>
<code>  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Oliver'</span>, <span class="hljs-attr">country</span>: <span class="hljs-string">'USA'</span> },</code>
<code>  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Leni'</span>, <span class="hljs-attr">country</span>: <span class="hljs-string">'Germany'</span> },</code>
<code>];</code>
<code/>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Map</span>.<span class="hljs-title function_">groupBy</span>(persons, <span class="hljs-function">(<span class="hljs-params">person</span>) =&gt;</span> person.<span class="hljs-property">country</span>),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([</code>
<code>    [</code>
<code>      <span class="hljs-string">'France'</span>,</code>
<code>      [</code>
<code>        { <span class="hljs-attr">name</span>: <span class="hljs-string">'Louise'</span>, <span class="hljs-attr">country</span>: <span class="hljs-string">'France'</span> },</code>
<code>        { <span class="hljs-attr">name</span>: <span class="hljs-string">'Léo'</span>, <span class="hljs-attr">country</span>: <span class="hljs-string">'France'</span> },</code>
<code>      ]</code>
<code>    ],</code>
<code>    [</code>
<code>      <span class="hljs-string">'Germany'</span>,</code>
<code>      [</code>
<code>        { <span class="hljs-attr">name</span>: <span class="hljs-string">'Felix'</span>, <span class="hljs-attr">country</span>: <span class="hljs-string">'Germany'</span> },</code>
<code>        { <span class="hljs-attr">name</span>: <span class="hljs-string">'Leni'</span>, <span class="hljs-attr">country</span>: <span class="hljs-string">'Germany'</span> },</code>
<code>      ]</code>
<code>    ],</code>
<code>    [</code>
<code>      <span class="hljs-string">'USA'</span>,</code>
<code>      [</code>
<code>        { <span class="hljs-attr">name</span>: <span class="hljs-string">'Ava'</span>, <span class="hljs-attr">country</span>: <span class="hljs-string">'USA'</span> },</code>
<code>        { <span class="hljs-attr">name</span>: <span class="hljs-string">'Oliver'</span>, <span class="hljs-attr">country</span>: <span class="hljs-string">'USA'</span> },</code>
<code>      ]</code>
<code>    ],</code>
<code>  ])</code>
<code>);</code>
</pre>
<p>For this use case, <code>Map.groupBy()</code> is a better choice because we can use arbitrary keys in Maps whereas in objects, keys are limited to strings and symbols.</p>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Using <code>Map.groupBy()</code> for an Array of objects</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/sync-iteration/count-cities_test.mjs</code></p>
</div>
<h3 id="quickref-sync-iteration"><a class="heading-id-link" href="#quickref-sync-iteration">32.9 Quick reference: synchronous iteration</a></h3>
<h4 id="synchronous-iteration-data-producers"><a class="heading-id-link" href="#synchronous-iteration-data-producers">32.9.1 Synchronous iteration: data producers</a></h4>
<p>These data structures are iterable:</p>
<ul>
  <li>
    Strings
  </li>
  <li>
    Arrays
  </li>
  <li>
    Sets
  </li>
  <li>
    Maps
  </li>
  <li>
    (Browsers: DOM data structures)
  </li>
</ul>
<p>The following data structures have the methods <code>.keys()</code>, <code>.values()</code>, and <code>.entries()</code> that return iterables that are not Arrays:</p>
<ul>
  <li>
    Arrays
  </li>
  <li>
    Sets
  </li>
  <li>
    Maps
  </li>
</ul>
<p>As an aside – the following static methods list property keys, values and entries (they are not normal methods because those can be accidentally overridden). They return Arrays.</p>
<ul>
  <li>
    <code>Object.keys(obj)</code>
  </li>
  <li>
    <code>Object.values(obj)</code>
  </li>
  <li>
    <code>Object.entries(obj)</code>
  </li>
</ul>
<p>Synchronous generator functions and methods expose their yielded values via iterable objects that they return:</p>
<pre class="language-js">
<code><span class="hljs-comment">/** Synchronous generator function */</span></code>
<code><span class="hljs-keyword">function</span>* <span class="hljs-title function_">createSyncIterable</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> <span class="hljs-string">'a'</span>;</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> <span class="hljs-string">'b'</span>;</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span> <span class="hljs-string">'c'</span>;</span></code>
<code><span class="hljs-params">}</span></code>
<code/>
<code><span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-title function_">createSyncIterable</span>()),</span></code>
<code><span class="hljs-params">  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]</span></code>
<code><span class="hljs-params">);</span></code>
</pre>
<h4 id="synchronous-iteration-data-consumers"><a class="heading-id-link" href="#synchronous-iteration-data-consumers">32.9.2 Synchronous iteration: data consumers</a></h4>
<p>This section lists constructs that consume data via synchronous iteration.</p>
<h5 id="language-constructs-that-iterate"><a class="heading-id-link" href="#language-constructs-that-iterate">32.9.2.1 Language constructs that iterate</a></h5>
<ul>
  <li>
    <p>The <code>for-of</code> loop:</p>
<pre class="language-js">
<code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> iterable) { <span class="hljs-comment">/*···*/</span> }</code>
</pre>
  </li>
  <li>
    <p>Spreading (via <code>...</code>) into Array literals and function calls:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, ...iterable, <span class="hljs-string">'z'</span>];</code>
<code><span class="hljs-title function_">func</span>(<span class="hljs-string">'a'</span>, ...iterable, <span class="hljs-string">'z'</span>);</code>
</pre>
  </li>
  <li>
    <p>Destructuring via an Array pattern:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> [x, y] = iterable;</code>
</pre>
  </li>
  <li>
    <p><code>yield*</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFunction</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">yield</span>* iterable;</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
  </li>
</ul>
<h5 id="converting-iterables-to-data-structures"><a class="heading-id-link" href="#converting-iterables-to-data-structures">32.9.2.2 Converting iterables to data structures</a></h5>
<ul>
  <li>
    <p><a href="ch_objects.html#Object.fromEntries"><code>Object.fromEntries()</code></a>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(iterableOverKeyValuePairs);</code>
</pre>
  </li>
  <li>
    <p><a href="ch_arrays.html#Array.from"><code>Array.from()</code></a>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> arr = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(iterable);</code>
</pre>
    <p>Alternative – <a href="ch_arrays.html#spreading-into-array-literals">spreading</a>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> arr = [...iterable];</code>
</pre>
  </li>
  <li>
    <p><a href="ch_maps.html#ch_maps"><code>new Map()</code></a> and <a href="ch_weakmaps.html#ch_weakmaps"><code>new WeakMap()</code></a>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> m  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(iterableOverKeyValuePairs);</code>
<code><span class="hljs-keyword">const</span> wm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>(iterableOverKeyValuePairs);</code>
</pre>
  </li>
  <li>
    <p><a href="ch_sets.html#ch_sets"><code>new Set()</code></a> and <a href="ch_weaksets.html#ch_weaksets"><code>new WeakSet()</code></a>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> s  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(iterableOverElements);</code>
<code><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>(iterableOverElements);</code>
</pre>
  </li>
</ul>
<h5 id="converting-iterables-over-promises-to-promises"><a class="heading-id-link" href="#converting-iterables-over-promises-to-promises">32.9.2.3 Converting iterables over Promises to Promises</a></h5>
<ul>
  <li>
    <p><a href="ch_promises.html#promise-combinators">Promise combinator functions</a>: <code>Promise.all()</code> etc.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> promise1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(iterableOverPromises);</code>
<code><span class="hljs-keyword">const</span> promise2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>(iterableOverPromises);</code>
<code><span class="hljs-keyword">const</span> promise3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>(iterableOverPromises);</code>
<code><span class="hljs-keyword">const</span> promise4 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(iterableOverPromises);</code>
</pre>
  </li>
</ul>
<h5 id="grouping-an-iterable-into-a-map-or-an-object"><a class="heading-id-link" href="#grouping-an-iterable-into-a-map-or-an-object">32.9.2.4 Grouping an iterable into a Map or an object</a></h5>
<ul>
  <li>
    <a href="ch_maps.html#qref-Map.groupBy">“<code>Map.groupBy(items, computeGroupKey)</code>”</a>
  </li>
  <li>
    <a href="ch_objects.html#qref-Object.groupBy">“<code>Object.groupBy(items, computeGroupKey)</code>”</a>
  </li>
</ul>
<h3 id="quickref-iterator"><a class="heading-id-link" href="#quickref-iterator">32.10 Quick reference: class <code>Iterator</code><span> <sup>ES2025</sup></span></a></h3>
<h4 id="creating-iterators"><a class="heading-id-link" href="#creating-iterators">32.10.1 Creating iterators</a></h4>
<p>The methods of class <code>Iterator</code> let us process data incrementally. Let’s explore where we can use them.</p>
<h5 id="getting-iterators-from-iterables"><a class="heading-id-link" href="#getting-iterators-from-iterables">32.10.1.1 Getting iterators from iterables</a></h5>
<ul>
  <li>
    <code>Iterator.from(iterable)</code> always returns instances of <code>Iterator</code> (converting non-instances to instances as needed).
  </li>
  <li>
    <code>iterable[Symbol.iterator]()</code> returns an iterator:
    <ul>
      <li>
        With all built-in data structures, the result is an instance of <code>Iterator</code>.
      </li>
      <li>
        With other, older iterable objects, the result may not be an instance of <code>Iterator</code>.
      </li>
    </ul>
  </li>
</ul>
<h5 id="builtin-methods-that-return-iterators"><a class="heading-id-link" href="#builtin-methods-that-return-iterators">32.10.1.2 Built-in methods that return iterators</a></h5>
<p>Arrays, Typed Arrays, Sets and Maps have additional methods that return iterators:</p>
<ul>
  <li>
    Arrays (similarly: Typed Arrays):
    <ul>
      <li>
        <code>Array.prototype.keys()</code> returns an iterator over numbers.
      </li>
      <li>
        <code>Array.prototype.values()</code> returns an iterator.
      </li>
      <li>
        <code>Array.prototype.entries()</code> returns an iterator over key-value pairs. The keys are numbers.
      </li>
    </ul>
  </li>
  <li>
    Sets:
    <ul>
      <li>
        <code>Set.prototype.values()</code> returns an iterator.
      </li>
      <li>
        <code>Set.prototype.keys()</code> returns an iterator. Equivalent to <code>.values()</code>.
      </li>
      <li>
        <code>Set.prototype.entries()</code> returns an iterator over value-value pairs (i.e., both components of the pair are the same value).
      </li>
    </ul>
  </li>
  <li>
    Maps:
    <ul>
      <li>
        <code>Map.prototype.keys()</code> returns an iterator.
      </li>
      <li>
        <code>Map.prototype.values()</code> returns an iterator.
      </li>
      <li>
        <code>Map.prototype.entries()</code> returns an iterator over key-value pairs.
      </li>
    </ul>
  </li>
</ul>
<p>The following methods return iterators:</p>
<ul>
  <li>
    <code>String.prototype.matchAll()</code> returns an iterator over match objects.
  </li>
</ul>
<h5 id="other-sources-of-iterators"><a class="heading-id-link" href="#other-sources-of-iterators">32.10.1.3 Other sources of iterators</a></h5>
<p>Generators also return iterators:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span>* <span class="hljs-title function_">gen</span>(<span class="hljs-params">) {}</span></code>
<code/>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-title function_">gen</span>() <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Iterator</span>,</span></code>
<code><span class="hljs-params">  <span class="hljs-literal">true</span></span></code>
<code><span class="hljs-params">);</span></code>
</pre>
<h4 id="iterator"><a class="heading-id-link" href="#iterator">32.10.2 <code>Iterator.*</code></a></h4>
<ul>
  <li>
    <code>Iterator.from(iterableOrIterator)</code> returns an iterator that is guaranteed to be an instance of <code>Iterator</code>. If the parameter is a legacy iterable or a legacy iterator, it wraps the result so that it becomes an instance of <code>Iterator</code>.
  </li>
</ul>
<h4 id="iteratorprototype-methods-that-pass-indices-to-callbacks"><a class="heading-id-link" href="#iteratorprototype-methods-that-pass-indices-to-callbacks">32.10.3 <code>Iterator.prototype.*</code>: methods that pass indices to callbacks</a></h4>
<p>Some of the iterator methods keep a counter for the iterated values and pass it on to their callbacks:</p>
<ul>
  <li>
    <code>.every()</code>
  </li>
  <li>
    <code>.filter()</code>
  </li>
  <li>
    <code>.find()</code>
  </li>
  <li>
    <code>.flatMap()</code>
  </li>
  <li>
    <code>.forEach()</code>
  </li>
  <li>
    <code>.map()</code>
  </li>
  <li>
    <code>.reduce()</code>
  </li>
  <li>
    <code>.some()</code>
  </li>
</ul>
<h4 id="iteratorprototype-methods-that-return-iterators"><a class="heading-id-link" href="#iteratorprototype-methods-that-return-iterators">32.10.4 <code>Iterator.prototype.*</code>: methods that return iterators</a></h4>
<ul>
  <li>
    <p><code id="qref-Iterator.prototype.drop">Iterator.prototype.drop(limit)</code> <span class="ibox ibox-small" size="small">ES2025</span></p>
<pre class="language-ts">
<code><span class="hljs-title class_">Iterator</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">drop</span>(<span class="hljs-attr">limit</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Iterator</span>&lt;T&gt;</code>
</pre>
    <p>This method returns an iterator that with all values of <code>iterator</code>, except for the first <code>limit</code> ones. That is, iteration starts when the iteration counter is <code>limit</code>.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Iterator</span>.<span class="hljs-title function_">from</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>]).<span class="hljs-title function_">drop</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">toArray</span>(),</code>
<code>  [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>]</code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Iterator.prototype.filter">Iterator.prototype.filter(filterFn)</code><br/><span class="ibox ibox-small" size="small">ES2025 | Callback gets counter</span></p>
<pre class="language-ts">
<code><span class="hljs-title class_">Iterator</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">filter</span>(</code>
<code>  <span class="hljs-attr">filterFn</span>: <span class="hljs-function">(<span class="hljs-params">value: T, counter: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span></code>
<code>): <span class="hljs-title class_">Iterator</span>&lt;T&gt;</code>
</pre>
    <p>This method returns an iterator whose values are the values of <code>iterator</code> for which <code>filterFn</code> returns <code>true</code>.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Iterator</span>.<span class="hljs-title function_">from</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>]).<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &lt;= <span class="hljs-string">'b'</span>).<span class="hljs-title function_">toArray</span>(),</code>
<code>  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]</code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Iterator.prototype.flatMap">Iterator.prototype.flatMap(mapFn)</code><br/><span class="ibox ibox-small" size="small">ES2025 | Callback gets counter</span></p>
<pre class="language-ts">
<code><span class="hljs-title class_">Iterator</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">flatMap</span>&lt;U&gt;(</code>
<code>  <span class="hljs-attr">mapFn</span>: <span class="hljs-function">(<span class="hljs-params">value: T, counter: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-title class_">Iterable</span>&lt;U&gt; | <span class="hljs-title class_">Iterator</span>&lt;U&gt;</code>
<code>): <span class="hljs-title class_">Iterator</span>&lt;U&gt;</code>
</pre>
    <p>This method returns an iterator whose values are the values of the iterables or iterators that are the results of applying <code>mapFn</code> to the values of <code>iterator</code>.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Iterator</span>.<span class="hljs-title function_">from</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>])</code>
<code>  .<span class="hljs-title function_">flatMap</span>(<span class="hljs-function">(<span class="hljs-params">value, counter</span>) =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(counter).<span class="hljs-title function_">fill</span>(value))</code>
<code>  .<span class="hljs-title function_">toArray</span>(),</code>
<code>  [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'d'</span>]</code>
<code>);</code>
</pre>
    <p>For more information see the section on the Array method with the same name: <a href="ch_arrays.html#Array.prototype.flatMap">“<code>.flatMap()</code>: Each input element produces zero or more output elements<span> <sup>ES2019</sup></span>” (§34.14.3)</a>.</p>
  </li>
  <li>
    <p><code id="qref-Iterator.prototype.map">Iterator.prototype.map(mapFn)</code><br/><span class="ibox ibox-small" size="small">ES2025 | Callback gets counter</span></p>
<pre class="language-ts">
<code><span class="hljs-title class_">Iterator</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">map</span>&lt;U&gt;(</code>
<code>  <span class="hljs-attr">mapFn</span>: <span class="hljs-function">(<span class="hljs-params">value: T, counter: <span class="hljs-built_in">number</span></span>) =&gt;</span> U</code>
<code>): <span class="hljs-title class_">Iterator</span>&lt;U&gt;</code>
</pre>
    <p>This method returns an iterator whose values are the result of applying <code>mapFn</code> to the values of <code>iterator</code>.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Iterator</span>.<span class="hljs-title function_">from</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>]).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + x).<span class="hljs-title function_">toArray</span>(),</code>
<code>  [<span class="hljs-string">'aa'</span>, <span class="hljs-string">'bb'</span>, <span class="hljs-string">'cc'</span>, <span class="hljs-string">'dd'</span>]</code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Iterator.prototype.take">Iterator.prototype.take(limit)</code> <span class="ibox ibox-small" size="small">ES2025</span></p>
<pre class="language-ts">
<code><span class="hljs-title class_">Iterator</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">take</span>(<span class="hljs-attr">limit</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Iterator</span>&lt;T&gt;</code>
</pre>
    <p>This method returns an iterator with the first <code>limit</code> values of <code>iterator</code>.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Iterator</span>.<span class="hljs-title function_">from</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>]).<span class="hljs-title function_">take</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">toArray</span>(),</code>
<code>  [<span class="hljs-string">'a'</span>]</code>
<code>);</code>
</pre>
  </li>
</ul>
<h4 id="iteratorprototype-methods-that-return-booleans"><a class="heading-id-link" href="#iteratorprototype-methods-that-return-booleans">32.10.5 <code>Iterator.prototype.*</code>: methods that return booleans</a></h4>
<ul>
  <li>
    <p><code id="qref-Iterator.prototype.every">Iterator.prototype.every(fn)</code><br/><span class="ibox ibox-small" size="small">ES2025 | Callback gets counter</span></p>
<pre class="language-ts">
<code><span class="hljs-title class_">Iterator</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">every</span>(</code>
<code>  <span class="hljs-attr">fn</span>: <span class="hljs-function">(<span class="hljs-params">value: T, counter: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span></code>
<code>): <span class="hljs-built_in">boolean</span></code>
</pre>
    <p>This method returns <code>true</code> if <code>fn</code> returns <code>true</code> for every value of <code>iterator</code>. Otherwise, it returns <code>false</code>.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">Iterator</span>.<span class="hljs-title function_">from</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>]).<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x === <span class="hljs-string">'c'</span>),</code>
<code>  <span class="hljs-literal">false</span></code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Iterator.prototype.some">Iterator.prototype.some(fn)</code><br/><span class="ibox ibox-small" size="small">ES2025 | Callback gets counter</span></p>
<pre class="language-ts">
<code><span class="hljs-title class_">Iterator</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">some</span>(</code>
<code>  <span class="hljs-attr">fn</span>: <span class="hljs-function">(<span class="hljs-params">value: T, counter: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span></code>
<code>): <span class="hljs-built_in">boolean</span></code>
</pre>
    <p>This method returns <code>true</code> if <code>fn</code> returns <code>true</code> for at least one value of <code>iterator</code>. Otherwise, it returns <code>false</code>.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">Iterator</span>.<span class="hljs-title function_">from</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>]).<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x === <span class="hljs-string">'c'</span>),</code>
<code>  <span class="hljs-literal">true</span></code>
<code>);</code>
</pre>
  </li>
</ul>
<h4 id="iteratorprototype-methods-that-return-other-kinds-of-values"><a class="heading-id-link" href="#iteratorprototype-methods-that-return-other-kinds-of-values">32.10.6 <code>Iterator.prototype.*</code>: methods that return other kinds of values</a></h4>
<ul>
  <li>
    <p><code id="qref-Iterator.prototype.find">Iterator.prototype.find(fn)</code><br/><span class="ibox ibox-small" size="small">ES2025 | Callback gets counter</span></p>
<pre class="language-ts">
<code><span class="hljs-title class_">Iterator</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">find</span>(</code>
<code>  <span class="hljs-attr">fn</span>: <span class="hljs-function">(<span class="hljs-params">value: T, counter: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span></code>
<code>): T</code>
</pre>
    <p>This method returns the first value of <code>iterator</code> for which <code>fn</code> returns <code>true</code>. If there is no such value, it returns <code>undefined</code>.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">Iterator</span>.<span class="hljs-title function_">from</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>]).<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">_, counter</span>) =&gt;</span> counter === <span class="hljs-number">1</span>),</code>
<code>  <span class="hljs-string">'b'</span></code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Iterator.prototype.reduce">Iterator.prototype.reduce(reducer, initialValue?)</code><br/><span class="ibox ibox-small" size="small">ES2025 | Callback gets counter</span></p>
<pre class="language-ts">
<code><span class="hljs-title class_">Iterator</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">reduce</span>&lt;U&gt;(</code>
<code>  <span class="hljs-attr">reducer</span>: <span class="hljs-function">(<span class="hljs-params">accumulator: U, value: T, counter: <span class="hljs-built_in">number</span></span>) =&gt;</span> U,</code>
<code>  initialValue?: U</code>
<code>): U</code>
</pre>
    <p>This method uses the function <code>reducer</code> to combine the values of <code>iterator</code> into a single value.</p>
    <p>Example – concatenating the strings of an iterator:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Iterator</span>.<span class="hljs-title function_">from</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>]).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, v</span>) =&gt;</span> acc + v),</code>
<code>  <span class="hljs-string">'abcd'</span></code>
<code>);</code>
</pre>
    <p>Example – computing the minimum of a Set of numbers:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">3</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">4</span>]);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  set.<span class="hljs-title function_">values</span>().<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">min, cur</span>) =&gt;</span> cur &lt; min ? cur : min, <span class="hljs-title class_">Infinity</span>),</code>
<code>  -<span class="hljs-number">5</span></code>
<code>);</code>
</pre>
    <p>For more information see the section on the Array method with the same name: <a href="ch_arrays.html#Array.prototype.reduce">“<code>.reduce()</code>: computing a summary for an Array” (§34.15)</a>.</p>
  </li>
  <li>
    <p><code id="qref-Iterator.prototype.toArray">Iterator.prototype.toArray()</code> <span class="ibox ibox-small" size="small">ES2025</span></p>
<pre class="language-ts">
<code><span class="hljs-title class_">Iterator</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">toArray</span>(): <span class="hljs-title class_">Array</span>&lt;T&gt;</code>
</pre>
    <p>This method returns the values of <code>iterator</code> in an Array.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Iterator</span>.<span class="hljs-title function_">from</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>]).<span class="hljs-title function_">toArray</span>(),</code>
<code>  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>]</code>
<code>);</code>
</pre>
  </li>
</ul>
<h4 id="iteratorprototype-other-methods"><a class="heading-id-link" href="#iteratorprototype-other-methods">32.10.7 <code>Iterator.prototype.*</code>: other methods</a></h4>
<ul>
  <li>
    <p><code id="qref-Iterator.prototype.forEach">Iterator.prototype.forEach(fn)</code><br/><span class="ibox ibox-small" size="small">ES2025 | Callback gets counter</span></p>
<pre class="language-ts">
<code><span class="hljs-title class_">Iterator</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">forEach</span>(</code>
<code>  <span class="hljs-attr">fn</span>: <span class="hljs-function">(<span class="hljs-params">value: T, counter: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span></code>
<code>): <span class="hljs-built_in">void</span></code>
</pre>
    <p>This method applies <code>fn</code> to each value in <code>iterator</code>.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> result = [];</code>
<code><span class="hljs-title class_">Iterator</span>.<span class="hljs-title function_">from</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>]).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> result.<span class="hljs-title function_">unshift</span>(x))</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  result,</code>
<code>  [<span class="hljs-string">'d'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>]</code>
<code>);</code>
</pre>
  </li>
</ul>

    
      
</body>
</html>