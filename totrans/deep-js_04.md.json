["```js\n    function multiply(x, y) {\n     if (typeof x !== 'number' || typeof y !== 'number') {\n     throw new TypeError();\n     }\n     // \u00b7\u00b7\u00b7\n    }\n    ```", "```js\n    function multiply(x, y) {\n     if (typeof x !== 'number' || typeof y !== 'number') {\n     return NaN;\n     }\n     // \u00b7\u00b7\u00b7\n    }\n    ```", "```js\n    function multiply(x, y) {\n     if (typeof x !== 'number') {\n     x = Number(x);\n     }\n     if (typeof y !== 'number') {\n     y = Number(y);\n     }\n     // \u00b7\u00b7\u00b7\n    }\n    ```", "```js\n// Coercion\nassert.equal(3 * true, 3);\n\n// Error values\nassert.equal(1 / 0, Infinity);\nassert.equal(Number('xyz'), NaN);\n```", "```js\n    > undefined.prop\n    TypeError: Cannot read property 'prop' of undefined\n    > null.prop\n    TypeError: Cannot read property 'prop' of null\n    > 'prop' in null\n    TypeError: Cannot use 'in' operator to search for 'prop' in null\n    ```", "```js\n    > 6 / Symbol()\n    TypeError: Cannot convert a Symbol value to a number\n    ```", "```js\n    > 6 / 3n\n    TypeError: Cannot mix BigInt and other types\n    ```", "```js\n    > 123()\n    TypeError: 123 is not a function\n    > (class {})()\n    TypeError: Class constructor  cannot be invoked without 'new'\n\n    > new 123\n    TypeError: 123 is not a constructor\n    > new (() => {})\n    TypeError: (intermediate value) is not a constructor\n    ```", "```js\n    > 'abc'.length = 1\n    TypeError: Cannot assign to read only property 'length'\n    > Object.freeze({prop:3}).prop = 1\n    TypeError: Cannot assign to read only property 'prop'\n    ```", "```js\n    let x = '3';\n    let y = '2';\n    assert.equal(Number(x) * Number(y), 6);\n    ```", "```js\n    let x = '3';\n    let y = '2';\n    assert.equal(x * y, 6);\n    ```", "```js\nfunction isNaN(number: number) {\n // \u00b7\u00b7\u00b7\n}\n```", "```js\nfunction isNaN(number) {\n let num = ToNumber(number);\n // \u00b7\u00b7\u00b7\n}\n```", "```js\n> Boolean(0)\nfalse\n> Boolean(1)\ntrue\n\n> Number('123')\n123\n```", "```js\n    Type(num)::mthd(\u00b7\u00b7\u00b7)\n    ```", "```js\n/**\n * An improved version of typeof\n */\nfunction TypeOf(value) {\n const result = typeof value;\n switch (result) {\n case 'function':\n return 'object';\n case 'object':\n if (value === null) {\n return 'null';\n } else {\n return 'object';\n }\n default:\n return result;\n }\n}\n\nfunction IsCallable(x) {\n return typeof x === 'function';\n}\n```", "```js\n/**\n * @param  hint Which type is preferred for the result:\n *             string, number, or don\u2019t care?\n */\nfunction ToPrimitive(input: any,\n hint: 'string'|'number'|'default' = 'default') {\n if (TypeOf(input) === 'object') {\n let exoticToPrim = input[Symbol.toPrimitive]; // (A)\n if (exoticToPrim !== undefined) {\n let result = exoticToPrim.call(input, hint);\n if (TypeOf(result) !== 'object') {\n return result;\n }\n throw new TypeError();\n }\n if (hint === 'default') {\n hint = 'number';\n }\n return OrdinaryToPrimitive(input, hint);\n } else {\n // input is already primitive\n return input;\n }\n }\n```", "```js\nfunction OrdinaryToPrimitive(O: object, hint: 'string' | 'number') {\n let methodNames;\n if (hint === 'string') {\n methodNames = ['toString', 'valueOf'];\n } else {\n methodNames = ['valueOf', 'toString'];\n }\n for (let name of methodNames) {\n let method = O[name];\n if (IsCallable(method)) {\n let result = method.call(O);\n if (TypeOf(result) !== 'object') {\n return result;\n }\n }\n }\n throw new TypeError();\n}\n```", "```js\nconst obj = {\n toString() { return 'a' },\n valueOf() { return 1 },\n};\n\n// String() prefers strings:\nassert.equal(String(obj), 'a');\n\n// Number() prefers numbers:\nassert.equal(Number(obj), 1);\n```", "```js\nDate.prototype[Symbol.toPrimitive] = function (\n hint: 'default' | 'string' | 'number') {\n let O = this;\n if (TypeOf(O) !== 'object') {\n throw new TypeError();\n }\n let tryFirst;\n if (hint === 'string' || hint === 'default') {\n tryFirst = 'string';\n } else if (hint === 'number') {\n tryFirst = 'number';\n } else {\n throw new TypeError();\n }\n return OrdinaryToPrimitive(O, tryFirst);\n };\n```", "```js\n    const d = new Date('2222-03-27');\n    assert.equal(\n     d == 'Wed Mar 27 2222 01:00:00 GMT+0100'\n     + ' (Central European Standard Time)',\n     true);\n    ```", "```js\n    const d = new Date('2222-03-27');\n    assert.equal(\n     123 + d,\n     '123Wed Mar 27 2222 01:00:00 GMT+0100'\n     + ' (Central European Standard Time)');\n    ```", "```js\nfunction ToString(argument) {\n if (argument === undefined) {\n return 'undefined';\n } else if (argument === null) {\n return 'null';\n } else if (argument === true) {\n return 'true';\n } else if (argument === false) {\n return 'false';\n } else if (TypeOf(argument) === 'number') {\n return Number.toString(argument);\n } else if (TypeOf(argument) === 'string') {\n return argument;\n } else if (TypeOf(argument) === 'symbol') {\n throw new TypeError();\n } else if (TypeOf(argument) === 'bigint') {\n return BigInt.toString(argument);\n } else {\n // argument is an object\n let primValue = ToPrimitive(argument, 'string'); // (A)\n return ToString(primValue);\n }\n}\n```", "```js\n> const sym = Symbol('sym');\n\n> ''+sym\nTypeError: Cannot convert a Symbol value to a string\n> `${sym}`\nTypeError: Cannot convert a Symbol value to a string\n```", "```js\n> String(sym)\n'Symbol(sym)'\n> sym.toString()\n'Symbol(sym)'\n```", "```js\nfunction String(value) {\n let s;\n if (value === undefined) {\n s = '';\n } else {\n if (new.target === undefined && TypeOf(value) === 'symbol') {\n // This function was function-called and value is a symbol\n return SymbolDescriptiveString(value);\n }\n s = ToString(value);\n }\n if (new.target === undefined) {\n // This function was function-called\n return s;\n }\n // This function was new-called\n return StringCreate(s, new.target.prototype); // simplified!\n}\n```", "```js\n/** \n * Creates a String instance that wraps `value`\n * and has the given protoype.\n */\nfunction StringCreate(value, prototype) {\n // \u00b7\u00b7\u00b7\n}\n\nfunction SymbolDescriptiveString(sym) {\n assert.equal(TypeOf(sym), 'symbol');\n let desc = sym.description;\n if (desc === undefined) {\n desc = '';\n }\n assert.equal(TypeOf(desc), 'string');\n return 'Symbol('+desc+')';\n}\n```", "```js\nSymbol.prototype.toString = function () {\n let sym = thisSymbolValue(this);\n return SymbolDescriptiveString(sym);\n};\nfunction thisSymbolValue(value) {\n if (TypeOf(value) === 'symbol') {\n return value;\n }\n if (TypeOf(value) === 'object' && '__SymbolData__' in value) {\n let s = value.__SymbolData__;\n assert.equal(TypeOf(s), 'symbol');\n return s;\n }\n}\n```", "```js\nObject.prototype.toString = function () {\n if (this === undefined) {\n return '[object Undefined]';\n }\n if (this === null) {\n return '[object Null]';\n }\n let O = ToObject(this);\n let isArray = Array.isArray(O);\n let builtinTag;\n if (isArray) {\n builtinTag = 'Array';\n } else if ('__ParameterMap__' in O) {\n builtinTag = 'Arguments';\n } else if ('__Call__' in O) {\n builtinTag = 'Function';\n } else if ('__ErrorData__' in O) {\n builtinTag = 'Error';\n } else if ('__BooleanData__' in O) {\n builtinTag = 'Boolean';\n } else if ('__NumberData__' in O) {\n builtinTag = 'Number';\n } else if ('__StringData__' in O) {\n builtinTag = 'String';\n } else if ('__DateValue__' in O) {\n builtinTag = 'Date';\n } else if ('__RegExpMatcher__' in O) {\n builtinTag = 'RegExp';\n } else {\n builtinTag = 'Object';\n }\n let tag = O[Symbol.toStringTag];\n if (TypeOf(tag) !== 'string') {\n tag = builtinTag;\n }\n return '[object ' + tag + ']';\n};\n```", "```js\n> String({})\n'[object Object]'\n```", "```js\nclass MyClass {}\nassert.equal(\n String(new MyClass()), '[object Object]');\n```", "```js\nclass MyClass {}\nMyClass.prototype[Symbol.toStringTag] = 'Custom!';\nassert.equal(\n String(new MyClass()), '[object Custom!]');\n```", "```js\n> ['a', 'b'].toString()\n'a,b'\n> Object.prototype.toString.call(['a', 'b'])\n'[object Array]'\n\n> /^abc$/.toString()\n'/^abc$/'\n> Object.prototype.toString.call(/^abc$/)\n'[object RegExp]'\n```", "```js\nfunction ToPropertyKey(argument) {\n let key = ToPrimitive(argument, 'string'); // (A)\n if (TypeOf(key) === 'symbol') {\n return key;\n }\n return ToString(key);\n}\n```", "```js\nfunction ToNumeric(value) {\n let primValue = ToPrimitive(value, 'number');\n if (TypeOf(primValue) === 'bigint') {\n return primValue;\n }\n return ToNumber(primValue);\n}\n```", "```js\nfunction ToNumber(argument) {\n if (argument === undefined) {\n return NaN;\n } else if (argument === null) {\n return +0;\n } else if (argument === true) {\n return 1;\n } else if (argument === false) {\n return +0;\n } else if (TypeOf(argument) === 'number') {\n return argument;\n } else if (TypeOf(argument) === 'string') {\n return parseTheString(argument); // not shown here\n } else if (TypeOf(argument) === 'symbol') {\n throw new TypeError();\n } else if (TypeOf(argument) === 'bigint') {\n throw new TypeError();\n } else {\n // argument is an object\n let primValue = ToPrimitive(argument, 'number');\n return ToNumber(primValue);\n }\n}\n```", "```js\nfunction Addition(leftHandSide, rightHandSide) {\n let lprim = ToPrimitive(leftHandSide);\n let rprim = ToPrimitive(rightHandSide);\n if (TypeOf(lprim) === 'string' || TypeOf(rprim) === 'string') { // (A)\n return ToString(lprim) + ToString(rprim);\n }\n let lnum = ToNumeric(lprim);\n let rnum = ToNumeric(rprim);\n if (TypeOf(lnum) !== TypeOf(rnum)) {\n throw new TypeError();\n }\n let T = Type(lnum);\n return T.add(lnum, rnum); // (B)\n}\n```", "```js\n/** Loose equality (==) */\nfunction abstractEqualityComparison(x, y) {\n if (TypeOf(x) === TypeOf(y)) {\n // Use strict equality (===)\n return strictEqualityComparison(x, y);\n }\n\n // Comparing null with undefined\n if (x === null && y === undefined) {\n return true;\n }\n if (x === undefined && y === null) {\n return true;\n }\n\n // Comparing a number and a string\n if (TypeOf(x) === 'number' && TypeOf(y) === 'string') {\n return abstractEqualityComparison(x, Number(y));\n }\n if (TypeOf(x) === 'string' && TypeOf(y) === 'number') {\n return abstractEqualityComparison(Number(x), y);\n }\n\n // Comparing a bigint and a string\n if (TypeOf(x) === 'bigint' && TypeOf(y) === 'string') {\n let n = StringToBigInt(y);\n if (Number.isNaN(n)) {\n return false;\n }\n return abstractEqualityComparison(x, n);\n }\n if (TypeOf(x) === 'string' && TypeOf(y) === 'bigint') {\n return abstractEqualityComparison(y, x);\n }\n\n // Comparing a boolean with a non-boolean\n if (TypeOf(x) === 'boolean') {\n return abstractEqualityComparison(Number(x), y);\n }\n if (TypeOf(y) === 'boolean') {\n return abstractEqualityComparison(x, Number(y));\n }\n\n // Comparing an object with a primitive\n // (other than undefined, null, a boolean)\n if (['string', 'number', 'bigint', 'symbol'].includes(TypeOf(x))\n && TypeOf(y) === 'object') {\n return abstractEqualityComparison(x, ToPrimitive(y));\n }\n if (TypeOf(x) === 'object'\n && ['string', 'number', 'bigint', 'symbol'].includes(TypeOf(y))) {\n return abstractEqualityComparison(ToPrimitive(x), y);\n }\n\n // Comparing a bigint with a number\n if ((TypeOf(x) === 'bigint' && TypeOf(y) === 'number')\n || (TypeOf(x) === 'number' && TypeOf(y) === 'bigint')) {\n if ([NaN, +Infinity, -Infinity].includes(x)\n || [NaN, +Infinity, -Infinity].includes(y)) {\n return false;\n }\n if (isSameMathematicalValue(x, y)) {\n return true;\n } else {\n return false;\n }\n }\n\n return false;\n}\n```"]