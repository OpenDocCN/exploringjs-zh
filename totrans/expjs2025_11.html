<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>9 Syntax</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>9 Syntax</h1>
<blockquote>原文：<a href="https://exploringjs.com/js/book/ch_syntax.html">https://exploringjs.com/js/book/ch_syntax.html</a></blockquote>

        
    
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#an-overview-of-javascripts-syntax">9.1 An overview of JavaScript’s syntax</a>
      <ol>
        <li>
          <a href="#basic-constructs">9.1.1 Basic constructs</a>
        </li>
        <li>
          <a href="#modules">9.1.2 Modules</a>
        </li>
        <li>
          <a href="#classes-1">9.1.3 Classes</a>
        </li>
        <li>
          <a href="#exception-handling">9.1.4 Exception handling</a>
        </li>
        <li>
          <a href="#legal-variable-and-property-names">9.1.5 Legal variable and property names</a>
        </li>
        <li>
          <a href="#casing-styles">9.1.6 Casing styles</a>
        </li>
        <li>
          <a href="#capitalization-of-names">9.1.7 Capitalization of names</a>
        </li>
        <li>
          <a href="#more-naming-conventions">9.1.8 More naming conventions</a>
        </li>
        <li>
          <a href="#where-to-put-semicolons">9.1.9 Where to put semicolons?</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#advanced">9.2 (Advanced)</a>
    </li>
    <li>
      <a href="#hashbang-lines">9.3 Hashbang lines (Unix shell scripts)</a>
    </li>
    <li>
      <a href="#identifiers">9.4 Identifiers</a>
      <ol>
        <li>
          <a href="#valid-identifiers-variable-names-etc">9.4.1 Valid identifiers (variable names, etc.)</a>
        </li>
        <li>
          <a href="#reserved-words">9.4.2 Reserved words</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#statement-vs-expression">9.5 Statement vs. expression</a>
      <ol>
        <li>
          <a href="#statements">9.5.1 Statements</a>
        </li>
        <li>
          <a href="#expressions">9.5.2 Expressions</a>
        </li>
        <li>
          <a href="#what-is-allowed-where">9.5.3 What is allowed where?</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#ambiguous-syntax">9.6 Ambiguous syntax</a>
      <ol>
        <li>
          <a href="#same-syntax-function-declaration-and-function-expression">9.6.1 Same syntax: function declaration and function expression</a>
        </li>
        <li>
          <a href="#same-syntax-object-literal-and-block">9.6.2 Same syntax: object literal and block</a>
        </li>
        <li>
          <a href="#disambiguation">9.6.3 Disambiguation</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#semicolons">9.7 Semicolons</a>
      <ol>
        <li>
          <a href="#rule-of-thumb-for-semicolons">9.7.1 Rule of thumb for semicolons</a>
        </li>
        <li>
          <a href="#semicolons-control-statements">9.7.2 Semicolons: control statements</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#automatic-semicolon-insertion-asi">9.8 Automatic semicolon insertion (ASI)</a>
      <ol>
        <li>
          <a href="#asi-triggered-unexpectedly">9.8.1 ASI triggered unexpectedly</a>
        </li>
        <li>
          <a href="#asi-unexpectedly-not-triggered">9.8.2 ASI unexpectedly not triggered</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#semicolons-best-practices">9.9 Semicolons: best practices</a>
    </li>
    <li>
      <a href="#strict-mode">9.10 Strict mode vs. sloppy mode</a>
      <ol>
        <li>
          <a href="#switching-on-strict-mode">9.10.1 Switching on strict mode</a>
        </li>
        <li>
          <a href="#improvements-in-strict-mode">9.10.2 Improvements in strict mode</a>
        </li>
      </ol>
    </li>
  </ol>
</nav>
<h3 id="an-overview-of-javascripts-syntax"><a class="heading-id-link" href="#an-overview-of-javascripts-syntax">9.1 An overview of JavaScript’s syntax</a></h3>
<p><span id="index-entry-syntax"/></p>
<p>This is a very first look at JavaScript’s syntax. Don’t worry if some things don’t make sense, yet. They will all be explained in more detail later in this book.</p>
<p>This overview is not exhaustive, either. It focuses on the essentials.</p>
<h4 id="basic-constructs"><a class="heading-id-link" href="#basic-constructs">9.1.1 Basic constructs</a></h4>
<h5 id="comments"><a class="heading-id-link" href="#comments">9.1.1.1 Comments</a></h5>
<pre class="language-js">
<span class="hljs-comment">// single-line comment</span>
<code/>
<span class="hljs-comment">/*</span>
<span class="hljs-comment">Comment with</span>
<span class="hljs-comment">multiple lines</span>
<span class="hljs-comment">*/</span>
</pre>
<h5 id="primitive-atomic-values"><a class="heading-id-link" href="#primitive-atomic-values">9.1.1.2 <em>Primitive</em> (atomic) values</a></h5>
<p><strong>Booleans:</strong></p>
<pre class="language-js">
<span class="hljs-literal">true</span>
<span class="hljs-literal">false</span>
</pre>
<p><strong>Numbers:</strong></p>
<pre class="language-js">
<span class="hljs-number">1.141</span>
-<span class="hljs-number">123</span>
</pre>
<p>The basic number type is used for both floating point numbers (doubles) and integers.</p>
<p><strong>Bigints:</strong></p>
<pre class="language-js">
<span class="hljs-number">17n</span>
-<span class="hljs-number">49n</span>
</pre>
<p>The basic number type can only properly represent integers within a range of 53 bits plus sign. Bigints can grow arbitrarily large in size.</p>
<p><strong>Strings:</strong></p>
<pre class="language-js">
<span class="hljs-string">'abc'</span>
<span class="hljs-string">"abc"</span>
<span class="hljs-string">`String with interpolated values: <span class="hljs-subst">${<span class="hljs-number">256</span>}</span> and <span class="hljs-subst">${<span class="hljs-literal">true</span>}</span>`</span>
</pre>
<p>JavaScript has no extra type for characters. It uses strings to represent them.</p>
<h5 id="assertions"><a class="heading-id-link" href="#assertions">9.1.1.3 Assertions</a></h5>
<p>An <em>assertion</em> describes what the result of a computation is expected to look like and throws an exception if those expectations aren’t correct. For example, the following assertion states that the result of the computation 7 plus 1 must be 8:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">7</span> + <span class="hljs-number">1</span>, <span class="hljs-number">8</span>);
</pre>
<p><code>assert.equal()</code> is a method call (the object is <code>assert</code>, the method is <code>.equal()</code>) with two arguments: the actual result and the expected result. It is part of a Node.js assertion API that is explained <a href="ch_assertion-api.html#ch_assertion-api">later in this book</a>.</p>
<p>There is also <code>assert.deepEqual()</code> that compares objects deeply.</p>
<h5 id="logging-to-the-console"><a class="heading-id-link" href="#logging-to-the-console">9.1.1.4 Logging to the console</a></h5>
<p>Logging to <a href="ch_console.html#browser-consoles">the console</a> of a browser or Node.js:</p>
<pre class="language-js">
<span class="hljs-comment">// Printing a value to standard out (another method call)</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Hello!'</span>);
<code/>
<span class="hljs-comment">// Printing error information to standard error</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Something went wrong!'</span>);
</pre>
<h5 id="operators"><a class="heading-id-link" href="#operators">9.1.1.5 Operators</a></h5>
<pre class="language-js">
<span class="hljs-comment">// Operators for booleans</span>
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// And</span>
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-literal">true</span> || <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// Or</span>
<code/>
<span class="hljs-comment">// Operators for numbers</span>
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">3</span> + <span class="hljs-number">4</span>, <span class="hljs-number">7</span>);
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">5</span> - <span class="hljs-number">1</span>, <span class="hljs-number">4</span>);
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">3</span> * <span class="hljs-number">4</span>, <span class="hljs-number">12</span>);
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">10</span> / <span class="hljs-number">4</span>, <span class="hljs-number">2.5</span>);
<code/>
<span class="hljs-comment">// Operators for bigints</span>
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">3n</span> + <span class="hljs-number">4n</span>, <span class="hljs-number">7n</span>);
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">5n</span> - <span class="hljs-number">1n</span>, <span class="hljs-number">4n</span>);
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">3n</span> * <span class="hljs-number">4n</span>, <span class="hljs-number">12n</span>);
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">10n</span> / <span class="hljs-number">4n</span>, <span class="hljs-number">2n</span>);
<code/>
<span class="hljs-comment">// Operators for strings</span>
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-string">'a'</span> + <span class="hljs-string">'b'</span>, <span class="hljs-string">'ab'</span>);
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-string">'I see '</span> + <span class="hljs-number">3</span> + <span class="hljs-string">' monkeys'</span>, <span class="hljs-string">'I see 3 monkeys'</span>);
<code/>
<span class="hljs-comment">// Comparison operators</span>
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">3</span> &lt; <span class="hljs-number">4</span>, <span class="hljs-literal">true</span>);
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">3</span> &lt;= <span class="hljs-number">4</span>, <span class="hljs-literal">true</span>);
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-string">'abc'</span> === <span class="hljs-string">'abc'</span>, <span class="hljs-literal">true</span>);
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-string">'abc'</span> !== <span class="hljs-string">'def'</span>, <span class="hljs-literal">true</span>);
</pre>
<p>JavaScript also has a <code>==</code> comparison operator. I recommend to avoid it – why is explained in <a href="ch_operators.html#recommendation-always-strict-equality">“Recommendation: always use strict equality” (§15.5.3)</a>.</p>
<h5 id="declaring-variables"><a class="heading-id-link" href="#declaring-variables">9.1.1.6 Declaring variables</a></h5>
<p><code>const</code> creates <em>immutable variable bindings</em>: Each variable must be initialized immediately and we can’t assign a different value later. However, the value itself may be mutable and we may be able to change its contents. In other words: <code>const</code> does not make values immutable.</p>
<pre class="language-js">
<span class="hljs-comment">// Declaring and initializing x (immutable binding):</span>
<span class="hljs-keyword">const</span> x = <span class="hljs-number">8</span>;
<code/>
<span class="hljs-comment">// Would cause a TypeError:</span>
<span class="hljs-comment">// x = 9;</span>
</pre>
<p><code>let</code> creates <em>mutable variable bindings</em>:</p>
<pre class="language-js">
<span class="hljs-comment">// Declaring y (mutable binding):</span>
<span class="hljs-keyword">let</span> y;
<code/>
<span class="hljs-comment">// We can assign a different value to y:</span>
y = <span class="hljs-number">3</span> * <span class="hljs-number">5</span>;
<code/>
<span class="hljs-comment">// Declaring and initializing z:</span>
<span class="hljs-keyword">let</span> z = <span class="hljs-number">3</span> * <span class="hljs-number">5</span>;
</pre>
<h5 id="ordinary-function-declarations"><a class="heading-id-link" href="#ordinary-function-declarations">9.1.1.7 Ordinary function declarations</a></h5>
<pre class="language-js">
<span class="hljs-comment">// add1() has the parameters a and b</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">add1</span>(<span class="hljs-params">a, b</span>) {
  <span class="hljs-keyword">return</span> a + b;
}
<span class="hljs-comment">// Calling function add1()</span>
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">add1</span>(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>), <span class="hljs-number">7</span>);
</pre>
<h5 id="arrow-function-expressions"><a class="heading-id-link" href="#arrow-function-expressions">9.1.1.8 Arrow function expressions</a></h5>
<p>Arrow function expressions are used especially as arguments of function calls and method calls:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> <span class="hljs-title function_">add2</span> = (<span class="hljs-params">a, b</span>) =&gt; { <span class="hljs-keyword">return</span> a + b };
<span class="hljs-comment">// Calling function add2()</span>
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">add2</span>(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>), <span class="hljs-number">7</span>);
<code/>
<span class="hljs-comment">// Equivalent to add2:</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">add3</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;
</pre>
<p>The previous code contains the following two arrow functions (the terms <em>expression</em> and <em>statement</em> are explained <a href="#statement-vs-expression">later in this chapter</a>):</p>
<pre class="language-js">
<span class="hljs-comment">// An arrow function whose body is a code block</span>
(a, b) =&gt; { <span class="hljs-keyword">return</span> a + b }
<code/>
<span class="hljs-comment">// An arrow function whose body is an expression</span>
(a, b) =&gt; a + b
</pre>
<h5 id="plain-objects"><a class="heading-id-link" href="#plain-objects">9.1.1.9 Plain objects</a></h5>
<pre class="language-js">
<span class="hljs-comment">// Creating a plain object via an object literal</span>
<span class="hljs-keyword">const</span> obj = {
  <span class="hljs-attr">first</span>: <span class="hljs-string">'Jane'</span>, <span class="hljs-comment">// property</span>
  <span class="hljs-attr">last</span>: <span class="hljs-string">'Doe'</span>, <span class="hljs-comment">// property</span>
  <span class="hljs-title function_">getFullName</span>(<span class="hljs-params">) { <span class="hljs-comment">// property (method)</span></span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">first</span> + <span class="hljs-string">' '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">last</span>;</span>
<span class="hljs-params">  },</span>
<span class="hljs-params">};</span>
<code/>
<span class="hljs-params"><span class="hljs-comment">// Getting a property value</span></span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(obj.<span class="hljs-property">first</span>, <span class="hljs-string">'Jane'</span>);</span>
<span class="hljs-params"><span class="hljs-comment">// Setting a property value</span></span>
<span class="hljs-params">obj.<span class="hljs-property">first</span> = <span class="hljs-string">'Janey'</span>;</span>
<code/>
<span class="hljs-params"><span class="hljs-comment">// Calling the method</span></span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(obj.<span class="hljs-title function_">getFullName</span>(), <span class="hljs-string">'Janey Doe'</span>);</span>
</pre>
<h5 id="arrays"><a class="heading-id-link" href="#arrays">9.1.1.10 Arrays</a></h5>
<pre class="language-js">
<span class="hljs-comment">// Creating an Array via an Array literal</span>
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
assert.<span class="hljs-title function_">equal</span>(arr.<span class="hljs-property">length</span>, <span class="hljs-number">3</span>);
<code/>
<span class="hljs-comment">// Getting an Array element</span>
assert.<span class="hljs-title function_">equal</span>(arr[<span class="hljs-number">1</span>], <span class="hljs-string">'b'</span>);
<span class="hljs-comment">// Setting an Array element</span>
arr[<span class="hljs-number">1</span>] = <span class="hljs-string">'β'</span>;
<code/>
<span class="hljs-comment">// Adding an element to an Array:</span>
arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">'d'</span>);
<code/>
assert.<span class="hljs-title function_">deepEqual</span>(
  arr, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'β'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>]);
</pre>
<h5 id="control-flow-statements"><a class="heading-id-link" href="#control-flow-statements">9.1.1.11 Control flow statements</a></h5>
<p>Conditional statement:</p>
<pre class="language-js">
<span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) {
  x = -x;
}
</pre>
<p><code>for-of</code> loop:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> element <span class="hljs-keyword">of</span> arr) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(element);
}
</pre>
<p>Output:</p>
<pre>
a
b
</pre>
<h4 id="modules"><a class="heading-id-link" href="#modules">9.1.2 Modules</a></h4>
<p>Each module is a single file. Consider, for example, the following two files with modules in them:</p>
<pre class="language-txt">
file-tools.mjs
main.mjs
</pre>
<p>The module in <code>file-tools.mjs</code> exports its function <code>isTextFilePath()</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">isTextFilePath</span>(<span class="hljs-params">filePath</span>) {
  <span class="hljs-keyword">return</span> filePath.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">'.txt'</span>);
}
</pre>
<p>The module in <code>main.mjs</code> imports the whole module <code>path</code> and the function <code>isTextFilePath()</code>:</p>
<pre class="language-js">
<span class="hljs-comment">// Import whole module as namespace object `path`</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'node:path'</span>;
<span class="hljs-comment">// Import a single export of module file-tools.mjs</span>
<span class="hljs-keyword">import</span> {isTextFilePath} <span class="hljs-keyword">from</span> <span class="hljs-string">'./file-tools.mjs'</span>;
</pre>
<h4 id="classes-1"><a class="heading-id-link" href="#classes-1">9.1.3 Classes</a></h4>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
  <span class="hljs-title function_">describe</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">`Person named <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-title function_">logNames</span>(<span class="hljs-params">persons</span>) {</span>
<span class="hljs-params">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> person <span class="hljs-keyword">of</span> persons) {</span>
<span class="hljs-params">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);</span>
<span class="hljs-params">    }</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<code/>
<span class="hljs-params"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> {</span>
<span class="hljs-params">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, title</span>) {</span>
<span class="hljs-params">    <span class="hljs-variable language_">super</span>(name);</span>
<span class="hljs-params">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = title;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">  <span class="hljs-title function_">describe</span>(<span class="hljs-params"/>) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">describe</span>() +</span>
<span class="hljs-params">      <span class="hljs-string">` (<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.title}</span>)`</span>;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<code/>
<span class="hljs-params"><span class="hljs-keyword">const</span> jane = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">'Jane'</span>, <span class="hljs-string">'CTO'</span>);</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">  jane.<span class="hljs-title function_">describe</span>(),</span>
<span class="hljs-params">  <span class="hljs-string">'Person named Jane (CTO)'</span>);</span>
</pre>
<h4 id="exception-handling"><a class="heading-id-link" href="#exception-handling">9.1.4 Exception handling</a></h4>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">throwsException</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Problem!'</span>);</span>
<span class="hljs-params">}</span>
<code/>
<span class="hljs-params"><span class="hljs-keyword">function</span> <span class="hljs-title function_">catchesException</span>(<span class="hljs-params"/>) {</span>
<span class="hljs-params">  <span class="hljs-keyword">try</span> {</span>
<span class="hljs-params">    <span class="hljs-title function_">throwsException</span>();</span>
<span class="hljs-params">  } <span class="hljs-keyword">catch</span> (err) {</span>
<span class="hljs-params">    assert.<span class="hljs-title function_">ok</span>(err <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Error</span>);</span>
<span class="hljs-params">    assert.<span class="hljs-title function_">equal</span>(err.<span class="hljs-property">message</span>, <span class="hljs-string">'Problem!'</span>);</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
</pre>
<p>Note:</p>
<ul>
  <li>
    <code>try-finally</code> and <code>try-catch-finally</code> are also supported.
  </li>
  <li>
    We can throw any value, but features such as stack traces are only supported by <code>Error</code> and its subclasses.
  </li>
</ul>
<h4 id="legal-variable-and-property-names"><a class="heading-id-link" href="#legal-variable-and-property-names">9.1.5 Legal variable and property names</a></h4>
<p><span id="index-entry-identifier"/></p>
<p>The grammatical category of variable names and property names is called <em>identifier</em>.</p>
<p>Identifiers are allowed to have the following characters:</p>
<ul>
  <li>
    Unicode letters: <code>A</code>–<code>Z</code>, <code>a</code>–<code>z</code> (etc.)
  </li>
  <li>
    <code>$</code>, <code>_</code>
  </li>
  <li>
    Unicode digits: <code>0</code>–<code>9</code> (etc.)
    <ul>
      <li>
        Variable names can’t start with a digit
      </li>
    </ul>
  </li>
</ul>
<p>Some words have special meaning in JavaScript and are called <em>reserved</em>. Examples include: <code>if</code>, <code>true</code>, <code>const</code>.</p>
<p>Reserved words can’t be used as variable names:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> <span class="hljs-keyword">if</span> = <span class="hljs-number">123</span>;
  <span class="hljs-comment">// SyntaxError: Unexpected token if</span>
</pre>
<p>But they are allowed as names of properties:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">if</span>: <span class="hljs-number">123</span> };</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">obj.<span class="hljs-property">if</span></span>
123
</pre>
<h4 id="casing-styles"><a class="heading-id-link" href="#casing-styles">9.1.6 Casing styles</a></h4>
<p><span id="index-entry-camel-case"/><span id="index-entry-case--camel"/>
<span id="index-entry-underscore-case"/><span id="index-entry-case--underscore"/>
<span id="index-entry-snake-case"/><span id="index-entry-case--snake"/>
<span id="index-entry-dash-case"/><span id="index-entry-case--dash"/>
<span id="index-entry-kebab-case"/><span id="index-entry-case--kebab"/></p>
<p>Common casing styles for concatenating words are:</p>
<ul>
  <li>
    Camel case: <code>threeConcatenatedWords</code> <span id="index-entry-camel-case2"/>
  </li>
  <li>
    Underscore case (also called <em>snake case</em>): <code>three_concatenated_words</code> <span id="index-entry-underscore-case2"/><span id="index-entry-snake-case2"/>
  </li>
  <li>
    Dash case (also called <em>kebab case</em>): <code>three-concatenated-words</code> <span id="index-entry-dash-case2"/><span id="index-entry-kebab-case2"/>
  </li>
</ul>
<h4 id="capitalization-of-names"><a class="heading-id-link" href="#capitalization-of-names">9.1.7 Capitalization of names</a></h4>
<p>In general, JavaScript uses camel case, except for constants.</p>
<p>Lowercase:</p>
<ul>
  <li>
    <p>Functions, variables: <code>myFunction</code></p>
  </li>
  <li>
    <p>Methods: <code>obj.myMethod</code></p>
  </li>
  <li>
    <p>CSS:</p>
    <ul>
      <li>
        CSS names: <code>my-utility-class</code> (dash case)
      </li>
      <li>
        Corresponding JavaScript names: <code>myUtilityClass</code>
      </li>
    </ul>
  </li>
  <li>
    <p>Module file names are usually dash-cased:</p>
<pre class="language-js">
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> theSpecialLibrary <span class="hljs-keyword">from</span> <span class="hljs-string">'./the-special-library.mjs'</span>;
</pre>
  </li>
</ul>
<p>Uppercase:</p>
<ul>
  <li>
    Classes: <code>MyClass</code>
  </li>
</ul>
<p>All-caps:</p>
<ul>
  <li>
    Constants (as shared between modules etc.): <code>MY_CONSTANT</code> (underscore case)
  </li>
</ul>
<h4 id="more-naming-conventions"><a class="heading-id-link" href="#more-naming-conventions">9.1.8 More naming conventions</a></h4>
<p>The following naming conventions are popular in JavaScript.</p>
<p>If the name of a parameter starts with an underscore (or is an underscore) it means that this parameter is not used – for example:</p>
<pre class="language-js">
arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">_x, i</span>) =&gt;</span> i)
</pre>
<p>If the name of a property of an object starts with an underscore then that property is considered private:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ValueWrapper</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = value;
  }
}
</pre>
<h4 id="where-to-put-semicolons"><a class="heading-id-link" href="#where-to-put-semicolons">9.1.9 Where to put semicolons?</a></h4>
<p>At the end of a statement:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> x = <span class="hljs-number">123</span>;
<span class="hljs-title function_">func</span>();
</pre>
<p>But not if that statement ends with a curly brace:</p>
<pre class="language-js">
<span class="hljs-keyword">while</span> (<span class="hljs-literal">false</span>) {
  <span class="hljs-comment">// ···</span>
} <span class="hljs-comment">// no semicolon</span>
<code/>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-comment">// ···</span></span>
<span class="hljs-params">} <span class="hljs-comment">// no semicolon</span></span>
</pre>
<p>However, adding a semicolon after such a statement is not a syntax error – it is interpreted as an empty statement:</p>
<pre class="language-js">
<span class="hljs-comment">// Function declaration followed by empty statement:</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-comment">// ···</span></span>
<span class="hljs-params">};</span>
</pre>
<h3 id="advanced"><a class="heading-id-link" href="#advanced">9.2 (Advanced)</a></h3>
<p>All remaining sections of this chapter are advanced.</p>
<h3 id="hashbang-lines"><a class="heading-id-link" href="#hashbang-lines">9.3 Hashbang lines (Unix shell scripts)</a></h3>
<p>In a Unix shell script, we can add a first line that starts with <code>#!</code> to tell Unix which executable should be used to run the script. These two characters have several names, including <em>hashbang</em>, <em>sharp-exclamation</em>, <em>sha-bang</em> (“sha” as in “sharp”) and <em>shebang</em>. Otherwise, hashbang lines are treated as comments by most shell scripting languages and JavaScript does so, too. This is a common hashbang line for Node.js:</p>
<pre>
#!/usr/bin/env node
</pre>
<p>If we want to pass arguments to <code>node</code>, we have to use the <code>env</code> option <code>-S</code> (to be safe, some Unixes don’t need it):</p>
<pre>
#!/usr/bin/env -S node --enable-source-maps --no-warnings=ExperimentalWarning
</pre>
<h3 id="identifiers"><a class="heading-id-link" href="#identifiers">9.4 Identifiers</a></h3>
<h4 id="valid-identifiers-variable-names-etc"><a class="heading-id-link" href="#valid-identifiers-variable-names-etc">9.4.1 Valid identifiers (variable names, etc.)</a></h4>
<p>First character:</p>
<ul>
  <li>
    Unicode letter (including accented characters such as <code>é</code> and <code>ü</code> and characters from non-latin alphabets, such as <code>α</code>)
  </li>
  <li>
    <code>$</code>
  </li>
  <li>
    <code>_</code>
  </li>
</ul>
<p>Subsequent characters:</p>
<ul>
  <li>
    Legal first characters
  </li>
  <li>
    Unicode digits (including Eastern Arabic numerals)
  </li>
  <li>
    Some other Unicode marks and punctuations
  </li>
</ul>
<p>Examples:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> ε = <span class="hljs-number">0.0001</span>;
<span class="hljs-keyword">const</span> строка = <span class="hljs-string">''</span>;
<span class="hljs-keyword">let</span> _tmp = <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> $foo2 = <span class="hljs-literal">true</span>;
</pre>
<h4 id="reserved-words"><a class="heading-id-link" href="#reserved-words">9.4.2 Reserved words</a></h4>
<p><span id="index-entry-reserved-word"/></p>
<p>Reserved words can’t be variable names, but they can be property names.</p>
<p>All JavaScript <em>keywords</em> are reserved words: <span id="index-entry-keyword"/></p>
<blockquote>
  <p><code>await</code> <code>break</code> <code>case</code> <code>catch</code> <code>class</code> <code>const</code> <code>continue</code> <code>debugger</code> <code>default</code> <code>delete</code> <code>do</code> <code>else</code> <code>export</code> <code>extends</code> <code>finally</code> <code>for</code> <code>function</code> <code>if</code> <code>import</code> <code>in</code> <code>instanceof</code> <code>let</code> <code>new</code> <code>return</code> <code>static</code> <code>super</code> <code>switch</code> <code>this</code> <code>throw</code> <code>try</code> <code>typeof</code> <code>var</code> <code>void</code> <code>while</code> <code>with</code> <code>yield</code></p>
</blockquote>
<p>The following tokens are also keywords, but currently not used in the language:</p>
<blockquote>
  <p><code>enum</code> <code>implements</code> <code>package</code> <code>protected</code> <code>interface</code> <code>private</code> <code>public</code></p>
</blockquote>
<p>The following literals are reserved words:</p>
<blockquote>
  <p><code>true</code> <code>false</code> <code>null</code></p>
</blockquote>
<p>Technically, these words are not reserved, but you should avoid them, too, because they effectively are keywords:</p>
<blockquote>
  <p><code>Infinity</code> <code>NaN</code> <code>undefined</code> <code>async</code></p>
</blockquote>
<p>You shouldn’t use the names of global variables (<code>String</code>, <code>Math</code>, etc.) for your own variables and parameters, either.</p>
<h3 id="statement-vs-expression"><a class="heading-id-link" href="#statement-vs-expression">9.5 Statement vs. expression</a></h3>
<p>In this section, we explore how JavaScript distinguishes two kinds of syntactic constructs: <em>statements</em> and <em>expressions</em>. Afterward, we’ll see that that can cause problems because the same syntax can mean different things, depending on where it is used.</p>
<div class="boxout">
  <p><img src="../Images/38ba63de820aae6f94a019538ae0f222.png" class="boxout-icon" height="24" alt="Icon “details”" data-original-src="https://exploringjs.com/js/book/icon/details.svg"/> <strong>We pretend there are only statements and expressions</strong></p>
  <div class="boxout-vspace"/>
  <p>For the sake of simplicity, we pretend that there are only statements and expressions in JavaScript.</p>
</div>
<h4 id="statements"><a class="heading-id-link" href="#statements">9.5.1 Statements</a></h4>
<p><span id="index-entry-statement"/></p>
<p>A <em>statement</em> is a piece of code that can be executed and performs some kind of action. For example, <code>if</code> is a statement:</p>
<pre class="language-js">
<span class="hljs-keyword">let</span> myStr;
<span class="hljs-keyword">if</span> (myBool) {
  myStr = <span class="hljs-string">'Yes'</span>;
} <span class="hljs-keyword">else</span> {
  myStr = <span class="hljs-string">'No'</span>;
}
</pre>
<p>One more example of a statement: a function declaration.</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">twice</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-keyword">return</span> x + x;
}
</pre>
<h4 id="expressions"><a class="heading-id-link" href="#expressions">9.5.2 Expressions</a></h4>
<p><span id="index-entry-expression"/><span id="index-entry-evaluating-an-expression"/></p>
<p>An <em>expression</em> is a piece of code that can be <em>evaluated</em> to produce a value. For example, the code between the parentheses is an expression:</p>
<pre class="language-js">
<span class="hljs-keyword">let</span> myStr = (myBool ? <span class="hljs-string">'Yes'</span> : <span class="hljs-string">'No'</span>);
</pre>
<p>The operator <code>_?_:_</code> used between the parentheses is called the <em>ternary operator</em>. It is the expression version of the <code>if</code> statement.</p>
<p>Let’s look at more examples of expressions. We enter expressions and the REPL evaluates them for us:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'ab'</span> + <span class="hljs-string">'cd'</span></span>
'abcd'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>(<span class="hljs-string">'123'</span>)</span>
123
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">true</span> || <span class="hljs-literal">false</span></span>
true
</pre>
<h4 id="what-is-allowed-where"><a class="heading-id-link" href="#what-is-allowed-where">9.5.3 What is allowed where?</a></h4>
<p>The current location within JavaScript source code determines which kind of syntactic constructs you are allowed to use:</p>
<ul>
  <li>
    <p>The body of a function must be a sequence of statements:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">max</span>(<span class="hljs-params">x, y</span>) {
  <span class="hljs-keyword">if</span> (x &gt; y) {
    <span class="hljs-keyword">return</span> x;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> y;
  }
}
</pre>
  </li>
  <li>
    <p>The arguments of a function call or a method call must be expressions:</p>
<pre class="language-js">
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'ab'</span> + <span class="hljs-string">'cd'</span>, <span class="hljs-title class_">Number</span>(<span class="hljs-string">'123'</span>));
</pre>
  </li>
</ul>
<p>However, expressions can be used as statements. Then they are called <em>expression statements</em>. The opposite is not true: when the context requires an expression, you can’t use a statement.</p>
<p>The following code demonstrates that any expression <code>bar()</code> can be either expression or statement – it depends on the context:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">bar</span>()); <span class="hljs-comment">// bar() is expression</span></span>
<span class="hljs-params">  <span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// bar(); is (expression) statement  </span></span>
<span class="hljs-params">}</span>
</pre>
<h3 id="ambiguous-syntax"><a class="heading-id-link" href="#ambiguous-syntax">9.6 Ambiguous syntax</a></h3>
<p>JavaScript has several programming constructs that are syntactically ambiguous: the same syntax is interpreted differently, depending on whether it is used in statement context or in expression context. This section explores the phenomenon and the pitfalls it causes.</p>
<h4 id="same-syntax-function-declaration-and-function-expression"><a class="heading-id-link" href="#same-syntax-function-declaration-and-function-expression">9.6.1 Same syntax: function declaration and function expression</a></h4>
<p>A <em>function declaration</em> is a statement:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">id</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-keyword">return</span> x;
}
</pre>
<p>A <em>function expression</em> is an expression (right-hand side of <code>=</code>):</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> id = <span class="hljs-keyword">function</span> <span class="hljs-title function_">me</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-keyword">return</span> x;
};
</pre>
<h4 id="same-syntax-object-literal-and-block"><a class="heading-id-link" href="#same-syntax-object-literal-and-block">9.6.2 Same syntax: object literal and block</a></h4>
<p>In the following code, <code>{}</code> is an <em>object literal</em>: an expression that creates an empty object.</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> obj = {};
</pre>
<p>This is an empty code block (a statement):</p>
<pre class="language-js">
{
}
</pre>
<h4 id="disambiguation"><a class="heading-id-link" href="#disambiguation">9.6.3 Disambiguation</a></h4>
<p>The ambiguities are only a problem in statement context: If the JavaScript parser encounters ambiguous syntax, it doesn’t know if it’s a plain statement or an expression statement. For example:</p>
<ul>
  <li>
    If a statement starts with <code>function</code>: Is it a function declaration or a function expression?
  </li>
  <li>
    If a statement starts with <code>{</code>: Is it an object literal or a code block?
  </li>
</ul>
<p>To resolve the ambiguity, statements starting with <code>function</code> or <code>{</code> are never interpreted as expressions. If you want an expression statement to start with either one of these tokens, you must wrap it in parentheses:</p>
<pre class="language-js">
(<span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x) })(<span class="hljs-string">'abc'</span>);
</pre>
<p>Output:</p>
<pre>
abc
</pre>
<p>In this code:</p>
<ol>
  <li>
    <p>We first create a function via a function expression:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x) }
</pre>
  </li>
  <li>
    <p>Then we invoke that function: <code>('abc')</code></p>
  </li>
</ol>
<p>The code fragment shown in (1) is only interpreted as an expression because we wrap it in parentheses. If we didn’t, we would get a syntax error because then JavaScript expects a function declaration and complains about the missing function name. Additionally, you can’t put a function call immediately after a function declaration.</p>
<p>Later in this book, we’ll see more examples of pitfalls caused by syntactic ambiguity:</p>
<ul>
  <li>
    <a href="ch_destructuring.html#assigning-via-object-destructuring">Assigning via object destructuring</a>
  </li>
  <li>
    <a href="ch_callables.html#returning-object-literal-from-arrow-function">Returning an object literal from an arrow function</a>
  </li>
</ul>
<h3 id="semicolons"><a class="heading-id-link" href="#semicolons">9.7 Semicolons</a></h3>
<h4 id="rule-of-thumb-for-semicolons"><a class="heading-id-link" href="#rule-of-thumb-for-semicolons">9.7.1 Rule of thumb for semicolons</a></h4>
<p>Each statement is terminated by a semicolon:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> x = <span class="hljs-number">3</span>;
<span class="hljs-title function_">someFunction</span>(<span class="hljs-string">'abc'</span>);
i++;
</pre>
<p>except statements ending with blocks:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-comment">// ···</span></span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-keyword">if</span> (y &gt; <span class="hljs-number">0</span>) {</span>
<span class="hljs-params">  <span class="hljs-comment">// ···</span></span>
<span class="hljs-params">}</span>
</pre>
<p>The following case is slightly tricky:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params">) =&gt; {}; <span class="hljs-comment">// semicolon!</span></span>
</pre>
<p>The whole <code>const</code> declaration (a statement) ends with a semicolon, but inside it, there is an arrow function expression. That is, it’s not the statement per se that ends with a curly brace; it’s the embedded arrow function expression. That’s why there is a semicolon at the end.</p>
<h4 id="semicolons-control-statements"><a class="heading-id-link" href="#semicolons-control-statements">9.7.2 Semicolons: control statements</a></h4>
<p>The body of a control statement is itself a statement. For example, this is the syntax of the <code>while</code> loop:</p>
<pre class="language-js">
<span class="hljs-keyword">while</span> (condition)
  statement
</pre>
<p>The body can be a single statement:</p>
<pre class="language-js">
<span class="hljs-keyword">while</span> (a &gt; <span class="hljs-number">0</span>) a--;
</pre>
<p>But blocks are also statements and therefore legal bodies of control statements:</p>
<pre class="language-js">
<span class="hljs-keyword">while</span> (a &gt; <span class="hljs-number">0</span>) {
  a--;
}
</pre>
<p>If you want a loop to have an empty body, your first option is an empty statement (which is just a semicolon):</p>
<pre class="language-js">
<span class="hljs-keyword">while</span> (<span class="hljs-title function_">processNextItem</span>() &gt; <span class="hljs-number">0</span>);
</pre>
<p>Your second option is an empty block:</p>
<pre class="language-js">
<span class="hljs-keyword">while</span> (<span class="hljs-title function_">processNextItem</span>() &gt; <span class="hljs-number">0</span>) {}
</pre>
<h3 id="automatic-semicolon-insertion-asi"><a class="heading-id-link" href="#automatic-semicolon-insertion-asi">9.8 Automatic semicolon insertion (ASI)</a></h3>
<p><span id="index-entry-ASI--automatic-semicolon-insertion-"/><span id="index-entry-automatic-semicolon-insertion--ASI-"/></p>
<p>While I recommend to always write semicolons, most of them are optional in JavaScript. The mechanism that makes this possible is called <em>automatic semicolon insertion</em> (ASI). In a way, it corrects syntax errors.</p>
<p>ASI works as follows. Parsing of a statement continues until there is either:</p>
<ul>
  <li>
    A semicolon
  </li>
  <li>
    A line terminator followed by an illegal token
  </li>
</ul>
<p>In other words, ASI can be seen as inserting semicolons at line breaks. <span refcheck="#asi-triggered-unexpectedly #asi-unexpectedly-not-triggered">The next subsections</span> cover the pitfalls of ASI.</p>
<h4 id="asi-triggered-unexpectedly"><a class="heading-id-link" href="#asi-triggered-unexpectedly">9.8.1 ASI triggered unexpectedly</a></h4>
<p>The good news about ASI is that – if you don’t rely on it and always write semicolons – there is only one pitfall that you need to be aware of. It is that JavaScript forbids line breaks after some tokens. If you do insert a line break, a semicolon will be inserted, too.</p>
<p>The token where this is most practically relevant is <code>return</code>. Consider, for example, the following code:</p>
<pre class="language-js">
<span class="hljs-keyword">return</span>
{
  <span class="hljs-attr">first</span>: <span class="hljs-string">'jane'</span>
};
</pre>
<p>This code is parsed as:</p>
<pre class="language-js">
<span class="hljs-keyword">return</span>;
{
  <span class="hljs-attr">first</span>: <span class="hljs-string">'jane'</span>;
}
;
</pre>
<p>That is:</p>
<ul>
  <li>
    Return statement without operand: <code>return;</code>
  </li>
  <li>
    Start of code block: <code>{</code>
  </li>
  <li>
    Expression statement <code>'jane';</code> with <a href="ch_control-flow.html#labels">label</a> <code>first:</code>
  </li>
  <li>
    End of code block: <code>}</code>
  </li>
  <li>
    Empty statement: <code>;</code>
  </li>
</ul>
<p>Why does JavaScript do this? It protects against accidentally returning a value in a line after a <code>return</code>.</p>
<h4 id="asi-unexpectedly-not-triggered"><a class="heading-id-link" href="#asi-unexpectedly-not-triggered">9.8.2 ASI unexpectedly not triggered</a></h4>
<p>In some cases, ASI is <em>not</em> triggered when you think it should be. That makes life more complicated for people who don’t like semicolons because they need to be aware of those cases. The following are three examples. There are more.</p>
<p><strong>Example 1:</strong> Unintended function call.</p>
<pre class="language-js">
a = b + c
(d + e).<span class="hljs-title function_">print</span>()
</pre>
<p>Parsed as:</p>
<pre class="language-js">
a = b + <span class="hljs-title function_">c</span>(d + e).<span class="hljs-title function_">print</span>();
</pre>
<p><strong>Example 2:</strong> Unintended division.</p>
<pre class="language-js">
a = b
/hi/g.<span class="hljs-title function_">exec</span>(c).<span class="hljs-title function_">map</span>(d)
</pre>
<p>Parsed as:</p>
<pre class="language-js">
a = b / hi / g.<span class="hljs-title function_">exec</span>(c).<span class="hljs-title function_">map</span>(d);
</pre>
<p><strong>Example 3:</strong> Unintended property access.</p>
<pre class="language-js">
<span class="hljs-title function_">someFunction</span>()
[<span class="hljs-string">'ul'</span>, <span class="hljs-string">'ol'</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + x)
</pre>
<p>Executed as:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> propKey = (<span class="hljs-string">'ul'</span>,<span class="hljs-string">'ol'</span>); <span class="hljs-comment">// comma operator</span>
assert.<span class="hljs-title function_">equal</span>(propKey, <span class="hljs-string">'ol'</span>);
<code/>
<span class="hljs-title function_">someFunction</span>()[propKey].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + x);
</pre>
<h3 id="semicolons-best-practices"><a class="heading-id-link" href="#semicolons-best-practices">9.9 Semicolons: best practices</a></h3>
<p>I recommend that you always write semicolons:</p>
<ul>
  <li>
    I like the visual structure it gives code – you clearly see where a statement ends.
  </li>
  <li>
    There are fewer rules to keep in mind.
  </li>
  <li>
    The majority of JavaScript programmers use semicolons.
  </li>
</ul>
<p>However, there are also many people who don’t like the added visual clutter of semicolons. If you are one of them: Code without them <em>is</em> legal. I recommend that you use tools to help you avoid mistakes. The following are two examples:</p>
<ul>
  <li>
    The automatic code formatter <a href="https://prettier.io">Prettier</a> can be configured to not use semicolons. It then automatically fixes problems. For example, if it encounters a line that starts with a square bracket, it prefixes that line with a semicolon.
  </li>
  <li>
    The static checker <a href="https://eslint.org">ESLint</a> has <a href="https://eslint.org/docs/rules/semi">a rule</a> that you tell your preferred style (always semicolons or as few semicolons as possible) and that warns you about critical issues.
  </li>
</ul>
<h3 id="strict-mode"><a class="heading-id-link" href="#strict-mode">9.10 Strict mode vs. sloppy mode</a></h3>
<p><span id="index-entry-strict-mode"/>
<span id="index-entry-sloppy-mode"/></p>
<p>Starting with ECMAScript 5, JavaScript has two <em>modes</em> in which JavaScript can be executed:</p>
<ul>
  <li>
    Normal “sloppy” mode is the default in scripts (code fragments that are a precursor to modules and supported by browsers).
  </li>
  <li>
    Strict mode is the default in modules and classes, and can be switched on in scripts (how is explained later). In this mode, several pitfalls of normal mode are removed and more exceptions are thrown.
  </li>
</ul>
<p>You’ll rarely encounter sloppy mode in modern JavaScript code, which is almost always located in modules. In this book, I assume that strict mode is always switched on.</p>
<h4 id="switching-on-strict-mode"><a class="heading-id-link" href="#switching-on-strict-mode">9.10.1 Switching on strict mode</a></h4>
<p>In script files and CommonJS modules, you switch on strict mode for a complete file, by putting the following code in the first line:</p>
<pre class="language-js">
<span class="hljs-meta">'use strict'</span>;
</pre>
<p>The neat thing about this “directive” is that ECMAScript versions before 5 simply ignore it: it’s an expression statement that does nothing.</p>
<p>You can also switch on strict mode for just a single function:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">functionInStrictMode</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-string">'use strict'</span>;</span>
<span class="hljs-params">}</span>
</pre>
<h4 id="improvements-in-strict-mode"><a class="heading-id-link" href="#improvements-in-strict-mode">9.10.2 Improvements in strict mode</a></h4>
<p>Let’s look at three things that strict mode does better than sloppy mode. Just in this one section, all code fragments are executed in sloppy mode.</p>
<h5 id="sloppy-mode-pitfall-changing-an-undeclared-variable-creates-a-global-variable"><a class="heading-id-link" href="#sloppy-mode-pitfall-changing-an-undeclared-variable-creates-a-global-variable">9.10.2.1 Sloppy mode pitfall: changing an undeclared variable creates a global variable</a></h5>
<p>In non-strict mode, changing an undeclared variable creates a global variable.</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">sloppyFunc</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  undeclaredVar1 = <span class="hljs-number">123</span>;</span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-title function_">sloppyFunc</span>();</span>
<span class="hljs-params"><span class="hljs-comment">// Created global variable `undeclaredVar1`:</span></span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(undeclaredVar1, <span class="hljs-number">123</span>);</span>
</pre>
<p>Strict mode does it better and throws a <code>ReferenceError</code>. That makes it easier to detect typos.</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">strictFunc</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-string">'use strict'</span>;</span>
<span class="hljs-params">  undeclaredVar2 = <span class="hljs-number">123</span>;</span>
<span class="hljs-params">}</span>
<span class="hljs-params">assert.<span class="hljs-title function_">throws</span>(</span>
<span class="hljs-params">  <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">strictFunc</span>(),</span>
<span class="hljs-params">  {</span>
<span class="hljs-params">    <span class="hljs-attr">name</span>: <span class="hljs-string">'ReferenceError'</span>,</span>
<span class="hljs-params">    <span class="hljs-attr">message</span>: <span class="hljs-string">'undeclaredVar2 is not defined'</span>,</span>
<span class="hljs-params">  });</span>
</pre>
<p>The <code>assert.throws()</code> states that its first argument, a function, throws a <code>ReferenceError</code> when it is called.</p>
<h5 id="function-declarations-are-blockscoped-in-strict-mode-functionscoped-in-sloppy-mode"><a class="heading-id-link" href="#function-declarations-are-blockscoped-in-strict-mode-functionscoped-in-sloppy-mode">9.10.2.2 Function declarations are block-scoped in strict mode, function-scoped in sloppy mode</a></h5>
<p>In strict mode, a variable created via a function declaration only exists within the innermost enclosing block:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">strictFunc</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-string">'use strict'</span>;</span>
<span class="hljs-params">  {</span>
<span class="hljs-params">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"/>) { <span class="hljs-keyword">return</span> <span class="hljs-number">123</span> }</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">  <span class="hljs-keyword">return</span> <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// ReferenceError</span></span>
<span class="hljs-params">}</span>
<span class="hljs-params">assert.<span class="hljs-title function_">throws</span>(</span>
<span class="hljs-params">  <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">strictFunc</span>(),</span>
<span class="hljs-params">  {</span>
<span class="hljs-params">    <span class="hljs-attr">name</span>: <span class="hljs-string">'ReferenceError'</span>,</span>
<span class="hljs-params">    <span class="hljs-attr">message</span>: <span class="hljs-string">'foo is not defined'</span>,</span>
<span class="hljs-params">  });</span>
</pre>
<p>In sloppy mode, function declarations are function-scoped:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">sloppyFunc</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  {</span>
<span class="hljs-params">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"/>) { <span class="hljs-keyword">return</span> <span class="hljs-number">123</span> }</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">  <span class="hljs-keyword">return</span> <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// works</span></span>
<span class="hljs-params">}</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">sloppyFunc</span>(), <span class="hljs-number">123</span>);</span>
</pre>
<h5 id="sloppy-mode-doesnt-throw-exceptions-when-changing-immutable-data"><a class="heading-id-link" href="#sloppy-mode-doesnt-throw-exceptions-when-changing-immutable-data">9.10.2.3 Sloppy mode doesn’t throw exceptions when changing immutable data</a></h5>
<p>In strict mode, you get an exception if you try to change immutable data:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">strictFunc</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-string">'use strict'</span>;</span>
<span class="hljs-params">  <span class="hljs-literal">true</span>.<span class="hljs-property">prop</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// TypeError</span></span>
<span class="hljs-params">}</span>
<span class="hljs-params">assert.<span class="hljs-title function_">throws</span>(</span>
<span class="hljs-params">  <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">strictFunc</span>(),</span>
<span class="hljs-params">  {</span>
<span class="hljs-params">    <span class="hljs-attr">name</span>: <span class="hljs-string">'TypeError'</span>,</span>
<span class="hljs-params">    <span class="hljs-attr">message</span>: <span class="hljs-string">"Cannot create property 'prop' on boolean 'true'"</span>,</span>
<span class="hljs-params">  });</span>
</pre>
<p>In sloppy mode, the assignment fails silently:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">sloppyFunc</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-literal">true</span>.<span class="hljs-property">prop</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// fails silently</span></span>
<span class="hljs-params">  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>.<span class="hljs-property">prop</span>;</span>
<span class="hljs-params">}</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">sloppyFunc</span>(), <span class="hljs-literal">undefined</span>);</span>
</pre>
<div class="boxout">
  <p><img src="../Images/38e6ff55e8d602659f3cdb8893e63f62.png" class="boxout-icon" height="24" alt="Icon “external”" data-original-src="https://exploringjs.com/js/book/icon/external.svg"/> <strong>Further reading: sloppy mode</strong></p>
  <div class="boxout-vspace"/>
  <p>For more information on how sloppy mode differs from strict mode, see <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">MDN</a>.</p>
</div>

    
      
</body>
</html>