- en: 8 The problems of shared mutable state and how to avoid them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/deep-js/ch_shared-mutable-state.html](https://exploringjs.com/deep-js/ch_shared-mutable-state.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 [What is shared mutable state and why is it problematic?](ch_shared-mutable-state.html#what-is-shared-mutable-state-and-why-is-it-problematic)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.2 [Avoiding sharing by copying data](ch_shared-mutable-state.html#avoiding-sharing-by-copying-data)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.2.1 [How does copying help with shared mutable state?](ch_shared-mutable-state.html#how-does-copying-help-with-shared-mutable-state)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.3 [Avoiding mutations by updating non-destructively](ch_shared-mutable-state.html#avoiding-mutations-by-updating-non-destructively)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.3.1 [How does non-destructive updating help with shared mutable state?](ch_shared-mutable-state.html#how-does-non-destructive-updating-help-with-shared-mutable-state)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.4 [Preventing mutations by making data immutable](ch_shared-mutable-state.html#preventing-mutations-by-making-data-immutable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.4.1 [How does immutability help with shared mutable state?](ch_shared-mutable-state.html#how-does-immutability-help-with-shared-mutable-state)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.5 [Libraries for avoiding shared mutable state](ch_shared-mutable-state.html#libraries-for-avoiding-shared-mutable-state)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.5.1 [Immutable.js](ch_shared-mutable-state.html#immutable.js)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.5.2 [Immer](ch_shared-mutable-state.html#immer)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter answers the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is shared mutable state?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is it problematic?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can its problems be avoided?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.1 What is shared mutable state and why is it problematic?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Shared mutable state works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If two or more parties can change the same data (variables, objects, etc.).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And if their lifetimes overlap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then there is a risk of one party’s modifications preventing other parties from
    working correctly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that this definition applies to function calls, cooperative multitasking
    (e.g., async functions in JavaScript), etc. The risks are similar in each case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example. The example is not realistic, but it demonstrates
    the risks and is easy to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, there are two independent parties:'
  prefs: []
  type: TYPE_NORMAL
- en: Function `main()` wants to log an Array before and after sorting it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function `logElements()` logs the elements of its parameter `arr`, but removes
    them while doing so.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logElements()` breaks `main()` and causes it to log an empty Array in line
    A.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the remainder of this chapter, we look at three ways of avoiding the problems
    of shared mutable state:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding sharing by copying data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding mutations by updating non-destructively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing mutations by making data immutable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In particular, we will come back to the example that we’ve just seen and fix
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2 Avoiding sharing by copying data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Copying data is one way of avoiding sharing it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6b17215a2abf7f098e996c026fba60fd.png)  **Background**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For background on copying data in JavaScript, please refer to the following
    two chapters in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[§6 “Copying objects and Arrays”](ch_copying-objects-and-arrays.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[§14 “Copying instances of classes: `.clone()` vs. copy constructors”](ch_copying-class-instances.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.2.1 How does copying help with shared mutable state?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As long as we only *read* from shared state, we don’t have any problems. Before
    *modifying* it, we need to “un-share” it, by copying it (as deeply as necessary).
  prefs: []
  type: TYPE_NORMAL
- en: '*Defensive copying* is a technique to always copy when issues *might* arise.
    Its objective is to keep the current entity (function, class, etc.) safe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input: Copying (potentially) shared data passed to us, lets us use that data
    without being disturbed by an external entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Output: Copying internal data before exposing it to an outside party, means
    that that party can’t disrupt our internal activity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that these measures protect us from other parties, but they also protect
    other parties from us.
  prefs: []
  type: TYPE_NORMAL
- en: The next sections illustrate both kinds of defensive copying.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.1.1 Copying shared input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Remember that in the motivating example at the beginning of this chapter, we
    got into trouble because `logElements()` modified its parameter `arr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add defensive copying to this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `logElements()` doesn’t cause problems anymore, if it is called inside
    `main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 8.2.1.2 Copying exposed internal data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s start with a class `StringBuilder` that doesn’t copy internal data it
    exposes (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as `.getParts()` isn’t used, everything works well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If, however, the result of `.getParts()` is changed (line A), then the `StringBuilder`
    ceases to work correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution is to copy the internal `._data` defensively before it is exposed
    (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now changing the result of `.getParts()` doesn’t interfere with the operation
    of `sb` anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 8.3 Avoiding mutations by updating non-destructively
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can avoid mutations if we only update data non-destructively.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6b17215a2abf7f098e996c026fba60fd.png)  **Background**'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on updating data, see [§7 “Updating data destructively
    and non-destructively”](ch_updating-destructively-and-nondestructively.html).
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.1 How does non-destructive updating help with shared mutable state?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With non-destructive updating, sharing data becomes unproblematic, because we
    never mutate the shared data. (This only works if everyone that accesses the data
    does that!)
  prefs: []
  type: TYPE_NORMAL
- en: 'Intriguingly, copying data becomes trivially simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This works, because we are only making non-destructive changes and are therefore
    copying the data on demand.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 Preventing mutations by making data immutable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can prevent mutations of shared data by making that data immutable.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6b17215a2abf7f098e996c026fba60fd.png)  **Background**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For background on how to make data immutable in JavaScript, please refer to
    the following two chapters in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[§10 “Protecting objects from being changed”](ch_protecting-objects.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[§15 “Immutable wrappers for collections”](ch_immutable-collection-wrappers.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.4.1 How does immutability help with shared mutable state?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If data is immutable, it can be shared without any risks. In particular, there
    is no need to copy defensively.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c17f3239b9e1f5d335bb0adf8211d9d3.png)  **Non-destructive updating
    is an important complement to immutable data**'
  prefs: []
  type: TYPE_NORMAL
- en: If we combine the two, immutable data becomes virtually as versatile as mutable
    data but without the associated risks.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 Libraries for avoiding shared mutable state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several libraries available for JavaScript that support immutable
    data with non-destructive updating. Two popular ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Immutable.js](https://github.com/immutable-js/immutable-js) provides immutable
    data structures for lists, stacks, sets, maps, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Immer](https://immerjs.github.io/immer/) also supports immutability and non-destructive
    updating but for plain objects, Arrays, Sets, and Maps. That is, no new data structures
    are needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These libraries are described in more detail in the next two sections.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.1 Immutable.js
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In its repository, [the library Immutable.js](https://github.com/immutable-js/immutable-js)
    is described as:'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable persistent data collections for JavaScript which increase efficiency
    and simplicity.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Immutable.js provides immutable data structures such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`List`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stack`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set` (which is different from JavaScript’s built-in `Set`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map` (which is different from JavaScript’s built-in `Map`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, we use an immutable `Map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Notes:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of modifying the receiver, “destructive” operations such as `.set()`
    return modified copies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To check if two data structures have the same content, we use the built-in `.equals()`
    method (line A and line B).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.5.2 Immer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In its repository, [the library Immer](https://immerjs.github.io/immer/) is
    described as:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the next immutable state by mutating the current one.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Immer helps with non-destructively updating (potentially nested) plain objects,
    Arrays, Sets, and Maps. That is, there are no custom data structures involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what using Immer looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The original data is stored in `people`. `produce()` provides us with a variable
    `draft`. We pretend that this variable is `people` and use operations with which
    we would normally make destructive changes. Immer intercepts these operations.
    Instead of mutating `draft`, it non-destructively changes `people`. The result
    is referenced by `modifiedPeople`. As a bonus, it is deeply immutable.
  prefs: []
  type: TYPE_NORMAL
- en: '`assert.deepEqual()` works because Immer returns plain objects and Arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/deep-js/issues/8)'
  prefs: []
  type: TYPE_NORMAL
