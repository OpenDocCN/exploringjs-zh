<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>9 Publishing npm packages with TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>9 Publishing npm packages with TypeScript</h1>
<blockquote>原文：<a href="https://exploringjs.com/ts/book/ch_typescript-npm-packages.html">https://exploringjs.com/ts/book/ch_typescript-npm-packages.html</a></blockquote>

    
        <div id="adbox">
      <div id="adbox-explain">(Ad, please don’t block.)</div>
              
          </div>
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#file-system-layout">9.1 File system layout</a>
      <ol>
        <li>
          <a href="#gitignore">9.1.1 <code>.gitignore</code></a>
        </li>
        <li>
          <a href="#unit-tests">9.1.2 Unit tests</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#tsconfig.json">9.2 <code>tsconfig.json</code></a>
      <ol>
        <li>
          <a href="#where-does-the-output-go">9.2.1 Where does the output go?</a>
        </li>
        <li>
          <a href="#output">9.2.2 Output</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#package.json">9.3 <code>package.json</code></a>
      <ol>
        <li>
          <a href="#using-js-for-esm-modules">9.3.1 Using <code>.js</code> for ESM modules</a>
        </li>
        <li>
          <a href="#which-files-should-be-uploaded-to-the-npm-registry">9.3.2 Which files should be uploaded to the npm registry?</a>
        </li>
        <li>
          <a href="#package-exports">9.3.3 Package exports</a>
        </li>
        <li>
          <a href="#package-imports">9.3.4 Package imports</a>
        </li>
        <li>
          <a href="#package-scripts">9.3.5 Package scripts</a>
        </li>
        <li>
          <a href="#development-dependencies">9.3.6 Development dependencies</a>
        </li>
        <li>
          <a href="#bin-scripts">9.3.7 Bin scripts: shell commands written in JavaScript</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#linting-npm-packages">9.4 Linting npm packages</a>
    </li>
    <li>
      <a href="#further-reading-3">9.5 Further reading</a>
    </li>
  </ol>
</nav>
<p>In this chapter, we’ll create an ESM-based library package for npm via TypeScript:</p>
<ul>
  <li>
    The described setup has worked well for me since TypeScript 4.7 (2022-05-24).
  </li>
  <li>
    We’ll only use tsc, but the setup is ready for other tools. For more information, see <a href="ch_tsconfig-json.html#compiling-without-tsc">“Compiling TypeScript with tools other than tsc” (§8.8)</a>.
  </li>
  <li>
    If you want to create a package with an executable and not a library, check out <a href="#bin-scripts">“Bin scripts: shell commands written in JavaScript” (§9.3.7)</a>.
  </li>
</ul>
<div class="boxout">
  <p><img src="../Images/25fa4b537bb7b3fd4dddaa93103f1bda.png" height="24" class="boxout-icon" alt="Icon “GitHub”" data-original-src="https://exploringjs.com/ts/book/icon/github.svg"/> <strong>Example package:</strong> <a href="https://github.com/rauschma/helpers"><code>@rauschma/helpers</code></a></p>
  <div class="boxout-vspace"/>
  <p>This package uses the setup described in this chapter.</p>
</div>
<h3 id="file-system-layout"><a class="heading-id-link" href="#file-system-layout">9.1 File system layout</a></h3>
<p>Our npm package has the following file system layout:</p>
<pre>
<code>my-package/</code>
<code>  README.md</code>
<code>  LICENSE</code>
<code>  package.json</code>
<code>  tsconfig.json</code>
<code>  docs/</code>
<code>    api/</code>
<code>  src/</code>
<code>    test/</code>
<code>  dist/</code>
<code>    test/</code>
</pre>
<p>Comments:</p>
<ul>
  <li>
    It’s usually a good idea to include a <code>README.md</code> and a <code>LICENSE</code>
  </li>
  <li>
    <code>package.json</code> describes the package and is described <a href="#package.json">later</a>.
  </li>
  <li>
    <code>tsconfig.json</code> configures TypeScript and is described <a href="#tsconfig.json">later</a>.
  </li>
  <li>
    <code>docs/api/</code> is for API documentation generated via TypeDoc. See <a href="ch_jsdoc.html#ch_jsdoc">“Documenting TypeScript APIs via doc comments and TypeDoc” (§11)</a>.
  </li>
  <li>
    <code>src/</code> is for the TypeScript source code.
  </li>
  <li>
    <code>src/test/</code> is for integration tests – tests that span multiple modules. More on unit tests soon.
    <ul>
      <li>
        Why don’t we put <code>src/</code> and <code>test/</code> next to each other? That would have the negative consequence that output files would be more deeply nested in the project directory than input files (<a href="ch_tsconfig-json.html#src-test-siblings">more information</a>).
      </li>
    </ul>
  </li>
  <li>
    <code>dist/</code> is where TypeScript writes its output.
  </li>
</ul>
<h4 id="gitignore"><a class="heading-id-link" href="#gitignore">9.1.1 <code>.gitignore</code></a></h4>
<p>I’m using Git for version control. This is my <code>.gitignore</code> (located inside <code>my-package/</code>)</p>
<pre>
<code>node_modules</code>
<code>dist</code>
<code>.DS_Store</code>
</pre>
<p>Why these entries?</p>
<ul>
  <li>
    <code>node_modules</code>: The most common practice currently seems to be <em>not</em> to check in the <code>node_modules</code> directory.
  </li>
  <li>
    <code>dist</code>: The compilation output of TypeScript is not checked into Git, but it is uploaded to the npm registry. More on that later.
  </li>
  <li>
    <code>.DS_Store</code>: This entry is about me being lazy as a macOS user. Since it’s only need on that operating system, you can argue that Mac people should add it via a global configuration setting and keep it out of project-specific gitignores.
  </li>
</ul>
<h4 id="unit-tests"><a class="heading-id-link" href="#unit-tests">9.1.2 Unit tests</a></h4>
<p>I have started to put the unit tests for a particular module next to that module:</p>
<pre>
<code>src/</code>
<code>  util.ts</code>
<code>  util_test.ts</code>
</pre>
<p>Given that unit tests help with understanding how a module works, it’s useful if they are easy to find.</p>
<h5 id="self-referencing-exports"><a class="heading-id-link" href="#self-referencing-exports">9.1.2.1 Tip for tests: self-reference the package</a></h5>
<p>If an npm package has <code>"exports"</code>, it can <em>self-reference</em> them via its package name:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// src/misc/errors.ts</span></code>
<code><span class="hljs-keyword">import</span> {helperFunc} <span class="hljs-keyword">from</span> <span class="hljs-string">'my-package/misc/errors.js'</span>;</code>
</pre>
<p>The Node.js documentation has <a href="https://nodejs.org/api/packages.html#self-referencing-a-package-using-its-name">more information</a> on self-referencing and notes: “Self-referencing is available only if <code>package.json</code> has <code>"exports"</code>, and will allow importing only what that <code>"exports"</code> (in the <code>package.json</code>) allows.”</p>
<p>Benefits of self-referencing:</p>
<ul>
  <li>
    It is useful for tests (which can demonstrate how importing packages would use the code).
  </li>
  <li>
    It checks if your package exports are set up properly.
  </li>
</ul>
<h3 id="tsconfig.json"><a class="heading-id-link" href="#tsconfig.json">9.2 <code>tsconfig.json</code></a></h3>
<p><a href="ch_tsconfig-json.html#tsconfig-summary">“Summary: Assemble your <code>tsconfig.json</code> by answering four questions” (§8.12)</a> helps us with creating a <code>tsconfig.json</code> file by asking us four questions. Let’s answer these questions for our npm package:</p>
<ul>
  <li>
    <p>Q: Do you want to transpile new JavaScript to older JavaScript?</p>
    <ul>
      <li>
        A: No. If we can constrain ourselves to JavaScript features supported by our target platforms then the output is simpler and more similar to the input.
      </li>
    </ul>
  </li>
  <li>
    <p>Q: Should TypeScript only allow JavaScript features at the non-type level?</p>
    <ul>
      <li>
        A: Yes because that keeps things simple and lets us use <a href="ch_tsconfig-json.html#type-stripping">type stripping</a> should we want to. It’s a forward-looking way of writing TypeScript.
      </li>
    </ul>
  </li>
  <li>
    <p>Q: Which filename extension do you want to use in local imports?</p>
    <ul>
      <li>
        A: ESM requires filename extensions and TypeScript traditionally does not change module specifiers during transpilation. Therefore, TypeScript ESM code initially used <code>.js</code>. Now TypeScript transpilation can change <code>.ts</code> to <code>.js</code>. Therefore, we can use <code>.ts</code> – with the benefit that the same code also runs without transpilation on some platforms (Node.js, Deno, Bun, etc.). The only caveat is that we still have to use <code>.js</code> when we self-reference modules (see previous section) or use <code>import()</code>.
      </li>
    </ul>
  </li>
  <li>
    <p>Q: What files should tsc emit? </p>
    <ul>
      <li>
        A: <code>.js</code>, <code>.js.map</code>, <code>.d.ts</code>, <code>.d.ts.map</code> (more information on that soon)
      </li>
    </ul>
  </li>
</ul>
<h4 id="where-does-the-output-go"><a class="heading-id-link" href="#where-does-the-output-go">9.2.1 Where does the output go?</a></h4>
<p><code>tsconfig.json</code>:</p>
<pre class="language-json">
<code><span class="hljs-punctuation">{</span></code>
<code>  <span class="hljs-attr">"include"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"src/**/*"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>    <span class="hljs-attr">"rootDir"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"src"</span><span class="hljs-punctuation">,</span></code>
<code>    <span class="hljs-attr">"outDir"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"dist"</span><span class="hljs-punctuation">,</span></code>
<code>    <span class="hljs-comment">// ···</span></code>
<code>  <span class="hljs-punctuation">}</span></code>
<code><span class="hljs-punctuation">}</span></code>
</pre>
<p>Consequences of these settings:</p>
<ul>
  <li>
    Input: <code>src/util.ts</code>
    <ul>
      <li>
        Output: <code>dist/util.js</code>
      </li>
    </ul>
  </li>
  <li>
    Input: <code>src/test/integration_test.ts</code>
    <ul>
      <li>
        Output: <code>dist/test/integration_test.js</code>
      </li>
    </ul>
  </li>
</ul>
<p>What if we want <code>src/</code> and <code>test/</code> to sit next to each other? See <a href="ch_tsconfig-json.html#src-test-siblings">“Putting <code>src/</code> and <code>test/</code> next to each other” (§8.4.1.1)</a> for more information.</p>
<h4 id="output"><a class="heading-id-link" href="#output">9.2.2 Output</a></h4>
<p>Given a TypeScript file <code>util.ts</code>, tsc writes the following output to <code>dist/</code>:</p>
<pre>
<code>src/</code>
<code>  util.ts</code>
<code>dist/</code>
<code>  util.js</code>
<code>  util.js.map</code>
<code>  util.d.ts</code>
<code>  util.d.ts.map</code>
</pre>
<p>Purposes of these files:</p>
<ul>
  <li>
    <p><code>util.js</code>: JavaScript code contained in <code>util.ts</code></p>
  </li>
  <li>
    <p><code>util.js.map</code>: <em>source map</em> for the JavaScript code. It enables the following functionality when running <code>util.js</code>:</p>
    <ul>
      <li>
        In a debugger, we see the TypeScript code.
      </li>
      <li>
        Stack traces contain TypeScript source code locations.
      </li>
    </ul>
  </li>
  <li>
    <p><code>util.d.ts</code>: types defined in <code>util.ts</code></p>
  </li>
  <li>
    <p><code>util.d.ts.map</code>: <em>declaration map</em> – a source map for <code>util.d.ts</code>. It enables TypeScript editors that support it to (e.g.) jump to the TypeScript source code of the definition of a type. I find that useful for libraries. It’s why I include the TypeScript source in their packages.</p>
  </li>
</ul>
<h3 id="package.json"><a class="heading-id-link" href="#package.json">9.3 <code>package.json</code></a></h3>
<p>Some settings in <code>package.json</code> also affect TypeScript. We’ll look at those next. Related material:</p>
<ul>
  <li>
    <p>Chapter <a href="https://exploringjs.com/nodejs-shell-scripting/ch_packages.html">“Packages: JavaScript’s units for software distribution”</a> of “Shell scripting with Node.js” provides a comprehensive look at npm packages.</p>
  </li>
  <li>
    <p>You can also take a look the the <a href="https://github.com/rauschma/helpers/blob/main/package.json"><code>package.json</code></a> of <code>@rauschma/helpers</code>.</p>
  </li>
</ul>
<h4 id="using-js-for-esm-modules"><a class="heading-id-link" href="#using-js-for-esm-modules">9.3.1 Using <code>.js</code> for ESM modules</a></h4>
<p>By default, <code>.js</code> files are interpreted as CommonJS modules. The following setting lets us use that filename extension for ESM modules:</p>
<pre class="language-json">
<code><span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"module"</span><span class="hljs-punctuation">,</span></code>
</pre>
<h4 id="which-files-should-be-uploaded-to-the-npm-registry"><a class="heading-id-link" href="#which-files-should-be-uploaded-to-the-npm-registry">9.3.2 Which files should be uploaded to the npm registry?</a></h4>
<p>We have to specify which files should be uploaded to the npm registry. While there is also the <code>.npmignore</code> file, explicitly listing what’s <em>included</em> is safer. That is done via the <code>package.json</code> property <code>"files"</code>:</p>
<pre class="language-json">
<code><span class="hljs-attr">"files"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span></code>
<code>  <span class="hljs-string">"package.json"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-string">"README.md"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-string">"LICENSE"</span><span class="hljs-punctuation">,</span></code>
<code/>
<code>  <span class="hljs-string">"src/**/*.ts"</span><span class="hljs-punctuation">,</span></code>
<code/>
<code>  <span class="hljs-string">"dist/**/*.js"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-string">"dist/**/*.js.map"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-string">"dist/**/*.d.ts"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-string">"dist/**/*.d.ts.map"</span><span class="hljs-punctuation">,</span></code>
<code/>
<code>  <span class="hljs-string">"!src/test/"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-string">"!src/**/*_test.ts"</span><span class="hljs-punctuation">,</span></code>
<code/>
<code>  <span class="hljs-string">"!dist/test/"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-string">"!dist/**/*_test.js"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-string">"!dist/**/*_test.js.map"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-string">"!dist/**/*_test.d.ts"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-string">"!dist/**/*_test.d.ts.map"</span></code>
<code><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span></code>
</pre>
<p>In <code>.gitignore</code>, we have ignored directory <code>dist/</code> because it contains information that can be generated automatically. However, here it is explicitly included because most of its contents have to be in the npm package.</p>
<p>Patterns that start with exclamation marks (<code>!</code>) define which files to exclude. In this case, we exclude the tests:</p>
<ul>
  <li>
    Some of them sit next to modules in <code>src/</code>.
  </li>
  <li>
    The remaining tests are located in <code>src/test/</code>.
  </li>
</ul>
<h4 id="package-exports"><a class="heading-id-link" href="#package-exports">9.3.3 Package exports</a></h4>
<p>If we want a package to support old code, there are several <code>package.json</code> properties, we have to take into consideration:</p>
<ul>
  <li>
    <code>"main"</code>: previously used by Node.js
  </li>
  <li>
    <code>"module"</code>: previously used by bundlers
  </li>
  <li>
    <code>"types"</code>: previously used by TypeScript
  </li>
  <li>
    <code>"typesVersions"</code>: previously used by TypeScript
  </li>
</ul>
<p>In contrast, for modern code, we only need:</p>
<pre class="language-json">
<code><span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>  <span class="hljs-comment">// Package exports go here</span></code>
<code><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span></code>
</pre>
<p>Before we get into details, there are two questions we have to consider:</p>
<ul>
  <li>
    <p>Is our package only going to be imported via a bare import or is it going to support subpath imports?</p>
<pre class="language-ts">
<code><span class="hljs-keyword">import</span> {someFunc} <span class="hljs-keyword">from</span> <span class="hljs-string">'my-package'</span>; <span class="hljs-comment">// bare import</span></code>
<code><span class="hljs-keyword">import</span> {someFunc} <span class="hljs-keyword">from</span> <span class="hljs-string">'my-package/sub/path'</span>; <span class="hljs-comment">// subpath import</span></code>
</pre>
  </li>
  <li>
    <p>If we export subpaths: Are they going to have filename extensions or not?</p>
  </li>
</ul>
<p>Tips for answering the latter question:</p>
<ul>
  <li>
    <p>The extensionless style has a long tradition. That hasn’t changed much with ESM, even though it requires filename extensions for local imports.</p>
  </li>
  <li>
    <p>Downside of the extensionless style (quoting <a href="https://nodejs.org/api/packages.html#extensions-in-subpaths">the Node.js documentation</a>): “With import maps now providing a standard for package resolution in browsers and other JavaScript runtimes, using the extensionless style can result in bloated import map definitions. Explicit file extensions can avoid this issue by enabling the import map to utilize a packages folder mapping to map multiple subpaths where possible instead of a separate map entry per package subpath export. This also mirrors the requirement of using the full specifier path in relative and absolute import specifiers.”</p>
  </li>
</ul>
<p>This is how I currently decide:</p>
<ul>
  <li>
    Most of my packages don’t have any subpaths at all.
  </li>
  <li>
    If the package is a collection of modules, I export them with extensions.
  </li>
  <li>
    If the modules are more like different versions of the package (think synchronous vs. asynchronous) then I export them without extensions.
  </li>
</ul>
<p>However, I don’t have strong preferences and may change my mind in the future.</p>
<h5 id="specifying-package-exports"><a class="heading-id-link" href="#specifying-package-exports">9.3.3.1 Specifying package exports</a></h5>
<pre class="language-js">
<code><span class="hljs-comment">// Bare export</span></code>
<code><span class="hljs-string">"."</span>: <span class="hljs-string">"./dist/main.js"</span>,</code>
<code/>
<code><span class="hljs-comment">// Subpaths with extensions</span></code>
<code><span class="hljs-string">"./misc/errors.js"</span>: <span class="hljs-string">"./dist/misc/errors.js"</span>, <span class="hljs-comment">// single file</span></code>
<code><span class="hljs-string">"./misc/*"</span>: <span class="hljs-string">"./dist/misc/*"</span>, <span class="hljs-comment">// subtree</span></code>
<code/>
<code><span class="hljs-comment">// Extensionless subpaths</span></code>
<code><span class="hljs-string">"./misc/errors"</span>: <span class="hljs-string">"./dist/misc/errors.js"</span>, <span class="hljs-comment">// single file</span></code>
<code><span class="hljs-string">"./misc/*"</span>: <span class="hljs-string">"./dist/misc/*.js"</span>, <span class="hljs-comment">// subtree</span></code>
</pre>
<p>Notes:</p>
<ul>
  <li>
    If there aren’t many modules then multiple single-file entries are more self-explanatory than one subtree entry.
  </li>
  <li>
    By default, <code>.d.ts</code> files must sit next to <code>.js</code> files. But that can be changed via <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#packagejson-exports-imports-and-self-referencing">the <code>types</code> import condition</a>.
  </li>
</ul>
<p>For more information on this topic, see section <a href="https://exploringjs.com/nodejs-shell-scripting/ch_packages.html#package-exports-controlling-what-other-packages-see">“Package exports: controlling what other packages see”</a> in “Exploring JavaScript”.</p>
<h4 id="package-imports"><a class="heading-id-link" href="#package-imports">9.3.4 Package imports</a></h4>
<p>Node’s package imports are also supported by TypeScript. They let us define aliases for paths. Those aliases have the benefit that they start at the top level of the package. This is an example:</p>
<pre class="language-json">
<code><span class="hljs-attr">"imports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>  <span class="hljs-attr">"#root/*"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./*"</span></code>
<code><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span></code>
</pre>
<p>We can use this package import as follows:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">import</span> pkg <span class="hljs-keyword">from</span> <span class="hljs-string">'#root/package.json'</span> <span class="hljs-keyword">with</span> { <span class="hljs-attr">type</span>: <span class="hljs-string">'json'</span> };</code>
<code><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pkg.<span class="hljs-property">version</span>);</code>
</pre>
<p>Package imports are especially helpful when the JavaScript output files are more deeply nested than the TypeScript input files. In that case we can’t use relative paths to access files at the top level.</p>
<p>For more information on package imports, see <a href="https://nodejs.org/api/packages.html#imports">the Node.js documentation</a>.</p>
<h4 id="package-scripts"><a class="heading-id-link" href="#package-scripts">9.3.5 Package scripts</a></h4>
<p><a href="https://docs.npmjs.com/cli/v11/using-npm/scripts">Package scripts</a> lets us define aliases such as <code>build</code> for shell commands and execute them via <code>npm run build</code>. We can get a list of those aliases via <code>npm run</code> (without a script name).</p>
<p>These are commands I find useful for my library projects:</p>
<pre class="language-json">
<code><span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>  <span class="hljs-attr">"\n========== Building =========="</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"npm run clean &amp;&amp; tsc"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"watch"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"tsc --watch"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"clean"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"shx rm -rf ./dist/*"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"\n========== Testing =========="</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"test"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"mocha --enable-source-maps --ui qunit"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"testall"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"mocha --enable-source-maps --ui qunit \"./dist/**/*_test.js\""</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"\n========== Publishing =========="</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"publishd"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"npm publish --dry-run"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"prepublishOnly"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"npm run build"</span></code>
<code><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span></code>
</pre>
<p>Explanations:</p>
<ul>
  <li>
    <code>build</code>: I clear directory <code>dist/</code> before each build. Why? When renaming TypeScript files, the old output files are not deleted. That is especially problematic with test files and regularly bites me. Whenever that happens, I can fix things via <code>npm run build</code>.
  </li>
  <li>
    <code>test</code>, <code>testall</code>:
    <ul>
      <li>
        <code>--enable-source-maps</code> enables source map support in Node.js and therefore accurate line numbers in stack traces.
      </li>
      <li>
        The test runner <a href="https://mochajs.org">Mocha</a> supports several testing styles. I prefer <code>--ui qunit</code> (<a href="https://github.com/rauschma/helpers/blob/main/src/string/string_test.ts">example</a>).
      </li>
    </ul>
  </li>
  <li>
    <code>publishd</code>: We publish an npm package via <code>npm publish</code>. <code>npm run publishd</code> invokes the “dry run” version of that command that doesn’t make any changes but provides helpful feedback – e.g., it shows which files are going to be part of the package.
  </li>
  <li>
    <code>prepublishOnly</code>: Before <code>npm publish</code> uploads files to the npm registry, it invokes this script. By building before publishing, we ensure that no stale files and no old files are uploaded.
  </li>
</ul>
<p>Why the named separators? The make the output of <code>npm run</code> easier to read.</p>
<h4 id="development-dependencies"><a class="heading-id-link" href="#development-dependencies">9.3.6 Development dependencies</a></h4>
<p>Even if a package of mine has no normal dependencies, it tends to have the following development dependencies:</p>
<pre class="language-json">
<code><span class="hljs-attr">"devDependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>  <span class="hljs-attr">"@types/mocha"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^10.0.6"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"@types/node"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^20.12.12"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"mocha"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^10.4.0"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"shx"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^0.3.4"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"typedoc"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^0.27.6"</span></code>
<code><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span></code>
</pre>
<p>Explanations:</p>
<ul>
  <li>
    <p><code>@types/node</code>: In unit tests, I’m using <code>node:assert</code> for assertions such as <code>assert.deepEqual()</code>. This dependency provides types for that and other Node modules.</p>
  </li>
  <li>
    <p><code>shx</code>: provides cross-platform versions of Unix shell commands. I’m often using:</p>
<pre>
<code>shx rm -rf</code>
<code>shx chmod u+x</code>
</pre>
  </li>
</ul>
<p>I also install the following two command line tools locally inside my projects so that they are guaranteed to be there. The neat thing about <code>npm run</code> is that it adds locally installed commands to the shell path – which means that they can be used in package scripts as if they were installed globally.</p>
<ul>
  <li>
    <code>mocha</code> and <code>@types/mocha</code>: I still prefer <a href="https://mochajs.org">Mocha</a>’s API and CLI user experience but <a href="https://nodejs.org/api/test.html">Node’s built-in test runner</a> has become an interesting alternative.
  </li>
  <li>
    <code>typedoc</code>: I’m using <a href="ch_jsdoc.html#ch_jsdoc">TypeDoc</a> to generate API documentation.
  </li>
</ul>
<h4 id="bin-scripts"><a class="heading-id-link" href="#bin-scripts">9.3.7 Bin scripts: shell commands written in JavaScript</a></h4>
<p>A <code>package.json</code> can contain the property <code>"bin"</code> which sets up executables. Check out my project <a href="https://github.com/rauschma/tsconfigurator">TSConfigurator</a> for a full example. That project has the following property in <code>package.json</code>:</p>
<pre class="language-json">
<code><span class="hljs-attr">"bin"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>  <span class="hljs-attr">"tsconfigurator"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./dist/tsconfigurator.js"</span></code>
<code><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span></code>
</pre>
<p>We can constrain the Node.js versions with which the bin scripts can be used:</p>
<pre class="language-json">
<code><span class="hljs-attr">"engines"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>  <span class="hljs-attr">"node"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"&gt;=23.6.0"</span></code>
<code><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span></code>
</pre>
<p>The following package script is useful (invoked from <code>"build"</code>, after <code>"tsc"</code>):</p>
<pre class="language-json">
<code><span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>  ···</code>
<code>  <span class="hljs-attr">"chmod"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"shx chmod u+x ./dist/tsconfigurator.js"</span></code>
<code><span class="hljs-punctuation">}</span></code>
</pre>
<p>If a package provides an executable and not a library, we don’t need to emit <code>.d.ts</code> files. If we use type stripping for <code>.js</code>, we may not need <code>.js.map</code> files either.</p>
<h3 id="linting-npm-packages"><a class="heading-id-link" href="#linting-npm-packages">9.4 Linting npm packages</a></h3>
<p>Linting the public interfaces of packages:</p>
<ul>
  <li>
    <a href="https://publint.dev">publint</a>: “Lints npm packages to ensure the widest compatibility across environments, such as Vite, Webpack, Rollup, Node.js, etc.”
  </li>
  <li>
    <a href="https://github.com/arethetypeswrong/arethetypeswrong.github.io">arethetypeswrong</a>: “This project attempts to analyze npm package contents for issues with their TypeScript types, particularly ESM-related module resolution issues.”
  </li>
  <li>
    <a href="https://npmpackagejsonlint.org">npm-package-json-lint</a>: “Configurable linter for <code>package.json</code> files”
  </li>
  <li>
    <a href="https://github.com/antfu/vitest-package-exports">vitest-package-exports</a>: “[…] get all exported APIs of a package and prevent unintended breaking changes”. Despite its name, this tool <a href="https://github.com/antfu/vitest-package-exports?tab=readme-ov-file#does-this-requires-vitest">does not require Vitest</a>.
  </li>
</ul>
<p>Linting npm packages internally:</p>
<ul>
  <li>
    <a href="https://github.com/voxpelli/node-installed-check">installed-check</a>: “Verifies that installed modules comply with the requirements [the Node.js <a href="https://docs.npmjs.com/cli/v11/configuring-npm/package-json#engines"><code>"engines"</code></a> version range] specified in <code>package.json</code>.”
  </li>
  <li>
    <a href="https://knip.dev">Knip</a>: “Finds and fixes unused files, dependencies and exports.” Supports JavaScript and TypeScript.
  </li>
  <li>
    <a href="https://github.com/antfu/node-modules-inspector">Node Modules Inspector</a>: “Visualize your <code>node_modules</code>, inspect dependencies, and more.”
  </li>
  <li>
    <a href="https://www.npmjs.com/package/madge">Madge</a>: create a visual graph of module dependencies, find circular dependencies, and more.
  </li>
</ul>
<h3 id="further-reading-3"><a class="heading-id-link" href="#further-reading-3">9.5 Further reading</a></h3>
<ul>
  <li>
    JavaScript modules (ESM): Chapter <a href="https://exploringjs.com/js/book/ch_modules.html">“Modules”</a> in “Exploring JavaScript”
  </li>
  <li>
    npm packages: Chapter <a href="https://exploringjs.com/nodejs-shell-scripting/ch_packages.html">“Packages: JavaScript’s units for software distribution”</a> in “Shell scripting with Node.js”
  </li>
</ul>
<p>Also useful:</p>
<ul>
  <li>
    Chapter <a href="https://nodejs.org/api/packages.html">“Modules: Packages”</a> of the Node.js documentation
  </li>
  <li>
    Section <a href="https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-exports">“<code>package.json "exports"</code>”</a> of the TypeScript Handbook
  </li>
</ul>

    
      
</body>
</html>