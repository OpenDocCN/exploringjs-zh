["```js\n> const wm = new WeakMap();\n> wm.set(123, 'test')\nTypeError: Invalid value used as weak map key\n```", "```js\nconst wm = new WeakMap();\n{\n const obj = {};\n wm.set(obj, 'attachedValue'); // (A)\n}\n// (B)\n```", "```js\n{\n const obj = {};\n obj.wm = 'attachedValue';\n}\n```", "```js\nconst cache = new WeakMap();\nfunction countOwnKeys(obj) {\n if (cache.has(obj)) {\n return [cache.get(obj), 'cached'];\n } else {\n const count = Object.keys(obj).length;\n cache.set(obj, count);\n return [count, 'computed'];\n }\n}\n```", "```js\n> const obj = { foo: 1, bar: 2};\n> countOwnKeys(obj)\n[2, 'computed']\n> countOwnKeys(obj)\n[2, 'cached']\n```", "```js\nconst _counter = new WeakMap();\nconst _action = new WeakMap();\n\nclass Countdown {\n constructor(counter, action) {\n _counter.set(this, counter);\n _action.set(this, action);\n }\n dec() {\n let counter = _counter.get(this);\n counter--;\n _counter.set(this, counter);\n if (counter === 0) {\n _action.get(this)();\n }\n }\n}\n\n// The two pseudo-properties are truly private:\nassert.deepEqual(\n Object.keys(new Countdown()),\n []);\n```", "```js\nlet invoked = false;\n\nconst cd = new Countdown(3, () => invoked = true);\n\ncd.dec(); assert.equal(invoked, false);\ncd.dec(); assert.equal(invoked, false);\ncd.dec(); assert.equal(invoked, true);\n```"]