- en: '12 TypeScript enums: How do they work? What can they be used for?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/tackling-ts/ch_enums.html](https://exploringjs.com/tackling-ts/ch_enums.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 12.1 [The basics](ch_enums.html#the-basics)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.1.1 [Numeric enums](ch_enums.html#numeric-enums)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.1.2 [String-based enums](ch_enums.html#string-based-enums)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.1.3 [Heterogeneous enums](ch_enums.html#heterogeneous-enums)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.1.4 [Omitting initializers](ch_enums.html#omitting-initializers)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.1.5 [Casing of enum member names](ch_enums.html#casing-of-enum-member-names)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.1.6 [Quoting enum member names](ch_enums.html#quoting-enum-member-names)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.2 [Specifying enum member values (advanced)](ch_enums.html#specifying-enum-member-values-advanced)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.2.1 [Literal enum members](ch_enums.html#literal-enum-members)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.2.2 [Constant enum members](ch_enums.html#constant-enum-members)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.2.3 [Computed enum members](ch_enums.html#computed-enum-members)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.3 [Downsides of numeric enums](ch_enums.html#downsides-of-numeric-enums)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '12.3.1 [Downside: logging](ch_enums.html#downside-logging)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '12.3.2 [Downside: loose type-checking](ch_enums.html#downside-loose-type-checking)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '12.3.3 [Recommendation: prefer string-based enums](ch_enums.html#recommendation-prefer-string-based-enums)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.4 [Use cases for enums](ch_enums.html#use-cases-for-enums)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '12.4.1 [Use case: bit patterns](ch_enums.html#use-case-bit-patterns)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '12.4.2 [Use case: multiple constants](ch_enums.html#use-case-multiple-constants)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '12.4.3 [Use case: more self-descriptive than booleans](ch_enums.html#use-case-more-self-descriptive-than-booleans)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '12.4.4 [Use case: better string constants](ch_enums.html#use-case-better-string-constants)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.5 [Enums at runtime](ch_enums.html#enums-at-runtime)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.5.1 [Reverse mappings](ch_enums.html#reverse-mappings)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.5.2 [String-based enums at runtime](ch_enums.html#string-based-enums-at-runtime)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.6 [`const` enums](ch_enums.html#const-enums)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.6.1 [Compiling non-const enums](ch_enums.html#compiling-non-const-enums)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.6.2 [Compiling const enums](ch_enums.html#compiling-const-enums)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.7 [Enums at compile time](ch_enums.html#enums-at-compile-time)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.7.1 [Enums are objects](ch_enums.html#enums-are-objects)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.7.2 [Safety checks for literal enums](ch_enums.html#safety-checks-for-literal-enums)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.7.3 [`keyof` and enums](ch_enums.html#keyof-and-enums)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.8 [Acknowledgment](ch_enums.html#acknowledgment)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter answers the following two questions:'
  prefs: []
  type: TYPE_NORMAL
- en: How do TypeScript’s enums work?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What can they be used for?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [the next chapter](ch_enum-alternatives.html), we take a look at alternatives
    to enums.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1 The basics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`boolean` is a type with a finite amount of values: `false` and `true`. With
    enums, TypeScript lets us define similar types ourselves.'
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.1 Numeric enums
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is a numeric enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Explanations:'
  prefs: []
  type: TYPE_NORMAL
- en: The entries `No` and `Yes` are called the *members* of the enum `NoYes`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each enum member has a *name* and a *value*. For example, the first member has
    the name `No` and the value `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The part of a member definition that starts with an equals sign and specifies
    a value is called an *initializer*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As in object literals, trailing commas are allowed and ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use members as if they were literals such as `true`, `123`, or `''abc''`
    – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 12.1.2 String-based enums
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Instead of numbers, we can also use strings as enum member values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 12.1.3 Heterogeneous enums
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last kind of enums is called *heterogeneous*. The member values of a heterogeneous
    enum are a mix of numbers and strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Heterogeneous enums are not used often because they have few applications.
  prefs: []
  type: TYPE_NORMAL
- en: Alas, TypeScript only supports numbers and strings as enum member values. Other
    values, such as symbols, are not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.4 Omitting initializers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can omit initializers in two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: We can omit the initializer of the first member. Then that member has the value
    0 (zero).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can omit the initializer of a member if the previous member has a number
    value. Then the current member has that value plus one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a numeric enum without any initializers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a heterogeneous enum where some initializers are omitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that we can’t omit the initializer in line A because the value of the preceding
    member is not a number.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.5 Casing of enum member names
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are several precedents for naming constants (in enums or elsewhere):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, JavaScript has used all-caps names, which is a convention it
    inherited from Java and C:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.MAX_VALUE`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Math.SQRT2`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Well-known symbols are camel-cased and start with lowercase letters because
    they are related to property names:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol.asyncIterator`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The TypeScript manual uses camel-cased names that start with uppercase letters.
    This is the standard TypeScript style and we used it for the `NoYes` enum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.1.6 Quoting enum member names
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Similar to JavaScript objects, we can quote the names of enum members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There is no way to compute the names of enum members. Object literals support
    computed property keys via square brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2 Specifying enum member values (advanced)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'TypeScript distinguishes three kinds of enum members, by how they are initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *literal enum member*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: either has no initializer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: or is initialized via a number literal or a string literal.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A *constant enum member* is initialized via an expression whose result can be
    computed at compile time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *computed enum member* is initialized via an arbitrary expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we have only used literal members.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous list, members that are mentioned earlier are less flexible but
    support more features. Read on for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.1 Literal enum members
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An enum member is *literal* if its value is specified:'
  prefs: []
  type: TYPE_NORMAL
- en: either implicitly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: or via a number literal (incl. negated number literals)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: or via a string literal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If an enum has only literal members, we can use those members as types (similar
    to how, e.g., number literals can be used as types):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`NoYes.No` in line A is an *enum member type*.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, literal enums support exhaustiveness checks (which we’ll look
    at later).
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.2 Constant enum members
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An enum member is constant if its value can be computed at compile time. Therefore,
    we can either specify its value implicitly (that is, we let TypeScript specify
    it for us). Or we can specify it explicitly and are only allowed to use the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: Number literals or string literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A reference to a previously defined constant enum member (in the current enum
    or in a previous enum)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parentheses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The unary operators `+`, `-`, `~`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The binary operators `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `>>>`, `&`, `|`, `^`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is an example of an enum whose members are all constant (we’ll see later
    how that enum is used):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In general, constant members can’t be used as types. However, exhaustiveness
    checks are still performed.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.3 Computed enum members
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The values of *computed enum members* can be specified via arbitrary expressions.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This was a numeric enum. String-based enums and heterogeneous enums are more
    limited. For example, we cannot use method invocations to specify member values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript does not do exhaustiveness checks for computed enum members.
  prefs: []
  type: TYPE_NORMAL
- en: 12.3 Downsides of numeric enums
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '12.3.1 Downside: logging'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When logging members of numeric enums, we only see numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '12.3.2 Downside: loose type-checking'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When using the enum as a type, the values that are allowed statically are not
    just those of the enum members – any number is accepted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Why aren’t there stricter static checks? [Daniel Rosenwasser explains](https://github.com/microsoft/TypeScript/issues/26362#issuecomment-412198938):'
  prefs: []
  type: TYPE_NORMAL
- en: The behavior is motivated by bitwise operations. There are times when `SomeFlag.Foo
    | SomeFlag.Bar` is intended to produce another `SomeFlag`. Instead you end up
    with `number`, and you don’t want to have to cast back to `SomeFlag`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I think if we did TypeScript over again and still had enums, we’d have made
    a separate construct for bit flags.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How enums are used for bit patterns is demonstrated soon in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '12.3.3 Recommendation: prefer string-based enums'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'My recommendation is to prefer string-based enums (for brevity’s sake, this
    chapter doesn’t always follow this recommendation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'On one hand, logging output is more useful for humans:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, we get stricter type checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Not even strings that are equal to values of members are allowed (line A).
  prefs: []
  type: TYPE_NORMAL
- en: 12.4 Use cases for enums
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '12.4.1 Use case: bit patterns'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [the Node.js file system module](https://nodejs.org/api/fs.html), several
    functions have the parameter `mode`. It specifies file permissions, via a numeric
    encoding that is a holdover from Unix:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Permissions are specified for three categories of users:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'User: the owner of the file'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Group: the members of the group associated with the file'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All: everyone'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Per category, the following permissions can be granted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'r (read): the users in the category are allowed to read the file'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'w (write): the users in the category are allowed to change the file'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'x (execute): the users in the category are allowed to run the file'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That means that permissions can be represented by 9 bits (3 categories with
    3 permissions each):'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | User | Group | All |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Permissions | r, w, x | r, w, x | r, w, x |'
  prefs: []
  type: TYPE_TB
- en: '| Bit | 8, 7, 6 | 5, 4, 3 | 2, 1, 0 |'
  prefs: []
  type: TYPE_TB
- en: 'Node.js doesn’t do this, but we could use an enum to work with these flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Bit patterns are combined via [bitwise Or](https://exploringjs.com/impatient-js/ch_numbers.html#binary-bitwise-operators):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 12.4.1.1 An alternative to bit patterns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The main idea behind bit patterns is that there is a set of flags and that any
    subset of those flags can be chosen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, using real sets to choose subsets is a more straightforward way
    of performing the same task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '12.4.2 Use case: multiple constants'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes, we have sets of constants that belong together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a good use case for an enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: One benefit of the enum is that the constant names are grouped and nested inside
    the namespace `LogLevel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another one is that we automatically get the type `LogLevel` for them. If we
    want such a type for the constants, we need more work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: For more information on this approach, see [§13.1.3 “Unions of symbol singleton
    types”](ch_enum-alternatives.html#unions-of-symbol-singleton-types).
  prefs: []
  type: TYPE_NORMAL
- en: '12.4.3 Use case: more self-descriptive than booleans'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When booleans are used to represent alternatives, enums are usually more self-descriptive.
  prefs: []
  type: TYPE_NORMAL
- en: '12.4.3.1 Boolean-ish example: ordered vs. unordered lists'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For example, to represent whether a list is ordered or not, we can use a boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: However, an enum is more self-descriptive and has the additional benefit that
    we can add more alternatives later if we need to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '12.4.3.2 Boolean-ish example: error handling modes'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Similarly, we can specify how to handle errors via a boolean value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can do so via an enum value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '12.4.4 Use case: better string constants'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider the following function that creates regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of the string constants, we can use an enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: What are the benefits of this approach?
  prefs: []
  type: TYPE_NORMAL
- en: It is more concise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is slightly safer: The type `Globalness` only accepts member names, not
    strings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.5 Enums at runtime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'TypeScript compiles enums to JavaScript objects. As an example, take the following
    enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript compiles this enum to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, the following assignments are made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two groups of assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: The first two assignments map enum member names to values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second two assignments map values to names. That enables *reverse mappings*,
    which we will look at next.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.5.1 Reverse mappings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Given a numeric enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The normal mapping is from member names to member values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Numeric enums also support a *reverse mapping* from member values to member
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'One use case for reverse mappings is printing the name of an enum member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 12.5.2 String-based enums at runtime
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: String-based enums have a simpler representation at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following enum.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'It is compiled to this JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript does not support reverse mappings for string-based enums.
  prefs: []
  type: TYPE_NORMAL
- en: 12.6 `const` enums
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If an enum is prefixed with the keyword `const`, it doesn’t have a representation
    at runtime. Instead, the values of its member are used directly.
  prefs: []
  type: TYPE_NORMAL
- en: 12.6.1 Compiling non-const enums
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To observe this effect, let us first examine the following non-const enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript compiles this code to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 12.6.2 Compiling const enums
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is the same code as previously, but now the enum is const:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the representation of the enum as a construct disappears and only the values
    of its members remain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 12.7 Enums at compile time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 12.7.1 Enums are objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'TypeScript treats (non-const) enums as if they were objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 12.7.2 Safety checks for literal enums
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we accept an enum member value, we often want to make sure that:'
  prefs: []
  type: TYPE_NORMAL
- en: We don’t receive illegal values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don’t forget to consider any enum member values. This is especially relevant
    if we add members later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Read on for more information. We will be working with the following enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 12.7.2.1 Protecting against illegal values
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the following code, we take two measures against illegal values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The measures are:'
  prefs: []
  type: TYPE_NORMAL
- en: At compile time, the type `NoYes` prevents illegal values being passed to the
    parameter `value`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At runtime, the `default` case is used to throw an exception if there is an
    unexpected value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.7.2.2 Protecting against forgetting cases via exhaustiveness checks
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can take one more measure. The following code performs an *exhaustiveness
    check*: TypeScript will warn us if we forget to consider all enum members.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'How does the exhaustiveness check work? For every case, TypeScript infers the
    type of `value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the default case, TypeScript infers the type `never` for `value` because
    we never get there. If however, we add a member `.Maybe` to `NoYes`, then the
    inferred type of `value` is `NoYes.Maybe`. And that type is statically incompatible
    with the type `never` of the parameter of `new UnsupportedValueError()`. That’s
    why we get the following error message at compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Conveniently, this kind of exhaustiveness check also works with `if` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 12.7.2.3 An alternative way of checking exhaustiveness
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Alternatively, we also get an exhaustiveness check if we specify a return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If we add a member to `NoYes`, then TypeScript complains that `toGerman4()`
    may return `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Downsides of this approach:**'
  prefs: []
  type: TYPE_NORMAL
- en: This approach does not work with `if` statements ([more information](https://github.com/microsoft/TypeScript/issues/17358)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No checks are performed at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.7.3 `keyof` and enums
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can use the `keyof` type operator to create the type whose elements are
    the keys of the enum members. When we do so, we need to combine `keyof` with `typeof`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 12.7.3.1 Using `keyof` without `typeof`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If we use `keyof` without `typeof`, we get a different, less useful, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '`keyof HttpRequestKeyEnum` is the same as `keyof number`.'
  prefs: []
  type: TYPE_NORMAL
- en: 12.8 Acknowledgment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thanks to Disqus user `@spira_mirabilis` for their feedback to this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/tackling-ts/issues/12)'
  prefs: []
  type: TYPE_NORMAL
