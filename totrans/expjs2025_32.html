<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>27 Callable values</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>27 Callable values</h1>
<blockquote>原文：<a href="https://exploringjs.com/js/book/ch_callables.html">https://exploringjs.com/js/book/ch_callables.html</a></blockquote>

        
    
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#kinds-of-functions">27.1 Kinds of functions</a>
    </li>
    <li>
      <a href="#ordinary-functions">27.2 Ordinary functions</a>
      <ol>
        <li>
          <a href="#named-function-expressions">27.2.1 Named function expressions<span> (advanced)</span></a>
        </li>
        <li>
          <a href="#terminology-function-definitions-and-function-expressions">27.2.2 Terminology: function definitions and function expressions</a>
        </li>
        <li>
          <a href="#parts-of-a-function-declaration">27.2.3 Parts of a function declaration</a>
        </li>
        <li>
          <a href="#roles-of-ordinary-functions">27.2.4 Roles played by ordinary functions</a>
        </li>
        <li>
          <a href="#terminology-entity-vs-syntax-vs-role-advanced">27.2.5 Terminology: entity vs. syntax vs. role<span> (advanced)</span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#specialized-functions">27.3 Specialized functions<span> <sup>ES6</sup></span></a>
      <ol>
        <li>
          <a href="#specialized-functions-are-still-functions">27.3.1 Specialized functions are still functions</a>
        </li>
        <li>
          <a href="#arrow-functions">27.3.2 Arrow functions</a>
        </li>
        <li>
          <a href="#this-in-callables">27.3.3 The special variable <code>this</code> in methods, ordinary functions and arrow functions</a>
        </li>
        <li>
          <a href="#prefer-specialized-functions">27.3.4 Recommendation: prefer specialized functions over ordinary functions</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#summary-kinds-of-callable-values">27.4 Summary: kinds of callable values</a>
    </li>
    <li>
      <a href="#returning-values-from-functions-and-methods">27.5 Returning values from functions and methods</a>
    </li>
    <li>
      <a href="#parameter-handling">27.6 Parameter handling</a>
      <ol>
        <li>
          <a href="#terminology-parameters-vs-arguments">27.6.1 Terminology: parameters vs. arguments</a>
        </li>
        <li>
          <a href="#callback-function">27.6.2 Terminology: callback</a>
        </li>
        <li>
          <a href="#too-many-or-not-enough-arguments">27.6.3 Too many or not enough arguments</a>
        </li>
        <li>
          <a href="#parameter-default-values">27.6.4 Parameter default values<span> <sup>ES6</sup></span></a>
        </li>
        <li>
          <a href="#rest-parameters">27.6.5 Rest parameters<span> <sup>ES6</sup></span></a>
        </li>
        <li>
          <a href="#named-parameters">27.6.6 Named parameters</a>
        </li>
        <li>
          <a href="#simulating-named-parameters">27.6.7 Simulating named parameters<span> <sup>ES6</sup></span></a>
        </li>
        <li>
          <a href="#spread-arguments">27.6.8 Spreading (<code>...</code>) into function calls<span> <sup>ES6</sup></span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#methods-of-functions">27.7 Methods of functions: <code>.call()</code>, <code>.apply()</code>, <code>.bind()</code></a>
      <ol>
        <li>
          <a href="#Function.prototype.call">27.7.1 The function method <code>.call()</code></a>
        </li>
        <li>
          <a href="#Function.prototype.apply">27.7.2 The function method <code>.apply()</code></a>
        </li>
        <li>
          <a href="#Function.prototype.bind">27.7.3 The function method <code>.bind()</code></a>
        </li>
      </ol>
    </li>
  </ol>
</nav>
<p>In this chapter, we look at JavaScript values that can be invoked: functions, methods, and classes.</p>
<h3 id="kinds-of-functions"><a class="heading-id-link" href="#kinds-of-functions">27.1 Kinds of functions</a></h3>
<p><span id="index-entry-ordinary-function"/><span id="index-entry-function--ordinary"/>
<span id="index-entry-specialized-function"/><span id="index-entry-function--specialized"/></p>
<p>JavaScript has two categories of functions:</p>
<ul>
  <li>
    <p>An <em>ordinary function</em> can play several roles:</p>
    <ul>
      <li>
        Real function
      </li>
      <li>
        Method
      </li>
      <li>
        Constructor function
      </li>
    </ul>
  </li>
  <li>
    <p>A <em>specialized function</em> can only play one of those roles – for example:</p>
    <ul>
      <li>
        An <em>arrow function</em> can only be a real function.
      </li>
      <li>
        A <em>method</em> can only be a method.
      </li>
      <li>
        A <em>class</em> can only be a constructor function.
      </li>
    </ul>
    <p>Specialized functions were added to the language in ECMAScript 6.</p>
  </li>
</ul>
<p>Read on to find out what all of those things mean.</p>
<h3 id="ordinary-functions"><a class="heading-id-link" href="#ordinary-functions">27.2 Ordinary functions</a></h3>
<p><span id="index-entry-function-declaration"/>
<span id="index-entry-anonymous-function-expression"/><span id="index-entry-function-expression--anonymous"/></p>
<p>The following code shows two ways of doing (roughly) the same thing: creating an ordinary function.</p>
<pre class="language-js">
<span class="hljs-comment">// Function declaration (a statement)</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ordinary1</span>(<span class="hljs-params">a, b, c</span>) {
  <span class="hljs-comment">// ···</span>
}
<code/>
<span class="hljs-comment">// const plus anonymous (nameless) function expression</span>
<span class="hljs-keyword">const</span> ordinary2 = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c</span>) {
  <span class="hljs-comment">// ···</span>
};
</pre>
<p>Inside a scope, function declarations are activated early (see <a href="ch_variables-assignment.html#declarations-scope-activation">“Declarations: scope and activation” (§13.8)</a>) and can be called before they are declared. That is occasionally useful.</p>
<p>Variable declarations, such as the one for <code>ordinary2</code>, are not activated early.</p>
<h4 id="named-function-expressions"><a class="heading-id-link" href="#named-function-expressions">27.2.1 Named function expressions<span> (advanced)</span></a></h4>
<p><span id="index-entry-named-function-expression"/><span id="index-entry-function-expression--named"/></p>
<p>So far, we have only seen anonymous function expressions – which don’t have names:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> anonFuncExpr = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c</span>) {
  <span class="hljs-comment">// ···</span>
};
</pre>
<p>But there are also <em>named function expressions</em>:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> namedFuncExpr = <span class="hljs-keyword">function</span> <span class="hljs-title function_">myName</span>(<span class="hljs-params">a, b, c</span>) {
  <span class="hljs-comment">// `myName` is only accessible in here</span>
};
</pre>
<p><code>myName</code> is only accessible inside the body of the function. The function can use it to refer to itself (for self-recursion, etc.) – independently of which variable it is assigned to:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> func = <span class="hljs-keyword">function</span> <span class="hljs-title function_">funcExpr</span>(<span class="hljs-params">) { <span class="hljs-keyword">return</span> funcExpr };</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">func</span>(), func);</span>
<code/>
<span class="hljs-params"><span class="hljs-comment">// The name `funcExpr` only exists inside the function body:</span></span>
<span class="hljs-params">assert.<span class="hljs-title function_">throws</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">funcExpr</span>(), <span class="hljs-title class_">ReferenceError</span>);</span>
</pre>
<p>Even if they are not assigned to variables, named function expressions have names (line A):</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getNameOfCallback</span>(<span class="hljs-params">callback</span>) {
  <span class="hljs-keyword">return</span> callback.<span class="hljs-property">name</span>;
}
<code/>
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title function_">getNameOfCallback</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">) {}), <span class="hljs-string">''</span> <span class="hljs-comment">// anonymous</span></span>
<span class="hljs-params">);</span>
<code/>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">  <span class="hljs-title function_">getNameOfCallback</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">named</span>(<span class="hljs-params"/>) {}), <span class="hljs-string">'named'</span> <span class="hljs-comment">// (A)</span></span>
<span class="hljs-params">);</span>
</pre>
<p>Note that functions created via function declarations or variable declarations always have names:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">funcDecl</span>(<span class="hljs-params">) {}</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">  <span class="hljs-title function_">getNameOfCallback</span>(funcDecl), <span class="hljs-string">'funcDecl'</span></span>
<span class="hljs-params">);</span>
<code/>
<span class="hljs-params"><span class="hljs-keyword">const</span> funcExpr = <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {};</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">  <span class="hljs-title function_">getNameOfCallback</span>(funcExpr), <span class="hljs-string">'funcExpr'</span></span>
<span class="hljs-params">);</span>
</pre>
<p>One benefit of functions having names is that those names show up in <a href="ch_exception-handling.html#error-stack">error stack traces</a>.</p>
<h4 id="terminology-function-definitions-and-function-expressions"><a class="heading-id-link" href="#terminology-function-definitions-and-function-expressions">27.2.2 Terminology: function definitions and function expressions</a></h4>
<p>A <em>function definition</em> is syntax that creates functions:</p>
<ul>
  <li>
    A function declaration (a statement)
  </li>
  <li>
    A function expression
  </li>
</ul>
<p>Function declarations always produce ordinary functions. Function expressions produce either ordinary functions or specialized functions:</p>
<ul>
  <li>
    Ordinary function expressions (which we have already encountered):
    <ul>
      <li>
        Anonymous function expressions
      </li>
      <li>
        Named function expressions
      </li>
    </ul>
  </li>
  <li>
    Specialized function expressions (which we’ll look at later):
    <ul>
      <li>
        Arrow functions (which are always expressions)
      </li>
    </ul>
  </li>
</ul>
<p>While function declarations are still popular in JavaScript, function expressions are almost always arrow functions in modern code.</p>
<h4 id="parts-of-a-function-declaration"><a class="heading-id-link" href="#parts-of-a-function-declaration">27.2.3 Parts of a function declaration</a></h4>
<p>Let’s examine the parts of a function declaration via the following example. Most of the terms also apply to function expressions.</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) {
  <span class="hljs-keyword">return</span> x + y;
}
</pre>
<ul>
  <li>
    <code>add</code> is the <em>name</em> of the function declaration.
  </li>
  <li>
    <code>add(x, y)</code> is the <em>head</em> of the function declaration.
  </li>
  <li>
    <code>x</code> and <code>y</code> are the <em>parameters</em>.
  </li>
  <li>
    The curly braces (<code>{</code> and <code>}</code>) and everything between them are the <em>body</em> of the function declaration.
  </li>
  <li>
    The <code>return</code> statement explicitly returns a value from the function.
  </li>
</ul>
<h5 id="trailing-commas-parameters"><a class="heading-id-link" href="#trailing-commas-parameters">27.2.3.1 Trailing commas in parameter lists<span> <sup>ES2017</sup></span></a></h5>
<p><span id="index-entry-trailing-commas-in-parameter-lists"/></p>
<p>JavaScript has always allowed and ignored trailing commas in Array literals. Since ES5, they are also allowed in object literals. Since ES2017, we can add trailing commas to parameter lists (declarations and invocations):</p>
<pre class="language-js">
<span class="hljs-comment">// Declaration</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">retrieveData</span>(
<span class="hljs-params">  contentText,</span>
<span class="hljs-params">  keyword,</span>
<span class="hljs-params">  {unique, ignoreCase, pageSize}, <span class="hljs-comment">// trailing comma</span></span>
) {
  <span class="hljs-comment">// ···</span>
}
<code/>
<span class="hljs-comment">// Invocation</span>
<span class="hljs-title function_">retrieveData</span>(
  <span class="hljs-string">''</span>,
  <span class="hljs-literal">null</span>,
  {<span class="hljs-attr">ignoreCase</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">pageSize</span>: <span class="hljs-number">10</span>}, <span class="hljs-comment">// trailing comma</span>
);
</pre>
<h4 id="roles-of-ordinary-functions"><a class="heading-id-link" href="#roles-of-ordinary-functions">27.2.4 Roles played by ordinary functions</a></h4>
<p><span id="index-entry-roles-of-an-ordinary-function"/><span id="index-entry-ordinary-function--roles-of-an"/><span id="index-entry-function--roles-of-an-ordinary"/></p>
<p>Consider the following function declaration from the previous section:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) {
  <span class="hljs-keyword">return</span> x + y;
}
</pre>
<p>This function declaration creates an ordinary function whose name is <code>add</code>. As an ordinary function, <code>add()</code> can play three roles:</p>
<ul>
  <li>
    <p>Real function: invoked via a function call. <span id="index-entry-real-function--role-of-an-ordinary-function-"/></p>
<pre class="language-js">
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>), <span class="hljs-number">3</span>);
</pre>
  </li>
  <li>
    <p>Method: stored in a property, invoked via a method call.  <span id="index-entry-method--role-of-an-ordinary-function-"/></p>
<pre class="language-js">
<span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">addAsMethod</span>: add };
assert.<span class="hljs-title function_">equal</span>(obj.<span class="hljs-title function_">addAsMethod</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>), <span class="hljs-number">6</span>); <span class="hljs-comment">// (A)</span>
</pre>
    <p>In line A, <code>obj</code> is called the <em>receiver</em> of the method call.</p>
  </li>
  <li>
    <p>Constructor function: invoked via <code>new</code>. <span id="index-entry-constructor-function--role-of-an-ordinary-function-"/></p>
<pre class="language-js">
<span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title function_">add</span>();
assert.<span class="hljs-title function_">equal</span>(inst <span class="hljs-keyword">instanceof</span> add, <span class="hljs-literal">true</span>);
</pre>
    <p>As an aside, the names of constructor functions (incl. classes) normally start with capital letters.</p>
  </li>
</ul>
<h4 id="terminology-entity-vs-syntax-vs-role-advanced"><a class="heading-id-link" href="#terminology-entity-vs-syntax-vs-role-advanced">27.2.5 Terminology: entity vs. syntax vs. role<span> (advanced)</span></a></h4>
<p>The distinction between the concepts <em>syntax</em>, <em>entity</em>, and <em>role</em> is subtle and often doesn’t matter. But it’s still useful to be aware of it:</p>
<ul>
  <li>
    <p>An <em>entity</em> is a JavaScript feature as it “lives” in RAM. An ordinary function is an entity.</p>
    <ul>
      <li>
        Entities include: ordinary functions, arrow functions, methods, and classes.
      </li>
    </ul>
  </li>
  <li>
    <p><em>Syntax</em> is the code that we use to create entities. Function declarations and anonymous function expressions are syntax. They both create entities that are called ordinary functions.</p>
    <ul>
      <li>
        Syntax includes: function declarations and anonymous function expressions. The syntax that produces arrow functions is also called <em>arrow functions</em>. The same is true for methods and classes.
      </li>
    </ul>
  </li>
  <li>
    <p>A <em>role</em> describes how we use entities. The entity <em>ordinary function</em> can play the role <em>real function</em>, or the role <em>method</em>, or the role <em>class</em>. The entity <em>arrow function</em> can also play the role <em>real function</em>.</p>
    <ul>
      <li>
        The roles of functions are: real function, method, and constructor function.
      </li>
    </ul>
  </li>
</ul>
<p>Many other programming languages only have a single entity that plays the role <em>real function</em>. Then they can use the name <em>function</em> for both role and entity.</p>
<h3 id="specialized-functions"><a class="heading-id-link" href="#specialized-functions">27.3 Specialized functions<span> <sup>ES6</sup></span></a></h3>
<p>Specialized functions are single-purpose versions of ordinary functions. Each one of them specializes in a single role:</p>
<ul>
  <li>
    <p>The purpose of an <em>arrow function</em> is to be a real function:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> <span class="hljs-title function_">arrow</span> = (<span class="hljs-params">) =&gt; {</span>
<span class="hljs-params">  <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;</span>
<span class="hljs-params">};</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">arrow</span>(), <span class="hljs-number">123</span>);</span>
</pre>
  </li>
  <li>
    <p>The purpose of a <em>method</em> is to be a method:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> obj = {
  <span class="hljs-title function_">myMethod</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">'abc'</span>;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">};</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(obj.<span class="hljs-title function_">myMethod</span>(), <span class="hljs-string">'abc'</span>);</span>
</pre>
  </li>
  <li>
    <p>The purpose of a <em>class</em> is to be a constructor function:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  <span class="hljs-comment">/* ··· */</span>
}
<span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();
</pre>
  </li>
</ul>
<p>Apart from nicer syntax, each kind of specialized function also supports new features, making them better at their jobs than ordinary functions.</p>
<ul>
  <li>
    Arrow functions are explained <span refcheck="#arrow-functions">soon</span>.
  </li>
  <li>
    Methods are explained <a href="ch_objects.html#methods-and-this">in the chapter on objects</a>.
  </li>
  <li>
    Classes are explained <a href="ch_classes.html#classes">in the chapter on classes</a>.
  </li>
</ul>
<p><a href="#tbl:capabilities-of-functions">Table 27.1</a> lists the capabilities of ordinary and specialized functions.</p>
<figure id="tbl:capabilities-of-functions" class="float">
  <table class="framed">
    <style>
      th:nth-child(1), td:nth-child(1) {
        text-align: left;
      }
      th:nth-child(2), td:nth-child(2) {
        text-align: left;
      }
      th:nth-child(3), td:nth-child(3) {
        text-align: left;
      }
      th:nth-child(4), td:nth-child(4) {
        text-align: left;
      }
    </style>
    <thead>
      <tr>
        <th/><th>Function call</th><th>Method call</th><th>Constructor call</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Ordinary function</td><td>(<code>this === undefined</code>)</td><td>✔</td><td>✔</td>
      </tr>
      <tr>
        <td>Arrow function</td><td>✔</td><td>(lexical <code>this</code>)</td><td>✘</td>
      </tr>
      <tr>
        <td>Method</td><td>(<code>this === undefined</code>)</td><td>✔</td><td>✘</td>
      </tr>
      <tr>
        <td>Class</td><td>✘</td><td>✘</td><td>✔</td>
      </tr>
    </tbody>
  </table>
  <figcaption>
    <p><span class="float-label">Table 27.1:</span> Capabilities of four kinds of functions. If a cell value is in parentheses, that implies some kind of limitation. The special variable <code>this</code> is explained in <a href="#this-in-callables">“The special variable <code>this</code> in methods, ordinary functions and arrow functions” (§27.3.3)</a>.</p>
  </figcaption>
</figure>
<h4 id="specialized-functions-are-still-functions"><a class="heading-id-link" href="#specialized-functions-are-still-functions">27.3.1 Specialized functions are still functions</a></h4>
<p>It’s important to note that arrow functions, methods, and classes are still categorized as functions:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">(<span class="hljs-function">() =&gt;</span> {}) <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">({ <span class="hljs-title function_">method</span>(<span class="hljs-params"/>) {} }.<span class="hljs-property">method</span>) <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">(<span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeClass</span> {}) <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span></span>
true
</pre>
<h4 id="arrow-functions"><a class="heading-id-link" href="#arrow-functions">27.3.2 Arrow functions</a></h4>
<p><span id="index-entry-arrow-function"/><span id="index-entry-function--arrow"/></p>
<p>Arrow functions were added to JavaScript for two reasons:</p>
<ol>
  <li>
    To provide a more concise way for creating functions.
  </li>
  <li>
    They work better as real functions inside methods: Methods can refer to the object that received a method call via the special variable <code>this</code>. Arrow functions can access the <code>this</code> of a surrounding method, ordinary functions can’t (because they have their own <code>this</code>).
  </li>
</ol>
<p>We’ll first examine the syntax of arrow functions and then how <code>this</code> works in various functions.</p>
<h5 id="the-syntax-of-arrow-functions"><a class="heading-id-link" href="#the-syntax-of-arrow-functions">27.3.2.1 The syntax of arrow functions</a></h5>
<p>Let’s review the syntax of an anonymous function expression:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> f = <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y, z</span>) { <span class="hljs-keyword">return</span> <span class="hljs-number">123</span> };
</pre>
<p>The (roughly) equivalent arrow function looks as follows. Arrow functions are expressions.</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params">x, y, z</span>) =&gt; { <span class="hljs-keyword">return</span> <span class="hljs-number">123</span> };
</pre>
<p>Here, the body of the arrow function is a block. But it can also be an expression. The following arrow function works exactly like the previous one.</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params">x, y, z</span>) =&gt; <span class="hljs-number">123</span>;
</pre>
<p>If an arrow function has only a single parameter and that parameter is an identifier (not <a href="ch_destructuring.html#ch_destructuring">a destructuring pattern</a>) then we can omit the parentheses around the parameter:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> <span class="hljs-title function_">id</span> = x =&gt; x;
</pre>
<p>That is convenient when passing arrow functions as parameters to other functions or methods:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x+<span class="hljs-number">1</span>)</span>
[ 2, 3, 4 ]
</pre>
<p>This previous example demonstrates one benefit of arrow functions – conciseness. If we perform the same task with a function expression, our code is more verbose:</p>
<pre class="language-js">
[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) { <span class="hljs-keyword">return</span> x+<span class="hljs-number">1</span> });
</pre>
<h5 id="returning-object-literal-from-arrow-function"><a class="heading-id-link" href="#returning-object-literal-from-arrow-function">27.3.2.2 Syntax pitfall: returning an object literal from an arrow function</a></h5>
<p>If we want the expression body of an arrow function to be an object literal, we must put the literal in parentheses:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> <span class="hljs-title function_">func1</span> = (<span class="hljs-params">) =&gt; ({<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>});</span>
<span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-title function_">func1</span>(), { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> });</span>
</pre>
<p>If we don’t, JavaScript thinks, the arrow function has a block body (that doesn’t return anything):</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> <span class="hljs-title function_">func2</span> = (<span class="hljs-params">) =&gt; {<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>};</span>
<span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-title function_">func2</span>(), <span class="hljs-literal">undefined</span>);</span>
</pre>
<p><code>{a: 1}</code> is interpreted as a block with <a href="ch_control-flow.html#labels">the label <code>a:</code></a> and the expression statement <code>1</code>. Without an explicit <code>return</code> statement, the block body returns <code>undefined</code>.</p>
<p>This pitfall is caused by <a href="ch_syntax.html#ambiguous-syntax">syntactic ambiguity</a>: object literals and code blocks have the same syntax. We use the parentheses to tell JavaScript that the body is an expression (an object literal) and not a statement (a block).</p>
<h4 id="this-in-callables"><a class="heading-id-link" href="#this-in-callables">27.3.3 The special variable <code>this</code> in methods, ordinary functions and arrow functions</a></h4>
<div class="boxout">
  <p><img src="../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png" class="boxout-icon" height="24" alt="Icon “reading”" data-original-src="https://exploringjs.com/js/book/icon/reading.svg"/> <strong>The special variable <code>this</code> is an object-oriented feature</strong></p>
  <div class="boxout-vspace"/>
  <p>We are taking a quick look at the special variable <code>this</code> here, in order to understand why arrow functions are better real functions than ordinary functions.</p>
  <p>But this feature only matters in object-oriented programming and is covered in more depth in <a href="ch_objects.html#methods-and-this">“Methods and the special variable <code>this</code>” (§30.6)</a>. Therefore, don’t worry if you don’t fully understand it yet.</p>
</div>
<p>Inside methods, the special variable <code>this</code> lets us access the <em>receiver</em> – the object which received the method call:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> obj = {
  <span class="hljs-title function_">myMethod</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    assert.<span class="hljs-title function_">equal</span>(<span class="hljs-variable language_">this</span>, obj);</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">};</span>
<span class="hljs-params">obj.<span class="hljs-title function_">myMethod</span>();</span>
</pre>
<p>Ordinary functions can be methods and therefore also have the implicit parameter <code>this</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> obj = {
  <span class="hljs-attr">myMethod</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">) {</span>
<span class="hljs-params">    assert.<span class="hljs-title function_">equal</span>(<span class="hljs-variable language_">this</span>, obj);</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">};</span>
<span class="hljs-params">obj.<span class="hljs-title function_">myMethod</span>();</span>
</pre>
<p><code>this</code> is even an implicit parameter when we use an ordinary function as a real function. Then its value is <code>undefined</code> (if <a href="ch_syntax.html#strict-mode">strict mode</a> is active, which it almost always is):</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ordinaryFunc</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  assert.<span class="hljs-title function_">equal</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-literal">undefined</span>);</span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-title function_">ordinaryFunc</span>();</span>
</pre>
<p>That means that an ordinary function, used as a real function, can’t access the <code>this</code> of a surrounding method (line A). In contrast, arrow functions don’t have <code>this</code> as an implicit parameter. They treat it like any other variable and can therefore access the <code>this</code> of a surrounding method (line B):</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> jill = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Jill'</span>,
  <span class="hljs-title function_">someMethod</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">ordinaryFunc</span>(<span class="hljs-params"/>) {</span>
<span class="hljs-params">      assert.<span class="hljs-title function_">throws</span>(</span>
<span class="hljs-params">        <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>, <span class="hljs-comment">// (A)</span></span>
<span class="hljs-params">        <span class="hljs-regexp">/^TypeError: Cannot read properties of undefined \(reading 'name'\)$/</span></span>
<span class="hljs-params">      );</span>
<span class="hljs-params">    }</span>
<span class="hljs-params">    <span class="hljs-title function_">ordinaryFunc</span>();</span>
<code/>
<span class="hljs-params">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">arrowFunc</span> = (<span class="hljs-params"/>) =&gt; {</span>
<span class="hljs-params">      assert.<span class="hljs-title function_">equal</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>, <span class="hljs-string">'Jill'</span>); <span class="hljs-comment">// (B)</span></span>
<span class="hljs-params">    };</span>
<span class="hljs-params">    <span class="hljs-title function_">arrowFunc</span>();</span>
<span class="hljs-params">  },</span>
<span class="hljs-params">};</span>
<span class="hljs-params">jill.<span class="hljs-title function_">someMethod</span>();</span>
</pre>
<p>In this code, we can observe two ways of handling <code>this</code>:</p>
<ul>
  <li>
    <p>Dynamic <code>this</code>: In line A, we try to access the <code>this</code> of <code>.someMethod()</code> from an ordinary function. There, it is <em>shadowed</em> by the function’s own <code>this</code>, which is <code>undefined</code> (as filled in by the function call). Given that ordinary functions receive their <code>this</code> via (dynamic) function or method calls, their <code>this</code> is called <em>dynamic</em>.</p>
  </li>
  <li>
    <p>Lexical <code>this</code>: In line B, we again try to access the <code>this</code> of <code>.someMethod()</code>. This time, we succeed because the arrow function does not have its own <code>this</code>. <code>this</code> is resolved <em>lexically</em>, just like any other variable. That’s why the <code>this</code> of arrow functions is called <em>lexical</em>.</p>
  </li>
</ul>
<p><span id="index-entry-dynamic-this"/><span id="index-entry-this--dynamic"/>
<span id="index-entry-lexical-this"/><span id="index-entry-this--lexical"/></p>
<h4 id="prefer-specialized-functions"><a class="heading-id-link" href="#prefer-specialized-functions">27.3.4 Recommendation: prefer specialized functions over ordinary functions</a></h4>
<p>Normally, we should prefer specialized functions over ordinary functions, especially classes and methods.</p>
<p>When it comes to real functions, the choice between an arrow function and an ordinary function is less clear-cut, though:</p>
<ul>
  <li>
    <p>For anonymous inline function expressions, arrow functions are clear winners, due to their compact syntax and them not having <code>this</code> as an implicit parameter:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> twiceOrdinary = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) {<span class="hljs-keyword">return</span> x * <span class="hljs-number">2</span>});
<span class="hljs-keyword">const</span> twiceArrow = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">2</span>);
</pre>
  </li>
  <li>
    <p>For stand-alone named function declarations, arrow functions still benefit from lexical <code>this</code>. But function declarations (which produce ordinary functions) have nice syntax and early activation is also occasionally useful (see <a href="ch_variables-assignment.html#declarations-scope-activation">“Declarations: scope and activation” (§13.8)</a>). If <code>this</code> doesn’t appear in the body of an ordinary function, there is no downside to using it as a real function. The static checking tool ESLint can warn us during development when we do this wrong via <a href="https://eslint.org/docs/rules/no-invalid-this">a built-in rule</a>.</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">timesOrdinary</span>(<span class="hljs-params">x, y</span>) {
  <span class="hljs-keyword">return</span> x * y;
}
<span class="hljs-keyword">const</span> <span class="hljs-title function_">timesArrow</span> = (<span class="hljs-params">x, y</span>) =&gt; {
  <span class="hljs-keyword">return</span> x * y;
};
</pre>
  </li>
</ul>
<h3 id="summary-kinds-of-callable-values"><a class="heading-id-link" href="#summary-kinds-of-callable-values">27.4 Summary: kinds of callable values</a></h3>
<div class="boxout">
  <p><img src="../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png" class="boxout-icon" height="24" alt="Icon “reading”" data-original-src="https://exploringjs.com/js/book/icon/reading.svg"/> <strong>This section refers to upcoming content</strong></p>
  <div class="boxout-vspace"/>
  <p>This section mainly serves as a reference for the current and upcoming chapters. Don’t worry if you don’t understand everything.</p>
</div>
<p>So far, all (real) functions and methods, that we have seen, were:</p>
<ul>
  <li>
    Single-result
  </li>
  <li>
    Synchronous
  </li>
</ul>
<p>Later chapters will cover other modes of programming:</p>
<ul>
  <li>
    <em>Iteration</em> treats objects as containers of data (so-called <em>iterables</em>) and provides a standardized way for retrieving what is inside them. If a function or a method returns an iterable, it returns multiple values.
  </li>
  <li>
    <em>Asynchronous programming</em> deals with handling a long-running computation. We are notified when the computation is finished and can do something else in between. The standard pattern for asynchronously delivering single results is called <em>Promise</em>.
  </li>
</ul>
<p>These modes can be combined – for example, there are synchronous iterables and asynchronous iterables.</p>
<p>Several new kinds of functions and methods help with some of the mode combinations:</p>
<ul>
  <li>
    <em>Async functions</em> help implement functions that return Promises. There are also <em>async methods</em>.
  </li>
  <li>
    <em>Synchronous generator functions</em> help implement functions that return synchronous iterables. There are also <em>synchronous generator methods</em>.
  </li>
  <li>
    <em>Asynchronous generator functions</em> help implement functions that return asynchronous iterables. There are also <em>asynchronous generator methods</em>.
  </li>
</ul>
<p>That leaves us with 4 kinds (2 × 2) of functions and methods:</p>
<ul>
  <li>
    Synchronous vs. asynchronous
  </li>
  <li>
    Generator vs. single-result
  </li>
</ul>
<p><a href="#tbl:syntax-functions-methods">Table 27.2</a> gives an overview of the syntax for creating these 4 kinds of functions and methods.</p>
<figure id="tbl:syntax-functions-methods" class="float">
  <table class="framed">
    <style>
      th:nth-child(1), td:nth-child(1) {
        text-align: left;
      }
      th:nth-child(2), td:nth-child(2) {
        text-align: left;
      }
      th:nth-child(3), td:nth-child(3) {
        text-align: left;
      }
      th:nth-child(4), td:nth-child(4) {
        text-align: left;
      }
    </style>
    <thead>
      <tr>
        <th/><th/><th><strong>Result</strong></th><th><strong>#</strong></th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Sync function</strong></td><td><strong>Sync method</strong></td><td/><td/>
      </tr>
      <tr>
        <td><code>function f() {}</code></td><td><code>{ m() {} }</code></td><td>value</td><td>1</td>
      </tr>
      <tr>
        <td><code>f = function () {}</code></td><td/><td/><td/>
      </tr>
      <tr>
        <td><code>f = () =&gt; {}</code></td><td/><td/><td/>
      </tr>
      <tr>
        <td><strong>Sync generator function</strong></td><td><strong>Sync gen. method</strong></td><td/><td/>
      </tr>
      <tr>
        <td><code>function* f() {}</code></td><td><code>{ * m() {} }</code></td><td>iterable</td><td>0+</td>
      </tr>
      <tr>
        <td><code>f = function* () {}</code></td><td/><td/><td/>
      </tr>
      <tr>
        <td><strong>Async function</strong></td><td><strong>Async method</strong></td><td/><td/>
      </tr>
      <tr>
        <td><code>async function f() {}</code></td><td><code>{ async m() {} }</code></td><td>Promise</td><td>1</td>
      </tr>
      <tr>
        <td><code>f = async function () {}</code></td><td/><td/><td/>
      </tr>
      <tr>
        <td><code>f = async () =&gt; {}</code></td><td/><td/><td/>
      </tr>
      <tr>
        <td><strong>Async generator function</strong></td><td><strong>Async gen. method</strong></td><td/><td/>
      </tr>
      <tr>
        <td><code>async function* f() {}</code></td><td><code>{ async * m() {} }</code></td><td>async iterable</td><td>0+</td>
      </tr>
      <tr>
        <td><code>f = async function* () {}</code></td><td/><td/><td/>
      </tr>
    </tbody>
  </table>
  <figcaption>
    <p><span class="float-label">Table 27.2:</span> Syntax for creating functions and methods. The last column specifies how many values are produced by an entity.</p>
  </figcaption>
</figure>
<h3 id="returning-values-from-functions-and-methods"><a class="heading-id-link" href="#returning-values-from-functions-and-methods">27.5 Returning values from functions and methods</a></h3>
<p>(Everything mentioned in this section applies to both functions and methods.)</p>
<p>The <code>return</code> statement explicitly returns a value from a function:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;</span>
<span class="hljs-params">}</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">func</span>(), <span class="hljs-number">123</span>);</span>
</pre>
<p>Another example:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">boolToYesNo</span>(<span class="hljs-params">bool</span>) {
  <span class="hljs-keyword">if</span> (bool) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Yes'</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'No'</span>;
  }
}
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">boolToYesNo</span>(<span class="hljs-literal">true</span>), <span class="hljs-string">'Yes'</span>);
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">boolToYesNo</span>(<span class="hljs-literal">false</span>), <span class="hljs-string">'No'</span>);
</pre>
<p>If, at the end of a function, we haven’t returned anything explicitly, JavaScript returns <code>undefined</code> for us:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">noReturn</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-comment">// No explicit return</span></span>
<span class="hljs-params">}</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">noReturn</span>(), <span class="hljs-literal">undefined</span>);</span>
</pre>
<h3 id="parameter-handling"><a class="heading-id-link" href="#parameter-handling">27.6 Parameter handling</a></h3>
<p>Once again, I am only mentioning functions in this section, but everything also applies to methods.</p>
<h4 id="terminology-parameters-vs-arguments"><a class="heading-id-link" href="#terminology-parameters-vs-arguments">27.6.1 Terminology: parameters vs. arguments</a></h4>
<p><span id="index-entry-parameter"/><span id="index-entry-argument"/>
<span id="index-entry-parameter-vs.-argument"/><span id="index-entry-argument-vs.-parameter"/></p>
<p>The term <em>parameter</em> and the term <em>argument</em> basically mean the same thing. If we want to, we can make the following distinction:</p>
<ul>
  <li>
    <p><em>Parameters</em> are part of a function definition. They are also called <em>formal parameters</em> and <em>formal arguments</em>.</p>
  </li>
  <li>
    <p><em>Arguments</em> are part of a function call. They are also called <em>actual parameters</em> and <em>actual arguments</em>.</p>
  </li>
</ul>
<h4 id="callback-function"><a class="heading-id-link" href="#callback-function">27.6.2 Terminology: callback</a></h4>
<p><span id="index-entry-callback-function"/></p>
<p>A <em>callback</em> or <em>callback function</em> is a function that is an argument of a function or method call.</p>
<p>The following is an example of a callback:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> myArray = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];
<span class="hljs-keyword">const</span> <span class="hljs-title function_">callback</span> = (<span class="hljs-params">x</span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);
myArray.<span class="hljs-title function_">forEach</span>(callback);
</pre>
<p>Output:</p>
<pre>
a
b
</pre>
<h4 id="too-many-or-not-enough-arguments"><a class="heading-id-link" href="#too-many-or-not-enough-arguments">27.6.3 Too many or not enough arguments</a></h4>
<p>JavaScript does not complain if a function call provides a different number of arguments than expected by the function definition:</p>
<ul>
  <li>
    Extra arguments are ignored.
  </li>
  <li>
    Missing parameters are set to <code>undefined</code>.
  </li>
</ul>
<p>For example:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x, y</span>) {
  <span class="hljs-keyword">return</span> [x, y];
}
<code/>
<span class="hljs-comment">// Too many arguments:</span>
assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-title function_">foo</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>), [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]);
<code/>
<span class="hljs-comment">// The expected number of arguments:</span>
assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-title function_">foo</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>), [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]);
<code/>
<span class="hljs-comment">// Not enough arguments:</span>
assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-title function_">foo</span>(<span class="hljs-string">'a'</span>), [<span class="hljs-string">'a'</span>, <span class="hljs-literal">undefined</span>]);
</pre>
<h4 id="parameter-default-values"><a class="heading-id-link" href="#parameter-default-values">27.6.4 Parameter default values<span> <sup>ES6</sup></span></a></h4>
<p><span id="index-entry-parameter-default-value"/><span id="index-entry-default-value--parameter-"/></p>
<p>Parameter default values specify the value to use if a parameter has not been provided – for example:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x, y=<span class="hljs-number">0</span></span>) {
  <span class="hljs-keyword">return</span> [x, y];
}
<code/>
assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-title function_">f</span>(<span class="hljs-number">1</span>), [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]);
assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-title function_">f</span>(), [<span class="hljs-literal">undefined</span>, <span class="hljs-number">0</span>]);
</pre>
<p><code>undefined</code> also triggers the default value:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title function_">f</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>),
  [<span class="hljs-literal">undefined</span>, <span class="hljs-number">0</span>]
);
</pre>
<h4 id="rest-parameters"><a class="heading-id-link" href="#rest-parameters">27.6.5 Rest parameters<span> <sup>ES6</sup></span></a></h4>
<p><span id="index-entry-rest-parameter--function-call-"/></p>
<p>A rest parameter is declared by prefixing an identifier with three dots (<code>...</code>). During a function or method call, it receives an Array with all remaining arguments. If there are no extra arguments at the end, it is an empty Array – for example:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x, ...y</span>) {
  <span class="hljs-keyword">return</span> [x, y];
}
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title function_">f</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>), [<span class="hljs-string">'a'</span>, [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]]
);
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title function_">f</span>(), [<span class="hljs-literal">undefined</span>, []]
);
</pre>
<p>There are two restrictions related to how we can use rest parameters:</p>
<ul>
  <li>
    <p>We cannot use more than one rest parameter per function definition.</p>
<pre class="language-js">
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">eval</span>(<span class="hljs-string">'function f(...x, ...y) {}'</span>),
  <span class="hljs-regexp">/^SyntaxError: Rest parameter must be last formal parameter$/</span>
);
</pre>
  </li>
  <li>
    <p>A rest parameter must always come last. As a consequence, we can’t access the last parameter like this:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">eval</span>(<span class="hljs-string">'function f(...restParams, lastParam) {}'</span>),
  <span class="hljs-regexp">/^SyntaxError: Rest parameter must be last formal parameter$/</span>
);
</pre>
  </li>
</ul>
<h5 id="enforcing-a-certain-number-of-arguments-via-a-rest-parameter"><a class="heading-id-link" href="#enforcing-a-certain-number-of-arguments-via-a-rest-parameter">27.6.5.1 Enforcing a certain number of arguments via a rest parameter</a></h5>
<p>We can use a rest parameter to enforce a certain number of arguments. Take, for example, the following function:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createPoint</span>(<span class="hljs-params">x, y</span>) {
  <span class="hljs-keyword">return</span> {x, y};
    <span class="hljs-comment">// same as {x: x, y: y}</span>
}
</pre>
<p>This is how we force callers to always provide two arguments:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createPoint</span>(<span class="hljs-params">...args</span>) {
  <span class="hljs-keyword">if</span> (args.<span class="hljs-property">length</span> !== <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Please provide exactly 2 arguments!'</span>);
  }
  <span class="hljs-keyword">const</span> [x, y] = args; <span class="hljs-comment">// (A)</span>
  <span class="hljs-keyword">return</span> {x, y};
}
</pre>
<p>In line A, we access the elements of <code>args</code> via <a href="ch_destructuring.html#ch_destructuring"><em>destructuring</em></a>.</p>
<h4 id="named-parameters"><a class="heading-id-link" href="#named-parameters">27.6.6 Named parameters</a></h4>
<p><span id="index-entry-named-parameter"/></p>
<p>When someone calls a function, the arguments provided by the caller are assigned to the parameters received by the callee. Two common ways of performing the mapping are:</p>
<ol>
  <li>
    <p>Positional parameters: An argument is assigned to a parameter if they have the same position. A function call with only positional arguments looks as follows.</p>
<pre class="language-js">
<span class="hljs-title function_">selectEntries</span>(<span class="hljs-number">3</span>, <span class="hljs-number">20</span>, <span class="hljs-number">2</span>)
</pre>
  </li>
  <li>
    <p>Named parameters: An argument is assigned to a parameter if they have the same name. JavaScript doesn’t have named parameters, but we can simulate them. For example, this is a function call with only (simulated) named arguments:</p>
<pre class="language-js">
<span class="hljs-title function_">selectEntries</span>({<span class="hljs-attr">start</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">end</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">step</span>: <span class="hljs-number">2</span>})
</pre>
  </li>
</ol>
<p>Named parameters have several benefits:</p>
<ul>
  <li>
    <p>They lead to more self-explanatory code because each argument has a descriptive label. Just compare the two versions of <code>selectEntries()</code>: with the second one, it is much easier to see what happens.</p>
  </li>
  <li>
    <p>The order of the arguments doesn’t matter (as long as the names are correct).</p>
  </li>
  <li>
    <p>Handling more than one optional parameter is more convenient: callers can easily provide any subset of all optional parameters and don’t have to be aware of the ones they omit (with positional parameters, we have to fill in preceding optional parameters, with <code>undefined</code>).</p>
  </li>
</ul>
<h4 id="simulating-named-parameters"><a class="heading-id-link" href="#simulating-named-parameters">27.6.7 Simulating named parameters<span> <sup>ES6</sup></span></a></h4>
<p>JavaScript doesn’t have real named parameters. The official way of simulating them is via object literals:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">selectEntries</span>(<span class="hljs-params">{start=<span class="hljs-number">0</span>, end=-<span class="hljs-number">1</span>, step=<span class="hljs-number">1</span>}</span>) {
  <span class="hljs-keyword">return</span> {start, end, step};
}
</pre>
<p>This function uses <a href="ch_destructuring.html#ch_destructuring"><em>destructuring</em></a> to access the properties of its single parameter. The pattern it uses is an abbreviation for the following pattern:</p>
<pre class="language-js">
{<span class="hljs-attr">start</span>: start=<span class="hljs-number">0</span>, <span class="hljs-attr">end</span>: end=-<span class="hljs-number">1</span>, <span class="hljs-attr">step</span>: step=<span class="hljs-number">1</span>}
</pre>
<p>This destructuring pattern works for empty object literals:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">selectEntries</span>({})</span>
{ start: 0, end: -1, step: 1 }
</pre>
<p>But it does not work if we call the function without any parameters:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">selectEntries</span>()</span>
TypeError: Cannot read properties of undefined (reading 'start')
</pre>
<p>We can fix this by providing a default value for the whole pattern. This default value works the same as default values for simpler parameter definitions: if the parameter is missing, the default is used.</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">selectEntries</span>(<span class="hljs-params">{start=<span class="hljs-number">0</span>, end=-<span class="hljs-number">1</span>, step=<span class="hljs-number">1</span>} = {}</span>) {
  <span class="hljs-keyword">return</span> {start, end, step};
}
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title function_">selectEntries</span>(),
  { <span class="hljs-attr">start</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">end</span>: -<span class="hljs-number">1</span>, <span class="hljs-attr">step</span>: <span class="hljs-number">1</span> }
);
</pre>
<h4 id="spread-arguments"><a class="heading-id-link" href="#spread-arguments">27.6.8 Spreading (<code>...</code>) into function calls<span> <sup>ES6</sup></span></a></h4>
<p><span id="index-entry-spreading-into-a-function-call"/></p>
<p>If we put three dots (<code>...</code>) in front of the argument of a function call, then we <em>spread</em> it. That means that the argument must be <a href="ch_sync-iteration.html#ch_sync-iteration">an <em>iterable</em> object</a> and the iterated values all become arguments. In other words, a single argument is expanded into multiple arguments – for example:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x, y</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y);
}
<span class="hljs-keyword">const</span> someIterable = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];
<span class="hljs-title function_">func</span>(...someIterable);
  <span class="hljs-comment">// same as func('a', 'b')</span>
</pre>
<p>Output:</p>
<pre>
a
b
</pre>
<p>Spreading and rest parameters use the same syntax (<code>...</code>), but they serve opposite purposes:</p>
<ul>
  <li>
    Rest parameters are used when defining functions or methods. They collect arguments into Arrays.
  </li>
  <li>
    Spread arguments are used when calling functions or methods. They turn iterable objects into arguments.
  </li>
</ul>
<h5 id="example-spreading-into-mathmax"><a class="heading-id-link" href="#example-spreading-into-mathmax">27.6.8.1 Example: spreading into <code>Math.max()</code></a></h5>
<p><code>Math.max()</code> returns the largest one of its zero or more arguments. Alas, it can’t be used for Arrays, but spreading gives us a way out:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">3</span>)</span>
11
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...[-<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">3</span>])</span>
11
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(-<span class="hljs-number">1</span>, ...[-<span class="hljs-number">5</span>, <span class="hljs-number">11</span>], <span class="hljs-number">3</span>)</span>
11
</pre>
<h5 id="example-spreading-into-arrayprototypepush"><a class="heading-id-link" href="#example-spreading-into-arrayprototypepush">27.6.8.2 Example: spreading into <code>Array.prototype.push()</code></a></h5>
<p>Similarly, the Array method <code>.push()</code> destructively adds its zero or more parameters to the end of its Array. JavaScript has no method for destructively appending an Array to another one. Once again, we are saved by spreading:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];
<span class="hljs-keyword">const</span> arr2 = [<span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>];
<code/>
arr1.<span class="hljs-title function_">push</span>(...arr2);
assert.<span class="hljs-title function_">deepEqual</span>(arr1, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>]);
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercises: Parameter handling</strong></p>
  <div class="boxout-vspace"/>
  <ul>
    <li>
      Positional parameters: <code>exercises/callables/positional_parameters_test.mjs</code>
    </li>
    <li>
      Named parameters: <code>exercises/callables/named_parameters_test.mjs</code>
    </li>
  </ul>
</div>
<h3 id="methods-of-functions"><a class="heading-id-link" href="#methods-of-functions">27.7 Methods of functions: <code>.call()</code>, <code>.apply()</code>, <code>.bind()</code></a></h3>
<p>Functions are objects and have methods. In this section, we look at three of those methods: <code>.call()</code>, <code>.apply()</code>, and <code>.bind()</code>.</p>
<h4 id="Function.prototype.call"><a class="heading-id-link" href="#Function.prototype.call">27.7.1 The function method <code>.call()</code></a></h4>
<p>Each function <code>someFunc</code> has the following method:</p>
<pre class="language-js">
someFunc.<span class="hljs-title function_">call</span>(thisValue, arg1, arg2, arg3);
</pre>
<p>This method invocation is loosely equivalent to the following function call:</p>
<pre class="language-js">
<span class="hljs-title function_">someFunc</span>(arg1, arg2, arg3);
</pre>
<p>However, with <code>.call()</code>, we can also specify a value for <a href="#this-in-callables">the implicit parameter <code>this</code></a>. In other words: <code>.call()</code> makes the implicit parameter <code>this</code> explicit.</p>
<p>The following code demonstrates the use of <code>.call()</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x, y</span>) {
  <span class="hljs-keyword">return</span> [<span class="hljs-variable language_">this</span>, x, y];
}
<code/>
assert.<span class="hljs-title function_">deepEqual</span>(
  func.<span class="hljs-title function_">call</span>(<span class="hljs-string">'hello'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>),
  [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]
);
</pre>
<p>As we have seen before, if we function-call an ordinary function, its <code>this</code> is <code>undefined</code>:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title function_">func</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>),
  [<span class="hljs-literal">undefined</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]
);
</pre>
<p>Therefore, the previous function call is equivalent to:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">deepEqual</span>(
  func.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>),
  [<span class="hljs-literal">undefined</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]
);
</pre>
<p>In arrow functions, the value for <code>this</code> provided via <code>.call()</code> (or other means) is ignored.</p>
<h4 id="Function.prototype.apply"><a class="heading-id-link" href="#Function.prototype.apply">27.7.2 The function method <code>.apply()</code></a></h4>
<p>Each function <code>someFunc</code> has the following method:</p>
<pre class="language-js">
someFunc.<span class="hljs-title function_">apply</span>(thisValue, [arg1, arg2, arg3]);
</pre>
<p>This method invocation is loosely equivalent to the following function call (which uses <a href="#spread-arguments">spreading</a>):</p>
<pre class="language-js">
<span class="hljs-title function_">someFunc</span>(...[arg1, arg2, arg3]);
</pre>
<p>However, with <code>.apply()</code>, we can also specify a value for <a href="#this-in-callables">the implicit parameter <code>this</code></a>.</p>
<p>The following code demonstrates the use of <code>.apply()</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x, y</span>) {
  <span class="hljs-keyword">return</span> [<span class="hljs-variable language_">this</span>, x, y];
}
<code/>
<span class="hljs-keyword">const</span> args = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];
assert.<span class="hljs-title function_">deepEqual</span>(
  func.<span class="hljs-title function_">apply</span>(<span class="hljs-string">'hello'</span>, args),
  [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]
);
</pre>
<h4 id="Function.prototype.bind"><a class="heading-id-link" href="#Function.prototype.bind">27.7.3 The function method <code>.bind()</code></a></h4>
<p><code>.bind()</code> is another method of function objects. This method is invoked as follows:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> boundFunc = someFunc.<span class="hljs-title function_">bind</span>(thisValue, arg1, arg2);
</pre>
<p><code>.bind()</code> returns a new function <code>boundFunc()</code>. Calling that function invokes <code>someFunc()</code> with <code>this</code> set to <code>thisValue</code> and these parameters: <code>arg1</code>, <code>arg2</code>, followed by the parameters of <code>boundFunc()</code>.</p>
<p>That is, the following two function calls are equivalent:</p>
<pre class="language-js">
<span class="hljs-title function_">boundFunc</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>)
someFunc.<span class="hljs-title function_">call</span>(thisValue, arg1, arg2, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>)
</pre>
<h5 id="an-alternative-to-bind"><a class="heading-id-link" href="#an-alternative-to-bind">27.7.3.1 An alternative to <code>.bind()</code></a></h5>
<p>Another way of pre-filling <code>this</code> and parameters is via an arrow function:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> <span class="hljs-title function_">boundFunc2</span> = (<span class="hljs-params">...args</span>) =&gt;
  someFunc.<span class="hljs-title function_">call</span>(thisValue, arg1, arg2, ...args);
</pre>
<h5 id="an-implementation-of-bind"><a class="heading-id-link" href="#an-implementation-of-bind">27.7.3.2 An implementation of <code>.bind()</code></a></h5>
<p>Considering the previous section, <code>.bind()</code> can be implemented as a real function as follows:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">bind</span>(<span class="hljs-params">func, thisValue, ...boundArgs</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span>
    func.<span class="hljs-title function_">call</span>(thisValue, ...boundArgs, ...args);
}
</pre>
<h5 id="example-binding-a-real-function"><a class="heading-id-link" href="#example-binding-a-real-function">27.7.3.3 Example: binding a real function</a></h5>
<p>Using <code>.bind()</code> for real functions is somewhat unintuitive because we have to provide a value for <code>this</code>. Given that it is <code>undefined</code> during function calls, it is usually set to <code>undefined</code> or <code>null</code>.</p>
<p>In the following example, we create <code>add8()</code>, a function that has one parameter, by binding the first parameter of <code>add()</code> to <code>8</code>.</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) {
  <span class="hljs-keyword">return</span> x + y;
}
<code/>
<span class="hljs-keyword">const</span> add8 = add.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-number">8</span>);
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">add8</span>(<span class="hljs-number">1</span>), <span class="hljs-number">9</span>);
</pre>

    
      
</body>
</html>