- en: 10 Using web streams on Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 在 Node.js 上使用 web 流
- en: 原文：[https://exploringjs.com/nodejs-shell-scripting/ch_web-streams.html](https://exploringjs.com/nodejs-shell-scripting/ch_web-streams.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/nodejs-shell-scripting/ch_web-streams.html](https://exploringjs.com/nodejs-shell-scripting/ch_web-streams.html)
- en: '* * *'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 10.1 [What are web streams?](ch_web-streams.html#what-are-web-streams)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.1 [什么是 web 流？](ch_web-streams.html#what-are-web-streams)
- en: 10.1.1 [Kinds of streams](ch_web-streams.html#kinds-of-streams)
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.1.1 [流的种类](ch_web-streams.html#kinds-of-streams)
- en: 10.1.2 [Pipe chains](ch_web-streams.html#pipe-chains)
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.1.2 [管道链](ch_web-streams.html#pipe-chains)
- en: 10.1.3 [Backpressure](ch_web-streams.html#backpressure)
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.1.3 [背压](ch_web-streams.html#backpressure)
- en: 10.1.4 [Support for web streams in Node.js](ch_web-streams.html#support-for-web-streams-in-node.js)
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.1.4 [Node.js 中对 web 流的支持](ch_web-streams.html#support-for-web-streams-in-node.js)
- en: 10.2 [Reading from ReadableStreams](ch_web-streams.html#reading-from-readablestreams)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.2 [从 ReadableStreams 读取](ch_web-streams.html#reading-from-readablestreams)
- en: 10.2.1 [Consuming ReadableStreams via Readers](ch_web-streams.html#ReadableStream-Reader)
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.2.1 [通过 Readers 消费 ReadableStreams](ch_web-streams.html#ReadableStream-Reader)
- en: 10.2.2 [Consuming ReadableStreams via asynchronous iteration](ch_web-streams.html#ReadableStream-async-iteration)
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.2.2 [通过异步迭代消费 ReadableStreams](ch_web-streams.html#ReadableStream-async-iteration)
- en: 10.2.3 [Piping ReadableStreams to WritableStreams](ch_web-streams.html#piping-ReadableStream-to-WritableStream)
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.2.3 [将 ReadableStreams 管道到 WritableStreams](ch_web-streams.html#piping-ReadableStream-to-WritableStream)
- en: 10.3 [Turning data sources into ReadableStreams via wrapping](ch_web-streams.html#turning-data-sources-into-readablestreams-via-wrapping)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.3 [通过包装将数据源转换为 ReadableStreams](ch_web-streams.html#turning-data-sources-into-readablestreams-via-wrapping)
- en: 10.3.1 [A first example of implementing an underlying source](ch_web-streams.html#readablestream-enqueue-strings)
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.3.1 [实现底层源的第一个示例](ch_web-streams.html#readablestream-enqueue-strings)
- en: 10.3.2 [Using a ReadableStream to wrap a push source or a pull source](ch_web-streams.html#using-a-readablestream-to-wrap-a-push-source-or-a-pull-source)
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.3.2 [使用 ReadableStream 包装推送源或拉取源](ch_web-streams.html#using-a-readablestream-to-wrap-a-push-source-or-a-pull-source)
- en: 10.4 [Writing to WritableStreams](ch_web-streams.html#writing-to-WritableStream)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.4 [写入 WritableStreams](ch_web-streams.html#writing-to-WritableStream)
- en: 10.4.1 [Writing to WritableStreams via Writers](ch_web-streams.html#writablestream-writer)
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.4.1 [通过 Writers 写入 WritableStreams](ch_web-streams.html#writablestream-writer)
- en: 10.4.2 [Piping to WritableStreams](ch_web-streams.html#piping-to-writablestream)
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.4.2 [管道到 WritableStreams](ch_web-streams.html#piping-to-writablestream)
- en: 10.5 [Turning data sinks into WritableStreams via wrapping](ch_web-streams.html#turning-data-sinks-into-writablestreams-via-wrapping)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.5 [通过包装将数据汇转换为 WritableStreams](ch_web-streams.html#turning-data-sinks-into-writablestreams-via-wrapping)
- en: '10.5.1 [Example: tracing a ReadableStream](ch_web-streams.html#example-tracing-a-readablestream)'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.5.1 [示例：跟踪 ReadableStream](ch_web-streams.html#example-tracing-a-readablestream)
- en: '10.5.2 [Example: collecting chunks written to a WriteStream in a string](ch_web-streams.html#StringWritableStream)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.5.2 [示例：收集写入字符串的 WriteStream 块](ch_web-streams.html#StringWritableStream)
- en: 10.6 [Using TransformStreams](ch_web-streams.html#transformstream)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.6 [使用 TransformStreams](ch_web-streams.html#transformstream)
- en: 10.6.1 [Standard TransformStreams](ch_web-streams.html#standard-transformstreams)
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.6.1 [标准 TransformStreams](ch_web-streams.html#standard-transformstreams)
- en: 10.7 [Implementing custom TransformStreams](ch_web-streams.html#implementing-custom-transformstreams)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.7 [实现自定义 TransformStreams](ch_web-streams.html#implementing-custom-transformstreams)
- en: '10.7.1 [Example: transforming a stream of arbitrary chunks to a stream of lines](ch_web-streams.html#ChunksToLinesStream)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.7.1 [示例：将任意块的流转换为行流](ch_web-streams.html#ChunksToLinesStream)
- en: '10.7.2 [Tip: async generators are also great for transforming streams](ch_web-streams.html#transforming-web-streams-via-generators)'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.7.2 [提示：异步生成器也非常适合转换流](ch_web-streams.html#transforming-web-streams-via-generators)
- en: 10.8 [A closer look at backpressure](ch_web-streams.html#a-closer-look-at-backpressure)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.8 [更深入地了解背压](ch_web-streams.html#a-closer-look-at-backpressure)
- en: 10.8.1 [Signalling backpressure](ch_web-streams.html#signalling-backpressure)
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.8.1 [信号背压](ch_web-streams.html#signalling-backpressure)
- en: 10.8.2 [Reacting to backpressure](ch_web-streams.html#reacting-to-backpressure)
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.8.2 [对背压的反应](ch_web-streams.html#reacting-to-backpressure)
- en: 10.9 [Byte streams](ch_web-streams.html#byte-streams)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.9 [字节流](ch_web-streams.html#byte-streams)
- en: 10.9.1 [Readable byte streams](ch_web-streams.html#readable-byte-streams)
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.9.1 [可读字节流](ch_web-streams.html#readable-byte-streams)
- en: '10.9.2 [Example: an infinite readable byte stream filled with random data](ch_web-streams.html#example-an-infinite-readable-byte-stream-filled-with-random-data)'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.9.2 [示例：填充随机数据的无限可读字节流](ch_web-streams.html#example-an-infinite-readable-byte-stream-filled-with-random-data)
- en: '10.9.3 [Example: compressing a readable byte stream](ch_web-streams.html#example-compressing-a-readable-byte-stream)'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.9.3 [示例：压缩可读字节流](ch_web-streams.html#example-compressing-a-readable-byte-stream)
- en: '10.9.4 [Example: reading a web page via `fetch()`](ch_web-streams.html#example-reading-a-web-page-via-fetch)'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.9.4 [示例：通过 `fetch()` 读取网页](ch_web-streams.html#example-reading-a-web-page-via-fetch)
- en: 10.10 [Node.js-specific helpers](ch_web-streams.html#node.js-specific-helpers)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.10 [Node.js 特定的辅助函数](ch_web-streams.html#node.js-specific-helpers)
- en: 10.11 [Further reading](ch_web-streams.html#further-reading-1)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.11 [进一步阅读](ch_web-streams.html#further-reading-1)
- en: '* * *'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[*Web streams*](https://streams.spec.whatwg.org/) are a standard for *streams*
    that is now supported on all major web platforms: web browsers, Node.js, and Deno.
    (Streams are an abstraction for reading and writing data sequentially in small
    pieces from all kinds of sources – files, data hosted on servers, etc.)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[*Web 流*](https://streams.spec.whatwg.org/) 是一种标准的 *流*，现在在所有主要的 web 平台上都得到支持：web
    浏览器、Node.js 和 Deno。（流是一种从各种来源顺序读取和写入数据的抽象，例如文件、托管在服务器上的数据等。）'
- en: For example, [the global function `fetch()`](https://developer.mozilla.org/en-US/docs/Web/API/fetch)
    (which downloads online resources) asynchronously returns a Response which has
    a property `.body` with a web stream.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[全局函数 `fetch()`](https://developer.mozilla.org/en-US/docs/Web/API/fetch)（用于下载在线资源）异步返回一个具有
    web 流属性 `.body` 的 Response。
- en: This chapter covers web streams on Node.js, but most of what we learn applies
    to all web platforms that support them.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了 Node.js 上的 web 流，但我们所学的大部分内容都适用于支持它们的所有 web 平台。
- en: 10.1 What are web streams?
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start with an overview of a few fundamentals of web streams. Afterwards,
    we’ll quickly move on to examples.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Streams are a data structure for accessing data such as:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Files
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data hosted on web servers
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Etc.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two of their benefits are:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: We can work with large amounts of data because streams allow us to split them
    up into smaller pieces (so-called *chunks*) which we can process one at a time.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can work with the same data structure, streams, while processing different
    data. That makes it easier to reuse code.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Web streams*](https://streams.spec.whatwg.org/#intro) (“web” is often omitted)
    are a relatively new standard that originated in web browsers but is now also
    supported by Node.js and Deno (as shown in this [MDN compatibility table](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API#browser_compatibility)).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'In web streams, chunks are usually either:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Text streams: Strings'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Binary streams: Uint8Arrays ([a kind of TypedArray](https://exploringjs.com/impatient-js/ch_typed-arrays.html))'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.1.1 Kinds of streams
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are three main kinds of web streams:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: A ReadableStream is used to read data from a *source*. Code that does that is
    called a *consumer*.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A WritableStream is used to write data to a *sink*. Code that does that is called
    a *producer*.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A TransformStream consists of two streams:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It receives input from its *writable side*, a WritableStream.
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It sends output to its *readable side*, a ReadableStream.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The idea is to transform data by “piping it through” a TransformStream. That
    is, we write data to the writable side and read transformed data from the readable
    side. The following TransformStreams are built into most JavaScript platforms
    (more on them later):'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Because JavaScript strings are UTF-16 encoded, UTF-8 encoded data is treated
    as binary in JavaScript. A `TextDecoderStream` converts such data to strings.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A `TextEncoderStream` converts JavaScript strings to UTF-8 data.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A ``CompressionStream` compresses binary data to GZIP and other compression
    formats.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A `DecompressionStream` decompresses binary data from GZIP and other compression
    formats.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ReadableStreams, WritableStreams and TransformStreams can be used to transport
    text or binary data. We’ll mostly do the former in this chapter. *Byte streams*
    for binary data are briefly mentioned at the end.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 10.1.2 Pipe chains
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Piping* is an operation that lets us *pipe* a ReadableStream to a WritableStream:
    As long as the ReadableStream produces data, this operation reads that data and
    writes it to the WritableStream. If we connect just two streams, we get a convenient
    way of transferring data from one location to another (e.g. to copy a file). However,
    we can also connect more than two streams and get *pipe chains* that can process
    data in a variety of ways. This is an example of a pipe chain:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: It starts with a ReadableStream.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next are one or more TransformStreams.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chain ends with a WritableStream.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A ReadableStream is connected to a TransformStream by piping the former to the
    writable side of the latter. Similarly, a TransformStream is connected to another
    TransformStream by piping the readable side of the former to the writable side
    of the latter. And a TransformStream is connected to a WritableStream by piping
    the readable side of the former to the latter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 10.1.3 Backpressure
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One problem in pipe chains is that a member may receive more data than it can
    handle at the moment. *Backpressure* is a technique for solving this problem:
    It enables a receiver of data to tell its sender that it should temporarily stop
    sending data so that the receiver doesn’t get overwhelmed.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to look at backpressure is as a signal that travels backwards through
    a pipe chain, from a member that is getting overwhelmed to the beginning of the
    chain. As an example, consider the following pipe chain:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is how backpressure travels through this chain:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Initially, the WriteableStream signals that it can’t process more data at the
    moment.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pipe stops reading from the TransformStream.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道停止从TransformStream中读取。
- en: Input accumulates inside the TransformStream (which is buffered).
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入在TransformStream中积累（被缓冲）。
- en: The TransformStream signals that it’s full.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TransformStream发出满的信号。
- en: The pipe stops reading from the ReadableStream.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道停止从ReadableStream中读取。
- en: We have reached the beginning of the pipe chain. Therefore, no data accumulates
    inside the ReadableStream (which is also buffered) and the WriteableStream has
    time to recover. Once it does, it signals that it is ready to receive data again.
    That signal also travels back through the chain until it reaches the ReadableStream
    and data processing resumes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达管道链的开头。因此，在ReadableStream中没有数据积累（也被缓冲），WritableStream有时间恢复。一旦它恢复，它会发出信号表明它已准备好再次接收数据。该信号也会通过链返回，直到它到达ReadableStream，数据处理恢复。
- en: In this first look at backpressure, several details were omitted to make things
    easier to understand. These will be covered later.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这第一次对背压的探讨中，为了让事情更容易理解，省略了一些细节。这些将在以后进行讨论。
- en: 10.1.4 Support for web streams in Node.js
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.4 Node.js中对web流的支持
- en: 'In Node.js, web streams are available from two sources:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，Web流可以从两个来源获得：
- en: From [module `'node:stream/web'`](https://nodejs.org/api/webstreams.html)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[模块`'node:stream/web'`](https://nodejs.org/api/webstreams.html)
- en: Via global variables (like in web browsers)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过全局变量（就像在Web浏览器中）
- en: 'At the moment, only one API has direct support for web streams in Node.js –
    [the Fetch API](https://nodejs.org/api/globals.html#fetch):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，只有一个API在Node.js中直接支持web流 – [Fetch API](https://nodejs.org/api/globals.html#fetch)：
- en: '[PRE1]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For other things, we need to use one of the following static methods in module
    `''node:stream''` to either convert a Node.js stream to a web stream or vice versa:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他事情，我们需要使用模块`'node:stream'`中以下静态方法之一，将Node.js流转换为Web流，反之亦然：
- en: 'Node.js Readables can be converted to and from WritableStreams:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js的Readable可以转换为WritableStreams，反之亦然：
- en: '`Readable.toWeb(nodeReadable)`'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Readable.toWeb(nodeReadable)`'
- en: '`Readable.fromWeb(webReadableStream, options?)`'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Readable.fromWeb(webReadableStream, options?)`'
- en: 'Node.js Writables can be converted to and from ReadableStreams:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js的Writable可以转换为ReadableStreams，反之亦然：
- en: '`Writable.toWeb(nodeWritable)`'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Writable.toWeb(nodeWritable)`'
- en: '`Writable.fromWeb(webWritableStream, options?)`'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Writable.fromWeb(webWritableStream, options?)`'
- en: 'Node.js Duplexes can be converted to and from TransformStreams:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js的Duplex可以转换为TransformStreams，反之亦然：
- en: '`Duplex.toWeb(nodeDuplex)`'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Duplex.toWeb(nodeDuplex)`'
- en: '`Duplex.fromWeb(webTransformStream, options?)`'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Duplex.fromWeb(webTransformStream, options?)`'
- en: 'One other API partially supports web streams: FileHandles have the method [`.readableWebStream()`](https://nodejs.org/dist/latest-v18.x/docs/api/fs.html#filehandlereadablewebstream).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个API部分支持web流：FileHandles有方法[`.readableWebStream()`](https://nodejs.org/dist/latest-v18.x/docs/api/fs.html#filehandlereadablewebstream)。
- en: 10.2 Reading from ReadableStreams
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2 从ReadableStreams中读取
- en: 'ReadableStreams let us read chunks of data from various sources. They have
    the following type (feel free to skim this type and the explanations of its properties;
    they will be explained again when we encounter them in examples):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ReadableStreams让我们从各种来源读取数据块。它们具有以下类型（随意浏览此类型及其属性的解释；当我们在示例中遇到它们时，它们将再次被解释）：
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Explanations of these properties:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性的解释：
- en: '`.getReader()` returns a Reader – an object through which we can read from
    a ReadableStream. ReadableStreams returning Readers is similar to [iterables](https://exploringjs.com/impatient-js/ch_sync-iteration.html)
    returning iterators.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.getReader()`返回一个Reader – 通过它我们可以从ReadableStream中读取。ReadableStreams返回Readers类似于[可迭代对象](https://exploringjs.com/impatient-js/ch_sync-iteration.html)返回迭代器。'
- en: '`.locked`: There can only be one active Reader per ReadableStream at a time.
    While one Reader is in use, the ReadableStream is locked and `.getReader()` cannot
    be invoked.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.locked`: 一次只能有一个活动的Reader读取ReadableStream。当一个Reader正在使用时，ReadableStream被锁定，无法调用`.getReader()`。'
- en: '`[Symbol.asyncIterator](https://exploringjs.com/impatient-js/ch_async-iteration.html)`:
    This method makes ReadableStreams [asynchronously iterable](https://exploringjs.com/impatient-js/ch_async-iteration.html).
    It is currently only implemented on some platforms.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Symbol.asyncIterator](https://exploringjs.com/impatient-js/ch_async-iteration.html)`:
    这个方法使得ReadableStreams可以[异步迭代](https://exploringjs.com/impatient-js/ch_async-iteration.html)。目前只在一些平台上实现。'
- en: '`.cancel(reason)` cancels the stream because the consumer isn’t interested
    in it anymore. `reason` is passed on to the `.cancel()` method of the ReadableStream’s
    *underlying source* (more on that later). The returned Promise fulfills when this
    operation is done.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.cancel(reason)`取消流，因为消费者对它不再感兴趣。`reason`被传递给ReadableStream的*底层源*的`.cancel()`方法（稍后会详细介绍）。返回的Promise在此操作完成时实现。'
- en: '`.pipeTo()` feeds the contents of its ReadableStream to a WritableStream. The
    returned Promise fulfills when this operation is done. `.pipeTo()` ensures that
    backpressure, closing, errors, etc. are all correctly propagated through a pipe
    chain. We can specify options via its second parameter:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.pipeTo()`将其ReadableStream的内容传送到WritableStream。返回的Promise在此操作完成时实现。`.pipeTo()`确保背压、关闭、错误等都正确地通过管道链传播。我们可以通过它的第二个参数指定选项：'
- en: '`.signal` lets us pass an AbortSignal to this method, which enables us to abort
    piping via an AbortController.'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.signal`让我们向这个方法传递一个AbortSignal，这使我们能够通过AbortController中止管道传输。'
- en: '`.preventClose`: If `true`, it prevents the WritableStream from being closed
    when the ReadableStream is closed. That is useful when we want to pipe more than
    one ReadableStream to the same WritableStream.'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.preventClose`: 如果为`true`，它会阻止在ReadableStream关闭时关闭WritableStream。当我们想要将多个ReadableStream管道到同一个WritableStream时，这是有用的。'
- en: The remaining options are beyond the scope of this chapter. They are documented
    [in the web streams specification](https://streams.spec.whatwg.org/#rs-prototype).
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余选项超出了本章的范围。它们在[web流规范](https://streams.spec.whatwg.org/#rs-prototype)中有文档记录。
- en: '`.pipeThrough()` connects its ReadableStream to a ReadableWritablePair (roughly:
    a TransformStream, more on that later). It returns the resulting ReadableStream
    (i.e., the readable side of the ReadableWritablePair).'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.pipeThrough()`将其ReadableStream连接到一个ReadableWritablePair（大致是一个TransformStream，稍后会详细介绍）。它返回生成的ReadableStream（即ReadableWritablePair的可读端）。'
- en: 'The following subsections cover three ways of consuming ReadableStreams:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节涵盖了三种消费ReadableStreams的方式：
- en: Reading via Readers
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Readers进行读取
- en: Reading via asynchronous iteration
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过异步迭代进行读取
- en: Piping ReadableStreams to WritableStreams
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将ReadableStreams连接到WritableStreams
- en: 10.2.1 Consuming ReadableStreams via Readers
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.1通过Reader消费ReadableStreams
- en: 'We can use *Readers* to read data from ReadableStreams. They have the following
    type (feel free to skim this type and the explanations of its properties; they
    will be explained again when we encounter them in examples):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用*Readers*从ReadableStreams中读取数据。它们具有以下类型（随意浏览此类型及其属性的解释；当我们在示例中遇到它们时，它们将再次被解释）：
- en: '[PRE3]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Explanations of these properties:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性的解释：
- en: '`.closed`: This Promise is fulfilled after the stream is closed. It is rejected
    if the stream errors or if a Reader’s lock is released before the stream is closed.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.closed`：此Promise在流关闭后被满足。如果流出现错误或者在流关闭之前Reader的锁被释放，它将被拒绝。'
- en: '`.cancel()`: In an active Reader, this method cancels the associated ReadableStream.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.cancel()`：在活动的Reader中，此方法取消关联的ReadableStream。'
- en: '`.releaseLock()` deactivates the Reader and unlocks its stream.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.releaseLock()`停用Reader并解锁其流。'
- en: '`.read()` returns a Promise for a ReadableStreamReadResult (a wrapped chunk)
    which has two properties:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.read()`返回一个Promise，用于ReadableStreamReadResult（一个包装的块），它有两个属性：'
- en: '`.done` is a boolean that is `false` as long as chunks can be read and `true`
    after the last chunk.'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.done`是一个布尔值，只要可以读取块，就为`false`，在最后一个块之后为`true`。'
- en: '`.value` is the chunk (or `undefined` after the last chunk).'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.value`是块（或在最后一个块之后是`undefined`）。'
- en: 'ReadableStreamReadResult may look familiar if you know how iteration works:
    ReadableStreams are similar to iterables, Readers are similar to iterators, and
    ReadableStreamReadResults are similar to the objects returned by the iterator
    method `.next()`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您了解迭代的工作原理，ReadableStreamReadResult可能会很熟悉：ReadableStreams类似于可迭代对象，Readers类似于迭代器，而ReadableStreamReadResults类似于迭代器方法`.next()`返回的对象。
- en: 'The following code demonstrates the protocol for using Readers:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了使用Readers的协议：
- en: '[PRE4]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Getting a Reader.** We can’t read directly from `readableStream`, we first
    need to acquire a *Reader* (line A). Each ReadableStream can have at most one
    Reader. After a Reader was acquired, `readableStream` is locked (line B). Before
    we can call `.getReader()` again, we must call `.releaseLock()` (line D).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取Reader。**我们不能直接从`readableStream`中读取，我们首先需要获取一个*Reader*（行A）。每个ReadableStream最多可以有一个Reader。获取Reader后，`readableStream`被锁定（行B）。在我们可以再次调用`.getReader()`之前，我们必须调用`.releaseLock()`（行D）。'
- en: '**Reading chunks.** `.read()` returns a Promise for an object with the properties
    `.done` and `.value` (line C). After the last chunk was read, `.done` is `true`.
    This approach is similar to how [asynchronous iteration](https://exploringjs.com/impatient-js/ch_async-iteration.html)
    works in JavaScript.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**读取块。**`.read()`返回一个带有属性`.done`和`.value`的对象的Promise（行C）。在读取最后一个块之后，`.done`为`true`。这种方法类似于JavaScript中[异步迭代](https://exploringjs.com/impatient-js/ch_async-iteration.html)的工作方式。'
- en: '10.2.1.1 Example: reading a file via a ReadableStream'
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.2.1.1示例：通过ReadableStream读取文件
- en: 'In the following example, we read chunks (strings) from a text file `data.txt`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们从文本文件`data.txt`中读取块（字符串）：
- en: '[PRE5]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We are converting a Node.js Readable to a web ReadableStream (line A). Then
    we use the previously explained protocol to read the chunks.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将Node.js Readable转换为web ReadableStream（行A）。然后我们使用先前解释的协议来读取块。
- en: '10.2.1.2 Example: assembling a string with the contents of a ReadableStream'
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.2.1.2示例：使用ReadableStream内容组装字符串
- en: 'In the next example, we concatenate all chunks of a ReadableStream into a string
    and return it:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将所有ReadableStream的块连接成一个字符串并返回它：
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Conveniently, the `finally` clause is always executed – now matter how we leave
    the `try` clause. That is, the lock is correctly released (line B) if we return
    a result (line A).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，`finally`子句总是被执行 - 无论我们如何离开`try`子句。也就是说，如果我们返回一个结果（行A），锁将被正确释放（行B）。
- en: 10.2.2 Consuming ReadableStreams via asynchronous iteration
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.2通过异步迭代消费ReadableStreams
- en: 'ReadableStreams can also be consumed via [asynchronous iteration](https://exploringjs.com/impatient-js/ch_async-iteration.html):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ReadableStreams也可以通过[异步迭代](https://exploringjs.com/impatient-js/ch_async-iteration.html)进行消费：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Thankfully, the `for-await-of` loop handles all the details of asynchronous
    iteration for us:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 值得庆幸的是，`for-await-of`循环为我们处理了异步迭代的所有细节：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '10.2.2.1 Example: using asynchronous iteration to read a stream'
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.2.2.1示例：使用异步迭代读取流
- en: 'Let’s redo our previous attempt to read text from a file. This time, we use
    asynchronous iteration instead of a Reader:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新尝试从文件中读取文本。这次，我们使用异步迭代而不是Reader：
- en: '[PRE9]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '10.2.2.2 Example: assembling a string with the contents of a ReadableStream'
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.2.2.2示例：使用ReadableStream内容组装字符串
- en: 'We have previously used a Reader to assemble a string with the contents of
    a ReadableStream. With asynchronous iteration, the code becomes simpler:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以前使用Reader来组装一个包含ReadableStream内容的字符串。有了异步迭代，代码变得更简单了：
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '10.2.2.3 Caveat: Browsers don’t support asynchronous iteration over ReadableStreams'
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.2.2.3注意事项：浏览器不支持对ReadableStreams进行异步迭代
- en: 'At the moment, Node.js and Deno support asynchronous iteration over ReadableStreams
    but web browsers don’t: There is [a GitHub issue](https://github.com/whatwg/streams/issues/778)
    that links to bug reports.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Node.js和Deno支持对ReadableStreams进行异步迭代，但Web浏览器不支持：有[一个GitHub问题](https://github.com/whatwg/streams/issues/778)链接到错误报告。
- en: 'Given that it’s not yet completely clear how async iteration will be supported
    on browsers, wrapping is a safer choice than polyfilling. The following code is
    based on [a suggestion in the Chromium bug report](https://bugs.chromium.org/p/chromium/issues/detail?id=929585#c10):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于尚不完全清楚浏览器将如何支持异步迭代，包装比填充更安全。以下代码基于[Chromium bug报告中的建议](https://bugs.chromium.org/p/chromium/issues/detail?id=929585#c10)：
- en: '[PRE11]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 10.2.3 Piping ReadableStreams to WritableStreams
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.3 将可读流导入可写流
- en: 'ReadableStreams have two methods for piping:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 可读流有两种管道方法：
- en: '`readableStream.pipeTo(writeableStream)` synchronously returns a Promise `p`.
    It asynchronously reads all chunks of `readableStream` and writes them to `writableStream`.
    When it is done, it fulfills `p`.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readableStream.pipeTo(writeableStream)`同步返回一个Promise `p`。它异步读取`readableStream`的所有块，并将它们写入`writableStream`。完成后，它会实现`p`。'
- en: We’ll see examples of `.pipeTo()` when we explore WritableStreams, as it provides
    a convenient way to transfer data into them.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们探索可写流时，我们将看到`.pipeTo()`的示例，因为它提供了一种方便的方式将数据传输到其中。
- en: '`readableStream.pipeThrough(transformStream)` pipes `readableStream` into `transformStream.writable`
    and returns `transformStream.readable` (every TransformStream has these properties
    that refer to its writable side and its readable side). Another way to view this
    operation is that we create a new ReadableStream by connecting a `transformStream`
    to a `readableStream`.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readableStream.pipeThrough(transformStream)`将`readableStream`导入`transformStream.writable`并返回`transformStream.readable`（每个TransformStream都有这些属性，它们指向其可写侧和可读侧）。另一种看待这个操作的方式是，我们通过连接`transformStream`到`readableStream`创建一个新的可读流。'
- en: We’ll see examples of `.pipeThrough()` when we explore TransformStreams, as
    this method is the main way in which they are used.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们探索TransformStreams时，我们将看到`.pipeThrough()`的示例，因为这是它们主要使用的方法。
- en: 10.3 Turning data sources into ReadableStreams via wrapping
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3 将数据源通过包装转换为可读流
- en: 'If we want to read an external source via a ReadableStream, we can wrap it
    in an adapter object and pass that object to the `ReadableStream` constructor.
    The adapter object is called the *underlying source* of the ReadableStream (queuing
    strategies are explained later, when we take a closer look at backpressure):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想通过一个可读流读取外部源，我们可以将其包装在一个适配器对象中，并将该对象传递给`ReadableStream`构造函数。适配器对象被称为可读流的*底层源*（当我们更仔细地看backpressure时，将解释排队策略）：
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is the type of underlying sources (feel free to skim this type and the
    explanations of its properties; they will be explained again when we encounter
    them in examples):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是底层源的类型（随意浏览此类型及其属性的解释；当我们在示例中遇到它们时，它们将再次解释）：
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is when the ReadableStream calls these methods:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当可读流调用这些方法时：
- en: '`.start(controller)` is called immediately after we invoke the constructor
    of `ReadableStream`.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用`ReadableStream`的构造函数后立即调用`.start(controller)`。
- en: '`.pull(controller)` is called whenever there is room in the internal queue
    of the ReadableStream. It is called repeatedly until the queue is full again.
    This method will only be called after `.start()` is finished. If `.pull()` doesn’t
    enqueue anything, it won’t be called again.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当可读流的内部队列中有空间时，都会调用`.pull(controller)`。直到队列再次满了为止，它会被重复调用。此方法只会在`.start()`完成后调用。如果`.pull()`没有入队任何内容，它将不会再次被调用。
- en: '`.cancel(reason)` is called if the consumer of a ReadableStream cancels it
    via `readableStream.cancel()` or `reader.cancel()`. `reason` is the value that
    was passed to these methods.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可读流的消费者通过`readableStream.cancel()`或`reader.cancel()`取消它，将调用`.cancel(reason)`。`reason`是传递给这些方法的值。
- en: Each of these methods can return a Promise and no further steps will be taken
    until the Promise is settled. That is useful if we want to do something asynchronous.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的每一个都可以返回一个Promise，并且在Promise解决之前不会采取进一步的步骤。如果我们想要做一些异步操作，这是有用的。
- en: 'The parameter `controller` of `.start()` and `.pull()` lets them access the
    stream. It has the following type:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`.start()`和`.pull()`的参数`controller`让它们访问流。它具有以下类型：'
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For now, chunks are strings. We’ll later get to byte streams, where Uint8Arrays
    are common. This is what the methods do:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，块是字符串。我们稍后将介绍字节流，其中Uint8Arrays很常见。这些方法的作用是：
- en: '`.enqueue(chunk)` adds `chunk` to the ReadableStream’s internal queue.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.enqueue(chunk)`将`chunk`添加到可读流的内部队列。'
- en: '`.desiredSize` indicates how much room there is in the queue into which `.enqueue()`
    writes. It is zero if the queue is full and negative if it has exceeded its maximum
    size. Therefore, if the desired size is zero or negative, we have to stop enqueuing.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.desiredSize`指示`.enqueue()`写入的队列中有多少空间。如果队列已满，则为零，如果超过了最大大小，则为负。因此，如果期望大小为零或负，则我们必须停止入队。'
- en: If a stream is closed, its desired size is zero.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果流关闭，其期望大小为零。
- en: If a stream is in error mode, its desired size is `null`.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果流处于错误模式，其期望大小为`null`。
- en: '`.close()` closes the ReadableStream. Consumers will still be able to empty
    the queue, but after that, the stream ends. It’s important that an underlying
    source calls this method – otherwise, reading its stream will never finish.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.close()`关闭可读流。消费者仍然可以清空队列，但之后，流将结束。底层源调用此方法很重要-否则，读取其流将永远不会结束。'
- en: '`.error(err)` puts the stream in an error mode: All future interactions with
    it will fail with the error value `err`.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.error(err)`将流置于错误模式：以后与它的所有交互都将以错误值`err`失败。'
- en: 10.3.1 A first example of implementing an underlying source
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.1 实现底层源的第一个示例
- en: In our first example of implementing an underlying source, we only provide method
    `.start()`. We’ll see use cases for `.pull()` in the next subsection.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现底层源的第一个示例中，我们只提供了`.start()`方法。我们将在下一小节中看到`.pull()`的用例。
- en: '[PRE15]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We use the controller to create a stream with two chunks (line A and line B).
    It’s important that we close the stream (line C). Otherwise, the `for-await-of`
    loop would never finish!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用控制器创建一个具有两个块（行A和行B）的流。关闭流很重要（行C）。否则，`for-await-of`循环永远不会结束！
- en: 'Note that this way of enqueuing isn’t completely safe: There is a risk of exceding
    the capacity of the internal queue. We’ll see soon how we can avoid that risk.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种入队的方式并不完全安全：存在超出内部队列容量的风险。我们很快将看到如何避免这种风险。
- en: 10.3.2 Using a ReadableStream to wrap a push source or a pull source
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.2 使用ReadableStream包装推送源或拉取源
- en: 'A common scenario is turning a push source or a pull source into a ReadableStream.
    The source being push or pull determines how we will hook into the ReadableStream
    with our UnderlyingSource:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的场景是将推送源或拉取源转换为ReadableStream。源是推送还是拉取决定了我们将如何与UnderlyingSource连接到ReadableStream：
- en: 'Push source: Such a source notifies us when there is new data. We use `.start()`
    to set up listeners and supporting data structures. If we receive too much data
    and the desired size isn’t positive anymore, we must tell our source to pause.
    If `.pull()` is called later, we can unpause it. Pausing an external source in
    reaction to the desired size becoming non-positive is called *applying backpressure*.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推送源：这样的源在有新数据时通知我们。我们使用`.start()`来设置监听器和支持数据结构。如果我们收到太多数据，期望的大小不再是正数，我们必须告诉我们的源暂停。如果以后调用了`.pull()`，我们可以取消暂停。对外部源在期望的大小变为非正数时暂停的反应称为*应用背压*。
- en: 'Pull source: We ask such a source for new data – often asynchronously. Therefore,
    we usually don’t do much in `.start()` and retrieve data whenever `.pull()` is
    called.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉取源：我们向这样的源请求新数据-通常是异步的。因此，我们通常在`.start()`中不做太多事情，并在调用`.pull()`时检索数据。
- en: We’ll see examples for both kinds of sources next.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将看到两种来源的例子。
- en: '10.3.2.1 Example: creating a ReadableStream from a push source with backpressure
    support'
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.3.2.1 示例：从具有背压支持的推送源创建一个ReadableStream
- en: 'In the following example, we wrap a ReadableStream around a socket – which
    pushes its data to us (it calls us). [This example](https://streams.spec.whatwg.org/#example-rs-push-backpressure)
    is taken from the web stream specification:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将一个ReadableStream包装在一个套接字周围-它向我们推送数据（它调用我们）。[这个例子](https://streams.spec.whatwg.org/#example-rs-push-backpressure)来自web流规范：
- en: '[PRE16]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '10.3.2.2 Example: creating a ReadableStream from a pull source'
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.3.2.2 示例：从拉取源创建一个ReadableStream
- en: 'The tool function `iterableToReadableStream()` takes an iterable over chunks
    and turns it into a ReadableStream:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 工具函数`iterableToReadableStream()`接受一个块的可迭代对象，并将其转换为一个ReadableStream：
- en: '[PRE17]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s use an async generator function to create an asynchronous iterable and
    turn that iterable into a ReadableStream:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个异步生成器函数来创建一个异步可迭代对象，并将该可迭代对象转换为一个ReadableStream：
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`iterableToReadableStream()` also works with synchronous iterables:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`iterableToReadableStream()`也适用于同步可迭代对象：'
- en: '[PRE19]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There may eventually by a static helper method `ReadableStream.from()` that
    provides this functionality ([see its pull request for more information](https://github.com/whatwg/streams/pull/1083)).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有一个静态的辅助方法`ReadableStream.from()`，提供这个功能（[请参阅其拉取请求以获取更多信息](https://github.com/whatwg/streams/pull/1083)）。
- en: 10.4 Writing to WritableStreams
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4 向WritableStreams写入
- en: 'WritableStreams let us write chunks of data to various sinks. They have the
    following type (feel free to skim this type and the explanations of its properties;
    they will be explained again when we encounter them in examples):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: WritableStreams让我们向各种接收器写入数据块。它们具有以下类型（随意浏览此类型和其属性的解释；当我们在示例中遇到它们时，它们将再次解释）：
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Explanations of these properties:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性的解释：
- en: '`.getWriter()` returns a Writer – an object through which we can write to a
    WritableStream.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.getWriter()`返回一个Writer-通过它我们可以向WritableStream写入数据的对象。'
- en: '`.locked`: There can only be one active Writer per WritableStream at a time.
    While one Writer is in use, the WritableStream is locked and `.getWriter()` cannot
    be invoked.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.locked`：WritableStream一次只能有一个活动的Writer。当一个Writer正在使用时，WritableStream被锁定，无法调用`.getWriter()`。'
- en: '`.close()` closes the stream:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.close()`关闭流：'
- en: The *underlying sink* (more on that later) will still receive all queued chunks
    before it’s closed.
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*底层接收器*（稍后会详细介绍）在关闭之前仍将接收所有排队的块。'
- en: From now on, all attempts to write will fail silently (without errors).
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从现在开始，所有的写入尝试都将无声地失败（没有错误）。
- en: The method returns a Promise that will be fulfilled if the sink succeeds in
    writing all queued chunks and closing. It will be rejected if any errors occur
    during these steps.
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法返回一个Promise，如果接收器成功写入所有排队的块并关闭，将实现该Promise。如果在这些步骤中发生任何错误，它将被拒绝。
- en: '`.abort()` aborts the stream:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.abort()`中止流：'
- en: It puts the stream in error mode.
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将流置于错误模式。
- en: The returned Promise fulfills if the sink shuts down successfully and rejects
    if errors occur.
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回的Promise在接收器成功关闭时实现，如果发生错误则拒绝。
- en: 'The following subsections cover two approaches to sending data to WritableStreams:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节涵盖了向WritableStreams发送数据的两种方法：
- en: Writing to WritableStreams via Writers
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Writers向WritableStreams写入
- en: Piping to WritableStreams
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据传输到WritableStreams
- en: 10.4.1 Writing to WritableStreams via Writers
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.1 通过Writers向WritableStreams写入
- en: 'We can use *Writers* to write to WritableStreams. They have the following type
    (feel free to skim this type and the explanations of its properties; they will
    be explained again when we encounter them in examples):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用*Writers*向WritableStreams写入。它们具有以下类型（随意浏览此类型和其属性的解释；当我们在示例中遇到它们时，它们将再次解释）：
- en: '[PRE21]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Explanations of these properties:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性的解释：
- en: '`.desiredSize` indicates how much room there is in this WriteStream’s queue.
    It is zero if the queue is full and negative if it has exceeded its maximum size.
    Therefore, if the desired size is zero or negative, we have to stop writing.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.desiredSize`指示WriteStream队列中有多少空间。如果队列已满，则为零，如果超过最大大小，则为负数。因此，如果期望的大小为零或负数，我们必须停止写入。'
- en: If a stream is closed, its desired size is zero.
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果流关闭，它的期望大小为零。
- en: If a stream is in error mode, its desired size is `null`.
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果流处于错误模式，它的期望大小为`null`。
- en: '`.ready` returns a Promise that is fulfilled when the desired size changes
    from non-positive to positive. That means that no backpressure is active and it’s
    OK to write data. If the desired size later changes back to non-positive, a new
    pending Promise is created and returned.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.ready`返回一个Promise，在期望的大小从非正数变为正数时实现。这意味着没有背压活动，可以写入数据。如果期望的大小后来再次变为非正数，则会创建并返回一个新的待处理Promise。'
- en: '`.write()` writes a chunk to the stream. It returns a Promise that is fulfilled
    after writing succeeds and rejected if there is an error.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.write()`将一个块写入流。它返回一个Promise，在写入成功后实现，如果有错误则拒绝。'
- en: '`.releaseLock()` releases the Writer’s lock on its stream.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.releaseLock()`释放Writer对其流的锁定。'
- en: '`.close()` has the same effect as closing the Writer’s stream.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.close()`具有与关闭Writer流相同的效果。'
- en: '`.closed` returns a Promise that is fulfilled when the stream is closed.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.closed`返回一个Promise，在流关闭时被实现。'
- en: '`.abort()` has the same effect as aborting the Writer’s stream.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.abort()`具有与中止Writer流相同的效果。'
- en: 'The following code shows the protocol for using Writers:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了使用Writers的协议：
- en: '[PRE22]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can’t write directly to a `writableStream`, we first need to acquire a *Writer*
    (line A). Each WritableStream can have at most one Writer. After a Writer was
    acquired, `writableStream` is locked (line B). Before we can call `.getWriter()`
    again, we must call `.releaseLock()` (line C).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能直接向`writableStream`写入，我们首先需要获取一个*Writer*（A行）。每个WritableStream最多只能有一个Writer。在获取了Writer之后，`writableStream`被锁定（B行）。在我们可以再次调用`.getWriter()`之前，我们必须调用`.releaseLock()`（C行）。
- en: There are three approaches to writing chunks.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种写入块的方法。
- en: '10.4.1.1 Writing approach 1: awaiting `.write()` (handling backpressure inefficiently)'
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.4.1.1写入方法1：等待`.write()`（处理背压效率低下）
- en: 'The first writing approach is to await each result of `.write()`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种写入方法是等待每个`.write()`的结果：
- en: '[PRE23]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The Promise returned by `.write()` fulfills when the chunk that we passed to
    it, was successfully written. What exactly “successfully written” means, depends
    on how a WritableStream is implemented – e.g., with a file stream, the chunk may
    have been sent to the operating system but still reside in a cache and therefore
    not have actually been written to disk.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由`.write()`返回的Promise在我们传递给它的块成功写入时实现。“成功写入”具体意味着什么取决于WritableStream的实现方式 -
    例如，对于文件流，该块可能已发送到操作系统，但仍然驻留在缓存中，因此实际上尚未写入磁盘。
- en: The Promise returned by `.close()` is fulfilled when the stream becomes closed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 由`.close()`返回的Promise在流关闭时实现。
- en: A downside of this writing approach is that waiting until writing succeeds means
    that the queue isn’t used. As a consequence, data throughput may be lower.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这种写入方法的一个缺点是等待写入成功意味着队列没有被使用。因此，数据吞吐量可能会较低。
- en: '10.4.1.2 Writing approach 2: ignoring `.write()` rejections (ignoring backpressure)'
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.4.1.2写入方法2：忽略`.write()`拒绝（忽略背压）
- en: 'In the second writing approach, we ignore the Promises returned by `.write()`
    and only await the Promise returned by `.close()`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种写入方法中，我们忽略了`.write()`返回的Promise，只等待`.close()`返回的Promise：
- en: '[PRE24]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The synchronous invocations of `.write()` add chunks to the internal queue of
    the WritableStream. By not awaiting the returned Promises, we don’t wait until
    each chunk is written. However, awaiting `.close()` ensures that the queue is
    empty and all writing succeeded before we continue.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`.write()`的同步调用将块添加到WritableStream的内部队列中。通过不等待返回的Promises，我们不必等待每个块被写入。但是，等待`.close()`确保队列为空，并且所有写入都成功后我们才继续。'
- en: Invoking `.catch()` in line A and line B is necessary to avoid warnings about
    unhandled Promise rejections when something goes wrong during writing. Such warnings
    are often logged to the console. We can afford to ignore the errors reported by
    `.write()` because `.close()` will also report them to us.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在A行和B行调用`.catch()`是必要的，以避免在写入过程中出现问题时出现有关未处理的Promise拒绝的警告。这样的警告通常会记录在控制台上。我们可以忽略`.write()`报告的错误，因为`.close()`也会向我们报告这些错误。
- en: 'The previous code can be improved by using a helper function that ignores Promise
    rejections:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用一个忽略Promise拒绝的辅助函数，可以改进先前的代码：
- en: '[PRE25]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'One downside of this approach is that backpressure is ignored: We simply assume
    that the queue is big enough to hold everything we write.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个缺点是忽略了背压：我们只是假设队列足够大，可以容纳我们写入的所有内容。
- en: '10.4.1.3 Writing approach 3: awaiting `.ready` (handling backpressure efficiently)'
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.4.1.3写入方法3：等待`.ready`（高效处理背压）
- en: 'In this writing approach, we handle backpressure efficiently by awaiting the
    Writer getter `.ready`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种写入方法中，我们通过等待Writer getter`.ready`来有效地处理背压：
- en: '[PRE26]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The Promise in `.ready` fulfills whenever the stream transitions from having
    backpressure to not having backpressure.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`.ready`中的Promise在流从有背压到无背压的转换时实现。'
- en: '10.4.1.4 Example: writing to a file via a Writer'
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.4.1.4示例：通过Writer写入文件
- en: 'In this example, we create a text file `data.txt` via a WritableStream:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过WritableStream创建一个文本文件`data.txt`：
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In line A, we create a Node.js stream for the file `data.txt`. In line B, we
    convert this stream to a web stream. Then we use a Writer to write strings to
    it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在A行，我们为文件`data.txt`创建了一个Node.js流。在B行，我们将这个流转换为web流。然后我们使用Writer将字符串写入其中。
- en: 10.4.2 Piping to WritableStreams
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.2向WritableStreams进行管道传输
- en: 'Instead of using Writers, we can also write to WritableStreams by piping ReadableStreams
    to them:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用Writers，我们还可以通过将ReadableStreams传输到WritableStreams来向WritableStreams写入：
- en: '[PRE28]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The Promise returned by `.pipeTo()` fulfills when piping finishes successfully.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由`.pipeTo()`返回的Promise在传输成功完成时实现。
- en: 10.4.2.1 Piping happens asynchronously
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.4.2.1管道传输是异步进行的
- en: 'Piping is performed after the current task completes or pauses. The following
    code demonstrates that:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 管道传输是在当前任务完成或暂停后执行的。以下代码演示了这一点：
- en: '[PRE29]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In line A we create a ReadableStream. In line B we create a WritableStream.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在A行我们创建一个ReadableStream。在B行我们创建一个WritableStream。
- en: We can see that `.pipeTo()` (line C) returns immediately. In a new task, chunks
    are read and written. Then `writableStream` is closed and, finally, `promise`
    is fulfilled.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`.pipeTo()`（行C）立即返回。在一个新的任务中，块被读取和写入。然后`writableStream`被关闭，最后，`promise`被实现。
- en: '10.4.2.2 Example: piping to a WritableStream for a file'
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.4.2.2 示例：将数据管道到文件的可写流
- en: 'In the following example, we create a WritableStream for a file and pipe a
    ReadableStream to it:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们为一个文件创建一个WritableStream，并将一个ReadableStream管道传递给它：
- en: '[PRE30]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In line A, we create a ReadableStream. In line B, we create a Node.js stream
    for the file `data.txt`. In line C, we convert this stream to a web stream. In
    line D, we pipe our `webReadableStream` to the WritableStream for the file.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在A行，我们创建了一个ReadableStream。在B行，我们为文件`data.txt`创建了一个Node.js流。在C行，我们将这个流转换为web流。在D行，我们将我们的`webReadableStream`管道传递给文件的WritableStream。
- en: '10.4.2.3 Example: writing two ReadableStreams to a WritableStream'
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.4.2.3 示例：将两个ReadableStreams写入到一个WritableStream
- en: In the following example, we write two ReadableStreams to a single WritableStream.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将两个ReadableStreams写入单个WritableStream。
- en: '[PRE31]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We tell `.pipeTo()` to not close the WritableStream after the ReadableStream
    is closed (line A and line B). Therefore, the WritableStream remains open after
    line A and we can pipe another ReadableStream to it.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉`.pipeTo()`在ReadableStream关闭后不关闭WritableStream（行A和行B）。因此，在行A之后，WritableStream保持打开状态，我们可以将另一个ReadableStream管道传递给它。
- en: 10.5 Turning data sinks into WritableStreams via wrapping
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5 将数据接收端通过包装转换为可写流
- en: 'If we want to write to an external sink via a WritableStream, we can wrap it
    in an adapter object and pass that object to the `WritableStream` constructor.
    The adapter object is called the *underlying sink* of the WritableStream (queuing
    strategies are explained later, when we take a closer look at backpressure):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想通过WritableStream写入到外部接收端，我们可以将其包装在一个适配器对象中，并将该对象传递给`WritableStream`的构造函数。适配器对象被称为WritableStream的*底层接收端*（当我们更仔细地看反压时，排队策略将在稍后解释）：
- en: '[PRE32]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is the type of underlying sinks (feel free to skim this type and the explanations
    of its properties; they will be explained again when we encounter them in examples):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这是底层接收端的类型（随意浏览此类型和其属性的解释；当我们在示例中遇到它们时，它们将再次解释）：
- en: '[PRE33]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Explanations of these properties:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性的解释：
- en: '`.start(controller)` is called immediately after we invoke the constructor
    of `WritableStream`. If we do something asynchronous, we can return a Promise.
    In this method, we can prepare for writing.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.start(controller)` 在我们调用`WritableStream`的构造函数后立即调用。如果我们做一些异步操作，我们可以返回一个Promise。在这个方法中，我们可以准备写入。'
- en: '`.write(chunk, controller)` is called when a new chunk is ready to be written
    to the external sink. We can exert backpressure by returning a Promise that fulfills
    once the backpressure is gone.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.write(chunk, controller)` 当一个新的块准备写入外部接收端时调用。我们可以通过返回一个Promise来施加反压，一旦反压消失就会实现。'
- en: '`.close()` is called after `writer.close()` was called and all queued writes
    succeeded. In this method, we can clean up after writing.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.close()` 在调用`writer.close()`后调用，并且所有排队的写入都成功。在这个方法中，我们可以在写入后进行清理。'
- en: '`.abort(reason)` is called if `writeStream.abort()` or `writer.abort()` were
    invoked. `reason` is the value passed to these methods.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果调用了`writeStream.abort()`或`writer.abort()`，则会调用`.abort(reason)`。`reason`是传递给这些方法的值。
- en: 'The parameter `controller` of `.start()` and `.write()` lets them error the
    WritableStream. It has the following type:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`.start()`和`.write()`的参数`controller`让它们错误WritableStream。它具有以下类型：'
- en: '[PRE34]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`.signal` is an AbortSignal that we can listen to if we want to abort a write
    or close operation when the stream is aborted.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.signal` 是一个AbortSignal，如果我们想在流被中止时中止写入或关闭操作，我们可以监听它。'
- en: '`.error(err)` errors the WritableStream: It is closed and all future interactions
    with it fail with the error value `err`.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.error(err)` 错误WritableStream：它被关闭，并且以后所有与它的交互都会失败，错误值为`err`。'
- en: '10.5.1 Example: tracing a ReadableStream'
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.5.1 示例：跟踪一个可读流
- en: 'In the next example, we pipe a ReadableStream to a WritableStream in order
    to check how the ReadableStream produces chunks:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将一个ReadableStream管道到一个WritableStream，以便检查ReadableStream如何生成块：
- en: '[PRE35]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '10.5.2 Example: collecting chunks written to a WriteStream in a string'
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.5.2 示例：收集写入到WriteStream的块到一个字符串中
- en: 'In the next example, we create a subclass of `WriteStream` that collects all
    written chunks in a string. We can access that string via method `.getString()`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们创建了`WriteStream`的一个子类，它将所有写入的块收集到一个字符串中。我们可以通过`.getString()`方法访问该字符串：
- en: '[PRE36]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A downside of this approach is that we are mixing two APIs: The API of `WritableStream`
    and our new string stream API. An alternative is to delegate to the WritableStream
    instead of extending it:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个缺点是我们混合了两个API：`WritableStream`的API和我们新的字符串流API。另一种选择是委托给WritableStream而不是扩展它：
- en: '[PRE37]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This functionality could also be implemented via a class (instead of as a factory
    function for objects).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能也可以通过类来实现（而不是作为对象的工厂函数）。
- en: 10.6 Using TransformStreams
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6 使用TransformStreams
- en: 'A TransformStream:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 一个TransformStream：
- en: Receives input via its *writable side*, a WritableStream.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过其*writable side*接收输入，即WritableStream。
- en: It then may or may not transform this input.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后可能会或可能不会转换这个输入。
- en: The result can be read via a ReadableStream, its *readable side*.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果可以通过一个ReadableStream来读取，它的*可读端*。
- en: 'The most common way to use TransformStreams is to “pipe through” them:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TransformStreams最常见的方式是“管道传递”它们：
- en: '[PRE38]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`.pipeThrough()` pipes `readableStream` to the writable side of `transformStream`
    and returns its readable side. In other words: We have created a new ReadableStream
    that is a transformed version of `readableStream`.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`.pipeThrough()` 将`readableStream`管道到`transformStream`的可写端，并返回其可读端。换句话说：我们已经创建了一个新的`ReadableStream`，它是`readableStream`的转换版本。'
- en: '`.pipeThrough()` accepts not only TransformStreams, but any object that has
    the following shape:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`.pipeThrough()` 不仅接受TransformStreams，还接受任何具有以下形式的对象：'
- en: '[PRE39]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 10.6.1 Standard TransformStreams
  id: totrans-307
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.6.1 标准TransformStreams
- en: 'Node.js supports the following standard TransformStreams:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js支持以下标准TransformStreams：
- en: '[Encoding (WHATWG standard)](https://encoding.spec.whatwg.org) – `TextEncoderStream`
    and `TextDecoderStream`:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[编码（WHATWG标准）](https://encoding.spec.whatwg.org) – `TextEncoderStream`和`TextDecoderStream`：'
- en: These streams support UTF-8, but also [many “legacy encodings”](https://encoding.spec.whatwg.org/#names-and-labels).
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些流支持UTF-8，但也支持[许多“旧编码”](https://encoding.spec.whatwg.org/#names-and-labels)。
- en: A single Unicode code point is encoded as up to four UTF-8 code units (bytes).
    In byte streams, encoded code points be be split across chunks. `TextDecoderStream`
    handles these cases correctly.
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Unicode代码点被编码为多达四个UTF-8代码单元（字节）。在字节流中，编码的代码点可能会跨越块。`TextDecoderStream`可以正确处理这些情况。
- en: Available on most JavaScript platforms ([`TextEncoderStream`](https://developer.mozilla.org/en-US/docs/Web/API/TextEncoderStream#browser_compatibility),
    [`TextDecoderStream`](https://developer.mozilla.org/en-US/docs/Web/API/TextDecoderStream#browser_compatibility)).
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数JavaScript平台都可以使用（[`TextEncoderStream`](https://developer.mozilla.org/en-US/docs/Web/API/TextEncoderStream#browser_compatibility),
    [`TextDecoderStream`](https://developer.mozilla.org/en-US/docs/Web/API/TextDecoderStream#browser_compatibility)）。
- en: '[Compression Streams (W3C Draft Community Group Report)](https://wicg.github.io/compression/)
    – [`CompressionStream`](https://developer.mozilla.org/en-US/docs/Web/API/CompressionStream),
    [`DecompressionStream`](https://developer.mozilla.org/en-US/docs/Web/API/DecompressionStream):'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[压缩流（W3C草案社区组报告）](https://wicg.github.io/compression/) – [`CompressionStream`](https://developer.mozilla.org/en-US/docs/Web/API/CompressionStream),
    [`DecompressionStream`](https://developer.mozilla.org/en-US/docs/Web/API/DecompressionStream):'
- en: '[Currently supported compression formats](https://wicg.github.io/compression/#supported-formats):
    `deflate` (ZLIB Compressed Data Format), `deflate-raw` (DEFLATE algorithm), `gzip`
    (GZIP file format).'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[当前支持的压缩格式](https://wicg.github.io/compression/#supported-formats): `deflate`（ZLIB压缩数据格式），`deflate-raw`（DEFLATE算法），`gzip`（GZIP文件格式）。'
- en: Available on many JavaScript platforms ([`CompressionStream`](https://developer.mozilla.org/en-US/docs/Web/API/CompressionStream#browser_compatibility),
    [`DecompressionStream`](https://developer.mozilla.org/en-US/docs/Web/API/DecompressionStream#browser_compatibility)).
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在许多JavaScript平台上都可以使用（[`CompressionStream`](https://developer.mozilla.org/en-US/docs/Web/API/CompressionStream#browser_compatibility),
    [`DecompressionStream`](https://developer.mozilla.org/en-US/docs/Web/API/DecompressionStream#browser_compatibility)）。
- en: '10.6.1.1 Example: decoding a stream of UTF-8-encoded bytes'
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.6.1.1 示例：解码一系列UTF-8编码的字节流
- en: 'In the following example, we decode a stream of UTF-8-encoded bytes:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们解码了一系列UTF-8编码的字节流：
- en: '[PRE40]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`response.body` is a ReadableByteStream whose chunks are instances of `Uint8Array`
    ([TypedArrays](https://exploringjs.com/impatient-js/ch_typed-arrays.html)). We
    pipe that stream through a `TextDecoderStream` to get a stream that has string
    chunks.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`response.body`是一个ReadableByteStream，其块是`Uint8Array`的实例（[TypedArrays](https://exploringjs.com/impatient-js/ch_typed-arrays.html)）。我们通过`TextDecoderStream`将该流传输，以获得具有字符串块的流。'
- en: Note that translating each byte chunk separately (e.g. via [a `TextDecoder`](https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder))
    doesn’t work because [a single Unicode code point is encoded as up to four bytes
    in UTF-8](https://exploringjs.com/impatient-js/ch_unicode.html#utf-8-unicode-transformation-format-8)
    and those bytes might not all be in the same chunk.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，单独翻译每个字节块（例如通过[`TextDecoder`](https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder)）是行不通的，因为[一个Unicode代码点在UTF-8中被编码为多达四个字节](https://exploringjs.com/impatient-js/ch_unicode.html#utf-8-unicode-transformation-format-8)，而这些字节可能不都在同一个块中。
- en: '10.6.1.2 Example: creating a readable text stream for standard input'
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.6.1.2 示例：创建一个用于标准输入的可读文本流
- en: 'The following Node.js module logs everything that is sent to it via standard
    input:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Node.js模块记录通过标准输入发送给它的所有内容：
- en: '[PRE41]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can access standard input via a stream stored in `process.stdin` (`process`
    is a global Node.js variable). If we don’t set an encoding for this stream and
    convert it via `Readable.toWeb()`, we get a byte stream. We pipe it through a
    TextDecoderStream in order to get a text stream.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过存储在`process.stdin`中的流访问标准输入（`process`是一个全局Node.js变量）。如果我们不为此流设置编码并通过`Readable.toWeb()`进行转换，我们将获得一个字节流。我们通过TextDecoderStream将其传输，以获得一个文本流。
- en: 'Note that we process standard input incrementally: As soon as another chunk
    is available, we log it. In other words, we don’t wait until standard input is
    finished. That is useful when the data is either large or only sent intermittently.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们逐步处理标准输入：一旦另一个块可用，我们就会记录它。换句话说，我们不会等到标准输入完成。当数据要么很大要么只是间歇性发送时，这是很有用的。
- en: 10.7 Implementing custom TransformStreams
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.7 实现自定义TransformStreams
- en: 'We can implement a custom TransformStream by passing a Transformer object to
    the constructor of `TransformStream`. Such has object has the following type (feel
    free to skim this type and the explanations of its properties; they will be explained
    again when we encounter them in examples):'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将Transformer对象传递给`TransformStream`的构造函数来实现自定义TransformStream。这样的对象具有以下类型（随意略过此类型和其属性的解释；当我们在示例中遇到它们时，它们将再次解释）：
- en: '[PRE42]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Explanations of these properties:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性的解释：
- en: '`.start(controller)` is called immediately after we invoke the constructor
    of `TransformStream`. Here we can prepare things before the transformations start.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.start(controller)`在我们调用`TransformStream`的构造函数之后立即调用。在这里，我们可以在转换开始之前准备好一些东西。'
- en: '`.transform(chunk, controller)` performs the actual transformations. It receives
    an input chunk and can use its parameter `controller` to enqueue one or more transformed
    output chunks. It can also choose not to enqueue anything at all.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.transform(chunk, controller)`执行实际的转换。它接收一个输入块，并可以使用其参数`controller`来排队一个或多个转换后的输出块。它也可以选择不排队任何内容。'
- en: '`.flush(controller)` is called after all input chunks were transformed successfully.
    Here we can perform clean-ups after the transformations are done.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.flush(controller)`在所有输入块成功转换后调用。在这里，我们可以在转换完成后执行清理工作。'
- en: Each of these methods can return a Promise and no further steps will be taken
    until the Promise is settled. That is useful if we want to do something asynchronous.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的每一个都可以返回一个Promise，并且在Promise解决之前不会采取进一步的步骤。如果我们想要执行一些异步操作，这是很有用的。
- en: 'The parameter `controller` has the following type:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`controller`具有以下类型：
- en: '[PRE43]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`.enqueue(chunk)` adds `chunk` to the readable side (output) of the TransformStream.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.enqueue(chunk)`将`chunk`添加到TransformStream的可读端（输出）。'
- en: '`.desiredSize` returns the desired size of the internal queue of the readable
    side (output) of the TransformStream.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.desiredSize`返回可读端（输出）的TransformStream内部队列的期望大小。'
- en: '`.terminate()` closes the readable side (output) and errors the writable side
    (input) of the TransformStream. It can be used if a transformer is not interested
    in the remaining chunks of the writable side (input) and wants to skip them.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.terminate()`关闭可读端（输出）并错误可写端（输入）的TransformStream。如果转换器对可写端（输入）的剩余块不感兴趣并希望跳过它们，则可以使用它。'
- en: '`.error(err)` errors the TransformStream: All future interactions with it will
    fail with the error value `err`.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.error(err)`错误TransformStream：以后所有与它的交互都将以错误值`err`失败。'
- en: What about backpressure in a TransformStream? The class propagates the backpressure
    from its readable side (output) to its writable side (input). The assumption is
    that transforming doesn’t change the amount of data much. Therefore, Transforms
    can get away with ignoring backpressure. However, it could be detected via `transformStreamDefaultController.desiredSize`
    and propagated by returning a Promise from `transformer.transform()`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: TransformStream中的背压如何？该类将背压从其可读端（输出）传播到其可写端（输入）。假设转换不会改变数据量太多。因此，Transform可以忽略背压。但是，可以通过`transformStreamDefaultController.desiredSize`检测到它，并通过从`transformer.transform()`返回一个Promise来传播它。
- en: '10.7.1 Example: transforming a stream of arbitrary chunks to a stream of lines'
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.7.1 示例：将任意块的流转换为行流
- en: 'The following subclass of `TransformStream` converts a stream with arbitrary
    chunks into a stream where each chunk comprises exactly one line of text. That
    is, with the possible exception of the last chunk, each chunk ends with an end-of-line
    (EOL) string: `''\n''` on Unix (incl. macOS) and `''\r\n''` on Windows.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransformStream`的以下子类将流转换为每个块都包含一行文本的流。也就是说，除了最后一个块可能以行尾（EOL）字符串结束之外，每个块都以行尾（EOL）字符串结束：Unix（包括macOS）上为`''\n''`，Windows上为`''\r\n''`。'
- en: '[PRE44]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that [Deno’s built-in `TextLineStream`](https://doc.deno.land/https://deno.land/std@0.141.0/streams/mod.ts/~/TextLineStream)
    provides similar functionality.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[Deno的内置`TextLineStream`](https://doc.deno.land/https://deno.land/std@0.141.0/streams/mod.ts/~/TextLineStream)提供类似的功能。
- en: 'Tip: We can also make this transformation via an async generator. It would
    asynchronously iterate over a ReadableStream and return an asynchronous iterable
    with lines. Its implementation is shown in [§9.4 “Transforming readable streams
    via async generators”](ch_nodejs-streams.html#transforming-Readable-via-async-generator).'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：我们也可以通过异步生成器进行这种转换。它将异步迭代ReadableStream并返回一个包含行的异步可迭代对象。其实现在[§9.4“通过异步生成器转换可读流”](ch_nodejs-streams.html#transforming-Readable-via-async-generator)中显示。
- en: '10.7.2 Tip: async generators are also great for transforming streams'
  id: totrans-346
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.7.2提示：异步生成器也非常适合转换流
- en: 'Due to ReadableStreams being asynchronously iterable, we can use [asynchronous
    generators](https://exploringjs.com/impatient-js/ch_async-iteration.html#async-generators)
    to transform them. That leads to very elegant code:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ReadableStreams是异步可迭代的，我们可以使用[异步生成器](https://exploringjs.com/impatient-js/ch_async-iteration.html#async-generators)来转换它们。这导致非常优雅的代码：
- en: '[PRE45]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 10.8 A closer look at backpressure
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.8 仔细观察背压
- en: 'Let’s take a closer look at backpressure. Consider the following pipe chain:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细观察背压。考虑以下管道链：
- en: '[PRE46]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`rs` is a ReadableStream, `ts` is a TransformStream, `ws` is a WritableStream.
    These are the connections that are created by the previous expression (`.pipeThrough`
    uses `.pipeTo` to connect `rs` to the writable side of `ts`):'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`rs`是一个ReadableStream，`ts`是一个TransformStream，`ws`是一个WritableStream。这些是由前一个表达式创建的连接（`.pipeThrough`使用`.pipeTo`将`rs`连接到`ts`的可写端）：'
- en: '[PRE47]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Observations:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 观察：
- en: The underlying source of `rs` can be viewed as a pipe chain member that comes
    before `rs`.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rs`的基础源可以被视为在`rs`之前的管道链成员。'
- en: The underlying sink of `ws` can be viewed as a pipe chain member that comes
    after `ws`.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ws`的基础接收器可以被视为在`ws`之后的管道链成员。'
- en: 'Each stream has an internal buffer: ReadableStreams buffers after their underlying
    sources. WritableStreams have buffers before their underlying sinks.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个流都有一个内部缓冲区：ReadableStreams在其基础源之后进行缓冲。WritableStreams在其基础接收器之前进行缓冲。
- en: 'Let’s assume that the underlying sink of `ws` is slow and the buffer of `ws`
    is eventually full. Then the following steps happen:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`ws`的基础接收器速度慢，`ws`的缓冲区最终满了。然后发生以下步骤：
- en: '`ws` signals it’s full.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ws`发出满的信号。'
- en: '`pipeTo` stops reading from `ts.readable`.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pipeTo`停止从`ts.readable`读取。'
- en: '`ts.readable` signals it’s full.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ts.readable`发出满的信号。'
- en: '`ts` stops moving chunks from `ts.writable` to `ts.readable`.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ts`停止从`ts.writable`移动块到`ts.readable`。'
- en: '`ts.writable` signals it’s full.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ts.writable`发出满的信号。'
- en: '`pipeTo` stops reading from `rs`.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pipeTo`停止从`rs`读取。'
- en: '`rs` signals it’s full to its underlying source.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rs`向其基础源发出满的信号。'
- en: The underlying source pauses.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础源暂停。
- en: 'This example illustrates that we need two kinds of functionality:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明我们需要两种功能：
- en: Entities receiving data need to be able to signal backpressure.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收数据的实体需要能够发出背压信号。
- en: Entities sending data need to react to signals by exerting backpressure.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送数据的实体需要对信号做出反应，施加背压。
- en: Let’s explore how these functionalities are implemented in the web streams API.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这些功能在web流API中是如何实现的。
- en: 10.8.1 Signalling backpressure
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.8.1 发出背压
- en: 'Backpressure is signalled by entities that are receiving data. Web streams
    have two such entities:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 背压由接收数据的实体发出信号。Web流有两个这样的实体：
- en: A WritableStream receives data via the Writer method `.write()`.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WritableStream通过Writer方法`.write()`接收数据。
- en: A ReadableStream receives data when its underlying source calls the ReadableStreamDefaultController
    method `.enqueue()`.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当其基础源调用ReadableStreamDefaultController方法`.enqueue()`时，ReadableStream接收数据。
- en: In both cases, the input is buffered via queues. The signal to apply backpressure
    is when a queue is full. Let’s see how that can be detected.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the locations of the queues:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: The queue of a WritableStream is stored internally in the WritableStreamDefaultController
    ([see web streams standard](https://streams.spec.whatwg.org/#ws-default-controller-internal-slots)).
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The queue of a ReadableStream is stored internally in the ReadableStreamDefaultController
    ([see web streams standard](https://streams.spec.whatwg.org/#rs-default-controller-internal-slots)).
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *desired size* of a queue is a number that indicates how much room is left
    in the queue:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: It is positive if there is still room in the queue.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is zero if the queue has reached its maximum size.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is negative if the queue has exceeded its maximum size.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, we have to apply backpressure if the desired size is zero or less.
    It is available via the getter `.desiredSize` of the object which contains the
    queue.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'How is the desired size computed? Via an object that specifies a so-called
    *queuing strategy*. `ReadableStream` and `WritableStream` have default queuing
    strategies which can be overridden via optional parameters of their constructors.
    [The interface `QueuingStrategy`](https://streams.spec.whatwg.org/#dictdef-queuingstrategy)
    has two properties:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Method `.size(chunk)` returns a size for `chunk`.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current size of a queue is the sum of the sizes of the chunks it contains.
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Property `.highWaterMark` specifies the maximum size of a queue.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The desired size of a queue is the high water mark minus the current size of
    the queue.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 10.8.2 Reacting to backpressure
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Entities sending data need to react to signalled backpressure by exerting backpressure.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 10.8.2.1 Code writing to a WritableStream via a Writer
  id: totrans-391
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can await the Promise in `writer.ready`. While we do, we are blocked and
    the desired backpressure is achieved. The Promise is fulfilled once there is room
    in the queue. Fulfillment is triggered when `writer.desiredSize` has a value greater
    than zero.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, we can await the Promise returned by `writer.write()`. If we
    do that, the queue won’t even be filled.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we want to, we can additionally base the size of our chunks on `writer.desiredSize`.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 10.8.2.2 The underlying source of a ReadableStream
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The underlying source object that can be passed to a ReadableStream wraps an
    external source. In a way, it is also a member of the pipe chain; one that comes
    before its ReadableStream.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Underlying pull sources are only asked for new data whenever there is room in
    the queue. While there isn’t, backpressure is exerted automatically because no
    data is pulled.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Underlying push sources should check `controller.desiredSize` after enqueuing
    something: If it’s zero or less, they should exert backpressure by pausing their
    external sources.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.8.2.3 The underlying sink of a WritableStream
  id: totrans-399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The underlying sink object that can be passed to a WritableStream wraps an external
    sink. In a way, it is also a member of the pipe chain; one that comes after its
    WritableStream.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Each external sink signals backpressure differently (in some cases not at all).
    The underlying sink can exert backpressure by returning a Promise from method
    `.write()` that is fulfilled once writing is finished. There is [an example in
    the web streams standard](https://streams.spec.whatwg.org/#example-ws-backpressure)
    that demonstrates how that works.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 10.8.2.4 A transformStream (`.writable` `→` `.readable`)
  id: totrans-402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The TransformStream connects its writable side with its readable side by implementing
    an underlying sink for the former and an underlying source for the latter. It
    has an internal slot `.[[backpressure]]` that indicates if internal backpressure
    is currently active or not.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'Method `.write()` of the underlying sink of the writable side waits asynchronously
    until there is no internal backpressure before it feeds another chunk to the TransformStream’s
    transformer (web streams standard: [`TransformStreamDefaultSinkWriteAlgorithm`](https://streams.spec.whatwg.org/#transform-stream-default-sink-write-algorithm)).
    The transformer may then enqueue something via its TransformStreamDefaultController.
    Note that `.write()` returns a Promise that fulfills when the method is finished.
    Until that happens, the WriteStream buffers incoming write requests via its queue.
    Therefore, backpressure for the writable side is signalled via that queue and
    its desired size.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可写端的底层接收器的`.write()`方法会异步等待，直到没有内部背压，然后将另一个块提供给TransformStream的转换器（web streams标准：[`TransformStreamDefaultSinkWriteAlgorithm`](https://streams.spec.whatwg.org/#transform-stream-default-sink-write-algorithm)）。然后转换器可以通过其TransformStreamDefaultController加入一些内容。请注意，`.write()`返回一个Promise，在方法完成时会被满足。在此之前，WriteStream通过其队列缓冲传入的写请求。因此，可写端的背压通过该队列及其期望的大小来表示。
- en: 'The TransformStream’s backpressure is activated if a chunk is enqueued via
    the TransformStreamDefaultController and the queue of the readable side becomes
    full (web streams standard: [`TransformStreamDefaultControllerEnqueue`](https://streams.spec.whatwg.org/#transform-stream-default-controller-enqueue)).'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果通过TransformStreamDefaultController将一个块加入队列，并且可读端的队列变满了，TransformStream的背压就会被激活（web
    streams标准：[`TransformStreamDefaultControllerEnqueue`](https://streams.spec.whatwg.org/#transform-stream-default-controller-enqueue)）。
- en: 'The TransformStream’s backpressure may be deactivated if something is read
    from the Reader (web streams standard: [`ReadableStreamDefaultReaderRead`](https://streams.spec.whatwg.org/#readable-stream-default-reader-read)):'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果从读取器中读取了一些内容，`ReadableStream`的背压可能会被取消（web streams标准：[`ReadableStreamDefaultReaderRead`](https://streams.spec.whatwg.org/#readable-stream-default-reader-read)）：
- en: 'If there is room in the queue now, it may be time to call `.pull()` of the
    underlying source (web streams standard: [`.[[PullSteps]]`](https://streams.spec.whatwg.org/#rs-default-controller-private-pull)).'
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果队列中现在有空间，可能是时候调用底层源的`.pull()`了（web streams标准：[`.[[PullSteps]]`](https://streams.spec.whatwg.org/#rs-default-controller-private-pull)）。
- en: '`.pull()` of the underlying source of the readable side deactivates the backpressure
    (web streams standard: [`TransformStreamDefaultSourcePullAlgorithm`](https://streams.spec.whatwg.org/#transform-stream-default-source-pull)).'
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可读端的底层源的`.pull()`会取消背压（web streams标准：[`TransformStreamDefaultSourcePullAlgorithm`](https://streams.spec.whatwg.org/#transform-stream-default-source-pull)）。
- en: 10.8.2.5 `.pipeTo()` (ReadableStream `→` WritableStream)
  id: totrans-409
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.8.2.5 `.pipeTo()`（ReadableStream `→` WritableStream）
- en: '`.pipeTo()` reads chunks from the ReadableStream via a reader and write them
    to the WritableStream via a Writer. It pauses whenever `writer.desiredSize` is
    zero or less (web streams standard: Step 15 of [`ReadableStreamPipeTo`](https://streams.spec.whatwg.org/#readable-stream-pipe-to)).'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`.pipeTo()`通过读取器从ReadableStream读取块，并通过写入器将它们写入WritableStream。当`writer.desiredSize`为零或更小时，它会暂停（web
    streams标准：[`ReadableStreamPipeTo`](https://streams.spec.whatwg.org/#readable-stream-pipe-to)的第15步）。'
- en: 10.9 Byte streams
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.9 字节流
- en: 'So far, we have only worked with *text streams*, streams whose chunks were
    strings. But the web streams API also supports *byte streams* for binary data,
    where chunks are Uint8Arrays ([TypedArrays](https://exploringjs.com/impatient-js/ch_typed-arrays.html)):'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用过*文本流*，流的块是字符串。但是web streams API也支持*字节流*，用于二进制数据，其中块是Uint8Arrays（[TypedArrays](https://exploringjs.com/impatient-js/ch_typed-arrays.html)）：
- en: '`ReadableStream` has a special `''bytes''` mode.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadableStream`有一个特殊的`''bytes''`模式。'
- en: '`WritableStream` itself doesn’t care if chunks are strings or Uint8Arrays.
    Therefore, whether an instance is a text stream or a byte stream depends on what
    kind of chunks the underlying sink can handle.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WritableStream`本身不关心块是字符串还是Uint8Arrays。因此，实例是文本流还是字节流取决于底层接收器可以处理什么类型的块。'
- en: What kind of chunks a `TransformStream` can handle also depends on its Transformer.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransformStream`可以处理什么类型的块也取决于其Transformer。'
- en: Next, we’ll learn how to create readable byte streams.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何创建可读的字节流。
- en: 10.9.1 Readable byte streams
  id: totrans-417
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.9.1 可读的字节流
- en: 'What kind of stream is created by the `ReadableStream` constructor depends
    on the optional property `.type` of its optional first parameter `underlyingSource`:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadableStream`构造函数创建的流的类型取决于可选的属性`.type`和可选的第一个参数`underlyingSource`：'
- en: If `.type` is omitted or no underlying source is provided, the new instance
    is a text stream.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`.type`被省略或没有提供底层源，则新实例是一个文本流。
- en: 'If `.type` is the string `''bytes''`, the new instance is a byte stream:'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`.type`是字符串`'bytes'`，则新实例是一个字节流：
- en: '[PRE48]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: What changes if a ReadableStream is in `'bytes'` mode?
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个ReadableStream处于`'bytes'`模式，会发生什么变化？
- en: In default mode, the underlying source can return any kind of chunk. In bytes
    mode, the chunks must be ArrayBufferViews, i.e. TypedArrays (such as Uint8Arrays)
    or DataViews.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认模式下，底层源可以返回任何类型的块。在字节模式下，块必须是ArrayBufferViews，即TypedArrays（例如Uint8Arrays）或DataViews。
- en: 'Additionally, a readable byte stream can create two kinds of readers:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可读的字节流可以创建两种读取器：
- en: '`.getReader()` returns an instance of `ReadableStreamDefaultReader`.'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.getReader()`返回一个`ReadableStreamDefaultReader`的实例。'
- en: '`.getReader({mode: ''byob''})` returns an instance of `ReadableStreamBYOBReader`.'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.getReader({mode: ''byob''})` 返回一个 `ReadableStreamBYOBReader` 的实例。'
- en: “BYOB“ stands for “Bring Your Own Buffer” and means that we can pass a buffer
    (an ArrayBufferView) to `reader.read()`. Afterwards, that ArrayBufferView will
    be detached and no longer usable. But `.read()` returns its data in a new ArrayBufferView
    that has the same type and accesses the same region of the same ArrayBuffer.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: “BYOB” 代表 “Bring Your Own Buffer”，意味着我们可以传递一个缓冲区（ArrayBufferView）给 `reader.read()`。之后，该ArrayBufferView将被分离并且不再可用。但是`.read()`
    返回其数据在一个新的ArrayBufferView中，该ArrayBufferView具有相同的类型并访问相同的ArrayBuffer的相同区域。
- en: 'Additionally, readable byte streams have different controllers: They are instances
    of `ReadableByteStreamController` (vs. `ReadableStreamDefaultController`). Apart
    from forcing underlying sources to enqueue ArrayBufferViews (TypedArrays or DataViews),
    it also supports ReadableStreamBYOBReaders via [its property `.byobRequest`](https://streams.spec.whatwg.org/#rbs-controller-prototype).
    An underlying source writes its data into the BYOBRequest stored in this property.
    The web streams standard has two examples of using `.byobRequest` in [its section
    “Examples of creating streams”](https://streams.spec.whatwg.org/#creating-examples).'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可读的字节流具有不同的控制器：它们是`ReadableByteStreamController`的实例（而不是`ReadableStreamDefaultController`）。除了强制底层源将ArrayBufferViews（TypedArrays或DataViews）入队之外，它还通过[其属性`.byobRequest`](https://streams.spec.whatwg.org/#rbs-controller-prototype)支持ReadableStreamBYOBReaders。底层源将其数据写入存储在此属性中的BYOBRequest。Web流标准在[其“创建流的示例”部分](https://streams.spec.whatwg.org/#creating-examples)中有两个使用`.byobRequest`的示例。
- en: '10.9.2 Example: an infinite readable byte stream filled with random data'
  id: totrans-429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.9.2 示例：填充随机数据的无限可读的字节流
- en: 'In the next example, create an infinite readable byte stream that fills its
    chunks with random data (inspiration: [`example4.mjs` in “Implementing the Web
    Streams API in Node.js”](https://www.jasnell.me/posts/webstreams#creating-and-using-a-readablestream)).'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，创建一个无限可读的字节流，用随机数据填充其块（灵感来自：[`example4.mjs` in “在Node.js中实现Web流API”](https://www.jasnell.me/posts/webstreams#creating-and-using-a-readablestream)）。
- en: '[PRE49]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Due to `readableByteStream` being infinite, we can’t loop over it. That’s why
    we only read its first chunk (line B).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`readableByteStream`是无限的，我们无法循环读取它。这就是为什么我们只读取它的第一个块（B行）。
- en: The buffer we create in line A is transferred and therefore unreadable after
    line B.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在A行创建的缓冲区在B行之后被传输，因此无法读取。
- en: '10.9.3 Example: compressing a readable byte stream'
  id: totrans-434
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.9.3 示例：压缩可读的字节流
- en: 'In the following example, we create a readable byte stream and pipe it through
    a stream that compresses it to the GZIP format:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们创建一个可读的字节流，并将其通过一个将其压缩为GZIP格式的流：
- en: '[PRE50]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '10.9.4 Example: reading a web page via `fetch()`'
  id: totrans-437
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.9.4 示例：通过`fetch()`读取网页
- en: 'The result of `fetch()` resolves to a response object whose property `.body`
    is a readable byte stream. We convert that byte stream to a text stream via `TextDecoderStream`:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch()`的结果解析为一个响应对象，其属性`.body`是一个可读的字节流。我们通过`TextDecoderStream`将该字节流转换为文本流：'
- en: '[PRE51]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 10.10 Node.js-specific helpers
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.10 Node.js特定的辅助函数
- en: 'Node.js is the only web platform that supports the following helper functions
    that it calls [*utility consumers*](https://nodejs.org/api/webstreams.html#utility-consumers):'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是唯一支持以下辅助函数的Web平台，它称之为[*实用消费者*](https://nodejs.org/api/webstreams.html#utility-consumers)：
- en: '[PRE52]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'These functions convert web ReadableStreams, Node.js Readables and AsyncIterators
    to Promises that are fulfilled with:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数将Web ReadableStreams、Node.js Readables和AsyncIterators转换为被满足的Promise：
- en: ArrayBuffers (`arrayBuffer()`)
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ArrayBuffers（`arrayBuffer()`）
- en: Blobs (`blob()`)
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blobs（`blob()`）
- en: Node.js Buffers (`buffer()`)
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js缓冲区（`buffer()`）
- en: JSON objects (`json()`)
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON对象（`json()`）
- en: Strings (`text()`)
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串（`text()`）
- en: 'Binary data is assumed to be UTF-8-encoded:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 假定二进制数据为UTF-8编码：
- en: '[PRE53]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'String streams work as expected:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串流按预期工作：
- en: '[PRE54]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 10.11 Further reading
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.11 进一步阅读
- en: All of the material mentioned in this section was a source for this chapter.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提到的所有材料都是本章的来源。
- en: 'This chapter doesn’t cover every aspect of the web streams API. You can find
    more information here:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不涵盖Web流API的每个方面。您可以在此处找到更多信息：
- en: '[“WHATWG Streams Standard”](https://streams.spec.whatwg.org/) by Adam Rice,
    Domenic Denicola, Mattias Buelens, and 吉野剛史 (Takeshi Yoshino)'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“WHATWG流标准”](https://streams.spec.whatwg.org/) by Adam Rice, Domenic Denicola,
    Mattias Buelens, and 吉野剛史 (Takeshi Yoshino)'
- en: '[“Web Streams API”](https://nodejs.org/api/webstreams.html) in the Node.js
    documentation'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“Web Streams API”](https://nodejs.org/api/webstreams.html) in Node.js文档'
- en: 'More material:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 更多材料：
- en: 'Web streams API:'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web流API：
- en: '[“Implementing the Web Streams API in Node.js”](https://www.jasnell.me/posts/webstreams)
    by James M. Snell'
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“在Node.js中实现Web流API”](https://www.jasnell.me/posts/webstreams) by James M.
    Snell'
- en: '[“Streams API”](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API)
    on MDN'
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“流API”](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API) 在MDN上'
- en: '[“Streams—The definitive guide”](https://web.dev/streams/) by Thomas Steiner'
  id: totrans-462
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“流-权威指南”](https://web.dev/streams/) by Thomas Steiner'
- en: 'Backpressure:'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背压：
- en: '[“Node.js Backpressuring in Streams”](https://enlear.academy/nodejs-backpressuring-in-streams-52638f505e1b)
    by Vladimir Topolev'
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“Node.js流中的背压”](https://enlear.academy/nodejs-backpressuring-in-streams-52638f505e1b)
    by Vladimir Topolev'
- en: '[“Backpressuring in Streams”](https://nodejs.org/en/docs/guides/backpressuring-in-streams/)
    in the Node.js documentation'
  id: totrans-465
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“流中的背压”](https://nodejs.org/en/docs/guides/backpressuring-in-streams/) in
    Node.js文档'
- en: 'Unicode (code points, UTF-8, UTF-16, etc.): [Chapter “Unicode – a brief introduction”](https://exploringjs.com/impatient-js/ch_unicode.html)
    in “JavaScript for impatient programmers”'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unicode（代码点，UTF-8，UTF-16等）：[“Unicode简介”章节](https://exploringjs.com/impatient-js/ch_unicode.html)
    in “JavaScript for impatient programmers”
- en: '[Chapter “Asynchronous iteration”](https://exploringjs.com/impatient-js/ch_async-iteration.html)
    in “JavaScript for impatient programmers”'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“异步迭代”章节](https://exploringjs.com/impatient-js/ch_async-iteration.html) in
    “JavaScript for impatient programmers”'
- en: '[Chapter “Typed Arrays: handling binary data”](https://exploringjs.com/impatient-js/ch_typed-arrays.html)
    in “JavaScript for impatient programmers”'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“Typed Arrays：处理二进制数据”章节](https://exploringjs.com/impatient-js/ch_typed-arrays.html)
    in “JavaScript for impatient programmers”'
- en: '[Comments](https://github.com/rauschma/nodejs-shell-scripting/issues/10)'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '[评论](https://github.com/rauschma/nodejs-shell-scripting/issues/10)'
