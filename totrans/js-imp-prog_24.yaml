- en: 20 Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/impatient-js/ch_strings.html](https://exploringjs.com/impatient-js/ch_strings.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '20.1 [Cheat sheet: strings](ch_strings.html#cheat-sheet-strings)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.1.1 [Working with strings](ch_strings.html#working-with-strings)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.1.2 [JavaScript characters vs. code points vs. grapheme clusters](ch_strings.html#javascript-characters-vs.-code-points-vs.-grapheme-clusters)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.1.3 [String methods](ch_strings.html#string-methods)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.2 [Plain string literals](ch_strings.html#plain-string-literals)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.2.1 [Escaping](ch_strings.html#escaping)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.3 [Accessing JavaScript characters](ch_strings.html#accessing-javascript-characters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.4 [String concatenation via `+`](ch_strings.html#string-concatenation-via)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.5 [Converting to string](ch_strings.html#converting-to-string)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.5.1 [Stringifying objects](ch_strings.html#stringifying-objects)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.5.2 [Customizing the stringification of objects](ch_strings.html#customizing-the-stringification-of-objects)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.5.3 [An alternate way of stringifying values](ch_strings.html#an-alternate-way-of-stringifying-values)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.6 [Comparing strings](ch_strings.html#comparing-strings)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '20.7 [Atoms of text: code points, JavaScript characters, grapheme clusters](ch_strings.html#atoms-of-text)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.7.1 [Working with code points](ch_strings.html#working-with-code-points)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.7.2 [Working with code units (char codes)](ch_strings.html#working-with-code-units-char-codes)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.7.3 [ASCII escapes](ch_strings.html#ascii-escapes)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '20.7.4 [Caveat: grapheme clusters](ch_strings.html#caveat-grapheme-clusters)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '20.8 [Quick reference: Strings](ch_strings.html#quickref-strings)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.8.1 [Converting to string](ch_strings.html#converting-to-string-1)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.8.2 [Numeric values of text atoms](ch_strings.html#numeric-values-of-text-atoms)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '20.8.3 [`String.prototype`: finding and matching](ch_strings.html#string.prototype-finding-and-matching)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '20.8.4 [`String.prototype`: extracting](ch_strings.html#string-api-extracting)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '20.8.5 [`String.prototype`: combining](ch_strings.html#string.prototype-combining)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '20.8.6 [`String.prototype`: transforming](ch_strings.html#string.prototype-transforming)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.8.7 [Sources](ch_strings.html#sources-2)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '20.1 Cheat sheet: strings'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Strings are primitive values in JavaScript and immutable. That is, string-related
    operations always produce new strings and never change existing strings.
  prefs: []
  type: TYPE_NORMAL
- en: 20.1.1 Working with strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Literals for strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Backslashes are used to:'
  prefs: []
  type: TYPE_NORMAL
- en: Escape literal delimiters (first 2 lines of previous example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Represent special characters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\\` represents a backslash'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\n` represents a newline'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\r` represents a carriage return'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\t` represents a tab'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside a `String.raw` tagged template (line A), backslashes are treated as
    normal characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Convertings values to strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Copying parts of a string
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Concatenating strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 20.1.2 JavaScript characters vs. code points vs. grapheme clusters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**JavaScript characters** are 16 bits in size. They are what is indexed in
    strings and what `.length` counts.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code points** are the atomic parts of Unicode text. Most of them fit into
    one JavaScript character, some of them occupy two (especially emojis):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Grapheme clusters** (*user-perceived characters*) represent written symbols.
    Each one comprises one or more code points.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to these facts, we shouldn’t split text into JavaScript characters, we
    should split it into graphemes. For more information on how to handle text, see
    [§20.7 “Atoms of text: code points, JavaScript characters, grapheme clusters”](ch_strings.html#atoms-of-text).'
  prefs: []
  type: TYPE_NORMAL
- en: 20.1.3 String methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This subsection gives a brief overview of the string API. There is [a more comprehensive
    quick reference](ch_strings.html#quickref-strings) at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding substrings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Splitting and joining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Padding and trimming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeating and changing case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 20.2 Plain string literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Plain string literals are delimited by either single quotes or double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Single quotes are used more often because it makes it easier to mention HTML,
    where double quotes are preferred.
  prefs: []
  type: TYPE_NORMAL
- en: '[The next chapter](ch_template-literals.html) covers *template literals*, which
    give us:'
  prefs: []
  type: TYPE_NORMAL
- en: String interpolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raw string literals (backslash has no special meaning)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.2.1 Escaping
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The backslash lets us create special characters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unix line break: `''\n''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows line break: `''\r\n''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tab: `''\t''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Backslash: `''\\''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The backslash also lets us use the delimiter of a string literal inside that
    literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 20.3 Accessing JavaScript characters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript has no extra data type for characters – characters are always represented
    as strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The characters we see on screen are called *grapheme clusters*. Most of them
    are represented by single JavaScript characters. However, there are also grapheme
    clusters (especially emojis) that are represented by multiple JavaScript characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'How that works is explained in [§20.7 “Atoms of text: code points, JavaScript
    characters, grapheme clusters”](ch_strings.html#atoms-of-text).'
  prefs: []
  type: TYPE_NORMAL
- en: 20.4 String concatenation via `+`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If at least one operand is a string, the plus operator (`+`) converts any non-strings
    to strings and concatenates the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The assignment operator `+=` is useful if we want to assemble a string, piece
    by piece:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **Concatenating via `+`
    is efficient**'
  prefs: []
  type: TYPE_NORMAL
- en: Using `+` to assemble strings is quite efficient because most JavaScript engines
    internally optimize it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Concatenating
    strings**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/strings/concat_string_array_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: 20.5 Converting to string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These are three ways of converting a value `x` to a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String(x)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''''+x`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x.toString()` (does not work for `undefined` and `null`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Recommendation: use the descriptive and safe `String()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Pitfall for booleans: If we convert a boolean to a string via `String()`, we
    generally can’t convert it back via `Boolean()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The only string for which `Boolean()` returns `false`, is the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: 20.5.1 Stringifying objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Plain objects have a default string representation that is not very useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrays have a better string representation, but it still hides much information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Stringifying functions, returns their source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 20.5.2 Customizing the stringification of objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can override the built-in way of stringifying objects by implementing the
    method `toString()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 20.5.3 An alternate way of stringifying values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The JSON data format is a text representation of JavaScript values. Therefore,
    [`JSON.stringify()`](ch_json.html#JSON.stringify) can also be used to convert
    values to strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The caveat is that JSON only supports `null`, booleans, numbers, strings, Arrays,
    and objects (which it always treats as if they were created by object literals).
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip: The third parameter lets us switch on multiline output and specify how
    much to indent – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This statement produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 20.6 Comparing strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Strings can be compared via the following operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one important caveat to consider: These operators compare based on
    the numeric values of JavaScript characters. That means that the order that JavaScript
    uses for strings is different from the one used in dictionaries and phone books:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Properly comparing text is beyond the scope of this book. It is supported via
    [the ECMAScript Internationalization API (`Intl`)](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Intl).
  prefs: []
  type: TYPE_NORMAL
- en: '20.7 Atoms of text: code points, JavaScript characters, grapheme clusters'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Quick recap of [§19 “Unicode – a brief introduction”](ch_unicode.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Code points* are the atomic parts of Unicode text. Each code point is 21 bits
    in size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript strings implement Unicode via the encoding format UTF-16\. It uses
    one or two 16-bit *code units* to encode a single code point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each JavaScript character (as indexed in strings) is a code unit. In the JavaScript
    standard library, code units are also called *char codes*.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Grapheme clusters* (*user-perceived characters*) represent written symbols,
    as displayed on screen or paper. One or more code points are needed to encode
    a single grapheme cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code demonstrates that a single code point comprises one or two
    JavaScript characters. We count the latter via `.length`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table summarizes the concepts we have just explored:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Entity | Size | Encoded via |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| JavaScript character (UTF-16 code unit) | 16 bits | – |'
  prefs: []
  type: TYPE_TB
- en: '| Unicode code point | 21 bits | 1–2 code units |'
  prefs: []
  type: TYPE_TB
- en: '| Unicode grapheme cluster |  | 1+ code points |'
  prefs: []
  type: TYPE_TB
- en: 20.7.1 Working with code points
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s explore JavaScript’s tools for working with code points.
  prefs: []
  type: TYPE_NORMAL
- en: A *Unicode code point escape* lets us specify a code point hexadecimally (1–5
    digits). It produces one or two JavaScript characters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **Unicode escape sequences**'
  prefs: []
  type: TYPE_NORMAL
- en: In the ECMAScript language specification, *Unicode code point escapes* and *Unicode
    code unit escapes* (which we’ll encounter later) are called *Unicode escape sequences*.
  prefs: []
  type: TYPE_NORMAL
- en: '`String.fromCodePoint()` converts a single code point to 1–2 JavaScript characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`.codePointAt()` converts 1–2 JavaScript characters to a single code point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can *iterate* over a string, which visits code points (not JavaScript characters).
    Iteration is described [later in this book](ch_sync-iteration.html). One way of
    iterating is via a `for-of` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[`Array.from()`](ch_arrays.html#Array.from) is also based on iteration and
    visits code points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'That makes it a good tool for counting code points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 20.7.2 Working with code units (char codes)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Indices and lengths of strings are based on JavaScript characters (as represented
    by UTF-16 code units).
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify a code unit hexadecimally, we can use a *Unicode code unit escape*
    with exactly four hexadecimal digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can use `String.fromCharCode()`. *Char code* is the standard library’s
    name for *code unit*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the char code of a character, use `.charCodeAt()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 20.7.3 ASCII escapes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If the code point of a character is below 256, we can refer to it via a *ASCII
    escape* with exactly two hexadecimal digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: (The official name of ASCII escapes is *Hexadecimal escape sequences* – it was
    the first escape that used hexadecimal numbers.)
  prefs: []
  type: TYPE_NORMAL
- en: '20.7.4 Caveat: grapheme clusters'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When working with text that may be written in any human language, it’s best
    to split at the boundaries of grapheme clusters, not at the boundaries of code
    points.
  prefs: []
  type: TYPE_NORMAL
- en: TC39 is working on [`Intl.Segmenter`](https://github.com/tc39/proposal-intl-segmenter),
    a proposal for the ECMAScript Internationalization API to support Unicode segmentation
    (along grapheme cluster boundaries, word boundaries, sentence boundaries, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: Until that proposal becomes a standard, we can use one of several libraries
    that are available (do a web search for “JavaScript grapheme”).
  prefs: []
  type: TYPE_NORMAL
- en: '20.8 Quick reference: Strings'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 20.8.1 Converting to string
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Tbl. [14](#tbl:converting-to-string) describes how various values are converted
    to strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14: Converting values to strings.'
  prefs: []
  type: TYPE_NORMAL
- en: '| `x` | `String(x)` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `undefined` | `''undefined''` |'
  prefs: []
  type: TYPE_TB
- en: '| `null` | `''null''` |'
  prefs: []
  type: TYPE_TB
- en: '| boolean | `false` `→` `''false''`, `true` `→` `''true''` |'
  prefs: []
  type: TYPE_TB
- en: '| number | Example: `123` `→` `''123''` |'
  prefs: []
  type: TYPE_TB
- en: '| bigint | Example: `123n` `→` `''123''` |'
  prefs: []
  type: TYPE_TB
- en: '| string | `x` (input, unchanged) |'
  prefs: []
  type: TYPE_TB
- en: '| symbol | Example: `Symbol(''abc'')` `→` `''Symbol(abc)''` |'
  prefs: []
  type: TYPE_TB
- en: '| object | Configurable via, e.g., `toString()` |'
  prefs: []
  type: TYPE_TB
- en: 20.8.2 Numeric values of text atoms
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Char code**: number representing a JavaScript character. JavaScript’s name
    for *Unicode code unit*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Size: 16 bits, unsigned'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Convert number to string: `String.fromCharCode()` ^([ES1])'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Convert string to number: string method `.charCodeAt()` ^([ES1])'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code point**: number representing an atomic part of Unicode text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Size: 21 bits, unsigned (17 planes, 16 bits each)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Convert number to string: `String.fromCodePoint()` ^([ES6])'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Convert string to number: string method `.codePointAt()` ^([ES6])'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '20.8.3 `String.prototype`: finding and matching'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: (`String.prototype` is where the methods of strings are stored.)
  prefs: []
  type: TYPE_NORMAL
- en: '`.endsWith(searchString: string, endPos=this.length): boolean` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if the string would end with `searchString` if its length were
    `endPos`. Returns `false` otherwise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.includes(searchString: string, startPos=0): boolean` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if the string contains the `searchString` and `false` otherwise.
    The search starts at `startPos`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.indexOf(searchString: string, minIndex=0): number` ^([ES1])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the lowest index at which `searchString` appears within the string or
    `-1, otherwise. Any returned index will be`minIndex` or higher.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.lastIndexOf(searchString: string, maxIndex=Infinity): number` ^([ES1])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the highest index at which `searchString` appears within the string
    or `-1, otherwise. Any returned index will be`maxIndex` or lower.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[1 of 2] `.match(regExp: string | RegExp): RegExpMatchArray | null` ^([ES3])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `regExp` is a regular expression with flag `/g` not set, then `.match()`
    returns the first match for `regExp` within the string. Or `null` if there is
    no match. If `regExp` is a string, it is used to create a regular expression (think
    parameter of `new RegExp()`) before performing the previously mentioned steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The result has the following type:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Numbered capture groups become Array indices (which is why this type extends
    `Array`). [Named capture groups](ch_regexps.html#named-capture-groups) (ES2018)
    become properties of `.groups`. In this mode, `.match()` works like `RegExp.prototype.exec()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Examples:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[2 of 2] `.match(regExp: RegExp): string[] | null` ^([ES3])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If flag `/g` of `regExp` is set, `.match()` returns either an Array with all
    matches or `null` if there was no match.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.search(regExp: string | RegExp): number` ^([ES3])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the index at which `regExp` occurs within the string. If `regExp` is
    a string, it is used to create a regular expression (think parameter of `new RegExp()`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.startsWith(searchString: string, startPos=0): boolean` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `true` if `searchString` occurs in the string at index `startPos`. Returns
    `false` otherwise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '20.8.4 `String.prototype`: extracting'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`.slice(start=0, end=this.length): string` ^([ES3])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the substring of the string that starts at (including) index `start`
    and ends at (excluding) index `end`. If an index is negative, it is added to `.length`
    before it is used (`-1` becomes `this.length-1`, etc.).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.at(index: number): string | undefined` ^([ES2022])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the JavaScript character at `index` as a string. If `index` is negative,
    it is added to `.length` before it is used (`-1` becomes `this.length-1`, etc.).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.split(separator: string | RegExp, limit?: number): string[]` ^([ES3])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Splits the string into an Array of substrings – the strings that occur between
    the separators. The separator can be a string:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It can also be a regular expression:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last invocation demonstrates that captures made by groups in the regular
    expression become elements of the returned Array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Warning: `.split('''')` splits a string into JavaScript characters.** That
    doesn’t work well when dealing with astral code points (which are encoded as two
    JavaScript characters). For example, emojis are astral:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instead, it is better to use `Array.from()` (or spreading):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.substring(start: number, end=this.length): string` ^([ES1])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `.slice()` instead of this method. `.substring()` wasn’t implemented consistently
    in older engines and doesn’t support negative indices.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '20.8.5 `String.prototype`: combining'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`.concat(...strings: string[]): string` ^([ES3])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the concatenation of the string and `strings`. `'a'.concat('b')` is
    equivalent to `'a'+'b'`. The latter is much more popular.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.padEnd(len: number, fillString='' ''): string` ^([ES2017])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Appends (fragments of) `fillString` to the string until it has the desired length
    `len`. If it already has or exceeds `len`, then it is returned without any changes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.padStart(len: number, fillString='' ''): string` ^([ES2017])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prepends (fragments of) `fillString` to the string until it has the desired
    length `len`. If it already has or exceeds `len`, then it is returned without
    any changes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.repeat(count=0): string` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the string, concatenated `count` times.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '20.8.6 `String.prototype`: transforming'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`.normalize(form: ''NFC''|''NFD''|''NFKC''|''NFKD'' = ''NFC''): string` ^([ES6])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normalizes the string according to [the Unicode Normalization Forms](https://unicode.org/reports/tr15/).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[1 of 2] `.replaceAll(searchValue: string | RegExp, replaceValue: string):
    string` ^([ES2021])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png)  **What to do if you can’t
    use `.replaceAll()`**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If `.replaceAll()` isn’t available on your targeted platform, you can use `.replace()`
    instead. How is explained in [§43.6.8.1 “`str.replace(searchValue, replacementValue)`
    ^([ES3])”](ch_regexps.html#String.prototype.replace).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Replaces all matches of `searchValue` with `replaceValue`. If `searchValue`
    is a regular expression without flag `/g`, a `TypeError` is thrown.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Special characters in `replaceValue` are:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`$$`: becomes `$`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$n`: becomes the capture of numbered group `n` (alas, `$0` stands for the
    string `''$0''`, it does not refer to the complete match)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$&`: becomes the complete match'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$``: becomes everything before the match'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$''`: becomes everything after the match'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[Named capture groups](ch_regexps.html#named-capture-groups) (ES2018) are supported,
    too:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`$<name>` becomes the capture of named group `name`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[2 of 2] `.replaceAll(searchValue: string | RegExp, replacer: (...args: any[])
    => string): string` ^([ES2021])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the second parameter is a function, occurrences are replaced with the strings
    it returns. Its parameters `args` are:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`matched: string`. The complete match'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g1: string|undefined`. The capture of numbered group 1'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g2: string|undefined`. The capture of numbered group 2'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: (Etc.)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offset: number`. Where was the match found in the input string?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input: string`. The whole input string'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[Named capture groups](ch_regexps.html#named-capture-groups) (ES2018) are supported,
    too. If there are any, an argument is added at the end with an object whose properties
    contain the captures:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.replace(searchValue: string | RegExp, replaceValue: string): string` ^([ES3])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.replace(searchValue: string | RegExp, replacer: (...args: any[]) => string):
    string` ^([ES3])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.replace()` works like `.replaceAll()`, but only replaces the first occurrence
    if `searchValue` is a string or a regular expression without `/g`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For more information on this method, see [§43.6.8.1 “`str.replace(searchValue,
    replacementValue)` ^([ES3])”](ch_regexps.html#String.prototype.replace).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.toUpperCase(): string` ^([ES1])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a copy of the string in which all lowercase alphabetic characters are
    converted to uppercase. How well that works for various alphabets, depends on
    the JavaScript engine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.toLowerCase(): string` ^([ES1])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a copy of the string in which all uppercase alphabetic characters are
    converted to lowercase. How well that works for various alphabets, depends on
    the JavaScript engine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.trim(): string` ^([ES5])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a copy of the string in which all leading and trailing whitespace (spaces,
    tabs, line terminators, etc.) is gone.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.trimEnd(): string` ^([ES2019])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similar to `.trim()` but only the end of the string is trimmed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.trimStart(): string` ^([ES2019])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similar to `.trim()` but only the beginning of the string is trimmed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 20.8.7 Sources
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[TypeScript’s built-in typings](https://github.com/Microsoft/TypeScript/blob/master/lib/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MDN web docs for JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ECMAScript language specification](https://tc39.github.io/ecma262/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Using string
    methods**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/strings/remove_extension_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz**'
  prefs: []
  type: TYPE_NORMAL
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  prefs: []
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/13)'
  prefs: []
  type: TYPE_NORMAL
