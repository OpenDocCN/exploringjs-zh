<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>29 The satisfies operator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>29 The satisfies operator</h1>
<blockquote>原文：<a href="https://exploringjs.com/ts/book/ch_satisfies.html">https://exploringjs.com/ts/book/ch_satisfies.html</a></blockquote>

    
        <div id="adbox">
      <div id="adbox-explain">(Ad, please don’t block.)</div>
              
          </div>
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#what-is-the-satisfies-operator">29.1 What is the <code>satisfies</code> operator?</a>
      <ol>
        <li>
          <a href="#syntax-no-line-terminator-before-satisfies">29.1.1 Syntax: no line terminator before <code>satisfies</code></a>
        </li>
        <li>
          <a href="#a-first-example">29.1.2 A first example</a>
        </li>
        <li>
          <a href="#example-optional-object-properties">29.1.3 Example: optional object properties</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#type-checking-object-property-values">29.2 Type-checking object property values</a>
      <ol>
        <li>
          <a href="#improvement-a-type-for-property-values">29.2.1 Improvement: a type for property values</a>
        </li>
        <li>
          <a href="#improvement-checking-property-values-via-satisfies">29.2.2 Improvement: checking property values via <code>satisfies</code></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#type-checking-object-property-keys">29.3 Type-checking object property keys</a>
    </li>
    <li>
      <a href="#constraining-literal-values">29.4 Constraining literal values</a>
      <ol>
        <li>
          <a href="#example-posting-json-via-fetch">29.4.1 Example: posting JSON via <code>fetch()</code></a>
        </li>
        <li>
          <a href="#example-export-default">29.4.2 Example: <code>export default</code></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#satisfies-isn-t-always-needed">29.5 <code>satisfies</code> isn’t always needed</a>
      <ol>
        <li>
          <a href="#example-union-of-string-and-number">29.5.1 Example: union of <code>string</code> and <code>number</code></a>
        </li>
        <li>
          <a href="#example-discriminated-union">29.5.2 Example: discriminated union</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#satisfies-can-change-inferred-types">29.6 <code>satisfies</code> can change inferred types</a>
      <ol>
        <li>
          <a href="#from-type-to-literal-type">29.6.1 From type to literal type</a>
        </li>
        <li>
          <a href="#from-array-to-tuple">29.6.2 From Array to tuple</a>
        </li>
        <li>
          <a href="#satisfies-does-not-change-explicit-types">29.6.3 <code>satisfies</code> does not change explicit types</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#type-level-satisfaction-check">29.7 Type-level satisfaction check</a>
    </li>
    <li>
      <a href="#further-reading-9">29.8 Further reading</a>
    </li>
  </ol>
</nav>
<p>The <code>satisfies</code> operator lets us check the type of a value (mostly) without influencing it. In this chapter, we examine how exactly it works and where it’s useful.</p>
<h3 id="what-is-the-satisfies-operator"><a class="heading-id-link" href="#what-is-the-satisfies-operator">29.1 What is the <code>satisfies</code> operator?</a></h3>
<p>The <code>satisfies</code> operator enforces at compile time that a given <code>value</code> is assignable to a given <code>Type</code>:</p>
<pre class="language-ts">
<code>value satisfies <span class="hljs-title class_">Type</span></code>
</pre>
<ul>
  <li>
    The result is still <code>value</code>. This operator has no effect at runtime.
  </li>
  <li>
    The type of <code>value</code> is usually unchanged. There are a few exceptions, though, which we’ll look at later.
  </li>
</ul>
<h4 id="syntax-no-line-terminator-before-satisfies"><a class="heading-id-link" href="#syntax-no-line-terminator-before-satisfies">29.1.1 Syntax: no line terminator before <code>satisfies</code></a></h4>
<p>This is not allowed:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-title function_">sayHello</span> = (<span class="hljs-params">name</span>) =&gt; <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>!`</span></code>
<code>  <span class="hljs-comment">// @ts-expect-error: Cannot find name 'satisfies'.</span></code>
<code>  satisfies (<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>) =&gt; <span class="hljs-built_in">string</span>;</code>
</pre>
<p>Parentheses can help:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> sayHello = (</code>
<code>  <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>!`</span></code>
<code>) satisfies (<span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>) =&gt; <span class="hljs-built_in">string</span>;</code>
</pre>
<h4 id="a-first-example"><a class="heading-id-link" href="#a-first-example">29.1.2 A first example</a></h4>
<p>Let’s examine how various annotations affect the type of an object literal. We start without any annotations:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> point1 = { <span class="hljs-attr">x</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">5</span> };</code>
<code>assertType&lt;</code>
<code>  { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span> }</code>
<code>&gt;(point1);</code>
</pre>
<p>TypeScript generalizes the types of <code>.x</code> and <code>.y</code> to <code>number</code>. That changes if we use the <code>as const</code> annotation:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> point2 = { <span class="hljs-attr">x</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">5</span> } <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code>
<code>assertType&lt;</code>
<code>  { <span class="hljs-keyword">readonly</span> <span class="hljs-attr">x</span>: <span class="hljs-number">2</span>, <span class="hljs-keyword">readonly</span> <span class="hljs-attr">y</span>: <span class="hljs-number">5</span> }</code>
<code>&gt;(point2);</code>
</pre>
<p>Now both properties are read-only and have narrow types. What happens if we want to check that the shape of our point is correct, via a new type <code>Point</code>?</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span> };</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">point3</span>: <span class="hljs-title class_">Point</span> = { <span class="hljs-attr">x</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">5</span> } <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code>
<code>assertType&lt;</code>
<code>  <span class="hljs-title class_">Point</span></code>
<code>&gt;(point3);</code>
</pre>
<p><code>point3</code> once again has a broader type. TypeScript infers the type name <code>Point</code>, which is an alias for the type that <code>point1</code> had. We declared that variable without any type-level annotations.</p>
<p><code>satisfies</code> lets us check that our point has the correct shape without discarding the narrow type that <code>as const</code> gives us:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> point4 = { <span class="hljs-attr">x</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">5</span> } <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span> satisfies <span class="hljs-title class_">Point</span>;</code>
<code>assertType&lt;</code>
<code>  { <span class="hljs-keyword">readonly</span> <span class="hljs-attr">x</span>: <span class="hljs-number">2</span>, <span class="hljs-keyword">readonly</span> <span class="hljs-attr">y</span>: <span class="hljs-number">5</span> }</code>
<code>&gt;(point4);</code>
</pre>
<p>How is <code>satisfies</code> different from <code>as</code>? On one hand, <code>as</code> generally changes the type of its left-hand side. On the other hand, it doesn’t type-check as thoroughly as <code>satisfies</code>:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// Should warn about missing property but doesn’t!</span></code>
<code><span class="hljs-keyword">const</span> point5 = { <span class="hljs-attr">x</span>: <span class="hljs-number">2</span> } <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Point</span>; <span class="hljs-comment">// OK</span></code>
<code>assertType&lt;</code>
<code>  <span class="hljs-title class_">Point</span></code>
<code>&gt;(point5);</code>
</pre>
<p>In contrast, <code>satisfies</code> warns us if we omit property <code>.y</code>:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// @ts-expect-error: Type '{ readonly x: 2; }' does not satisfy</span></code>
<code><span class="hljs-comment">// the expected type 'Point'.</span></code>
<code><span class="hljs-keyword">const</span> point6 = { <span class="hljs-attr">x</span>: <span class="hljs-number">2</span> } <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span> satisfies <span class="hljs-title class_">Point</span>;</code>
</pre>
<p>Why do we want the type of a point to be narrow? Actually, often we are perfectly fine with broader types. But there are use cases that require them to be narrow. We’ll look at those next.</p>
<h4 id="example-optional-object-properties"><a class="heading-id-link" href="#example-optional-object-properties">29.1.3 Example: optional object properties</a></h4>
<p>The following code demonstrates that <code>partialPoint1</code> having the broader type <code>PartialPoint</code> makes it less pleasant to work with:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialPoint</span> = { x?: <span class="hljs-built_in">number</span>, y?: <span class="hljs-built_in">number</span> };</code>
<code/>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">partialPoint1</span>: <span class="hljs-title class_">PartialPoint</span> = { <span class="hljs-attr">y</span>: <span class="hljs-number">7</span> };</code>
<code/>
<code><span class="hljs-comment">// Should be an error</span></code>
<code><span class="hljs-keyword">const</span> x1 = partialPoint1.<span class="hljs-property">x</span>;</code>
<code>assertType&lt;<span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>&gt;(x1);</code>
<code/>
<code><span class="hljs-comment">// Type should be `number`</span></code>
<code><span class="hljs-keyword">const</span> y1 = partialPoint1.<span class="hljs-property">y</span>;</code>
<code>assertType&lt;<span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>&gt;(y1);</code>
</pre>
<p>This is what happens if we use <code>satisfies</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> partialPoint2 = { <span class="hljs-attr">y</span>: <span class="hljs-number">7</span> } satisfies <span class="hljs-title class_">PartialPoint</span>;</code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Property 'x' does not exist on type</span></code>
<code><span class="hljs-comment">// '{ y: number; }'.</span></code>
<code><span class="hljs-keyword">const</span> x2 = partialPoint2.<span class="hljs-property">x</span>;</code>
<code/>
<code><span class="hljs-keyword">const</span> y2 = partialPoint2.<span class="hljs-property">y</span>;</code>
<code>assertType&lt;<span class="hljs-built_in">number</span>&gt;(y2);</code>
</pre>
<h3 id="type-checking-object-property-values"><a class="heading-id-link" href="#type-checking-object-property-values">29.2 Type-checking object property values</a></h3>
<p>The following object implements an enum for text styles:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-title class_">TextStyle</span> = {</code>
<code>  <span class="hljs-title class_">Bold</span>: {</code>
<code>    <span class="hljs-attr">html</span>: <span class="hljs-string">'b'</span>,</code>
<code>    <span class="hljs-attr">latex</span>: <span class="hljs-string">'textbf'</span>,</code>
<code>  },</code>
<code>  <span class="hljs-title class_">Italics</span>: {</code>
<code>    <span class="hljs-attr">html</span>: <span class="hljs-string">'i'</span>,</code>
<code>    <span class="hljs-comment">// Missing: latex</span></code>
<code>  },</code>
<code>};</code>
<code/>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">TextStyleKeys</span> = keyof <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">TextStyle</span>;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">TextStyleKeys</span>, <span class="hljs-string">"Bold"</span> | <span class="hljs-string">"Italics"</span></code>
<code>&gt;&gt;;</code>
</pre>
<ul>
  <li>
    On one hand, it’s neat that we can derive a type <code>TextStyleKeys</code> with property keys.
  </li>
  <li>
    On the other hand, we forgot property <code>TextStyle.Italics.latex</code> and TypeScript didn’t warn us.
  </li>
</ul>
<h4 id="improvement-a-type-for-property-values"><a class="heading-id-link" href="#improvement-a-type-for-property-values">29.2.1 Improvement: a type for property values</a></h4>
<p>Let’s use the following type to check property values:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">TTextStyle</span> = {</code>
<code>  <span class="hljs-attr">html</span>: <span class="hljs-built_in">string</span>,</code>
<code>  <span class="hljs-attr">latex</span>: <span class="hljs-built_in">string</span>,</code>
<code>};</code>
</pre>
<p>Our first attempt looks like this:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-title class_">TextStyle</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">TTextStyle</span>&gt;  = {</code>
<code>  <span class="hljs-title class_">Bold</span>: {</code>
<code>    <span class="hljs-attr">html</span>: <span class="hljs-string">'b'</span>,</code>
<code>    <span class="hljs-attr">latex</span>: <span class="hljs-string">'textbf'</span>,</code>
<code>  },</code>
<code>  <span class="hljs-comment">// @ts-expect-error: Property 'latex' is missing in type</span></code>
<code>  <span class="hljs-comment">// '{ html: string; }' but required in type 'TTextStyle'.</span></code>
<code>  <span class="hljs-title class_">Italics</span>: {</code>
<code>    <span class="hljs-attr">html</span>: <span class="hljs-string">'i'</span>,</code>
<code>  },</code>
<code>};</code>
<code/>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">TextStyleKeys</span> = keyof <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">TextStyle</span>;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">TextStyleKeys</span>, <span class="hljs-built_in">string</span></code>
<code>&gt;&gt;;</code>
</pre>
<ul>
  <li>
    Upside: We get a warning that a property is missing.
  </li>
  <li>
    Downside: We can’t extract the property keys anymore – <code>TextStyleKeys</code> is now <code>string</code>.
  </li>
</ul>
<h4 id="improvement-checking-property-values-via-satisfies"><a class="heading-id-link" href="#improvement-checking-property-values-via-satisfies">29.2.2 Improvement: checking property values via <code>satisfies</code></a></h4>
<p>Once again, <code>satisfies</code> can help us:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-title class_">TextStyle</span>  = {</code>
<code>  <span class="hljs-title class_">Bold</span>: {</code>
<code>    <span class="hljs-attr">html</span>: <span class="hljs-string">'b'</span>,</code>
<code>    <span class="hljs-attr">latex</span>: <span class="hljs-string">'textbf'</span>,</code>
<code>  },</code>
<code>  <span class="hljs-comment">// @ts-expect-error: Property 'latex' is missing in type</span></code>
<code>  <span class="hljs-comment">// '{ html: string; }' but required in type 'TTextStyle'.</span></code>
<code>  <span class="hljs-title class_">Italics</span>: {</code>
<code>    <span class="hljs-attr">html</span>: <span class="hljs-string">'i'</span>,</code>
<code>  },</code>
<code>} satisfies <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">TTextStyle</span>&gt;;</code>
<code/>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">TextStyleKeys</span> = keyof <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">TextStyle</span>;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">TextStyleKeys</span>, <span class="hljs-string">"Bold"</span> | <span class="hljs-string">"Italics"</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>Now we get a warning for the missing property and a useful type <code>TextStyleKeys</code>.</p>
<h3 id="type-checking-object-property-keys"><a class="heading-id-link" href="#type-checking-object-property-keys">29.3 Type-checking object property keys</a></h3>
<p>In the previous example, we checked the shapes of property values. Sometimes we are additionally dealing with a limited set of property keys and would like to check those – to avoid typos etc.</p>
<p>The following example is inspired by <a href="https://github.com/microsoft/TypeScript/issues/47920">the pull request for <code>satisfies</code></a> and uses the type <code>ColorName</code> to check property keys and the type <code>Color</code> to check property values. We get an error because they key <code>'blue'</code> is missing:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ColorName</span> = <span class="hljs-string">'red'</span> | <span class="hljs-string">'green'</span> | <span class="hljs-string">'blue'</span>;</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Color</span> =</code>
<code>  | <span class="hljs-built_in">string</span> <span class="hljs-comment">// hex</span></code>
<code>  | [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>] <span class="hljs-comment">// RGB</span></code>
<code>;</code>
<code><span class="hljs-keyword">const</span> fullColorTable = {</code>
<code>  <span class="hljs-attr">red</span>: [<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</code>
<code>  <span class="hljs-attr">green</span>: <span class="hljs-string">'#00FF00'</span>,</code>
<code><span class="hljs-comment">// @ts-expect-error:</span></code>
<code><span class="hljs-comment">// Type '{ red: [number, number, number]; green: string; }'</span></code>
<code><span class="hljs-comment">// does not satisfy the expected type 'Record&lt;ColorName, Color&gt;'.</span></code>
<code>} satisfies <span class="hljs-title class_">Record</span>&lt;<span class="hljs-title class_">ColorName</span>, <span class="hljs-title class_">Color</span>&gt;;</code>
</pre>
<p>What if we don’t want to use all of the keys but still get checks for typos? That can be achieved by making the record for the object partial (line A):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> partialColorTable = {</code>
<code>  <span class="hljs-attr">red</span>: [<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</code>
<code>  <span class="hljs-comment">// @ts-expect-error: Object literal may only specify known</span></code>
<code>  <span class="hljs-comment">// properties, but 'greenn' does not exist in type</span></code>
<code>  <span class="hljs-comment">// 'Partial&lt;Record&lt;ColorName, Color&gt;&gt;'.</span></code>
<code>  <span class="hljs-comment">// Did you mean to write 'green'?</span></code>
<code>  <span class="hljs-attr">greenn</span>: <span class="hljs-string">'#00FF00'</span>,</code>
<code>} satisfies <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">Record</span>&lt;<span class="hljs-title class_">ColorName</span>, <span class="hljs-title class_">Color</span>&gt;&gt;; <span class="hljs-comment">// (A)</span></code>
</pre>
<p>We can also extract the property keys:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> partialColorTable2 = {</code>
<code>  <span class="hljs-attr">red</span>: [<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</code>
<code>  <span class="hljs-attr">green</span>: <span class="hljs-string">'#00FF00'</span>,</code>
<code>} satisfies <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">Record</span>&lt;<span class="hljs-title class_">ColorName</span>, <span class="hljs-title class_">Color</span>&gt;&gt;;</code>
<code/>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">PropKeys</span> = keyof <span class="hljs-keyword">typeof</span> partialColorTable2;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">PropKeys</span>, <span class="hljs-string">"red"</span> | <span class="hljs-string">"green"</span></code>
<code>&gt;&gt;;</code>
</pre>
<h3 id="constraining-literal-values"><a class="heading-id-link" href="#constraining-literal-values">29.4 Constraining literal values</a></h3>
<p>Consider the following function call:</p>
<pre class="language-ts">
<code><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-comment">/*···*/</span> });</code>
</pre>
<p>The parameter of <code>JSON.stringify()</code> has the type <code>any</code>. How can we ensure on our end that the object we pass to it has the right shape (no typos in the property keys etc.)? One option is to create a variable for the object:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>: <span class="hljs-title class_">SomeType</span> = { <span class="hljs-comment">/*···*/</span> };</code>
<code><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj);</code>
</pre>
<p>Another option is to use <code>satisfies</code>:</p>
<pre class="language-ts">
<code><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-comment">/*···*/</span> } satisfies <span class="hljs-title class_">SomeType</span>);</code>
</pre>
<p>The following subsections demonstrate this technique for several use cases.</p>
<h4 id="example-posting-json-via-fetch"><a class="heading-id-link" href="#example-posting-json-via-fetch">29.4.1 Example: posting JSON via <code>fetch()</code></a></h4>
<p>The following code was inspired by <a href="https://www.totaltypescript.com/how-to-use-satisfies-operator#strongly-typed-post-request-with-satisfies">an article by Matt Pocock</a>: We are using <code>fetch()</code> to post data to an API.</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Product</span> = {</code>
<code>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,</code>
<code>  <span class="hljs-attr">quantity</span>: <span class="hljs-built_in">number</span>,</code>
<code>};</code>
<code/>
<code><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'/api/products'</span>, {</code>
<code>  <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,</code>
<code>  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(</code>
<code>    {</code>
<code>      <span class="hljs-attr">name</span>: <span class="hljs-string">'Toothbrush'</span>,</code>
<code>      <span class="hljs-attr">quantity</span>: <span class="hljs-number">3</span>,</code>
<code>    } satisfies <span class="hljs-title class_">Product</span></code>
<code>  ),</code>
<code>  <span class="hljs-attr">headers</span>: {</code>
<code>    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,</code>
<code>  },</code>
<code>});</code>
</pre>
<h4 id="example-export-default"><a class="heading-id-link" href="#example-export-default">29.4.2 Example: <code>export default</code></a></h4>
<p>Inline named exports can have type annotations:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">StringCallback</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./core.js'</span>;</code>
<code/>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">toUpperCase</span>: <span class="hljs-title class_">StringCallback</span> =</code>
<code>  <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> str.<span class="hljs-title function_">toUpperCase</span>();</code>
</pre>
<p>With a default export, there is no way to add one but we can use <code>satisfies</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">StringCallback</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./core.js'</span>;</code>
<code/>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (</code>
<code>  <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> str.<span class="hljs-title function_">toUpperCase</span>()</code>
<code>) satisfies <span class="hljs-title class_">StringCallback</span>;</code>
</pre>
<h3 id="satisfies-isn-t-always-needed"><a class="heading-id-link" href="#satisfies-isn-t-always-needed">29.5 <code>satisfies</code> isn’t always needed</a></h3>
<p>In this section, we look at code where it seems like we would need <code>satisfies</code>, but TypeScript already correctly narrows the code.</p>
<h4 id="example-union-of-string-and-number"><a class="heading-id-link" href="#example-union-of-string-and-number">29.5.1 Example: union of <code>string</code> and <code>number</code></a></h4>
<p>In the following code, we don’t need to use <code>satisfies</code> for <code>str1</code> and <code>str2</code> – they are already narrowed to <code>string</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">StrOrNum</span> = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;</code>
<code/>
<code><span class="hljs-keyword">const</span> str1 = <span class="hljs-string">'abc'</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">StrOrNum</span>;</code>
<code><span class="hljs-comment">// @ts-expect-error: Property 'toUpperCase' does not exist on</span></code>
<code><span class="hljs-comment">// type 'StrOrNum'.</span></code>
<code>str1.<span class="hljs-title function_">toUpperCase</span>();</code>
<code/>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">str2</span>: <span class="hljs-title class_">StrOrNum</span> = <span class="hljs-string">'abc'</span>;</code>
<code>str2.<span class="hljs-title function_">toUpperCase</span>(); <span class="hljs-comment">// OK</span></code>
<code/>
<code><span class="hljs-keyword">let</span> <span class="hljs-attr">str3</span>: <span class="hljs-title class_">StrOrNum</span> = <span class="hljs-string">'abc'</span>;</code>
<code>str3.<span class="hljs-title function_">toUpperCase</span>(); <span class="hljs-comment">// OK</span></code>
</pre>
<h4 id="example-discriminated-union"><a class="heading-id-link" href="#example-discriminated-union">29.5.2 Example: discriminated union</a></h4>
<p>In the next example, <code>linkToIntro</code> is also narrowed to one element of the discriminated union <code>LinkHref</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">LinkHref</span> =</code>
<code>  | {</code>
<code>    <span class="hljs-attr">kind</span>: <span class="hljs-string">'LinkHrefUrl'</span>,</code>
<code>    <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>,</code>
<code>  }</code>
<code>  | {</code>
<code>    <span class="hljs-attr">kind</span>: <span class="hljs-string">'LinkHrefId'</span>,</code>
<code>    <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>,</code>
<code>  }</code>
<code>;</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">linkToIntro</span>: <span class="hljs-title class_">LinkHref</span> = {</code>
<code>  <span class="hljs-attr">kind</span>: <span class="hljs-string">'LinkHrefId'</span>,</code>
<code>  <span class="hljs-attr">id</span>: <span class="hljs-string">'#intro'</span>,</code>
<code>};</code>
<code><span class="hljs-comment">// Type was narrowed:</span></code>
<code>assertType&lt;</code>
<code>  {</code>
<code>    <span class="hljs-attr">kind</span>: <span class="hljs-string">'LinkHrefId'</span>,</code>
<code>    <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>,</code>
<code>  }</code>
<code>&gt;(linkToIntro);</code>
</pre>
<h3 id="satisfies-can-change-inferred-types"><a class="heading-id-link" href="#satisfies-can-change-inferred-types">29.6 <code>satisfies</code> can change inferred types</a></h3>
<p>While <code>satisfies</code> usually does not change the inferred type of a value, there are exceptions.</p>
<h4 id="from-type-to-literal-type"><a class="heading-id-link" href="#from-type-to-literal-type">29.6.1 From type to literal type</a></h4>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Robin</span> = {</code>
<code>  <span class="hljs-attr">name</span>: <span class="hljs-string">'Robin'</span>,</code>
<code>};</code>
<code/>
<code><span class="hljs-keyword">const</span> robin1 = { <span class="hljs-attr">name</span>: <span class="hljs-string">'Robin'</span> };</code>
<code>assertType&lt;<span class="hljs-built_in">string</span>&gt;(robin1.<span class="hljs-property">name</span>);</code>
<code/>
<code><span class="hljs-keyword">const</span> robin2 = { <span class="hljs-attr">name</span>: <span class="hljs-string">'Robin'</span> } satisfies <span class="hljs-title class_">Robin</span>;</code>
<code>assertType&lt;<span class="hljs-string">'Robin'</span>&gt;(robin2.<span class="hljs-property">name</span>);</code>
</pre>
<h4 id="from-array-to-tuple"><a class="heading-id-link" href="#from-array-to-tuple">29.6.2 From Array to tuple</a></h4>
<pre class="language-ts">
<code><span class="hljs-comment">// No `satisfies`</span></code>
<code><span class="hljs-keyword">const</span> tuple1 = [<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>];</code>
<code>assertType&lt;</code>
<code>  (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[]</code>
<code>&gt;(tuple1);</code>
<code/>
<code><span class="hljs-comment">// Non-empty tuple</span></code>
<code><span class="hljs-keyword">const</span> tuple2 = [<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>] satisfies [<span class="hljs-built_in">unknown</span>, ...<span class="hljs-built_in">unknown</span>[]];</code>
<code>assertType&lt;</code>
<code>  [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>]</code>
<code>&gt;(tuple2);</code>
<code/>
<code><span class="hljs-comment">// Any tuple</span></code>
<code><span class="hljs-keyword">const</span> tuple3 = [] satisfies [<span class="hljs-built_in">unknown</span>?, ...<span class="hljs-built_in">unknown</span>[]];</code>
<code>assertType&lt;</code>
<code>  []</code>
<code>&gt;(tuple3);</code>
<code/>
<code><span class="hljs-comment">// Any tuple</span></code>
<code><span class="hljs-keyword">const</span> tuple4 = [<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>] satisfies [] | <span class="hljs-built_in">unknown</span>[];</code>
<code>assertType&lt;</code>
<code>  [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>]</code>
<code>&gt;(tuple4);</code>
</pre>
<h4 id="satisfies-does-not-change-explicit-types"><a class="heading-id-link" href="#satisfies-does-not-change-explicit-types">29.6.3 <code>satisfies</code> does not change explicit types</a></h4>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">tuple1</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>&gt; = [<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>];</code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Type '(string | number)[]' does not satisfy</span></code>
<code><span class="hljs-comment">// the expected type '[unknown, ...unknown[]]'.</span></code>
<code><span class="hljs-keyword">const</span> tuple2 = tuple1 satisfies [<span class="hljs-built_in">unknown</span>, ...<span class="hljs-built_in">unknown</span>[]];</code>
</pre>
<h3 id="type-level-satisfaction-check"><a class="heading-id-link" href="#type-level-satisfaction-check">29.7 Type-level satisfaction check</a></h3>
<p>TypeScript does have an operation at the type level that is similar to <code>satisfies</code>, but we can implement it ourselves:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Satisfies</span>&lt;<span class="hljs-title class_">Type</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Constraint</span>, <span class="hljs-title class_">Constraint</span>&gt; = <span class="hljs-title class_">Type</span>;</code>
<code/>
<code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Satisfies</span>&lt;<span class="hljs-number">123</span>, <span class="hljs-built_in">number</span>&gt;; <span class="hljs-comment">// 123</span></code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-variable constant_">T1</span>, <span class="hljs-number">123</span></code>
<code>&gt;&gt;;</code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Type 'number' does not satisfy</span></code>
<code><span class="hljs-comment">// the constraint 'string'.</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">Satisfies</span>&lt;<span class="hljs-number">123</span>, <span class="hljs-built_in">string</span>&gt;;</code>
</pre>
<h3 id="further-reading-9"><a class="heading-id-link" href="#further-reading-9">29.8 Further reading</a></h3>
<ul>
  <li>
    Pull request <a href="https://github.com/microsoft/TypeScript/issues/47920">“<code>satisfies</code> operator to ensure an expression matches some type”</a>
  </li>
</ul>

    
      
</body>
</html>