<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>29 Modules ES6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>29 Modules ES6</h1>
<blockquote>原文：<a href="https://exploringjs.com/js/book/ch_modules.html">https://exploringjs.com/js/book/ch_modules.html</a></blockquote>

        
    
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#cheat-sheet-modules">29.1 Cheat sheet: modules</a>
      <ol>
        <li>
          <a href="#named-exports-named-imports-namespace-imports">29.1.1 Named exports, named imports, namespace imports</a>
        </li>
        <li>
          <a href="#dynamic-imports-via-import-es2020">29.1.2 Dynamic imports via <code>import()</code><span> <sup>ES2020</sup></span></a>
        </li>
        <li>
          <a href="#default-exports-and-imports">29.1.3 Default exports and imports</a>
        </li>
        <li>
          <a href="#kinds-of-module-specifiers">29.1.4 Kinds of module specifiers</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#source-code-units">29.2 JavaScript’s source code units: scripts and modules</a>
      <ol>
        <li>
          <a href="#code-before-builtin-modules-was-written-in-ecmascript-5">29.2.1 Code before built-in modules was written in ECMAScript 5</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#scripts">29.3 Before we had modules, we had scripts</a>
    </li>
    <li>
      <a href="#module-systems-created-prior-to-es6">29.4 Module systems created prior to ES6</a>
      <ol>
        <li>
          <a href="#server-side-commonjs-modules">29.4.1 Server side: CommonJS modules</a>
        </li>
        <li>
          <a href="#client-side-amd-asynchronous-module-definition-modules">29.4.2 Client side: AMD (Asynchronous Module Definition) modules</a>
        </li>
        <li>
          <a href="#characteristics-of-javascript-modules">29.4.3 Characteristics of JavaScript modules</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#ecmascript-modules">29.5 ECMAScript modules</a>
      <ol>
        <li>
          <a href="#es-modules-syntax-semantics-loader-api">29.5.1 ES modules: syntax, semantics, loader API</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#named-exports-and-imports">29.6 Named exports and imports</a>
      <ol>
        <li>
          <a href="#named-exports">29.6.1 Named exports</a>
        </li>
        <li>
          <a href="#named-imports">29.6.2 Named imports</a>
        </li>
        <li>
          <a href="#namespace-imports">29.6.3 Namespace imports</a>
        </li>
        <li>
          <a href="#named-exporting-styles-inline-versus-clause-advanced">29.6.4 Named exporting styles: inline versus clause<span> (advanced)</span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#default-exports-and-default-imports">29.7 Default exports and default imports</a>
      <ol>
        <li>
          <a href="#the-two-styles-of-defaultexporting">29.7.1 The two styles of default-exporting</a>
        </li>
        <li>
          <a href="#the-default-export-as-a-named-export-advanced">29.7.2 The default export as a named export<span> (advanced)</span></a>
        </li>
        <li>
          <a href="#recommendations-named-exports-vs-default-exports">29.7.3 Recommendations: named exports vs. default exports</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#re-exporting">29.8 Re-exporting</a>
    </li>
    <li>
      <a href="#more-details-on-exporting-and-importing">29.9 More details on exporting and importing</a>
      <ol>
        <li>
          <a href="#imports-are-readonly-views-on-exports">29.9.1 Imports are read-only views on exports</a>
        </li>
        <li>
          <a href="#esms-transparent-support-for-cyclic-imports-advanced">29.9.2 ESM’s transparent support for cyclic imports<span> (advanced)</span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#javascript-packages">29.10 Packages: JavaScript’s units for software distribution</a>
      <ol>
        <li>
          <a href="#publishing-packages">29.10.1 Publishing packages: package registries, package managers, package names</a>
        </li>
        <li>
          <a href="#package-file-system-layout">29.10.2 The file system layout of a package</a>
        </li>
        <li>
          <a href="#packagejson">29.10.3 <code>package.json</code></a>
        </li>
        <li>
          <a href="#package-exports">29.10.4 Package exports: controlling what other packages see</a>
        </li>
        <li>
          <a href="#package-imports">29.10.5 Package imports</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#naming-modules">29.11 Naming modules</a>
    </li>
    <li>
      <a href="#module-specifiers">29.12 Module specifiers</a>
      <ol>
        <li>
          <a href="#kinds-of-module-specifiers-1">29.12.1 Kinds of module specifiers</a>
        </li>
        <li>
          <a href="#filename-extensions-in-module-specifiers">29.12.2 Filename extensions in module specifiers</a>
        </li>
        <li>
          <a href="#module-specifiers-in-nodejs">29.12.3 Module specifiers in Node.js</a>
        </li>
        <li>
          <a href="#module-specifiers-in-browsers">29.12.4 Module specifiers in browsers</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#import.meta">29.13 <code>import.meta</code> – metadata for the current module<span> <sup>ES2020</sup></span></a>
      <ol>
        <li>
          <a href="#import.meta.url">29.13.1 <code>import.meta.url</code></a>
        </li>
        <li>
          <a href="#importmetaurl-and-class-url">29.13.2 <code>import.meta.url</code> and class <code>URL</code></a>
        </li>
        <li>
          <a href="#importmetaurl-on-nodejs">29.13.3 <code>import.meta.url</code> on Node.js</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#dynamic-imports">29.14 Loading modules dynamically via <code>import()</code><span> <sup>ES2020</sup> (advanced)</span></a>
      <ol>
        <li>
          <a href="#the-limitations-of-static-import-statements">29.14.1 The limitations of static <code>import</code> statements</a>
        </li>
        <li>
          <a href="#dynamic-imports-via-the-import-operator">29.14.2 Dynamic imports via the <code>import()</code> operator</a>
        </li>
        <li>
          <a href="#use-cases-for-import">29.14.3 Use cases for <code>import()</code></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#top-level-await">29.15 Top-level <code>await</code> in modules<span> <sup>ES2022</sup> (advanced)</span></a>
      <ol>
        <li>
          <a href="#use-cases-for-toplevel-await">29.15.1 Use cases for top-level <code>await</code></a>
        </li>
        <li>
          <a href="#how-does-toplevel-await-work-under-the-hood">29.15.2 How does top-level <code>await</code> work under the hood?</a>
        </li>
        <li>
          <a href="#the-pros-and-cons-of-toplevel-await">29.15.3 The pros and cons of top-level <code>await</code></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#import-attributes">29.16 Import attributes: importing non-JavaScript artifacts<span> <sup>ES2025</sup></span></a>
      <ol>
        <li>
          <a href="#the-history-of-importing-nonjavascript-artifacts">29.16.1 The history of importing non-JavaScript artifacts</a>
        </li>
        <li>
          <a href="#use-cases-for-importing-nonjavascript-artifacts">29.16.2 Use cases for importing non-JavaScript artifacts</a>
        </li>
        <li>
          <a href="#import-attributes-1">29.16.3 Import attributes</a>
        </li>
        <li>
          <a href="#the-syntax-of-import-attributes">29.16.4 The syntax of import attributes</a>
        </li>
        <li>
          <a href="#json-modules">29.16.5 JSON modules<span> <sup>ES2025</sup></span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#polyfills">29.17 Polyfills: emulating native web platform features<span> (advanced)</span></a>
      <ol>
        <li>
          <a href="#sources-of-this-section">29.17.1 Sources of this section</a>
        </li>
      </ol>
    </li>
  </ol>
</nav>
<h3 id="cheat-sheet-modules"><a class="heading-id-link" href="#cheat-sheet-modules">29.1 Cheat sheet: modules</a></h3>
<h4 id="named-exports-named-imports-namespace-imports"><a class="heading-id-link" href="#named-exports-named-imports-namespace-imports">29.1.1 Named exports, named imports, namespace imports</a></h4>
<p>If we put <code>export</code> in front of a named entity inside a module, it becomes a <em>named export</em> of that module. All other entities are private to the module.</p>
<pre class="language-js">
<code><span class="hljs-comment">//===== lib.mjs =====</span></code>
<code><span class="hljs-comment">// Named exports</span></code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> one = <span class="hljs-number">1</span>, two = <span class="hljs-number">2</span>;</code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<pre class="language-js">
<code><span class="hljs-comment">//===== main.mjs =====</span></code>
<code><span class="hljs-comment">// Named imports</span></code>
<code><span class="hljs-keyword">import</span> {one, myFunc <span class="hljs-keyword">as</span> f} <span class="hljs-keyword">from</span> <span class="hljs-string">'./lib.mjs'</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(one, <span class="hljs-number">1</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">f</span>(), <span class="hljs-number">3</span>);</code>
<code/>
<code><span class="hljs-comment">// Namespace import</span></code>
<code><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> lib <span class="hljs-keyword">from</span> <span class="hljs-string">'./lib.mjs'</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(lib.<span class="hljs-property">one</span>, <span class="hljs-number">1</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(lib.<span class="hljs-title function_">myFunc</span>(), <span class="hljs-number">3</span>);</code>
</pre>
<p>The string after <code>from</code> is called a <em>module specifier</em>. It identifies from which module we want to import.</p>
<h4 id="dynamic-imports-via-import-es2020"><a class="heading-id-link" href="#dynamic-imports-via-import-es2020">29.1.2 Dynamic imports via <code>import()</code><span> <sup>ES2020</sup></span></a></h4>
<p>So far, all imports we have seen were <em>static</em>, with the following constraints:</p>
<ul>
  <li>
    They have to appear at the top level of a module.
  </li>
  <li>
    The module specifier is fixed.
  </li>
</ul>
<p>Dynamic imports via <code>import()</code> don’t have those constraints:</p>
<pre class="language-js">
<code><span class="hljs-comment">//===== lib.mjs =====</span></code>
<code><span class="hljs-comment">// Named exports</span></code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> one = <span class="hljs-number">1</span>, two = <span class="hljs-number">2</span>;</code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<pre class="language-js">
<code><span class="hljs-comment">//===== main.mjs =====</span></code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">importLibrary</span>(<span class="hljs-params">moduleSpecifier</span>) {</code>
<code>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">import</span>(moduleSpecifier)</code>
<code>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">lib</span>) =&gt;</span> {</code>
<code>    assert.<span class="hljs-title function_">equal</span>(lib.<span class="hljs-property">one</span>, <span class="hljs-number">1</span>);</code>
<code>    assert.<span class="hljs-title function_">equal</span>(lib.<span class="hljs-title function_">myFunc</span>(), <span class="hljs-number">3</span>);</code>
<code>  });</code>
<code>}</code>
<code><span class="hljs-keyword">await</span> importLibrary(<span class="hljs-string">'./lib.mjs'</span>);</code>
</pre>
<h4 id="default-exports-and-imports"><a class="heading-id-link" href="#default-exports-and-imports">29.1.3 Default exports and imports</a></h4>
<p>A <em>default export</em> is most often used when a module only contains a single entity (even though it can be combined with named exports):</p>
<pre class="language-js">
<code><span class="hljs-comment">//===== lib1.mjs =====</span></code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getHello</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">return</span> <span class="hljs-string">'hello'</span>;</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p>There can be at most one default export. That’s why <code>const</code> or <code>let</code> can’t be default-exported (line A):</p>
<pre class="language-js">
<code><span class="hljs-comment">//===== lib2.mjs =====</span></code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-number">123</span>; <span class="hljs-comment">// (A) instead of `const`</span></code>
</pre>
<p>This is the syntax for importing default exports:</p>
<pre class="language-js">
<code><span class="hljs-comment">//===== main.mjs =====</span></code>
<code><span class="hljs-keyword">import</span> lib1 <span class="hljs-keyword">from</span> <span class="hljs-string">'./lib1.mjs'</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">lib1</span>(), <span class="hljs-string">'hello'</span>);</code>
<code/>
<code><span class="hljs-keyword">import</span> lib2 <span class="hljs-keyword">from</span> <span class="hljs-string">'./lib2.mjs'</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(lib2, <span class="hljs-number">123</span>);</code>
</pre>
<h4 id="kinds-of-module-specifiers"><a class="heading-id-link" href="#kinds-of-module-specifiers">29.1.4 Kinds of module specifiers</a></h4>
<p>Module specifiers identify modules. There are three kinds of them:</p>
<ul>
  <li>
    <p><em>Absolute specifiers</em> are full URLs – for example:</p>
<pre class="language-js">
<code><span class="hljs-string">'https://www.unpkg.com/browse/yargs@17.3.1/browser.mjs'</span></code>
<code><span class="hljs-string">'file:///opt/nodejs/config.mjs'</span></code>
</pre>
    <p>Absolute specifiers are mostly used to access libraries that are directly hosted on the web.</p>
  </li>
  <li>
    <p><em>Relative specifiers</em> are relative URLs (starting with <code>'/'</code>, <code>'./'</code> or <code>'../'</code>) – for example:</p>
<pre class="language-js">
<code><span class="hljs-string">'./sibling-module.js'</span></code>
<code><span class="hljs-string">'../module-in-parent-dir.mjs'</span></code>
<code><span class="hljs-string">'../../dir/other-module.js'</span></code>
</pre>
    <p>Every module has a URL whose protocol depends on its location (<code>file:</code>, <code>https:</code>, etc.). If it uses a relative specifier, JavaScript turns that specifier into a full URL by resolving it against the module’s URL.</p>
    <p>Relative specifiers are mostly used to access other modules within the same code base.</p>
  </li>
  <li>
    <p><em>Bare specifiers</em> are paths (without protocol and domain) that start with neither slashes nor dots. They begin with the names of packages. Those names can optionally be followed by <em>subpaths</em>:</p>
<pre class="language-js">
<code><span class="hljs-string">'some-package'</span></code>
<code><span class="hljs-string">'some-package/sync'</span></code>
<code><span class="hljs-string">'some-package/util/files/path-tools.js'</span></code>
</pre>
    <p>Bare specifiers can also refer to packages with scoped names:</p>
<pre class="language-js">
<code><span class="hljs-string">'@some-scope/scoped-name'</span></code>
<code><span class="hljs-string">'@some-scope/scoped-name/async'</span></code>
<code><span class="hljs-string">'@some-scope/scoped-name/dir/some-module.mjs'</span></code>
</pre>
    <p>Each bare specifier refers to exactly one module inside a package; if it has no subpath, it refers to the designated “main” module of its package.</p>
    <p>A bare specifier is never used directly but always <em>resolved</em> – translated to an absolute specifier. How resolution works depends on the platform.</p>
  </li>
</ul>
<h3 id="source-code-units"><a class="heading-id-link" href="#source-code-units">29.2 JavaScript’s source code units: scripts and modules</a></h3>
<p>What does “source code unit” mean in the world of JavaScript?</p>
<ul>
  <li>
    A chunk of JavaScript source code (text)
  </li>
  <li>
    Often one unit is stored in a single file.
  </li>
  <li>
    We can also embed multiple units in a single HTML file.
  </li>
</ul>
<p>JavaScript has a rich history of source code units: ES6 brought built-in modules, but older formats are still around, too. Understanding the latter helps understand the former, so let’s investigate. The next sections describe the following ways of delivering JavaScript source code:</p>
<ul>
  <li>
    <em>Scripts</em> are code fragments that browsers run in global scope. They are precursors of modules.
  </li>
  <li>
    <em>CommonJS modules</em> are a module format designed for servers (e.g., via Node.js).
  </li>
  <li>
    <em>AMD modules</em> are a module format designed for browsers.
  </li>
  <li>
    <em>ECMAScript modules</em> are JavaScript’s built-in module format. It supersedes all previous formats.
  </li>
</ul>
<p><a href="#tbl:source-code-units">Table 29.1</a> gives an overview of these source code units. Note that we can choose between two filename extensions for CommonJS modules and ECMAScript modules. Which choice to make depends on how we want to use a file. Details are given later in this chapter.</p>
<figure id="tbl:source-code-units" class="float">
  <table class="framed">
    <style>
      th:nth-child(1), td:nth-child(1) {
        text-align: left;
      }
      th:nth-child(2), td:nth-child(2) {
        text-align: left;
      }
      th:nth-child(3), td:nth-child(3) {
        text-align: left;
      }
      th:nth-child(4), td:nth-child(4) {
        text-align: left;
      }
      th:nth-child(5), td:nth-child(5) {
        text-align: left;
      }
    </style>
    <thead>
      <tr>
        <th/><th>Usage</th><th>Runs on</th><th>Loaded</th><th>Filename ext.</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Script</td><td>Legacy</td><td>browsers</td><td>async</td><td><code>.js</code></td>
      </tr>
      <tr>
        <td>CommonJS module</td><td>Decreasing</td><td>servers</td><td>sync</td><td><code>.js .cjs</code></td>
      </tr>
      <tr>
        <td>AMD module</td><td>Legacy</td><td>browsers</td><td>async</td><td><code>.js</code></td>
      </tr>
      <tr>
        <td>ECMAScript module</td><td>Modern</td><td>browsers, servers</td><td>async</td><td><code>.js .mjs</code></td>
      </tr>
    </tbody>
  </table>
  <figcaption>
    <p><span class="float-label">Table 29.1:</span> Ways of delivering JavaScript source code.</p>
  </figcaption>
</figure>
<h4 id="code-before-builtin-modules-was-written-in-ecmascript-5"><a class="heading-id-link" href="#code-before-builtin-modules-was-written-in-ecmascript-5">29.2.1 Code before built-in modules was written in ECMAScript 5</a></h4>
<p>Before we get to built-in modules (which were introduced with ES6), all code that we’ll see, will be written in ES5. Among other things:</p>
<ul>
  <li>
    ES5 did not have <code>const</code> and <code>let</code>; only <code>var</code>.
  </li>
  <li>
    ES5 did not have arrow functions; only function expressions.
  </li>
</ul>
<h3 id="scripts"><a class="heading-id-link" href="#scripts">29.3 Before we had modules, we had scripts</a></h3>
<p><span id="index-entry-script"/></p>
<p>Initially, browsers only had <em>scripts</em> – pieces of code that were executed in global scope. As an example, consider an HTML file that loads script files via the following HTML:</p>
<pre class="language-html">
<code><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"other-module1.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code>
<code><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"other-module2.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code>
<code><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"my-module.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code>
</pre>
<p>The main file is <code>my-module.js</code>, where we simulate a module:</p>
<pre class="language-js">
<code><span class="hljs-keyword">var</span> myModule = (<span class="hljs-keyword">function</span> (<span class="hljs-params">) { <span class="hljs-comment">// Open IIFE</span></span></code>
<code><span class="hljs-params">  <span class="hljs-comment">// Imports (via global variables)</span></span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">var</span> importedFunc1 = otherModule1.<span class="hljs-property">importedFunc1</span>;</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">var</span> importedFunc2 = otherModule2.<span class="hljs-property">importedFunc2</span>;</span></code>
<code/>
<code><span class="hljs-params">  <span class="hljs-comment">// Body</span></span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">internalFunc</span>(<span class="hljs-params"/>) {</span></code>
<code><span class="hljs-params">    <span class="hljs-comment">// ···</span></span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">exportedFunc</span>(<span class="hljs-params"/>) {</span></code>
<code><span class="hljs-params">    importedFunc1();</span></code>
<code><span class="hljs-params">    importedFunc2();</span></code>
<code><span class="hljs-params">    <span class="hljs-title function_">internalFunc</span>();</span></code>
<code><span class="hljs-params">  }</span></code>
<code/>
<code><span class="hljs-params">  <span class="hljs-comment">// Exports (assigned to global variable `myModule`)</span></span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">return</span> {</span></code>
<code><span class="hljs-params">    <span class="hljs-attr">exportedFunc</span>: exportedFunc,</span></code>
<code><span class="hljs-params">  };</span></code>
<code><span class="hljs-params">})(); <span class="hljs-comment">// Close IIFE</span></span></code>
</pre>
<p><span id="index-entry-immediately-invoked-function-expression--IIFE-"/>
<span id="index-entry-IIFE--immediately-invoked-function-expression-"/>
<span id="index-entry-revealing-module-pattern"/></p>
<p><code>myModule</code> is a global variable that is assigned the result of immediately invoking a function expression. The function expression starts in the first line. It is invoked in the last line.</p>
<p>This way of wrapping a code fragment is called <em>immediately invoked function expression</em> (IIFE, coined by Ben Alman). What do we gain from an IIFE? <code>var</code> is not block-scoped (like <code>const</code> and <code>let</code>), it is function-scoped: the only way to create new scopes for <code>var</code>-declared variables is via functions or methods (with <code>const</code> and <code>let</code>, we can use either functions, methods, or blocks <code>{}</code>). Therefore, the IIFE in the example hides all of the following variables from global scope and minimizes name clashes: <code>importedFunc1</code>, <code>importedFunc2</code>, <code>internalFunc</code>, <code>exportedFunc</code>.</p>
<p>Note that we are using an IIFE in a particular manner: at the end, we pick what we want to export and return it via an object literal. That is called the <em>revealing module pattern</em> (coined by Christian Heilmann).</p>
<p>This way of simulating modules, has several issues:</p>
<ul>
  <li>
    Libraries in script files export and import functionality via global variables, which risks name clashes.
  </li>
  <li>
    Dependencies are not stated explicitly, and there is no built-in way for a script to load the scripts it depends on. Therefore, the web page has to load not just the scripts that are needed by the page but also the dependencies of those scripts, the dependencies’ dependencies, etc. And it has to do so in the right order!
  </li>
</ul>
<h3 id="module-systems-created-prior-to-es6"><a class="heading-id-link" href="#module-systems-created-prior-to-es6">29.4 Module systems created prior to ES6</a></h3>
<p>Prior to ECMAScript 6, JavaScript did not have built-in modules. Therefore, the flexible syntax of the language was used to implement custom module systems <em>within</em> the language. Two popular ones are:</p>
<ul>
  <li>
    CommonJS (targeting the server side)
  </li>
  <li>
    AMD (Asynchronous Module Definition, targeting the client side)
  </li>
</ul>
<h4 id="server-side-commonjs-modules"><a class="heading-id-link" href="#server-side-commonjs-modules">29.4.1 Server side: CommonJS modules</a></h4>
<p><span id="index-entry-CommonJS-module"/><span id="index-entry-module--CommonJS"/></p>
<p>The original CommonJS standard for modules was created for server and desktop platforms. It was the foundation of the original Node.js module system, where it achieved enormous popularity. Contributing to that popularity were the npm package manager for Node and tools that enabled using Node modules on the client side (browserify, webpack, and others).</p>
<p>From now on, <em>CommonJS module</em> means the Node.js version of this standard (which has a few additional features). This is an example of a CommonJS module:</p>
<pre class="language-js">
<code><span class="hljs-comment">// Imports</span></code>
<code><span class="hljs-keyword">var</span> importedFunc1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./other-module1.js'</span>).<span class="hljs-property">importedFunc1</span>;</code>
<code><span class="hljs-keyword">var</span> importedFunc2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./other-module2.js'</span>).<span class="hljs-property">importedFunc2</span>;</code>
<code/>
<code><span class="hljs-comment">// Body</span></code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">internalFunc</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-comment">// ···</span></span></code>
<code><span class="hljs-params">}</span></code>
<code><span class="hljs-params"><span class="hljs-keyword">function</span> <span class="hljs-title function_">exportedFunc</span>(<span class="hljs-params"/>) {</span></code>
<code><span class="hljs-params">  importedFunc1();</span></code>
<code><span class="hljs-params">  importedFunc2();</span></code>
<code><span class="hljs-params">  <span class="hljs-title function_">internalFunc</span>();</span></code>
<code><span class="hljs-params">}</span></code>
<code/>
<code><span class="hljs-params"><span class="hljs-comment">// Exports</span></span></code>
<code><span class="hljs-params"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {</span></code>
<code><span class="hljs-params">  <span class="hljs-attr">exportedFunc</span>: exportedFunc,</span></code>
<code><span class="hljs-params">};</span></code>
</pre>
<p>CommonJS can be characterized as follows:</p>
<ul>
  <li>
    Designed for servers.
  </li>
  <li>
    Modules are meant to be loaded <em>synchronously</em> (the importer waits while the imported module is loaded and executed).
  </li>
  <li>
    Compact syntax.
  </li>
</ul>
<h4 id="client-side-amd-asynchronous-module-definition-modules"><a class="heading-id-link" href="#client-side-amd-asynchronous-module-definition-modules">29.4.2 Client side: AMD (Asynchronous Module Definition) modules</a></h4>
<p><span id="index-entry-AMD-module"/><span id="index-entry-module--AMD"/>
<span id="index-entry-RequireJS"/></p>
<p>The AMD module format was created to be easier to use in browsers than the CommonJS format. Its most popular implementation is <a href="https://requirejs.org">RequireJS</a>. The following is an example of an AMD module.</p>
<pre class="language-js">
<code><span class="hljs-title function_">define</span>([<span class="hljs-string">'./other-module1.js'</span>, <span class="hljs-string">'./other-module2.js'</span>],</code>
<code>  <span class="hljs-keyword">function</span> (<span class="hljs-params">otherModule1, otherModule2</span>) {</code>
<code>    <span class="hljs-keyword">var</span> importedFunc1 = otherModule1.<span class="hljs-property">importedFunc1</span>;</code>
<code>    <span class="hljs-keyword">var</span> importedFunc2 = otherModule2.<span class="hljs-property">importedFunc2</span>;</code>
<code/>
<code>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">internalFunc</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">      <span class="hljs-comment">// ···</span></span></code>
<code><span class="hljs-params">    }</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">exportedFunc</span>(<span class="hljs-params"/>) {</span></code>
<code><span class="hljs-params">      importedFunc1();</span></code>
<code><span class="hljs-params">      importedFunc2();</span></code>
<code><span class="hljs-params">      <span class="hljs-title function_">internalFunc</span>();</span></code>
<code><span class="hljs-params">    }</span></code>
<code><span class="hljs-params">    </span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> {</span></code>
<code><span class="hljs-params">      <span class="hljs-attr">exportedFunc</span>: exportedFunc,</span></code>
<code><span class="hljs-params">    };</span></code>
<code><span class="hljs-params">  });</span></code>
</pre>
<p>AMD can be characterized as follows:</p>
<ul>
  <li>
    Designed for browsers.
  </li>
  <li>
    Modules are meant to be loaded <em>asynchronously</em>. That’s a crucial requirement for browsers, where code can’t wait until a module has finished downloading. It has to be notified once the module is available.
  </li>
  <li>
    The syntax is slightly more complicated.
  </li>
</ul>
<p>Benefit of AMD modules (and the reason why they work well for browsers): They can be executed directly. In contrast, CommonJS modules must either be compiled before deployment or custom source code must be generated and evaluated dynamically <a href="ch_dynamic-code-evaluation.html#eval">(think <code>eval()</code>)</a>. That isn’t always permitted on the web.</p>
<h4 id="characteristics-of-javascript-modules"><a class="heading-id-link" href="#characteristics-of-javascript-modules">29.4.3 Characteristics of JavaScript modules</a></h4>
<p>Looking at CommonJS and AMD, similarities between JavaScript module systems emerge:</p>
<ul>
  <li>
    There is one module per file.
  </li>
  <li>
    Such a file is basically a piece of code that is executed:
    <ul>
      <li>
        Local scope: The code is executed in a local “module scope”. Therefore, by default, all of the variables, functions, and classes declared in it are internal and not global.
      </li>
      <li>
        Exports: If we want any declared entity to be exported, we must explicitly mark it as an export.
      </li>
      <li>
        Imports: Each module can import exported entities from other modules. Those other modules are identified via <em>module specifiers</em> (usually paths, occasionally full URLs).
      </li>
    </ul>
  </li>
  <li>
    Modules are <em>singletons</em>: Even if a module is imported multiple times, only a single “instance” of it exists.
  </li>
  <li>
    No global variables are used. Instead, module specifiers serve as global IDs.
  </li>
</ul>
<h3 id="ecmascript-modules"><a class="heading-id-link" href="#ecmascript-modules">29.5 ECMAScript modules</a></h3>
<p><span id="index-entry-ECMAScript-module"/><span id="index-entry-ES-module"/></p>
<p><em>ECMAScript modules</em> (<em>ES modules</em> or <em>ESM</em>) were introduced with ES6. They continue the tradition of JavaScript modules and have all of their aforementioned characteristics. Additionally:</p>
<ul>
  <li>
    With CommonJS, ES modules share the compact syntax and support for cyclic dependencies.
  </li>
  <li>
    With AMD, ES modules share being designed for asynchronous loading.
  </li>
</ul>
<p>ES modules also have new benefits:</p>
<ul>
  <li>
    The syntax is even more compact than CommonJS’s.
  </li>
  <li>
    Modules have <em>static</em> structures (which can’t be changed at runtime). That helps with static checking, optimized access of imports, dead code elimination, and more.
  </li>
  <li>
    Support for cyclic imports is completely transparent.
  </li>
</ul>
<p>This is an example of ES module syntax:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> {importedFunc1} <span class="hljs-keyword">from</span> <span class="hljs-string">'./other-module1.mjs'</span>;</code>
<code><span class="hljs-keyword">import</span> {importedFunc2} <span class="hljs-keyword">from</span> <span class="hljs-string">'./other-module2.mjs'</span>;</code>
<code/>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">internalFunc</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  ···</span></code>
<code><span class="hljs-params">}</span></code>
<code/>
<code><span class="hljs-params"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">exportedFunc</span>(<span class="hljs-params"/>) {</span></code>
<code><span class="hljs-params">  importedFunc1();</span></code>
<code><span class="hljs-params">  importedFunc2();</span></code>
<code><span class="hljs-params">  <span class="hljs-title function_">internalFunc</span>();</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p>From now on, “module” means “ECMAScript module”.</p>
<h4 id="es-modules-syntax-semantics-loader-api"><a class="heading-id-link" href="#es-modules-syntax-semantics-loader-api">29.5.1 ES modules: syntax, semantics, loader API</a></h4>
<p>The full standard of ES modules comprises the following parts:</p>
<ol>
  <li>
    Syntax (how code is written): What is a module? How are imports and exports declared? Etc.
  </li>
  <li>
    Semantics (how code is executed): How are variable bindings exported? How are imports connected with exports? Etc.
  </li>
  <li>
    A programmatic loader API for configuring module loading.
  </li>
</ol>
<p>Parts 1 and 2 were introduced with ES6. Work on part 3 is ongoing.</p>
<h3 id="named-exports-and-imports"><a class="heading-id-link" href="#named-exports-and-imports">29.6 Named exports and imports</a></h3>
<h4 id="named-exports"><a class="heading-id-link" href="#named-exports">29.6.1 Named exports</a></h4>
<p><span id="index-entry-named-export"/><span id="index-entry-export--named"/><span id="index-entry-export"/></p>
<p>Each module can have zero or more <em>named exports</em>.</p>
<p>As an example, consider the following two files:</p>
<pre class="language-txt">
<code>lib/my-math.mjs</code>
<code>main.mjs</code>
</pre>
<p>Module <code>my-math.mjs</code> has two named exports: <code>square</code> and <code>LIGHT_SPEED</code>.</p>
<pre class="language-js">
<code><span class="hljs-comment">// Not exported, private to module</span></code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">times</span>(<span class="hljs-params">a, b</span>) {</code>
<code>  <span class="hljs-keyword">return</span> a * b;</code>
<code>}</code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>) {</code>
<code>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">times</span>(x, x);</code>
<code>}</code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">LIGHT_SPEED</span> = <span class="hljs-number">299792458</span>;</code>
</pre>
<p>To export something, we put the keyword <code>export</code> in front of a declaration. Entities that are not exported are private to a module and can’t be accessed from outside.</p>
<h4 id="named-imports"><a class="heading-id-link" href="#named-imports">29.6.2 Named imports</a></h4>
<p><span id="index-entry-named-import"/><span id="index-entry-import--named"/><span id="index-entry-import"/></p>
<p>Module <code>main.mjs</code> has a single named import, <code>square</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> {square} <span class="hljs-keyword">from</span> <span class="hljs-string">'./lib/my-math.mjs'</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">square</span>(<span class="hljs-number">3</span>), <span class="hljs-number">9</span>);</code>
</pre>
<p>It can also rename its import:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> {square <span class="hljs-keyword">as</span> sq} <span class="hljs-keyword">from</span> <span class="hljs-string">'./lib/my-math.mjs'</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">sq</span>(<span class="hljs-number">3</span>), <span class="hljs-number">9</span>);</code>
</pre>
<h5 id="syntactic-pitfall-named-importing-is-not-destructuring"><a class="heading-id-link" href="#syntactic-pitfall-named-importing-is-not-destructuring">29.6.2.1 Syntactic pitfall: named importing is not destructuring</a></h5>
<p>Both named importing and destructuring look similar:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> {func} <span class="hljs-keyword">from</span> <span class="hljs-string">'./util.mjs'</span>; <span class="hljs-comment">// import</span></code>
<code><span class="hljs-keyword">const</span> {func} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./util.mjs'</span>); <span class="hljs-comment">// destructuring</span></code>
</pre>
<p>But they are quite different:</p>
<ul>
  <li>
    <p>Imports remain connected with their exports.</p>
  </li>
  <li>
    <p>We can destructure again inside a destructuring pattern, but the <code>{}</code> in an import statement can’t be nested.</p>
  </li>
  <li>
    <p>The syntax for renaming is different:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> {func <span class="hljs-keyword">as</span> f} <span class="hljs-keyword">from</span> <span class="hljs-string">'./util.mjs'</span>; <span class="hljs-comment">// importing</span></code>
<code><span class="hljs-keyword">const</span> {<span class="hljs-attr">func</span>: f} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./util.mjs'</span>); <span class="hljs-comment">// destructuring</span></code>
</pre>
    <p>Rationale: Destructuring is reminiscent of an object literal (including nesting), while importing evokes the idea of renaming.</p>
  </li>
</ul>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Named exports</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/modules/export_named_test.mjs</code></p>
</div>
<h4 id="namespace-imports"><a class="heading-id-link" href="#namespace-imports">29.6.3 Namespace imports</a></h4>
<p><span id="index-entry-namespace-import"/><span id="index-entry-import--namespace"/></p>
<p><em>Namespace imports</em> are an alternative to named imports. If we namespace-import a module, it becomes an object whose properties are the named exports. This is what <code>main.mjs</code> looks like if we use a namespace import:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> myMath <span class="hljs-keyword">from</span> <span class="hljs-string">'./lib/my-math.mjs'</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(myMath.<span class="hljs-title function_">square</span>(<span class="hljs-number">3</span>), <span class="hljs-number">9</span>);</code>
<code/>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(myMath), [<span class="hljs-string">'LIGHT_SPEED'</span>, <span class="hljs-string">'square'</span>]</code>
<code>);</code>
</pre>
<h4 id="named-exporting-styles-inline-versus-clause-advanced"><a class="heading-id-link" href="#named-exporting-styles-inline-versus-clause-advanced">29.6.4 Named exporting styles: inline versus clause<span> (advanced)</span></a></h4>
<p>The named export style we have seen so far was <em>inline</em>: We exported entities by prefixing them with the keyword <code>export</code>.</p>
<p>But we can also use separate <em>export clauses</em>. For example, this is what <code>lib/my-math.mjs</code> looks like with an export clause:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">times</span>(<span class="hljs-params">a, b</span>) {</code>
<code>  <span class="hljs-keyword">return</span> a * b;</code>
<code>}</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>) {</code>
<code>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">times</span>(x, x);</code>
<code>}</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">LIGHT_SPEED</span> = <span class="hljs-number">299792458</span>;</code>
<code/>
<code><span class="hljs-keyword">export</span> { square, <span class="hljs-variable constant_">LIGHT_SPEED</span> }; <span class="hljs-comment">// semicolon!</span></code>
</pre>
<p>With an export clause, we can rename before exporting and use different names internally:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">times</span>(<span class="hljs-params">a, b</span>) {</code>
<code>  <span class="hljs-keyword">return</span> a * b;</code>
<code>}</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">sq</span>(<span class="hljs-params">x</span>) {</code>
<code>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">times</span>(x, x);</code>
<code>}</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">LS</span> = <span class="hljs-number">299792458</span>;</code>
<code/>
<code><span class="hljs-keyword">export</span> {</code>
<code>  sq <span class="hljs-keyword">as</span> square,</code>
<code>  <span class="hljs-variable constant_">LS</span> <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">LIGHT_SPEED</span>, <span class="hljs-comment">// trailing comma is optional</span></code>
<code>};</code>
</pre>
<h3 id="default-exports-and-default-imports"><a class="heading-id-link" href="#default-exports-and-default-imports">29.7 Default exports and default imports</a></h3>
<p><span id="index-entry-default-export"/><span id="index-entry-export--default"/><span id="index-entry-export-default"/></p>
<p>Each module can have at most one <em>default export</em>. The idea is that the module <em>is</em> the default-exported value.</p>
<p>As an example of default exports, consider the following two files:</p>
<pre class="language-txt">
<code>my-func.mjs</code>
<code>main.mjs</code>
</pre>
<p>Module <code>my-func.mjs</code> has a default export:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">GREETING</span> = <span class="hljs-string">'Hello!'</span>;</code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">GREETING</span>;</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p>Module <code>main.mjs</code> default-imports the exported function:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> myFunc <span class="hljs-keyword">from</span> <span class="hljs-string">'./my-func.mjs'</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">myFunc</span>(), <span class="hljs-string">'Hello!'</span>);</code>
</pre>
<p>Note the syntactic difference: the curly braces around named imports indicate that we are reaching <em>into</em> the module, while a default import <em>is</em> the module.</p>
<div class="boxout">
  <p><img src="../Images/3decb3ca67c240d2bb04742c1f28af18.png" class="boxout-icon" height="24" alt="Icon “question”" data-original-src="https://exploringjs.com/js/book/icon/question.svg"/> <strong>What are use cases for default exports?</strong></p>
  <div class="boxout-vspace"/>
  <p>The most common use case for a default export is a module that contains a single function or a single class.</p>
</div>
<h4 id="the-two-styles-of-defaultexporting"><a class="heading-id-link" href="#the-two-styles-of-defaultexporting">29.7.1 The two styles of default-exporting</a></h4>
<p>There are two styles of doing default exports.</p>
<p>First, we can label existing declarations with <code>export default</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params">) {} <span class="hljs-comment">// no semicolon!</span></span></code>
<code><span class="hljs-params"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {} <span class="hljs-comment">// no semicolon!</span></span></code>
</pre>
<p>Second, we can directly default-export values. This style of <code>export default</code> is much like a declaration.</p>
<pre class="language-js">
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> myFunc; <span class="hljs-comment">// defined elsewhere</span></code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">MyClass</span>; <span class="hljs-comment">// defined previously</span></code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// result of invocation is default-exported</span></code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-string">'abc'</span> + <span class="hljs-string">'def'</span>;</code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> { <span class="hljs-attr">no</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">yes</span>: <span class="hljs-literal">true</span> };</code>
</pre>
<h5 id="why-are-there-two-default-export-styles"><a class="heading-id-link" href="#why-are-there-two-default-export-styles">29.7.1.1 Why are there two default export styles?</a></h5>
<p>The reason is that <code>export default</code> can’t be used to label <code>const</code>: <code>const</code> may define multiple values, but <code>export default</code> needs exactly one value. Consider the following hypothetical code:</p>
<pre class="language-js">
<code><span class="hljs-comment">// Not legal JavaScript!</span></code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>, c = <span class="hljs-number">3</span>;</code>
</pre>
<p>With this code, we don’t know which one of the three values is the default export.</p>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Default exports</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/modules/export_default_test.mjs</code></p>
</div>
<h4 id="the-default-export-as-a-named-export-advanced"><a class="heading-id-link" href="#the-default-export-as-a-named-export-advanced">29.7.2 The default export as a named export<span> (advanced)</span></a></h4>
<p>Internally, a default export is simply a named export whose name is <code>default</code>. As an example, consider the previous module <code>my-func.mjs</code> with a default export:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">GREETING</span> = <span class="hljs-string">'Hello!'</span>;</code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">GREETING</span>;</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p>The following module <code>my-func2.mjs</code> is equivalent to that module:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">GREETING</span> = <span class="hljs-string">'Hello!'</span>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">GREETING</span>;</span></code>
<code><span class="hljs-params">}</span></code>
<code/>
<code><span class="hljs-params"><span class="hljs-keyword">export</span> {</span></code>
<code><span class="hljs-params">  greet <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span>,</span></code>
<code><span class="hljs-params">};</span></code>
</pre>
<p>For importing, we can use a normal default import:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> myFunc <span class="hljs-keyword">from</span> <span class="hljs-string">'./my-func2.mjs'</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">myFunc</span>(), <span class="hljs-string">'Hello!'</span>);</code>
</pre>
<p>Or we can use a named import:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> {<span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> myFunc} <span class="hljs-keyword">from</span> <span class="hljs-string">'./my-func2.mjs'</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">myFunc</span>(), <span class="hljs-string">'Hello!'</span>);</code>
</pre>
<p>The default export is also available via property <code>.default</code> of namespace imports:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> mf <span class="hljs-keyword">from</span> <span class="hljs-string">'./my-func2.mjs'</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(mf.<span class="hljs-title function_">default</span>(), <span class="hljs-string">'Hello!'</span>);</code>
</pre>
<div class="boxout">
  <p><img src="../Images/3decb3ca67c240d2bb04742c1f28af18.png" class="boxout-icon" height="24" alt="Icon “question”" data-original-src="https://exploringjs.com/js/book/icon/question.svg"/> <strong>Isn’t <code>default</code> illegal as a variable name?</strong></p>
  <div class="boxout-vspace"/>
  <p><code>default</code> can’t be a variable name, but it can be an export name and it can be a property name:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  <span class="hljs-attr">default</span>: <span class="hljs-number">123</span>,</code>
<code>};</code>
<code>assert.<span class="hljs-title function_">equal</span>(obj.<span class="hljs-property">default</span>, <span class="hljs-number">123</span>);</code>
</pre>
</div>
<h4 id="recommendations-named-exports-vs-default-exports"><a class="heading-id-link" href="#recommendations-named-exports-vs-default-exports">29.7.3 Recommendations: named exports vs. default exports</a></h4>
<p>These are my recommendations:</p>
<ul>
  <li>
    <p>Avoid mixing named exports and default exports: A module can have both named exports and a default export, but it’s usually better to stick to one export style per module.</p>
    <ul>
      <li>
        There is one exception: For unit-testing, it can make sense to name-export internal functions (etc.) that complement the default export (the public API of the module).
      </li>
    </ul>
  </li>
  <li>
    <p>In some cases, you may be sure that the module will only ever export a single value (usually a function or a class). That is, conceptually, the module <em>is</em> the value – similarly to a variable. Then a default export is a good option.</p>
  </li>
  <li>
    <p>You can never go wrong with only using named exports.</p>
  </li>
</ul>
<h3 id="re-exporting"><a class="heading-id-link" href="#re-exporting">29.8 Re-exporting</a></h3>
<p>A module <code>library.mjs</code> can export one or more exports of another module <code>internal.mjs</code> as if it had made them itself. That is called <em>re-exporting</em>.</p>
<pre class="language-js">
<code><span class="hljs-comment">//===== internal.mjs =====</span></code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">internalFunc</span>(<span class="hljs-params">) {}</span></code>
<code><span class="hljs-params"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">INTERNAL_DEF</span> = <span class="hljs-string">'hello'</span>;</span></code>
<code><span class="hljs-params"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-number">123</span>;</span></code>
</pre>
<pre class="language-js">
<code><span class="hljs-comment">//===== library.mjs =====</span></code>
<code><span class="hljs-comment">// Named re-export [ES6]</span></code>
<code><span class="hljs-keyword">export</span> {internalFunc <span class="hljs-keyword">as</span> func, <span class="hljs-variable constant_">INTERNAL_DEF</span> <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">DEF</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">'./internal.mjs'</span>;</code>
<code><span class="hljs-comment">// Wildcard re-export [ES6]</span></code>
<code><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">'./internal.mjs'</span>;</code>
<code><span class="hljs-comment">// Namespace re-export [ES2020]</span></code>
<code><span class="hljs-keyword">export</span> * <span class="hljs-keyword">as</span> ns <span class="hljs-keyword">from</span> <span class="hljs-string">'./internal.mjs'</span>;</code>
</pre>
<ul>
  <li>
    The wildcard re-export turns all exports of module <code>internal.mjs</code> into exports of <code>library.mjs</code>, except the default export.
  </li>
  <li>
    The namespace re-export turns all exports of module <code>internal.mjs</code> into an object that becomes the named export <code>ns</code> of <code>library.mjs</code>. Because <code>internal.mjs</code> has a default export, <code>ns</code> has a property <code>.default</code>.
  </li>
</ul>
<p>The following code demonstrates the two bullet points above:</p>
<pre class="language-js">
<code><span class="hljs-comment">//===== main.mjs =====</span></code>
<code><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> library <span class="hljs-keyword">from</span> <span class="hljs-string">'./library.mjs'</span>;</code>
<code/>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(library),</code>
<code>  [<span class="hljs-string">'DEF'</span>, <span class="hljs-string">'INTERNAL_DEF'</span>, <span class="hljs-string">'func'</span>, <span class="hljs-string">'internalFunc'</span>, <span class="hljs-string">'ns'</span>]</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(library.<span class="hljs-property">ns</span>),</code>
<code>  [<span class="hljs-string">'INTERNAL_DEF'</span>, <span class="hljs-string">'default'</span>, <span class="hljs-string">'internalFunc'</span>]</code>
<code>);</code>
</pre>
<h3 id="more-details-on-exporting-and-importing"><a class="heading-id-link" href="#more-details-on-exporting-and-importing">29.9 More details on exporting and importing</a></h3>
<h4 id="imports-are-readonly-views-on-exports"><a class="heading-id-link" href="#imports-are-readonly-views-on-exports">29.9.1 Imports are read-only views on exports</a></h4>
<p>So far, we have used imports and exports intuitively, and everything seems to have worked as expected. But now it is time to take a closer look at how imports and exports are really related.</p>
<p>Consider the following two modules:</p>
<pre class="language-txt">
<code>counter.mjs</code>
<code>main.mjs</code>
</pre>
<p><code>counter.mjs</code> exports a (mutable!) variable and a function:</p>
<pre class="language-js">
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> counter = <span class="hljs-number">3</span>;</code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">incCounter</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  counter++;</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p><code>main.mjs</code> name-imports both exports. When we use <code>incCounter()</code>, we discover that the connection to <code>counter</code> is live – we can always access the live state of that variable:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> { counter, incCounter } <span class="hljs-keyword">from</span> <span class="hljs-string">'./counter.mjs'</span>;</code>
<code/>
<code><span class="hljs-comment">// The imported value `counter` is live</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(counter, <span class="hljs-number">3</span>);</code>
<code><span class="hljs-title function_">incCounter</span>();</code>
<code>assert.<span class="hljs-title function_">equal</span>(counter, <span class="hljs-number">4</span>);</code>
</pre>
<p>Note that while the connection is live and we can read <code>counter</code>, we cannot change this variable (e.g., via <code>counter++</code>).</p>
<p>There are two benefits to handling imports this way:</p>
<ul>
  <li>
    It is easier to split modules because previously shared variables can become exports.
  </li>
  <li>
    This behavior is crucial for supporting transparent cyclic imports. Read on for more information.
  </li>
</ul>
<h4 id="esms-transparent-support-for-cyclic-imports-advanced"><a class="heading-id-link" href="#esms-transparent-support-for-cyclic-imports-advanced">29.9.2 ESM’s transparent support for cyclic imports<span> (advanced)</span></a></h4>
<p>ESM supports cyclic imports transparently. To understand how that is achieved, consider the following example: <a href="#fig:module-imports">figure 29.1</a> shows a directed graph of modules importing other modules. P importing M is the cycle in this case.</p>
<figure id="fig:module-imports" class="float">
  <p><img src="../Images/e021933bd9279348226080408fab73a2.png" texfactor="0.7" alt="" style="width:174.2441px; height:140.22835px" data-original-src="https://exploringjs.com/js/book/img/modules/module-imports.svg"/></p>
  <figcaption>
    <p><span class="float-label">Figure 29.1:</span> A directed graph of modules importing modules: M imports N and O, N imports P and Q, etc.</p>
  </figcaption>
</figure>
<p>After parsing, these modules are set up in two phases:</p>
<ul>
  <li>
    Instantiation: Every module is visited and its imports are connected to its exports. Before a parent can be instantiated, all of its children must be instantiated. 
  </li>
  <li>
    Evaluation: The bodies of the modules are executed. Once again, children are evaluated before parents.
  </li>
</ul>
<p>This approach handles cyclic imports correctly, due to two features of ES modules:</p>
<ul>
  <li>
    <p>Due to the static structure of ES modules, the exports are already known after parsing. That makes it possible to instantiate P before its child M: P can already look up M’s exports.</p>
  </li>
  <li>
    <p>When P is evaluated, M hasn’t been evaluated, yet. However, entities in P can already mention imports from M. They just can’t use them, yet, because the imported values are filled in later. For example, a function in P can access an import from M. The only limitation is that we must wait until after the evaluation of M, before calling that function.</p>
    <p>Imports being filled in later is enabled by them being “live immutable views” on exports.</p>
  </li>
</ul>
<h3 id="javascript-packages"><a class="heading-id-link" href="#javascript-packages">29.10 Packages: JavaScript’s units for software distribution</a></h3>
<p><span id="index-entry-package"/>
<span id="index-entry-npm-package"/><span id="index-entry-package--npm"/>
<span id="index-entry-package-manager"/>
<span id="index-entry-npm"/></p>
<p>In the JavaScripte ecosystem, a <em>package</em> is a way of organizing software projects: It is a directory with a standardized layout. A package can contain all kinds of files - for example:</p>
<ul>
  <li>
    A web application written in JavaScript, to be deployed on a server
  </li>
  <li>
    JavaScript libraries (for Node.js, for browsers, for all JavaScript platforms, etc.)
  </li>
  <li>
    Libraries for programming languages other than JavaScript: TypeScript, Rust, etc.
  </li>
  <li>
    Unit tests (e.g. for the libraries in the package)
  </li>
  <li>
    Node.js-based shell scripts – e.g., development tools such as compilers, test runners, and documentation generators
  </li>
  <li>
    Many other kinds of artifacts
  </li>
</ul>
<p>A package can <em>depend on</em> other packages (which are called its <em>dependencies</em>):</p>
<ul>
  <li>
    Libraries needed by the package’s JavaScript code
  </li>
  <li>
    Shell scripts used during development
  </li>
  <li>
    Etc.
  </li>
</ul>
<p>The dependencies of a package are installed inside that package (we’ll see how soon).</p>
<p>One common distinction between packages is:</p>
<ul>
  <li>
    <em>Published packages</em> can be installed by us:
    <ul>
      <li>
        Global installation: We can install them globally so that their shell scripts become available at the command line.
      </li>
      <li>
        Local installation: We can install them as dependencies into our own packages.
      </li>
    </ul>
  </li>
  <li>
    <em>Unpublished packages</em> never become dependencies of other packages, but do have dependencies themselves. Examples include web applications that are deployed to servers.
  </li>
</ul>
<p>The next subsection explains how packages can be published.</p>
<h4 id="publishing-packages"><a class="heading-id-link" href="#publishing-packages">29.10.1 Publishing packages: package registries, package managers, package names</a></h4>
<p>The main way of publishing a package is to upload it to a package registry – an online software repository. Two popular public registries are:</p>
<ul>
  <li>
    <a href="https://www.npmjs.com">The <em>npm registry</em></a> is most widely used and the default when using Node.js.
  </li>
  <li>
    <a href="https://jsr.io">The open-source package registry JSR</a> has special support for TypeScript and was created by the makers of the JavaScript runtime Deno.
  </li>
</ul>
<p>Companies can also host their own private registries.</p>
<p>A <em>package manager</em> is a command line tool that downloads packages from a registry (or other sources) and installs them as shell scripts and/or as dependencies. The most popular package manager is called <em>npm</em> and comes bundled with Node.js. Its name originally stood for “Node Package Manager”. Later, when npm and the npm registry were used not only for Node.js packages, that meaning was changed to “npm is not a package manager” ([source](<a href="https://en.wikipedia.org/wiki/Npm_(software)#Acronym)).">https://en.wikipedia.org/wiki/Npm_(software)#Acronym)).</a> There are other popular package managers such as jsr, vlt, pnpm and yarn. All of these package managers support either or both of the npm registry and JSR.</p>
<p>Let’s explore how the npm registry works. Each package has a name. There are two kinds of names:</p>
<ul>
  <li>
    <p><em>Global names</em> are unique across the whole registry. These are two examples:</p>
<pre>
<code>minimatch</code>
<code>mocha</code>
</pre>
  </li>
  <li>
    <p><em>Scoped names</em> consist of two parts: A scope and a name. Scopes are globally unique, names are unique per scope. These are two examples:</p>
<pre>
<code>@babel/core</code>
<code>@rauschma/iterable</code>
</pre>
    <p>The scope starts with an <code>@</code> symbol and is separated from the name with a slash.</p>
  </li>
</ul>
<h4 id="package-file-system-layout"><a class="heading-id-link" href="#package-file-system-layout">29.10.2 The file system layout of a package</a></h4>
<p><span id="index-entry-package.json"/>
<span id="index-entry-node_modules"/></p>
<p>Once a package <code>my-package</code> is fully installed, it almost always looks like this:</p>
<pre>
<code>my-package/</code>
<code>  package.json</code>
<code>  node_modules/</code>
<code>  [More files]</code>
</pre>
<p>What are the purposes of these file system entries?</p>
<ul>
  <li>
    <p><code>package.json</code> is a file every package must have:</p>
    <ul>
      <li>
        It contains metadata describing the package (its name, its version, its author, etc.).
      </li>
      <li>
        It lists the dependencies of the package: other packages that it needs, such as libraries and tools. Per dependency, we record:
        <ul>
          <li>
            A range of version numbers. Not specifying a specific version allows for upgrades and for code sharing between dependencies.
          </li>
          <li>
            By default, dependencies come from the npm registry. But we can also specify other sources: a local directory, a GZIP file, a URL pointing to a GZIP file, a registry other than npm’s, a git repository, etc.
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><code>node_modules/</code> is a directory into which the dependencies of the package are installed. Each dependency also has a <code>node_modules</code> folder with its dependencies, etc. The result is a tree of dependencies.</p>
  </li>
</ul>
<p>Most packages also have the file <code>package-lock.json</code> that sits next to <code>package.json</code>: It records the exact versions of the dependencies that were installed and is kept up to date if we add more dependencies via npm.</p>
<h4 id="packagejson"><a class="heading-id-link" href="#packagejson">29.10.3 <code>package.json</code></a></h4>
<p>This is a starter <code>package.json</code> that can be created via npm:</p>
<pre class="language-json">
<code><span class="hljs-punctuation">{</span></code>
<code>  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"my-package"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1.0.0"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"description"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"main"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"index.js"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>    <span class="hljs-attr">"test"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></code>
<code>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"keywords"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"author"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"license"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ISC"</span></code>
<code><span class="hljs-punctuation">}</span></code>
</pre>
<p>What are the purposes of these properties?</p>
<ul>
  <li>
    <p>Some properties are required for public packages (published on the npm registry):</p>
    <ul>
      <li>
        <code>name</code> specifies the name of this package.
      </li>
      <li>
        <code>version</code> is used for version management and follows <a href="https://semver.org">semantic versioning</a> with three dot-separated numbers:
        <ul>
          <li>
            The <em>major version</em> is incremented when incompatible API changes are made.
          </li>
          <li>
            The <em>minor version</em> is incremented when functionality is added in a backward compatible manner.
          </li>
          <li>
            The <em>patch version</em> is incremented when small changes are made that don’t really change the functionality.
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Other properties for public packages are optional:</p>
    <ul>
      <li>
        <code>description</code>, <code>keywords</code>, <code>author</code> are optional and make it easier to find packages.
      </li>
      <li>
        <code>license</code> clarifies how this package can be used. It makes sense to provide this value if the package is public in any way. <a href="https://choosealicense.com">“Choose an open source license”</a> can help with making this choice.
      </li>
    </ul>
  </li>
  <li>
    <p><code>main</code> is a legacy property and has been superseded by <code>exports</code>. It points to the code of a library package.</p>
  </li>
  <li>
    <p><code>scripts</code> is a property for setting up abbreviations for development-time shell commands. These can be executed via <code>npm run</code>. For example, the script <code>test</code> can be executed via <code>npm run test</code>.</p>
  </li>
</ul>
<p>More useful properties:</p>
<ul>
  <li>
    <p>Normally, the properties <code>name</code> and <code>version</code> are required and npm warns us if they are missing. However, we can change that via the following setting:</p>
<pre class="language-json">
<code><span class="hljs-attr">"private"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span></code>
</pre>
    <p>That prevents the package from accidentally being published and allows us to omit name and version.</p>
  </li>
  <li>
    <p><code>exports</code> is for <em>package exports</em> – which specify how importers see the content of this package. We’ll learn more about package exports <a href="#package-exports">later</a>.</p>
  </li>
  <li>
    <p><code>imports</code> is for <em>package imports</em> – which define aliases for module specifiers that packages can use internally. We’ll learn more about package imports <a href="#package-imports">later</a>.</p>
  </li>
  <li>
    <p><code>dependencies</code> lists the dependencies of a package.</p>
  </li>
  <li>
    <p><code>devDependencies</code> are dependencies that are only installed during development (not when a package is added as a dependency).</p>
  </li>
  <li>
    <p>The following setting means that all files with the name extension <code>.js</code> are interpreted as ECMAScript modules. Unless we are dealing with legacy code, it makes sense to add it:</p>
<pre class="language-json">
<code><span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"module"</span></code>
</pre>
  </li>
  <li>
    <p><code>bin</code> lists modules within the package that are installed as shell scripts.</p>
  </li>
</ul>
<div class="boxout">
  <p><img src="../Images/38e6ff55e8d602659f3cdb8893e63f62.png" class="boxout-icon" height="24" alt="Icon “external”" data-original-src="https://exploringjs.com/js/book/icon/external.svg"/> <strong>More information on <code>package.json</code></strong></p>
  <div class="boxout-vspace"/>
  <p>See <a href="https://docs.npmjs.com/files/package.json">the npm documentation</a>.</p>
</div>
<h4 id="package-exports"><a class="heading-id-link" href="#package-exports">29.10.4 Package exports: controlling what other packages see</a></h4>
<p><a href="https://nodejs.org/api/packages.html#packages_package_entry_points"><em>Package exports</em></a> are specified via property <code>"exports"</code> in <code>package.json</code> and support three important features:</p>
<ul>
  <li>
    <p>Hiding the internals of a package:</p>
    <ul>
      <li>
        <p>Without property <code>"exports"</code>, every module in a package <code>my-lib</code> can be accessed via a relative path after the package name – e.g.:</p>
<pre class="language-js">
<code><span class="hljs-string">'my-lib/dist/src/internal/internal-module.js'</span></code>
</pre>
      </li>
      <li>
        <p>Once the property exists, only specifiers listed in it can be used. Everything else is hidden from the outside.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Nicer module specifiers: Package exports let us change the bare specifier subpaths for importing the modules of a package: They can be shorter, extension-less, etc.</p>
  </li>
  <li>
    <p>Conditional exports: The same module specifier exports different modules – depending on which JavaScript platform an importer uses (browser, Node.js, etc.).</p>
  </li>
</ul>
<p>Next, we’ll look at some example. For a more detailed explanation of how package exports work, see section <a href="https://exploringjs.com/nodejs-shell-scripting/ch_packages.html#package-exports-controlling-what-other-packages-see">“Package exports: controlling what other packages see”</a> in “Shell scripting with Node.js”.</p>
<h5 id="examples-package-exports"><a class="heading-id-link" href="#examples-package-exports">29.10.4.1 Examples: package exports</a></h5>
<p>Example – specifying which module is imported via the bare specifier of a package (in the past, this was specified via property <code>main</code>):</p>
<pre class="language-json">
<code><span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>  <span class="hljs-attr">"."</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./dist/src/main.js"</span></code>
<code><span class="hljs-punctuation">}</span></code>
</pre>
<p>Example – specifying a better path for a module:</p>
<pre class="language-json">
<code><span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>  <span class="hljs-comment">// With filename extension</span></code>
<code>  <span class="hljs-attr">"./util/errors.js"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./dist/src/util/errors.js"</span><span class="hljs-punctuation">,</span></code>
<code/>
<code>  <span class="hljs-comment">// Without filename extension</span></code>
<code>  <span class="hljs-attr">"./util/errors"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./dist/src/util/errors.js"</span></code>
<code><span class="hljs-punctuation">}</span></code>
</pre>
<p>Example – specifying better paths for a tree of modules:</p>
<pre class="language-json">
<code><span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>  <span class="hljs-comment">// With filename extensions</span></code>
<code>  <span class="hljs-attr">"./*"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./dist/src/*"</span><span class="hljs-punctuation">,</span></code>
<code/>
<code>  <span class="hljs-comment">// Without filename extensions</span></code>
<code>  <span class="hljs-attr">"./*"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./dist/src/*.js"</span></code>
<code><span class="hljs-punctuation">}</span></code>
</pre>
<h5 id="conditional-package-exports"><a class="heading-id-link" href="#conditional-package-exports">29.10.4.2 Examples: conditional package exports</a></h5>
<p>The examples in this subsection show excerpts of <code>package.json</code>.</p>
<p>Example – export different modules for Node.js, browsers and other platforms:</p>
<pre class="language-json">
<code><span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>  <span class="hljs-attr">"."</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>    <span class="hljs-attr">"node"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./main-node.js"</span><span class="hljs-punctuation">,</span></code>
<code>    <span class="hljs-attr">"browser"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./main-browser.js"</span><span class="hljs-punctuation">,</span></code>
<code>    <span class="hljs-attr">"default"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./main-browser.js"</span></code>
<code>  <span class="hljs-punctuation">}</span></code>
<code><span class="hljs-punctuation">}</span></code>
</pre>
<p>Example – development vs. production:</p>
<pre class="language-json">
<code><span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>  <span class="hljs-attr">"."</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>    <span class="hljs-attr">"development"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./main-development.js"</span><span class="hljs-punctuation">,</span></code>
<code>    <span class="hljs-attr">"production"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./main-production.js"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-punctuation">}</span></code>
<code><span class="hljs-punctuation">}</span></code>
</pre>
<p>In Node.js we can specify an environment like this:</p>
<pre>
<code>node --conditions development app.mjs</code>
</pre>
<h4 id="package-imports"><a class="heading-id-link" href="#package-imports">29.10.5 Package imports</a></h4>
<p><a href="https://nodejs.org/api/packages.html#imports">Package imports</a> let a package define abbreviations for module specifiers that it can use itself, internally (where package exports define abbreviations for other packages). This is an example:</p>
<p><code>package.json</code>:</p>
<pre class="language-json">
<code><span class="hljs-punctuation">{</span></code>
<code>  <span class="hljs-attr">"imports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>    <span class="hljs-attr">"#some-pkg"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>      <span class="hljs-attr">"node"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"some-pkg-node-native"</span><span class="hljs-punctuation">,</span></code>
<code>      <span class="hljs-attr">"default"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./polyfills/some-pkg-polyfill.js"</span></code>
<code>    <span class="hljs-punctuation">}</span></code>
<code>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>    <span class="hljs-attr">"some-pkg-node-native"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^1.2.3"</span></code>
<code>  <span class="hljs-punctuation">}</span></code>
<code><span class="hljs-punctuation">}</span></code>
</pre>
<p>Each of the keys of <code>"imports"</code> has to start with a hash sign (<code>#</code>). The key <code>"#some-pkg"</code> is <em>conditional</em> (with the same features as <a href="#conditional-package-exports">conditional package exports</a>):</p>
<ul>
  <li>
    <p>If the current package is used on Node.js, the module specifier <code>'#some-pkg'</code> refers to package <code>some-pkg-node-native</code>.</p>
  </li>
  <li>
    <p>Elsewhere, <code>'#some-pkg'</code> refers to the file <code>./polyfills/some-pkg-polyfill.js</code> inside the current package.</p>
  </li>
</ul>
<p>Note that only package imports can refer to external packages, package exports can’t do that.</p>
<p>What are the use cases for package imports?</p>
<ul>
  <li>
    Referring to different platform-specific implementations modules via the same module specifier (as demonstrated above).
  </li>
  <li>
    Aliases to modules inside the current package – to avoid relative specifiers (which can get complicated with deeply nested directories).
  </li>
</ul>
<h5 id="examples-accessing-packagejson-via-package-imports"><a class="heading-id-link" href="#examples-accessing-packagejson-via-package-imports">29.10.5.1 Examples: accessing <code>package.json</code> via package imports</a></h5>
<p>Let’s explore two ways of accessing <code>package.json</code> via package imports.</p>
<p>First, we can define a package import for the root level of the package:</p>
<pre class="language-json">
<code><span class="hljs-attr">"imports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>  <span class="hljs-attr">"#root/*"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./*"</span></code>
<code><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span></code>
</pre>
<p>Then the import statement looks like this:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> pkg <span class="hljs-keyword">from</span> <span class="hljs-string">'#root/package.json'</span> <span class="hljs-keyword">with</span> { <span class="hljs-attr">type</span>: <span class="hljs-string">'json'</span> };</code>
<code><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pkg.<span class="hljs-property">version</span>);</code>
</pre>
<p>Second, we can define a package import just for <code>package.json</code>:</p>
<pre class="language-json">
<code><span class="hljs-attr">"imports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>  <span class="hljs-attr">"#pkg"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./package.json"</span></code>
<code><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span></code>
</pre>
<p>Then the import statement looks like this:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> pkg <span class="hljs-keyword">from</span> <span class="hljs-string">'#pkg'</span> <span class="hljs-keyword">with</span> { <span class="hljs-attr">type</span>: <span class="hljs-string">'json'</span> };</code>
<code><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pkg.<span class="hljs-property">version</span>);</code>
</pre>
<h3 id="naming-modules"><a class="heading-id-link" href="#naming-modules">29.11 Naming modules</a></h3>
<p>There are no established best practices for naming module files and the variables they are imported into.</p>
<p>In this chapter, I’m using the following naming style:</p>
<ul>
  <li>
    <p>The names of module files are dash-cased and only have lowercase letters:</p>
<pre class="language-txt">
<code>./my-module.mjs</code>
<code>./some-func.mjs</code>
</pre>
  </li>
  <li>
    <p>The names of namespace imports are camel-cased and start with lowercase letters:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> myModule <span class="hljs-keyword">from</span> <span class="hljs-string">'./my-module.mjs'</span>;</code>
</pre>
  </li>
  <li>
    <p>The names of default imports are camel-cased and start with lowercase letters:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> someFunc <span class="hljs-keyword">from</span> <span class="hljs-string">'./some-func.mjs'</span>;</code>
</pre>
  </li>
</ul>
<p>What is the thinking behind this style? We want module file names to be similar to package names:</p>
<ul>
  <li>
    <p>Dashes are far more commonly used than underscores in package names. Maybe that is influenced by underscores being very rare in domain names.</p>
  </li>
  <li>
    <p>npm doesn’t allow uppercase letters in package names (<a href="https://docs.npmjs.com/cli/v11/configuring-npm/package-json#name">source</a>).</p>
  </li>
</ul>
<p>Thanks to CSS, there are clear rules for translating dash-cased names to camel-cased names. We can use these rules for namespace imports and default imports.</p>
<h3 id="module-specifiers"><a class="heading-id-link" href="#module-specifiers">29.12 Module specifiers</a></h3>
<p><span id="index-entry-module-specifier"/><span id="index-entry-specifier--module"/></p>
<p><em>Module specifiers</em> are the strings that identify modules. They work slightly differently in browsers and Node.js. Before we can look at the differences, we need to learn about the different categories of module specifiers.</p>
<h4 id="kinds-of-module-specifiers-1"><a class="heading-id-link" href="#kinds-of-module-specifiers-1">29.12.1 Kinds of module specifiers</a></h4>
<p>There are three kinds of module specifiers:</p>
<ul>
  <li>
    <p><em>Absolute specifiers</em> are full URLs – for example:</p>
<pre class="language-js">
<code><span class="hljs-string">'https://www.unpkg.com/browse/yargs@17.3.1/browser.mjs'</span></code>
<code><span class="hljs-string">'file:///opt/nodejs/config.mjs'</span></code>
</pre>
    <p>Absolute specifiers are mostly used to access libraries that are directly hosted on the web.</p>
  </li>
  <li>
    <p><em>Relative specifiers</em> are relative URLs (starting with <code>'/'</code>, <code>'./'</code> or <code>'../'</code>) – for example:</p>
<pre class="language-js">
<code><span class="hljs-string">'./sibling-module.js'</span></code>
<code><span class="hljs-string">'../module-in-parent-dir.mjs'</span></code>
<code><span class="hljs-string">'../../dir/other-module.js'</span></code>
</pre>
    <p>Every module has a URL whose protocol depends on its location (<code>file:</code>, <code>https:</code>, etc.). If it uses a relative specifier, JavaScript turns that specifier into a full URL by resolving it against the module’s URL.</p>
    <p>Relative specifiers are mostly used to access other modules within the same code base.</p>
  </li>
  <li>
    <p><em>Bare specifiers</em> are paths (without protocol and domain) that start with neither slashes nor dots. They begin with the names of packages. Those names can optionally be followed by <em>subpaths</em>:</p>
<pre class="language-js">
<code><span class="hljs-string">'some-package'</span></code>
<code><span class="hljs-string">'some-package/sync'</span></code>
<code><span class="hljs-string">'some-package/util/files/path-tools.js'</span></code>
</pre>
    <p>Bare specifiers can also refer to packages with scoped names:</p>
<pre class="language-js">
<code><span class="hljs-string">'@some-scope/scoped-name'</span></code>
<code><span class="hljs-string">'@some-scope/scoped-name/async'</span></code>
<code><span class="hljs-string">'@some-scope/scoped-name/dir/some-module.mjs'</span></code>
</pre>
    <p>Each bare specifier refers to exactly one module inside a package; if it has no subpath, it refers to the designated “main” module of its package.</p>
    <p>A bare specifier is never used directly but always <em>resolved</em> – translated to an absolute specifier. How resolution works depends on the platform. We’ll learn more soon.</p>
  </li>
</ul>
<h4 id="filename-extensions-in-module-specifiers"><a class="heading-id-link" href="#filename-extensions-in-module-specifiers">29.12.2 Filename extensions in module specifiers</a></h4>
<ul>
  <li>
    Absolute specifiers and relative specifiers always have filename extensions – mainly <code>.js</code> or <code>.mjs</code>.
  </li>
  <li>
    There are three styles of bare specifiers:
    <ul>
      <li>
        <p>Style 1: no subpath</p>
<pre class="language-js">
<code><span class="hljs-string">'my-library'</span></code>
</pre>
      </li>
      <li>
        <p>Style 2: a subpath without a filename extension. In this case, the subpath works like a modifier for the package name:</p>
<pre class="language-js">
<code><span class="hljs-string">'my-parser/sync'</span></code>
<code><span class="hljs-string">'my-parser/async'</span></code>
<code/>
<code><span class="hljs-string">'assertions'</span></code>
<code><span class="hljs-string">'assertions/strict'</span></code>
</pre>
      </li>
      <li>
        <p>Style 3: a subpath with a filename extension. In this case, the package is seen as a collection of modules and the subpath points to one of them:</p>
<pre class="language-js">
<code><span class="hljs-string">'large-package/misc/util.js'</span></code>
<code><span class="hljs-string">'large-package/main/parsing.js'</span></code>
<code><span class="hljs-string">'large-package/main/printing.js'</span></code>
</pre>
      </li>
    </ul>
  </li>
</ul>
<p>Caveat of style 3 bare specifiers: How the filename extension is interpreted depends on the dependency and may differ from the importing package. For example, the importing package may use <code>.mjs</code> for ESM modules and <code>.js</code> for CommonJS modules, while the ESM modules exported by the dependency may have bare paths with the filename extension <code>.js</code>.</p>
<h4 id="module-specifiers-in-nodejs"><a class="heading-id-link" href="#module-specifiers-in-nodejs">29.12.3 Module specifiers in Node.js</a></h4>
<p>Let’s see how module specifiers work in Node.js. Especially bare specifiers are handled differently than in browsers.</p>
<h5 id="resolving-module-specifiers-in-nodejs"><a class="heading-id-link" href="#resolving-module-specifiers-in-nodejs">29.12.3.1 Resolving module specifiers in Node.js</a></h5>
<p>The <a href="https://nodejs.org/api/esm.html#resolution-algorithm"><em>Node.js resolution algorithm</em></a> works as follows:</p>
<ul>
  <li>
    Parameters:
    <ul>
      <li>
        URL of importing module
      </li>
      <li>
        Module specifier
      </li>
    </ul>
  </li>
  <li>
    Result: Resolved URL for module specifier
  </li>
</ul>
<p>This is the algorithm:</p>
<ul>
  <li>
    <p>If a specifier is absolute, resolution is already finished. Three protocols are most common:</p>
    <ul>
      <li>
        <code>file:</code> for local files
      </li>
      <li>
        <code>https:</code> for remote files
      </li>
      <li>
        <code>node:</code> for built-in modules
      </li>
    </ul>
  </li>
  <li>
    <p>If a specifier is relative, it is resolved against the URL of the importing module.</p>
  </li>
  <li>
    <p>If a specifier is bare:</p>
    <ul>
      <li>
        <p>If it starts with <code>'#'</code>, it is resolved by looking it up among the <em>package imports</em> (which are explained <a href="#package-imports">later</a>) and resolving the result.</p>
      </li>
      <li>
        <p>Otherwise, it is a bare specifier that has one of these formats (the subpath is optional):</p>
        <ul>
          <li>
            <code>«package»/sub/path</code>
          </li>
          <li>
            <code>@«scope»/«scoped-package»/sub/path</code>
          </li>
        </ul>
        <p>The resolution algorithm traverses the current directory and its ancestors until it finds a directory <code>node_modules</code> that has a subdirectory matching the beginning of the bare specifier, i.e. either:</p>
        <ul>
          <li>
            <code>node_modules/«package»/</code>
          </li>
          <li>
            <code>node_modules/@«scope»/«scoped-package»/</code>
          </li>
        </ul>
        <p>That directory is the directory of the package. By default, the (potentially empty) subpath after the package ID is interpreted as relative to the package directory. The default can be overridden via <em>package exports</em> which are explained next.</p>
      </li>
    </ul>
  </li>
</ul>
<p>The result of the resolution algorithm must point to a file. That explains why absolute specifiers and relative specifiers always have filename extensions. Bare specifiers often don’t because they are abbreviations that are looked up in package exports.</p>
<p>Module files usually have these filename extensions:</p>
<ul>
  <li>
    If a file has the name extension <code>.mjs</code>, it is always an ES module.
  </li>
  <li>
    A file that has the name extension <code>.js</code> is an ES module if the closest <code>package.json</code> has this entry:
    <ul>
      <li>
        <code>"type": "module"</code>
      </li>
    </ul>
  </li>
</ul>
<p>If Node.js executes code provided via stdin, <code>--eval</code> or <code>--print</code>, we use <a href="https://nodejs.org/api/cli.html#--input-typetype">the following command-line option</a> so that it is interpreted as an ES module:</p>
<pre>
<code>--input-type=module</code>
</pre>
<h4 id="module-specifiers-in-browsers"><a class="heading-id-link" href="#module-specifiers-in-browsers">29.12.4 Module specifiers in browsers</a></h4>
<p>In browsers, we can write inline modules like this:</p>
<pre class="language-html">
<code><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>&gt;</span></code>
<code><span class="language-javascript">  <span class="hljs-comment">// Inline module</span></span></code>
<code><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code>
</pre>
<p><code>type="module"</code> tells the browser that this is an ESM module and not <a href="#scripts">a browser script</a>.</p>
<p>We can only use two kinds of module specifiers:</p>
<pre class="language-html">
<code><span class="hljs-comment">&lt;!-- Absolute module specifier --&gt;</span></code>
<code><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/lodash"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code>
<code/>
<code><span class="hljs-comment">&lt;!-- Relative module specifier --&gt;</span></code>
<code><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"bundle.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code>
</pre>
<p>Read on to find out how to work around this limitation and use npm packages.</p>
<h5 id="filename-extensions-in-browsers"><a class="heading-id-link" href="#filename-extensions-in-browsers">29.12.4.1 Filename extensions in browsers</a></h5>
<p>Browsers don’t care about filename extensions, only about content types.</p>
<p>Hence, we can use any filename extension for ECMAScript modules, as long as they are served with <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#textjavascript">a JavaScript content type</a> (<code>text/javascript</code> is recommended).</p>
<h5 id="using-npm-packages-in-browsers"><a class="heading-id-link" href="#using-npm-packages-in-browsers">29.12.4.2 Using npm packages in browsers</a></h5>
<p>On Node.js, npm packages are downloaded into the <code>node_modules</code> directory and accessed via bare module specifiers. Node.js traverses the file system in order to find packages. We can’t do that in web browsers. Three approaches are common for bringing npm packages to browsers.</p>
<h6 id="approach-1-using-a-content-delivery-network"><a class="heading-id-link" href="#approach-1-using-a-content-delivery-network">29.12.4.2.1 Approach 1: Using a content delivery network</a></h6>
<p>Content delivery networks (CDNs) such as <a href="https://unpkg.com"><code>unpkg.com</code></a> and <a href="https://esm.sh"><code>esm.sh</code></a> let us import npm packages via URLs. This is what the <code>unpkg.com</code> URLs look like:</p>
<pre>
<code>https://unpkg.com/«package»@«version»/«file»</code>
</pre>
<p>For example:</p>
<pre>
<code>https://unpkg.com/lodash@4.17.21/lodash.js</code>
</pre>
<p>One downside of CDNs is that they introduce an additional point of failure:</p>
<ul>
  <li>
    CDNs can go offline.
  </li>
  <li>
    There is a risk of CDNs serving malicious code – e.g. if they are hacked or taken over by a new maintainer.
  </li>
</ul>
<h6 id="approach-2-using-nodemodules-with-bare-specifiers-and-a-bundler"><a class="heading-id-link" href="#approach-2-using-nodemodules-with-bare-specifiers-and-a-bundler">29.12.4.2.2 Approach 2: Using <code>node_modules</code> with bare specifiers and a bundler</a></h6>
<p>A <a href="ch_next-steps.html#bundler">bundler</a> is a build tool. It works roughly as follows:</p>
<ul>
  <li>
    Given a directory with a web app. We point the bundler to the app’s <em>entry point</em> – the module where execution starts.
  </li>
  <li>
    It collects everything that module imports (its imports, the imports of the imports, etc.).
  </li>
  <li>
    It produces a <em>bundle</em>, a single file with all the code. That file can be used from an HTML page.
  </li>
</ul>
<p>If an app has multiple entry points, the bundler produces multiple bundles. It’s also possible to tell it to create bundles for parts of the application that are loaded on demand.</p>
<p>When bundling, we can use bare import specifiers in files because bundlers know how to find the corresponding modules in <code>node_modules</code>. Bundlers also honor package exports and package imports.</p>
<p>Why bundle?</p>
<ul>
  <li>
    Loading a single file tends to be faster than loading multiple files – especially if there are many small ones.
  </li>
  <li>
    Bundlers only include code in the file that is really used (which is especially relevant for libraries). That saves storage space and also speeds up loading.
  </li>
</ul>
<p>A downside of bundling is that we need to bundle the whole app every time we want to run it.</p>
<h6 id="approach-3-converting-npm-packages-to-browsercompatible-files"><a class="heading-id-link" href="#approach-3-converting-npm-packages-to-browsercompatible-files">29.12.4.2.3 Approach 3: Converting npm packages to browser-compatible files</a></h6>
<p>There are package managers for browsers that let us download modules as single bundled files that can be used in browsers. As an example, consider the following directory of a web app:</p>
<pre>
<code>my-web-app/</code>
<code>  assets/</code>
<code>    lodash-es.js</code>
<code>  src/</code>
<code>    main.js</code>
</pre>
<p>We used a bundler to install package <code>lodash-es</code> into a single file. Module <code>main.js</code> can import it like this:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> {pick} <span class="hljs-keyword">from</span> <span class="hljs-string">'../assets/lodash-es.js'</span>;</code>
</pre>
<p>To deploy this app, the contents of <code>assets/</code> and <code>src/</code> are copied to the production server (in addition to non-JavaScript artifacts).</p>
<p>What are the benefits of this approach compared to using a bundler?</p>
<ul>
  <li>
    We install the external dependencies once and then can always run our app immediately – no prior bundling is required (which can be time-consuming).
  </li>
  <li>
    Unbundled code is easier to debug.
  </li>
</ul>
<h6 id="import-maps"><a class="heading-id-link" href="#import-maps">29.12.4.2.4 Improving approach 3: import maps</a></h6>
<p>Approach 3 can be further improved: <a href="https://2ality.com/2022/01/esm-specifiers.html#import-maps"><em>Import maps</em></a> are a browser technology that lets us define abbreviations for module specifiers – e.g. <code>'lodash-es'</code> for <code>'../assets/lodash-es.js'</code>.</p>
<p>This is what an import map looks like if we store it <em>inline</em> – inside an HTML file:</p>
<pre class="language-html">
<code><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"importmap"</span>&gt;</span></code>
<code><span class="language-javascript">{</span></code>
<code><span class="language-javascript">  <span class="hljs-string">"imports"</span>: {</span></code>
<code><span class="language-javascript">    <span class="hljs-string">"lodash-es"</span>: <span class="hljs-string">"./assets/lodash-es.js"</span></span></code>
<code><span class="language-javascript">  }</span></code>
<code><span class="language-javascript">}</span></code>
<code><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code>
</pre>
<p>We can also store import maps in external files (the content type must be <code>application/importmap+json</code>):</p>
<pre class="language-html">
<code><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"importmap"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"imports.importmap"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code>
</pre>
<p>Now the import in <code>main.js</code> looks like this:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> {pick} <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash-es'</span>;</code>
</pre>
<h3 id="import.meta"><a class="heading-id-link" href="#import.meta">29.13 <code>import.meta</code> – metadata for the current module<span> <sup>ES2020</sup></span></a></h3>
<p><span id="index-entry-import.meta"/></p>
<p>The object <code>import.meta</code> holds metadata for the current module.</p>
<h4 id="import.meta.url"><a class="heading-id-link" href="#import.meta.url">29.13.1 <code>import.meta.url</code></a></h4>
<p><span id="index-entry-import.meta.url"/></p>
<p>The most important property of <code>import.meta</code> is <code>.url</code> which contains a string with the URL of the current module’s file – for example:</p>
<pre class="language-txt">
<code>'https://example.com/code/main.mjs'</code>
</pre>
<h4 id="importmetaurl-and-class-url"><a class="heading-id-link" href="#importmetaurl-and-class-url">29.13.2 <code>import.meta.url</code> and class <code>URL</code></a></h4>
<p>Class <code>URL</code> is available via a global variable in browsers and on Node.js. We can look up its full functionality in <a href="https://nodejs.org/api/url.html#url_class_url">the Node.js documentation</a>. When working with <code>import.meta.url</code>, its constructor is especially useful:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-attr">input</span>: <span class="hljs-built_in">string</span>, base?: <span class="hljs-built_in">string</span>|<span class="hljs-variable constant_">URL</span>)</code>
</pre>
<p>Parameter <code>input</code> contains the URL to be parsed. It can be relative if the second parameter, <code>base</code>, is provided.</p>
<p>In other words, this constructor lets us resolve a relative path against a base URL:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'other.mjs'</span>, <span class="hljs-string">'https://example.com/code/main.mjs'</span>).<span class="hljs-property">href</span></span></code>
<code>'https://example.com/code/other.mjs'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'../other.mjs'</span>, <span class="hljs-string">'https://example.com/code/main.mjs'</span>).<span class="hljs-property">href</span></span></code>
<code>'https://example.com/other.mjs'</code>
</pre>
<p>This is how we get a <code>URL</code> instance that points to a file <code>data.txt</code> that sits next to the current module:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> urlOfData = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'data.txt'</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>);</code>
</pre>
<h4 id="importmetaurl-on-nodejs"><a class="heading-id-link" href="#importmetaurl-on-nodejs">29.13.3 <code>import.meta.url</code> on Node.js</a></h4>
<p>On Node.js, <code>import.meta.url</code> is always a string with a <code>file:</code> URL – for example:</p>
<pre class="language-txt">
<code>'file:///Users/rauschma/my-module.mjs'</code>
</pre>
<h5 id="example-reading-a-sibling-file-of-a-module"><a class="heading-id-link" href="#example-reading-a-sibling-file-of-a-module">29.13.3.1 Example: reading a sibling file of a module</a></h5>
<p>Many Node.js file system operations accept either strings with paths or instances of <code>URL</code>. That enables us to read a sibling file <code>data.txt</code> of the current module:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'node:fs'</span>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">readData</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-comment">// data.txt sits next to current module</span></span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">const</span> urlOfData = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'data.txt'</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>);</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">return</span> fs.<span class="hljs-title function_">readFileSync</span>(urlOfData, {<span class="hljs-attr">encoding</span>: <span class="hljs-string">'UTF-8'</span>});</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<h5 id="module-fs-and-urls"><a class="heading-id-link" href="#module-fs-and-urls">29.13.3.2 Module <code>fs</code> and URLs</a></h5>
<p>For most functions of the module <code>fs</code>, we can refer to files via:</p>
<ul>
  <li>
    Paths – in strings or instances of <code>Buffer</code>.
  </li>
  <li>
    URLs – in instances of <code>URL</code> (with the protocol <code>file:</code>)
  </li>
</ul>
<p>For more information on this topic, see <a href="https://nodejs.org/api/fs.html#fs_file_paths">the Node.js API documentation</a>.</p>
<h5 id="converting-urls-paths"><a class="heading-id-link" href="#converting-urls-paths">29.13.3.3 Converting between <code>file:</code> URLs and paths</a></h5>
<p><a href="https://nodejs.org/api/url.html">The Node.js module <code>url</code></a> has two functions for converting between <code>file:</code> URLs and paths:</p>
<ul>
  <li>
    <code>fileURLToPath(url: URL|string): string</code> <br/>
    Converts a <code>file:</code> URL to a path.
  </li>
  <li>
    <code>pathToFileURL(path: string): URL</code> <br/>
    Converts a path to a <code>file:</code> URL.
  </li>
</ul>
<p>If we need a path that can be used in the local file system, then property <code>.pathname</code> of <code>URL</code> instances does not always work:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'file:///tmp/with%20space.txt'</span>).<span class="hljs-property">pathname</span>,</code>
<code>  <span class="hljs-string">'/tmp/with%20space.txt'</span>);</code>
</pre>
<p>Therefore, it is better to use <code>fileURLToPath()</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> url <span class="hljs-keyword">from</span> <span class="hljs-string">'node:url'</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  url.<span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-string">'file:///tmp/with%20space.txt'</span>),</code>
<code>  <span class="hljs-string">'/tmp/with space.txt'</span>); <span class="hljs-comment">// result on Unix</span></code>
</pre>
<p>Similarly, <code>pathToFileURL()</code> does more than just prepend <code>'file://'</code> to an absolute path.</p>
<h3 id="dynamic-imports"><a class="heading-id-link" href="#dynamic-imports">29.14 Loading modules dynamically via <code>import()</code><span> <sup>ES2020</sup> (advanced)</span></a></h3>
<p><span id="index-entry-import--"/>
<span id="index-entry-dynamic-imports"/><span id="index-entry-imports--dynamic"/></p>
<div class="boxout">
  <p><img src="../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png" class="boxout-icon" height="24" alt="Icon “reading”" data-original-src="https://exploringjs.com/js/book/icon/reading.svg"/> <strong>The <code>import()</code> operator returns Promises</strong></p>
  <div class="boxout-vspace"/>
  <p>Promises are a technique for handling results that are computed asynchronously (i.e., not immediately). It may make sense to postpone reading this section until you understand them. More information:</p>
  <ul>
    <li>
      <a href="ch_promises.html#ch_promises">“Promises for asynchronous programming<span> <sup>ES6</sup></span>” (§43)</a>
    </li>
    <li>
      <a href="ch_async-functions.html#ch_async-functions">“Async functions<span> <sup>ES2017</sup></span>” (§44)</a> (explains the <code>await</code> operator for Promises, which we use in this section)
    </li>
  </ul>
</div>
<h4 id="the-limitations-of-static-import-statements"><a class="heading-id-link" href="#the-limitations-of-static-import-statements">29.14.1 The limitations of static <code>import</code> statements</a></h4>
<p>So far, the only way to import a module has been via an <code>import</code> statement. That statement has several limitations:</p>
<ul>
  <li>
    We must use it at the top level of a module. That is, we can’t, for example, import something when we are inside a function or inside an <code>if</code> statement.
  </li>
  <li>
    The module specifier is always fixed. That is, we can’t change what we import depending on a condition. And we can’t assemble a specifier dynamically.
  </li>
</ul>
<h4 id="dynamic-imports-via-the-import-operator"><a class="heading-id-link" href="#dynamic-imports-via-the-import-operator">29.14.2 Dynamic imports via the <code>import()</code> operator</a></h4>
<p>The <code>import()</code> operator doesn’t have the limitations of <code>import</code> statements. It looks like this:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> namespaceObject = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(moduleSpecifierStr);</code>
<code><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(namespaceObject.<span class="hljs-property">namedExport</span>);</code>
</pre>
<p>This operator is used like a function, receives a string with a module specifier and returns a Promise that resolves to a namespace object. The properties of that object are the exports of the imported module.</p>
<p>Note that <code>await</code> can be used at the top levels of modules (see <a href="#top-level-await">next section</a>).</p>
<h5 id="example-loading-a-module-dynamically"><a class="heading-id-link" href="#example-loading-a-module-dynamically">29.14.2.1 Example: loading a module dynamically</a></h5>
<p>Consider the following files:</p>
<pre class="language-txt">
<code>lib/my-math.mjs</code>
<code>main1.mjs</code>
<code>main2.mjs</code>
</pre>
<p>We have already seen module <code>my-math.mjs</code>:</p>
<pre class="language-js">
<code><span class="hljs-comment">// Not exported, private to module</span></code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">times</span>(<span class="hljs-params">a, b</span>) {</code>
<code>  <span class="hljs-keyword">return</span> a * b;</code>
<code>}</code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>) {</code>
<code>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">times</span>(x, x);</code>
<code>}</code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">LIGHT_SPEED</span> = <span class="hljs-number">299792458</span>;</code>
</pre>
<p>We can use <code>import()</code> to load this module on demand:</p>
<pre class="language-js">
<code><span class="hljs-comment">// main1.mjs</span></code>
<code><span class="hljs-keyword">const</span> moduleSpecifier = <span class="hljs-string">'./lib/my-math.mjs'</span>;</code>
<code/>
<code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getLightSpeedAsync</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">const</span> myMath = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(moduleSpecifier);</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">return</span> myMath.<span class="hljs-property">LIGHT_SPEED</span>;</span></code>
<code><span class="hljs-params">}</span></code>
<code/>
<code><span class="hljs-params"><span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getLightSpeedAsync</span>();</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(result, <span class="hljs-number">299792458</span>);</span></code>
</pre>
<p>Two things in this code can’t be done with <code>import</code> statements:</p>
<ul>
  <li>
    We are importing inside a function (not at the top level).
  </li>
  <li>
    The module specifier comes from a variable.
  </li>
</ul>
<div class="boxout">
  <p><img src="../Images/3decb3ca67c240d2bb04742c1f28af18.png" class="boxout-icon" height="24" alt="Icon “question”" data-original-src="https://exploringjs.com/js/book/icon/question.svg"/> <strong>Why is <code>import()</code> an operator and not a function?</strong></p>
  <div class="boxout-vspace"/>
  <p><code>import()</code> looks like a function but couldn’t be implemented as a function:</p>
  <ul>
    <li>
      It needs to know the URL of the current module in order to resolve relative module specifiers.
    </li>
    <li>
      If <code>import()</code> were a function, we’d have to explicitly pass this information to it (e.g. via an parameter).
    </li>
    <li>
      In contrast, an operator is a core language construct and has implicit access to more data, including the URL of the current module.
    </li>
  </ul>
</div>
<h4 id="use-cases-for-import"><a class="heading-id-link" href="#use-cases-for-import">29.14.3 Use cases for <code>import()</code></a></h4>
<h5 id="loading-code-on-demand"><a class="heading-id-link" href="#loading-code-on-demand">29.14.3.1 Loading code on demand</a></h5>
<p>Some functionality of web apps doesn’t have to be present when they start, it can be loaded on demand. Then <code>import()</code> helps because we can put such functionality into modules – for example:</p>
<pre class="language-js">
<code>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">async</span> (event) =&gt; {</code>
<code>  <span class="hljs-keyword">const</span> dialogBox = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./dialogBox.mjs'</span>);</code>
<code>  dialogBox.<span class="hljs-title function_">open</span>();</code>
<code>});</code>
</pre>
<h5 id="conditional-loading-of-modules"><a class="heading-id-link" href="#conditional-loading-of-modules">29.14.3.2 Conditional loading of modules</a></h5>
<p>We may want to load a module depending on whether a condition is true. For example, a module with <a href="#polyfills">a polyfill</a> that makes a new feature available on legacy platforms:</p>
<pre class="language-js">
<code><span class="hljs-keyword">if</span> (<span class="hljs-title function_">isLegacyPlatform</span>()) {</code>
<code>  <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./my-polyfill.mjs'</span>);</code>
<code>}</code>
</pre>
<h5 id="computed-module-specifiers"><a class="heading-id-link" href="#computed-module-specifiers">29.14.3.3 Computed module specifiers</a></h5>
<p>For applications such as internationalization, it helps if we can dynamically compute module specifiers:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> message = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">`messages_<span class="hljs-subst">${getLocale()}</span>.mjs`</span>);</code>
</pre>
<h3 id="top-level-await"><a class="heading-id-link" href="#top-level-await">29.15 Top-level <code>await</code> in modules<span> <sup>ES2022</sup> (advanced)</span></a></h3>
<div class="boxout">
  <p><img src="../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png" class="boxout-icon" height="24" alt="Icon “reading”" data-original-src="https://exploringjs.com/js/book/icon/reading.svg"/> <strong><code>await</code> is a feature of async functions</strong></p>
  <div class="boxout-vspace"/>
  <p><code>await</code> is explained in <a href="ch_async-functions.html#ch_async-functions">“Async functions<span> <sup>ES2017</sup></span>” (§44)</a>. It may make sense to postpone reading this section until you understand async functions.</p>
</div>
<p>We can use the <code>await</code> operator at the top level of a module. If we do that, the module becomes asynchronous and works differently. Thankfully, we don’t usually see that as programmers because it is handled transparently by the language.</p>
<h4 id="use-cases-for-toplevel-await"><a class="heading-id-link" href="#use-cases-for-toplevel-await">29.15.1 Use cases for top-level <code>await</code></a></h4>
<p>Why would we want to use the <code>await</code> operator at the top level of a module? It lets us initialize a module with asynchronously loaded data. The next three subsections show three examples of where that is useful.</p>
<h5 id="loading-modules-dynamically"><a class="heading-id-link" href="#loading-modules-dynamically">29.15.1.1 Loading modules dynamically</a></h5>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(location.<span class="hljs-property">search</span>);</code>
<code><span class="hljs-keyword">const</span> language = params.<span class="hljs-title function_">get</span>(<span class="hljs-string">'lang'</span>);</code>
<code><span class="hljs-keyword">const</span> messages = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">`./messages-<span class="hljs-subst">${language}</span>.mjs`</span>); <span class="hljs-comment">// (A)</span></code>
<code/>
<code><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(messages.<span class="hljs-property">welcome</span>);</code>
</pre>
<p>In line A, we <a href="#dynamic-imports">dynamically import</a> a module. Thanks to top-level <code>await</code>, that is almost as convenient as using a normal, static import.</p>
<h5 id="using-a-fallback-if-module-loading-fails"><a class="heading-id-link" href="#using-a-fallback-if-module-loading-fails">29.15.1.2 Using a fallback if module loading fails</a></h5>
<pre class="language-js">
<code><span class="hljs-keyword">let</span> mylib;</code>
<code><span class="hljs-keyword">try</span> {</code>
<code>  mylib = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'https://primary.example.com/mylib'</span>);</code>
<code>} <span class="hljs-keyword">catch</span> {</code>
<code>  mylib = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'https://secondary.example.com/mylib'</span>);</code>
<code>}</code>
</pre>
<h5 id="using-whichever-resource-loads-fastest"><a class="heading-id-link" href="#using-whichever-resource-loads-fastest">29.15.1.3 Using whichever resource loads fastest</a></h5>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> resource = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>([</code>
<code>  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'http://example.com/first.txt'</span>)</code>
<code>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">text</span>()),</code>
<code>  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'http://example.com/second.txt'</span>)</code>
<code>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">text</span>()),</code>
<code>]);</code>
</pre>
<p>Due to <a href="ch_promises.html#Promise.any"><code>Promise.any()</code></a>, variable <code>resource</code> is initialized via whichever download finishes first.</p>
<h4 id="how-does-toplevel-await-work-under-the-hood"><a class="heading-id-link" href="#how-does-toplevel-await-work-under-the-hood">29.15.2 How does top-level <code>await</code> work under the hood?</a></h4>
<p>Consider the following two files.</p>
<p><code>first.mjs</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'http://example.com/first.txt'</span>);</code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> first = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">text</span>();</code>
</pre>
<p><code>main.mjs</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> {first} <span class="hljs-keyword">from</span> <span class="hljs-string">'./first.mjs'</span>;</code>
<code><span class="hljs-keyword">import</span> {second} <span class="hljs-keyword">from</span> <span class="hljs-string">'./second.mjs'</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(first, <span class="hljs-string">'First!'</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(second, <span class="hljs-string">'Second!'</span>);</code>
</pre>
<p>Both are roughly equivalent to the following code:</p>
<p><code>first.mjs</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> first;</code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> promise = (<span class="hljs-keyword">async</span> () =&gt; { <span class="hljs-comment">// (A)</span></code>
<code>  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'http://example.com/first.txt'</span>);</code>
<code>  first = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">text</span>();</code>
<code>})();</code>
</pre>
<p><code>main.mjs</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> {promise <span class="hljs-keyword">as</span> firstPromise, first} <span class="hljs-keyword">from</span> <span class="hljs-string">'./first.mjs'</span>;</code>
<code><span class="hljs-keyword">import</span> {promise <span class="hljs-keyword">as</span> secondPromise, second} <span class="hljs-keyword">from</span> <span class="hljs-string">'./second.mjs'</span>;</code>
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> promise = (<span class="hljs-keyword">async</span> () =&gt; { <span class="hljs-comment">// (B)</span></code>
<code>  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([firstPromise, secondPromise]); <span class="hljs-comment">// (C)</span></code>
<code>  assert.<span class="hljs-title function_">equal</span>(first, <span class="hljs-string">'First!'</span>);</code>
<code>  assert.<span class="hljs-title function_">equal</span>(second, <span class="hljs-string">'Second!'</span>);</code>
<code>})();</code>
</pre>
<p>A module becomes asynchronous if:</p>
<ol>
  <li>
    It directly uses top-level <code>await</code> (<code>first.mjs</code>).
  </li>
  <li>
    It imports one or more asynchronous modules (<code>main.mjs</code>).
  </li>
</ol>
<p>Each asynchronous module exports a Promise (line A and line B) that is fulfilled after its body was executed. At that point, it is safe to access the exports of that module.</p>
<p>In case (2), the importing module waits until the Promises of all imported asynchronous modules are fulfilled, before it enters its body (line C). Synchronous modules are handled as usually.</p>
<p>Awaited rejections and synchronous exceptions are managed as in async functions.</p>
<h4 id="the-pros-and-cons-of-toplevel-await"><a class="heading-id-link" href="#the-pros-and-cons-of-toplevel-await">29.15.3 The pros and cons of top-level <code>await</code></a></h4>
<p>What are the pros and cons of top-level <code>await</code>?</p>
<ul>
  <li>
    <p>Pros:</p>
    <ul>
      <li>
        It is convenient to have this operator available at the top level of a module, especially for dynamically imported modules.
      </li>
      <li>
        It obviates the need for complicated techniques to ensure that importers don’t access data before it is ready.
      </li>
      <li>
        Tt supports asynchronicity transparently: Importers do not need to know if an imported module is asynchronous or not.
      </li>
    </ul>
  </li>
  <li>
    <p>Cons:</p>
    <ul>
      <li>
        Top-level <code>await</code> delays the initialization of importing modules. Therefore, it’s best used sparingly. Asynchronous tasks that take longer are better performed later, on demand. However, even modules without top-level <code>await</code> can block importers (e.g. via an infinite loop at the top level), so blocking per se is not an argument against it.
      </li>
      <li>
        On Node.js, ESM modules that use top-level <code>await</code> cannot be required from CommonJS. That matters if you write an ESM-based package and want it to be usable from CommonJS code bases. For more information, see section <a href="https://nodejs.org/api/modules.html#loading-ecmascript-modules-using-require">“Loading ECMAScript modules using <code>require()</code>”</a> in the Node.js documentation.
      </li>
    </ul>
  </li>
</ul>
<h3 id="import-attributes"><a class="heading-id-link" href="#import-attributes">29.16 Import attributes: importing non-JavaScript artifacts<span> <sup>ES2025</sup></span></a></h3>
<h4 id="the-history-of-importing-nonjavascript-artifacts"><a class="heading-id-link" href="#the-history-of-importing-nonjavascript-artifacts">29.16.1 The history of importing non-JavaScript artifacts</a></h4>
<p>Importing artifacts that are not JavaScript code as modules, has a long tradition in the JavaScript ecosystem. For example, the JavaScript module loader RequireJS has support for so-called <a href="https://requirejs.org/docs/plugins.html"><em>plugins</em></a>. To give you a feeling for how old RequireJS is: Version 1.0.0 was released in 2009. Specifiers of modules that are imported via a plugin look like this:</p>
<pre>
<code>'«specifier-of-plugin-module»!«specifier-of-artifact»'</code>
</pre>
<p>For example, the following module specifier imports a file as JSON:</p>
<pre>
<code>'json!./data/config.json'</code>
</pre>
<p>Inspired by RequireJS, webpack supports the same module specifier syntax for its <a href="https://webpack.js.org/loaders/"><em>loaders</em></a>.</p>
<h4 id="use-cases-for-importing-nonjavascript-artifacts"><a class="heading-id-link" href="#use-cases-for-importing-nonjavascript-artifacts">29.16.2 Use cases for importing non-JavaScript artifacts</a></h4>
<p>These are a few use cases for importing non-JavaScript artifacts:</p>
<ul>
  <li>
    Importing JSON configuration data
  </li>
  <li>
    Importing WebAssembly code as if it were a JavaScript module
  </li>
  <li>
    Importing CSS to build user interfaces
  </li>
</ul>
<p>For more use cases, you can take a look at <a href="https://webpack.js.org/loaders/">the list of webpack’s loaders</a>.</p>
<h4 id="import-attributes-1"><a class="heading-id-link" href="#import-attributes-1">29.16.3 Import attributes</a></h4>
<p>The motivating use case for import attributes was importing JSON data as a module. That looks as follows:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> configData <span class="hljs-keyword">from</span> <span class="hljs-string">'./config-data.json'</span> <span class="hljs-keyword">with</span> { <span class="hljs-attr">type</span>: <span class="hljs-string">'json'</span> };</code>
</pre>
<p><code>type</code> is an import attribute (more on the syntax soon).</p>
<p>You may wonder why a JavaScript engine can’t use the filename extension <code>.json</code> to determine that this is JSON data. However, a core architectural principle of the web is to never use the filename extension to determine what’s inside a file. Instead, content types are used.</p>
<p>If a server is set up correctly then why not do a normal import and omit the import attributes?</p>
<ul>
  <li>
    The server may be deliberately misconfigured – e.g., an external server not controlled by the people who wrote the code. It could swap an imported JSON file with code that would be executed by the importer.
  </li>
  <li>
    The server may be accidentally misconfigured. With import attributes, we get feedback more quickly.
  </li>
  <li>
    Given that the expected content type is not explicit in the code, the attributes also document the expectations of the programmer.
  </li>
</ul>
<h4 id="the-syntax-of-import-attributes"><a class="heading-id-link" href="#the-syntax-of-import-attributes">29.16.4 The syntax of import attributes</a></h4>
<p>Let’s examine in more detail what import attributes look like.</p>
<h5 id="static-import-statements"><a class="heading-id-link" href="#static-import-statements">29.16.4.1 Static import statements</a></h5>
<p>We have already seen a normal (static) import statement:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> configData <span class="hljs-keyword">from</span> <span class="hljs-string">'./config-data.json'</span> <span class="hljs-keyword">with</span> { <span class="hljs-attr">type</span>: <span class="hljs-string">'json'</span> };</code>
</pre>
<p>The import attributes start with the keyword <code>with</code>. That keyword is followed by an object literal. For now, the following object literal features are supported:</p>
<ul>
  <li>
    Unquoted keys and quoted keys
  </li>
  <li>
    The values must be strings
  </li>
</ul>
<p>There are no other syntactic restrictions placed on the keys and the values, but engines should throw an exception if they don’t support a key and/or a value:</p>
<ul>
  <li>
    Attributes change what is imported, so simply ignoring them is risky because that changes the runtime behavior of code.
  </li>
  <li>
    A side benefit is that this makes it easier to add more features in the future because no one will use keys and values in unexpected ways.
  </li>
</ul>
<h5 id="dynamic-imports-1"><a class="heading-id-link" href="#dynamic-imports-1">29.16.4.2 Dynamic imports</a></h5>
<p>To support import attributes, <a href="import-operator">dynamic imports</a> get a second parameter – an object with configuration data:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> configData = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(</code>
<code>  <span class="hljs-string">'./config-data.json'</span>, { <span class="hljs-attr">with</span>: { <span class="hljs-attr">type</span>: <span class="hljs-string">'json'</span> } }</code>
<code>);</code>
</pre>
<p>The import attributes don’t exist at the top level; they are specified via the property <code>with</code>. That makes it possible to add more configuration options in the future.</p>
<h5 id="reexport-statements"><a class="heading-id-link" href="#reexport-statements">29.16.4.3 Re-export statements</a></h5>
<p>A re-export imports and exports in a single step. For the former, we need attributes:</p>
<pre class="language-js">
<code><span class="hljs-keyword">export</span> { <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> config } <span class="hljs-keyword">from</span> <span class="hljs-string">'./config-data.json'</span> <span class="hljs-keyword">with</span> { <span class="hljs-attr">type</span>: <span class="hljs-string">'json'</span> };</code>
</pre>
<h4 id="json-modules"><a class="heading-id-link" href="#json-modules">29.16.5 JSON modules<span> <sup>ES2025</sup></span></a></h4>
<p>Import attributes are really just syntax. They lay the foundation for actual features that make use of that syntax. The first ECMAScript feature based on import attributes is JSON modules – which we’ve already seen in action:</p>
<p>This is a file <code>config-data.json</code>:</p>
<pre class="language-json">
<code><span class="hljs-punctuation">{</span></code>
<code>  <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1.0.0"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"maxCount"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span></code>
<code><span class="hljs-punctuation">}</span></code>
</pre>
<p>It sits next to the following ECMAScript module <code>main.js</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> configData <span class="hljs-keyword">from</span> <span class="hljs-string">'./config-data.json'</span> <span class="hljs-keyword">with</span> { <span class="hljs-attr">type</span>: <span class="hljs-string">'json'</span> };</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  configData,</code>
<code>  {</code>
<code>    <span class="hljs-attr">version</span>: <span class="hljs-string">'1.0.0'</span>,</code>
<code>    <span class="hljs-attr">maxCount</span>: <span class="hljs-number">20</span></code>
<code>  }</code>
<code>);</code>
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Importing JSON</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/modules/get-version_test.mjs</code></p>
</div>
<h3 id="polyfills"><a class="heading-id-link" href="#polyfills">29.17 Polyfills: emulating native web platform features<span> (advanced)</span></a></h3>
<p><span id="index-entry-polyfill"/>
<span id="index-entry-polyfill--speculative"/><span id="index-entry-speculative-polyfill"/><span id="index-entry-prollyfill"/>
<span id="index-entry-shim"/>
<span id="index-entry-replica"/><span id="index-entry-ponyfill"/></p>
<div class="boxout">
  <p><img src="../Images/38ba63de820aae6f94a019538ae0f222.png" class="boxout-icon" height="24" alt="Icon “details”" data-original-src="https://exploringjs.com/js/book/icon/details.svg"/> <strong>Backends have polyfills, too</strong></p>
  <div class="boxout-vspace"/>
  <p>This section is about frontend development and web browsers, but similar ideas apply to backend development.</p>
</div>
<p><em>Polyfills</em> help with a conflict that we are facing when developing a web application in JavaScript:</p>
<ul>
  <li>
    On one hand, we want to use modern web platform features that make the app better and/or development easier.
  </li>
  <li>
    On the other hand, the app should run on as many browsers as possible.
  </li>
</ul>
<p>Given a web platform feature X:</p>
<ul>
  <li>
    <p>A <em>polyfill</em> for X is a piece of code. If it is executed on a platform that already has built-in support for X, it does nothing. Otherwise, it makes the feature available on the platform. In the latter case, the polyfilled feature is (mostly) indistinguishable from a native implementation. In order to achieve that, the polyfill usually makes global changes. For example, it may modify global data or configure a global module loader. Polyfills are often packaged as modules.</p>
    <ul>
      <li>
        The term <a href="https://remysharp.com/2010/10/08/what-is-a-polyfill"><em>polyfill</em></a> was coined by Remy Sharp.
      </li>
    </ul>
  </li>
  <li>
    <p>A <em>speculative polyfill</em> is a polyfill for a proposed web platform feature (that is not standardized, yet).</p>
    <ul>
      <li>
        Alternative term: <em>prollyfill</em>
      </li>
    </ul>
  </li>
  <li>
    <p>A <em>replica</em> of X is a library that reproduces the API and functionality of X locally. Such a library exists independently of a native (and global) implementation of X.</p>
    <ul>
      <li>
        <em>Replica</em> is a new term introduced in this section. Alternative term: <em>ponyfill</em>
      </li>
    </ul>
  </li>
  <li>
    <p>There is also the term <em>shim</em>, but it doesn’t have a universally agreed upon definition. It often means roughly the same as <em>polyfill</em>.</p>
  </li>
</ul>
<p>Every time our web applications starts, it must first execute all polyfills for features that may not be available everywhere. Afterwards, we can be sure that those features are available natively.</p>
<h4 id="sources-of-this-section"><a class="heading-id-link" href="#sources-of-this-section">29.17.1 Sources of this section</a></h4>
<ul>
  <li>
    <a href="https://remysharp.com/2010/10/08/what-is-a-polyfill">“What is a Polyfill?”</a> by Remy Sharp
  </li>
  <li>
    Inspiration for the term <em>replica</em>: <a href="https://en.wikipedia.org/wiki/Paris_Las_Vegas">The Eiffel Tower in Las Vegas</a>
  </li>
  <li>
    Useful clarification of “polyfill” and related terms: <a href="https://www.w3.org/2001/tag/doc/polyfills/">“Polyfills and the evolution of the Web”</a>. Edited by Andrew Betts.
  </li>
</ul>

    
      
</body>
</html>