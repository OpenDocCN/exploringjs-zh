<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>48 Creating and parsing JSON (JSON)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>48 Creating and parsing JSON (JSON)</h1>
<blockquote>原文：<a href="https://exploringjs.com/js/book/ch_json.html">https://exploringjs.com/js/book/ch_json.html</a></blockquote>

        
    
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#the-discovery-and-standardization-of-json">48.1 The discovery and standardization of JSON</a>
      <ol>
        <li>
          <a href="#json-grammar-is-frozen">48.1.1 JSON’s grammar is frozen</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#json-syntax">48.2 JSON syntax</a>
    </li>
    <li>
      <a href="#json-api">48.3 The <code>JSON</code> API</a>
      <ol>
        <li>
          <a href="#JSON.stringify">48.3.1 <code>JSON.stringify(data, replacer?, space?)</code></a>
        </li>
        <li>
          <a href="#JSON.parse">48.3.2 <code>JSON.parse(text, reviver?)</code></a>
        </li>
        <li>
          <a href="#example-converting-to-and-from-json">48.3.3 Example: converting to and from JSON</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#json-replacers-revivers">48.4 Customizing stringification and parsing<span> (advanced)</span></a>
      <ol>
        <li>
          <a href="#stringfy-specifying-which-properties-of-objects-to-stringify">48.4.1 <code>.stringfy()</code>: specifying which properties of objects to stringify</a>
        </li>
        <li>
          <a href="#json-value-visitors">48.4.2 <code>.stringify()</code> and <code>.parse()</code>: value visitors</a>
        </li>
        <li>
          <a href="#example-visiting-values">48.4.3 Example: visiting values</a>
        </li>
        <li>
          <a href="#example-stringifying-unsupported-values">48.4.4 Example: stringifying unsupported values</a>
        </li>
        <li>
          <a href="#example-parsing-unsupported-values">48.4.5 Example: parsing unsupported values</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#faq">48.5 FAQ</a>
      <ol>
        <li>
          <a href="#why-doesnt-json-support-comments">48.5.1 Why doesn’t JSON support comments?</a>
        </li>
      </ol>
    </li>
  </ol>
</nav>
<p>JSON (“JavaScript Object Notation”) is a storage format that uses text to encode data. Its syntax is a subset of JavaScript expressions. As an example, consider the following text, stored in a file <code>jane.json</code>:</p>
<pre class="language-js">
<code>{</code>
<code>  <span class="hljs-string">"first"</span>: <span class="hljs-string">"Jane"</span>,</code>
<code>  <span class="hljs-string">"last"</span>: <span class="hljs-string">"Porter"</span>,</code>
<code>  <span class="hljs-string">"married"</span>: <span class="hljs-literal">true</span>,</code>
<code>  <span class="hljs-string">"born"</span>: <span class="hljs-number">1890</span>,</code>
<code>  <span class="hljs-string">"friends"</span>: [ <span class="hljs-string">"Tarzan"</span>, <span class="hljs-string">"Cheeta"</span> ]</code>
<code>}</code>
</pre>
<p>JavaScript has the global namespace object <code>JSON</code> that provides methods for creating and parsing JSON.</p>
<h3 id="the-discovery-and-standardization-of-json"><a class="heading-id-link" href="#the-discovery-and-standardization-of-json">48.1 The discovery and standardization of JSON</a></h3>
<p>A specification for JSON was published by Douglas Crockford in 2001, at <a href="http://json.org/"><code>json.org</code></a>. He explains:</p>
<blockquote>
  <p>I discovered JSON. I do not claim to have invented JSON because it already existed in nature. What I did was I found it, I named it, I described how it was useful. I don't claim to be the first person to have discovered it; I know that there are other people who discovered it at least a year before I did. The earliest occurrence I've found was, there was someone at Netscape who was using JavaScript array literals for doing data communication as early as 1996, which was at least five years before I stumbled onto the idea.</p>
</blockquote>
<p>Later, JSON was standardized as <a href="https://ecma-international.org/publications-and-standards/standards/ecma-404/">ECMA-404</a>:</p>
<ul>
  <li>
    1st edition: October 2013
  </li>
  <li>
    2nd edition: December 2017
  </li>
</ul>
<h4 id="json-grammar-is-frozen"><a class="heading-id-link" href="#json-grammar-is-frozen">48.1.1 JSON’s grammar is frozen</a></h4>
<p>Quoting the ECMA-404 standard:</p>
<blockquote>
  <p>Because it is so simple, it is not expected that the JSON grammar will ever change. This gives JSON, as a foundational notation, tremendous stability.</p>
</blockquote>
<p>Therefore, JSON will never get improvements such as optional trailing commas, comments, or unquoted keys – independently of whether or not they are considered desirable. However, that still leaves room for creating supersets of JSON that compile to plain JSON.</p>
<h3 id="json-syntax"><a class="heading-id-link" href="#json-syntax">48.2 JSON syntax</a></h3>
<p><span id="index-entry-JSON--data-format-"/></p>
<p>JSON consists of the following parts of JavaScript:</p>
<ul>
  <li>
    Compound:
    <ul>
      <li>
        Object literals:
        <ul>
          <li>
            Property keys are double-quoted strings.
          </li>
          <li>
            Property values are JSON values.
          </li>
          <li>
            No trailing commas are allowed.
          </li>
        </ul>
      </li>
      <li>
        Array literals:
        <ul>
          <li>
            Elements are JSON values.
          </li>
          <li>
            No holes or trailing commas are allowed.
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    Atomic:
    <ul>
      <li>
        <code>null</code> (but not <code>undefined</code>)
      </li>
      <li>
        Booleans
      </li>
      <li>
        Numbers (excluding <code>NaN</code>, <code>+Infinity</code>, <code>-Infinity</code>)
      </li>
      <li>
        Strings (must be double-quoted)
      </li>
    </ul>
  </li>
</ul>
<p>As a consequence, we can’t (directly) represent cyclic structures in JSON.</p>
<h3 id="json-api"><a class="heading-id-link" href="#json-api">48.3 The <code>JSON</code> API</a></h3>
<p><span id="index-entry-JSON--namespace-object-"/></p>
<p>The global namespace object <code>JSON</code> contains two methods for working with JSON data:</p>
<ul>
  <li>
    <code>JSON.stringify(data, replacer?, space?)</code>
  </li>
  <li>
    <code>JSON.parse(text, reviver?)</code>
  </li>
</ul>
<p>The next sections explain how those methods work.</p>
<h4 id="JSON.stringify"><a class="heading-id-link" href="#JSON.stringify">48.3.1 <code>JSON.stringify(data, replacer?, space?)</code></a></h4>
<p>This method converts JavaScript <code>data</code> to a JSON string. In this section, we ignore the parameter <code>replacer</code>; it is explained in <a href="#json-replacers-revivers">“Customizing stringification and parsing<span> (advanced)</span>” (§48.4)</a>.</p>
<h5 id="result-a-single-line-of-text"><a class="heading-id-link" href="#result-a-single-line-of-text">48.3.1.1 Result: a single line of text</a></h5>
<p>If we only provide the first argument, <code>.stringify()</code> returns a single line of text:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({<span class="hljs-attr">prop</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]}),</code>
<code>  <span class="hljs-string">'{"prop":["a","b"]}'</span></code>
<code>);</code>
</pre>
<h5 id="result-a-tree-of-indented-lines"><a class="heading-id-link" href="#result-a-tree-of-indented-lines">48.3.1.2 Result: a tree of indented lines</a></h5>
<p>If you provide a non-negative integer for <code>space</code>, then <code>.stringify()</code> returns one or more lines and indents by <code>space</code> spaces per level of nesting:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({<span class="hljs-attr">prop</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]}, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>),</code>
<code><span class="hljs-string">`{</span></code>
<code><span class="hljs-string">  "prop": [</span></code>
<code><span class="hljs-string">    "a",</span></code>
<code><span class="hljs-string">    "b"</span></code>
<code><span class="hljs-string">  ]</span></code>
<code><span class="hljs-string">}`</span></code>
<code>);</code>
</pre>
<h5 id="json-stringify-details"><a class="heading-id-link" href="#json-stringify-details">48.3.1.3 Details on how data is converted to JSON</a></h5>
<p><strong>Primitive values:</strong></p>
<ul>
  <li>
    <p>Supported primitive values are stringified as expected:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-literal">null</span>)</span></code>
<code>'null'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-literal">true</span>)</span></code>
<code>'true'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-number">123</span>)</span></code>
<code>'123'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">'abc'</span>)</span></code>
<code>'"abc"'</code>
</pre>
  </li>
  <li>
    <p>Unsupported numbers: the string <code>'null'</code></p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-title class_">NaN</span>)</span></code>
<code>'null'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-title class_">Infinity</span>)</span></code>
<code>'null'</code>
</pre>
  </li>
  <li>
    <p>Bigints (no matter where they appear): <code>TypeError</code></p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-number">123n</span>)</span></code>
<code>TypeError: Do not know how to serialize a BigInt</code>
</pre>
  </li>
  <li>
    <p>Other unsupported primitive values are not stringified; they produce the result <code>undefined</code>:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-literal">undefined</span>)</span></code>
<code>undefined</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-title class_">Symbol</span>())</span></code>
<code>undefined</code>
</pre>
  </li>
</ul>
<p><strong>Objects:</strong></p>
<ul>
  <li>
    <p>If an object has a method <code>.toJSON()</code>, then the result of that method is stringified:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({<span class="hljs-title function_">toJSON</span>(<span class="hljs-params"/>) {<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>}})</span></code>
<code>'true'</code>
</pre>
    <p>Dates have a method <code>.toJSON()</code> that returns a string:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2999</span>, <span class="hljs-number">11</span>, <span class="hljs-number">31</span>))</span></code>
<code>'"2999-12-30T23:00:00.000Z"'</code>
</pre>
  </li>
  <li>
    <p>Wrapped primitive values are unwrapped and stringified:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">true</span>))</span></code>
<code>'true'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">123</span>))</span></code>
<code>'123'</code>
</pre>
  </li>
  <li>
    <p>An unsupported <code>undefined</code>-producing value is stringified as <code>null</code> inside an Array:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>([<span class="hljs-literal">undefined</span>, <span class="hljs-number">123</span>, <span class="hljs-title class_">Symbol</span>()])</span></code>
<code>'[null,123,null]'</code>
</pre>
  </li>
  <li>
    <p>All other objects – except for functions – are stringified as object literals. If a property has an unsupported <code>undefined</code>-producing value, it is omitted:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({<span class="hljs-attr">a</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">b</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">c</span>: <span class="hljs-title class_">Symbol</span>()})</span></code>
<code>'{"b":true}'</code>
</pre>
  </li>
  <li>
    <p>Functions are not stringified:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-function">() =&gt;</span> {})</span></code>
<code>undefined</code>
</pre>
  </li>
</ul>
<p><strong>Circular data:</strong> <code>JSON.stringify()</code> throws an exception if data is circular:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> cycle = {};</code>
<code>cycle.<span class="hljs-property">prop</span> = cycle;</code>
<code>assert.<span class="hljs-title function_">throws</span>(</code>
<code>  <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(cycle),</code>
<code>  <span class="hljs-regexp">/^TypeError: Converting circular structure to JSON/</span></code>
<code>);</code>
</pre>
<h4 id="JSON.parse"><a class="heading-id-link" href="#JSON.parse">48.3.2 <code>JSON.parse(text, reviver?)</code></a></h4>
<p>This method converts a JSON <code>text</code> to a JavaScript value.  In this section, we ignore the parameter <code>reviver</code>; it is explained in <a href="#json-replacers-revivers">“Customizing stringification and parsing<span> (advanced)</span>” (§48.4)</a>.</p>
<p>Example:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">'{"prop":["a","b"]}'</span>)</span></code>
<code>{ prop: [ 'a', 'b' ] }</code>
</pre>
<h4 id="example-converting-to-and-from-json"><a class="heading-id-link" href="#example-converting-to-and-from-json">48.3.3 Example: converting to and from JSON</a></h4>
<p>The following class implements conversions from (line A) and to (line B) JSON.</p>
<pre class="language-js">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {</code>
<code>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">fromJson</span>(<span class="hljs-params">jsonObj</span>) { <span class="hljs-comment">// (A)</span></code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(jsonObj.<span class="hljs-property">x</span>, jsonObj.<span class="hljs-property">y</span>);</code>
<code>  }</code>
<code/>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y</span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;</code>
<code>  }</code>
<code>  </code>
<code>  <span class="hljs-title function_">toJSON</span>(<span class="hljs-params">) { <span class="hljs-comment">// (B)</span></span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> {<span class="hljs-attr">x</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>, <span class="hljs-attr">y</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>};</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<ul>
  <li>
    <p>Converting JSON to a point: We use the static method <code>Point.fromJson()</code> to parse JSON and create an instance of <code>Point</code>.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Point</span>.<span class="hljs-title function_">fromJson</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">'{"x":3,"y":5}'</span>)),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>) );</code>
</pre>
  </li>
  <li>
    <p>Converting a point to JSON: <code>JSON.stringify()</code> internally calls <a href="#json-stringify-details">the previously mentioned method <code>.toJSON()</code></a>.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)),</code>
<code>  <span class="hljs-string">'{"x":3,"y":5}'</span> );</code>
</pre>
  </li>
</ul>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Converting an object to and from JSON</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/json/to_from_json_test.mjs</code></p>
</div>
<h3 id="json-replacers-revivers"><a class="heading-id-link" href="#json-replacers-revivers">48.4 Customizing stringification and parsing<span> (advanced)</span></a></h3>
<p>Stringification and parsing can be customized as follows:</p>
<ul>
  <li>
    <p><code>JSON.stringify(data, replacer?, space?)</code></p>
    <p>The optional parameter <code>replacer</code> contains either:</p>
    <ul>
      <li>
        An Array with names of properties. If a value in <code>data</code> is stringified as an object literal, then only the mentioned properties are considered. All other properties are ignored.
      </li>
      <li>
        A <em>value visitor</em>, a function that can transform JavaScript data before it is stringified.
      </li>
    </ul>
  </li>
  <li>
    <p><code>JSON.parse(text, reviver?)</code></p>
    <p>The optional parameter <code>reviver</code> contains a value visitor that can transform the parsed JSON data before it is returned.</p>
  </li>
</ul>
<h4 id="stringfy-specifying-which-properties-of-objects-to-stringify"><a class="heading-id-link" href="#stringfy-specifying-which-properties-of-objects-to-stringify">48.4.1 <code>.stringfy()</code>: specifying which properties of objects to stringify</a></h4>
<p>If the second parameter of <code>.stringify()</code> is an Array, then only object properties, whose names are mentioned there, are included in the result:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,</code>
<code>  <span class="hljs-attr">b</span>: {</code>
<code>    <span class="hljs-attr">c</span>: <span class="hljs-number">2</span>,</code>
<code>    <span class="hljs-attr">d</span>: <span class="hljs-number">3</span>,</code>
<code>  }</code>
<code>};</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj, [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]),</code>
<code>  <span class="hljs-string">'{"b":{"c":2}}'</span>);</code>
</pre>
<h4 id="json-value-visitors"><a class="heading-id-link" href="#json-value-visitors">48.4.2 <code>.stringify()</code> and <code>.parse()</code>: value visitors</a></h4>
<p>What I call a <em>value visitor</em> is a function that transforms JavaScript data:</p>
<ul>
  <li>
    <code>JSON.stringify()</code> lets the value visitor in its parameter <code>replacer</code> transform JavaScript data before it is stringified.
  </li>
  <li>
    <code>JSON.parse()</code> lets the value visitor in its parameter <code>reviver</code> transform parsed JavaScript data before it is returned.
  </li>
</ul>
<p>In this section, JavaScript data is considered to be a tree of values. If the data is atomic, it is a tree that only has a root. All values in the tree are fed to the value visitor, one at a time. Depending on what the visitor returns, the current value is omitted, changed, or preserved.</p>
<p>A value visitor has the following type signature:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ValueVisitor</span> = <span class="hljs-function">(<span class="hljs-params">key: <span class="hljs-built_in">string</span>, value: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">any</span>;</code>
</pre>
<p>The parameters are:</p>
<ul>
  <li>
    <code>value</code>: The current value.
  </li>
  <li>
    <code>this</code>: Parent of current value. The parent of the root value <code>r</code> is <code>{'': r}</code>.
    <ul>
      <li>
        Note: <code>this</code> is an implicit parameter and only available if the value visitor is an ordinary function.
      </li>
    </ul>
  </li>
  <li>
    <code>key</code>: Key or index of the current value inside its parent. The key of the root value is <code>''</code>.
  </li>
</ul>
<p>The value visitor can return:</p>
<ul>
  <li>
    <code>value</code>: means there won’t be any change.
  </li>
  <li>
    A different value <code>x</code>: leads to <code>value</code> being replaced with <code>x</code> in the output tree.
  </li>
  <li>
    <code>undefined</code>: leads to <code>value</code> being omitted in the output tree.
  </li>
</ul>
<h4 id="example-visiting-values"><a class="heading-id-link" href="#example-visiting-values">48.4.3 Example: visiting values</a></h4>
<p>The following code shows in which order a value visitor sees values:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> log = [];</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">valueVisitor</span>(<span class="hljs-params">key, value</span>) {</code>
<code>  log.<span class="hljs-title function_">push</span>({<span class="hljs-attr">this</span>: <span class="hljs-variable language_">this</span>, key, value});</code>
<code>  <span class="hljs-keyword">return</span> value; <span class="hljs-comment">// no change</span></code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">const</span> root = {</code>
<code>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,</code>
<code>  <span class="hljs-attr">b</span>: {</code>
<code>    <span class="hljs-attr">c</span>: <span class="hljs-number">2</span>,</code>
<code>    <span class="hljs-attr">d</span>: <span class="hljs-number">3</span>,</code>
<code>  }</code>
<code>};</code>
<code><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(root, valueVisitor);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(log, [</code>
<code>  { <span class="hljs-attr">this</span>: { <span class="hljs-string">''</span>: root }, <span class="hljs-attr">key</span>: <span class="hljs-string">''</span>,  <span class="hljs-attr">value</span>: root   },</code>
<code>  { <span class="hljs-attr">this</span>: root        , <span class="hljs-attr">key</span>: <span class="hljs-string">'a'</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>      },</code>
<code>  { <span class="hljs-attr">this</span>: root        , <span class="hljs-attr">key</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">value</span>: root.<span class="hljs-property">b</span> },</code>
<code>  { <span class="hljs-attr">this</span>: root.<span class="hljs-property">b</span>      , <span class="hljs-attr">key</span>: <span class="hljs-string">'c'</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>      },</code>
<code>  { <span class="hljs-attr">this</span>: root.<span class="hljs-property">b</span>      , <span class="hljs-attr">key</span>: <span class="hljs-string">'d'</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>      },</code>
<code>]);</code>
</pre>
<p>As we can see, the replacer of <code>JSON.stringify()</code> visits values top-down (root first, leaves last). The rationale for going in that direction is that we are converting JavaScript values to JSON values. And a single JavaScript object may be expanded into a tree of JSON-compatible values.</p>
<p>In contrast, the reviver of <code>JSON.parse()</code> visits values bottom-up (leaves first, root last). The rationale for going in that direction is that we are assembling JSON values into JavaScript values. Therefore, we need to convert the parts before we can convert the whole.</p>
<h4 id="example-stringifying-unsupported-values"><a class="heading-id-link" href="#example-stringifying-unsupported-values">48.4.4 Example: stringifying unsupported values</a></h4>
<p><code>JSON.stringify()</code> has no special support for regular expression objects – it stringifies them as if they were plain objects:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  <span class="hljs-attr">name</span>: <span class="hljs-string">'abc'</span>,</code>
<code>  <span class="hljs-attr">regex</span>: <span class="hljs-regexp">/abc/ui</span>,</code>
<code>};</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj),</code>
<code>  <span class="hljs-string">'{"name":"abc","regex":{}}'</span>);</code>
</pre>
<p>We can fix that via a replacer:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">replacer</span>(<span class="hljs-params">key, value</span>) {</code>
<code>  <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>) {</code>
<code>    <span class="hljs-keyword">return</span> {</code>
<code>      <span class="hljs-attr">__type__</span>: <span class="hljs-string">'RegExp'</span>,</code>
<code>      <span class="hljs-attr">source</span>: value.<span class="hljs-property">source</span>,</code>
<code>      <span class="hljs-attr">flags</span>: value.<span class="hljs-property">flags</span>,</code>
<code>    };</code>
<code>  } <span class="hljs-keyword">else</span> {</code>
<code>    <span class="hljs-keyword">return</span> value; <span class="hljs-comment">// no change</span></code>
<code>  }</code>
<code>}</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj, replacer, <span class="hljs-number">2</span>),</code>
<code><span class="hljs-string">`{</span></code>
<code><span class="hljs-string">  "name": "abc",</span></code>
<code><span class="hljs-string">  "regex": {</span></code>
<code><span class="hljs-string">    "__type__": "RegExp",</span></code>
<code><span class="hljs-string">    "source": "abc",</span></code>
<code><span class="hljs-string">    "flags": "iu"</span></code>
<code><span class="hljs-string">  }</span></code>
<code><span class="hljs-string">}`</span>);</code>
</pre>
<h4 id="example-parsing-unsupported-values"><a class="heading-id-link" href="#example-parsing-unsupported-values">48.4.5 Example: parsing unsupported values</a></h4>
<p>To <code>JSON.parse()</code> the result from the previous section, we need a reviver:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">reviver</span>(<span class="hljs-params">key, value</span>) {</code>
<code>  <span class="hljs-comment">// Very simple check</span></code>
<code>  <span class="hljs-keyword">if</span> (value &amp;&amp; value.<span class="hljs-property">__type__</span> === <span class="hljs-string">'RegExp'</span>) {</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(value.<span class="hljs-property">source</span>, value.<span class="hljs-property">flags</span>);</code>
<code>  } <span class="hljs-keyword">else</span> {</code>
<code>    <span class="hljs-keyword">return</span> value;</code>
<code>  }</code>
<code>}</code>
<code><span class="hljs-keyword">const</span> str = <span class="hljs-string">`{</span></code>
<code><span class="hljs-string">  "name": "abc",</span></code>
<code><span class="hljs-string">  "regex": {</span></code>
<code><span class="hljs-string">    "__type__": "RegExp",</span></code>
<code><span class="hljs-string">    "source": "abc",</span></code>
<code><span class="hljs-string">    "flags": "iu"</span></code>
<code><span class="hljs-string">  }</span></code>
<code><span class="hljs-string">}`</span>;</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str, reviver),</code>
<code>  {</code>
<code>    <span class="hljs-attr">name</span>: <span class="hljs-string">'abc'</span>,</code>
<code>    <span class="hljs-attr">regex</span>: <span class="hljs-regexp">/abc/ui</span>,</code>
<code>  });</code>
</pre>
<h3 id="faq"><a class="heading-id-link" href="#faq">48.5 FAQ</a></h3>
<h4 id="why-doesnt-json-support-comments"><a class="heading-id-link" href="#why-doesnt-json-support-comments">48.5.1 Why doesn’t JSON support comments?</a></h4>
<p>Douglas Crockford explains why in <a href="https://web.archive.org/web/20190308024153/https://plus.google.com/+DouglasCrockfordEsq/posts/RK8qyGVaGSr">a Google+ post from 1 May 2012</a>:</p>
<blockquote>
  <p>I removed comments from JSON because I saw people were using them to hold parsing directives, a practice which would have destroyed interoperability.  I know that the lack of comments makes some people sad, but it shouldn't.</p>
  <p>Suppose you are using JSON to keep configuration files, which you would like to annotate. Go ahead and insert all the comments you like. Then pipe it through JSMin [a minifier for JavaScript] before handing it to your JSON parser.</p>
</blockquote>

    
      
</body>
</html>