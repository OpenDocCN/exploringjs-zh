["```js\nasync function fetchJsonAsync(url) {\n try {\n const request = await fetch(url); // async\n const text = await request.text(); // async\n return JSON.parse(text); // sync\n }\n catch (error) {\n assert.fail(error);\n }\n}\n\n```", "```js\nfunction fetchJsonViaPromises(url) {\n return fetch(url) // async\n .then(request => request.text()) // async\n .then(text => JSON.parse(text)) // sync\n .catch((error) => {\n assert.fail(error);\n });\n}\n\n```", "```js\nfetchJsonAsync('http://example.com/person.json')\n.then((obj) => {\n assert.deepEqual(obj, {\n first: 'Jane',\n last: 'Doe',\n });\n});\n\n```", "```js\n    async function f() {\n     assert.equal(\n     await Promise.resolve('fulfilled'),\n     'fulfilled'\n     );\n    }\n\n    ```", "```js\n    async function f() {\n     try {\n     await Promise.reject('rejected');\n     } catch (err) {\n     assert.equal(err, 'rejected');\n     }\n    }\n\n    ```", "```js\n    async function f1() { return 'fulfilled' }\n    f1().then(\n     result => assert.equal(result, 'fulfilled')\n    );\n\n    ```", "```js\n    async function f() { throw 'rejected' }\n    f().catch(\n     error => assert.equal(error, 'rejected')\n    );\n\n    ```", "```js\n// Async function declaration\nasync function func1() {}\n `// Async function expression`\n`const func2 = async function () {};`\n ```", "```js `// Async method definition in an object literal` `const obj = { async m() {} };`  `` `// Async method definition in a class definition` `class MyClass { async m() {} }` `` ```", "```js` \n```", "```js```", "``` ```", "````` ![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **Asynchronous functions vs. async functions**    The difference between the terms *asynchronous function* and *async function* is subtle, but important:    *   An *asynchronous function* is any function that delivers its result asynchronously – for example, a callback-based function or a Promise-based function.           *   An *async function* is defined via special syntax, involving the keywords `async` and `await`. It is also called async/await due to these two keywords. Async functions are based on Promises and therefore also asynchronous functions (which is somewhat confusing).              That being said: These two terms are also often used interchangeably.    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Fetch API via async functions**    `exercises/async-functions/fetch_json2_test.mjs`    ### [44.2 What values can be used with `await`?](#what-values-can-be-used-with-await)    The `await` operator can only be used inside async functions and async generators (which are explained in [“Asynchronous generators” (§45.2)](ch_async-iteration.html#async-generators)). Its operand is usually a Promise and leads to the following steps being performed:    *   The current async function is paused. *   When and if the Promise is settled, the async function is resumed:     *   If the Promise is fulfilled, `await` returns the fulfillment value.     *   If the Promise is rejected, `await` throws the rejection value.    For more information on what exactly pausing and resuming means, see [“Async functions start synchronously, settle asynchronously” (§44.5)](#async-funcs-start-sync-settle-async).    Read on to find out how `await` handles various values.    #### [44.2.1 Awaiting fulfilled Promises](#awaiting-fulfilled-promises)    If its operand is a fulfilled Promise, `await` returns its fulfillment value:    ```js assert.equal(  await Promise.resolve('fulfilled'), 'fulfilled' );  ```    The value of `await` is delivered asynchronously:    ```js async function awaitPromise() {  queueMicrotask( // (A)  () => console.log('OTHER TASK')  );  console.log('before');  await Promise.resolve('fulfilled');  console.log('after'); } await awaitPromise();  ```    Output:    ```js before OTHER TASK after  ```    In line A, we can’t use `setTimeout()`. We have to use `queueMicrotask()` because Promise-related tasks are so-called *microtasks* which are different from normal tasks and always handled before them (via a *microtask queue*). For more information, see the MDN article [“In depth: Microtasks and the JavaScript runtime environment”](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth).    #### [44.2.2 Awaiting rejected Promises](#awaiting-rejected-promises)    If its operand is a rejected Promise, then `await` throws the rejection value:    ```js try {  await Promise.reject(  new Error('Problem!')  );  assert.fail(); // we never get here } catch (err) {  assert.deepEqual(err, new Error('Problem!')); }  ```    #### [44.2.3 Awaiting non-Promise values](#awaiting-nonpromise-values)    Non-Promise values can also be awaited and are simply passed on:    ```js assert.equal(  await 'non-Promise value', 'non-Promise value' );  ```    Even in this case, the result of `await` is delivered asynchronously:    ```js async function awaitNonPromiseValue() {  queueMicrotask(() => console.log('OTHER TASK'));  console.log('before');  await 'non-Promise value';  console.log('after'); } await awaitNonPromiseValue();  ```    Output:    ```js before OTHER TASK after  ```    ### [44.3 Where can `await` be used?](#where-can-await-be-used)    #### [44.3.1 Using `await` at the top levels of modules ^(ES2022)](#using-await-at-the-top-levels-of-modules-es2022)    We can use `await` at the top levels of modules – for example:    ```js let mylib; try {  mylib = await import('https://primary.example.com/mylib'); } catch {  mylib = await import('https://secondary.example.com/mylib'); }  ```    For more information on this feature, see [“Top-level `await` in modules ^(ES2022) (advanced)” (§29.15)](ch_modules.html#top-level-await).    #### [44.3.2 Awaiting is shallow](#awaiting-is-shallow)    If we are inside an async function and want to pause it via `await`, we must do so directly within that function; we can’t use it inside a nested function, such as a callback. That is, pausing is *shallow*.    Let’s examine what that means. In the following code, we try to await inside a nested function:    ```js async function f() {  const nestedFunc = () => {  const result = await Promise.resolve('abc'); // SyntaxError!  return 'RESULT: ' + result;  };  return [ nestedFunc() ]; }  ```    However, that isn’t even valid syntax because `await` is not allowed inside synchronous functions such as `nestedFunc()`. What happens if we make `nestedFunc()` an async function?    ```js async function f() {  const nestedFunc = async () => {  const result = await Promise.resolve('abc'); // (A)  return 'RESULT: ' + result;  };  return [ nestedFunc() ]; // (B) } const arr = await f(); // (C) assert.equal(  arr[0] instanceof Promise, true );  ```    This time, the `await` in line A pauses `nestedFunc()`, not `f()`. `nestedFunc()` returns a Promise, which is wrapped in an Array in line B. Note [the top-level `await`](ch_modules.html#top-level-await) in line C.    To make this code work, we must await the result of `nestedFunc()`:    ```js async function f() {  const nestedFunc = async () => {  const result = await Promise.resolve('abc');  return 'RESULT: ' + result;  };  return [ await nestedFunc() ]; } assert.deepEqual(  await f(), ['RESULT: abc'] );  ```    To summarize: `await` only affects the immediately surrounding function (which must be an async function).    #### [44.3.3 Example: `.map()` with an async function as a callback](#map-with-async-callback)    What happens if we use an async function as a callback for `.map()`? Then the result is an Array of Promises:    ```js const arrayOfPromises = arr.map(  async (x) => { /*···*/ } );  ```    We can use [`Promise.all()`](ch_promises.html#Promise.all) to convert that Array of Promises to a Promise for an Array and await that Promise:    ```js const array = await Promise.all(  arr.map(  async (x) => { /*···*/ }  ) );  ```    We use that technique in the following code, which downloads files via [`fetch()`](ch_promises.html#fetch-api). The content of each file is its filename.    ```js const urls = [  'http://example.com/file1.txt',  'http://example.com/file2.txt', ]; const uppercaseTexts = await Promise.all( // (A)  urls.map(async (url) => {  const response = await fetch(url);  const text = await response.text();  return text.toUpperCase();  }) ); assert.deepEqual(  uppercaseTexts,  ['FILE1.TXT', 'FILE2.TXT'] );  ```    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Mapping and filtering asynchronously**    `exercises/async-functions/map_async_test.mjs`    ### [44.4 `return` in async functions](#return-in-async-functions)    #### [44.4.1 The result of an async function is always a Promise](#the-result-of-an-async-function-is-always-a-promise)    If we call an async function, the result is always a Promise – even if the async function throws an exception. Inside the async function, we can fulfill the result Promise by returning non-Promise values (line A):    ```js async function asyncFunc() {  return 123; // (A) }  `asyncFunc()` `.then((result) => {`  `assert.equal(result, 123);` `});`  ```   ```js```` As usual, if we don’t explicitly return anything, `undefined` is returned for us:    ```js async function asyncFunc() {}  `asyncFunc()` `.then((result) => {`  `assert.equal(result, undefined);` `});`  ```   ```js``` We reject the result Promise via `throw` (line A):    ``` async function asyncFunc() {  throw new Error('Problem!'); // (A) }  `asyncFunc()` `.catch((err) => {`  `assert.deepEqual(err, new Error('Problem!'));` `});`  ```js   `````", "```js async function asyncFunc1() {  return Promise.resolve('fulfilled'); } const p1 = asyncFunc1(); p1.then(  result => assert.equal(result, 'fulfilled') );  ```", "```js async function asyncFunc2() {  return Promise.reject('rejected'); } const p2 = asyncFunc2(); p2.catch(  error => assert.equal(error, 'rejected') );  ```", "```js async function asyncFunc() {  console.log('asyncFunc() starts'); // (A)  return 'abc'; } asyncFunc(). then((x) => { // (B)  console.log(`Resolved: ${x}`); }); console.log('Task ends'); // (C)  ```", "```js asyncFunc() starts Task ends Resolved: abc  ```", "```js async function asyncFunc() {  const writer = openFile('someFile.txt');  writer.write('hello'); // don’t wait  writer.write('world'); // don’t wait  await writer.close(); // wait for file to close }  ```", "```js await longRunningAsyncOperation(); console.log('Done!');  ```", "```js async function f() {  return await Promise.resolve('result'); }  ```", "```js async function f() {  return Promise.resolve('result'); }  ```", "```js async function f() {  try {  return await Promise.reject('error'); // (A)  } catch (err) {  return 'Caught an error: ' + err;  } } f().then((result) => {  assert.equal(result, 'Caught an error: error'); });  ```", "```js async function f() {  try {  return Promise.reject('error');  } catch (err) {  return 'Caught an error: ' + err;  } } f().catch((reason) => {  assert.equal(reason, 'error'); });  ```", "```js async function returnAfterPause(id) {  console.log('START ' + id);  await delay(10); // pause  console.log('END ' + id);  return id; }  `/**`  ``* Resolves after `ms` milliseconds``  `*/` `function delay(ms) {`  `return new Promise((resolve, _reject) => {`  `setTimeout(resolve, ms);`  `});` `}`  ```", "```js` #### [44.7.1 `await`: running Promise-based functions sequentially](#await-sequentially)    If we prefix the invocations of multiple Promise-based functions with `await`, then those functions are executed sequentially:    ```", "```js    Output:    ```", "```js    That is, `returnAfterPause('second')` is only started after `returnAfterPause('first')` is completely finished.    #### [44.7.2 `await`: running Promise-based functions concurrently](#await-concurrently)    If we want to run multiple Promise-based functions concurrently, we can use the utility method `Promise.all()`:    ```", "```js    Output:    ```", "```js    Here, both asynchronous functions are started at the same time. Once both are settled, `await` gives us either an Array of fulfillment values or – if at least one Promise is rejected – an exception.    Recall from [earlier](ch_promises.html#focus-on-async-start) that what counts is when we start a Promise-based computation; not how we process its result. Therefore, the following code is as “concurrent” as the previous one:    ```", "```js    Output:    ```", "```js ```", "```js`` ```", "```js ```", "```js` ```", "```js`` ```"]