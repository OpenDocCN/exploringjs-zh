- en: 18 Bigints – arbitrary-precision integers [ES2020] (advanced)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/impatient-js/ch_bigints.html](https://exploringjs.com/impatient-js/ch_bigints.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 18.1 [Why bigints?](ch_bigints.html#why-bigints)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.2 [Bigints](ch_bigints.html#bigints)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.2.1 [Going beyond 53 bits for integers](ch_bigints.html#going-beyond-53-bits-for-integers)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '18.2.2 [Example: using bigints](ch_bigints.html#example-using-bigints)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.3 [Bigint literals](ch_bigints.html#bigint-literals)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.3.1 [Underscores (`_`) as separators in bigint literals [ES2021]](ch_bigints.html#numeric-separator-bigint-literals)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.4 [Reusing number operators for bigints (overloading)](ch_bigints.html#reusing-number-operators-for-bigints-overloading)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.4.1 [Arithmetic operators](ch_bigints.html#arithmetic-operators-1)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.4.2 [Ordering operators](ch_bigints.html#ordering-operators-1)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.4.3 [Bitwise operators](ch_bigints.html#bitwise-operators-1)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.4.4 [Loose equality (`==`) and inequality (`!=`)](ch_bigints.html#loose-equality-and-inequality)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.4.5 [Strict equality (`===`) and inequality (`!==`)](ch_bigints.html#strict-equality-and-inequality)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.5 [The wrapper constructor `BigInt`](ch_bigints.html#the-wrapper-constructor-bigint)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.5.1 [`BigInt` as a constructor and as a function](ch_bigints.html#bigint-as-a-constructor-and-as-a-function)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.5.2 [`BigInt.prototype.*` methods](ch_bigints.html#bigint.prototype.-methods)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.5.3 [`BigInt.*` methods](ch_bigints.html#bigint.-methods)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.5.4 [Casting and 64-bit integers](ch_bigints.html#casting-and-64-bit-integers)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.6 [Coercing bigints to other primitive types](ch_bigints.html#coercing-bigints-to-other-primitive-types)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.7 [TypedArrays and DataView operations for 64-bit values](ch_bigints.html#typedarrays-and-dataview-operations-for-64-bit-values)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.8 [Bigints and JSON](ch_bigints.html#bigints-and-json)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.8.1 [Stringifying bigints](ch_bigints.html#stringifying-bigints)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.8.2 [Parsing bigints](ch_bigints.html#parsing-bigints)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '18.9 [FAQ: Bigints](ch_bigints.html#faq-bigints)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.9.1 [How do I decide when to use numbers and when to use bigints?](ch_bigints.html#how-do-i-decide-when-to-use-numbers-and-when-to-use-bigints)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.9.2 [Why not just increase the precision of numbers in the same manner as
    is done for bigints?](ch_bigints.html#why-not-just-increase-the-precision-of-numbers-in-the-same-manner-as-is-done-for-bigints)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we take a look at *bigints*, JavaScript’s integers whose storage
    space grows and shrinks as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 18.1 Why bigints?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before ECMAScript 2020, JavaScript handled integers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There only was a single type for floating point numbers and integers: 64-bit
    floating point numbers (IEEE 754 double precision).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Under the hood, most JavaScript engines transparently supported integers: If
    a number has no decimal digits and is within a certain range, it can internally
    be stored as a genuine integer. This representation is called *small integer*
    and usually fits into 32 bits. For example, the range of small integers on the
    64-bit version of the V8 engine is from −2^(31) to 2^(31)−1 ([source](https://medium.com/fhinkel/v8-internals-how-small-is-a-small-integer-e0badc18b6da)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript numbers could also represent integers beyond the small integer range,
    as floating point numbers. Here, the safe range is plus/minus 53 bits. For more
    information on this topic, see [§16.9.3 “Safe integers”](ch_numbers.html#safe-integers).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sometimes, we need more than signed 53 bits – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Twitter uses 64-bit integers as IDs for tweets ([source](https://dev.twitter.com/overview/api/twitter-ids-json-and-snowflake)).
    In JavaScript, these IDs had to be stored in strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Financial technology uses so-called *big integers* (integers with arbitrary
    precision) to represent amounts of money. Internally, the amounts are multiplied
    so that the decimal numbers disappear. For example, USD amounts are multiplied
    by 100 so that the cents disappear.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.2 Bigints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Bigint* is a new primitive data type for integers. Bigints don’t have a fixed
    storage size in bits; their sizes adapt to the integers they represent:'
  prefs: []
  type: TYPE_NORMAL
- en: Small integers are represented with fewer bits than large integers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no negative lower limit or positive upper limit for the integers that
    can be represented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A bigint literal is a sequence of one or more digits, suffixed with an `n`
    – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Operators such as `-` and `*` are overloaded and work with bigints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Bigints are primitive values. `typeof` returns a new result for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 18.2.1 Going beyond 53 bits for integers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'JavaScript numbers are internally represented as a fraction multiplied by an
    exponent (see [§16.8 “Background: floating point precision”](ch_numbers.html#background-floating-point-precision)
    for details). As a consequence, if we go beyond the highest [*safe integer*](ch_numbers.html#safe-integers)
    2^(53)−1, there are still *some* integers that can be represented, but with gaps
    between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Bigints enable us to go beyond 53 bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '18.2.2 Example: using bigints'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is what using bigints looks like (code based on an example in the proposal):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 18.3 Bigint literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like number literals, bigint literals support several bases:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Decimal: `123n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hexadecimal: `0xFFn`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Binary: `0b1101n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Octal: `0o777n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Negative bigints are produced by prefixing the unary minus operator: `-0123n`'
  prefs: []
  type: TYPE_NORMAL
- en: 18.3.1 Underscores (`_`) as separators in bigint literals [ES2021]
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Just like in number literals](ch_numbers.html#numeric-separator-number-literals),
    we can use underscores (`_`) as separators in bigint literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Bigints are often used to represent money in the financial technical sector.
    Separators can help here, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As with number literals, two restrictions apply:'
  prefs: []
  type: TYPE_NORMAL
- en: We can only put an underscore between two digits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use at most one underscore in a row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.4 Reusing number operators for bigints (overloading)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With most operators, we are not allowed to mix bigints and numbers. If we do,
    exceptions are thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for this rule is that there is no general way of coercing a number
    and a bigint to a common type: numbers can’t represent bigints beyond 53 bits,
    bigints can’t represent fractions. Therefore, the exceptions warn us about typos
    that may lead to unexpected results.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, should the result of the following expression be `9007199254740993n`
    or `9007199254740992`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also not clear what the result of the following expression should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 18.4.1 Arithmetic operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Binary `+`, binary `-`, `*`, `**` work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It is OK to mix bigints and strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`/`, `%` round towards zero (like `Math.trunc()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Unary `-` works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Unary `+` is not supported for bigints because much code relies on it coercing
    its operand to number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 18.4.2 Ordering operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Ordering operators `<`, `>`, `>=`, `<=` work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Comparing bigints and numbers does not pose any risks. Therefore, we can mix
    bigints and numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 18.4.3 Bitwise operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 18.4.3.1 Bitwise operators for numbers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Bitwise operators interpret numbers as 32-bit integers. These integers are
    either unsigned or signed. If they are signed, the negative of an integer is its
    *two’s complement* (adding an integer to its two’s complement – while ignoring
    overflow – produces zero):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to these integers having a fixed size, their highest bits indicate their
    signs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 18.4.3.2 Bitwise operators for bigints
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For bigints, bitwise operators interpret a negative sign as an infinite two’s
    complement – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-1` is `···111111` (ones extend infinitely to the left)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-2` is `···111110`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-3` is `···111101`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-4` is `···111100`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is, a negative sign is more of an external flag and not represented as
    an actual bit.
  prefs: []
  type: TYPE_NORMAL
- en: 18.4.3.3 Bitwise Not (`~`)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Bitwise Not (`~`) inverts all bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 18.4.3.4 Binary bitwise operators (`&`, `|`, `^`)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Applying binary bitwise operators to bigints works analogously to applying
    them to numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 18.4.3.5 Bitwise signed shift operators (`<<` and `>>`)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The signed shift operators for bigints preserve the sign of a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that `-1n` is a sequence of ones that extends infinitely to the left.
    That’s why shifting it left doesn’t change it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 18.4.3.6 Bitwise unsigned right shift operator (`>>>`)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There is no unsigned right shift operator for bigints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Why? The idea behind unsigned right shifting is that a zero is shifted in “from
    the left”. In other words, the assumption is that there is a finite amount of
    binary digits.
  prefs: []
  type: TYPE_NORMAL
- en: However, with bigints, there is no “left”, their binary digits extend infinitely.
    This is especially important with negative numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Signed right shift works even with an infinite number of digits because the
    highest digit is preserved. Therefore, it can be adapted to bigints.
  prefs: []
  type: TYPE_NORMAL
- en: 18.4.4 Loose equality (`==`) and inequality (`!=`)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Loose equality (`==`) and inequality (`!=`) coerce values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 18.4.5 Strict equality (`===`) and inequality (`!==`)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Strict equality (`===`) and inequality (`!==`) only consider values to be equal
    if they have the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 18.5 The wrapper constructor `BigInt`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Analogously to numbers, bigints have the associated wrapper constructor `BigInt`.
  prefs: []
  type: TYPE_NORMAL
- en: 18.5.1 `BigInt` as a constructor and as a function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`new BigInt()`: throws a `TypeError`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BigInt(x)` converts arbitrary values `x` to bigint. This works similarly to
    `Number()`, with several differences which are summarized in tbl. [13](#tbl:converting-values-to-bigints)
    and explained in more detail in the following subsections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Table 13: Converting values to bigints.'
  prefs: []
  type: TYPE_NORMAL
- en: '| `x` | `BigInt(x)` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `undefined` | Throws `TypeError` |'
  prefs: []
  type: TYPE_TB
- en: '| `null` | Throws `TypeError` |'
  prefs: []
  type: TYPE_TB
- en: '| boolean | `false` `→` `0n`, `true` `→` `1n` |'
  prefs: []
  type: TYPE_TB
- en: '| number | Example: `123` `→` `123n` |'
  prefs: []
  type: TYPE_TB
- en: '|  | Non-integer `→` throws `RangeError` |'
  prefs: []
  type: TYPE_TB
- en: '| bigint | `x` (no change) |'
  prefs: []
  type: TYPE_TB
- en: '| string | Example: `''123''` `→` `123n` |'
  prefs: []
  type: TYPE_TB
- en: '|  | Unparsable `→` throws `SyntaxError` |'
  prefs: []
  type: TYPE_TB
- en: '| symbol | Throws `TypeError` |'
  prefs: []
  type: TYPE_TB
- en: '| object | Configurable (e.g. via `.valueOf()`) |'
  prefs: []
  type: TYPE_TB
- en: 18.5.1.1 Converting `undefined` and `null`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A `TypeError` is thrown if `x` is either `undefined` or `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 18.5.1.2 Converting strings
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If a string does not represent an integer, `BigInt()` throws a `SyntaxError`
    (whereas `Number()` returns the error value `NaN`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The suffix `''n''` is not allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'All bases of bigint literals are allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 18.5.1.3 Non-integer numbers produce exceptions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 18.5.1.4 Converting objects
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'How objects are converted to bigints can be configured – for example, by overriding
    `.valueOf()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 18.5.2 `BigInt.prototype.*` methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`BigInt.prototype` holds the methods “inherited” by primitive bigints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BigInt.prototype.toLocaleString(locales?, options?)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BigInt.prototype.toString(radix?)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BigInt.prototype.valueOf()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.5.3 `BigInt.*` methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`BigInt.asIntN(width, theInt)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casts `theInt` to `width` bits (signed). This influences how the value is represented
    internally.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`BigInt.asUintN(width, theInt)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casts `theInt` to `width` bits (unsigned).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 18.5.4 Casting and 64-bit integers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Casting allows us to create integer values with a specific number of bits.
    If we want to restrict ourselves to just 64-bit integers, we have to always cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 18.6 Coercing bigints to other primitive types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This table show what happens if we convert bigints to other primitive types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Convert to | Explicit conversion | Coercion (implicit conversion) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| boolean | `Boolean(0n)` `→` `false` | `!0n` `→` `true` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `Boolean(int)` `→` `true` | `!int` `→` `false` |'
  prefs: []
  type: TYPE_TB
- en: '| number | `Number(7n)` `→` `7` (example) | `+int` `→` `TypeError` (1) |'
  prefs: []
  type: TYPE_TB
- en: '| string | `String(7n)` `→` `''7''` (example) | `''''+7n` `→` `''7''` (example)
    |'
  prefs: []
  type: TYPE_TB
- en: 'Footnote:'
  prefs: []
  type: TYPE_NORMAL
- en: (1) Unary `+` is not supported for bigints, because much code relies on it coercing
    its operand to number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.7 TypedArrays and DataView operations for 64-bit values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Thanks to bigints, Typed Arrays and DataViews can support 64-bit values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Typed Array constructors:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BigInt64Array`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BigUint64Array`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DataView methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DataView.prototype.getBigInt64()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DataView.prototype.setBigInt64()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DataView.prototype.getBigUint64()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DataView.prototype.setBigUint64()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.8 Bigints and JSON
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The JSON standard is fixed and won’t change. The upside is that old JSON parsing
    code will never be outdated. The downside is that JSON can’t be extended to contain
    bigints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stringifying bigints throws exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 18.8.1 Stringifying bigints
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Therefore, our best option is to store bigints in strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 18.8.2 Parsing bigints
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following code shows how to parse strings such as the one that we have produced
    in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '18.9 FAQ: Bigints'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 18.9.1 How do I decide when to use numbers and when to use bigints?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'My recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use numbers for up to 53 bits and for Array indices. Rationale: They already
    appear everywhere and are handled efficiently by most engines (especially if they
    fit into 31 bits). Appearances include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.forEach()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array.prototype.entries()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use bigints for large numeric values: If your fraction-less values don’t fit
    into 53 bits, you have no choice but to move to bigints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All existing web APIs return and accept only numbers and will only upgrade to
    bigint on a case-by-case basis.
  prefs: []
  type: TYPE_NORMAL
- en: 18.9.2 Why not just increase the precision of numbers in the same manner as
    is done for bigints?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One could conceivably split `number` into `integer` and `double`, but that would
    add many new complexities to the language (several integer-only operators etc.).
    I’ve sketched the consequences in [a Gist](https://gist.github.com/rauschma/13d48d1c49615ce2396ce7c9e45d4cd1).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**Acknowledgements:**'
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to Daniel Ehrenberg for reviewing an earlier version of this content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to Dan Callahan for reviewing an earlier version of this content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/50)'
  prefs: []
  type: TYPE_NORMAL
