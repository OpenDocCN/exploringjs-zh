["```ts\nclass OtherClass {}\n\nclass MyClass1 extends OtherClass {\n publicInstanceField = 1;\n constructor() {\n super();\n }\n publicPrototypeMethod() {\n return 2;\n }\n}\n\nconst inst1 = new MyClass1();\nassert.equal(inst1.publicInstanceField, 1);\nassert.equal(inst1.publicPrototypeMethod(), 2);\n\n```", "```ts\nclass MyClass2 {\n static staticPublicField = 1;\n static staticPublicMethod() {\n return 2;\n }\n}\n\nassert.equal(MyClass2.staticPublicField, 1);\nassert.equal(MyClass2.staticPublicMethod(), 2);\n\n```", "```ts\nclass MyClass3 {\n #privateField = 1;\n #privateMethod() {\n return 2;\n }\n static accessPrivateMembers() {\n // Private members can only be accessed from inside class definitions\n const inst3 = new MyClass3();\n assert.equal(inst3.#privateField, 1);\n assert.equal(inst3.#privateMethod(), 2);\n }\n}\n\n```", "```ts\nclass MyClass4 {\n #name = 'Rumpelstiltskin';\n\n /** Prototype getter */\n get name() {\n return this.#name;\n }\n\n /** Prototype setter */\n set name(value) {\n this.#name = value;\n }\n}\nconst inst5 = new MyClass4();\nassert.equal(inst5.name, 'Rumpelstiltskin'); // getter\ninst5.name = 'Queen'; // setter\nassert.equal(inst5.name, 'Queen'); // getter\n\n```", "```ts\nclass MyClass5 {\n * publicPrototypeGeneratorMethod() {\n yield 'hello';\n yield 'world';\n }\n}\n\nconst inst6 = new MyClass5();\nassert.deepEqual(\n Array.from(inst6.publicPrototypeGeneratorMethod()),\n ['hello', 'world']\n);\n\n```", "```ts\nclass MyClass6 {\n async publicPrototypeAsyncMethod() {\n const result = await Promise.resolve('abc');\n return result + result;\n }\n}\n\nconst inst7 = new MyClass6();\nassert.equal(\n await inst7.publicPrototypeAsyncMethod(),\n 'abcabc'\n);\n\n```", "```ts\nconst publicInstanceFieldKey = Symbol('publicInstanceFieldKey');\nconst publicPrototypeMethodKey = Symbol('publicPrototypeMethodKey');\n\nclass MyClass7 {\n [publicInstanceFieldKey] = 1;\n [publicPrototypeMethodKey]() {\n return 2;\n }\n}\n\nconst inst8 = new MyClass7();\nassert.equal(inst8[publicInstanceFieldKey], 1);\nassert.equal(inst8[publicPrototypeMethodKey](), 2);\n\n```", "```ts\nclass ClassA {\n static staticMthdA() {}\n constructor(instPropA) {\n this.instPropA = instPropA;\n }\n prototypeMthdA() {}\n}\nclass ClassB extends ClassA {\n static staticMthdB() {}\n constructor(instPropA, instPropB) {\n super(instPropA);\n this.instPropB = instPropB;\n }\n prototypeMthdB() {}\n}\nconst instB = new ClassB(0, 1);\n\n```", "```ts\nclass PersonPrivateProperty {\n private name: string; // (A)\n constructor(name: string) {\n this.name = name;\n }\n sayHello() {\n return `Hello ${this.name}!`;\n }\n}\n\n```", "```ts\nconst john = new PersonPrivateProperty('John');\n\nassert.equal(\n john.sayHello(), 'Hello John!'\n);\n\n// @ts-expect-error: Property 'name' is private and only accessible\n// within class 'PersonPrivateProperty'.\njohn.name; // (A)\n\n```", "```ts\nassert.deepEqual(\n Object.keys(john),\n ['name']\n);\n\n```", "```ts\nclass PersonPrivateProperty {\n constructor(name) {\n this.name = name;\n }\n sayHello() {\n return `Hello ${this.name}!`;\n }\n}\n\n```", "```ts\nclass PersonPrivateField {\n #name: string;\n constructor(name: string) {\n this.#name = name;\n }\n sayHello() {\n return `Hello ${this.#name}!`;\n }\n}\n\n```", "```ts\nconst john = new PersonPrivateField('John');\n\nassert.equal(\n john.sayHello(), 'Hello John!'\n);\n\n```", "```ts\nassert.throws(\n () => eval('john.#name'), // (A)\n {\n name: 'SyntaxError',\n message: \"Private field '#name' must be declared in \"\n + \"an enclosing class\",\n }\n);\n\nassert.deepEqual(\n Object.keys(john),\n []\n);\n\n```", "```ts\nclass PersonPrivateField {\n #name;\n constructor(name) {\n this.#name = name;\n }\n sayHello() {\n return `Hello ${this.#name}!`;\n }\n}\n\n```", "```ts\nclass PrivatePerson {\n private name: string;\n constructor(name: string) {\n this.name = name;\n }\n sayHello() {\n return `Hello ${this.name}!`;\n }\n}\nclass PrivateEmployee extends PrivatePerson {\n private company: string;\n constructor(name: string, company: string) {\n super(name);\n this.company = company;\n }\n override sayHello() { // (A)\n // @ts-expect-error: Property 'name' is private and only\n // accessible within class 'PrivatePerson'.\n return `Hello ${this.name} from ${this.company}!`; // (B)\n } \n}\n\n```", "```ts\nclass ProtectedPerson {\n protected name: string; // (A)\n constructor(name: string) {\n this.name = name;\n }\n sayHello() {\n return `Hello ${this.name}!`;\n }\n}\nclass ProtectedEmployee extends ProtectedPerson {\n protected company: string; // (B)\n constructor(name: string, company: string) {\n super(name);\n this.company = company;\n }\n override sayHello() {\n return `Hello ${this.name} from ${this.company}!`; // OK\n } \n}\n\n```", "```ts\nclass DataContainer {\n #data: string;\n static async create() {\n const data = await Promise.resolve('downloaded'); // (A)\n return new this(data);\n }\n private constructor(data: string) {\n this.#data = data;\n }\n getData() {\n return 'DATA: '+this.#data;\n }\n}\nconst dataContainer = await DataContainer.create();\nassert.equal(\n dataContainer.getData(),\n 'DATA: downloaded'\n);\n\n```", "```ts\n    class Point {\n     x: number;\n     y: number;\n     constructor(x: number, y: number) {\n     this.x = x;\n     this.y = y;\n     }\n    }\n\n    ```", "```ts\n    class Point {\n     x = 0;\n     y = 0;\n\n     // No constructor needed\n    }\n\n    ```", "```ts\nclass Point {\n x!: number; // (A)\n y!: number; // (B)\n constructor() {\n this.initProperties();\n }\n initProperties() {\n this.x = 0;\n this.y = 0;\n }\n}\n\n```", "```ts\nclass CompilerError implements CompilerErrorProps { // (A)\n line!: number;\n description!: string;\n constructor(props: CompilerErrorProps) {\n Object.assign(this, props); // (B)\n }\n}\n\n// Helper interface for the parameter properties\ninterface CompilerErrorProps {\n line: number,\n description: string,\n}\n\n// Using the class:\nconst err = new CompilerError({\n line: 123,\n description: 'Unexpected token',\n});\n\n```", "```ts\nclass C {\n str;\n constructor(str: string) {\n this.str = str; // (A)\n }\n}\n\n```", "```ts\nclass Point {\n constructor(public x: number, public y: number) {\n }\n}\n\n```", "```ts\nclass Point {\n constructor(x, y) {\n this.x = x;\n this.y = y;\n }\n}\n\n```", "```ts\nclass StringBuilder {\n string = '';\n add(str: string) {\n this.string += str;\n }\n}\nabstract class Printable {\n toString() {\n const out = new StringBuilder();\n this.print(out);\n return out.string;\n }\n abstract print(out: StringBuilder): void;\n}\n\n```", "```ts\nclass Entries extends Printable {\n entries: Entry[];\n constructor(entries: Entry[]) {\n super();\n this.entries = entries;\n }\n print(out: StringBuilder): void {\n for (const entry of this.entries) {\n entry.print(out);\n }\n }\n}\nclass Entry extends Printable {\n key: string;\n value: string;\n constructor(key: string, value: string) {\n super();\n this.key = key;\n this.value = value;\n }\n print(out: StringBuilder): void {\n out.add(this.key);\n out.add(': ');\n out.add(this.value);\n out.add('\\n');\n }\n}\n\n```", "```ts\nconst entries = new Entries([\n new Entry('accept-ranges', 'bytes'),\n new Entry('content-length', '6518'),\n]);\nassert.equal(\n entries.toString(),\n 'accept-ranges: bytes\\ncontent-length: 6518\\n'\n);\n\n```", "```ts\nclass A {\n m(): void {}\n}\nclass B extends A {\n // `override` is required\n override m(): void {} // (A)\n}\n\n```", "```ts\nabstract class A {\n abstract m(): void;\n}\nclass B extends A {\n // `override` is optional\n override m(): void {}\n}\n\n```", "```ts\nclass Counter {\n count = 0;\n inc(): void {\n this.count++;\n }\n}\n\n// Trying out the functionality\nconst counter = new Counter();\ncounter.inc();\nassert.equal(\n counter.count, 1\n);\n\n```", "```ts\ntype Counter = {\n count: number,\n};\nfunction createCounter(): Counter {\n return {\n count: 0,\n };\n}\nfunction inc(counter: Counter): void {\n counter.count++;\n}\n\n// Trying out the functionality\nconst counter = createCounter();\ninc(counter);\nassert.equal(\n counter.count, 1\n);\n\n```"]