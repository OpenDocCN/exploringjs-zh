- en: 42 Foundations of asynchronous programming in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_async-js.html](https://exploringjs.com/js/book/ch_async-js.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[42.1 The event loop](#event-loop)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[42.2 How to avoid blocking the JavaScript process](#how-to-avoid-blocking-the-javascript-process)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[42.2.1 The user interface of the browser can be blocked](#blocking-browsers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[42.2.2 How can we avoid blocking the browser?](#avoiding-blocking-browser)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[42.2.3 Scheduling new tasks via `setTimeout()`](#setTimeout)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[42.2.4 Run-to-completion semantics](#run-to-completion-semantics)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[42.3 Patterns for delivering results asynchronously](#patterns-for-async-results)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[42.3.1 Delivering asynchronous results via events](#event-pattern)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[42.3.2 Delivering asynchronous results via callbacks](#callback-pattern)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[42.4 Asynchronous code: the downsides](#async-code-downsides)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[42.5 Resources](#resources)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This chapter explains the foundations of asynchronous programming in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '[42.1 The event loop](#event-loop)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Normally JavaScript runs in a single process – in both web browsers and Node.js.
    Inside that single process, *tasks* are run, one at a time. A *task* is a piece
    of code – think function with zero parameters. Tasks are managed via a queue:'
  prefs: []
  type: TYPE_NORMAL
- en: The *event loop* runs continuously inside the JavaScript process. During each
    loop iteration, it takes one task out of the queue (if the queue is empty, it
    waits until it isn’t) and executes it. After the task is finished, control goes
    back to the event loop, which then retrieves the next task from the queue and
    executes it. And so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Task sources* add tasks to the queue. Some of those sources run concurrently
    to the JavaScript process. For example, one task source takes care of user interface
    events: if a user clicks somewhere and a click listener was registered, then an
    invocation of that listener is added to the task queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following JavaScript code is an approximation of the event loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The event loop is depicted in [figure 42.1](#fig:event_loop).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/74ee57a8c7fc965c57f47cc602fdd8cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 42.1: *Task sources* add code to run to the *task queue*, which is emptied
    by the *event loop*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[42.2 How to avoid blocking the JavaScript process](#how-to-avoid-blocking-the-javascript-process)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[42.2.1 The user interface of the browser can be blocked](#blocking-browsers)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Many of the user interface mechanisms of browsers also run in the JavaScript
    process (as tasks). Therefore, long-running JavaScript code can block the user
    interface. Let’s look at a web page that demonstrates that. There are two ways
    in which we can try out that page:'
  prefs: []
  type: TYPE_NORMAL
- en: We can [run it online](http://rauschma.github.io/async-examples/blocking.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can open the following file inside the repository with the exercises: `demos/async-js/blocking.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following HTML is the page’s user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The idea is that we click “Block” and a long-running loop is executed via JavaScript.
    During that loop, we can’t click the button because the browser/JavaScript process
    is blocked.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simplified version of the JavaScript code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3][PRE4]js[PRE5] With this API, we first create a request object (line
    A), then configure it, then activate it (line E). The configuration consists of:    *   Specifying
    which HTTP request method to use (line B): `GET`, `POST`, `PUT`, etc. *   Registering
    a listener (line C) that is notified if something could be downloaded. Inside
    the listener, we still need to determine if the download contains what we requested
    or informs us of an error. Note that some of the result data is delivered via
    the request object `xhr`. (I’m not a fan of this kind of mixing of input and output
    data.) *   Registering a listener (line D) that is notified if there was a network
    error.    ##### [42.3.1.3 Events: DOM](#events-dom)    We have already seen DOM
    events in action in [“The user interface of the browser can be blocked” (§42.2.1)](#blocking-browsers).
    The following code also handles `click` events:    [PRE6]   [PRE7] readFile(''some-file.txt'',
    {encoding: ''utf-8''},  (error, data) => {  if (error) {  assert.fail(error);  return;  }  assert.equal(data,
    ''The content of some-file.txt'');  });  [PRE8]` [PRE9][PRE10][PRE11][PRE12]``````'
  prefs: []
  type: TYPE_NORMAL
