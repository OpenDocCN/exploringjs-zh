- en: 7 Syntax
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/impatient-js/ch_syntax.html](https://exploringjs.com/impatient-js/ch_syntax.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 7.1 [An overview of JavaScript’s syntax](ch_syntax.html#an-overview-of-javascripts-syntax)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.1.1 [Basic constructs](ch_syntax.html#basic-constructs)
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.1.2 [Modules](ch_syntax.html#modules)
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.1.3 [Classes](ch_classes.html#classes)
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.1.4 [Exception handling](ch_syntax.html#exception-handling)
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.1.5 [Legal variable and property names](ch_syntax.html#legal-variable-and-property-names)
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.1.6 [Casing styles](ch_syntax.html#casing-styles)
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.1.7 [Capitalization of names](ch_syntax.html#capitalization-of-names)
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.1.8 [More naming conventions](ch_syntax.html#more-naming-conventions)
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.1.9 [Where to put semicolons?](ch_syntax.html#where-to-put-semicolons)
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.2 [(Advanced)](ch_syntax.html#advanced)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.3 [Identifiers](ch_syntax.html#identifiers)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.3.1 [Valid identifiers (variable names, etc.)](ch_syntax.html#valid-identifiers-variable-names-etc.)
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.3.2 [Reserved words](ch_syntax.html#reserved-words)
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.4 [Statement vs. expression](ch_syntax.html#statement-vs-expression)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.4.1 [Statements](ch_syntax.html#statements)
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.4.2 [Expressions](ch_syntax.html#expressions)
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.4.3 [What is allowed where?](ch_syntax.html#what-is-allowed-where)
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.5 [Ambiguous syntax](ch_syntax.html#ambiguous-syntax)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '7.5.1 [Same syntax: function declaration and function expression](ch_syntax.html#same-syntax-function-declaration-and-function-expression)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '7.5.2 [Same syntax: object literal and block](ch_syntax.html#same-syntax-object-literal-and-block)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.5.3 [Disambiguation](ch_syntax.html#disambiguation)
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.6 [Semicolons](ch_syntax.html#semicolons)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.6.1 [Rule of thumb for semicolons](ch_syntax.html#rule-of-thumb-for-semicolons)
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '7.6.2 [Semicolons: control statements](ch_syntax.html#semicolons-control-statements)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.7 [Automatic semicolon insertion (ASI)](ch_syntax.html#automatic-semicolon-insertion-asi)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.7.1 [ASI triggered unexpectedly](ch_syntax.html#asi-triggered-unexpectedly)
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.7.2 [ASI unexpectedly not triggered](ch_syntax.html#asi-unexpectedly-not-triggered)
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '7.8 [Semicolons: best practices](ch_syntax.html#semicolons-best-practices)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.9 [Strict mode vs. sloppy mode](ch_syntax.html#strict-mode)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.9.1 [Switching on strict mode](ch_syntax.html#switching-on-strict-mode)
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.9.2 [Improvements in strict mode](ch_syntax.html#improvements-in-strict-mode)
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 7.1 An overview of JavaScript’s syntax
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a very first look at JavaScript’s syntax. Don’t worry if some things
    don’t make sense, yet. They will all be explained in more detail later in this
    book.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: This overview is not exhaustive, either. It focuses on the essentials.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.1 Basic constructs
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 7.1.1.1 Comments
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 7.1.1.2 *Primitive* (atomic) values
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Booleans:**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Numbers:**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The basic number type is used for both floating point numbers (doubles) and
    integers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '**Bigints:**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The basic number type can only properly represent integers within a range of
    53 bits plus sign. Bigints can grow arbitrarily large in size.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '**Strings:**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: JavaScript has no extra type for characters. It uses strings to represent them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.1.3 Assertions
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An *assertion* describes what the result of a computation is expected to look
    like and throws an exception if those expectations aren’t correct. For example,
    the following assertion states that the result of the computation 7 plus 1 must
    be 8:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`assert.equal()` is a method call (the object is `assert`, the method is `.equal()`)
    with two arguments: the actual result and the expected result. It is part of a
    Node.js assertion API that is explained [later in this book](ch_assertion-api.html).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: There is also `assert.deepEqual()` that compares objects deeply.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.1.4 Logging to the console
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Logging to [the console](ch_console.html#browser-consoles) of a browser or
    Node.js:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 7.1.1.5 Operators
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'JavaScript also has a `==` comparison operator. I recommend to avoid it – why
    is explained in [§13.4.3 “Recommendation: always use strict equality”](ch_operators.html#recommendation-always-strict-equality).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.1.6 Declaring variables
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`const` creates *immutable variable bindings*: Each variable must be initialized
    immediately and we can’t assign a different value later. However, the value itself
    may be mutable and we may be able to change its contents. In other words: `const`
    does not make values immutable.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`let` creates *mutable variable bindings*:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 7.1.1.7 Ordinary function declarations
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 7.1.1.8 Arrow function expressions
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Arrow function expressions are used especially as arguments of function calls
    and method calls:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The previous code contains the following two arrow functions (the terms *expression*
    and *statement* are explained [later in this chapter](ch_syntax.html#statement-vs-expression)):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 7.1.1.9 Plain objects
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 7.1.1.10 Arrays
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 7.1.1.11 Control flow statements
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Conditional statement:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`for-of` loop:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 7.1.2 Modules
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Each module is a single file. Consider, for example, the following two files
    with modules in them:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The module in `file-tools.mjs` exports its function `isTextFilePath()`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The module in `main.mjs` imports the whole module `path` and the function `isTextFilePath()`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 7.1.3 Classes
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 7.1.4 Exception handling
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '`try-finally` and `try-catch-finally` are also supported.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can throw any value, but features such as stack traces are only supported
    by `Error` and its subclasses.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.1.5 Legal variable and property names
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The grammatical category of variable names and property names is called *identifier*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Identifiers are allowed to have the following characters:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Unicode letters: `A`–`Z`, `a`–`z` (etc.)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$`, `_`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unicode digits: `0`–`9` (etc.)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable names can’t start with a digit
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some words have special meaning in JavaScript and are called *reserved*. Examples
    include: `if`, `true`, `const`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Reserved words can’t be used as variable names:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'But they are allowed as names of properties:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 7.1.6 Casing styles
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Common casing styles for concatenating words are:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Camel case: `threeConcatenatedWords`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Underscore case (also called *snake case*): `three_concatenated_words`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dash case (also called *kebab case*): `three-concatenated-words`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.1.7 Capitalization of names
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In general, JavaScript uses camel case, except for constants.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Lowercase:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions, variables: `myFunction`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods: `obj.myMethod`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CSS:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CSS entity: `special-class`'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Corresponding JavaScript variable: `specialClass`'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Uppercase:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes: `MyClass`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Constants: `MY_CONSTANT`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Constants are also often written in camel case: `myConstant`'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.1.8 More naming conventions
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following naming conventions are popular in JavaScript.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'If the name of a parameter starts with an underscore (or is an underscore)
    it means that this parameter is not used – for example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the name of a property of an object starts with an underscore then that
    property is considered private:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 7.1.9 Where to put semicolons?
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At the end of a statement:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'But not if that statement ends with a curly brace:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'However, adding a semicolon after such a statement is not a syntax error –
    it is interpreted as an empty statement:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz: basic**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 7.2 (Advanced)
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All remaining sections of this chapter are advanced.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 7.3 Identifiers
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 7.3.1 Valid identifiers (variable names, etc.)
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First character:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Unicode letter (including accented characters such as `é` and `ü` and characters
    from non-latin alphabets, such as `α`)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subsequent characters:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Legal first characters
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unicode digits (including Eastern Arabic numerals)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some other Unicode marks and punctuations
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 7.3.2 Reserved words
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Reserved words can’t be variable names, but they can be property names.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'All JavaScript *keywords* are reserved words:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '`await` `break` `case` `catch` `class` `const` `continue` `debugger` `default`
    `delete` `do` `else` `export` `extends` `finally` `for` `function` `if` `import`
    `in` `instanceof` `let` `new` `return` `static` `super` `switch` `this` `throw`
    `try` `typeof` `var` `void` `while` `with` `yield`'
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following tokens are also keywords, but currently not used in the language:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '`enum` `implements` `package` `protected` `interface` `private` `public`'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following literals are reserved words:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '`true` `false` `null`'
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Technically, these words are not reserved, but you should avoid them, too,
    because they effectively are keywords:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '`Infinity` `NaN` `undefined` `async`'
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You shouldn’t use the names of global variables (`String`, `Math`, etc.) for
    your own variables and parameters, either.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 7.4 Statement vs. expression
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we explore how JavaScript distinguishes two kinds of syntactic
    constructs: *statements* and *expressions*. Afterward, we’ll see that that can
    cause problems because the same syntax can mean different things, depending on
    where it is used.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **We pretend there are
    only statements and expressions**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, we pretend that there are only statements and expressions
    in JavaScript.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 7.4.1 Statements
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *statement* is a piece of code that can be executed and performs some kind
    of action. For example, `if` is a statement:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'One more example of a statement: a function declaration.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 7.4.2 Expressions
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An *expression* is a piece of code that can be *evaluated* to produce a value.
    For example, the code between the parentheses is an expression:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The operator `_?_:_` used between the parentheses is called the *ternary operator*.
    It is the expression version of the `if` statement.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at more examples of expressions. We enter expressions and the REPL
    evaluates them for us:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 7.4.3 What is allowed where?
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The current location within JavaScript source code determines which kind of
    syntactic constructs you are allowed to use:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of a function must be a sequence of statements:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The arguments of a function call or a method call must be expressions:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'However, expressions can be used as statements. Then they are called *expression
    statements*. The opposite is not true: when the context requires an expression,
    you can’t use a statement.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates that any expression `bar()` can be either expression
    or statement – it depends on the context:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 7.5 Ambiguous syntax
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript has several programming constructs that are syntactically ambiguous:
    the same syntax is interpreted differently, depending on whether it is used in
    statement context or in expression context. This section explores the phenomenon
    and the pitfalls it causes.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '7.5.1 Same syntax: function declaration and function expression'
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *function declaration* is a statement:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'A *function expression* is an expression (right-hand side of `=`):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '7.5.2 Same syntax: object literal and block'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the following code, `{}` is an *object literal*: an expression that creates
    an empty object.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is an empty code block (a statement):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 7.5.3 Disambiguation
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The ambiguities are only a problem in statement context: If the JavaScript
    parser encounters ambiguous syntax, it doesn’t know if it’s a plain statement
    or an expression statement. For example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'If a statement starts with `function`: Is it a function declaration or a function
    expression?'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If a statement starts with `{`: Is it an object literal or a code block?'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To resolve the ambiguity, statements starting with `function` or `{` are never
    interpreted as expressions. If you want an expression statement to start with
    either one of these tokens, you must wrap it in parentheses:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In this code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'We first create a function via a function expression:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then we invoke that function: `(''abc'')`'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code fragment shown in (1) is only interpreted as an expression because
    we wrap it in parentheses. If we didn’t, we would get a syntax error because then
    JavaScript expects a function declaration and complains about the missing function
    name. Additionally, you can’t put a function call immediately after a function
    declaration.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Later in this book, we’ll see more examples of pitfalls caused by syntactic
    ambiguity:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[Assigning via object destructuring](ch_destructuring.html#assigning-via-object-destructuring)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Returning an object literal from an arrow function](ch_callables.html#returning-object-literal-from-arrow-function)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.6 Semicolons
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 7.6.1 Rule of thumb for semicolons
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Each statement is terminated by a semicolon:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'except statements ending with blocks:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following case is slightly tricky:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The whole `const` declaration (a statement) ends with a semicolon, but inside
    it, there is an arrow function expression. That is, it’s not the statement per
    se that ends with a curly brace; it’s the embedded arrow function expression.
    That’s why there is a semicolon at the end.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '7.6.2 Semicolons: control statements'
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The body of a control statement is itself a statement. For example, this is
    the syntax of the `while` loop:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The body can be a single statement:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'But blocks are also statements and therefore legal bodies of control statements:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you want a loop to have an empty body, your first option is an empty statement
    (which is just a semicolon):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Your second option is an empty block:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 7.7 Automatic semicolon insertion (ASI)
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While I recommend to always write semicolons, most of them are optional in JavaScript.
    The mechanism that makes this possible is called *automatic semicolon insertion*
    (ASI). In a way, it corrects syntax errors.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'ASI works as follows. Parsing of a statement continues until there is either:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: A semicolon
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line terminator followed by an illegal token
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, ASI can be seen as inserting semicolons at line breaks. The
    next subsections cover the pitfalls of ASI.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 7.7.1 ASI triggered unexpectedly
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The good news about ASI is that – if you don’t rely on it and always write semicolons
    – there is only one pitfall that you need to be aware of. It is that JavaScript
    forbids line breaks after some tokens. If you do insert a line break, a semicolon
    will be inserted, too.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'The token where this is most practically relevant is `return`. Consider, for
    example, the following code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This code is parsed as:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'That is:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Return statement without operand: `return;`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start of code block: `{`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expression statement `'jane';` with [label](ch_control-flow.html#labels) `first:`
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'End of code block: `}`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Empty statement: `;`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why does JavaScript do this? It protects against accidentally returning a value
    in a line after a `return`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 7.7.2 ASI unexpectedly not triggered
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In some cases, ASI is *not* triggered when you think it should be. That makes
    life more complicated for people who don’t like semicolons because they need to
    be aware of those cases. The following are three examples. There are more.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 1:** Unintended function call.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Parsed as:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**Example 2:** Unintended division.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Parsed as:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '**Example 3:** Unintended property access.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Executed as:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '7.8 Semicolons: best practices'
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I recommend that you always write semicolons:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: I like the visual structure it gives code – you clearly see where a statement
    ends.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are less rules to keep in mind.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The majority of JavaScript programmers use semicolons.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, there are also many people who don’t like the added visual clutter
    of semicolons. If you are one of them: Code without them *is* legal. I recommend
    that you use tools to help you avoid mistakes. The following are two examples:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: The automatic code formatter [Prettier](https://prettier.io) can be configured
    to not use semicolons. It then automatically fixes problems. For example, if it
    encounters a line that starts with a square bracket, it prefixes that line with
    a semicolon.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The static checker [ESLint](https://eslint.org) has [a rule](https://eslint.org/docs/rules/semi)
    that you tell your preferred style (always semicolons or as few semicolons as
    possible) and that warns you about critical issues.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.9 Strict mode vs. sloppy mode
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Starting with ECMAScript 5, JavaScript has two *modes* in which JavaScript
    can be executed:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Normal “sloppy” mode is the default in scripts (code fragments that are a precursor
    to modules and supported by browsers).
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strict mode is the default in modules and classes, and can be switched on in
    scripts (how is explained later). In this mode, several pitfalls of normal mode
    are removed and more exceptions are thrown.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格模式是模块和类的默认模式，并且可以在脚本中打开（稍后会解释）。在此模式下，消除了普通模式的几个陷阱，并且会抛出更多的异常。
- en: You’ll rarely encounter sloppy mode in modern JavaScript code, which is almost
    always located in modules. In this book, I assume that strict mode is always switched
    on.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代JavaScript代码中，您很少会遇到懈怠模式，它几乎总是位于模块中。在本书中，我假设严格模式总是打开的。
- en: 7.9.1 Switching on strict mode
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.9.1 打开严格模式
- en: 'In script files and CommonJS modules, you switch on strict mode for a complete
    file, by putting the following code in the first line:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本文件和CommonJS模块中，您可以通过在第一行放置以下代码来为整个文件切换到严格模式：
- en: '[PRE59]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The neat thing about this “directive” is that ECMAScript versions before 5
    simply ignore it: it’s an expression statement that does nothing.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个“指令”的好处是，ECMAScript 5之前的版本简单地忽略它：它是一个什么都不做的表达式语句。
- en: 'You can also switch on strict mode for just a single function:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以仅为单个函数切换到严格模式：
- en: '[PRE60]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 7.9.2 Improvements in strict mode
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.9.2 严格模式的改进
- en: Let’s look at three things that strict mode does better than sloppy mode. Just
    in this one section, all code fragments are executed in sloppy mode.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看严格模式比懈怠模式做得更好的三件事。在这一部分中，所有代码片段都在懈怠模式下执行。
- en: '7.9.2.1 Sloppy mode pitfall: changing an undeclared variable creates a global
    variable'
  id: totrans-293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.9.2.1 懈怠模式陷阱：更改未声明的变量会创建全局变量
- en: In non-strict mode, changing an undeclared variable creates a global variable.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在非严格模式下，更改未声明的变量会创建一个全局变量。
- en: '[PRE61]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Strict mode does it better and throws a `ReferenceError`. That makes it easier
    to detect typos.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式做得更好，并抛出`ReferenceError`。这样更容易检测拼写错误。
- en: '[PRE62]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `assert.throws()` states that its first argument, a function, throws a `ReferenceError`
    when it is called.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert.throws()`声明其第一个参数，一个函数，在调用时会抛出`ReferenceError`。'
- en: 7.9.2.2 Function declarations are block-scoped in strict mode, function-scoped
    in sloppy mode
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.9.2.2 在严格模式下，函数声明是块作用域的，在懈怠模式下是函数作用域的
- en: 'In strict mode, a variable created via a function declaration only exists within
    the innermost enclosing block:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，通过函数声明创建的变量仅存在于最内层的封闭块中：
- en: '[PRE63]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In sloppy mode, function declarations are function-scoped:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在懈怠模式下，函数声明是函数作用域的：
- en: '[PRE64]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 7.9.2.3 Sloppy mode doesn’t throw exceptions when changing immutable data
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.9.2.3 懈怠模式在更改不可变数据时不会抛出异常
- en: 'In strict mode, you get an exception if you try to change immutable data:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，如果尝试更改不可变数据，会得到一个异常：
- en: '[PRE65]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In sloppy mode, the assignment fails silently:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在懈怠模式下，赋值会悄无声息地失败：
- en: '[PRE66]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '![](../Images/aec4653f22c8cf0e517ff5024759dfe1.png)  **Further reading: sloppy
    mode**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/aec4653f22c8cf0e517ff5024759dfe1.png) **进一步阅读：懈怠模式**'
- en: For more information on how sloppy mode differs from strict mode, see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 有关懈怠模式与严格模式之间的区别的更多信息，请参见[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)。
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz: advanced**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png) **测验：高级**'
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[测验应用程序](ch_quizzes-exercises.html#quizzes)。
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/5)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[评论](https://github.com/rauschma/impatient-js/issues/5)'
