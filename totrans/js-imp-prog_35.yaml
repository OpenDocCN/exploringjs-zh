- en: 29 Classes [ES6]
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 29 [ES6中的类]
- en: 原文：[https://exploringjs.com/impatient-js/ch_classes.html](https://exploringjs.com/impatient-js/ch_classes.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/impatient-js/ch_classes.html](https://exploringjs.com/impatient-js/ch_classes.html)
- en: '* * *'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '29.1 [Cheat sheet: classes](ch_classes.html#cheat-sheet-classes)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.1 [速查表：类](ch_classes.html#cheat-sheet-classes)
- en: 29.2 [The essentials of classes](ch_classes.html#classes)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.2 [类的基本要点](ch_classes.html#classes)
- en: 29.2.1 [A class for persons](ch_classes.html#a-class-for-persons)
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.2.1 [一个人的类](ch_classes.html#a-class-for-persons)
- en: 29.2.2 [Class expressions](ch_classes.html#class-expressions)
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.2.2 [类表达式](ch_classes.html#class-expressions)
- en: 29.2.3 [The `instanceof` operator](ch_classes.html#the-instanceof-operator)
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.2.3 [instanceof运算符](ch_classes.html#the-instanceof-operator)
- en: 29.2.4 [Public slots (properties) vs. private slots](ch_classes.html#private-slots)
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.2.4 [公共槽（属性）vs. 私有槽](ch_classes.html#private-slots)
- en: 29.2.5 [Private slots in more detail [ES2022] (advanced)](ch_classes.html#private-slots-in-more-detail-es2022-advanced)
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.2.5 [更详细的私有槽[ES2022]（高级）](ch_classes.html#private-slots-in-more-detail-es2022-advanced)
- en: 29.2.6 [The pros and cons of classes in JavaScript](ch_classes.html#the-pros-and-cons-of-classes-in-javascript)
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.2.6 [JavaScript中类的优缺点](ch_classes.html#the-pros-and-cons-of-classes-in-javascript)
- en: 29.2.7 [Tips for using classes](ch_classes.html#tips-for-using-classes)
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.2.7 [使用类的技巧](ch_classes.html#tips-for-using-classes)
- en: 29.3 [The internals of classes](ch_classes.html#internals-of-classes)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.3 [类的内部](ch_classes.html#internals-of-classes)
- en: 29.3.1 [A class is actually two connected objects](ch_classes.html#a-class-is-actually-two-connected-objects)
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.3.1 [类实际上是两个连接的对象](ch_classes.html#a-class-is-actually-two-connected-objects)
- en: 29.3.2 [Classes set up the prototype chains of their instances](ch_classes.html#classes-set-up-the-prototype-chains-of-their-instances)
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.3.2 [类设置其实例的原型链](ch_classes.html#classes-set-up-the-prototype-chains-of-their-instances)
- en: 29.3.3 [`.__proto__` vs. `.prototype`](ch_classes.html#proto__-vs.-.prototype)
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.3.3 [`.__proto__` vs. `.prototype`](ch_classes.html#proto__-vs.-.prototype)
- en: 29.3.4 [`Person.prototype.constructor` (advanced)](ch_classes.html#person.prototype.constructor-advanced)
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.3.4 [`Person.prototype.constructor`（高级）](ch_classes.html#person.prototype.constructor-advanced)
- en: 29.3.5 [Dispatched vs. direct method calls (advanced)](ch_classes.html#method-calls-dispatched-direct)
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.3.5 [分派vs. 直接方法调用（高级）](ch_classes.html#method-calls-dispatched-direct)
- en: 29.3.6 [Classes evolved from ordinary functions (advanced)](ch_classes.html#classes-evolved-from-ordinary-functions-advanced)
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.3.6 [类从普通函数演变而来（高级）](ch_classes.html#classes-evolved-from-ordinary-functions-advanced)
- en: 29.4 [Prototype members of classes](ch_classes.html#prototype-members-of-classes)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.4 [类的原型成员](ch_classes.html#prototype-members-of-classes)
- en: 29.4.1 [Public prototype methods and accessors](ch_classes.html#public-prototype-methods-and-accessors)
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.4.1 [公共原型方法和访问器](ch_classes.html#public-prototype-methods-and-accessors)
- en: 29.4.2 [Private methods and accessors [ES2022]](ch_classes.html#private-methods-accessors)
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.4.2 [私有方法和访问器[ES2022]](ch_classes.html#private-methods-accessors)
- en: 29.5 [Instance members of classes [ES2022]](ch_classes.html#instance-members-of-classes-es2022)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.5 [类的实例成员[ES2022]](ch_classes.html#instance-members-of-classes-es2022)
- en: 29.5.1 [Instance public fields](ch_classes.html#instance-public-fields)
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.5.1 [实例公共字段](ch_classes.html#instance-public-fields)
- en: 29.5.2 [Instance private fields](ch_classes.html#instance-private-fields)
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.5.2 [实例私有字段](ch_classes.html#instance-private-fields)
- en: 29.5.3 [Private instance data before ES2022 (advanced)](ch_classes.html#private-instance-data-before-es2022-advanced)
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.5.3 [ES2022之前的实例私有数据（高级）](ch_classes.html#private-instance-data-before-es2022-advanced)
- en: 29.5.4 [Simulating protected visibility and friend visibility via WeakMaps (advanced)](ch_classes.html#instance-protected-fields)
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.5.4 [通过WeakMaps模拟受保护的可见性和友元可见性（高级）](ch_classes.html#instance-protected-fields)
- en: 29.6 [Static members of classes](ch_classes.html#static-members-of-classes)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.6 [类的静态成员](ch_classes.html#static-members-of-classes)
- en: 29.6.1 [Static public methods and accessors](ch_classes.html#static-public-methods-and-accessors)
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.6.1 [静态公共方法和访问器](ch_classes.html#static-public-methods-and-accessors)
- en: 29.6.2 [Static public fields [ES2022]](ch_classes.html#static-public-fields)
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.6.2 [ES2022中的静态公共字段](ch_classes.html#static-public-fields)
- en: 29.6.3 [Static private methods, accessors, and fields [ES2022]](ch_classes.html#static-private-methods-accessors-fields)
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.6.3 [ES2022中的静态私有方法、访问器和字段](ch_classes.html#static-private-methods-accessors-fields)
- en: 29.6.4 [Static initialization blocks in classes [ES2022]](ch_classes.html#class-static-initialization-blocks)
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.6.4 [类中的静态初始化块[ES2022]](ch_classes.html#class-static-initialization-blocks)
- en: '29.6.5 [Pitfall: Using `this` to access static private fields](ch_classes.html#this-and-static-private-fields)'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.6.5 [陷阱：使用`this`访问静态私有字段](ch_classes.html#this-and-static-private-fields)
- en: 29.6.6 [All members (static, prototype, instance) can access all private members](ch_classes.html#all-members-static-prototype-instance-can-access-all-private-members)
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.6.6 [所有成员（静态的、原型的、实例的）都可以访问所有私有成员](ch_classes.html#all-members-static-prototype-instance-can-access-all-private-members)
- en: 29.6.7 [Static private methods and data before ES2022](ch_classes.html#static-private-methods-and-data-before-es2022)
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.6.7 [ES2022之前的静态私有方法和数据](ch_classes.html#static-private-methods-and-data-before-es2022)
- en: 29.6.8 [Static factory methods](ch_classes.html#static-factory-methods)
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.6.8 [静态工厂方法](ch_classes.html#static-factory-methods)
- en: 29.7 [Subclassing](ch_classes.html#subclassing)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.7 [子类化](ch_classes.html#subclassing)
- en: 29.7.1 [The internals of subclassing (advanced)](ch_classes.html#the-internals-of-subclassing-advanced)
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.7.1 [子类化的内部（高级）](ch_classes.html#the-internals-of-subclassing-advanced)
- en: 29.7.2 [`instanceof` and subclassing (advanced)](ch_classes.html#instanceof-operator)
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.7.2 [`instanceof`和子类化（高级）](ch_classes.html#instanceof-operator)
- en: 29.7.3 [Not all objects are instances of `Object` (advanced)](ch_classes.html#non-instances-of-object)
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.7.3 [并非所有对象都是`Object`的实例（高级）](ch_classes.html#non-instances-of-object)
- en: 29.7.4 [Prototype chains of built-in objects (advanced)](ch_classes.html#prototype-chains-of-built-ins)
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.7.4 [内置对象的原型链（高级）](ch_classes.html#prototype-chains-of-built-ins)
- en: 29.7.5 [Mixin classes (advanced)](ch_classes.html#mixin-classes-advanced)
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.7.5 [混入类（高级）](ch_classes.html#mixin-classes-advanced)
- en: 29.8 [The methods and accessors of `Object.prototype` (advanced)](ch_classes.html#Object.prototype-methods)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.8 [`Object.prototype`的方法和访问器（高级）](ch_classes.html#Object.prototype-methods)
- en: 29.8.1 [Using `Object.prototype` methods safely](ch_classes.html#using-object-methods-safely)
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.8.1 [安全使用 `Object.prototype` 方法](ch_classes.html#using-object-methods-safely)
- en: 29.8.2 [`Object.prototype.toString()`](ch_classes.html#Object.prototype.toString)
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.8.2 [`Object.prototype.toString()`](ch_classes.html#Object.prototype.toString)
- en: 29.8.3 [`Object.prototype.toLocaleString()`](ch_classes.html#Object.prototype.toLocaleString)
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.8.3 [`Object.prototype.toLocaleString()`](ch_classes.html#Object.prototype.toLocaleString)
- en: 29.8.4 [`Object.prototype.valueOf()`](ch_classes.html#Object.prototype.valueOf)
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.8.4 [`Object.prototype.valueOf()`](ch_classes.html#Object.prototype.valueOf)
- en: 29.8.5 [`Object.prototype.isPrototypeOf()`](ch_classes.html#Object.prototype.isPrototypeOf)
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.8.5 [`Object.prototype.isPrototypeOf()`](ch_classes.html#Object.prototype.isPrototypeOf)
- en: 29.8.6 [`Object.prototype.propertyIsEnumerable()`](ch_classes.html#Object.prototype.propertyIsEnumerable)
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.8.6 [`Object.prototype.propertyIsEnumerable()`](ch_classes.html#Object.prototype.propertyIsEnumerable)
- en: 29.8.7 [`Object.prototype.__proto__` (accessor)](ch_classes.html#Object.prototype.__proto__)
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.8.7 [`Object.prototype.__proto__`（访问器）](ch_classes.html#Object.prototype.__proto__)
- en: 29.8.8 [`Object.prototype.hasOwnProperty()`](ch_classes.html#Object.prototype.hasOwnProperty)
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.8.8 [`Object.prototype.hasOwnProperty()`](ch_classes.html#Object.prototype.hasOwnProperty)
- en: '29.9 [FAQ: classes](ch_classes.html#faq-classes)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.9 [常见问题：类](ch_classes.html#faq-classes)
- en: 29.9.1 [Why are they called “instance private fields” in this book and not “private
    instance fields”?](ch_classes.html#why-are-they-called-instance-private-fields-in-this-book-and-not-private-instance-fields)
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.9.1 为什么本书中称其为“实例私有字段”，而不是“私有实例字段”？](ch_classes.html#why-are-they-called-instance-private-fields-in-this-book-and-not-private-instance-fields)
- en: 29.9.2 [Why the identifier prefix `#`? Why not declare private fields via `private`?](ch_classes.html#why-the-identifier-prefix-why-not-declare-private-fields-via-private)
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29.9.2 为什么标识符前缀是 `#`？为什么不通过 `private` 声明私有字段？](ch_classes.html#why-the-identifier-prefix-why-not-declare-private-fields-via-private)
- en: '* * *'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'In this book, JavaScript’s style of object-oriented programming (OOP) is introduced
    in four steps. This chapter covers step 3 and 4, [the previous chapter](ch_objects.html)
    covers step 1 and 2\. The steps are (fig. [12](#fig:oop_steps_3_4)):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，JavaScript的面向对象编程（OOP）分为四个步骤介绍。本章涵盖了第3步和第4步，[上一章](ch_objects.html)涵盖了第1步和第2步。这些步骤如下（图12）：
- en: '**Single objects (previous chapter):** How do *objects*, JavaScript’s basic
    OOP building blocks, work in isolation?'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单个对象（上一章）：** JavaScript的基本OOP构建块 *对象* 在孤立状态下是如何工作的？'
- en: '**Prototype chains (previous chapter):** Each object has a chain of zero or
    more *prototype objects*. Prototypes are JavaScript’s core inheritance mechanism.'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**原型链（上一章）：** 每个对象都有零个或多个 *原型对象* 的链。原型是JavaScript的核心继承机制。'
- en: '**Classes (this chapter):** JavaScript’s *classes* are factories for objects.
    The relationship between a class and its instances is based on prototypal inheritance
    (step 2).'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**类（本章）：** JavaScript的 *类* 是对象的工厂。类与其实例之间的关系基于原型继承（第2步）。'
- en: '**Subclassing (this chapter):** The relationship between a *subclass* and its
    *superclass* is also based on prototypal inheritance.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**子类化（本章）：** *子类* 与 *超类* 之间的关系也是基于原型继承的。'
- en: '![Figure 12: This book introduces object-oriented programming in JavaScript
    in four steps.](../Images/1cbbf21bc1415ec3aaec2ea35fe128e8.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图12：本书以四个步骤介绍JavaScript中的面向对象编程。](../Images/1cbbf21bc1415ec3aaec2ea35fe128e8.png)'
- en: 'Figure 12: This book introduces object-oriented programming in JavaScript in
    four steps.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图12：本书以四个步骤介绍JavaScript中的面向对象编程。
- en: '29.1 Cheat sheet: classes'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.1 备忘单：类
- en: 'Superclass:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 超类：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Subclass:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 子类：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notes:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: '`.#firstName` is a *private field* and must be declared (line A) before it
    can be initialized (line B).'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.#firstName` 是一个 *私有字段*，必须在初始化之前（行B）进行声明（行A）。'
- en: A private field can only be accessed inside its surrounding class. It can’t
    even be accessed by subclasses.
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有字段只能在其所在的类内部访问。甚至子类也无法访问它。
- en: '`.title` is a property and can be initialized without a prior declaration (line
    C). JavaScript relatively often makes instance data public (in contrast to, e.g.,
    Java that prefers to hide it).'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.title` 是一个属性，可以在没有先前声明的情况下进行初始化（行C）。JavaScript相对经常地将实例数据公开（与例如Java相反，后者更喜欢隐藏它）。'
- en: 29.2 The essentials of classes
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.2 课程的要点
- en: Classes are basically a compact syntax for setting up prototype chains (which
    are explained in [the previous chapter](ch_objects.html#prototype-chains)). Under
    the hood, JavaScript’s classes are unconventional. But that is something we rarely
    see when working with them. They should normally feel familiar to people who have
    used other object-oriented programming languages.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 类基本上是一种紧凑的语法，用于设置原型链（在[上一章](ch_objects.html#prototype-chains)中有解释）。在底层，JavaScript的类是非常规的。但是当我们使用它们时，我们很少看到这一点。它们通常应该对已经使用过其他面向对象编程语言的人来说是熟悉的。
- en: Note that we don’t need classes to create objects. We can also do so via [object
    literals](ch_objects.html#object-literals). That’s why the singleton pattern isn’t
    needed in JavaScript and classes are used less than in many other languages that
    have them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不需要类来创建对象。我们也可以通过[对象字面量](ch_objects.html#object-literals)来创建对象。这就是为什么JavaScript不需要单例模式，而类的使用比许多其他具有类的语言中少。
- en: 29.2.1 A class for persons
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.2.1 人的类
- en: '[We have previously worked with `jane` and `tarzan`, single objects representing
    persons](ch_objects.html#sharing-data-via-prototypes). Let’s use a *class declaration*
    to implement a factory for such objects:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[我们之前使用了 `jane` 和 `tarzan`，它们是代表人的单个对象](ch_objects.html#sharing-data-via-prototypes)。让我们使用
    *类声明* 来实现这样的对象的工厂：'
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`jane` and `tarzan` can now be created via `new Person()`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以通过 `new Person()` 创建 `jane` 和 `tarzan`：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let’s examine what’s inside the body of class `Person`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`Person`类的内部是什么。
- en: '`.constructor()` is a special method that is called after the creation of a
    new instance. Inside it, `this` refers to that instance.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.constructor()` 是一个特殊的方法，在创建新实例之后调用。在其中，`this` 指的是该实例。'
- en: '[ES2022] `.#firstName` is an *instance private field*: Such fields are stored
    in instances. They are accessed similarly to properties, but their names are separate
    – they always start with hash symbols (`#`). And they are invisible to the world
    outside the class:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES2022] `.#firstName`是一个*实例私有字段*：这样的字段存储在实例中。它们的访问方式类似于属性，但它们的名称是分开的-它们总是以井号符号（`#`）开头。并且它们对类外部是不可见的：'
- en: '[PRE4]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Before we can initialize `.#firstName` in the constructor (line B), we need
    to declare it by mentioning it in the class body (line A).
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们可以在构造函数中初始化`.#firstName`（B行）之前，我们需要在类主体中提到它来声明它（A行）。
- en: '`.describe()` is a method. If we invoke it via `obj.describe()` then `this`
    refers to `obj` inside the body of `.describe()`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.describe()`是一个方法。如果我们通过`obj.describe()`调用它，那么`this`在`.describe()`的主体内指的是`obj`。'
- en: '[PRE5]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`.extractName()` is a *static* method. “Static” means that it belongs to the
    class, not to instances:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.extractName()`是一个*静态*方法。“静态”意味着它属于类，而不属于实例：'
- en: '[PRE6]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also create instance properties (public fields) in constructors:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在构造函数中创建实例属性（公共字段）：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In contrast to instance private fields, instance properties don’t have to be
    declared in class bodies.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与实例私有字段相反，实例属性不必在类主体中声明。
- en: 29.2.2 Class expressions
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.2.2 类表达式
- en: 'There are two kinds of *class definitions* (ways of defining classes):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种*类定义*（定义类的方式）：
- en: '*Class declarations*, which we have seen in the previous section.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类声明*，我们在上一节中看到的。'
- en: '*Class expressions*, which we’ll see next.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类表达式*，我们将在下面看到。'
- en: 'Class expressions can be anonymous and named:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 类表达式可以是匿名的也可以是命名的：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The name of a named class expression works similarly to [the name of a named
    function expression](ch_callables.html#named-function-expressions): It can only
    be accessed inside the body of a class and stays the same, regardless of what
    the class is assigned to.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 命名类表达式的名称类似于[命名函数表达式的名称](ch_callables.html#named-function-expressions)：它只能在类主体内部访问，并且保持不变，无论该类分配给什么。
- en: 29.2.3 The `instanceof` operator
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.2.3 `instanceof`运算符
- en: 'The `instanceof` operator tells us if a value is an instance of a given class:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof`运算符告诉我们一个值是否是给定类的实例：'
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We’ll explore the `instanceof` operator in more detail [later](ch_classes.html#instanceof-operator),
    after we have looked at subclassing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在之后更详细地探讨`instanceof`运算符（在我们看完子类化之后）。
- en: 29.2.4 Public slots (properties) vs. private slots
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.2.4 公共槽（属性）vs. 私有槽
- en: In the JavaScript language, objects can have two kinds of “slots”.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript语言中，对象可以有两种“槽”。
- en: '*Public slots* (which are are also called *properties*). For example, methods
    are public slots.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*公共槽*（也称为*属性*）。例如，方法是公共槽。'
- en: '*Private slots* [ES2022]. For example, private fields are private slots.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*私有槽*[ES2022]。例如，私有字段是私有槽。'
- en: 'These are the most important rules we need to know about properties and private
    slots:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们需要了解有关属性和私有槽的最重要规则：
- en: In classes, we can use public and private versions of fields, methods, getters
    and setters. All of them are slots in objects. Which objects they are placed in
    depends on whether the keyword `static` is used and other factors.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类中，我们可以使用字段、方法、getter和setter的公共和私有版本。它们都是对象中的槽。它们放置在哪些对象取决于是否使用关键字`static`和其他因素。
- en: A getter and a setter that have the same key create a single *accessor* slot.
    An Accessor can also have only a getter or only a setter.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有相同键的getter和setter创建一个单一的*访问器*槽。访问器也可以只有getter或只有setter。
- en: 'Properties and private slots are very different – for example:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性和私有槽非常不同-例如：
- en: They are stored separately.
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们被分开存储。
- en: Their keys are different. The keys of private slots can’t even be accessed directly
    (see [§29.2.5.2 “Each private slot has a unique key (a *private name*)”](ch_classes.html#private-names)
    later in this chapter).
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的键是不同的。私有槽的键甚至不能直接访问（参见本章后面的[§29.2.5.2“每个私有槽都有一个唯一的键（*私有名称*）”](ch_classes.html#private-names)）。
- en: Properties are inherited from prototypes, private slots aren’t.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性是从原型继承的，私有槽不是。
- en: Private slots can only be created via classes.
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有槽只能通过类创建。
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **More information on
    properties and private slots**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](../Images/b666ba365e94edaf0ef510fd7e12c7de.png) **有关属性和私有槽的更多信息**
- en: 'This chapter doesn’t cover all details of properties and private slots (just
    the essentials). If you want to dig deeper, you can do so here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不涵盖所有属性和私有槽的细节（只涵盖基本内容）。如果您想深入了解，可以在这里进行。
- en: '[§28.8.1 “Property attributes and property descriptors [ES5]”](ch_objects.html#property-attributes-property-descriptors)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[§28.8.1“属性属性和属性描述符[ES5]”](ch_objects.html#property-attributes-property-descriptors)'
- en: Section [“Object Internal Methods and Internal Slots”](https://tc39.es/ecma262/#sec-object-internal-methods-and-internal-slots)
    in the ECMAScript language specification explains how private slots work. Search
    for “`[[PrivateElements]]`”.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript语言规范中的“对象内部方法和内部槽”一节解释了私有槽的工作原理。搜索“`[[PrivateElements]]`”。
- en: 'The following class demonstrates the two kinds of slots. Each of its instances
    has one private field and one property:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类演示了两种槽。它的每个实例都有一个私有字段和一个属性：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As expected, outside `MyClass`, we can only see the property:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，在`MyClass`之外，我们只能看到属性：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next, we’ll look at some of the details of private slots.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一些私有槽的细节。
- en: 29.2.5 Private slots in more detail [ES2022] (advanced)
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.2.5 更详细的私有槽[ES2022]（高级）
- en: 29.2.5.1 Private slots can’t be accessed in subclasses
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.2.5.1 私有槽不能在子类中访问
- en: 'A private slot really can only be accessed inside the body of its class. We
    can’t even access it from a subclass:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 私有槽确实只能在其类的主体内部访问。我们甚至不能从子类访问它：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[Subclassing via `extends`](ch_classes.html#subclassing) is explained later
    in this chapter. How to work around this limitation is explained in [§29.5.4 “Simulating
    protected visibility and friend visibility via WeakMaps”](ch_classes.html#instance-protected-fields).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[通过`extends`进行子类化](ch_classes.html#subclassing)在本章后面有解释。如何解决这个限制在[§29.5.4 “通过WeakMaps模拟受保护的可见性和友元可见性”](ch_classes.html#instance-protected-fields)中有解释。'
- en: 29.2.5.2 Each private slot has a unique key (a *private name*)
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.2.5.2 每个私有槽都有一个唯一的键（*私有名称*）
- en: 'Private slots have unique keys that are similar to [symbols](ch_symbols.html).
    Consider the following class from earlier:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 私有槽具有类似于[symbols](ch_symbols.html)的唯一键。考虑之前的以下类：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Internally, the private field of `MyClass` is handled roughly like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`MyClass`的私有字段大致处理如下：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The value of `instancePrivateFieldKey` is called a *private name*. We can’t
    use private names directly in JavaScript, we can only use them indirectly, via
    the fixed identifiers of private fields, private methods, and private accessors.
    Where the fixed identifiers of public slots (such as `getInstanceValues`) are
    interpreted as string keys, the fixed identifiers of private slots (such as `#instancePrivateField`)
    refer to private names (similarly to how variable names refer to values).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`instancePrivateFieldKey`的值称为*私有名称*。我们不能直接在JavaScript中使用私有名称，我们只能间接使用它们，通过私有字段、私有方法和私有访问器的固定标识符。公共槽的固定标识符（如`getInstanceValues`）被解释为字符串键，私有槽的固定标识符（如`#instancePrivateField`）引用私有名称（类似于变量名称引用值）。'
- en: 29.2.5.3 The same private identifier refers to different private names in different
    classes
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.2.5.3 相同的私有标识符在不同类中引用不同的私有名称
- en: 'Because the identifiers of private slots aren’t used as keys, using the same
    identifier in different classes produces different slots (line A and line C):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因为私有槽的标识符不被用作键，所以在不同类中使用相同的标识符会产生不同的槽（A行和C行）：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 29.2.5.4 The names of private fields never clash
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.2.5.4 私有字段的名称永远不会冲突
- en: 'Even if a subclass uses the same name for a private field, the two names never
    clash because they refer to private names (which are always unique). In the following
    example, `.#privateField` in `SuperClass` does not clash with `.#privateField`
    in `SubClass`, even though both slots are stored directly in `inst`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 即使子类使用相同的名称作为私有字段，这两个名称也永远不会冲突，因为它们引用私有名称（始终是唯一的）。在下面的示例中，`SuperClass`中的`.#privateField`与`SubClass`中的`.#privateField`不冲突，即使两个槽都直接存储在`inst`中：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Subclassing via `extends`](ch_classes.html#subclassing) is explained later
    in this chapter.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[通过`extends`进行子类化](ch_classes.html#subclassing)在本章后面有解释。'
- en: 29.2.5.5 Using `in` to check if an object has a given private slot
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.2.5.5 使用`in`来检查对象是否具有给定的私有槽
- en: 'The `in` operator can be used to check if a private slot exists (line A):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`运算符可用于检查私有槽是否存在（A行）：'
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let’s look at more examples of `in` applied to private slots.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`in`应用于私有槽的更多示例。
- en: '**Private methods.** The following code shows that private methods create private
    slots in instances:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**私有方法。**以下代码显示私有方法在实例中创建私有槽：'
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Static private fields.** We can also use `in` for a static private field:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态私有字段。**我们也可以使用`in`来检查静态私有字段：'
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Static private methods.** And we can check for the slot of a static private
    method:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态私有方法。**我们也可以检查静态私有方法的槽：'
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Using the same private identifier in different classes.** In the next example,
    the two classes `Color` and `Person` both have a slot whose identifier is `#name`.
    The `in` operator distinguishes them correctly:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**在不同类中使用相同的私有标识符。**在下一个示例中，两个类`Color`和`Person`都有一个标识符为`#name`的槽。`in`运算符可以正确区分它们：'
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 29.2.6 The pros and cons of classes in JavaScript
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.2.6 类在JavaScript中的优缺点
- en: 'I recommend using classes for the following reasons:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用类的原因如下：
- en: Classes are a common standard for object creation and inheritance that is now
    widely supported across libraries and frameworks. This is an improvement compared
    to how things were before, when almost every framework had its own inheritance
    library.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类是对象创建和继承的常见标准，现在在许多库和框架中得到了广泛支持。与以前几乎每个框架都有自己的继承库相比，这是一个改进。
- en: They help tools such as IDEs and type checkers with their work and enable new
    features there.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有助于IDE和类型检查器的工作，并在那里启用新功能。
- en: If you come from another language to JavaScript and are used to classes, then
    you can get started more quickly.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您来自另一种语言到JavaScript，并且习惯于类，那么您可以更快地开始。
- en: JavaScript engines optimize them. That is, code that uses classes is almost
    always faster than code that uses a custom inheritance library.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript引擎对它们进行了优化。也就是说，使用类的代码几乎总是比使用自定义继承库的代码更快。
- en: We can subclass built-in constructor functions such as `Error`.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以对内置构造函数进行子类化，如`Error`。
- en: 'That doesn’t mean that classes are perfect:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着类是完美的：
- en: There is a risk of overdoing inheritance.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在过度继承的风险。
- en: There is a risk of putting too much functionality in classes (when some of it
    is often better put in functions).
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类中放入过多功能存在风险（其中一些功能通常最好放在函数中）。
- en: Classes look familiar to programmers coming from other languages, but they work
    differently and are used differently (see next subsection). Therefore, there is
    a risk of those programmers writing code that doesn’t feel like JavaScript.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类看起来对于来自其他语言的程序员来说很熟悉，但它们的工作方式和使用方式不同（见下一小节）。因此，存在这样的风险，即这些程序员编写的代码感觉不像JavaScript。
- en: 'How classes seem to work superficially is quite different from how they actually
    work. In other words, there is a disconnect between syntax and semantics. Two
    examples are:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类在表面上的工作方式与实际工作方式非常不同。换句话说，语法和语义之间存在断裂。两个例子是：
- en: A method definition inside a class `C` creates a method in the object `C.prototype`.
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类`C`内部的方法定义会在对象`C.prototype`中创建一个方法。
- en: Classes are functions.
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类是函数。
- en: The motivation for the disconnect is backward compatibility. Thankfully, the
    disconnect causes few problems in practice; we are usually OK if we go along with
    what classes pretend to be.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 断开连接的动机是向后兼容性。幸运的是，这种断开在实践中几乎没有问题；如果我们按照类所假装的那样做，通常都没问题。
- en: This was a first look at classes. We’ll explore more features soon.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对类的第一次看法。我们很快会探索更多功能。
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Writing a
    class**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png) **练习：编写一个类**'
- en: '`exercises/classes/point_class_test.mjs`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/classes/point_class_test.mjs`'
- en: 29.2.7 Tips for using classes
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.2.7 使用类的提示
- en: Use inheritance sparingly – it tends to make code more complicated and spread
    out related functionality across multiple locations.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谨慎使用继承 - 它往往会使代码变得更加复杂，并将相关功能分散到多个位置。
- en: 'Instead of static members, it is often better to use external functions and
    variables. We can even make those private to a module, simply by not exporting
    them. Two important exceptions to this rule are:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常最好使用外部函数和变量而不是静态成员。我们甚至可以通过不导出它们来将它们私有化到一个模块中。这个规则的两个重要例外是：
- en: Operations that need access to private slots
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要访问私有插槽的操作
- en: '[Static factory methods](ch_classes.html#static-factory-methods)'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[静态工厂方法](ch_classes.html#static-factory-methods)'
- en: Only put core functionality in prototype methods. Other functionality is better
    implemented via functions – especially algorithms that involve instances of multiple
    classes.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只将核心功能放在原型方法中。其他功能最好通过函数实现 - 尤其是涉及多个类的实例的算法。
- en: 29.3 The internals of classes
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.3 类的内部
- en: 29.3.1 A class is actually two connected objects
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.3.1 类实际上是两个连接的对象
- en: 'Under the hood, a class becomes two connected objects. Let’s revisit class
    `Person` to see how that works:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，一个类变成了两个连接的对象。让我们重新审视类`Person`，看看它是如何工作的：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The first object created by the class is stored in `Person`. It has four properties:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 类创建的第一个对象存储在`Person`中。它有四个属性：
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The two remaining properties are:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的两个属性是：
- en: '`Person.extractNames` is the static method that we have already seen in action.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Person.extractNames`是我们已经看到在操作中的静态方法。'
- en: '`Person.prototype` points to the second object that is created by a class definition.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Person.prototype`指向由类定义创建的第二个对象。'
- en: 'These are the contents of `Person.prototype`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Person.prototype`的内容：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There are two properties:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个属性：
- en: '`Person.prototype.constructor` points to the constructor.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Person.prototype.constructor`指向构造函数。'
- en: '`Person.prototype.describe` is the method that we have already used.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Person.prototype.describe`是我们已经使用过的方法。'
- en: 29.3.2 Classes set up the prototype chains of their instances
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.3.2 类设置其实例的原型链
- en: 'The object `Person.prototype` is the prototype of all instances:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对象`Person.prototype`是所有实例的原型：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'That explains how the instances get their methods: They inherit them from the
    object `Person.prototype`.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了实例如何获得它们的方法：它们从对象`Person.prototype`继承。
- en: Fig. [13](#fig:oo_person_class) visualizes how everything is connected.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图13可视化了一切是如何连接的。
- en: '![Figure 13: The class Person has the property .prototype that points to an
    object that is the prototype of all instances of Person. The objects jane and
    tarzan are two such instances.](../Images/c08fdf88503c70cdc845305d06d0c55a.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图13：类Person具有属性.prototype，指向所有Person实例的原型对象。对象jane和tarzan是这样的实例。](../Images/c08fdf88503c70cdc845305d06d0c55a.png)'
- en: 'Figure 13: The class `Person` has the property `.prototype` that points to
    an object that is the prototype of all instances of `Person`. The objects `jane`
    and `tarzan` are two such instances.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图13：类`Person`具有属性`.prototype`，指向所有`Person`实例的原型对象。对象`jane`和`tarzan`是这样的实例。
- en: 29.3.3 `.__proto__` vs. `.prototype`
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.3.3 `.__proto__` vs. `.prototype`
- en: 'It is easy to confuse `.__proto__` and `.prototype`. Hopefully, fig. [13](#fig:oo_person_class)
    makes it clear how they differ:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易混淆`.__proto__`和`.prototype`。希望图13能清楚地说明它们的区别：
- en: '[`.__proto__`](ch_classes.html#Object.prototype.__proto__) is an accessor of
    class `Object` that lets us get and set the prototypes of its instances.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`.__proto__`](ch_classes.html#Object.prototype.__proto__)是类`Object`的访问器，它让我们获取和设置其实例的原型。'
- en: '`.prototype` is a normal property like any other. It is only special because
    the `new` operator uses its value as the prototype of instances. Its name is not
    ideal. A different name such as `.instancePrototype` would be more fitting.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.prototype`是一个像其他任何属性一样的普通属性。它之所以特殊，只是因为`new`运算符使用它的值作为实例的原型。它的名称并不理想。一个不同的名称，比如`.instancePrototype`，更合适。'
- en: 29.3.4 `Person.prototype.constructor` (advanced)
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.3.4 `Person.prototype.constructor`（高级）
- en: 'There is one detail in fig. [13](#fig:oo_person_class) that we haven’t looked
    at, yet: `Person.prototype.constructor` points back to `Person`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图13中有一个细节我们还没有看过：`Person.prototype.constructor`指回`Person`：
- en: '[PRE26]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This setup exists due to backward compatibility. But it has two additional benefits.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置存在是因为向后兼容性。但它有两个额外的好处。
- en: 'First, each instance of a class inherits property `.constructor`. Therefore,
    given an instance, we can make “similar” objects via it:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，每个类的实例都继承属性`.constructor`。因此，给定一个实例，我们可以通过它创建“相似”的对象：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Second, we can get the name of the class that created a given instance:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可以获取创建给定实例的类的名称：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 29.3.5 Dispatched vs. direct method calls (advanced)
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.3.5 分派 vs. 直接方法调用（高级）
- en: 'In this subsection, we learn about two different ways of invoking methods:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们学习了两种不同的调用方法：
- en: Dispatched method calls
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分派方法调用
- en: Direct method calls
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接方法调用
- en: Understanding both of them will give us important insights into how methods
    work.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 理解它们两个将为我们提供重要的方法工作见解。
- en: 'We’ll also need the second way [later](ch_classes.html#using-object-methods-safely)
    in this chapter: It will allow us to borrow useful methods from `Object.prototype`.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要本章后面的第二种方法：它将允许我们从`Object.prototype`中借用有用的方法。
- en: 29.3.5.1 Dispatched method calls
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.3.5.1 分派方法调用
- en: 'Let’s examine how method calls work with classes. We are revisiting `jane`
    from earlier:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看类的方法调用是如何工作的。我们重新访问之前的`jane`：
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Fig. [14](#fig:jane_proto_chain) has a diagram with `jane`’s prototype chain.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图[14](#fig:jane_proto_chain)有一个带有`jane`的原型链的图表。
- en: '![Figure 14: The prototype chain of jane starts with jane and continues with
    Person.prototype.](../Images/e78cd85588d30424a17c527acfb55b69.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图14：jane的原型链以jane开始，然后继续到Person.prototype。](../Images/e78cd85588d30424a17c527acfb55b69.png)'
- en: 'Figure 14: The prototype chain of `jane` starts with `jane` and continues with
    `Person.prototype`.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图14：`jane`的原型链以`jane`开始，然后继续到`Person.prototype`。
- en: Normal method calls are *dispatched* – the method call
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 普通方法调用是*分发*的-方法调用
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'happens in two steps:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 发生在两个步骤中：
- en: 'Dispatch: JavaScript traverses the prototype chain starting with `jane` to
    find the first object that has an own property with the key `''describe''`: It
    first looks at `jane` and doesn’t find an own property `.describe`. It continues
    with `jane`’s prototype, `Person.prototype` and finds an own property `describe`
    whose value it returns.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发：JavaScript遍历原型链，从`jane`开始查找具有键`'describe'`的自有属性的第一个对象：它首先查看`jane`，并没有找到自有属性`.describe`。它继续查看`jane`的原型，`Person.prototype`，并找到了一个自有属性`describe`，返回其值。
- en: '[PRE31]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Invocation: Method-invoking a value is different from function-invoking a value
    in that it not only calls what comes before the parentheses with the arguments
    inside the parentheses but also sets `this` to the receiver of the method call
    (in this case, `jane`):'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用：方法调用一个值与函数调用一个值不同，它不仅调用括号前面的内容和括号内的参数，还将`this`设置为方法调用的接收者（在本例中为`jane`）：
- en: '[PRE32]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This way of dynamically looking for a method and invoking it is called *dynamic
    dispatch*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这种动态查找方法并调用它的方式称为*动态分发*。
- en: 29.3.5.2 Direct method calls
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.3.5.2 直接方法调用
- en: 'We can also make method calls *directly*, without dispatching:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以*直接*进行方法调用，而无需分发：
- en: '[PRE33]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This time, we directly point to the method via `Person.prototype.describe` and
    don’t search for it in the prototype chain. We also specify `this` differently
    – via `.call()`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们直接通过`Person.prototype.describe`指向方法，而不是在原型链中搜索它。我们还通过`.call()`不同地指定了`this`。
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **`this` always points
    to the instance**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`this` 总是指向实例'
- en: No matter where in the prototype chain of an instance a method is located, `this`
    always points to the instance (the beginning of the prototype chain). That enables
    `.describe()` to access `.#firstName` in the example.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 无论实例的原型链中的方法位于何处，`this` 总是指向实例（原型链的开头）。这使得`.describe()`能够在示例中访问`.#firstName`。
- en: 'When are direct method calls useful? Whenever we want to borrow a method from
    elsewhere that a given object doesn’t have – for example:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 直接方法调用何时有用？每当我们想要从其他地方借用一个给定对象没有的方法时，例如：
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 29.3.6 Classes evolved from ordinary functions (advanced)
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.3.6 类从普通函数演变而来（高级）
- en: 'Before ECMAScript 6, JavaScript didn’t have classes. Instead, [ordinary functions](ch_callables.html#ordinary-functions)
    were used as *constructor functions*:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECMAScript 6之前，JavaScript没有类。而是使用[普通函数](ch_callables.html#ordinary-functions)作为*构造函数*：
- en: '[PRE35]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Classes provide better syntax for this approach:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 类提供了更好的语法来实现这一点：
- en: '[PRE36]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Subclassing is especially tricky with constructor functions. Classes also offer
    benefits that go beyond more convenient syntax:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构造函数进行子类化特别棘手。类还提供了超出更方便的语法之外的好处：
- en: Built-in constructor functions such as `Error` can be subclassed.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置构造函数（如`Error`）可以被子类化。
- en: We can access overridden properties via `super`.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过`super`访问被覆盖的属性。
- en: Classes can’t be function-called.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类不能被函数调用。
- en: Methods can’t be `new`-called and don’t have the property `.prototype`.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法不能被`new`调用，也没有`.prototype`属性。
- en: Support for private instance data.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持私有实例数据。
- en: And more.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有更多。
- en: 'Classes are so compatible with constructor functions that they can even extend
    them:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 类与构造函数非常兼容，甚至可以扩展它们：
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`extends` and subclassing are explained [later in this chapter](ch_classes.html#subclassing).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`extends`和子类化在[本章后面](ch_classes.html#subclassing)有解释。'
- en: 29.3.6.1 A class is the constructor
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.3.6.1 类就是构造函数
- en: This brings us to an interesting insight. On one hand, `StringBuilderClass`
    refers to its constructor via `StringBuilderClass.prototype.constructor`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了一个有趣的见解。一方面，`StringBuilderClass`通过`StringBuilderClass.prototype.constructor`引用其构造函数。
- en: 'On the other hand, the class *is* the constructor (a function):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，类*就是*构造函数（一个函数）：
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **Constructor (functions)
    vs. classes**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  构造函数（函数）与类'
- en: Due to how similar they are, I use the terms *constructor (function)* and *class*
    interchangeably.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的相似性，我可以互换使用术语*构造函数（函数）*和*类*。
- en: 29.4 Prototype members of classes
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.4 类的原型成员
- en: 29.4.1 Public prototype methods and accessors
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.4.1 公共原型方法和访问器
- en: All members in the body of the following class declaration create properties
    of `PublicProtoClass.prototype`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类声明体中的所有成员都创建了`PublicProtoClass.prototype`的属性。
- en: '[PRE39]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 29.4.1.1 All kinds of public prototype methods and accessors (advanced)
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.4.1.1 各种公共原型方法和访问器（高级）
- en: '[PRE40]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Quoted and computed keys can also be used in object literals:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 引用和计算键也可以在对象字面量中使用：
- en: '[§28.7.1 “Quoted keys in object literals”](ch_objects.html#object-literals-quoted-keys)'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[§28.7.1 “对象字面量中的引用键”](ch_objects.html#object-literals-quoted-keys)'
- en: '[§28.7.2 “Computed keys in object literals”](ch_objects.html#object-literals-computed-keys)'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[§28.7.2 “对象字面量中的计算键”](ch_objects.html#object-literals-computed-keys)'
- en: 'More information on accessors (defined via getters and/or setters), generators,
    async methods, and async generator methods:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 有关访问器（通过getter和/或setter定义）、生成器、异步方法和异步生成器方法的更多信息：
- en: '[§28.3.6 “Object literals: accessors”](ch_objects.html#object-literal-accessors)'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[§28.3.6 “对象字面量：访问器”](ch_objects.html#object-literal-accessors)'
- en: '[§38 “Synchronous generators”](ch_sync-generators.html)'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[§38 “同步生成器”](ch_sync-generators.html)'
- en: '[§41 “Async functions”](ch_async-functions.html)'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[§41 “异步函数”](ch_async-functions.html)'
- en: '[§42.2 “Asynchronous generators”](ch_async-iteration.html#async-generators)'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[§42.2 “异步生成器”](ch_async-iteration.html#async-generators)'
- en: 29.4.2 Private methods and accessors [ES2022]
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.4.2 私有方法和访问器 [ES2022]
- en: Private methods (and accessors) are an interesting mix of prototype members
    and instance members.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 私有方法（和访问器）是原型成员和实例成员的有趣混合体。
- en: 'On one hand, private methods are stored in slots in instances (line A):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，私有方法存储在实例的槽中（A行）：
- en: '[PRE41]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Why are they not stored in `.prototype` objects? Private slots are not inherited,
    only properties are.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它们不存储在`.prototype`对象中？私有槽不会被继承，只有属性会被继承。
- en: 'On the other hand, private methods are shared between instances – like prototype
    public methods:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，私有方法在实例之间是共享的，就像原型公共方法一样：
- en: '[PRE42]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Due to that and due to their syntax being similar to prototype public methods,
    they are covered here.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的语法与原型公共方法相似，因此它们在这里进行了介绍。
- en: 'The following code demonstrates how private methods and accessors work:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了私有方法和访问器的工作原理：
- en: '[PRE43]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 29.4.2.1 All kinds of private methods and accessors (advanced)
  id: totrans-283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.4.2.1 各种私有方法和访问器（高级）
- en: 'With private slots, the keys are always identifiers:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用私有槽时，键始终是标识符：
- en: '[PRE44]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'More information on accessors (defined via getters and/or setters), generators,
    async methods, and async generator methods:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于访问器（通过getter和/或setter定义）、生成器、异步方法和异步生成器方法的信息：
- en: '[§28.3.6 “Object literals: accessors”](ch_objects.html#object-literal-accessors)'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[§28.3.6 “对象字面量：访问器”](ch_objects.html#object-literal-accessors)'
- en: '[§38 “Synchronous generators”](ch_sync-generators.html)'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[§38 “同步生成器”](ch_sync-generators.html)'
- en: '[§41 “Async functions”](ch_async-functions.html)'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[§41 “异步函数”](ch_async-functions.html)'
- en: '[§42.2 “Asynchronous generators”](ch_async-iteration.html#async-generators)'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[§42.2 “异步生成器”](ch_async-iteration.html#async-generators)'
- en: 29.5 Instance members of classes [ES2022]
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.5 实例类成员 [ES2022]
- en: 29.5.1 Instance public fields
  id: totrans-292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.5.1 实例公共字段
- en: 'Instances of the following class have two instance properties (created in line
    A and line B):'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类的实例具有两个实例属性（在A行和B行创建）：
- en: '[PRE45]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If we create an instance property inside the constructor (line B), we don’t
    need to “declare” it elsewhere. As we have already seen, that is different for
    instance private fields.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在构造函数中创建了一个实例属性（B行），我们就不需要在其他地方“声明”它。正如我们已经看到的，对于实例私有字段来说是不同的。
- en: Note that instance properties are relatively common in JavaScript; much more
    so than in, e.g., Java, where most instance state is private.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，实例属性在JavaScript中相对常见；比如在Java中，大多数实例状态都是私有的。
- en: 29.5.1.1 Instance public fields with quoted and computed keys (advanced)
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.5.1.1 具有带引号和计算键的实例公共字段（高级）
- en: '[PRE46]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 29.5.1.2 What is the value of `this` in instance public fields? (advanced)
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.5.1.2 实例公共字段中`this`的值是什么？（高级）
- en: 'In the initializer of a instance public field, `this` refers to the newly created
    instance:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例公共字段的初始化程序中，`this`指的是新创建的实例：
- en: '[PRE47]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 29.5.1.3 When are instance public fields executed? (advanced)
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.5.1.3 实例公共字段何时执行？（高级）
- en: 'The execution of instance public fields roughly follows these two rules:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 实例公共字段的执行大致遵循这两条规则：
- en: In base classes (classes without superclasses), instance public fields are executed
    immediately before the constructor.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基类（没有超类的类）中，实例公共字段在构造函数之前立即执行。
- en: 'In derived classes (classes with superclasses):'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在派生类（具有超类的类）中：
- en: The superclass sets up its instance slots when `super()` is called.
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`super()`被调用时，超类设置其实例槽。
- en: Instance public fields are executed immediately after `super()`.
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例公共字段在`super()`之后立即执行。
- en: 'The following example demonstrates these rules:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了这些规则：
- en: '[PRE48]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`extends` and subclassing are explained [later in this chapter](ch_classes.html#subclassing).'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`extends`和子类化在[本章后面](ch_classes.html#subclassing)有解释。'
- en: 29.5.2 Instance private fields
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.5.2 实例私有字段
- en: 'The following class contains two instance private fields (line A and line B):'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类包含两个实例私有字段（A行和B行）：
- en: '[PRE49]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note that we can only use `.#privateField2` in line C if we declare it in the
    class body.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们在类主体中声明了`.#privateField2`，那么我们只能在C行中使用它。
- en: 29.5.3 Private instance data before ES2022 (advanced)
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.5.3 ES2022之前的私有实例数据（高级）
- en: In this section, we look at two techniques for keeping instance data private.
    Because they don’t rely on classes, we can also use them for objects that were
    created in other ways – e.g., via object literals.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍两种保持实例数据私有的技术。因为它们不依赖于类，所以我们也可以用它们来处理其他方式创建的对象，比如通过对象字面量。
- en: '29.5.3.1 Before ES6: private members via naming conventions'
  id: totrans-317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.5.3.1 ES6之前：通过命名约定实现私有成员
- en: 'The first technique makes a property private by prefixing its name with an
    underscore. This doesn’t protect the property in any way; it merely signals to
    the outside: “You don’t need to know about this property.”'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种技术是通过在属性名称前加下划线使其私有化。这并不以任何方式保护属性；它只是向外界发出信号：“你不需要知道这个属性。”
- en: In the following code, the properties `._counter` and `._action` are private.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，属性`._counter`和`._action`是私有的。
- en: '[PRE50]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: With this technique, we don’t get any protection and private names can clash.
    On the plus side, it is easy to use.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，我们不会得到任何保护，私有名称可能会冲突。但好处是，它很容易使用。
- en: 'Private methods work similarly: They are normal methods whose names start with
    underscores.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 私有方法的工作方式类似：它们是以下划线开头的普通方法。
- en: '29.5.3.2 ES6 and later: private instance data via WeakMaps'
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.5.3.2 ES6及以后：通过WeakMaps实现私有实例数据
- en: 'We can also manage private instance data via WeakMaps:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过WeakMaps管理私有实例数据：
- en: '[PRE51]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How exactly that works is explained [in the chapter on WeakMaps](ch_weakmaps.html#private-data-in-weakmaps).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 关于它的工作原理的详细解释在[WeakMaps章节](ch_weakmaps.html#private-data-in-weakmaps)中有说明。
- en: This technique offers us considerable protection from outside access and there
    can’t be any name clashes. But it is also more complicated to use.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术为我们提供了相当大的保护，防止外部访问和名称冲突。但它也更复杂一些。
- en: 'We control the visibility of the pseudo-property `_superProp` by controlling
    who has access to it – for example: If the variable exists inside a module and
    isn’t exported, everyone inside the module and no one outside the module can access
    it. In other words: The scope of privacy isn’t the class in this case, it’s the
    module. We could narrow the scope, though:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 通过控制谁可以访问 `_superProp` 来控制伪属性 `_superProp` 的可见性——例如：如果变量存在于模块内并且未导出，则模块内的所有人都可以访问它，模块外的任何人都无法访问它。换句话说：在这种情况下，隐私的范围不是类，而是模块。不过，我们可以缩小范围：
- en: '[PRE52]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This technique doesn’t really support private methods. But module-local functions
    that have access to `_superProp` are the next best thing:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术实际上不支持私有方法。但是，具有对 `_superProp` 的访问权限的模块局部函数是下一个最好的选择：
- en: '[PRE53]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that `this` becomes the explicit function parameter `_this` (line A).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`this` 变成了显式函数参数 `_this`（A行）。
- en: 29.5.4 Simulating protected visibility and friend visibility via WeakMaps (advanced)
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.5.4 通过 WeakMaps 模拟受保护的可见性和友元可见性（高级）
- en: 'As previously discussed, instance private fields are only visible inside their
    classes and not even in subclasses. Thus, there is no built-in way to get:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，实例私有字段只在其类内部可见，甚至在子类中也不可见。因此，没有内置的方法可以获取：
- en: 'Protected visibility: A class and all of its subclasses can access a piece
    instance data.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受保护的可见性：一个类及其所有子类可以访问一个实例数据。
- en: 'Friend visibility: A class and its “friends” (designated functions, objects,
    or classes) can access a piece of instance data.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 友元可见性：一个类及其“友元”（指定的函数、对象或类）可以访问一个实例数据。
- en: 'In the previous subsection, we simulated “module visibility” (everyone inside
    a module has access to a piece of instance data) via WeakMaps. Therefore:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一小节中，我们通过 WeakMaps 模拟了“模块可见性”（模块内的所有人都可以访问一个实例数据）。因此：
- en: If we put a class and its subclasses into the same module, we get protected
    visibility.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们将一个类及其子类放入同一个模块中，我们就会得到受保护的可见性。
- en: If we put a class and its friends into the same module, we get friend visibility.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们将一个类及其友元放入同一个模块中，我们就会得到友元可见性。
- en: 'The next example demonstrates protected visibility:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例演示了受保护的可见性：
- en: '[PRE54]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[Subclassing via `extends`](ch_classes.html#subclassing) is explained later
    in this chapter.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '[通过 `extends` 进行子类化](ch_classes.html#subclassing) 在本章后面有解释。'
- en: 29.6 Static members of classes
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.6 类的静态成员
- en: 29.6.1 Static public methods and accessors
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.6.1 静态公共方法和访问器
- en: All members in the body of the following class declaration create so-called
    *static* properties – properties of `StaticClass` itself.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下类声明的主体中，所有成员都创建所谓的 *静态* 属性——`StaticClass` 本身的属性。
- en: '[PRE55]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 29.6.1.1 All kinds of static public methods and accessors (advanced)
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.6.1.1 所有种类的静态公共方法和访问器（高级）
- en: '[PRE56]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Quoted and computed keys can also be used in object literals:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 引号和计算键也可以在对象字面量中使用：
- en: '[§28.7.1 “Quoted keys in object literals”](ch_objects.html#object-literals-quoted-keys)'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[§28.7.1 “对象字面量中的引号键”](ch_objects.html#object-literals-quoted-keys)'
- en: '[§28.7.2 “Computed keys in object literals”](ch_objects.html#object-literals-computed-keys)'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[§28.7.2 “对象字面量中的计算键”](ch_objects.html#object-literals-computed-keys)'
- en: 'More information on accessors (defined via getters and/or setters), generators,
    async methods, and async generator methods:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 有关访问器（通过 getter 和/或 setter 定义）、生成器、异步方法和异步生成器方法的更多信息：
- en: '[§28.3.6 “Object literals: accessors”](ch_objects.html#object-literal-accessors)'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[§28.3.6 “对象字面量：访问器”](ch_objects.html#object-literal-accessors)'
- en: '[§38 “Synchronous generators”](ch_sync-generators.html)'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[§38 “同步生成器”](ch_sync-generators.html)'
- en: '[§41 “Async functions”](ch_async-functions.html)'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[§41 “异步函数”](ch_async-functions.html)'
- en: '[§42.2 “Asynchronous generators”](ch_async-iteration.html#async-generators)'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[§42.2 “异步生成器”](ch_async-iteration.html#async-generators)'
- en: 29.6.2 Static public fields [ES2022]
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.6.2 静态公共字段 [ES2022]
- en: 'The following code demonstrates static public fields. `StaticPublicFieldClass`
    has three of them:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了静态公共字段。`StaticPublicFieldClass` 有三个静态公共字段：
- en: '[PRE57]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 29.6.3 Static private methods, accessors, and fields [ES2022]
  id: totrans-360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.6.3 静态私有方法、访问器和字段 [ES2022]
- en: 'The following class has two static private slots (line A and line B):'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类有两个静态私有槽（A行和B行）：
- en: '[PRE58]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This is a complete list of all kinds of static private slots:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这是所有种类的静态私有槽的完整列表：
- en: '[PRE59]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 29.6.4 Static initialization blocks in classes [ES2022]
  id: totrans-365
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.6.4 类中的静态初始化块 [ES2022]
- en: 'To set up instance data via classes, we have two constructs:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类设置实例数据，我们有两种构造：
- en: '*Fields*, to create and optionally initialize instance data'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*字段*，用于创建并可选地初始化实例数据'
- en: '*Constructors*, blocks of code that are executed every time a new instance
    is created'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构造函数*，每次创建新实例时执行的代码块'
- en: 'For static data, we have:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 对于静态数据，我们有：
- en: '*Static fields*'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*静态字段*'
- en: '*Static blocks* that are executed when a class is created'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*静态块* 在类创建时执行'
- en: 'The following code demonstrates static blocks (line A):'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了静态块（A行）：
- en: '[PRE60]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We could also execute the code inside the static block after the class (at
    the top level). However, using a static block has two benefits:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在类后执行静态块中的代码（在顶层）。然而，使用静态块有两个好处：
- en: All class-related code is inside the class.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有与类相关的代码都在类内部。
- en: The code in a static block has access to private slots.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态块中的代码可以访问私有槽。
- en: 29.6.4.1 Rules for static initialization blocks
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.6.4.1 静态初始化块的规则
- en: 'The rules for how static initialization blocks work, are relatively simple:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 静态初始化块的工作规则相对简单：
- en: There can be more than one static block per class.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个类可以有多个静态块。
- en: The execution of static blocks is interleaved with the execution of static field
    initializers.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态块的执行与静态字段初始化的执行交错进行。
- en: The static members of a superclass are executed before the static members of
    a subclass.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超类的静态成员在子类的静态成员之前执行。
- en: 'The following code demonstrates these rules:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了这些规则：
- en: '[PRE61]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[Subclassing via `extends`](ch_classes.html#subclassing) is explained later
    in this chapter.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '[通过 `extends` 进行子类化](ch_classes.html#subclassing) 在本章后面有解释。'
- en: '29.6.5 Pitfall: Using `this` to access static private fields'
  id: totrans-385
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.6.5 陷阱：使用 `this` 访问静态私有字段
- en: In static public members, we can access static public slots via `this`. Alas,
    we should not use it to access static private slots.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态公共成员中，我们可以通过`this`访问静态公共插槽。遗憾的是，我们不应该用它来访问静态私有插槽。
- en: 29.6.5.1 `this` and static public fields
  id: totrans-387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.6.5.1 `this`和静态公共字段
- en: 'Consider the following code:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE62]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[Subclassing via `extends`](ch_classes.html#subclassing) is explained later
    in this chapter.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '[通过`extends`进行子类化](ch_classes.html#subclassing)在本章后面有解释。'
- en: Static public fields are properties. If we make the method call
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 静态公共字段是属性。如果我们调用该方法
- en: '[PRE63]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'then `this` points to `SuperClass` and everything works as expected. We can
    also invoke `.getPublicViaThis()` via the subclass:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`this`指向`SuperClass`，一切都按预期工作。我们还可以通过子类调用`.getPublicViaThis()`：
- en: '[PRE64]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`SubClass` inherits `.getPublicViaThis()` from its prototype `SuperClass`.
    `this` points to `SubClass` and things continue to work, because `SubClass` also
    inherits the property `.publicData`.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`SubClass`从其原型`SuperClass`继承了`.getPublicViaThis()`。`this`指向`SubClass`，事情继续进行，因为`SubClass`还继承了`.publicData`属性。'
- en: As an aside, if we assigned to `this.publicData` in `getPublicViaThis()` and
    invoked it via `SubClass.getPublicViaThis()`, then we would create a new own poperty
    of `SubClass` that (non-destructively) overrides the property inherited from `SuperClass`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果我们在`getPublicViaThis()`中为`this.publicData`赋值，并通过`SubClass.getPublicViaThis()`调用它，那么我们将创建一个新的`SubClass`自己的属性，它（非破坏性地）覆盖了从`SuperClass`继承的属性。
- en: 29.6.5.2 `this` and static private fields
  id: totrans-397
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.6.5.2 `this`和静态私有字段
- en: 'Consider the following code:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE65]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Invoking `.getPrivateDataViaThis()` via `SuperClass` works, because `this`
    points to `SuperClass`:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`SuperClass`调用`.getPrivateDataViaThis()`是有效的，因为`this`指向`SuperClass`：
- en: '[PRE66]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'However, invoking `.getPrivateDataViaThis()` via `SubClass` does not work,
    because `this` now points to `SubClass` and `SubClass` has no static private field
    `.#privateData` (private slots in prototype chains are not inherited):'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过`SubClass`调用`.getPrivateDataViaThis()`是无效的，因为此时`this`指向`SubClass`，而`SubClass`没有静态私有字段`.#privateData`（原型链中的私有插槽不会被继承）：
- en: '[PRE67]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The workaround is to accesss `.#privateData` directly, via `SuperClass`:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是直接访问`.#privateData`，通过`SuperClass`：
- en: '[PRE68]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: With static private methods, we are facing the same issue.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态私有方法时，我们面临相同的问题。
- en: 29.6.6 All members (static, prototype, instance) can access all private members
  id: totrans-407
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.6.6 所有成员（静态、原型、实例）都可以访问所有私有成员
- en: 'Every member inside a class can access all other members inside that class
    – both public and private ones:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的每个成员都可以访问该类中的所有其他成员-包括公共成员和私有成员：
- en: '[PRE69]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In contrast, no one outside can access the private members:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，外部任何人都无法访问私有成员：
- en: '[PRE70]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 29.6.7 Static private methods and data before ES2022
  id: totrans-412
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.6.7 ES2022之前的静态私有方法和数据
- en: 'The following code only works in ES2022 – due to every line that has a hash
    symbol (`#`) in it:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码仅在ES2022中有效-由于每一行中都有一个井号（`#`）：
- en: '[PRE71]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Since private slots only exist once per class, we can move `#secret` and `#getSecretInParens`
    to the scope surrounding the class and use a module to hide them from the world
    outside the module.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 由于私有插槽只存在于每个类中一次，我们可以将`#secret`和`#getSecretInParens`移到围绕类的范围，并使用模块将它们隐藏在模块外的世界中。
- en: '[PRE72]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 29.6.8 Static factory methods
  id: totrans-417
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.6.8 静态工厂方法
- en: 'Sometimes there are multiple ways in which a class can be instantiated. Then
    we can implement *static factory methods* such as `Point.fromPolar()`:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 有时类可以以多种方式实例化。然后我们可以实现“静态工厂方法”，比如`Point.fromPolar()`：
- en: '[PRE73]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'I like how descriptive static factory methods are: `fromPolar` describes how
    an instance is created. JavaScript’s standard library also has such factory methods
    – for example:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢静态工厂方法的描述性：`fromPolar`描述了如何创建实例。JavaScript的标准库也有这样的工厂方法-例如：
- en: '`Array.from()`'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.from()`'
- en: '`Object.create()`'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.create()`'
- en: 'I prefer to either have no static factory methods or *only* static factory
    methods. Things to consider in the latter case:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢要么没有静态工厂方法，要么*只有*静态工厂方法。在后一种情况下需要考虑的事项：
- en: One factory method will probably directly call the constructor (but have a descriptive
    name).
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个工厂方法可能会直接调用构造函数（但具有描述性的名称）。
- en: We need to find a way to prevent the constructor being called from outside.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要找到一种方法来防止构造函数被外部调用。
- en: In the following code, we use a secret token (line A) to prevent the constructor
    being called from outside the current module.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们使用一个秘密令牌（A行）来防止构造函数被外部模块调用。
- en: '[PRE74]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 29.7 Subclassing
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.7 子类化
- en: 'Classes can also extend existing classes. For example, the following class
    `Employee` extends `Person`:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 类也可以扩展现有的类。例如，以下类`Employee`扩展了`Person`：
- en: '[PRE75]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Terminology related to extending:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 与扩展相关的术语：
- en: Another word for *extending* is *subclassing*.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “扩展”的另一个词是“子类化”。
- en: '`Person` is the superclass of `Employee`.'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Person`是`Employee`的超类。'
- en: '`Employee` is the subclass of `Person`.'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Employee`是`Person`的子类。'
- en: A *base class* is a class that has no superclasses.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “基类”是一个没有超类的类。
- en: A *derived class* is a class that has a superclass.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “派生类”是一个有超类的类。
- en: Inside the `.constructor()` of a derived class, we must call the super-constructor
    via `super()` before we can access `this`. Why is that?
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在派生类的`.constructor()`中，我们必须在访问`this`之前通过`super()`调用超级构造函数。为什么？
- en: 'Let’s consider a chain of classes:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一系列的类：
- en: Base class `A`
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基类`A`
- en: Class `B` extends `A`.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类`B`扩展了`A`。
- en: Class `C` extends `B`.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类`C`扩展了`B`。
- en: If we invoke `new C()`, `C`’s constructor super-calls `B`’s constructor which
    super-calls `A`’s constructor. Instances are always created in base classes, before
    the constructors of subclasses add their slots. Therefore, the instance doesn’t
    exist before we call `super()` and we can’t access it via `this`, yet.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`new C()`，`C`的构造函数会调用`B`的构造函数，后者会调用`A`的构造函数。实例总是在基类中创建，然后在子类的构造函数添加插槽之前。因此，在调用`super()`之前实例不存在，我们无法通过`this`访问它。
- en: 'Note that static public slots are inherited. For example, `Employee` inherits
    the static method `.extractNames()`:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，静态公共插槽是继承的。例如，`Employee`继承了静态方法`.extractNames()`：
- en: '[PRE76]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Subclassing**'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **练习：子类化**'
- en: '`exercises/classes/color_point_class_test.mjs`'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/classes/color_point_class_test.mjs`'
- en: 29.7.1 The internals of subclassing (advanced)
  id: totrans-447
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.7.1 子类的内部（高级）
- en: '![Figure 15: These are the objects that make up class Person and its subclass,
    Employee. The left column is about classes. The right column is about the Employee
    instance jane and its prototype chain.](../Images/2f7f76cfc1a6bab2586a13f8db175cd7.png)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![图15：这些是类Person及其子类Employee的对象。左列是关于类的，右列是关于Employee实例jane及其原型链的。](../Images/2f7f76cfc1a6bab2586a13f8db175cd7.png)'
- en: 'Figure 15: These are the objects that make up class `Person` and its subclass,
    `Employee`. The left column is about classes. The right column is about the `Employee`
    instance `jane` and its prototype chain.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 图15：这些是类`Person`及其子类`Employee`的对象。左列是关于类的，右列是关于`Employee`实例`jane`及其原型链的。
- en: 'The classes `Person` and `Employee` from the previous section are made up of
    several objects (fig. [15](#fig:oo_subclassing)). One key insight for understanding
    how these objects are related is that there are two prototype chains:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节中的类`Person`和`Employee`由几个对象组成（图[15](#fig:oo_subclassing)）。理解这些对象如何相关的一个关键见解是，有两个原型链：
- en: The instance prototype chain, on the right.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例的原型链，位于右侧。
- en: The class prototype chain, on the left.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的原型链，位于左侧。
- en: 29.7.1.1 The instance prototype chain (right column)
  id: totrans-453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.7.1.1 实例原型链（右列）
- en: 'The instance prototype chain starts with `jane` and continues with `Employee.prototype`
    and `Person.prototype`. In principle, the prototype chain ends at this point,
    but we get one more object: `Object.prototype`. This prototype provides services
    to virtually all objects, which is why it is included here, too:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 实例的原型链以`jane`开始，然后是`Employee.prototype`和`Person.prototype`。原则上，原型链在这一点上结束，但我们得到了另一个对象：`Object.prototype`。这个原型为几乎所有对象提供服务，这就是为什么它也被包括在这里：
- en: '[PRE77]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 29.7.1.2 The class prototype chain (left column)
  id: totrans-456
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.7.1.2 类原型链（左列）
- en: In the class prototype chain, `Employee` comes first, `Person` next. Afterward,
    the chain continues with `Function.prototype`, which is only there because `Person`
    is a function and functions need the services of `Function.prototype`.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在类原型链中，`Employee`排在第一位，`Person`排在其后。之后，链条继续包括`Function.prototype`，这是因为`Person`是一个函数，函数需要`Function.prototype`的服务。
- en: '[PRE78]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 29.7.2 `instanceof` and subclassing (advanced)
  id: totrans-459
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.7.2 `instanceof`和子类（高级）
- en: 'We have not yet learned how `instanceof` really works. How does `instanceof`
    determine if a value `x` is an instance of a class `C` (it can be a direct instance
    of `C` or a direct instance of a subclass of `C`)? It checks if `C.prototype`
    is in the prototype chain of `x`. That is, the following two expressions are equivalent:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有学习`instanceof`的真正工作原理。`instanceof`如何确定值`x`是否是类`C`的实例（它可以是`C`的直接实例或`C`的子类的直接实例）？它检查`C.prototype`是否在`x`的原型链中。也就是说，以下两个表达式是等价的：
- en: '[PRE79]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If we go back to fig. [15](#fig:oo_subclassing), we can confirm that the prototype
    chain does lead us to the following correct answers:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到图[15](#fig:oo_subclassing)，我们可以确认原型链确实给我们带来了以下正确的答案：
- en: '[PRE80]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Note that `instanceof` always returns `false` if its self-hand side is a primitive
    value:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果`instanceof`的自身操作数是原始值，`instanceof`总是返回`false`：
- en: '[PRE81]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 29.7.3 Not all objects are instances of `Object` (advanced)
  id: totrans-466
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.7.3 并非所有对象都是`Object`的实例（高级）
- en: 'An object (a non-primitive value) is only an instance of `Object` if `Object.prototype`
    is in its prototype chain [(see previous subsection)](ch_classes.html#instanceof-operator).
    Virtually all objects are instances of `Object` – for example:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 只有对象（非原始值）是`Object`的实例，如果`Object.prototype`在它们的原型链中[(见上一小节)](ch_classes.html#instanceof-operator)。几乎所有对象都是`Object`的实例——例如：
- en: '[PRE82]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'In the next example, `obj1` and `obj2` are both objects (line A and line C),
    but they are not instances of `Object` (line B and line D): `Object.prototype`
    is not in their prototype chains because they don’t have any prototypes.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，`obj1`和`obj2`都是对象（行A和行C），但它们不是`Object`的实例（行B和行D）：`Object.prototype`不在它们的原型链中，因为它们没有任何原型。
- en: '[PRE83]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '`Object.prototype` is the object that ends most prototype chains. Its prototype
    is `null`, which means it isn’t an instance of `Object` either:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.prototype`是结束大多数原型链的对象。它的原型是`null`，这意味着它也不是`Object`的实例：'
- en: '[PRE84]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 29.7.4 Prototype chains of built-in objects (advanced)
  id: totrans-473
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.7.4 内置对象的原型链（高级）
- en: Next, we’ll use our knowledge of subclassing to understand the prototype chains
    of a few built-in objects. The following tool function `p()` helps us with our
    explorations.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将利用我们对子类的了解来理解一些内置对象的原型链。以下工具函数`p()`将帮助我们进行探索。
- en: '[PRE85]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We extracted method `.getPrototypeOf()` of `Object` and assigned it to `p`.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提取了`Object`的方法`.getPrototypeOf()`并将其赋值给`p`。
- en: 29.7.4.1 The prototype chain of `{}`
  id: totrans-477
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.7.4.1 `{}`的原型链
- en: 'Let’s start by examining plain objects:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从检查普通对象开始：
- en: '[PRE86]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '![Figure 16: The prototype chain of an object created via an object literal
    starts with that object, continues with Object.prototype, and ends with null.](../Images/e6bb1e3280584f9f2a385f54baab341c.png)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![图16：通过对象字面量创建的对象的原型链以该对象开始，继续包括Object.prototype，最后为null。](../Images/e6bb1e3280584f9f2a385f54baab341c.png)'
- en: 'Figure 16: The prototype chain of an object created via an object literal starts
    with that object, continues with `Object.prototype`, and ends with `null`.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 图16：通过对象字面量创建的对象的原型链以该对象开始，继续包括`Object.prototype`，最后为`null`。
- en: Fig. [16](#fig:proto_chain_object) shows a diagram for this prototype chain.
    We can see that `{}` really is an instance of `Object` – `Object.prototype` is
    in its prototype chain.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 图[16](#fig:proto_chain_object)显示了这个原型链的图表。我们可以看到`{}`确实是`Object`的一个实例——`Object.prototype`在它的原型链中。
- en: 29.7.4.2 The prototype chain of `[]`
  id: totrans-483
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.7.4.2 `[]`的原型链
- en: What does the prototype chain of an Array look like?
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的原型链是什么样的？
- en: '[PRE87]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '![Figure 17: The prototype chain of an Array has these members: the Array instance,
    Array.prototype, Object.prototype, null.](../Images/b5d54f0b878da14e43c748ac3f704302.png)'
  id: totrans-486
  prefs: []
  type: TYPE_IMG
  zh: '![图17：数组的原型链包括这些成员：数组实例，Array.prototype，Object.prototype，null。](../Images/b5d54f0b878da14e43c748ac3f704302.png)'
- en: 'Figure 17: The prototype chain of an Array has these members: the Array instance,
    `Array.prototype`, `Object.prototype`, `null`.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 图17：Array的原型链有这些成员：Array实例，`Array.prototype`，`Object.prototype`，`null`。
- en: This prototype chain (visualized in fig. [17](#fig:proto_chain_array)) tells
    us that an Array object is an instance of `Array` and of `Object`.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原型链（在图17中可视化）告诉我们，Array对象是`Array`和`Object`的实例。
- en: 29.7.4.3 The prototype chain of `function () {}`
  id: totrans-489
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.7.4.3 `function () {}`的原型链
- en: 'Lastly, the prototype chain of an ordinary function tells us that all functions
    are objects:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，普通函数的原型链告诉我们，所有函数都是对象：
- en: '[PRE88]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 29.7.4.4 The prototype chains of built-in classes
  id: totrans-492
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.7.4.4 内置类的原型链
- en: 'The prototype of a base class is `Function.prototype` which means that it is
    a function (an instance of `Function`):'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 基类的原型是`Function.prototype`，这意味着它是一个函数（`Function`的实例）：
- en: '[PRE89]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The prototype of a derived class is its superclass:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类的原型是它的超类：
- en: '[PRE90]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Interestingly, `Object`, `Array`, and `Function` are all base classes:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`Object`、`Array`和`Function`都是基类：
- en: '[PRE91]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: However, as we have seen, even the instances of base classes have `Object.prototype`
    in their prototype chains because it provides services that all objects need.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们所见，即使基类的实例也在它们的原型链中有`Object.prototype`，因为它提供了所有对象都需要的服务。
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **Why are `Array` and
    `Function` base classes?**'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`Array`和`Function`是基类？
- en: Base classes are where instances are actually created. Both `Array` and `Function`
    need to create their own instances because they have so-called “internal slots”
    which can’t be added later to instances created by `Object`.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 基类是实例实际创建的地方。`Array`和`Function`都需要创建自己的实例，因为它们有所谓的“内部插槽”，这些插槽不能后来添加到由`Object`创建的实例中。
- en: 29.7.5 Mixin classes (advanced)
  id: totrans-502
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.7.5 mixin类（高级）
- en: 'JavaScript’s class system only supports *single inheritance*. That is, each
    class can have at most one superclass. One way around this limitation is via a
    technique called *mixin classes* (short: *mixins*).'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的类系统只支持*单一继承*。也就是说，每个类最多只能有一个超类。绕过这个限制的一种方法是通过一种称为*mixin类*（简称：*mixin*）的技术。
- en: 'The idea is as follows: Let’s say we want a class `C` to inherit from two superclasses
    `S1` and `S2`. That would be *multiple inheritance*, which JavaScript doesn’t
    support.'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 思路是这样的：假设我们想让一个类`C`继承自两个超类`S1`和`S2`。这将是*多重继承*，JavaScript不支持。
- en: 'Our workaround is to turn `S1` and `S2` into *mixins*, factories for subclasses:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解决方法是将`S1`和`S2`转换为*mixins*，子类的工厂：
- en: '[PRE92]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Each of these two functions returns a class that extends a given superclass
    `Sup`. We create class `C` as follows:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数中的每一个都返回一个扩展给定超类`Sup`的类。我们创建类`C`如下：
- en: '[PRE93]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: We now have a class `C` that extends the class returned by `S2()` which extends
    the class returned by `S1()` which extends `Object`.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个类`C`，它扩展了由`S2()`返回的类，该类又扩展了由`S1()`返回的类，该类又扩展了`Object`。
- en: '29.7.5.1 Example: a mixin for brand management'
  id: totrans-510
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.7.5.1 品牌管理的mixin示例
- en: 'We implement a mixin `Branded` that has helper methods for setting and getting
    the brand of an object:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个mixin`Branded`，它具有设置和获取对象品牌的辅助方法：
- en: '[PRE94]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We use this mixin to implement a class `City` that has a name:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个mixin来实现一个具有名称的类`City`：
- en: '[PRE95]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The following code confirms that the mixin works:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码确认mixin起作用：
- en: '[PRE96]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 29.7.5.2 The benefits of mixins
  id: totrans-517
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 29.7.5.2 mixin的好处
- en: 'Mixins free us from the constraints of single inheritance:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: Mixin使我们摆脱了单一继承的限制：
- en: The same class can extend a single superclass and zero or more mixins.
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的类可以扩展一个超类和零个或多个mixins。
- en: The same mixin can be used by multiple classes.
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的mixin可以被多个类使用。
- en: 29.8 The methods and accessors of `Object.prototype` (advanced)
  id: totrans-521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.8 `Object.prototype`的方法和访问器（高级）
- en: 'As we have seen in [§29.7.3 “Not all objects are instances of `Object`”](ch_classes.html#non-instances-of-object),
    almost all objects are instances of `Object`. This class provides several useful
    methods and an accessor to its instances:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[§29.7.3 “并非所有对象都是`Object`的实例”](ch_classes.html#non-instances-of-object)中所看到的，几乎所有对象都是`Object`的实例。这个类提供了几个有用的方法和一个访问器给它的实例：
- en: 'Configuring how objects are converted to primitive values (e.g. by the `+`
    operator): The following methods have default implementations but are often overridden
    in subclasses or instances.'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置如何将对象转换为原始值（例如通过`+`运算符）：以下方法有默认实现，但通常在子类或实例中被覆盖。
- en: '[`.toString()`](ch_classes.html#Object.prototype.toString): Configures how
    an object is converted to a string.'
  id: totrans-524
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`.toString()`](ch_classes.html#Object.prototype.toString)：配置如何将对象转换为字符串。'
- en: '[`.toLocaleString()`](ch_classes.html#Object.prototype.toLocaleString): A version
    of `.toString()` that can be configured in various ways via arguments (language,
    region, etc.).'
  id: totrans-525
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`.toLocaleString()`](ch_classes.html#Object.prototype.toLocaleString)：`.toString()`的一个版本，可以通过参数（语言、地区等）以各种方式配置。'
- en: '[`.valueOf()`](ch_classes.html#Object.prototype.valueOf): Configures how an
    object is converted to a non-string primitive value (often a number).'
  id: totrans-526
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`.valueOf()`](ch_classes.html#Object.prototype.valueOf)：配置如何将对象转换为非字符串原始值（通常是数字）。'
- en: 'Useful methods (with pitfalls – see next subsection):'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用的方法（带有陷阱-见下一小节）：
- en: '[`.isPrototypeOf()`](ch_classes.html#Object.prototype.isPrototypeOf): Is the
    receiver in the prototype chain of a given object?'
  id: totrans-528
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`.isPrototypeOf()`](ch_classes.html#Object.prototype.isPrototypeOf)：接收者是否在给定对象的原型链中？'
- en: '[`.propertyIsEnumerable()`](ch_classes.html#Object.prototype.propertyIsEnumerable):
    Does the receiver have an enumerable own property with the given key?'
  id: totrans-529
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`.propertyIsEnumerable()`](ch_classes.html#Object.prototype.propertyIsEnumerable)：接收者是否具有具有给定键的可枚举自有属性？'
- en: 'Avoid these features (there are better alternatives):'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用这些特性（有更好的替代方法）：
- en: '[`.__proto__`](ch_classes.html#Object.prototype.__proto__): Get and set the
    prototype of the receiver.'
  id: totrans-531
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`.__proto__`](ch_classes.html#Object.prototype.__proto__)：获取和设置接收者的原型。'
- en: 'Using this accessor is not recommended. Alternatives:'
  id: totrans-532
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不建议使用这个访问器。替代方法：
- en: '`Object.getPrototypeOf()`'
  id: totrans-533
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.getPrototypeOf()`'
- en: '`Object.setPrototypeOf()`'
  id: totrans-534
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.setPrototypeOf()`'
- en: '[`.hasOwnProperty()`](ch_classes.html#Object.prototype.hasOwnProperty): Does
    the receiver have an own property with a given key?'
  id: totrans-535
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`.hasOwnProperty()`](ch_classes.html#Object.prototype.hasOwnProperty): 接收者是否具有给定键的自有属性？'
- en: 'Using this method is not recommended. Alternative in ES2022 and later: `Object.hasOwn()`.'
  id: totrans-536
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不建议使用这个方法。ES2022及以后的替代方法：`Object.hasOwn()`。
- en: 'Before we take a closer look at each of these features, we’ll learn about an
    important pitfall (and how to work around it): We can’t use the features of `Object.prototype`
    with all objects.'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更详细地了解这些特性之前，我们将了解一个重要的陷阱（以及如何解决它）：我们不能在所有对象上使用 `Object.prototype` 的特性。
- en: 29.8.1 Using `Object.prototype` methods safely
  id: totrans-538
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.8.1 安全地使用 `Object.prototype` 的方法
- en: 'Invoking one of the methods of `Object.prototype` on an arbitrary object doesn’t
    always work. To illustrate why, we use method `Object.prototype.hasOwnProperty`,
    which returns `true` if an object has an own property with a given key:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在任意对象上调用 `Object.prototype` 的方法并不总是有效。为了说明这一点，我们使用了 `Object.prototype.hasOwnProperty`
    方法，它返回 `true` 如果对象具有给定键的自有属性：
- en: '[PRE97]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Invoking `.hasOwnProperty()` on an arbitrary object can fail in two ways. On
    one hand, this method isn’t available if an object is not an instance of `Object`
    (see [§29.7.3 “Not all objects are instances of `Object`”](ch_classes.html#non-instances-of-object)):'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 在任意对象上调用 `.hasOwnProperty()` 可能会失败。一方面，如果对象不是 `Object` 的实例，则此方法不可用（参见[§29.7.3
    “并非所有对象都是 `Object` 的实例”](ch_classes.html#non-instances-of-object)）：
- en: '[PRE98]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'On the other hand, we can’t use `.hasOwnProperty()` if an object overrides
    it with an own property (line A):'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果对象用自有属性覆盖了 `.hasOwnProperty()`，则我们不能使用它（行 A）：
- en: '[PRE99]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'There is, however, a safe way to use `.hasOwnProperty()`:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种安全的方法来使用 `.hasOwnProperty()`：
- en: '[PRE100]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The method invocation in line A is explained in [§29.3.5 “Dispatched vs. direct
    method calls”](ch_classes.html#method-calls-dispatched-direct).
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 行 A 中的方法调用在[§29.3.5 “分派 vs. 直接方法调用”](ch_classes.html#method-calls-dispatched-direct)中有解释。
- en: 'We can also use [`.bind()`](ch_objects.html#methods-bind) to implement `hasOwnProp()`:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用[`.bind()`](ch_objects.html#methods-bind)来实现 `hasOwnProp()`：
- en: '[PRE101]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: How does this work? When we invoke `.call()` like in line A in the previous
    example, it does exactly what `hasOwnProp()` should do, including avoiding the
    pitfalls. However, if we want to function-call it, we can’t simply extract it,
    we must also ensure that its `this` always has the right value. That’s what `.bind()`
    does.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的？当我们像前面的示例中的行 A 那样调用 `.call()` 时，它确切地执行了 `hasOwnProp()` 应该执行的操作，包括避免陷阱。然而，如果我们想要函数调用它，我们不能简单地提取它，我们还必须确保它的
    `this` 始终具有正确的值。这就是 `.bind()` 的作用。
- en: '![](../Images/4e01a86e5fc2028470dca44da5c2d2aa.png)  **Is it never OK to use
    `Object.prototype` methods via dynamic dispatch?**'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/4e01a86e5fc2028470dca44da5c2d2aa.png) **通过动态分派使用 `Object.prototype`
    方法永远不可以吗？**'
- en: 'In some cases we can be lazy and call `Object.prototype` methods like normal
    methods (without `.call()` or `.bind()`): If we know the receivers and they are
    fixed-layout objects.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可以懒惰地像普通方法一样调用 `Object.prototype` 的方法（不需要 `.call()` 或 `.bind()`）：如果我们知道接收者并且它们是固定布局的对象。
- en: If, on the other hand, we don’t know their receivers and/or they are dictionary
    objects, then we need to take precautions.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们不知道它们的接收者和/或它们是字典对象，那么我们需要采取预防措施。
- en: 29.8.2 `Object.prototype.toString()`
  id: totrans-554
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.8.2 `Object.prototype.toString()`
- en: 'By overriding `.toString()` (in a subclass or an instance), we can configure
    how objects are converted to strings:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重写 `.toString()`（在子类或实例中），我们可以配置对象如何转换为字符串：
- en: '[PRE102]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'For converting objects to strings it’s better to use `String()` because that
    also works with `undefined` and `null`:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象转换为字符串最好使用 `String()`，因为它也适用于 `undefined` 和 `null`：
- en: '[PRE103]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 29.8.3 `Object.prototype.toLocaleString()`
  id: totrans-559
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.8.3 `Object.prototype.toLocaleString()`
- en: '`.toLocaleString()` is a version of `.toString()` that can be configured via
    a locale and often additional options. Any class or instance can implement this
    method. In the standard library, the following classes do:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '`.toLocaleString()` 是 `.toString()` 的一个版本，可以通过区域设置和通常的附加选项进行配置。任何类或实例都可以实现这个方法。在标准库中，以下类可以实现：'
- en: '`Array.prototype.toLocaleString()`'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.toLocaleString()`'
- en: '`Number.prototype.toLocaleString()`'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number.prototype.toLocaleString()`'
- en: '`Date.prototype.toLocaleString()`'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.prototype.toLocaleString()`'
- en: '`TypedArray.prototype.toLocaleString()`'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TypedArray.prototype.toLocaleString()`'
- en: '`BigInt.prototype.toLocaleString()`'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BigInt.prototype.toLocaleString()`'
- en: 'As an example, this is how numbers with decimal fractions are converted to
    string differently, depending on locale (`''fr''` is French, `''en''` is English):'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是十进制小数如何根据区域设置（'fr' 是法语，'en' 是英语）而被转换为不同的字符串的示例：
- en: '[PRE104]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 29.8.4 `Object.prototype.valueOf()`
  id: totrans-568
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.8.4 `Object.prototype.valueOf()`
- en: 'By overriding `.valueOf()` (in a subclass or an instance), we can configure
    how objects are converted to non-string values (often numbers):'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重写 `.valueOf()`（在子类或实例中），我们可以配置对象如何转换为非字符串值（通常是数字）：
- en: '[PRE105]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 29.8.5 `Object.prototype.isPrototypeOf()`
  id: totrans-571
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.8.5 `Object.prototype.isPrototypeOf()`
- en: '`proto.isPrototypeOf(obj)` returns `true` if `proto` is in the prototype chain
    of `obj` and `false` otherwise.'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '`proto.isPrototypeOf(obj)` 如果 `proto` 在 `obj` 的原型链中则返回 `true`，否则返回 `false`。'
- en: '[PRE106]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'This is how to use this method safely (for details see [§29.8.1 “Using `Object.prototype`
    methods safely”](ch_classes.html#using-object-methods-safely)):'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何安全使用这个方法的（详情见[§29.8.1 “安全使用 `Object.prototype` 方法”](ch_classes.html#using-object-methods-safely)）：
- en: '[PRE107]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 29.8.6 `Object.prototype.propertyIsEnumerable()`
  id: totrans-576
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.8.6 `Object.prototype.propertyIsEnumerable()`
- en: '`obj.propertyIsEnumerable(propKey)` returns `true` if `obj` has an own enumerable
    property whose key is `propKey` and `false` otherwise.'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj.propertyIsEnumerable(propKey)` 如果 `obj` 具有一个自有可枚举属性，其键为 `propKey` 则返回
    `true`，否则返回 `false`。'
- en: '[PRE108]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'This is how to use this method safely (for details see [§29.8.1 “Using `Object.prototype`
    methods safely”](ch_classes.html#using-object-methods-safely)):'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何安全使用这个方法的（详情见[§29.8.1 “安全使用 `Object.prototype` 方法”](ch_classes.html#using-object-methods-safely)）：
- en: '[PRE109]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Another safe alternative is to use [property descriptors](ch_objects.html#property-attributes-property-descriptors):'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个安全的替代方法是使用[属性描述符](ch_objects.html#property-attributes-property-descriptors)：
- en: '[PRE110]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 29.8.7 `Object.prototype.__proto__` (accessor)
  id: totrans-583
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.8.7 `Object.prototype.__proto__`（访问器）
- en: 'Property `__proto__` exists in two versions:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 属性 `__proto__` 存在两个版本：
- en: An accessor that all instances of `Object` have.
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有`Object`的实例都有的访问器。
- en: A property of object literals that sets the prototypes of the objects created
    by them.
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象文字的一个属性，它设置了由它们创建的对象的原型。
- en: 'I recommend to avoid the former feature:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议避免前一种特性：
- en: As explained in [§29.8.1 “Using `Object.prototype` methods safely”](ch_classes.html#using-object-methods-safely),
    it doesn’t work with all objects.
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如[§29.8.1 “Using `Object.prototype` methods safely”](ch_classes.html#using-object-methods-safely)中所解释的，它并不适用于所有对象。
- en: The ECMAScript specification has deprecated it and calls it [“optional” and
    “legacy”](https://tc39.es/ecma262/#sec-object.prototype.__proto__).
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript规范已经将其弃用，并称其为“可选的”和“遗留的”(https://tc39.es/ecma262/#sec-object.prototype.__proto__)。
- en: In contrast, `__proto__` in object literals always works and is not deprecated.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，对象文字中的`__proto__`总是有效的，而且没有被弃用。
- en: Read on if you are interested in how the accessor `__proto__` works.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对访问器`__proto__`的工作原理感兴趣，请继续阅读。
- en: '`__proto__` is an accessor of `Object.prototype` that is inherited by all instances
    of `Object`. Implementing it via a class would look like this:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '`__proto__`是`Object.prototype`的一个访问器，它被所有`Object`的实例继承。通过类实现它会像这样：'
- en: '[PRE111]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Since `__proto__` is inherited from `Object.prototype`, we can remove this
    feature by creating an object that doesn’t have `Object.prototype` in its prototype
    chain (see [§29.7.3 “Not all objects are instances of `Object`”](ch_classes.html#non-instances-of-object)):'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`__proto__`是从`Object.prototype`继承的，我们可以通过创建一个不在其原型链中具有`Object.prototype`的对象来移除这个特性（参见[§29.7.3
    “Not all objects are instances of `Object`”](ch_classes.html#non-instances-of-object)）：
- en: '[PRE112]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 29.8.8 `Object.prototype.hasOwnProperty()`
  id: totrans-596
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.8.8 `Object.prototype.hasOwnProperty()`
- en: '![](../Images/0ac255e56dc93a43365d8502301c8688.png)  **Better alternative to
    `.hasOwnProperty()`: `Object.hasOwn()` [ES2022]**'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/0ac255e56dc93a43365d8502301c8688.png)  **Better alternative to
    `.hasOwnProperty()`: `Object.hasOwn()` [ES2022]**'
- en: 'See [§28.9.4 “`Object.hasOwn()`: Is a given property own (non-inherited)? [ES2022]”](ch_objects.html#Object.hasOwn).'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '参见[§28.9.4 “`Object.hasOwn()`: Is a given property own (non-inherited)? [ES2022]”](ch_objects.html#Object.hasOwn)。'
- en: '`obj.hasOwnProperty(propKey)` returns `true` if `obj` has an own (non-inherited)
    property whose key is `propKey` and `false` otherwise.'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj.hasOwnProperty(propKey)`如果`obj`有一个自有的（非继承的）属性，其键是`propKey`，则返回`true`，否则返回`false`。'
- en: '[PRE113]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'This is how to use this method safely (for details see [§29.8.1 “Using `Object.prototype`
    methods safely”](ch_classes.html#using-object-methods-safely)):'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何安全使用这个方法的（详情见[§29.8.1 “Using `Object.prototype` methods safely”](ch_classes.html#using-object-methods-safely)）：
- en: '[PRE114]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '29.9 FAQ: classes'
  id: totrans-603
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.9 常见问题：类
- en: 29.9.1 Why are they called “instance private fields” in this book and not “private
    instance fields”?
  id: totrans-604
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.9.1 为什么在本书中称它们为“实例私有字段”，而不是“私有实例字段”？
- en: 'That is done to highlight how different properties (public slots) and private
    slots are: By changing the order of the adjectives, the words “public” and “field”
    and the words “private” and “field” are always mentioned together.'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了突出不同的属性（公共槽）和私有槽：通过改变形容词的顺序，“public”和“field”以及“private”和“field”这些词总是一起提到。
- en: 29.9.2 Why the identifier prefix `#`? Why not declare private fields via `private`?
  id: totrans-606
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 29.9.2 为什么标识符前缀`#`？为什么不通过`private`声明私有字段？
- en: 'Could private fields be declared via `private` and use normal identifiers?
    Let’s examine what would happen if that were possible:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 私有字段是否可以通过`private`声明并使用普通标识符？让我们来看看如果可能的话会发生什么：
- en: '[PRE115]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Whenever an expression such as `other.value` appears in the body of `MyClass`,
    JavaScript has to decide:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 每当`other.value`这样的表达式出现在`MyClass`的主体中时，JavaScript都必须决定：
- en: Is `.value` a property?
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.value`是一个属性吗？'
- en: Is `.value` a private field?
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.value`是一个私有字段吗？'
- en: 'At compile time, JavaScript doesn’t know if the declaration in line A applies
    to `other` (due to it being an instance of `MyClass`) or not. That leaves two
    options for making the decision:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，JavaScript不知道A行的声明是否适用于`other`（因为它是`MyClass`的一个实例）或者不适用。这留下了两种选择来做决定：
- en: '`.value` is always interpreted as a private field.'
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.value`总是被解释为私有字段。'
- en: 'JavaScript decides at runtime:'
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaScript在运行时决定：
- en: If `other` is an instance of `MyClass`, then `.value` is interpreted as a private
    field.
  id: totrans-615
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`other`是`MyClass`的一个实例，那么`.value`会被解释为私有字段。
- en: Otherwise `.value` is interpreted as a property.
  id: totrans-616
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则`.value`被解释为属性。
- en: 'Both options have downsides:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个选项都有缺点：
- en: With option (1), we can’t use `.value` as a property, anymore – for any object.
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用选项（1），我们不能再将`.value`作为属性使用——对于任何对象都是如此。
- en: With option (2), performance is affected negatively.
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项（2）会对性能产生负面影响。
- en: 'That’s why the name prefix `#` was introduced. The decision is now easy: If
    we use `#`, we want to access a private field. If we don’t, we want to access
    a property.'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么引入了名字前缀`#`。现在决定很容易：如果我们使用`#`，我们想要访问一个私有字段。如果不使用，我们想要访问一个属性。
- en: '`private` works for statically typed languages (such as TypeScript) because
    they know at compile time if `other` is an instance of `MyClass` and can then
    treat `.value` as private or public.'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '`private`适用于静态类型语言（如TypeScript），因为它们在编译时知道`other`是否是`MyClass`的一个实例，然后可以将`.value`视为私有或公共的。'
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz**'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz**'
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[quiz app](ch_quizzes-exercises.html#quizzes)。
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/19)'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '[评论](https://github.com/rauschma/impatient-js/issues/19)'
