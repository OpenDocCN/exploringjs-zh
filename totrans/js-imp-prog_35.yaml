- en: 29 Classes [ES6]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/impatient-js/ch_classes.html](https://exploringjs.com/impatient-js/ch_classes.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '29.1 [Cheat sheet: classes](ch_classes.html#cheat-sheet-classes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.2 [The essentials of classes](ch_classes.html#classes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.2.1 [A class for persons](ch_classes.html#a-class-for-persons)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.2.2 [Class expressions](ch_classes.html#class-expressions)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.2.3 [The `instanceof` operator](ch_classes.html#the-instanceof-operator)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.2.4 [Public slots (properties) vs. private slots](ch_classes.html#private-slots)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.2.5 [Private slots in more detail [ES2022] (advanced)](ch_classes.html#private-slots-in-more-detail-es2022-advanced)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.2.6 [The pros and cons of classes in JavaScript](ch_classes.html#the-pros-and-cons-of-classes-in-javascript)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.2.7 [Tips for using classes](ch_classes.html#tips-for-using-classes)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.3 [The internals of classes](ch_classes.html#internals-of-classes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.3.1 [A class is actually two connected objects](ch_classes.html#a-class-is-actually-two-connected-objects)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.3.2 [Classes set up the prototype chains of their instances](ch_classes.html#classes-set-up-the-prototype-chains-of-their-instances)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.3.3 [`.__proto__` vs. `.prototype`](ch_classes.html#proto__-vs.-.prototype)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.3.4 [`Person.prototype.constructor` (advanced)](ch_classes.html#person.prototype.constructor-advanced)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.3.5 [Dispatched vs. direct method calls (advanced)](ch_classes.html#method-calls-dispatched-direct)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.3.6 [Classes evolved from ordinary functions (advanced)](ch_classes.html#classes-evolved-from-ordinary-functions-advanced)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.4 [Prototype members of classes](ch_classes.html#prototype-members-of-classes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.4.1 [Public prototype methods and accessors](ch_classes.html#public-prototype-methods-and-accessors)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.4.2 [Private methods and accessors [ES2022]](ch_classes.html#private-methods-accessors)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.5 [Instance members of classes [ES2022]](ch_classes.html#instance-members-of-classes-es2022)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.5.1 [Instance public fields](ch_classes.html#instance-public-fields)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.5.2 [Instance private fields](ch_classes.html#instance-private-fields)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.5.3 [Private instance data before ES2022 (advanced)](ch_classes.html#private-instance-data-before-es2022-advanced)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.5.4 [Simulating protected visibility and friend visibility via WeakMaps (advanced)](ch_classes.html#instance-protected-fields)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.6 [Static members of classes](ch_classes.html#static-members-of-classes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.6.1 [Static public methods and accessors](ch_classes.html#static-public-methods-and-accessors)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.6.2 [Static public fields [ES2022]](ch_classes.html#static-public-fields)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.6.3 [Static private methods, accessors, and fields [ES2022]](ch_classes.html#static-private-methods-accessors-fields)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.6.4 [Static initialization blocks in classes [ES2022]](ch_classes.html#class-static-initialization-blocks)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '29.6.5 [Pitfall: Using `this` to access static private fields](ch_classes.html#this-and-static-private-fields)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.6.6 [All members (static, prototype, instance) can access all private members](ch_classes.html#all-members-static-prototype-instance-can-access-all-private-members)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.6.7 [Static private methods and data before ES2022](ch_classes.html#static-private-methods-and-data-before-es2022)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.6.8 [Static factory methods](ch_classes.html#static-factory-methods)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.7 [Subclassing](ch_classes.html#subclassing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.7.1 [The internals of subclassing (advanced)](ch_classes.html#the-internals-of-subclassing-advanced)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.7.2 [`instanceof` and subclassing (advanced)](ch_classes.html#instanceof-operator)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.7.3 [Not all objects are instances of `Object` (advanced)](ch_classes.html#non-instances-of-object)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.7.4 [Prototype chains of built-in objects (advanced)](ch_classes.html#prototype-chains-of-built-ins)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.7.5 [Mixin classes (advanced)](ch_classes.html#mixin-classes-advanced)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.8 [The methods and accessors of `Object.prototype` (advanced)](ch_classes.html#Object.prototype-methods)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.8.1 [Using `Object.prototype` methods safely](ch_classes.html#using-object-methods-safely)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.8.2 [`Object.prototype.toString()`](ch_classes.html#Object.prototype.toString)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.8.3 [`Object.prototype.toLocaleString()`](ch_classes.html#Object.prototype.toLocaleString)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.8.4 [`Object.prototype.valueOf()`](ch_classes.html#Object.prototype.valueOf)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.8.5 [`Object.prototype.isPrototypeOf()`](ch_classes.html#Object.prototype.isPrototypeOf)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.8.6 [`Object.prototype.propertyIsEnumerable()`](ch_classes.html#Object.prototype.propertyIsEnumerable)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.8.7 [`Object.prototype.__proto__` (accessor)](ch_classes.html#Object.prototype.__proto__)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.8.8 [`Object.prototype.hasOwnProperty()`](ch_classes.html#Object.prototype.hasOwnProperty)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '29.9 [FAQ: classes](ch_classes.html#faq-classes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.9.1 [Why are they called “instance private fields” in this book and not “private
    instance fields”?](ch_classes.html#why-are-they-called-instance-private-fields-in-this-book-and-not-private-instance-fields)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.9.2 [Why the identifier prefix `#`? Why not declare private fields via `private`?](ch_classes.html#why-the-identifier-prefix-why-not-declare-private-fields-via-private)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, JavaScript’s style of object-oriented programming (OOP) is introduced
    in four steps. This chapter covers step 3 and 4, [the previous chapter](ch_objects.html)
    covers step 1 and 2\. The steps are (fig. [12](#fig:oop_steps_3_4)):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single objects (previous chapter):** How do *objects*, JavaScript’s basic
    OOP building blocks, work in isolation?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Prototype chains (previous chapter):** Each object has a chain of zero or
    more *prototype objects*. Prototypes are JavaScript’s core inheritance mechanism.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Classes (this chapter):** JavaScript’s *classes* are factories for objects.
    The relationship between a class and its instances is based on prototypal inheritance
    (step 2).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Subclassing (this chapter):** The relationship between a *subclass* and its
    *superclass* is also based on prototypal inheritance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12: This book introduces object-oriented programming in JavaScript
    in four steps.](../Images/1cbbf21bc1415ec3aaec2ea35fe128e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12: This book introduces object-oriented programming in JavaScript in
    four steps.'
  prefs: []
  type: TYPE_NORMAL
- en: '29.1 Cheat sheet: classes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Superclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Notes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.#firstName` is a *private field* and must be declared (line A) before it
    can be initialized (line B).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A private field can only be accessed inside its surrounding class. It can’t
    even be accessed by subclasses.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.title` is a property and can be initialized without a prior declaration (line
    C). JavaScript relatively often makes instance data public (in contrast to, e.g.,
    Java that prefers to hide it).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.2 The essentials of classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes are basically a compact syntax for setting up prototype chains (which
    are explained in [the previous chapter](ch_objects.html#prototype-chains)). Under
    the hood, JavaScript’s classes are unconventional. But that is something we rarely
    see when working with them. They should normally feel familiar to people who have
    used other object-oriented programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we don’t need classes to create objects. We can also do so via [object
    literals](ch_objects.html#object-literals). That’s why the singleton pattern isn’t
    needed in JavaScript and classes are used less than in many other languages that
    have them.
  prefs: []
  type: TYPE_NORMAL
- en: 29.2.1 A class for persons
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[We have previously worked with `jane` and `tarzan`, single objects representing
    persons](ch_objects.html#sharing-data-via-prototypes). Let’s use a *class declaration*
    to implement a factory for such objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`jane` and `tarzan` can now be created via `new Person()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let’s examine what’s inside the body of class `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: '`.constructor()` is a special method that is called after the creation of a
    new instance. Inside it, `this` refers to that instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES2022] `.#firstName` is an *instance private field*: Such fields are stored
    in instances. They are accessed similarly to properties, but their names are separate
    – they always start with hash symbols (`#`). And they are invisible to the world
    outside the class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before we can initialize `.#firstName` in the constructor (line B), we need
    to declare it by mentioning it in the class body (line A).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.describe()` is a method. If we invoke it via `obj.describe()` then `this`
    refers to `obj` inside the body of `.describe()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.extractName()` is a *static* method. “Static” means that it belongs to the
    class, not to instances:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also create instance properties (public fields) in constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In contrast to instance private fields, instance properties don’t have to be
    declared in class bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 29.2.2 Class expressions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two kinds of *class definitions* (ways of defining classes):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Class declarations*, which we have seen in the previous section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Class expressions*, which we’ll see next.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Class expressions can be anonymous and named:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The name of a named class expression works similarly to [the name of a named
    function expression](ch_callables.html#named-function-expressions): It can only
    be accessed inside the body of a class and stays the same, regardless of what
    the class is assigned to.'
  prefs: []
  type: TYPE_NORMAL
- en: 29.2.3 The `instanceof` operator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `instanceof` operator tells us if a value is an instance of a given class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We’ll explore the `instanceof` operator in more detail [later](ch_classes.html#instanceof-operator),
    after we have looked at subclassing.
  prefs: []
  type: TYPE_NORMAL
- en: 29.2.4 Public slots (properties) vs. private slots
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the JavaScript language, objects can have two kinds of “slots”.
  prefs: []
  type: TYPE_NORMAL
- en: '*Public slots* (which are are also called *properties*). For example, methods
    are public slots.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Private slots* [ES2022]. For example, private fields are private slots.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the most important rules we need to know about properties and private
    slots:'
  prefs: []
  type: TYPE_NORMAL
- en: In classes, we can use public and private versions of fields, methods, getters
    and setters. All of them are slots in objects. Which objects they are placed in
    depends on whether the keyword `static` is used and other factors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A getter and a setter that have the same key create a single *accessor* slot.
    An Accessor can also have only a getter or only a setter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Properties and private slots are very different – for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are stored separately.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Their keys are different. The keys of private slots can’t even be accessed directly
    (see [§29.2.5.2 “Each private slot has a unique key (a *private name*)”](ch_classes.html#private-names)
    later in this chapter).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties are inherited from prototypes, private slots aren’t.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Private slots can only be created via classes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **More information on
    properties and private slots**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter doesn’t cover all details of properties and private slots (just
    the essentials). If you want to dig deeper, you can do so here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[§28.8.1 “Property attributes and property descriptors [ES5]”](ch_objects.html#property-attributes-property-descriptors)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Section [“Object Internal Methods and Internal Slots”](https://tc39.es/ecma262/#sec-object-internal-methods-and-internal-slots)
    in the ECMAScript language specification explains how private slots work. Search
    for “`[[PrivateElements]]`”.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following class demonstrates the two kinds of slots. Each of its instances
    has one private field and one property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, outside `MyClass`, we can only see the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’ll look at some of the details of private slots.
  prefs: []
  type: TYPE_NORMAL
- en: 29.2.5 Private slots in more detail [ES2022] (advanced)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 29.2.5.1 Private slots can’t be accessed in subclasses
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A private slot really can only be accessed inside the body of its class. We
    can’t even access it from a subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[Subclassing via `extends`](ch_classes.html#subclassing) is explained later
    in this chapter. How to work around this limitation is explained in [§29.5.4 “Simulating
    protected visibility and friend visibility via WeakMaps”](ch_classes.html#instance-protected-fields).'
  prefs: []
  type: TYPE_NORMAL
- en: 29.2.5.2 Each private slot has a unique key (a *private name*)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Private slots have unique keys that are similar to [symbols](ch_symbols.html).
    Consider the following class from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Internally, the private field of `MyClass` is handled roughly like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The value of `instancePrivateFieldKey` is called a *private name*. We can’t
    use private names directly in JavaScript, we can only use them indirectly, via
    the fixed identifiers of private fields, private methods, and private accessors.
    Where the fixed identifiers of public slots (such as `getInstanceValues`) are
    interpreted as string keys, the fixed identifiers of private slots (such as `#instancePrivateField`)
    refer to private names (similarly to how variable names refer to values).
  prefs: []
  type: TYPE_NORMAL
- en: 29.2.5.3 The same private identifier refers to different private names in different
    classes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Because the identifiers of private slots aren’t used as keys, using the same
    identifier in different classes produces different slots (line A and line C):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 29.2.5.4 The names of private fields never clash
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Even if a subclass uses the same name for a private field, the two names never
    clash because they refer to private names (which are always unique). In the following
    example, `.#privateField` in `SuperClass` does not clash with `.#privateField`
    in `SubClass`, even though both slots are stored directly in `inst`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[Subclassing via `extends`](ch_classes.html#subclassing) is explained later
    in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 29.2.5.5 Using `in` to check if an object has a given private slot
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `in` operator can be used to check if a private slot exists (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at more examples of `in` applied to private slots.
  prefs: []
  type: TYPE_NORMAL
- en: '**Private methods.** The following code shows that private methods create private
    slots in instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Static private fields.** We can also use `in` for a static private field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Static private methods.** And we can check for the slot of a static private
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Using the same private identifier in different classes.** In the next example,
    the two classes `Color` and `Person` both have a slot whose identifier is `#name`.
    The `in` operator distinguishes them correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 29.2.6 The pros and cons of classes in JavaScript
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I recommend using classes for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes are a common standard for object creation and inheritance that is now
    widely supported across libraries and frameworks. This is an improvement compared
    to how things were before, when almost every framework had its own inheritance
    library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They help tools such as IDEs and type checkers with their work and enable new
    features there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you come from another language to JavaScript and are used to classes, then
    you can get started more quickly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript engines optimize them. That is, code that uses classes is almost
    always faster than code that uses a custom inheritance library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can subclass built-in constructor functions such as `Error`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That doesn’t mean that classes are perfect:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a risk of overdoing inheritance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a risk of putting too much functionality in classes (when some of it
    is often better put in functions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes look familiar to programmers coming from other languages, but they work
    differently and are used differently (see next subsection). Therefore, there is
    a risk of those programmers writing code that doesn’t feel like JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How classes seem to work superficially is quite different from how they actually
    work. In other words, there is a disconnect between syntax and semantics. Two
    examples are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method definition inside a class `C` creates a method in the object `C.prototype`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes are functions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The motivation for the disconnect is backward compatibility. Thankfully, the
    disconnect causes few problems in practice; we are usually OK if we go along with
    what classes pretend to be.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This was a first look at classes. We’ll explore more features soon.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Writing a
    class**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/classes/point_class_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: 29.2.7 Tips for using classes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use inheritance sparingly – it tends to make code more complicated and spread
    out related functionality across multiple locations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead of static members, it is often better to use external functions and
    variables. We can even make those private to a module, simply by not exporting
    them. Two important exceptions to this rule are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations that need access to private slots
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Static factory methods](ch_classes.html#static-factory-methods)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Only put core functionality in prototype methods. Other functionality is better
    implemented via functions – especially algorithms that involve instances of multiple
    classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.3 The internals of classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 29.3.1 A class is actually two connected objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Under the hood, a class becomes two connected objects. Let’s revisit class
    `Person` to see how that works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The first object created by the class is stored in `Person`. It has four properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The two remaining properties are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Person.extractNames` is the static method that we have already seen in action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Person.prototype` points to the second object that is created by a class definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the contents of `Person.prototype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Person.prototype.constructor` points to the constructor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Person.prototype.describe` is the method that we have already used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.3.2 Classes set up the prototype chains of their instances
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The object `Person.prototype` is the prototype of all instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'That explains how the instances get their methods: They inherit them from the
    object `Person.prototype`.'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. [13](#fig:oo_person_class) visualizes how everything is connected.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13: The class Person has the property .prototype that points to an
    object that is the prototype of all instances of Person. The objects jane and
    tarzan are two such instances.](../Images/c08fdf88503c70cdc845305d06d0c55a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13: The class `Person` has the property `.prototype` that points to
    an object that is the prototype of all instances of `Person`. The objects `jane`
    and `tarzan` are two such instances.'
  prefs: []
  type: TYPE_NORMAL
- en: 29.3.3 `.__proto__` vs. `.prototype`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It is easy to confuse `.__proto__` and `.prototype`. Hopefully, fig. [13](#fig:oo_person_class)
    makes it clear how they differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`.__proto__`](ch_classes.html#Object.prototype.__proto__) is an accessor of
    class `Object` that lets us get and set the prototypes of its instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.prototype` is a normal property like any other. It is only special because
    the `new` operator uses its value as the prototype of instances. Its name is not
    ideal. A different name such as `.instancePrototype` would be more fitting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.3.4 `Person.prototype.constructor` (advanced)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There is one detail in fig. [13](#fig:oo_person_class) that we haven’t looked
    at, yet: `Person.prototype.constructor` points back to `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This setup exists due to backward compatibility. But it has two additional benefits.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, each instance of a class inherits property `.constructor`. Therefore,
    given an instance, we can make “similar” objects via it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we can get the name of the class that created a given instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 29.3.5 Dispatched vs. direct method calls (advanced)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this subsection, we learn about two different ways of invoking methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Dispatched method calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Direct method calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding both of them will give us important insights into how methods
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll also need the second way [later](ch_classes.html#using-object-methods-safely)
    in this chapter: It will allow us to borrow useful methods from `Object.prototype`.'
  prefs: []
  type: TYPE_NORMAL
- en: 29.3.5.1 Dispatched method calls
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s examine how method calls work with classes. We are revisiting `jane`
    from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Fig. [14](#fig:jane_proto_chain) has a diagram with `jane`’s prototype chain.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14: The prototype chain of jane starts with jane and continues with
    Person.prototype.](../Images/e78cd85588d30424a17c527acfb55b69.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14: The prototype chain of `jane` starts with `jane` and continues with
    `Person.prototype`.'
  prefs: []
  type: TYPE_NORMAL
- en: Normal method calls are *dispatched* – the method call
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'happens in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dispatch: JavaScript traverses the prototype chain starting with `jane` to
    find the first object that has an own property with the key `''describe''`: It
    first looks at `jane` and doesn’t find an own property `.describe`. It continues
    with `jane`’s prototype, `Person.prototype` and finds an own property `describe`
    whose value it returns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Invocation: Method-invoking a value is different from function-invoking a value
    in that it not only calls what comes before the parentheses with the arguments
    inside the parentheses but also sets `this` to the receiver of the method call
    (in this case, `jane`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This way of dynamically looking for a method and invoking it is called *dynamic
    dispatch*.
  prefs: []
  type: TYPE_NORMAL
- en: 29.3.5.2 Direct method calls
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can also make method calls *directly*, without dispatching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This time, we directly point to the method via `Person.prototype.describe` and
    don’t search for it in the prototype chain. We also specify `this` differently
    – via `.call()`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **`this` always points
    to the instance**'
  prefs: []
  type: TYPE_NORMAL
- en: No matter where in the prototype chain of an instance a method is located, `this`
    always points to the instance (the beginning of the prototype chain). That enables
    `.describe()` to access `.#firstName` in the example.
  prefs: []
  type: TYPE_NORMAL
- en: 'When are direct method calls useful? Whenever we want to borrow a method from
    elsewhere that a given object doesn’t have – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 29.3.6 Classes evolved from ordinary functions (advanced)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before ECMAScript 6, JavaScript didn’t have classes. Instead, [ordinary functions](ch_callables.html#ordinary-functions)
    were used as *constructor functions*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Classes provide better syntax for this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Subclassing is especially tricky with constructor functions. Classes also offer
    benefits that go beyond more convenient syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: Built-in constructor functions such as `Error` can be subclassed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can access overridden properties via `super`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes can’t be function-called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods can’t be `new`-called and don’t have the property `.prototype`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for private instance data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Classes are so compatible with constructor functions that they can even extend
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`extends` and subclassing are explained [later in this chapter](ch_classes.html#subclassing).'
  prefs: []
  type: TYPE_NORMAL
- en: 29.3.6.1 A class is the constructor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This brings us to an interesting insight. On one hand, `StringBuilderClass`
    refers to its constructor via `StringBuilderClass.prototype.constructor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the class *is* the constructor (a function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **Constructor (functions)
    vs. classes**'
  prefs: []
  type: TYPE_NORMAL
- en: Due to how similar they are, I use the terms *constructor (function)* and *class*
    interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: 29.4 Prototype members of classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 29.4.1 Public prototype methods and accessors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All members in the body of the following class declaration create properties
    of `PublicProtoClass.prototype`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 29.4.1.1 All kinds of public prototype methods and accessors (advanced)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Quoted and computed keys can also be used in object literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[§28.7.1 “Quoted keys in object literals”](ch_objects.html#object-literals-quoted-keys)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[§28.7.2 “Computed keys in object literals”](ch_objects.html#object-literals-computed-keys)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information on accessors (defined via getters and/or setters), generators,
    async methods, and async generator methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[§28.3.6 “Object literals: accessors”](ch_objects.html#object-literal-accessors)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[§38 “Synchronous generators”](ch_sync-generators.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[§41 “Async functions”](ch_async-functions.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[§42.2 “Asynchronous generators”](ch_async-iteration.html#async-generators)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.4.2 Private methods and accessors [ES2022]
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Private methods (and accessors) are an interesting mix of prototype members
    and instance members.
  prefs: []
  type: TYPE_NORMAL
- en: 'On one hand, private methods are stored in slots in instances (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Why are they not stored in `.prototype` objects? Private slots are not inherited,
    only properties are.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, private methods are shared between instances – like prototype
    public methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Due to that and due to their syntax being similar to prototype public methods,
    they are covered here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates how private methods and accessors work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 29.4.2.1 All kinds of private methods and accessors (advanced)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'With private slots, the keys are always identifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'More information on accessors (defined via getters and/or setters), generators,
    async methods, and async generator methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[§28.3.6 “Object literals: accessors”](ch_objects.html#object-literal-accessors)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[§38 “Synchronous generators”](ch_sync-generators.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[§41 “Async functions”](ch_async-functions.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[§42.2 “Asynchronous generators”](ch_async-iteration.html#async-generators)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.5 Instance members of classes [ES2022]
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 29.5.1 Instance public fields
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Instances of the following class have two instance properties (created in line
    A and line B):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If we create an instance property inside the constructor (line B), we don’t
    need to “declare” it elsewhere. As we have already seen, that is different for
    instance private fields.
  prefs: []
  type: TYPE_NORMAL
- en: Note that instance properties are relatively common in JavaScript; much more
    so than in, e.g., Java, where most instance state is private.
  prefs: []
  type: TYPE_NORMAL
- en: 29.5.1.1 Instance public fields with quoted and computed keys (advanced)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 29.5.1.2 What is the value of `this` in instance public fields? (advanced)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the initializer of a instance public field, `this` refers to the newly created
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 29.5.1.3 When are instance public fields executed? (advanced)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The execution of instance public fields roughly follows these two rules:'
  prefs: []
  type: TYPE_NORMAL
- en: In base classes (classes without superclasses), instance public fields are executed
    immediately before the constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In derived classes (classes with superclasses):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The superclass sets up its instance slots when `super()` is called.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance public fields are executed immediately after `super()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example demonstrates these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`extends` and subclassing are explained [later in this chapter](ch_classes.html#subclassing).'
  prefs: []
  type: TYPE_NORMAL
- en: 29.5.2 Instance private fields
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following class contains two instance private fields (line A and line B):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note that we can only use `.#privateField2` in line C if we declare it in the
    class body.
  prefs: []
  type: TYPE_NORMAL
- en: 29.5.3 Private instance data before ES2022 (advanced)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, we look at two techniques for keeping instance data private.
    Because they don’t rely on classes, we can also use them for objects that were
    created in other ways – e.g., via object literals.
  prefs: []
  type: TYPE_NORMAL
- en: '29.5.3.1 Before ES6: private members via naming conventions'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The first technique makes a property private by prefixing its name with an
    underscore. This doesn’t protect the property in any way; it merely signals to
    the outside: “You don’t need to know about this property.”'
  prefs: []
  type: TYPE_NORMAL
- en: In the following code, the properties `._counter` and `._action` are private.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: With this technique, we don’t get any protection and private names can clash.
    On the plus side, it is easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Private methods work similarly: They are normal methods whose names start with
    underscores.'
  prefs: []
  type: TYPE_NORMAL
- en: '29.5.3.2 ES6 and later: private instance data via WeakMaps'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can also manage private instance data via WeakMaps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How exactly that works is explained [in the chapter on WeakMaps](ch_weakmaps.html#private-data-in-weakmaps).
  prefs: []
  type: TYPE_NORMAL
- en: This technique offers us considerable protection from outside access and there
    can’t be any name clashes. But it is also more complicated to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'We control the visibility of the pseudo-property `_superProp` by controlling
    who has access to it – for example: If the variable exists inside a module and
    isn’t exported, everyone inside the module and no one outside the module can access
    it. In other words: The scope of privacy isn’t the class in this case, it’s the
    module. We could narrow the scope, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This technique doesn’t really support private methods. But module-local functions
    that have access to `_superProp` are the next best thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note that `this` becomes the explicit function parameter `_this` (line A).
  prefs: []
  type: TYPE_NORMAL
- en: 29.5.4 Simulating protected visibility and friend visibility via WeakMaps (advanced)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As previously discussed, instance private fields are only visible inside their
    classes and not even in subclasses. Thus, there is no built-in way to get:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Protected visibility: A class and all of its subclasses can access a piece
    instance data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Friend visibility: A class and its “friends” (designated functions, objects,
    or classes) can access a piece of instance data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the previous subsection, we simulated “module visibility” (everyone inside
    a module has access to a piece of instance data) via WeakMaps. Therefore:'
  prefs: []
  type: TYPE_NORMAL
- en: If we put a class and its subclasses into the same module, we get protected
    visibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we put a class and its friends into the same module, we get friend visibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next example demonstrates protected visibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[Subclassing via `extends`](ch_classes.html#subclassing) is explained later
    in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 29.6 Static members of classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 29.6.1 Static public methods and accessors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All members in the body of the following class declaration create so-called
    *static* properties – properties of `StaticClass` itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 29.6.1.1 All kinds of static public methods and accessors (advanced)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Quoted and computed keys can also be used in object literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[§28.7.1 “Quoted keys in object literals”](ch_objects.html#object-literals-quoted-keys)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[§28.7.2 “Computed keys in object literals”](ch_objects.html#object-literals-computed-keys)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information on accessors (defined via getters and/or setters), generators,
    async methods, and async generator methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[§28.3.6 “Object literals: accessors”](ch_objects.html#object-literal-accessors)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[§38 “Synchronous generators”](ch_sync-generators.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[§41 “Async functions”](ch_async-functions.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[§42.2 “Asynchronous generators”](ch_async-iteration.html#async-generators)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.6.2 Static public fields [ES2022]
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following code demonstrates static public fields. `StaticPublicFieldClass`
    has three of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 29.6.3 Static private methods, accessors, and fields [ES2022]
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following class has two static private slots (line A and line B):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a complete list of all kinds of static private slots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 29.6.4 Static initialization blocks in classes [ES2022]
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To set up instance data via classes, we have two constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Fields*, to create and optionally initialize instance data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Constructors*, blocks of code that are executed every time a new instance
    is created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For static data, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Static fields*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Static blocks* that are executed when a class is created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code demonstrates static blocks (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also execute the code inside the static block after the class (at
    the top level). However, using a static block has two benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: All class-related code is inside the class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code in a static block has access to private slots.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.6.4.1 Rules for static initialization blocks
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The rules for how static initialization blocks work, are relatively simple:'
  prefs: []
  type: TYPE_NORMAL
- en: There can be more than one static block per class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The execution of static blocks is interleaved with the execution of static field
    initializers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The static members of a superclass are executed before the static members of
    a subclass.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code demonstrates these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[Subclassing via `extends`](ch_classes.html#subclassing) is explained later
    in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '29.6.5 Pitfall: Using `this` to access static private fields'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In static public members, we can access static public slots via `this`. Alas,
    we should not use it to access static private slots.
  prefs: []
  type: TYPE_NORMAL
- en: 29.6.5.1 `this` and static public fields
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[Subclassing via `extends`](ch_classes.html#subclassing) is explained later
    in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Static public fields are properties. If we make the method call
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'then `this` points to `SuperClass` and everything works as expected. We can
    also invoke `.getPublicViaThis()` via the subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '`SubClass` inherits `.getPublicViaThis()` from its prototype `SuperClass`.
    `this` points to `SubClass` and things continue to work, because `SubClass` also
    inherits the property `.publicData`.'
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, if we assigned to `this.publicData` in `getPublicViaThis()` and
    invoked it via `SubClass.getPublicViaThis()`, then we would create a new own poperty
    of `SubClass` that (non-destructively) overrides the property inherited from `SuperClass`.
  prefs: []
  type: TYPE_NORMAL
- en: 29.6.5.2 `this` and static private fields
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoking `.getPrivateDataViaThis()` via `SuperClass` works, because `this`
    points to `SuperClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'However, invoking `.getPrivateDataViaThis()` via `SubClass` does not work,
    because `this` now points to `SubClass` and `SubClass` has no static private field
    `.#privateData` (private slots in prototype chains are not inherited):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The workaround is to accesss `.#privateData` directly, via `SuperClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: With static private methods, we are facing the same issue.
  prefs: []
  type: TYPE_NORMAL
- en: 29.6.6 All members (static, prototype, instance) can access all private members
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Every member inside a class can access all other members inside that class
    – both public and private ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, no one outside can access the private members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 29.6.7 Static private methods and data before ES2022
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following code only works in ES2022 – due to every line that has a hash
    symbol (`#`) in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Since private slots only exist once per class, we can move `#secret` and `#getSecretInParens`
    to the scope surrounding the class and use a module to hide them from the world
    outside the module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 29.6.8 Static factory methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes there are multiple ways in which a class can be instantiated. Then
    we can implement *static factory methods* such as `Point.fromPolar()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'I like how descriptive static factory methods are: `fromPolar` describes how
    an instance is created. JavaScript’s standard library also has such factory methods
    – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.from()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.create()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I prefer to either have no static factory methods or *only* static factory
    methods. Things to consider in the latter case:'
  prefs: []
  type: TYPE_NORMAL
- en: One factory method will probably directly call the constructor (but have a descriptive
    name).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to find a way to prevent the constructor being called from outside.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following code, we use a secret token (line A) to prevent the constructor
    being called from outside the current module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 29.7 Subclassing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Classes can also extend existing classes. For example, the following class
    `Employee` extends `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Terminology related to extending:'
  prefs: []
  type: TYPE_NORMAL
- en: Another word for *extending* is *subclassing*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Person` is the superclass of `Employee`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Employee` is the subclass of `Person`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *base class* is a class that has no superclasses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *derived class* is a class that has a superclass.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the `.constructor()` of a derived class, we must call the super-constructor
    via `super()` before we can access `this`. Why is that?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a chain of classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Base class `A`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `B` extends `A`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `C` extends `B`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we invoke `new C()`, `C`’s constructor super-calls `B`’s constructor which
    super-calls `A`’s constructor. Instances are always created in base classes, before
    the constructors of subclasses add their slots. Therefore, the instance doesn’t
    exist before we call `super()` and we can’t access it via `this`, yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that static public slots are inherited. For example, `Employee` inherits
    the static method `.extractNames()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Subclassing**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/classes/color_point_class_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: 29.7.1 The internals of subclassing (advanced)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '![Figure 15: These are the objects that make up class Person and its subclass,
    Employee. The left column is about classes. The right column is about the Employee
    instance jane and its prototype chain.](../Images/2f7f76cfc1a6bab2586a13f8db175cd7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15: These are the objects that make up class `Person` and its subclass,
    `Employee`. The left column is about classes. The right column is about the `Employee`
    instance `jane` and its prototype chain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The classes `Person` and `Employee` from the previous section are made up of
    several objects (fig. [15](#fig:oo_subclassing)). One key insight for understanding
    how these objects are related is that there are two prototype chains:'
  prefs: []
  type: TYPE_NORMAL
- en: The instance prototype chain, on the right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class prototype chain, on the left.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.7.1.1 The instance prototype chain (right column)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The instance prototype chain starts with `jane` and continues with `Employee.prototype`
    and `Person.prototype`. In principle, the prototype chain ends at this point,
    but we get one more object: `Object.prototype`. This prototype provides services
    to virtually all objects, which is why it is included here, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 29.7.1.2 The class prototype chain (left column)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the class prototype chain, `Employee` comes first, `Person` next. Afterward,
    the chain continues with `Function.prototype`, which is only there because `Person`
    is a function and functions need the services of `Function.prototype`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 29.7.2 `instanceof` and subclassing (advanced)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have not yet learned how `instanceof` really works. How does `instanceof`
    determine if a value `x` is an instance of a class `C` (it can be a direct instance
    of `C` or a direct instance of a subclass of `C`)? It checks if `C.prototype`
    is in the prototype chain of `x`. That is, the following two expressions are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'If we go back to fig. [15](#fig:oo_subclassing), we can confirm that the prototype
    chain does lead us to the following correct answers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `instanceof` always returns `false` if its self-hand side is a primitive
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 29.7.3 Not all objects are instances of `Object` (advanced)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An object (a non-primitive value) is only an instance of `Object` if `Object.prototype`
    is in its prototype chain [(see previous subsection)](ch_classes.html#instanceof-operator).
    Virtually all objects are instances of `Object` – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next example, `obj1` and `obj2` are both objects (line A and line C),
    but they are not instances of `Object` (line B and line D): `Object.prototype`
    is not in their prototype chains because they don’t have any prototypes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '`Object.prototype` is the object that ends most prototype chains. Its prototype
    is `null`, which means it isn’t an instance of `Object` either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 29.7.4 Prototype chains of built-in objects (advanced)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we’ll use our knowledge of subclassing to understand the prototype chains
    of a few built-in objects. The following tool function `p()` helps us with our
    explorations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: We extracted method `.getPrototypeOf()` of `Object` and assigned it to `p`.
  prefs: []
  type: TYPE_NORMAL
- en: 29.7.4.1 The prototype chain of `{}`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s start by examining plain objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 16: The prototype chain of an object created via an object literal
    starts with that object, continues with Object.prototype, and ends with null.](../Images/e6bb1e3280584f9f2a385f54baab341c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16: The prototype chain of an object created via an object literal starts
    with that object, continues with `Object.prototype`, and ends with `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. [16](#fig:proto_chain_object) shows a diagram for this prototype chain.
    We can see that `{}` really is an instance of `Object` – `Object.prototype` is
    in its prototype chain.
  prefs: []
  type: TYPE_NORMAL
- en: 29.7.4.2 The prototype chain of `[]`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: What does the prototype chain of an Array look like?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 17: The prototype chain of an Array has these members: the Array instance,
    Array.prototype, Object.prototype, null.](../Images/b5d54f0b878da14e43c748ac3f704302.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17: The prototype chain of an Array has these members: the Array instance,
    `Array.prototype`, `Object.prototype`, `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: This prototype chain (visualized in fig. [17](#fig:proto_chain_array)) tells
    us that an Array object is an instance of `Array` and of `Object`.
  prefs: []
  type: TYPE_NORMAL
- en: 29.7.4.3 The prototype chain of `function () {}`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Lastly, the prototype chain of an ordinary function tells us that all functions
    are objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 29.7.4.4 The prototype chains of built-in classes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The prototype of a base class is `Function.prototype` which means that it is
    a function (an instance of `Function`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The prototype of a derived class is its superclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, `Object`, `Array`, and `Function` are all base classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: However, as we have seen, even the instances of base classes have `Object.prototype`
    in their prototype chains because it provides services that all objects need.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **Why are `Array` and
    `Function` base classes?**'
  prefs: []
  type: TYPE_NORMAL
- en: Base classes are where instances are actually created. Both `Array` and `Function`
    need to create their own instances because they have so-called “internal slots”
    which can’t be added later to instances created by `Object`.
  prefs: []
  type: TYPE_NORMAL
- en: 29.7.5 Mixin classes (advanced)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'JavaScript’s class system only supports *single inheritance*. That is, each
    class can have at most one superclass. One way around this limitation is via a
    technique called *mixin classes* (short: *mixins*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is as follows: Let’s say we want a class `C` to inherit from two superclasses
    `S1` and `S2`. That would be *multiple inheritance*, which JavaScript doesn’t
    support.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our workaround is to turn `S1` and `S2` into *mixins*, factories for subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these two functions returns a class that extends a given superclass
    `Sup`. We create class `C` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: We now have a class `C` that extends the class returned by `S2()` which extends
    the class returned by `S1()` which extends `Object`.
  prefs: []
  type: TYPE_NORMAL
- en: '29.7.5.1 Example: a mixin for brand management'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We implement a mixin `Branded` that has helper methods for setting and getting
    the brand of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We use this mixin to implement a class `City` that has a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code confirms that the mixin works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 29.7.5.2 The benefits of mixins
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Mixins free us from the constraints of single inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: The same class can extend a single superclass and zero or more mixins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same mixin can be used by multiple classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 29.8 The methods and accessors of `Object.prototype` (advanced)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we have seen in [§29.7.3 “Not all objects are instances of `Object`”](ch_classes.html#non-instances-of-object),
    almost all objects are instances of `Object`. This class provides several useful
    methods and an accessor to its instances:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuring how objects are converted to primitive values (e.g. by the `+`
    operator): The following methods have default implementations but are often overridden
    in subclasses or instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`.toString()`](ch_classes.html#Object.prototype.toString): Configures how
    an object is converted to a string.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`.toLocaleString()`](ch_classes.html#Object.prototype.toLocaleString): A version
    of `.toString()` that can be configured in various ways via arguments (language,
    region, etc.).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`.valueOf()`](ch_classes.html#Object.prototype.valueOf): Configures how an
    object is converted to a non-string primitive value (often a number).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Useful methods (with pitfalls – see next subsection):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`.isPrototypeOf()`](ch_classes.html#Object.prototype.isPrototypeOf): Is the
    receiver in the prototype chain of a given object?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`.propertyIsEnumerable()`](ch_classes.html#Object.prototype.propertyIsEnumerable):
    Does the receiver have an enumerable own property with the given key?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Avoid these features (there are better alternatives):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`.__proto__`](ch_classes.html#Object.prototype.__proto__): Get and set the
    prototype of the receiver.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using this accessor is not recommended. Alternatives:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.getPrototypeOf()`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.setPrototypeOf()`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`.hasOwnProperty()`](ch_classes.html#Object.prototype.hasOwnProperty): Does
    the receiver have an own property with a given key?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using this method is not recommended. Alternative in ES2022 and later: `Object.hasOwn()`.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we take a closer look at each of these features, we’ll learn about an
    important pitfall (and how to work around it): We can’t use the features of `Object.prototype`
    with all objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 29.8.1 Using `Object.prototype` methods safely
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Invoking one of the methods of `Object.prototype` on an arbitrary object doesn’t
    always work. To illustrate why, we use method `Object.prototype.hasOwnProperty`,
    which returns `true` if an object has an own property with a given key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoking `.hasOwnProperty()` on an arbitrary object can fail in two ways. On
    one hand, this method isn’t available if an object is not an instance of `Object`
    (see [§29.7.3 “Not all objects are instances of `Object`”](ch_classes.html#non-instances-of-object)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, we can’t use `.hasOwnProperty()` if an object overrides
    it with an own property (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'There is, however, a safe way to use `.hasOwnProperty()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The method invocation in line A is explained in [§29.3.5 “Dispatched vs. direct
    method calls”](ch_classes.html#method-calls-dispatched-direct).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use [`.bind()`](ch_objects.html#methods-bind) to implement `hasOwnProp()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: How does this work? When we invoke `.call()` like in line A in the previous
    example, it does exactly what `hasOwnProp()` should do, including avoiding the
    pitfalls. However, if we want to function-call it, we can’t simply extract it,
    we must also ensure that its `this` always has the right value. That’s what `.bind()`
    does.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4e01a86e5fc2028470dca44da5c2d2aa.png)  **Is it never OK to use
    `Object.prototype` methods via dynamic dispatch?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases we can be lazy and call `Object.prototype` methods like normal
    methods (without `.call()` or `.bind()`): If we know the receivers and they are
    fixed-layout objects.'
  prefs: []
  type: TYPE_NORMAL
- en: If, on the other hand, we don’t know their receivers and/or they are dictionary
    objects, then we need to take precautions.
  prefs: []
  type: TYPE_NORMAL
- en: 29.8.2 `Object.prototype.toString()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'By overriding `.toString()` (in a subclass or an instance), we can configure
    how objects are converted to strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'For converting objects to strings it’s better to use `String()` because that
    also works with `undefined` and `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 29.8.3 `Object.prototype.toLocaleString()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`.toLocaleString()` is a version of `.toString()` that can be configured via
    a locale and often additional options. Any class or instance can implement this
    method. In the standard library, the following classes do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.toLocaleString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number.prototype.toLocaleString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.prototype.toLocaleString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypedArray.prototype.toLocaleString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BigInt.prototype.toLocaleString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, this is how numbers with decimal fractions are converted to
    string differently, depending on locale (`''fr''` is French, `''en''` is English):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 29.8.4 `Object.prototype.valueOf()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'By overriding `.valueOf()` (in a subclass or an instance), we can configure
    how objects are converted to non-string values (often numbers):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 29.8.5 `Object.prototype.isPrototypeOf()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`proto.isPrototypeOf(obj)` returns `true` if `proto` is in the prototype chain
    of `obj` and `false` otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how to use this method safely (for details see [§29.8.1 “Using `Object.prototype`
    methods safely”](ch_classes.html#using-object-methods-safely)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 29.8.6 `Object.prototype.propertyIsEnumerable()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`obj.propertyIsEnumerable(propKey)` returns `true` if `obj` has an own enumerable
    property whose key is `propKey` and `false` otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how to use this method safely (for details see [§29.8.1 “Using `Object.prototype`
    methods safely”](ch_classes.html#using-object-methods-safely)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Another safe alternative is to use [property descriptors](ch_objects.html#property-attributes-property-descriptors):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 29.8.7 `Object.prototype.__proto__` (accessor)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Property `__proto__` exists in two versions:'
  prefs: []
  type: TYPE_NORMAL
- en: An accessor that all instances of `Object` have.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A property of object literals that sets the prototypes of the objects created
    by them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I recommend to avoid the former feature:'
  prefs: []
  type: TYPE_NORMAL
- en: As explained in [§29.8.1 “Using `Object.prototype` methods safely”](ch_classes.html#using-object-methods-safely),
    it doesn’t work with all objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ECMAScript specification has deprecated it and calls it [“optional” and
    “legacy”](https://tc39.es/ecma262/#sec-object.prototype.__proto__).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In contrast, `__proto__` in object literals always works and is not deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: Read on if you are interested in how the accessor `__proto__` works.
  prefs: []
  type: TYPE_NORMAL
- en: '`__proto__` is an accessor of `Object.prototype` that is inherited by all instances
    of `Object`. Implementing it via a class would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `__proto__` is inherited from `Object.prototype`, we can remove this
    feature by creating an object that doesn’t have `Object.prototype` in its prototype
    chain (see [§29.7.3 “Not all objects are instances of `Object`”](ch_classes.html#non-instances-of-object)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 29.8.8 `Object.prototype.hasOwnProperty()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '![](../Images/0ac255e56dc93a43365d8502301c8688.png)  **Better alternative to
    `.hasOwnProperty()`: `Object.hasOwn()` [ES2022]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'See [§28.9.4 “`Object.hasOwn()`: Is a given property own (non-inherited)? [ES2022]”](ch_objects.html#Object.hasOwn).'
  prefs: []
  type: TYPE_NORMAL
- en: '`obj.hasOwnProperty(propKey)` returns `true` if `obj` has an own (non-inherited)
    property whose key is `propKey` and `false` otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how to use this method safely (for details see [§29.8.1 “Using `Object.prototype`
    methods safely”](ch_classes.html#using-object-methods-safely)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '29.9 FAQ: classes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 29.9.1 Why are they called “instance private fields” in this book and not “private
    instance fields”?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'That is done to highlight how different properties (public slots) and private
    slots are: By changing the order of the adjectives, the words “public” and “field”
    and the words “private” and “field” are always mentioned together.'
  prefs: []
  type: TYPE_NORMAL
- en: 29.9.2 Why the identifier prefix `#`? Why not declare private fields via `private`?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Could private fields be declared via `private` and use normal identifiers?
    Let’s examine what would happen if that were possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever an expression such as `other.value` appears in the body of `MyClass`,
    JavaScript has to decide:'
  prefs: []
  type: TYPE_NORMAL
- en: Is `.value` a property?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is `.value` a private field?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At compile time, JavaScript doesn’t know if the declaration in line A applies
    to `other` (due to it being an instance of `MyClass`) or not. That leaves two
    options for making the decision:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.value` is always interpreted as a private field.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'JavaScript decides at runtime:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `other` is an instance of `MyClass`, then `.value` is interpreted as a private
    field.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise `.value` is interpreted as a property.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both options have downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: With option (1), we can’t use `.value` as a property, anymore – for any object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With option (2), performance is affected negatively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That’s why the name prefix `#` was introduced. The decision is now easy: If
    we use `#`, we want to access a private field. If we don’t, we want to access
    a property.'
  prefs: []
  type: TYPE_NORMAL
- en: '`private` works for statically typed languages (such as TypeScript) because
    they know at compile time if `other` is an instance of `MyClass` and can then
    treat `.value` as private or public.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz**'
  prefs: []
  type: TYPE_NORMAL
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  prefs: []
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/19)'
  prefs: []
  type: TYPE_NORMAL
