- en: 25 Read-only accessibility (readonly etc.)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/ts/book/ch_readonly.html](https://exploringjs.com/ts/book/ch_readonly.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Ad, please don’t block.)
  prefs: []
  type: TYPE_NORMAL
- en: '[25.1 `const` variable declarations: only the binding is immutable](#const-variable-declarations-only-the-binding-is-immutable)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[25.2 Read-only object properties](#read-only-object-properties)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[25.2.1 No change after initialization](#no-change-after-initialization)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[25.2.2 `readonly` doesn’t affect assignability](#readonly-doesn-t-affect-assignability)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[25.2.3 Read-only index signatures](#read-only-index-signatures)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[25.2.4 Utility type `Readonly<T>`](#utility-type-readonly-t)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[25.3 Class properties](#class-properties)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[25.4 Read-only Arrays](#read-only-arrays)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[25.5 Read-only tuples](#read-only-tuples)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[25.6 `ReadonlySet` and `ReadonlyMap`](#readonlyset-and-readonlymap)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[25.7 Const assertions (`as const`)](#const-assertions)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[25.8 Usage recommendations](#usage-recommendations)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[25.8.1 You need `ReadonlyArray` if you want to accept read-only tuples](#you-need-readonlyarray-if-you-want-to-accept-read-only-tuples)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[25.8.2 A downside of using the type `ReadonlyArray`](#a-downside-of-using-the-type-readonlyarray)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[25.9 Further reading](#further-reading-8)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[25.9.1 Sources of this chapter](#sources-of-this-chapter-3)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In this chapter, we look at how can make things “read-only” in TypeScript –
    mainly via the keyword `readonly`.
  prefs: []
  type: TYPE_NORMAL
- en: '[25.1 `const` variable declarations: only the binding is immutable](#const-variable-declarations-only-the-binding-is-immutable)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In JavaScript, if a variable is declared via `const`, the binding becomes immutable
    but not the bound value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript’s read-only accessibility is similar. However, it is only checked
    at compile time; it does not affect the emitted JavaScript in any way.
  prefs: []
  type: TYPE_NORMAL
- en: '[25.2 Read-only object properties](#read-only-object-properties)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use the keyword `readonly` to make object properties immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Making a property immutable has the following consequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[25.2.1 No change after initialization](#no-change-after-initialization)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a property `.count` is read-only, we can initialize it via an object literal
    but not change it afterwards. If we want to change its value, we have to create
    a new object (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This mutating version of `toIncremented()` produces a compile-time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[25.2.2 `readonly` doesn’t affect assignability](#readonly-doesn-t-affect-assignability)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Somewhat surprisingly, `readonly` does not affect assignability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can, however, detect it via type equality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There already is [a pull request](https://github.com/microsoft/TypeScript/pull/58296)
    for the compiler option `--enforceReadonly` which would change this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[25.2.3 Read-only index signatures](#read-only-index-signatures)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In addition to properties, index signatures can also be modified by `readonly`.
    The following built-in type describes Array-like objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Line A is a read-only index signature. One example of `ArrayLike` being used:
    The type of the parameter of `Array.from()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If the index signature is read-only, we can’t use indexed access to change
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[25.2.4 Utility type `Readonly<T>`](#utility-type-readonly-t)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The utility type `Readonly<T>` makes all properties of `T` read-only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[25.3 Class properties](#class-properties)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Classes can also have read-only properties. Those must be initialized directly
    or in the constructor and can’t be changed afterward. That’s why the mutating
    increment `.incMut()` doesn’t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[25.4 Read-only Arrays](#read-only-arrays)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two ways in which, e.g. an Array of strings can be declared to be
    read-only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`ReadonlyArray` is only a type: In contrast to `Array`, it does not exist at
    runtime. This is how we can use this type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We create a normal Array and give it the type `ReadonlyArray<string>`. That’s
    how to make Arrays that are read-only at the type level.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last line, we can see that type `ReadonlyArray` does not only make properties
    and the index signature `readonly` – it is also missing mutating methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to create Arrays that are read-only at runtime, we could use the
    following approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We don’t implement `ReadonlyArray<T>` because we don’t provide indexed access
    via square brackets, only via `.at()`. The former could be done via [Proxies](https://exploringjs.com/deep-js/ch_proxies.html)
    but that would lead to less elegant and performant code.
  prefs: []
  type: TYPE_NORMAL
- en: '[25.5 Read-only tuples](#read-only-tuples)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In normal tuples, we can assign different values to the elements, but not the
    length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If a tuple is read-only, we can’t assign different values to either elements
    or `.length`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We set up the read-only tuple once (at the beginning) and can’t change it later.
    The type of a read-only tuple is a subtype of `ReadonlyArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[25.6 `ReadonlySet` and `ReadonlyMap`](#readonlyset-and-readonlymap)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similar to type `ReadonlyArray` being a read-only version of `Array`, there
    are also read-only versions of `Set` and `Map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we could use `ReadonlySet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a wrapper class that makes a Set read-only at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[25.7 Const assertions (`as const`)](#const-assertions)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The const assertion `as const` is an annotation for values that only affects
    their types. It can be applied to:'
  prefs: []
  type: TYPE_NORMAL
- en: References to enum members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It has two effects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A value with a non-primitive type becomes read-only:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Object: all properties become read-only'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Array: becomes read-only tuple'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The inferred type become narrower – e.g. `'abc'` (not `string`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how objects are affected – note the `readonly` and the narrower type
    (`123` vs. `number`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how Arrays are affected – note the `readonly` and the narrower types
    (`''a''` and `''b''` vs. `string`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Since primitive values are already immutable, `as const` only leads to a narrower
    type being inferred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Switching from `let` to `const` also narrows the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[25.8 Usage recommendations](#usage-recommendations)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[25.8.1 You need `ReadonlyArray` if you want to accept read-only tuples](#you-need-readonlyarray-if-you-want-to-accept-read-only-tuples)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Even though `readonly` does not affect assignability, read-only tuples are a
    subtype of `ReadonlyArray` and therefore not compatible with `Array` because the
    latter type has methods that the former doesn’t have. Let’s examine what that
    means for functions and generic types.
  prefs: []
  type: TYPE_NORMAL
- en: '[25.8.1.1 Functions](#functions)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following function `sum()` can’t be applied to read-only tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[25.8.1.2 Generic types](#generic-types-1)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If a type `T` is constrained to a normal array type then it doesn’t match the
    type of an `as const` literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can change that by switching to `ReadonlyArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[25.8.2 A downside of using the type `ReadonlyArray`](#a-downside-of-using-the-type-readonlyarray)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There is one downside of using the type `ReadonlyArray`: You can’t pass on
    the data to locations that do not use that type (of which there are many) – e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[25.9 Further reading](#further-reading-8)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Chapter [“Protecting objects from being changed”](https://exploringjs.com/js/book/ch_objects.html#protecting-objects)
    in “Exploring JavaScript”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[25.9.1 Sources of this chapter](#sources-of-this-chapter-3)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following sections of the official TypeScript Handbook were sources of
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`readonly` and `const`](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#readonly-and-const)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Utility Types > `Readonly<Type>`](https://www.typescriptlang.org/docs/handbook/utility-types.html#readonlytype)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Class Members > Fields > `readonly`](https://www.typescriptlang.org/docs/handbook/2/classes.html#readonly)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Object Types > Property Modifiers > `readonly` Properties](https://www.typescriptlang.org/docs/handbook/2/objects.html#readonly-properties)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `ReadonlyArray` Type](https://www.typescriptlang.org/docs/handbook/2/objects.html#the-readonlyarray-type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`readonly` Tuple Types](https://www.typescriptlang.org/docs/handbook/2/objects.html#readonly-tuple-types)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
