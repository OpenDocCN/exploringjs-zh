<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>31 Classes ES6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>31 Classes ES6</h1>
<blockquote>原文：<a href="https://exploringjs.com/js/book/ch_classes.html">https://exploringjs.com/js/book/ch_classes.html</a></blockquote>

        
    
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#cheat-sheet-classes">31.1 Cheat sheet: classes</a>
    </li>
    <li>
      <a href="#classes">31.2 The essentials of classes</a>
      <ol>
        <li>
          <a href="#a-class-for-persons">31.2.1 A class for persons</a>
        </li>
        <li>
          <a href="#class-expressions">31.2.2 Class expressions</a>
        </li>
        <li>
          <a href="#the-instanceof-operator">31.2.3 The <code>instanceof</code> operator</a>
        </li>
        <li>
          <a href="#private-slots">31.2.4 Public slots (properties) vs. private slots</a>
        </li>
        <li>
          <a href="#private-slots-in-more-detail-es2022-advanced">31.2.5 Private slots in more detail<span> <sup>ES2022</sup> (advanced)</span></a>
        </li>
        <li>
          <a href="#the-pros-and-cons-of-classes-in-javascript">31.2.6 The pros and cons of classes in JavaScript</a>
        </li>
        <li>
          <a href="#tips-for-using-classes">31.2.7 Tips for using classes</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#internals-of-classes">31.3 The internals of classes</a>
      <ol>
        <li>
          <a href="#a-class-is-actually-two-connected-objects">31.3.1 A class is actually two connected objects</a>
        </li>
        <li>
          <a href="#classes-set-up-the-prototype-chains-of-their-instances">31.3.2 Classes set up the prototype chains of their instances</a>
        </li>
        <li>
          <a href="#proto-vs-prototype">31.3.3 <code>.__proto__</code> vs. <code>.prototype</code></a>
        </li>
        <li>
          <a href="#personprototypeconstructor-advanced">31.3.4 <code>Person.prototype.constructor</code><span> (advanced)</span></a>
        </li>
        <li>
          <a href="#method-calls-dispatched-direct">31.3.5 Dispatched vs. direct method calls<span> (advanced)</span></a>
        </li>
        <li>
          <a href="#classes-evolved-from-ordinary-functions-advanced">31.3.6 Classes evolved from ordinary functions<span> (advanced)</span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#prototype-members-of-classes">31.4 Prototype members of classes</a>
      <ol>
        <li>
          <a href="#public-prototype-methods-and-accessors">31.4.1 Public prototype methods and accessors</a>
        </li>
        <li>
          <a href="#private-methods-accessors">31.4.2 Private methods and accessors<span> <sup>ES2022</sup></span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#instance-members-of-classes-es2022">31.5 Instance members of classes<span> <sup>ES2022</sup></span></a>
      <ol>
        <li>
          <a href="#instance-public-fields">31.5.1 Instance public fields</a>
        </li>
        <li>
          <a href="#instance-private-fields">31.5.2 Instance private fields</a>
        </li>
        <li>
          <a href="#private-instance-data-before-es2022-advanced">31.5.3 Private instance data before ES2022<span> (advanced)</span></a>
        </li>
        <li>
          <a href="#instance-protected-fields">31.5.4 Simulating protected visibility and friend visibility via WeakMaps<span> (advanced)</span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#static-members-of-classes">31.6 Static members of classes</a>
      <ol>
        <li>
          <a href="#static-public-methods-and-accessors">31.6.1 Static public methods and accessors</a>
        </li>
        <li>
          <a href="#static-public-fields">31.6.2 Static public fields<span> <sup>ES2022</sup></span></a>
        </li>
        <li>
          <a href="#static-private-methods-accessors-fields">31.6.3 Static private methods, accessors, and fields<span> <sup>ES2022</sup></span></a>
        </li>
        <li>
          <a href="#class-static-initialization-blocks">31.6.4 Static initialization blocks in classes<span> <sup>ES2022</sup></span></a>
        </li>
        <li>
          <a href="#this-and-static-private-fields">31.6.5 Pitfall: Using <code>this</code> to access static private fields</a>
        </li>
        <li>
          <a href="#all-members-static-prototype-instance-can-access-all-private-members">31.6.6 All members (static, prototype, instance) can access all private members</a>
        </li>
        <li>
          <a href="#static-private-methods-and-data-before-es2022">31.6.7 Static private methods and data before ES2022</a>
        </li>
        <li>
          <a href="#static-factory-methods">31.6.8 Static factory methods</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#subclassing">31.7 Subclassing</a>
      <ol>
        <li>
          <a href="#defining-subclasses-via-extends">31.7.1 Defining subclasses via <code>extends</code></a>
        </li>
        <li>
          <a href="#internals-of-subclassing">31.7.2 The internals of subclassing<span> (advanced)</span></a>
        </li>
        <li>
          <a href="#instanceof-operator-details">31.7.3 The <code>instanceof</code> operator in detail<span> (advanced)</span></a>
        </li>
        <li>
          <a href="#non-instances-of-object">31.7.4 Not all objects are instances of <code>Object</code><span> (advanced)</span></a>
        </li>
        <li>
          <a href="#base-class-vs-derived-class-advanced">31.7.5 Base class vs. derived class<span> (advanced)</span></a>
        </li>
        <li>
          <a href="#prototype-chains-of-builtin-objects">31.7.6 The prototype chains of plain objects and Arrays<span> (advanced)</span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#mixin-classes-advanced">31.8 Mixin classes<span> (advanced)</span></a>
      <ol>
        <li>
          <a href="#example-a-mixin-for-name-management">31.8.1 Example: a mixin for name management</a>
        </li>
        <li>
          <a href="#the-benefits-of-mixins">31.8.2 The benefits of mixins</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#the-methods-and-accessors-of-objectprototype-advanced">31.9 The methods and accessors of <code>Object.prototype</code><span> (advanced)</span></a>
      <ol>
        <li>
          <a href="#using-object-methods-safely">31.9.1 Using <code>Object.prototype</code> methods safely</a>
        </li>
        <li>
          <a href="#Object.prototype.toString">31.9.2 <code>Object.prototype.toString()</code><span> <sup>ES1</sup></span></a>
        </li>
        <li>
          <a href="#Object.prototype.toLocaleString">31.9.3 <code>Object.prototype.toLocaleString()</code><span> <sup>ES3</sup></span></a>
        </li>
        <li>
          <a href="#Object.prototype.valueOf">31.9.4 <code>Object.prototype.valueOf()</code><span> <sup>ES1</sup></span></a>
        </li>
        <li>
          <a href="#Object.prototype.isPrototypeOf">31.9.5 <code>Object.prototype.isPrototypeOf()</code><span> <sup>ES3</sup></span></a>
        </li>
        <li>
          <a href="#Object.prototype.propertyIsEnumerable">31.9.6 <code>Object.prototype.propertyIsEnumerable()</code><span> <sup>ES3</sup></span></a>
        </li>
        <li>
          <a href="#Object.prototype.__proto__">31.9.7 <code>Object.prototype.__proto__</code> (accessor)<span> <sup>ES6</sup></span></a>
        </li>
        <li>
          <a href="#Object.prototype.hasOwnProperty">31.9.8 <code>Object.prototype.hasOwnProperty()</code><span> <sup>ES3</sup></span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#quickref-object-prototype">31.10 Quick reference: <code>Object.prototype.*</code></a>
      <ol>
        <li>
          <a href="#objectprototype-configuring-how-objects-are-converted-to-primitive-values">31.10.1 <code>Object.prototype.*</code>: configuring how objects are converted to primitive values</a>
        </li>
        <li>
          <a href="#objectprototype-useful-methods-with-pitfalls">31.10.2 <code>Object.prototype.*</code>: useful methods with pitfalls</a>
        </li>
        <li>
          <a href="#objectprototype-methods-to-avoid">31.10.3 <code>Object.prototype.*</code>: methods to avoid</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#faq-classes">31.11 FAQ: classes</a>
      <ol>
        <li>
          <a href="#why-are-they-called-instance-private-fields-in-this-book-and-not-private-instance-fields">31.11.1 Why are they called “instance private fields” in this book and not “private instance fields”?</a>
        </li>
        <li>
          <a href="#why-the-identifier-prefix--why-not-declare-private-fields-via-private">31.11.2 Why the identifier prefix <code>#</code>? Why not declare private fields via <code>private</code>?</a>
        </li>
      </ol>
    </li>
  </ol>
</nav>
<p>In this book, JavaScript’s style of object-oriented programming (OOP) is introduced in four steps. This chapter covers step 3 and 4, <a href="ch_objects.html#ch_objects">the previous chapter</a> covers step 1 and 2. The steps are (<a href="#fig:oop_steps_3_4">figure 31.1</a>):</p>
<ol>
  <li>
    <strong>Single objects (previous chapter):</strong> How do <em>objects</em>, JavaScript’s basic OOP building blocks, work in isolation?
  </li>
  <li>
    <strong>Prototype chains (previous chapter):</strong> Each object has a chain of zero or more <em>prototype objects</em>. Prototypes are JavaScript’s core inheritance mechanism.
  </li>
  <li>
    <strong>Classes (this chapter):</strong> JavaScript’s <em>classes</em> are factories for objects. The relationship between a class and its instances is based on prototypal inheritance (step 2).
  </li>
  <li>
    <strong>Subclassing (this chapter):</strong> The relationship between a <em>subclass</em> and its <em>superclass</em> is also based on prototypal inheritance.
  </li>
</ol>
<figure id="fig:oop_steps_3_4" class="float">
  <p><img src="../Images/211f8dccf8d4dc41541fb43a82eac91f.png" alt="" style="width:435.701px; height:183.85075px" data-original-src="https://exploringjs.com/js/book/img/classes/oop_steps_3_4.svg"/></p>
  <figcaption>
    <p><span class="float-label">Figure 31.1:</span> This book introduces object-oriented programming in JavaScript in four steps.</p>
  </figcaption>
</figure>
<h3 id="cheat-sheet-classes"><a class="heading-id-link" href="#cheat-sheet-classes">31.1 Cheat sheet: classes</a></h3>
<p>A JavaScript class:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">firstName</span>) { <span class="hljs-comment">// (A)</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = firstName; <span class="hljs-comment">// (B)</span>
  }
  <span class="hljs-title function_">describe</span>(<span class="hljs-params">) { <span class="hljs-comment">// (C)</span></span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">'Person named '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span>;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-keyword">const</span> tarzan = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'Tarzan'</span>);</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">  tarzan.<span class="hljs-property">firstName</span>, <span class="hljs-string">'Tarzan'</span></span>
<span class="hljs-params">);</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">  tarzan.<span class="hljs-title function_">describe</span>(),</span>
<span class="hljs-params">  <span class="hljs-string">'Person named Tarzan'</span></span>
<span class="hljs-params">);</span>
<span class="hljs-params"><span class="hljs-comment">// One property (public slot)</span></span>
<span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span>
<span class="hljs-params">  <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(tarzan), [<span class="hljs-string">'firstName'</span>]</span>
<span class="hljs-params">);</span>
</pre>
<p>Explanations:</p>
<ul>
  <li>
    Inside a class, <code>this</code> refers to the current instance
  </li>
  <li>
    Line A: constructor of the class
  </li>
  <li>
    Line B: Property <code>.firstName</code> (a public slot) is created (no prior declaration necessary).
  </li>
  <li>
    Line C: method <code>.describe()</code>
  </li>
</ul>
<p>Public instance data such as <code>.firstName</code> is relatively common in JavaScript.</p>
<p>The same class <code>Person</code>, but with private instance data:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  #firstName; <span class="hljs-comment">// (A)</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">firstName</span>) {
    <span class="hljs-variable language_">this</span>.#firstName = firstName; <span class="hljs-comment">// (B)</span>
  }
  <span class="hljs-title function_">describe</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">'Person named '</span> + <span class="hljs-variable language_">this</span>.#firstName;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-keyword">const</span> tarzan = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'Tarzan'</span>);</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">  tarzan.<span class="hljs-title function_">describe</span>(),</span>
<span class="hljs-params">  <span class="hljs-string">'Person named Tarzan'</span></span>
<span class="hljs-params">);</span>
<span class="hljs-params"><span class="hljs-comment">// No properties, only a private field</span></span>
<span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span>
<span class="hljs-params">  <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(tarzan), []</span>
<span class="hljs-params">);</span>
</pre>
<p>Explanations:</p>
<ul>
  <li>
    Line A: private field <code>.#firstName</code>. In contrast to properties, private fields must be declared (line A) before they can be used (line B). A private field can only be accessed inside the class that declares it. It can’t even be accessed by subclasses.
  </li>
</ul>
<p>Class <code>Employee</code> is a subclass of <code>Person</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> {
  #title;
<code/>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">firstName, title</span>) {
    <span class="hljs-variable language_">super</span>(firstName); <span class="hljs-comment">// (A)</span>
    <span class="hljs-variable language_">this</span>.#title = title;
  }
  <span class="hljs-title function_">describe</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">super</span>.describe()}</span> (<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.#title}</span>)`</span>; <span class="hljs-comment">// (B)</span></span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<code/>
<span class="hljs-params"><span class="hljs-keyword">const</span> jane = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">'Jane'</span>, <span class="hljs-string">'CTO'</span>);</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">  jane.<span class="hljs-title function_">describe</span>(),</span>
<span class="hljs-params">  <span class="hljs-string">'Person named Jane (CTO)'</span></span>
<span class="hljs-params">);</span>
</pre>
<ul>
  <li>
    Line A: In subclasses, we can omit the constructor. If we don’t, we have to call <code>super()</code>.
  </li>
  <li>
    Line B: We can refer to overridden methods via <code>super</code>.
  </li>
</ul>
<p>The next class demonstrates how to create properties via <em>public fields</em> (line A):</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBuilderClass</span> {
  string = <span class="hljs-string">''</span>; <span class="hljs-comment">// (A)</span>
  <span class="hljs-title function_">add</span>(<span class="hljs-params">str</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">string</span> += str;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
  }
}
<code/>
<span class="hljs-keyword">const</span> sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilderClass</span>();
sb.<span class="hljs-title function_">add</span>(<span class="hljs-string">'Hello'</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">' everyone'</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">'!'</span>);
assert.<span class="hljs-title function_">equal</span>(
  sb.<span class="hljs-property">string</span>, <span class="hljs-string">'Hello everyone!'</span>
);
</pre>
<p>JavaScript also supports <code>static</code> members, but external functions and variables are often preferred.</p>
<h3 id="classes"><a class="heading-id-link" href="#classes">31.2 The essentials of classes</a></h3>
<p><span id="index-entry-class"/></p>
<p>Classes are basically a compact syntax for setting up prototype chains (which are explained in <a href="ch_objects.html#prototype-chains">the previous chapter</a>). Under the hood, JavaScript’s classes are unconventional. But that is something we rarely see when working with them. They should normally feel familiar to people who have used other object-oriented programming languages.</p>
<p>Note that we don’t need classes to create objects. We can also do so via <a href="ch_objects.html#object-literals">object literals</a>. That’s why the singleton pattern isn’t needed in JavaScript and classes are used less than in many other languages that have them.</p>
<h4 id="a-class-for-persons"><a class="heading-id-link" href="#a-class-for-persons">31.2.1 A class for persons</a></h4>
<p><span id="index-entry-class2"/><span id="index-entry-static"/></p>
<p><a href="ch_objects.html#sharing-data-via-prototypes">We have previously worked with <code>jane</code> and <code>tarzan</code>, single objects representing persons</a>. Let’s use a <em>class declaration</em> to implement a factory for such objects:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  #firstName; <span class="hljs-comment">// (A)</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">firstName</span>) {
    <span class="hljs-variable language_">this</span>.#firstName = firstName; <span class="hljs-comment">// (B)</span>
  }
  <span class="hljs-title function_">describe</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">`Person named <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.#firstName}</span>`</span>;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-title function_">extractNames</span>(<span class="hljs-params">persons</span>) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> persons.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">person</span> =&gt;</span> person.#firstName);</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
</pre>
<p><code>jane</code> and <code>tarzan</code> can now be created via <code>new Person()</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> jane = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'Jane'</span>);
<span class="hljs-keyword">const</span> tarzan = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'Tarzan'</span>);
</pre>
<p>Let’s examine what’s inside the body of class <code>Person</code>.</p>
<ul>
  <li>
    <p><code>.constructor()</code> is a special method that is called after the creation of a new instance. Inside it, <code>this</code> refers to that instance.</p>
  </li>
  <li>
    <p><code>.#firstName</code> <sup>ES2022</sup> is an <em>instance private field</em>: Such fields are stored in instances. They are accessed similarly to properties, but their names are separate – they always start with hash symbols (<code>#</code>). And they are invisible to the world outside the class:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(jane),
  []
);
</pre>
    <p>Before we can initialize <code>.#firstName</code> in the constructor (line B), we need to declare it by mentioning it in the class body (line A).</p>
  </li>
  <li>
    <p><code>.describe()</code> is a method. If we invoke it via <code>obj.describe()</code> then <code>this</code> refers to <code>obj</code> inside the body of <code>.describe()</code>.</p>
<pre class="language-js">
assert.<span class="hljs-title function_">equal</span>(
  jane.<span class="hljs-title function_">describe</span>(), <span class="hljs-string">'Person named Jane'</span>
);
assert.<span class="hljs-title function_">equal</span>(
  tarzan.<span class="hljs-title function_">describe</span>(), <span class="hljs-string">'Person named Tarzan'</span>
);
</pre>
  </li>
  <li>
    <p><code>.extractName()</code> is a <em>static</em> method. “Static” means that it belongs to the class, not to instances:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">extractNames</span>([jane, tarzan]),
  [<span class="hljs-string">'Jane'</span>, <span class="hljs-string">'Tarzan'</span>]
);
</pre>
  </li>
</ul>
<p>We can also create instance properties (public fields) in constructors:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;
  }
}
<span class="hljs-keyword">const</span> abcContainer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Container</span>(<span class="hljs-string">'abc'</span>);
assert.<span class="hljs-title function_">equal</span>(
  abcContainer.<span class="hljs-property">value</span>, <span class="hljs-string">'abc'</span>
);
</pre>
<p>In contrast to instance private fields, instance properties don’t have to be declared in class bodies.</p>
<h4 id="class-expressions"><a class="heading-id-link" href="#class-expressions">31.2.2 Class expressions</a></h4>
<p><span id="index-entry-class-definition"/><span id="index-entry-class-declaration"/><span id="index-entry-class-expression"/></p>
<p>There are two kinds of <em>class definitions</em> (ways of defining classes):</p>
<ul>
  <li>
    <em>Class declarations</em>, which we have seen in the previous section.
  </li>
  <li>
    <em>Class expressions</em>, which we’ll see next.
  </li>
</ul>
<p>Class expressions can be anonymous and named:</p>
<pre class="language-js">
<span class="hljs-comment">// Anonymous class expression</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">class</span> { ··· };
<code/>
<span class="hljs-comment">// Named class expression</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> { ··· };
</pre>
<p>The name of a named class expression works similarly to <a href="ch_callables.html#named-function-expressions">the name of a named function expression</a>: It can only be accessed inside the body of a class and stays the same, regardless of what the class is assigned to.</p>
<h4 id="the-instanceof-operator"><a class="heading-id-link" href="#the-instanceof-operator">31.2.3 The <code>instanceof</code> operator</a></h4>
<p><span id="index-entry-instanceof2"/></p>
<p>The <code>instanceof</code> operator tells us if a value is an instance of a given class:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'Jane'</span>) <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">{} <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span></span>
false
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">{} <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span></span>
true
</pre>
<p>We’ll explore the <code>instanceof</code> operator in more detail <a href="#instanceof-operator-details">later</a>, after we have looked at subclassing.</p>
<h4 id="private-slots"><a class="heading-id-link" href="#private-slots">31.2.4 Public slots (properties) vs. private slots</a></h4>
<p><span id="index-entry-public-slot"/><span id="index-entry-slot--public"/>
<span id="index-entry-property"/>
<span id="index-entry-private-slot"/><span id="index-entry-slot--private"/></p>
<p>In the JavaScript language, objects can have two kinds of “slots”.</p>
<ul>
  <li>
    <em>Public slots</em> (which are are also called <em>properties</em>). For example, methods are public slots.
  </li>
  <li>
    <em>Private slots</em> <sup>ES2022</sup>. For example, private fields are private slots.
  </li>
</ul>
<p>These are the most important rules we need to know about properties and private slots:</p>
<ul>
  <li>
    In classes, we can use public and private versions of fields, methods, getters and setters. All of them are slots in objects. Which objects they are placed in depends on whether the keyword <code>static</code> is used and other factors.
  </li>
  <li>
    A getter and a setter that have the same key create a single <em>accessor</em> slot. An Accessor can also have only a getter or only a setter.
  </li>
  <li>
    Properties and private slots are very different – for example:
    <ul>
      <li>
        They are stored separately.
      </li>
      <li>
        Their keys are different. The keys of private slots can’t even be accessed directly (see <a href="#private-names">“Each private slot has a unique key (a <em>private name</em>)” (§31.2.5.2)</a> later in this chapter).
      </li>
      <li>
        Properties are inherited from prototypes, private slots aren’t.
      </li>
      <li>
        Private slots can only be created via classes.
      </li>
    </ul>
  </li>
</ul>
<p>The following class demonstrates the two kinds of slots. Each of its instances has one private field and one property:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  #instancePrivateField = <span class="hljs-number">1</span>;
  instanceProperty = <span class="hljs-number">2</span>;
  <span class="hljs-title function_">getInstanceValues</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> [</span>
<span class="hljs-params">      <span class="hljs-variable language_">this</span>.#instancePrivateField,</span>
<span class="hljs-params">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">instanceProperty</span>,</span>
<span class="hljs-params">    ];</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();</span>
<span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span>
<span class="hljs-params">  inst.<span class="hljs-title function_">getInstanceValues</span>(), [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]</span>
<span class="hljs-params">);</span>
</pre>
<p>As expected, outside <code>MyClass</code>, we can only see the property:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(inst),
  [<span class="hljs-string">'instanceProperty'</span>]
);
</pre>
<div class="boxout">
  <p><img src="../Images/38ba63de820aae6f94a019538ae0f222.png" class="boxout-icon" height="24" alt="Icon “details”" data-original-src="https://exploringjs.com/js/book/icon/details.svg"/> <strong>More information on properties</strong></p>
  <div class="boxout-vspace"/>
  <p>This chapter doesn’t cover all details of properties (just the essentials). If you want to dig deeper, you can do so in <a href="ch_objects.html#property-attributes-property-descriptors">“Property attributes and property descriptors<span> <sup>ES5</sup> (advanced)</span>” (§30.10)</a></p>
</div>
<p>Next, we’ll look at some of the details of private slots.</p>
<h4 id="private-slots-in-more-detail-es2022-advanced"><a class="heading-id-link" href="#private-slots-in-more-detail-es2022-advanced">31.2.5 Private slots in more detail<span> <sup>ES2022</sup> (advanced)</span></a></h4>
<h5 id="private-slots-cant-be-accessed-in-subclasses"><a class="heading-id-link" href="#private-slots-cant-be-accessed-in-subclasses">31.2.5.1 Private slots can’t be accessed in subclasses</a></h5>
<p>A private slot really can only be accessed inside the class that declares it. We can’t even access it from a subclass:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperClass</span> {
  #superProp = <span class="hljs-string">'superProp'</span>;
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">SuperClass</span> {
  <span class="hljs-title function_">getSuperProp</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#superProp;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-comment">// SyntaxError: Private field '#superProp'</span></span>
<span class="hljs-params"><span class="hljs-comment">// must be declared in an enclosing class</span></span>
</pre>
<p><a href="#subclassing">Subclassing via <code>extends</code></a> is explained later in this chapter. How to work around this limitation is explained in <a href="#instance-protected-fields">“Simulating protected visibility and friend visibility via WeakMaps<span> (advanced)</span>” (§31.5.4)</a>.</p>
<h5 id="private-names"><a class="heading-id-link" href="#private-names">31.2.5.2 Each private slot has a unique key (a <em>private name</em>)</a></h5>
<p><span id="index-entry-private-name"/></p>
<p>Private slots have unique keys that are similar to <a href="ch_symbols.html#ch_symbols">symbols</a>. Consider the following class from earlier:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  #instancePrivateField = <span class="hljs-number">1</span>;
  instanceProperty = <span class="hljs-number">2</span>;
  <span class="hljs-title function_">getInstanceValues</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> [</span>
<span class="hljs-params">      <span class="hljs-variable language_">this</span>.#instancePrivateField,</span>
<span class="hljs-params">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">instanceProperty</span>,</span>
<span class="hljs-params">    ];</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
</pre>
<p>Internally, the private field of <code>MyClass</code> is handled roughly like this:</p>
<pre class="language-js">
<span class="hljs-keyword">let</span> <span class="hljs-title class_">MyClass</span>;
{ <span class="hljs-comment">// Scope of the body of the class</span>
  <span class="hljs-keyword">const</span> instancePrivateFieldKey = <span class="hljs-title class_">Symbol</span>();
  <span class="hljs-title class_">MyClass</span> = <span class="hljs-keyword">class</span> {
    __PrivateElements__ = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([
      [instancePrivateFieldKey, <span class="hljs-number">1</span>],
    ]);
    instanceProperty = <span class="hljs-number">2</span>;
    <span class="hljs-title function_">getInstanceValues</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">      <span class="hljs-keyword">return</span> [</span>
<span class="hljs-params">        <span class="hljs-variable language_">this</span>.<span class="hljs-property">__PrivateElements__</span>.<span class="hljs-title function_">get</span>(instancePrivateFieldKey),</span>
<span class="hljs-params">        <span class="hljs-variable language_">this</span>.<span class="hljs-property">instanceProperty</span>,</span>
<span class="hljs-params">      ];</span>
<span class="hljs-params">    }</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
</pre>
<p>The value of <code>instancePrivateFieldKey</code> is called a <em>private name</em>. We can’t use private names directly in JavaScript, we can only use them indirectly, via the fixed identifiers of private fields, private methods, and private accessors. Where the fixed identifiers of public slots (such as <code>getInstanceValues</code>) are interpreted as string keys, the fixed identifiers of private slots (such as <code>#instancePrivateField</code>) refer to private names (similarly to how variable names refer to values).</p>
<div class="boxout">
  <p><img src="../Images/38ba63de820aae6f94a019538ae0f222.png" class="boxout-icon" height="24" alt="Icon “details”" data-original-src="https://exploringjs.com/js/book/icon/details.svg"/> <strong>Private slots in the ECMAScript language specification</strong></p>
  <div class="boxout-vspace"/>
  <p>Section <a href="https://tc39.es/ecma262/#sec-object-internal-methods-and-internal-slots">“Object Internal Methods and Internal Slots”</a> in the ECMAScript language specification explains how private slots work. Search for “<code>[[PrivateElements]]</code>”.</p>
</div>
<h5 id="private-names-are-statically-scoped-like-variables"><a class="heading-id-link" href="#private-names-are-statically-scoped-like-variables">31.2.5.3 Private names are statically scoped (like variables)</a></h5>
<p>A callable entity can only access the name of a private slot if it was born inside the scope where the name was declared. However, it doesn’t lose this ability if it moves somewhere else later on:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  #privateData = <span class="hljs-string">'hello'</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">createGetter</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> obj.#privateData; <span class="hljs-comment">// (A)</span></span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<code/>
<span class="hljs-params"><span class="hljs-keyword">const</span> myInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();</span>
<span class="hljs-params"><span class="hljs-keyword">const</span> getter = <span class="hljs-title class_">MyClass</span>.<span class="hljs-title function_">createGetter</span>();</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">  <span class="hljs-title function_">getter</span>(myInstance), <span class="hljs-string">'hello'</span> <span class="hljs-comment">// (B)</span></span>
<span class="hljs-params">);</span>
</pre>
<p>The arrow function <code>getter</code> was born inside <code>MyClass</code> (line A), but it can still access the private name <code>#privateData</code> after it left its birth scope (line B).</p>
<h5 id="the-same-private-identifier-refers-to-different-private-names-in-different-classes"><a class="heading-id-link" href="#the-same-private-identifier-refers-to-different-private-names-in-different-classes">31.2.5.4 The same private identifier refers to different private names in different classes</a></h5>
<p>Because the identifiers of private slots aren’t used as keys, using the same identifier in different classes produces different slots (line A and line C):</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> {
  #name; <span class="hljs-comment">// (A)</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.#name = name; <span class="hljs-comment">// (B)</span>
  }
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params">obj</span>) {
    <span class="hljs-keyword">return</span> obj.#name;
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  #name; <span class="hljs-comment">// (C)</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.#name = name;
  }
}
<code/>
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title class_">Color</span>.<span class="hljs-title function_">getName</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-string">'green'</span>)), <span class="hljs-string">'green'</span>
);
<code/>
<span class="hljs-comment">// We can’t access the private slot #name of a Person in line B:</span>
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Color</span>.<span class="hljs-title function_">getName</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'Jane'</span>)),
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'TypeError'</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">'Cannot read private member #name from'</span>
      + <span class="hljs-string">' an object whose class did not declare it'</span>,
  }
);
</pre>
<h5 id="the-names-of-private-fields-never-clash"><a class="heading-id-link" href="#the-names-of-private-fields-never-clash">31.2.5.5 The names of private fields never clash</a></h5>
<p>Even if a subclass uses the same name for a private field, the two names never clash because they refer to private names (which are always unique). In the following example, <code>.#privateField</code> in <code>SuperClass</code> does not clash with <code>.#privateField</code> in <code>SubClass</code>, even though both slots are stored directly in <code>inst</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperClass</span> {
  #privateField = <span class="hljs-string">'super'</span>;
  <span class="hljs-title function_">getSuperPrivateField</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#privateField;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">SuperClass</span> {</span>
<span class="hljs-params">  #privateField = <span class="hljs-string">'sub'</span>;</span>
<span class="hljs-params">  <span class="hljs-title function_">getSubPrivateField</span>(<span class="hljs-params"/>) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#privateField;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubClass</span>();</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">  inst.<span class="hljs-title function_">getSuperPrivateField</span>(), <span class="hljs-string">'super'</span></span>
<span class="hljs-params">);</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">  inst.<span class="hljs-title function_">getSubPrivateField</span>(), <span class="hljs-string">'sub'</span></span>
<span class="hljs-params">);</span>
</pre>
<p><a href="#subclassing">Subclassing via <code>extends</code></a> is explained later in this chapter.</p>
<h5 id="private-slot-checks"><a class="heading-id-link" href="#private-slot-checks">31.2.5.6 Using <code>in</code> to check if an object has a given private slot</a></h5>
<p>The <code>in</code> operator can be used to check if a private slot exists (line A):</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> {
  #name;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.#name = name;
  }
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">obj</span>) {
    <span class="hljs-keyword">return</span> #name <span class="hljs-keyword">in</span> obj; <span class="hljs-comment">// (A)</span>
  }
}
</pre>
<p>Let’s look at more examples of <code>in</code> applied to private slots.</p>
<p><strong>Private methods.</strong> The following code shows that private methods create private slots in instances:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">C1</span> {
  #<span class="hljs-title function_">priv</span>(<span class="hljs-params">) {}</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">obj</span>) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> #priv <span class="hljs-keyword">in</span> obj;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(<span class="hljs-variable constant_">C1</span>.<span class="hljs-title function_">check</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">C1</span>()), <span class="hljs-literal">true</span>);</span>
</pre>
<p><strong>Static private fields.</strong> We can also use <code>in</code> for a static private field:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">C2</span> {
  <span class="hljs-keyword">static</span> #priv = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">obj</span>) {
    <span class="hljs-keyword">return</span> #priv <span class="hljs-keyword">in</span> obj;
  }
}
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-variable constant_">C2</span>.<span class="hljs-title function_">check</span>(<span class="hljs-variable constant_">C2</span>), <span class="hljs-literal">true</span>);
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-variable constant_">C2</span>.<span class="hljs-title function_">check</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">C2</span>()), <span class="hljs-literal">false</span>);
</pre>
<p><strong>Static private methods.</strong> And we can check for the slot of a static private method:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">C3</span> {
  <span class="hljs-keyword">static</span> #<span class="hljs-title function_">priv</span>(<span class="hljs-params">) {}</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">obj</span>) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> #priv <span class="hljs-keyword">in</span> obj;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(<span class="hljs-variable constant_">C3</span>.<span class="hljs-title function_">check</span>(<span class="hljs-variable constant_">C3</span>), <span class="hljs-literal">true</span>);</span>
</pre>
<p><strong>Using the same private identifier in different classes.</strong> In the next example, the two classes <code>Color</code> and <code>Person</code> both have a slot whose identifier is <code>#name</code>. The <code>in</code> operator distinguishes them correctly:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> {
  #name;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.#name = name;
  }
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">obj</span>) {
    <span class="hljs-keyword">return</span> #name <span class="hljs-keyword">in</span> obj;
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  #name;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.#name = name;
  }
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">obj</span>) {
    <span class="hljs-keyword">return</span> #name <span class="hljs-keyword">in</span> obj;
  }
}
<code/>
<span class="hljs-comment">// Detecting Color’s #name</span>
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title class_">Color</span>.<span class="hljs-title function_">check</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>()), <span class="hljs-literal">true</span>
);
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title class_">Color</span>.<span class="hljs-title function_">check</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()), <span class="hljs-literal">false</span>
);
<code/>
<span class="hljs-comment">// Detecting Person’s #name</span>
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">check</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()), <span class="hljs-literal">true</span>
);
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">check</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>()), <span class="hljs-literal">false</span>
);
</pre>
<h4 id="the-pros-and-cons-of-classes-in-javascript"><a class="heading-id-link" href="#the-pros-and-cons-of-classes-in-javascript">31.2.6 The pros and cons of classes in JavaScript</a></h4>
<p>I recommend using classes for the following reasons:</p>
<ul>
  <li>
    <p>Classes are a common standard for object creation and inheritance that is now widely supported across libraries and frameworks. This is an improvement compared to how things were before, when almost every framework had its own inheritance library.</p>
  </li>
  <li>
    <p>They help tools such as IDEs and type checkers with their work and enable new features there.</p>
  </li>
  <li>
    <p>If you come from another language to JavaScript and are used to classes, then you can get started more quickly.</p>
  </li>
  <li>
    <p>JavaScript engines optimize them. That is, code that uses classes is almost always faster than code that uses a custom inheritance library.</p>
  </li>
  <li>
    <p>We can subclass built-in constructor functions such as <code>Error</code>.</p>
  </li>
</ul>
<p>That doesn’t mean that classes are perfect:</p>
<ul>
  <li>
    <p>There is a risk of overdoing inheritance.</p>
  </li>
  <li>
    <p>There is a risk of putting too much functionality in classes (when some of it is often better put in functions).</p>
  </li>
  <li>
    <p>Classes look familiar to programmers coming from other languages, but they work differently and are used differently (see next subsection). Therefore, there is a risk of those programmers writing code that doesn’t feel like JavaScript.</p>
  </li>
  <li>
    <p>How classes seem to work superficially is quite different from how they actually work. In other words, there is a disconnect between syntax and semantics. Two examples are:</p>
    <ul>
      <li>
        A method definition inside a class <code>C</code> creates a method in the object <code>C.prototype</code>.
      </li>
      <li>
        Classes are functions.
      </li>
    </ul>
    <p>The motivation for the disconnect is backward compatibility. Thankfully, the disconnect causes few problems in practice; we are usually OK if we go along with what classes pretend to be.</p>
  </li>
</ul>
<p>This was a first look at classes. We’ll explore more features soon.</p>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Writing a class</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/classes/point_class_test.mjs</code></p>
</div>
<h4 id="tips-for-using-classes"><a class="heading-id-link" href="#tips-for-using-classes">31.2.7 Tips for using classes</a></h4>
<ul>
  <li>
    Use inheritance sparingly – it tends to make code more complicated and spread out related functionality across multiple locations.
  </li>
  <li>
    Instead of static members, it is often better to use external functions and variables. We can even make those private to a module, simply by not exporting them. Two important exceptions to this rule are:
    <ul>
      <li>
        Operations that need access to private slots
      </li>
      <li>
        <a href="#static-factory-methods">Static factory methods</a>
      </li>
    </ul>
  </li>
  <li>
    Only put core functionality in prototype methods. Other functionality is better implemented via functions – especially algorithms that involve instances of multiple classes.
  </li>
</ul>
<h3 id="internals-of-classes"><a class="heading-id-link" href="#internals-of-classes">31.3 The internals of classes</a></h3>
<h4 id="a-class-is-actually-two-connected-objects"><a class="heading-id-link" href="#a-class-is-actually-two-connected-objects">31.3.1 A class is actually two connected objects</a></h4>
<p>Under the hood, a class becomes two connected objects. Let’s revisit class <code>Person</code> to see how that works:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  #firstName;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">firstName</span>) {
    <span class="hljs-variable language_">this</span>.#firstName = firstName;
  }
  <span class="hljs-title function_">describe</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">`Person named <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.#firstName}</span>`</span>;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-title function_">extractNames</span>(<span class="hljs-params">persons</span>) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> persons.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">person</span> =&gt;</span> person.#firstName);</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
</pre>
<p>The first object created by the class is stored in <code>Person</code>. It has four properties:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(<span class="hljs-title class_">Person</span>),
  [<span class="hljs-string">'length'</span>, <span class="hljs-string">'name'</span>, <span class="hljs-string">'prototype'</span>, <span class="hljs-string">'extractNames'</span>]
);
<code/>
<span class="hljs-comment">// The number of parameters of the constructor</span>
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title class_">Person</span>.<span class="hljs-property">length</span>, <span class="hljs-number">1</span>
);
<code/>
<span class="hljs-comment">// The name of the class</span>
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title class_">Person</span>.<span class="hljs-property">name</span>, <span class="hljs-string">'Person'</span>
);
</pre>
<p>The two remaining properties are:</p>
<ul>
  <li>
    <code>Person.extractNames</code> is the static method that we have already seen in action.
  </li>
  <li>
    <code>Person.prototype</code> points to the second object that is created by a class definition.
  </li>
</ul>
<p>These are the contents of <code>Person.prototype</code>:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>),
  [<span class="hljs-string">'constructor'</span>, <span class="hljs-string">'describe'</span>]
);
</pre>
<p>There are two properties:</p>
<ul>
  <li>
    <code>Person.prototype.constructor</code> points to the constructor.
  </li>
  <li>
    <code>Person.prototype.describe</code> is the method that we have already used.
  </li>
</ul>
<h4 id="classes-set-up-the-prototype-chains-of-their-instances"><a class="heading-id-link" href="#classes-set-up-the-prototype-chains-of-their-instances">31.3.2 Classes set up the prototype chains of their instances</a></h4>
<p>The object <code>Person.prototype</code> is the prototype of all instances:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> jane = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'Jane'</span>);
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(jane), <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
);
<code/>
<span class="hljs-keyword">const</span> tarzan = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'Tarzan'</span>);
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(tarzan), <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
);
</pre>
<p>That explains how the instances get their methods: They inherit them from the object <code>Person.prototype</code>.</p>
<p><a href="#fig:oo_person_class">Figure 31.2</a> visualizes how everything is connected.</p>
<figure id="fig:oo_person_class" class="float">
  <p><img src="../Images/96be80cce4461d811881a458537b27cb.png" alt="" style="width:431.1471px; height:208.13821px" data-original-src="https://exploringjs.com/js/book/img/classes/oo_person_class.svg"/></p>
  <figcaption>
    <p><span class="float-label">Figure 31.2:</span> The class <code>Person</code> has the property <code>.prototype</code> that points to an object that is the prototype of all instances of <code>Person</code>. The objects <code>jane</code> and <code>tarzan</code> are two such instances.</p>
  </figcaption>
</figure>
<h4 id="proto-vs-prototype"><a class="heading-id-link" href="#proto-vs-prototype">31.3.3 <code>.__proto__</code> vs. <code>.prototype</code></a></h4>
<p>It is easy to confuse <code>.__proto__</code> and <code>.prototype</code>. Hopefully, <a href="#fig:oo_person_class">figure 31.2</a> makes it clear how they differ:</p>
<ul>
  <li>
    <p><a href="#Object.prototype.__proto__"><code>Object.prototype.__proto__</code></a> is an accessor that most objects inherit that gets and sets the prototype of the receiver. Therefore the following two expressions are equivalent:</p>
<pre class="language-js">
someObj.<span class="hljs-property">__proto__</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(someObj)
</pre>
    <p>As are the following two expressions:</p>
<pre class="language-js">
someObj.<span class="hljs-property">__proto__</span> = anotherObj
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(someObj, anotherObj)
</pre>
  </li>
  <li>
    <p><code>SomeClass.prototype</code> holds the object that becomes the prototype of all instances of <code>SomeClass</code>. A better name for <code>.prototype</code> would be <code>.instancePrototype</code>. This property is only special because the <code>new</code> operator uses it to set up instances of <code>SomeClass</code>.</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeClass</span> {}
<span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SomeClass</span>();
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(inst), <span class="hljs-title class_">SomeClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
);
</pre>
  </li>
</ul>
<h4 id="personprototypeconstructor-advanced"><a class="heading-id-link" href="#personprototypeconstructor-advanced">31.3.4 <code>Person.prototype.constructor</code><span> (advanced)</span></a></h4>
<p>There is one detail in <a href="#fig:oo_person_class">figure 31.2</a> that we haven’t looked at, yet: <code>Person.prototype.constructor</code> points back to <code>Person</code>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span></span>
true
</pre>
<p>This setup exists due to backward compatibility. But it has two additional benefits.</p>
<p>First, each instance of a class inherits property <code>.constructor</code>. Therefore, given an instance, we can make “similar” objects via it:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> jane = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'Jane'</span>);
<code/>
<span class="hljs-keyword">const</span> cheeta = <span class="hljs-keyword">new</span> jane.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-string">'Cheeta'</span></span>);
<span class="hljs-comment">// cheeta is also an instance of Person</span>
assert.<span class="hljs-title function_">equal</span>(cheeta <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>, <span class="hljs-literal">true</span>);
</pre>
<p>Second, we can get the name of the class that created a given instance:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> tarzan = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'Tarzan'</span>);
assert.<span class="hljs-title function_">equal</span>(tarzan.<span class="hljs-property">constructor</span>.<span class="hljs-property">name</span>, <span class="hljs-string">'Person'</span>);
</pre>
<h4 id="method-calls-dispatched-direct"><a class="heading-id-link" href="#method-calls-dispatched-direct">31.3.5 Dispatched vs. direct method calls<span> (advanced)</span></a></h4>
<p>In this subsection, we learn about two different ways of invoking methods:</p>
<ul>
  <li>
    Dispatched method calls
  </li>
  <li>
    Direct method calls
  </li>
</ul>
<p>Understanding both of them will give us important insights into how methods work.</p>
<p>We’ll also need the second way <a href="#using-object-methods-safely">later</a> in this chapter: It will allow us to borrow useful methods from <code>Object.prototype</code>.</p>
<h5 id="dispatched-method-calls"><a class="heading-id-link" href="#dispatched-method-calls">31.3.5.1 Dispatched method calls</a></h5>
<p><span id="index-entry-dispatched-method-call"/><span id="index-entry-method-call--dispatched"/></p>
<p>Let’s examine how method calls work with classes. We are revisiting <code>jane</code> from earlier:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  #firstName;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">firstName</span>) {
    <span class="hljs-variable language_">this</span>.#firstName = firstName;
  }
  <span class="hljs-title function_">describe</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">'Person named '</span>+<span class="hljs-variable language_">this</span>.#firstName;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-keyword">const</span> jane = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'Jane'</span>);</span>
</pre>
<p><a href="#fig:jane_proto_chain">Figure 31.3</a> has a diagram with <code>jane</code>’s prototype chain.</p>
<figure id="fig:jane_proto_chain" class="float">
  <p><img src="../Images/75efdfc55284976c46d9812c0dd3353b.png" alt="" style="width:163.96px; height:190.69982px" data-original-src="https://exploringjs.com/js/book/img/classes/jane_proto_chain.svg"/></p>
  <figcaption>
    <p><span class="float-label">Figure 31.3:</span> The prototype chain of <code>jane</code> starts with <code>jane</code> and continues with <code>Person.prototype</code>.</p>
  </figcaption>
</figure>
<p>Normal method calls are <em>dispatched</em> – the method call</p>
<pre class="language-js">
jane.<span class="hljs-title function_">describe</span>()
</pre>
<p>happens in two steps:</p>
<ul>
  <li>
    <p>Dispatch: JavaScript traverses the prototype chain starting with <code>jane</code> to find the first object that has an own property with the key <code>'describe'</code>: It first looks at <code>jane</code> and doesn’t find an own property <code>.describe</code>. It continues with <code>jane</code>’s prototype, <code>Person.prototype</code> and finds an own property <code>describe</code> whose value it returns.</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> func = jane.<span class="hljs-property">describe</span>;
</pre>
  </li>
  <li>
    <p>Invocation: Method-invoking a value is different from function-invoking a value in that it not only calls what comes before the parentheses with the arguments inside the parentheses but also sets <code>this</code> to the receiver of the method call (in this case, <code>jane</code>):</p>
<pre class="language-js">
func.<span class="hljs-title function_">call</span>(jane);
</pre>
  </li>
</ul>
<p>This way of dynamically looking for a method and invoking it is called <em>dynamic dispatch</em>.</p>
<h5 id="direct-method-calls"><a class="heading-id-link" href="#direct-method-calls">31.3.5.2 Direct method calls</a></h5>
<p><span id="index-entry-direct-method-call"/><span id="index-entry-method-call--direct"/></p>
<p>We can also make method calls <em>directly</em>, without dispatching:</p>
<pre class="language-js">
<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">describe</span>.<span class="hljs-title function_">call</span>(jane)
</pre>
<p>This time, we directly point to the method via <code>Person.prototype.describe</code> and don’t search for it in the prototype chain. We also specify <code>this</code> differently – via <code>.call()</code>.</p>
<div class="boxout">
  <p><img src="../Images/38ba63de820aae6f94a019538ae0f222.png" class="boxout-icon" height="24" alt="Icon “details”" data-original-src="https://exploringjs.com/js/book/icon/details.svg"/> <strong><code>this</code> always points to the instance</strong></p>
  <div class="boxout-vspace"/>
  <p>No matter where in the prototype chain of an instance a method is located, <code>this</code> always points to the instance (the beginning of the prototype chain). That enables <code>.describe()</code> to access <code>.#firstName</code> in the example.</p>
</div>
<p>When are direct method calls useful? Whenever we want to borrow a method from elsewhere that a given object doesn’t have – for example:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);
<code/>
<span class="hljs-comment">// `obj` is not an instance of Object and doesn’t inherit</span>
<span class="hljs-comment">// its prototype method .toString()</span>
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> obj.<span class="hljs-title function_">toString</span>(),
  <span class="hljs-regexp">/^TypeError: obj.toString is not a function$/</span>
);
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj),
  <span class="hljs-string">'[object Object]'</span>
);
</pre>
<h4 id="classes-evolved-from-ordinary-functions-advanced"><a class="heading-id-link" href="#classes-evolved-from-ordinary-functions-advanced">31.3.6 Classes evolved from ordinary functions<span> (advanced)</span></a></h4>
<p>Before ECMAScript 6, JavaScript didn’t have classes. Instead, <a href="ch_callables.html#ordinary-functions">ordinary functions</a> were used as <em>constructor functions</em>:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">StringBuilderConstr</span>(<span class="hljs-params">initialString</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">string</span> = initialString;
}
<span class="hljs-title class_">StringBuilderConstr</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">add</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">string</span> += str;
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
};
<code/>
<span class="hljs-keyword">const</span> sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilderConstr</span>(<span class="hljs-string">'¡'</span>);
sb.<span class="hljs-title function_">add</span>(<span class="hljs-string">'Hola'</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">'!'</span>);
assert.<span class="hljs-title function_">equal</span>(
  sb.<span class="hljs-property">string</span>, <span class="hljs-string">'¡Hola!'</span>
);
</pre>
<p>Classes provide better syntax for this approach:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBuilderClass</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">initialString</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">string</span> = initialString;
  }
  <span class="hljs-title function_">add</span>(<span class="hljs-params">str</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">string</span> += str;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
  }
}
<span class="hljs-keyword">const</span> sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilderClass</span>(<span class="hljs-string">'¡'</span>);
sb.<span class="hljs-title function_">add</span>(<span class="hljs-string">'Hola'</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">'!'</span>);
assert.<span class="hljs-title function_">equal</span>(
  sb.<span class="hljs-property">string</span>, <span class="hljs-string">'¡Hola!'</span>
);
</pre>
<p>Subclassing is especially tricky with constructor functions. Classes also offer benefits that go beyond more convenient syntax:</p>
<ul>
  <li>
    Built-in constructor functions such as <code>Error</code> can be subclassed.
  </li>
  <li>
    We can access overridden properties via <code>super</code>.
  </li>
  <li>
    Classes can’t be function-called.
  </li>
  <li>
    Methods can’t be <code>new</code>-called and don’t have the property <code>.prototype</code>.
  </li>
  <li>
    Support for private instance data.
  </li>
  <li>
    And more.
  </li>
</ul>
<p>Classes are so compatible with constructor functions that they can even extend them:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperConstructor</span>(<span class="hljs-params">) {}</span>
<span class="hljs-params"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">SuperConstructor</span> {}</span>
<code/>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubClass</span>() <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SuperConstructor</span>, <span class="hljs-literal">true</span></span>
<span class="hljs-params">);</span>
</pre>
<p><code>extends</code> and subclassing are explained <a href="#subclassing">later in this chapter</a>.</p>
<h5 id="a-class-is-the-constructor"><a class="heading-id-link" href="#a-class-is-the-constructor">31.3.6.1 A class is the constructor</a></h5>
<p>This brings us to an interesting insight. On one hand, <code>StringBuilderClass</code> refers to its constructor via <code>StringBuilderClass.prototype.constructor</code>.</p>
<p>On the other hand, the class <em>is</em> the constructor (a function):</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">StringBuilderClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">StringBuilderClass</span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">StringBuilderClass</span></span>
'function'
</pre>
<div class="boxout">
  <p><img src="../Images/38ba63de820aae6f94a019538ae0f222.png" class="boxout-icon" height="24" alt="Icon “details”" data-original-src="https://exploringjs.com/js/book/icon/details.svg"/> <strong>Constructor (functions) vs. classes</strong></p>
  <div class="boxout-vspace"/>
  <p>Due to how similar they are, I use the terms <em>constructor (function)</em> and <em>class</em> interchangeably.</p>
</div>
<h3 id="prototype-members-of-classes"><a class="heading-id-link" href="#prototype-members-of-classes">31.4 Prototype members of classes</a></h3>
<h4 id="public-prototype-methods-and-accessors"><a class="heading-id-link" href="#public-prototype-methods-and-accessors">31.4.1 Public prototype methods and accessors</a></h4>
<p>All members in the body of the following class declaration create properties of <code>PublicProtoClass.prototype</code>.</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PublicProtoClass</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">args</span>) {
    <span class="hljs-comment">// (Do something with `args` here.)</span>
  }
  <span class="hljs-title function_">publicProtoMethod</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">'publicProtoMethod'</span>;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">  <span class="hljs-keyword">get</span> <span class="hljs-title function_">publicProtoAccessor</span>() {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">'publicProtoGetter'</span>;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">  <span class="hljs-keyword">set</span> <span class="hljs-title function_">publicProtoAccessor</span>(<span class="hljs-params">value</span>) {</span>
<span class="hljs-params">    assert.<span class="hljs-title function_">equal</span>(value, <span class="hljs-string">'publicProtoSetter'</span>);</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<code/>
<span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span>
<span class="hljs-params">  <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(<span class="hljs-title class_">PublicProtoClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>),</span>
<span class="hljs-params">  [<span class="hljs-string">'constructor'</span>, <span class="hljs-string">'publicProtoMethod'</span>, <span class="hljs-string">'publicProtoAccessor'</span>]</span>
<span class="hljs-params">);</span>
<code/>
<span class="hljs-params"><span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PublicProtoClass</span>(<span class="hljs-string">'arg1'</span>, <span class="hljs-string">'arg2'</span>);</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">  inst.<span class="hljs-title function_">publicProtoMethod</span>(), <span class="hljs-string">'publicProtoMethod'</span></span>
<span class="hljs-params">);</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">  inst.<span class="hljs-property">publicProtoAccessor</span>, <span class="hljs-string">'publicProtoGetter'</span></span>
<span class="hljs-params">);</span>
<span class="hljs-params">inst.<span class="hljs-property">publicProtoAccessor</span> = <span class="hljs-string">'publicProtoSetter'</span>;</span>
</pre>
<h5 id="all-kinds-of-public-prototype-methods-and-accessors-advanced"><a class="heading-id-link" href="#all-kinds-of-public-prototype-methods-and-accessors-advanced">31.4.1.1 All kinds of public prototype methods and accessors<span> (advanced)</span></a></h5>
<pre class="language-js">
<span class="hljs-keyword">const</span> accessorKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'accessorKey'</span>);
<span class="hljs-keyword">const</span> syncMethodKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'syncMethodKey'</span>);
<span class="hljs-keyword">const</span> syncGenMethodKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'syncGenMethodKey'</span>);
<span class="hljs-keyword">const</span> asyncMethodKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'asyncMethodKey'</span>);
<span class="hljs-keyword">const</span> asyncGenMethodKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'asyncGenMethodKey'</span>);
<code/>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PublicProtoClass2</span> {
  <span class="hljs-comment">// Identifier keys</span>
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">accessor</span>() {}
  <span class="hljs-keyword">set</span> <span class="hljs-title function_">accessor</span>(<span class="hljs-params">value</span>) {}
  <span class="hljs-title function_">syncMethod</span>(<span class="hljs-params">) {}</span>
<span class="hljs-params">  * <span class="hljs-title function_">syncGeneratorMethod</span>(<span class="hljs-params"/>) {}</span>
<span class="hljs-params">  <span class="hljs-keyword">async</span> <span class="hljs-title function_">asyncMethod</span>(<span class="hljs-params"/>) {}</span>
<span class="hljs-params">  <span class="hljs-keyword">async</span> * <span class="hljs-title function_">asyncGeneratorMethod</span>(<span class="hljs-params"/>) {}</span>
<code/>
<span class="hljs-params">  <span class="hljs-comment">// Quoted keys</span></span>
<span class="hljs-params">  get <span class="hljs-string">'an accessor'</span>() {}</span>
<span class="hljs-params">  set <span class="hljs-string">'an accessor'</span>(value) {}</span>
<span class="hljs-params">  <span class="hljs-string">'sync method'</span>() {}</span>
<span class="hljs-params">  * <span class="hljs-string">'sync generator method'</span>() {}</span>
<span class="hljs-params">  <span class="hljs-keyword">async</span> <span class="hljs-string">'async method'</span>() {}</span>
<span class="hljs-params">  <span class="hljs-keyword">async</span> * <span class="hljs-string">'async generator method'</span>() {}</span>
<code/>
<span class="hljs-params">  <span class="hljs-comment">// Computed keys</span></span>
<span class="hljs-params">  get [accessorKey]() {}</span>
<span class="hljs-params">  set [accessorKey](value) {}</span>
<span class="hljs-params">  [syncMethodKey]() {}</span>
<span class="hljs-params">  * [syncGenMethodKey]() {}</span>
<span class="hljs-params">  <span class="hljs-keyword">async</span> [asyncMethodKey]() {}</span>
<span class="hljs-params">  <span class="hljs-keyword">async</span> * [asyncGenMethodKey]() {}</span>
<span class="hljs-params">}</span>
<code/>
<span class="hljs-params"><span class="hljs-comment">// Quoted and computed keys are accessed via square brackets:</span></span>
<span class="hljs-params"><span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PublicProtoClass2</span>();</span>
<span class="hljs-params">inst[<span class="hljs-string">'sync method'</span>]();</span>
<span class="hljs-params">inst[syncMethodKey]();</span>
</pre>
<p>Quoted and computed keys can also be used in object literals:</p>
<ul>
  <li>
    <a href="ch_objects.html#object-literals-quoted-keys">“Quoted keys in object literals” (§30.9.1)</a>
  </li>
  <li>
    <a href="ch_objects.html#object-literals-computed-keys">“Computed keys in object literals” (§30.9.2)</a>
  </li>
</ul>
<p>More information on accessors (defined via getters and/or setters), generators, async methods, and async generator methods:</p>
<ul>
  <li>
    <a href="ch_objects.html#object-literal-accessors">“Object literals: accessors” (§30.3.6)</a>
  </li>
  <li>
    <a href="ch_sync-generators.html#ch_sync-generators">“Synchronous generators<span> <sup>ES6</sup> (advanced)</span>” (§33)</a>
  </li>
  <li>
    <a href="ch_async-functions.html#ch_async-functions">“Async functions<span> <sup>ES2017</sup></span>” (§44)</a>
  </li>
  <li>
    <a href="ch_async-iteration.html#async-generators">“Asynchronous generators” (§45.2)</a>
  </li>
</ul>
<h4 id="private-methods-accessors"><a class="heading-id-link" href="#private-methods-accessors">31.4.2 Private methods and accessors<span> <sup>ES2022</sup></span></a></h4>
<p>Private methods (and accessors) are an interesting mix of prototype members and instance members.</p>
<p>On one hand, private methods are stored in slots in instances (line A):</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  #<span class="hljs-title function_">privateMethod</span>(<span class="hljs-params">) {}</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-title function_">check</span>(<span class="hljs-params"/>) {</span>
<span class="hljs-params">    <span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();</span>
<span class="hljs-params">    assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">      #privateMethod <span class="hljs-keyword">in</span> inst, <span class="hljs-literal">true</span> <span class="hljs-comment">// (A)</span></span>
<span class="hljs-params">    );</span>
<span class="hljs-params">    assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">      #privateMethod <span class="hljs-keyword">in</span> <span class="hljs-title class_">MyClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-literal">false</span></span>
<span class="hljs-params">    );</span>
<span class="hljs-params">    assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">      #privateMethod <span class="hljs-keyword">in</span> <span class="hljs-title class_">MyClass</span>, <span class="hljs-literal">false</span></span>
<span class="hljs-params">    );</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-title class_">MyClass</span>.<span class="hljs-title function_">check</span>();</span>
</pre>
<p>Why are they not stored in <code>.prototype</code> objects? Private slots are not inherited, only properties are.</p>
<p>On the other hand, private methods are shared between instances – like prototype public methods:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  #<span class="hljs-title function_">privateMethod</span>(<span class="hljs-params">) {}</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-title function_">check</span>(<span class="hljs-params"/>) {</span>
<span class="hljs-params">    <span class="hljs-keyword">const</span> inst1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();</span>
<span class="hljs-params">    <span class="hljs-keyword">const</span> inst2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();</span>
<span class="hljs-params">    assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">      inst1.#privateMethod,</span>
<span class="hljs-params">      inst2.#privateMethod</span>
<span class="hljs-params">    );</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
</pre>
<p>Due to that and due to their syntax being similar to prototype public methods, they are covered here.</p>
<p>The following code demonstrates how private methods and accessors work:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PrivateMethodClass</span> {
  #<span class="hljs-title function_">privateMethod</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">'privateMethod'</span>;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">  get #<span class="hljs-title function_">privateAccessor</span>(<span class="hljs-params"/>) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">'privateGetter'</span>;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">  set #<span class="hljs-title function_">privateAccessor</span>(<span class="hljs-params">value</span>) {</span>
<span class="hljs-params">    assert.<span class="hljs-title function_">equal</span>(value, <span class="hljs-string">'privateSetter'</span>);</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">  <span class="hljs-title function_">callPrivateMembers</span>(<span class="hljs-params"/>) {</span>
<span class="hljs-params">    assert.<span class="hljs-title function_">equal</span>(<span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">privateMethod</span>(), <span class="hljs-string">'privateMethod'</span>);</span>
<span class="hljs-params">    assert.<span class="hljs-title function_">equal</span>(<span class="hljs-variable language_">this</span>.#privateAccessor, <span class="hljs-string">'privateGetter'</span>);</span>
<span class="hljs-params">    <span class="hljs-variable language_">this</span>.#privateAccessor = <span class="hljs-string">'privateSetter'</span>;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span>
<span class="hljs-params">  <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivateMethodClass</span>()), []</span>
<span class="hljs-params">);</span>
</pre>
<h5 id="all-kinds-of-private-methods-and-accessors-advanced"><a class="heading-id-link" href="#all-kinds-of-private-methods-and-accessors-advanced">31.4.2.1 All kinds of private methods and accessors<span> (advanced)</span></a></h5>
<p>With private slots, the keys are always identifiers:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PrivateMethodClass2</span> {
  get #<span class="hljs-title function_">accessor</span>(<span class="hljs-params">) {}</span>
<span class="hljs-params">  set #<span class="hljs-title function_">accessor</span>(<span class="hljs-params">value</span>) {}</span>
<span class="hljs-params">  #<span class="hljs-title function_">syncMethod</span>(<span class="hljs-params"/>) {}</span>
<span class="hljs-params">  * #<span class="hljs-title function_">syncGeneratorMethod</span>(<span class="hljs-params"/>) {}</span>
<span class="hljs-params">  <span class="hljs-keyword">async</span> #<span class="hljs-title function_">asyncMethod</span>(<span class="hljs-params"/>) {}</span>
<span class="hljs-params">  <span class="hljs-keyword">async</span> * #<span class="hljs-title function_">asyncGeneratorMethod</span>(<span class="hljs-params"/>) {}</span>
<span class="hljs-params">}</span>
</pre>
<p>More information on accessors (defined via getters and/or setters), generators, async methods, and async generator methods:</p>
<ul>
  <li>
    <a href="ch_objects.html#object-literal-accessors">“Object literals: accessors” (§30.3.6)</a>
  </li>
  <li>
    <a href="ch_sync-generators.html#ch_sync-generators">“Synchronous generators<span> <sup>ES6</sup> (advanced)</span>” (§33)</a>
  </li>
  <li>
    <a href="ch_async-functions.html#ch_async-functions">“Async functions<span> <sup>ES2017</sup></span>” (§44)</a>
  </li>
  <li>
    <a href="ch_async-iteration.html#async-generators">“Asynchronous generators” (§45.2)</a>
  </li>
</ul>
<h3 id="instance-members-of-classes-es2022"><a class="heading-id-link" href="#instance-members-of-classes-es2022">31.5 Instance members of classes<span> <sup>ES2022</sup></span></a></h3>
<h4 id="instance-public-fields"><a class="heading-id-link" href="#instance-public-fields">31.5.1 Instance public fields</a></h4>
<p>Instances of the following class have two instance properties (created in line A and line B):</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">InstPublicClass</span> {
  <span class="hljs-comment">// Instance public field</span>
  instancePublicField = <span class="hljs-number">0</span>; <span class="hljs-comment">// (A)</span>
<code/>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-comment">// We don’t need to mention .property elsewhere!</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span> = value; <span class="hljs-comment">// (B)</span>
  }
}
<code/>
<span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstPublicClass</span>(<span class="hljs-string">'constrArg'</span>);
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(inst),
  [<span class="hljs-string">'instancePublicField'</span>, <span class="hljs-string">'property'</span>]
);
assert.<span class="hljs-title function_">equal</span>(
  inst.<span class="hljs-property">instancePublicField</span>, <span class="hljs-number">0</span>
);
assert.<span class="hljs-title function_">equal</span>(
  inst.<span class="hljs-property">property</span>, <span class="hljs-string">'constrArg'</span>
);
</pre>
<p>If we create an instance property inside the constructor (line B), we don’t need to “declare” it elsewhere. As we have already seen, that is different for instance private fields.</p>
<p>Note that instance properties are relatively common in JavaScript; much more so than in, e.g., Java, where most instance state is private.</p>
<h5 id="instance-public-fields-quoted-keys-computed-keys"><a class="heading-id-link" href="#instance-public-fields-quoted-keys-computed-keys">31.5.1.1 Instance public fields with quoted and computed keys<span> (advanced)</span></a></h5>
<pre class="language-js">
<span class="hljs-keyword">const</span> computedFieldKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'computedFieldKey'</span>);
<span class="hljs-keyword">class</span> <span class="hljs-title class_">InstPublicClass2</span> {
  <span class="hljs-string">'quoted field key'</span> = <span class="hljs-number">1</span>;
  [computedFieldKey] = <span class="hljs-number">2</span>;
}
<span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstPublicClass2</span>();
assert.<span class="hljs-title function_">equal</span>(inst[<span class="hljs-string">'quoted field key'</span>], <span class="hljs-number">1</span>);
assert.<span class="hljs-title function_">equal</span>(inst[computedFieldKey], <span class="hljs-number">2</span>);
</pre>
<h5 id="what-is-the-value-of-this-in-instance-public-fields-advanced"><a class="heading-id-link" href="#what-is-the-value-of-this-in-instance-public-fields-advanced">31.5.1.2 What is the value of <code>this</code> in instance public fields?<span> (advanced)</span></a></h5>
<p>In the initializer of a instance public field, <code>this</code> refers to the newly created instance:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  instancePublicField = <span class="hljs-variable language_">this</span>;
}
<span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();
assert.<span class="hljs-title function_">equal</span>(
  inst.<span class="hljs-property">instancePublicField</span>, inst
);
</pre>
<h5 id="when-are-instance-public-fields-executed-advanced"><a class="heading-id-link" href="#when-are-instance-public-fields-executed-advanced">31.5.1.3 When are instance public fields executed?<span> (advanced)</span></a></h5>
<p>The execution of instance public fields roughly follows these two rules:</p>
<ul>
  <li>
    In base classes (classes without superclasses), instance public fields are executed immediately before the constructor.
  </li>
  <li>
    In derived classes (classes with superclasses):
    <ul>
      <li>
        The superclass sets up its instance slots when <code>super()</code> is called.
      </li>
      <li>
        Instance public fields are executed immediately after <code>super()</code>.
      </li>
    </ul>
  </li>
</ul>
<p>The following example demonstrates these rules:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperClass</span> {
  superProp = <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'superProp'</span>);
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'super-constructor'</span>);</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">SuperClass</span> {</span>
<span class="hljs-params">  subProp = <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'subProp'</span>);</span>
<span class="hljs-params">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {</span>
<span class="hljs-params">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'BEFORE super()'</span>);</span>
<span class="hljs-params">    <span class="hljs-variable language_">super</span>();</span>
<span class="hljs-params">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'AFTER super()'</span>);</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-keyword">new</span> <span class="hljs-title class_">SubClass</span>();</span>
</pre>
<p>Output:</p>
<pre>
BEFORE super()
superProp
super-constructor
subProp
AFTER super()
</pre>
<p><code>extends</code> and subclassing are explained <a href="#subclassing">later in this chapter</a>.</p>
<h4 id="instance-private-fields"><a class="heading-id-link" href="#instance-private-fields">31.5.2 Instance private fields</a></h4>
<p>The following class contains two instance private fields (line A and line B):</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">InstPrivateClass</span> {
  #privateField1 = <span class="hljs-string">'private field 1'</span>; <span class="hljs-comment">// (A)</span>
  #privateField2; <span class="hljs-comment">// (B) required!</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-variable language_">this</span>.#privateField2 = value; <span class="hljs-comment">// (C)</span>
  }
  <span class="hljs-comment">/**</span>
<span class="hljs-comment">   * Private fields are not accessible outside the class body.</span>
<span class="hljs-comment">   */</span>
  <span class="hljs-title function_">checkPrivateValues</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">      <span class="hljs-variable language_">this</span>.#privateField1, <span class="hljs-string">'private field 1'</span></span>
<span class="hljs-params">    );</span>
<span class="hljs-params">    assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">      <span class="hljs-variable language_">this</span>.#privateField2, <span class="hljs-string">'constructor argument'</span></span>
<span class="hljs-params">    );</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<code/>
<span class="hljs-params"><span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstPrivateClass</span>(<span class="hljs-string">'constructor argument'</span>);</span>
<span class="hljs-params">  inst.<span class="hljs-title function_">checkPrivateValues</span>();</span>
<code/>
<span class="hljs-params"><span class="hljs-comment">// No instance properties were created</span></span>
<span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span>
<span class="hljs-params">  <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(inst),</span>
<span class="hljs-params">  []</span>
<span class="hljs-params">);</span>
</pre>
<p>Note that we can only use <code>.#privateField2</code> in line C if we declare it in the class body.</p>
<h4 id="private-instance-data-before-es2022-advanced"><a class="heading-id-link" href="#private-instance-data-before-es2022-advanced">31.5.3 Private instance data before ES2022<span> (advanced)</span></a></h4>
<p>In this section, we look at two techniques for keeping instance data private. Because they don’t rely on classes, we can also use them for objects that were created in other ways – e.g., via object literals.</p>
<h5 id="before-es6-private-members-via-naming-conventions"><a class="heading-id-link" href="#before-es6-private-members-via-naming-conventions">31.5.3.1 Before ES6: private members via naming conventions</a></h5>
<p>The first technique makes a property private by prefixing its name with an underscore. This doesn’t protect the property in any way; it merely signals to the outside: “You don’t need to know about this property.”</p>
<p>In the following code, the properties <code>._counter</code> and <code>._action</code> are private.</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Countdown</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">counter, action</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_counter</span> = counter;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_action</span> = action;
  }
  <span class="hljs-title function_">dec</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_counter</span>--;</span>
<span class="hljs-params">    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">_counter</span> === <span class="hljs-number">0</span>) {</span>
<span class="hljs-params">      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_action</span>();</span>
<span class="hljs-params">    }</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<code/>
<span class="hljs-params"><span class="hljs-comment">// The two properties aren’t really private:</span></span>
<span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span>
<span class="hljs-params">  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Countdown</span>()),</span>
<span class="hljs-params">  [<span class="hljs-string">'_counter'</span>, <span class="hljs-string">'_action'</span>]);</span>
</pre>
<p>With this technique, we don’t get any protection and private names can clash. On the plus side, it is easy to use.</p>
<p>Private methods work similarly: They are normal methods whose names start with underscores.</p>
<h5 id="es6-and-later-private-instance-data-via-weakmaps"><a class="heading-id-link" href="#es6-and-later-private-instance-data-via-weakmaps">31.5.3.2 ES6 and later: private instance data via WeakMaps</a></h5>
<p>We can also manage private instance data via WeakMaps:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> _counter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();
<span class="hljs-keyword">const</span> _action = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();
<code/>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Countdown</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">counter, action</span>) {
    _counter.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, counter);
    _action.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, action);
  }
  <span class="hljs-title function_">dec</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-keyword">let</span> counter = _counter.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>);</span>
<span class="hljs-params">    counter--;</span>
<span class="hljs-params">    _counter.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, counter);</span>
<span class="hljs-params">    <span class="hljs-keyword">if</span> (counter === <span class="hljs-number">0</span>) {</span>
<span class="hljs-params">      _action.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>)();</span>
<span class="hljs-params">    }</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<code/>
<span class="hljs-params"><span class="hljs-comment">// The two pseudo-properties are truly private:</span></span>
<span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span>
<span class="hljs-params">  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Countdown</span>()),</span>
<span class="hljs-params">  []);</span>
</pre>
<p>How exactly that works is explained <a href="ch_weakmaps.html#private-data-in-weakmaps">in the chapter on WeakMaps</a>.</p>
<p>This technique offers us considerable protection from outside access and there can’t be any name clashes. But it is also more complicated to use.</p>
<p>We control the visibility of the pseudo-property <code>_superProp</code> by controlling who has access to it – for example: If the variable exists inside a module and isn’t exported, everyone inside the module and no one outside the module can access it. In other words: The scope of privacy isn’t the class in this case, it’s the module. We could narrow the scope, though:</p>
<pre class="language-js">
<span class="hljs-keyword">let</span> <span class="hljs-title class_">Countdown</span>;
{ <span class="hljs-comment">// class scope</span>
  <span class="hljs-keyword">const</span> _counter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();
  <span class="hljs-keyword">const</span> _action = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();
<code/>
  <span class="hljs-title class_">Countdown</span> = <span class="hljs-keyword">class</span> {
    <span class="hljs-comment">// ···</span>
  }
}
</pre>
<p>This technique doesn’t really support private methods. But module-local functions that have access to <code>_superProp</code> are the next best thing:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> _counter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();
<span class="hljs-keyword">const</span> _action = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();
<code/>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Countdown</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">counter, action</span>) {
    _counter.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, counter);
    _action.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, action);
  }
  <span class="hljs-title function_">dec</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-title function_">privateDec</span>(<span class="hljs-variable language_">this</span>);</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<code/>
<span class="hljs-params"><span class="hljs-keyword">function</span> <span class="hljs-title function_">privateDec</span>(<span class="hljs-params">_this</span>) { <span class="hljs-comment">// (A)</span></span>
<span class="hljs-params">  <span class="hljs-keyword">let</span> counter = _counter.<span class="hljs-title function_">get</span>(_this);</span>
<span class="hljs-params">  counter--;</span>
<span class="hljs-params">  _counter.<span class="hljs-title function_">set</span>(_this, counter);</span>
<span class="hljs-params">  <span class="hljs-keyword">if</span> (counter === <span class="hljs-number">0</span>) {</span>
<span class="hljs-params">    _action.<span class="hljs-title function_">get</span>(_this)();</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
</pre>
<p>Note that <code>this</code> becomes the explicit function parameter <code>_this</code> (line A).</p>
<h4 id="instance-protected-fields"><a class="heading-id-link" href="#instance-protected-fields">31.5.4 Simulating protected visibility and friend visibility via WeakMaps<span> (advanced)</span></a></h4>
<p>As previously discussed, instance private fields are only visible inside their classes and not even in subclasses. Thus, there is no built-in way to get:</p>
<ul>
  <li>
    Protected visibility: A class and all of its subclasses can access a piece instance data.
  </li>
  <li>
    Friend visibility: A class and its “friends” (designated functions, objects, or classes) can access a piece of instance data.
  </li>
</ul>
<p>In the previous subsection, we simulated “module visibility” (everyone inside a module has access to a piece of instance data) via WeakMaps. Therefore:</p>
<ul>
  <li>
    If we put a class and its subclasses into the same module, we get protected visibility.
  </li>
  <li>
    If we put a class and its friends into the same module, we get friend visibility.
  </li>
</ul>
<p>The next example demonstrates protected visibility:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> _superProp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperClass</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    _superProp.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">'superProp'</span>);</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">SuperClass</span> {</span>
<span class="hljs-params">  <span class="hljs-title function_">getSuperProp</span>(<span class="hljs-params"/>) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> _superProp.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>);</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubClass</span>().<span class="hljs-title function_">getSuperProp</span>(),</span>
<span class="hljs-params">  <span class="hljs-string">'superProp'</span></span>
<span class="hljs-params">);</span>
</pre>
<p><a href="#subclassing">Subclassing via <code>extends</code></a> is explained later in this chapter.</p>
<h3 id="static-members-of-classes"><a class="heading-id-link" href="#static-members-of-classes">31.6 Static members of classes</a></h3>
<h4 id="static-public-methods-and-accessors"><a class="heading-id-link" href="#static-public-methods-and-accessors">31.6.1 Static public methods and accessors</a></h4>
<p>All members in the body of the following class declaration create so-called <em>static</em> properties – properties of <code>StaticClass</code> itself.</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticPublicMethodsClass</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">staticMethod</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">'staticMethod'</span>;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> <span class="hljs-title function_">staticAccessor</span>() {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">'staticGetter'</span>;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">set</span> <span class="hljs-title function_">staticAccessor</span>(<span class="hljs-params">value</span>) {</span>
<span class="hljs-params">    assert.<span class="hljs-title function_">equal</span>(value, <span class="hljs-string">'staticSetter'</span>);</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">  <span class="hljs-title class_">StaticPublicMethodsClass</span>.<span class="hljs-title function_">staticMethod</span>(), <span class="hljs-string">'staticMethod'</span></span>
<span class="hljs-params">);</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">  <span class="hljs-title class_">StaticPublicMethodsClass</span>.<span class="hljs-property">staticAccessor</span>, <span class="hljs-string">'staticGetter'</span></span>
<span class="hljs-params">);</span>
<span class="hljs-params"><span class="hljs-title class_">StaticPublicMethodsClass</span>.<span class="hljs-property">staticAccessor</span> = <span class="hljs-string">'staticSetter'</span>;</span>
</pre>
<h5 id="all-kinds-of-static-public-methods-and-accessors-advanced"><a class="heading-id-link" href="#all-kinds-of-static-public-methods-and-accessors-advanced">31.6.1.1 All kinds of static public methods and accessors<span> (advanced)</span></a></h5>
<pre class="language-js">
<span class="hljs-keyword">const</span> accessorKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'accessorKey'</span>);
<span class="hljs-keyword">const</span> syncMethodKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'syncMethodKey'</span>);
<span class="hljs-keyword">const</span> syncGenMethodKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'syncGenMethodKey'</span>);
<span class="hljs-keyword">const</span> asyncMethodKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'asyncMethodKey'</span>);
<span class="hljs-keyword">const</span> asyncGenMethodKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'asyncGenMethodKey'</span>);
<code/>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticPublicMethodsClass2</span> {
  <span class="hljs-comment">// Identifier keys</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> <span class="hljs-title function_">accessor</span>() {}
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">set</span> <span class="hljs-title function_">accessor</span>(<span class="hljs-params">value</span>) {}
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">syncMethod</span>(<span class="hljs-params">) {}</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> * <span class="hljs-title function_">syncGeneratorMethod</span>(<span class="hljs-params"/>) {}</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">asyncMethod</span>(<span class="hljs-params"/>) {}</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> * <span class="hljs-title function_">asyncGeneratorMethod</span>(<span class="hljs-params"/>) {}</span>
<code/>
<span class="hljs-params">  <span class="hljs-comment">// Quoted keys</span></span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> get <span class="hljs-string">'an accessor'</span>() {}</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> set <span class="hljs-string">'an accessor'</span>(value) {}</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-string">'sync method'</span>() {}</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> * <span class="hljs-string">'sync generator method'</span>() {}</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-string">'async method'</span>() {}</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> * <span class="hljs-string">'async generator method'</span>() {}</span>
<code/>
<span class="hljs-params">  <span class="hljs-comment">// Computed keys</span></span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> get [accessorKey]() {}</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> set [accessorKey](value) {}</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> [syncMethodKey]() {}</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> * [syncGenMethodKey]() {}</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> [asyncMethodKey]() {}</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> * [asyncGenMethodKey]() {}</span>
<span class="hljs-params">}</span>
<code/>
<span class="hljs-params"><span class="hljs-comment">// Quoted and computed keys are accessed via square brackets:</span></span>
<span class="hljs-params"><span class="hljs-title class_">StaticPublicMethodsClass2</span>[<span class="hljs-string">'sync method'</span>]();</span>
<span class="hljs-params"><span class="hljs-title class_">StaticPublicMethodsClass2</span>[syncMethodKey]();</span>
</pre>
<p>Quoted and computed keys can also be used in object literals:</p>
<ul>
  <li>
    <a href="ch_objects.html#object-literals-quoted-keys">“Quoted keys in object literals” (§30.9.1)</a>
  </li>
  <li>
    <a href="ch_objects.html#object-literals-computed-keys">“Computed keys in object literals” (§30.9.2)</a>
  </li>
</ul>
<p>More information on accessors (defined via getters and/or setters), generators, async methods, and async generator methods:</p>
<ul>
  <li>
    <a href="ch_objects.html#object-literal-accessors">“Object literals: accessors” (§30.3.6)</a>
  </li>
  <li>
    <a href="ch_sync-generators.html#ch_sync-generators">“Synchronous generators<span> <sup>ES6</sup> (advanced)</span>” (§33)</a>
  </li>
  <li>
    <a href="ch_async-functions.html#ch_async-functions">“Async functions<span> <sup>ES2017</sup></span>” (§44)</a>
  </li>
  <li>
    <a href="ch_async-iteration.html#async-generators">“Asynchronous generators” (§45.2)</a>
  </li>
</ul>
<h4 id="static-public-fields"><a class="heading-id-link" href="#static-public-fields">31.6.2 Static public fields<span> <sup>ES2022</sup></span></a></h4>
<p>The following code demonstrates static public fields. <code>StaticPublicFieldClass</code> has three of them:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> computedFieldKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'computedFieldKey'</span>);
<span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticPublicFieldClass</span> {
  <span class="hljs-keyword">static</span> identifierFieldKey = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-string">'quoted field key'</span> = <span class="hljs-number">2</span>;
  <span class="hljs-keyword">static</span> [computedFieldKey] = <span class="hljs-number">3</span>;
}
<code/>
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(<span class="hljs-title class_">StaticPublicFieldClass</span>),
  [
    <span class="hljs-string">'length'</span>, <span class="hljs-comment">// number of constructor parameters</span>
    <span class="hljs-string">'name'</span>, <span class="hljs-comment">// 'StaticPublicFieldClass'</span>
    <span class="hljs-string">'prototype'</span>,
    <span class="hljs-string">'identifierFieldKey'</span>,
    <span class="hljs-string">'quoted field key'</span>,
    computedFieldKey,
  ],
);
<code/>
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">StaticPublicFieldClass</span>.<span class="hljs-property">identifierFieldKey</span>, <span class="hljs-number">1</span>);
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">StaticPublicFieldClass</span>[<span class="hljs-string">'quoted field key'</span>], <span class="hljs-number">2</span>);
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">StaticPublicFieldClass</span>[computedFieldKey], <span class="hljs-number">3</span>);
</pre>
<h4 id="static-private-methods-accessors-fields"><a class="heading-id-link" href="#static-private-methods-accessors-fields">31.6.3 Static private methods, accessors, and fields<span> <sup>ES2022</sup></span></a></h4>
<p>The following class has two static private slots (line A and line B):</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticPrivateClass</span> {
  <span class="hljs-comment">// Declare and initialize</span>
  <span class="hljs-keyword">static</span> #staticPrivateField = <span class="hljs-string">'hello'</span>; <span class="hljs-comment">// (A)</span>
  <span class="hljs-keyword">static</span> #<span class="hljs-title function_">twice</span>(<span class="hljs-params">) { <span class="hljs-comment">// (B)</span></span>
<span class="hljs-params">    <span class="hljs-keyword">const</span> str = <span class="hljs-title class_">StaticPrivateClass</span>.#staticPrivateField;</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> str + <span class="hljs-string">' '</span> + str;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getResultOfTwice</span>(<span class="hljs-params"/>) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-title class_">StaticPrivateClass</span>.#<span class="hljs-title function_">twice</span>();</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<code/>
<span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span>
<span class="hljs-params">  <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(<span class="hljs-title class_">StaticPrivateClass</span>),</span>
<span class="hljs-params">  [</span>
<span class="hljs-params">    <span class="hljs-string">'length'</span>, <span class="hljs-comment">// number of constructor parameters</span></span>
<span class="hljs-params">    <span class="hljs-string">'name'</span>, <span class="hljs-comment">// 'StaticPublicFieldClass'</span></span>
<span class="hljs-params">    <span class="hljs-string">'prototype'</span>,</span>
<span class="hljs-params">    <span class="hljs-string">'getResultOfTwice'</span>,</span>
<span class="hljs-params">  ],</span>
<span class="hljs-params">);</span>
<code/>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">  <span class="hljs-title class_">StaticPrivateClass</span>.<span class="hljs-title function_">getResultOfTwice</span>(),</span>
<span class="hljs-params">  <span class="hljs-string">'hello hello'</span></span>
<span class="hljs-params">);</span>
</pre>
<p>This is a complete list of all kinds of static private slots:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  <span class="hljs-keyword">static</span> #<span class="hljs-title function_">staticPrivateMethod</span>(<span class="hljs-params">) {}</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> * #<span class="hljs-title function_">staticPrivateGeneratorMethod</span>(<span class="hljs-params"/>) {}</span>
<code/>
<span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> #<span class="hljs-title function_">staticPrivateAsyncMethod</span>(<span class="hljs-params"/>) {}</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> * #<span class="hljs-title function_">staticPrivateAsyncGeneratorMethod</span>(<span class="hljs-params"/>) {}</span>
<span class="hljs-params">  </span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> get #<span class="hljs-title function_">staticPrivateAccessor</span>(<span class="hljs-params"/>) {}</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> set #<span class="hljs-title function_">staticPrivateAccessor</span>(<span class="hljs-params">value</span>) {}</span>
<span class="hljs-params">}</span>
</pre>
<h4 id="class-static-initialization-blocks"><a class="heading-id-link" href="#class-static-initialization-blocks">31.6.4 Static initialization blocks in classes<span> <sup>ES2022</sup></span></a></h4>
<p>To set up instance data via classes, we have two constructs:</p>
<ul>
  <li>
    <em>Fields</em>, to create and optionally initialize instance data
  </li>
  <li>
    <em>Constructors</em>, blocks of code that are executed every time a new instance is created
  </li>
</ul>
<p>For static data, we have:</p>
<ul>
  <li>
    <em>Static fields</em>
  </li>
  <li>
    <em>Static blocks</em> that are executed when a class is created
  </li>
</ul>
<p>The following code demonstrates static blocks (line A):</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Translator</span> {
  <span class="hljs-keyword">static</span> translations = {
    <span class="hljs-attr">yes</span>: <span class="hljs-string">'ja'</span>,
    <span class="hljs-attr">no</span>: <span class="hljs-string">'nein'</span>,
    <span class="hljs-attr">maybe</span>: <span class="hljs-string">'vielleicht'</span>,
  };
  <span class="hljs-keyword">static</span> englishWords = [];
  <span class="hljs-keyword">static</span> germanWords = [];
  <span class="hljs-keyword">static</span> { <span class="hljs-comment">// (A)</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [english, german] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">translations</span>)) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">englishWords</span>.<span class="hljs-title function_">push</span>(english);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">germanWords</span>.<span class="hljs-title function_">push</span>(german);
    }
  }
}
</pre>
<p>We could also execute the code inside the static block after the class (at the top level). However, using a static block has two benefits:</p>
<ul>
  <li>
    All class-related code is inside the class.
  </li>
  <li>
    The code in a static block has access to private slots.
  </li>
</ul>
<h5 id="rules-for-static-initialization-blocks"><a class="heading-id-link" href="#rules-for-static-initialization-blocks">31.6.4.1 Rules for static initialization blocks</a></h5>
<p>The rules for how static initialization blocks work, are relatively simple:</p>
<ul>
  <li>
    There can be more than one static block per class.
  </li>
  <li>
    The execution of static blocks is interleaved with the execution of static field initializers.
  </li>
  <li>
    The static members of a superclass are executed before the static members of a subclass.
  </li>
</ul>
<p>The following code demonstrates these rules:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperClass</span> {
  <span class="hljs-keyword">static</span> superField1 = <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'superField1'</span>);
  <span class="hljs-keyword">static</span> {
    assert.<span class="hljs-title function_">equal</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-title class_">SuperClass</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'static block 1 SuperClass'</span>);
  }
  <span class="hljs-keyword">static</span> superField2 = <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'superField2'</span>);
  <span class="hljs-keyword">static</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'static block 2 SuperClass'</span>);
  }
}
<code/>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">SuperClass</span> {
  <span class="hljs-keyword">static</span> subField1 = <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'subField1'</span>);
  <span class="hljs-keyword">static</span> {
    assert.<span class="hljs-title function_">equal</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-title class_">SubClass</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'static block 1 SubClass'</span>);
  }
  <span class="hljs-keyword">static</span> subField2 = <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'subField2'</span>);
  <span class="hljs-keyword">static</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'static block 2 SubClass'</span>);
  }
}
</pre>
<p>Output:</p>
<pre>
superField1
static block 1 SuperClass
superField2
static block 2 SuperClass
subField1
static block 1 SubClass
subField2
static block 2 SubClass
</pre>
<p><a href="#subclassing">Subclassing via <code>extends</code></a> is explained later in this chapter.</p>
<h4 id="this-and-static-private-fields"><a class="heading-id-link" href="#this-and-static-private-fields">31.6.5 Pitfall: Using <code>this</code> to access static private fields</a></h4>
<p>In static public members, we can access static public slots via <code>this</code>. Alas, we should not use it to access static private slots.</p>
<h5 id="this-and-static-public-fields"><a class="heading-id-link" href="#this-and-static-public-fields">31.6.5.1 <code>this</code> and static public fields</a></h5>
<p>Consider the following code:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperClass</span> {
  <span class="hljs-keyword">static</span> publicData = <span class="hljs-number">1</span>;
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getPublicViaThis</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">publicData</span>;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">SuperClass</span> {</span>
<span class="hljs-params">}</span>
</pre>
<p><a href="#subclassing">Subclassing via <code>extends</code></a> is explained later in this chapter.</p>
<p>Static public fields are properties. If we make the method call</p>
<pre class="language-js">
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">SuperClass</span>.<span class="hljs-title function_">getPublicViaThis</span>(), <span class="hljs-number">1</span>);
</pre>
<p>then <code>this</code> points to <code>SuperClass</code> and everything works as expected. We can also invoke <code>.getPublicViaThis()</code> via the subclass:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">SubClass</span>.<span class="hljs-title function_">getPublicViaThis</span>(), <span class="hljs-number">1</span>);
</pre>
<p><code>SubClass</code> inherits <code>.getPublicViaThis()</code> from its prototype <code>SuperClass</code>. <code>this</code> points to <code>SubClass</code> and things continue to work, because <code>SubClass</code> also inherits the property <code>.publicData</code>.</p>
<p>As an aside, if we assigned to <code>this.publicData</code> in <code>getPublicViaThis()</code> and invoked it via <code>SubClass.getPublicViaThis()</code>, then we would create a new own poperty of <code>SubClass</code> that (non-destructively) overrides the property inherited from <code>SuperClass</code>.</p>
<h5 id="this-and-static-private-fields-1"><a class="heading-id-link" href="#this-and-static-private-fields-1">31.6.5.2 <code>this</code> and static private fields</a></h5>
<p>Consider the following code:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperClass</span> {
  <span class="hljs-keyword">static</span> #privateData = <span class="hljs-number">2</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getPrivateDataViaThis</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#privateData;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getPrivateDataViaClassName</span>(<span class="hljs-params"/>) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-title class_">SuperClass</span>.#privateData;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<span class="hljs-params"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">SuperClass</span> {</span>
<span class="hljs-params">}</span>
</pre>
<p>Invoking <code>.getPrivateDataViaThis()</code> via <code>SuperClass</code> works, because <code>this</code> points to <code>SuperClass</code>:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">SuperClass</span>.<span class="hljs-title function_">getPrivateDataViaThis</span>(), <span class="hljs-number">2</span>);
</pre>
<p>However, invoking <code>.getPrivateDataViaThis()</code> via <code>SubClass</code> does not work, because <code>this</code> now points to <code>SubClass</code> and <code>SubClass</code> has no static private field <code>.#privateData</code> (private slots in prototype chains are not inherited):</p>
<pre class="language-js">
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">SubClass</span>.<span class="hljs-title function_">getPrivateDataViaThis</span>(),
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'TypeError'</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">'Cannot read private member #privateData from'</span>
      + <span class="hljs-string">' an object whose class did not declare it'</span>,
  }
);
</pre>
<p>The workaround is to accesss <code>.#privateData</code> directly, via <code>SuperClass</code>:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">SubClass</span>.<span class="hljs-title function_">getPrivateDataViaClassName</span>(), <span class="hljs-number">2</span>);
</pre>
<p>With static private methods, we are facing the same issue.</p>
<h4 id="all-members-static-prototype-instance-can-access-all-private-members"><a class="heading-id-link" href="#all-members-static-prototype-instance-can-access-all-private-members">31.6.6 All members (static, prototype, instance) can access all private members</a></h4>
<p>Every member inside a class can access all other members inside that class – both public and private ones:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoClass</span> {
  <span class="hljs-keyword">static</span> #staticPrivateField = <span class="hljs-number">1</span>;
  #instPrivField = <span class="hljs-number">2</span>;
<code/>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">staticMethod</span>(<span class="hljs-params">inst</span>) {
    <span class="hljs-comment">// A static method can access static private fields</span>
    <span class="hljs-comment">// and instance private fields</span>
    assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">DemoClass</span>.#staticPrivateField, <span class="hljs-number">1</span>);
    assert.<span class="hljs-title function_">equal</span>(inst.#instPrivField, <span class="hljs-number">2</span>);
  }
<code/>
  <span class="hljs-title function_">protoMethod</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-comment">// A prototype method can access instance private fields</span></span>
<span class="hljs-params">    <span class="hljs-comment">// and static private fields</span></span>
<span class="hljs-params">    assert.<span class="hljs-title function_">equal</span>(<span class="hljs-variable language_">this</span>.#instPrivField, <span class="hljs-number">2</span>);</span>
<span class="hljs-params">    assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">DemoClass</span>.#staticPrivateField, <span class="hljs-number">1</span>);</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
</pre>
<p>In contrast, no one outside can access the private members:</p>
<pre class="language-js">
<span class="hljs-comment">// Accessing private fields outside their classes triggers</span>
<span class="hljs-comment">// syntax errors (before the code is even executed).</span>
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">eval</span>(<span class="hljs-string">'DemoClass.#staticPrivateField'</span>),
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'SyntaxError'</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">"Private field '#staticPrivateField' must"</span>
      + <span class="hljs-string">" be declared in an enclosing class"</span>,
  }
);
<span class="hljs-comment">// Accessing private fields outside their classes triggers</span>
<span class="hljs-comment">// syntax errors (before the code is even executed).</span>
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">eval</span>(<span class="hljs-string">'new DemoClass().#instPrivField'</span>),
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'SyntaxError'</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">"Private field '#instPrivField' must"</span>
      + <span class="hljs-string">" be declared in an enclosing class"</span>,
  }
);
</pre>
<h4 id="static-private-methods-and-data-before-es2022"><a class="heading-id-link" href="#static-private-methods-and-data-before-es2022">31.6.7 Static private methods and data before ES2022</a></h4>
<p>The following code only works in ES2022 – due to every line that has a hash symbol (<code>#</code>) in it:</p>
<pre class="language-js">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticClass</span> {
  <span class="hljs-keyword">static</span> #secret = <span class="hljs-string">'Rumpelstiltskin'</span>;
  <span class="hljs-keyword">static</span> #<span class="hljs-title function_">getSecretInParens</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">`(<span class="hljs-subst">${StaticClass.#secret}</span>)`</span>;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-title function_">callStaticPrivateMethod</span>(<span class="hljs-params"/>) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-title class_">StaticClass</span>.#<span class="hljs-title function_">getSecretInParens</span>();</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
</pre>
<p>Since private slots only exist once per class, we can move <code>.#secret</code> and <code>.#getSecretInParens</code> to the scope surrounding the class and use a module to hide them from the world outside the module:</p>
<ul>
  <li>
    <code>.#secret</code> becomes a top-level variable in the module.
  </li>
  <li>
    <code>.getSecretInParens()</code> becomes a top-level function in the module.
  </li>
</ul>
<p>The result looks as follows:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> secret = <span class="hljs-string">'Rumpelstiltskin'</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getSecretInParens</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">  <span class="hljs-keyword">return</span> <span class="hljs-string">`(<span class="hljs-subst">${secret}</span>)`</span>;</span>
<span class="hljs-params">}</span>
<code/>
<span class="hljs-params"><span class="hljs-comment">// Only the class is accessible outside the module</span></span>
<span class="hljs-params"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticClass</span> {</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-title function_">callStaticPrivateMethod</span>(<span class="hljs-params"/>) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getSecretInParens</span>();</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
</pre>
<h4 id="static-factory-methods"><a class="heading-id-link" href="#static-factory-methods">31.6.8 Static factory methods</a></h4>
<p>Sometimes there are multiple ways in which a class can be instantiated. Then we can implement <em>static factory methods</em> such as <code>Point.fromPolar()</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">fromPolar</span>(<span class="hljs-params">radius, angle</span>) {
    <span class="hljs-keyword">const</span> x = radius * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(angle);
    <span class="hljs-keyword">const</span> y = radius * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(angle);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(x, y);
  }
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;
  }
}
<code/>
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Point</span>.<span class="hljs-title function_">fromPolar</span>(<span class="hljs-number">13</span>, <span class="hljs-number">0.39479111969976155</span>),
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">12</span>, <span class="hljs-number">5</span>)
);
</pre>
<p>I like how descriptive static factory methods are: <code>fromPolar</code> describes how an instance is created. JavaScript’s standard library also has such factory methods – for example:</p>
<ul>
  <li>
    <code>Array.from()</code>
  </li>
  <li>
    <code>Object.create()</code>
  </li>
</ul>
<p>I prefer to either have no static factory methods or <em>only</em> static factory methods. Things to consider in the latter case:</p>
<ul>
  <li>
    One factory method will probably directly call the constructor (but have a descriptive name).
  </li>
  <li>
    We need to find a way to prevent the constructor being called from outside.
  </li>
</ul>
<p>In the following code, we use a secret token (line A) to prevent the constructor being called from outside the current module.</p>
<pre class="language-js">
<span class="hljs-comment">// Only accessible inside the current module</span>
<span class="hljs-keyword">const</span> secretToken = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'secretToken'</span>); <span class="hljs-comment">// (A)</span>
<code/>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(secretToken, x, y);
  }
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">fromPolar</span>(<span class="hljs-params">radius, angle</span>) {
    <span class="hljs-keyword">const</span> x = radius * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(angle);
    <span class="hljs-keyword">const</span> y = radius * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(angle);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(secretToken, x, y);
  }
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">token, x, y</span>) {
    <span class="hljs-keyword">if</span> (token !== secretToken) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">'Must use static factory method'</span>);
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;
  }
}
<span class="hljs-title class_">Point</span>.<span class="hljs-title function_">create</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// OK</span>
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>),
  <span class="hljs-title class_">TypeError</span>
);
</pre>
<h3 id="subclassing"><a class="heading-id-link" href="#subclassing">31.7 Subclassing</a></h3>
<h4 id="defining-subclasses-via-extends"><a class="heading-id-link" href="#defining-subclasses-via-extends">31.7.1 Defining subclasses via <code>extends</code></a></h4>
<p><span id="index-entry-extends"/>
<span id="index-entry-extending-classes"/><span id="index-entry-classes--extending"/>
<span id="index-entry-subclassing"/>
<span id="index-entry-subclass"/><span id="index-entry-superclass"/>
<span id="index-entry-base-class"/><span id="index-entry-class--base"/>
<span id="index-entry-derived-class"/><span id="index-entry-class--derived"/></p>
<p>Classes can extend existing classes. For example, the following class <code>Employee</code> extends <code>Person</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  #firstName;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">firstName</span>) {
    <span class="hljs-variable language_">this</span>.#firstName = firstName;
  }
  <span class="hljs-title function_">describe</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">`Person named <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.#firstName}</span>`</span>;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-title function_">extractNames</span>(<span class="hljs-params">persons</span>) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> persons.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">person</span> =&gt;</span> person.#firstName);</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<code/>
<span class="hljs-params"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> {</span>
<span class="hljs-params">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">firstName, title</span>) {</span>
<span class="hljs-params">    <span class="hljs-variable language_">super</span>(firstName);</span>
<span class="hljs-params">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = title;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">  <span class="hljs-title function_">describe</span>(<span class="hljs-params"/>) {</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">describe</span>() +</span>
<span class="hljs-params">      <span class="hljs-string">` (<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.title}</span>)`</span>;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">}</span>
<code/>
<span class="hljs-params"><span class="hljs-keyword">const</span> jane = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">'Jane'</span>, <span class="hljs-string">'CTO'</span>);</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">  jane.<span class="hljs-property">title</span>,</span>
<span class="hljs-params">  <span class="hljs-string">'CTO'</span></span>
<span class="hljs-params">);</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">  jane.<span class="hljs-title function_">describe</span>(),</span>
<span class="hljs-params">  <span class="hljs-string">'Person named Jane (CTO)'</span></span>
<span class="hljs-params">);</span>
</pre>
<p>Terminology related to extending:</p>
<ul>
  <li>
    Another word for <em>extending</em> is <em>subclassing</em>.
  </li>
  <li>
    <code>Person</code> is the superclass of <code>Employee</code>.
  </li>
  <li>
    <code>Employee</code> is the subclass of <code>Person</code>.
  </li>
  <li>
    A <em>base class</em> is a class that has no superclasses.
  </li>
  <li>
    A <em>derived class</em> is a class that has a superclass.
  </li>
</ul>
<p>Inside the <code>.constructor()</code> of a derived class, we must call the super-constructor via <code>super()</code> before we can access <code>this</code>. Why is that?</p>
<p>Let’s consider a chain of classes:</p>
<ul>
  <li>
    Base class <code>A</code>
  </li>
  <li>
    Class <code>B</code> extends <code>A</code>.
  </li>
  <li>
    Class <code>C</code> extends <code>B</code>.
  </li>
</ul>
<p>If we invoke <code>new C()</code>, <code>C</code>’s constructor super-calls <code>B</code>’s constructor which super-calls <code>A</code>’s constructor. Instances are always created in base classes, before the constructors of subclasses add their slots. Therefore, the instance doesn’t exist before we call <code>super()</code> and we can’t access it via <code>this</code>, yet.</p>
<p>Note that static public slots are inherited. For example, <code>Employee</code> inherits the static method <code>.extractNames()</code>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'extractNames'</span> <span class="hljs-keyword">in</span> <span class="hljs-title class_">Employee</span></span>
true
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Subclassing</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/classes/color_point_class_test.mjs</code></p>
</div>
<h4 id="internals-of-subclassing"><a class="heading-id-link" href="#internals-of-subclassing">31.7.2 The internals of subclassing<span> (advanced)</span></a></h4>
<figure id="fig:oo_subclassing" class="float">
  <p><img src="../Images/9e9cfd8d183a6ecd074a55a7eb578773.png" alt="" style="width:360.75px; height:223.59182px" data-original-src="https://exploringjs.com/js/book/img/classes/oo_subclassing.svg"/></p>
  <figcaption>
    <p><span class="float-label">Figure 31.4:</span> These are the objects that make up class <code>Person</code> and its subclass, <code>Employee</code>. The left column is about classes. The right column is about the <code>Employee</code> instance <code>jane</code> and its prototype chain.</p>
  </figcaption>
</figure>
<p>The classes <code>Person</code> and <code>Employee</code> from the previous section are made up of several objects (<a href="#fig:oo_subclassing">figure 31.4</a>). One key insight for understanding how these objects are related is that there are two prototype chains:</p>
<ul>
  <li>
    The instance prototype chain, on the right.
  </li>
  <li>
    The class prototype chain, on the left.
  </li>
</ul>
<p>Each class contributes a prototype to the instance prototype chain but is also in its own chain of prototypes.</p>
<h5 id="the-instance-prototype-chain-right-column"><a class="heading-id-link" href="#the-instance-prototype-chain-right-column">31.7.2.1 The instance prototype chain (right column)</a></h5>
<p>The instance prototype chain starts with <code>jane</code> and continues with <code>Employee.prototype</code> and <code>Person.prototype</code>. In principle, the prototype chain ends at this point, but we get one more object:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></span>
true
</pre>
<p><code>Object.prototype</code> provides services to virtually all objects, which is why it is included here, too. The prototype of <code>Object.prototype</code> is <code>null</code>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)</span>
null
</pre>
<h5 id="the-class-prototype-chain-left-column"><a class="heading-id-link" href="#the-class-prototype-chain-left-column">31.7.2.2 The class prototype chain (left column)</a></h5>
<p>In the class prototype chain, <code>Employee</code> comes first, <code>Person</code> next. In principle, the prototype chain ends at this point, but <code>Person</code> does have a prototype:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-title class_">Person</span>) === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></span>
true
</pre>
<p><code>Person</code> only has this prototype because it’s a function and <code>Function.prototype</code> is the prototype of all functions. (As an aside, the prototype of <code>Function.prototype</code> is <code>Object.prototype</code>.)</p>
<h4 id="instanceof-operator-details"><a class="heading-id-link" href="#instanceof-operator-details">31.7.3 The <code>instanceof</code> operator in detail<span> (advanced)</span></a></h4>
<p>We have not yet learned how <code>instanceof</code> really works: How does <code>instanceof</code> determine if a value <code>x</code> is an instance of a class <code>C</code>? Note that “instance of <code>C</code>” means direct instance of <code>C</code> or direct instance of a subclass of <code>C</code>.</p>
<p><code>instanceof</code> checks if <code>C.prototype</code> is in the prototype chain of <code>x</code>. That is, the following two expressions are equivalent:</p>
<pre class="language-js">
x <span class="hljs-keyword">instanceof</span> C
C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(x)
</pre>
<p>If we go back to <a href="#fig:oo_subclassing">figure 31.4</a>, we can confirm that the prototype chain does lead us to the following correct answers:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">jane <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Employee</span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">jane <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">jane <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span></span>
true
</pre>
<p>Note that <code>instanceof</code> always returns <code>false</code> if its self-hand side is a primitive value:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'abc'</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span></span>
false
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">123</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span></span>
false
</pre>
<h4 id="non-instances-of-object"><a class="heading-id-link" href="#non-instances-of-object">31.7.4 Not all objects are instances of <code>Object</code><span> (advanced)</span></a></h4>
<p>An object (a non-primitive value) is only an instance of <code>Object</code> if <code>Object.prototype</code> is in its prototype chain <a href="#instanceof-operator-details">(see previous subsection)</a>. Virtually all objects are instances of <code>Object</code> – for example:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">equal</span>(
  {<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>} <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>, <span class="hljs-literal">true</span>
);
assert.<span class="hljs-title function_">equal</span>(
  [<span class="hljs-string">'a'</span>] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>, <span class="hljs-literal">true</span>
);
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-regexp">/abc/g</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>, <span class="hljs-literal">true</span>
);
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>() <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>, <span class="hljs-literal">true</span>
);
<code/>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {}
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>() <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>, <span class="hljs-literal">true</span>
);
</pre>
<p>In the next example, <code>obj1</code> and <code>obj2</code> are both objects (line A and line C), but they are not instances of <code>Object</code> (line B and line D): <code>Object.prototype</code> is not in their prototype chains because they don’t have any prototypes.</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> obj1 = {<span class="hljs-attr">__proto__</span>: <span class="hljs-literal">null</span>};
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-keyword">typeof</span> obj1, <span class="hljs-string">'object'</span> <span class="hljs-comment">// (A)</span>
);
assert.<span class="hljs-title function_">equal</span>(
  obj1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>, <span class="hljs-literal">false</span> <span class="hljs-comment">// (B)</span>
);
<code/>
<span class="hljs-keyword">const</span> obj2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-keyword">typeof</span> obj2, <span class="hljs-string">'object'</span> <span class="hljs-comment">// (C)</span>
);
assert.<span class="hljs-title function_">equal</span>(
  obj2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>, <span class="hljs-literal">false</span> <span class="hljs-comment">// (D)</span>
);
</pre>
<p><code>Object.prototype</code> is the object that ends most prototype chains. Its prototype is <code>null</code>, which means it isn’t an instance of <code>Object</code> either:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></span>
'object'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)</span>
null
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span></span>
false
</pre>
<h4 id="base-class-vs-derived-class-advanced"><a class="heading-id-link" href="#base-class-vs-derived-class-advanced">31.7.5 Base class vs. derived class<span> (advanced)</span></a></h4>
<p>A base class is different from a class that extends <code>Object</code>.</p>
<p>The following class is derived from class <code>Object</code>. <a href="#fig:class-derived">Figure 31.5</a> shows its object diagram.</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">DerivedClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Object</span> {}
<span class="hljs-keyword">const</span> derivedInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DerivedClass</span>();
</pre>
<figure id="fig:class-derived" class="float">
  <p><img src="../Images/ccf6009e97e345718b2e2852460148fd.png" alt="" style="width:360.75px; height:223.59182px" data-original-src="https://exploringjs.com/js/book/img/classes/class-derived.svg"/></p>
  <figcaption>
    <p><span class="float-label">Figure 31.5:</span> Object diagram for class <code>DerivedClass</code> and its instance <code>derivedInstance</code>: Both <code>Object</code> and <code>DerivedClass</code> appear in the class prototype chain (left column). They both contribute prototypes to the instance prototype chain (right column).</p>
  </figcaption>
</figure>
<p>In contrast, the following class is a base class. <a href="#fig:class-base">Figure 31.6</a> shows its object diagram.</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseClass</span> {}
<span class="hljs-keyword">const</span> baseInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BaseClass</span>();
</pre>
<figure id="fig:class-base" class="float">
  <p><img src="../Images/d47fa0c82efa7280cc3139a980d91244.png" alt="" style="width:360.75px; height:151.59183px" data-original-src="https://exploringjs.com/js/book/img/classes/class-base.svg"/></p>
  <figcaption>
    <p><span class="float-label">Figure 31.6:</span> Object diagram for class <code>BaseClass</code> and its instance <code>baseInstance</code>: The instance prototype chain (right column) is the same as for <code>derivedInstance</code>. However, <code>Object</code> does not appear in the class prototype chain (left column).</p>
  </figcaption>
</figure>
<h4 id="prototype-chains-of-builtin-objects"><a class="heading-id-link" href="#prototype-chains-of-builtin-objects">31.7.6 The prototype chains of plain objects and Arrays<span> (advanced)</span></a></h4>
<p>Next, we’ll use our knowledge of subclassing to understand the prototype chains of plain objects and Arrays. The following tool function <code>p()</code> helps us with our explorations:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Object</span>.<span class="hljs-property">getPrototypeOf</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-title class_">Object</span>);
</pre>
<p>We extracted method <code>.getPrototypeOf()</code> of <code>Object</code> and assigned it to <code>p</code>.</p>
<h5 id="the-prototype-chains-of-plain-objects"><a class="heading-id-link" href="#the-prototype-chains-of-plain-objects">31.7.6.1 The prototype chains of plain objects</a></h5>
<p>Let’s explore the prototype chain of a plain object:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Object</span>.<span class="hljs-property">getPrototypeOf</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-title class_">Object</span>);</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">p</span>({}) === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">p</span>(<span class="hljs-title function_">p</span>({}))</span>
null
</pre>
<p><a href="#fig:builtin-object">Figure 31.7</a> shows a diagram for a plain object and its class <code>Object</code>.</p>
<figure id="fig:builtin-object" class="float">
  <p><img src="../Images/9a2acdc1ab742c804e273ce5af871ba1.png" alt="" style="width:360.75px; height:151.59183px" data-original-src="https://exploringjs.com/js/book/img/classes/builtin-object.svg"/></p>
  <figcaption>
    <p><span class="float-label">Figure 31.7:</span> The prototype of the empty plain object <code>{}</code> is <code>Object.prototype</code> – which makes it an instance of the class <code>Object</code>.</p>
  </figcaption>
</figure>
<h5 id="the-prototype-chains-of-arrays"><a class="heading-id-link" href="#the-prototype-chains-of-arrays">31.7.6.2 The prototype chains of Arrays</a></h5>
<p>Let’s explore the prototype chain of an Array:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Object</span>.<span class="hljs-property">getPrototypeOf</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-title class_">Object</span>);</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">p</span>([]) === <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">p</span>(<span class="hljs-title function_">p</span>([])) === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">p</span>(<span class="hljs-title function_">p</span>(<span class="hljs-title function_">p</span>([]))) === <span class="hljs-literal">null</span></span>
true
</pre>
<p><a href="#fig:builtin-array">Figure 31.8</a> shows a diagram for an Array and its class <code>Array</code>.</p>
<figure id="fig:builtin-array" class="float">
  <p><img src="../Images/2d8acaa0b29263257e64a3d6f87074a8.png" alt="" style="width:360.75px; height:151.59183px" data-original-src="https://exploringjs.com/js/book/img/classes/builtin-array.svg"/></p>
  <figcaption>
    <p><span class="float-label">Figure 31.8:</span> The empty Array <code>[]</code> is an instance of <code>Array</code> (via <code>Array.prototype</code>) and an instance of <code>Object</code> (via <code>Object.prototype</code>). However, class <code>Array</code> is not derived from class <code>Object</code> – it is a base class.</p>
  </figcaption>
</figure>
<p>It’s interesting that <code>Array</code> is a base class:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-title class_">Array</span>) === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></span>
true
</pre>
<p>Therefore, all instances of <code>Array</code> are also instances of <code>Object</code> – yet <code>Array</code> is not a subclass of <code>Object</code>. This divergence is only possible because the instance prototype chain is separate from the class prototype chain in JavaScript.</p>
<p>Why isn’t <code>Object</code> the prototype of <code>Array</code>? One reason is that it has been this way since long before classes were added to JavaScript and can’t really be changed due to the importance of backward compatibility in JavaScript. Another reason is that base classes are where instances are actually created. <code>Array</code> needs to create its own instances because they have so-called “internal slots” which can’t be added later to instances created by <code>Object</code>.</p>
<h5 id="the-prototype-chains-of-functions"><a class="heading-id-link" href="#the-prototype-chains-of-functions">31.7.6.3 The prototype chains of functions</a></h5>
<p>Functions are similar to Arrays. On one hand, <code>Function</code> is a base class:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-function">() =&gt;</span> {}) === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></span>
true
</pre>
<p>On the other hand, function objects are instances of <code>Object</code>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Object</span>.<span class="hljs-property">getPrototypeOf</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-title class_">Object</span>);</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">p</span>(<span class="hljs-function">() =&gt;</span> {}) === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">p</span>(<span class="hljs-title function_">p</span>(<span class="hljs-function">() =&gt;</span> {})) === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">p</span>(<span class="hljs-title function_">p</span>(<span class="hljs-title function_">p</span>(<span class="hljs-function">() =&gt;</span> {})))</span>
null
</pre>
<h3 id="mixin-classes-advanced"><a class="heading-id-link" href="#mixin-classes-advanced">31.8 Mixin classes<span> (advanced)</span></a></h3>
<p><span id="index-entry-mixin-class"/><span id="index-entry-class--mixin"/>
<span id="index-entry-single-inheritance"/><span id="index-entry-inheritance--single"/>
<span id="index-entry-multiple-inheritance"/><span id="index-entry-inheritance--multiple"/></p>
<p>JavaScript’s class system only supports <em>single inheritance</em>. That is, each class can have at most one superclass. One way around this limitation is via a technique called <em>mixin classes</em> (short: <em>mixins</em>).</p>
<p>The idea is as follows: Let’s say we want a class <code>C</code> to inherit from two superclasses <code>S1</code> and <code>S2</code>. That would be <em>multiple inheritance</em>, which JavaScript doesn’t support.</p>
<p>Our workaround is to turn <code>S1</code> and <code>S2</code> into <em>mixins</em>, factories for subclasses:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> <span class="hljs-title function_">S1</span> = (<span class="hljs-params">Sup</span>) =&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">Sup</span> { <span class="hljs-comment">/*···*/</span> };
<span class="hljs-keyword">const</span> <span class="hljs-title function_">S2</span> = (<span class="hljs-params">Sup</span>) =&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">Sup</span> { <span class="hljs-comment">/*···*/</span> };
</pre>
<p>Each of these two functions returns a class that extends a given superclass <code>Sup</code>. We create class <code>C</code> as follows:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">S2</span>(<span class="hljs-title function_">S1</span>(<span class="hljs-title class_">Object</span>)) {
  <span class="hljs-comment">/*···*/</span>
}
</pre>
<p>We now have a class <code>C</code> that extends the class returned by <code>S2()</code> which extends the class returned by <code>S1()</code> which extends <code>Object</code>.</p>
<h4 id="example-a-mixin-for-name-management"><a class="heading-id-link" href="#example-a-mixin-for-name-management">31.8.1 Example: a mixin for name management</a></h4>
<p>We implement a mixin <code>Named</code> adds a property <code>.name</code> and a method <code>.toString()</code> to its superclass:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> <span class="hljs-title function_">Named</span> = (<span class="hljs-params">Sup</span>) =&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">Sup</span> {
  name = <span class="hljs-string">'(Unnamed)'</span>;
  <span class="hljs-title function_">toString</span>(<span class="hljs-params">) {</span>
<span class="hljs-params">    <span class="hljs-keyword">const</span> className = <span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>.<span class="hljs-property">name</span>;</span>
<span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${className}</span> named <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>;</span>
<span class="hljs-params">  }</span>
<span class="hljs-params">};</span>
</pre>
<p>We use this mixin to implement a class <code>City</code> that has a name:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">City</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Named</span>(<span class="hljs-title class_">Object</span>) {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">super</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
}
</pre>
<p>The following code confirms that the mixin works:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> paris = <span class="hljs-keyword">new</span> <span class="hljs-title class_">City</span>(<span class="hljs-string">'Paris'</span>);
assert.<span class="hljs-title function_">equal</span>(
  paris.<span class="hljs-property">name</span>, <span class="hljs-string">'Paris'</span>
);
assert.<span class="hljs-title function_">equal</span>(
  paris.<span class="hljs-title function_">toString</span>(), <span class="hljs-string">'City named Paris'</span>
);
</pre>
<h4 id="the-benefits-of-mixins"><a class="heading-id-link" href="#the-benefits-of-mixins">31.8.2 The benefits of mixins</a></h4>
<p>Mixins free us from the constraints of single inheritance:</p>
<ul>
  <li>
    The same class can extend a single superclass and zero or more mixins.
  </li>
  <li>
    The same mixin can be used by multiple classes.
  </li>
</ul>
<h3 id="the-methods-and-accessors-of-objectprototype-advanced"><a class="heading-id-link" href="#the-methods-and-accessors-of-objectprototype-advanced">31.9 The methods and accessors of <code>Object.prototype</code><span> (advanced)</span></a></h3>
<h4 id="using-object-methods-safely"><a class="heading-id-link" href="#using-object-methods-safely">31.9.1 Using <code>Object.prototype</code> methods safely</a></h4>
<p>Invoking one of the methods of <code>Object.prototype</code> on an arbitrary object doesn’t always work. To illustrate why, we use method <code>Object.prototype.hasOwnProperty</code>, which returns <code>true</code> if an object has an own property with a given key:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">{<span class="hljs-attr">ownProp</span>: <span class="hljs-literal">true</span>}.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'ownProp'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">{<span class="hljs-attr">ownProp</span>: <span class="hljs-literal">true</span>}.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'abc'</span>)</span>
false
</pre>
<p>Invoking <code>.hasOwnProperty()</code> on an arbitrary object can fail in two ways. On one hand, this method isn’t available if an object is not an instance of <code>Object</code> (see <a href="#non-instances-of-object">“Not all objects are instances of <code>Object</code><span> (advanced)</span>” (§31.7.4)</a>):</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);
assert.<span class="hljs-title function_">equal</span>(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>, <span class="hljs-literal">false</span>);
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> obj.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'prop'</span>),
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'TypeError'</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">'obj.hasOwnProperty is not a function'</span>,
  }
);
</pre>
<p>On the other hand, we can’t use <code>.hasOwnProperty()</code> if an object overrides it with an own property (line A):</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> obj = {
  <span class="hljs-attr">hasOwnProperty</span>: <span class="hljs-string">'yes'</span> <span class="hljs-comment">// (A)</span>
};
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> obj.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'prop'</span>),
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'TypeError'</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">'obj.hasOwnProperty is not a function'</span>,
  }
);
</pre>
<p>There is, however, a safe way to use <code>.hasOwnProperty()</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">hasOwnProp</span>(<span class="hljs-params">obj, propName</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(obj, propName); <span class="hljs-comment">// (A)</span>
}
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title function_">hasOwnProp</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>), <span class="hljs-string">'prop'</span>), <span class="hljs-literal">false</span>
);
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title function_">hasOwnProp</span>({<span class="hljs-attr">hasOwnProperty</span>: <span class="hljs-string">'yes'</span>}, <span class="hljs-string">'prop'</span>), <span class="hljs-literal">false</span>
);
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title function_">hasOwnProp</span>({<span class="hljs-attr">hasOwnProperty</span>: <span class="hljs-string">'yes'</span>}, <span class="hljs-string">'hasOwnProperty'</span>), <span class="hljs-literal">true</span>
);
</pre>
<p>The method invocation in line A is explained in <a href="#method-calls-dispatched-direct">“Dispatched vs. direct method calls<span> (advanced)</span>” (§31.3.5)</a>.</p>
<p>We can also use <a href="ch_objects.html#methods-bind"><code>.bind()</code></a> to implement <code>hasOwnProp()</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> hasOwnProp = <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">call</span>
  .<span class="hljs-title function_">bind</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>);
</pre>
<p>How does this code work? In line A in the example before the code above, we used the function method <code>.call()</code> to turn the function <code>hasOwnProperty</code> with one implicit parameter (<code>this</code>) and one explicit parameter (<code>propName</code>) into a function that has two explicit parameters (<code>obj</code> and <code>propName</code>).</p>
<p>In other words – method <code>.call()</code> invokes the function <code>f</code> referred to by its receiver (<code>this</code>):</p>
<ul>
  <li>
    The first (explicit) parameter of <code>.call()</code> becomes the <code>this</code> of <code>f</code>.
  </li>
  <li>
    The second (explicit) parameter of <code>.call()</code> becomes the first argument of <code>f</code>.
  </li>
  <li>
    Etc.
  </li>
</ul>
<p>We use <code>.bind()</code> to create a version <code>.call()</code> whose <code>this</code> always refers to <code>Object.prototype.hasOwnProperty</code>. That new version invokes <code>.hasOwnProperty()</code> in the same manner as we did in line A – which is what we want.</p>
<div class="boxout">
  <p><img src="../Images/3decb3ca67c240d2bb04742c1f28af18.png" class="boxout-icon" height="24" alt="Icon “question”" data-original-src="https://exploringjs.com/js/book/icon/question.svg"/> <strong>Is it never OK to use <code>Object.prototype</code> methods via dynamic dispatch?</strong></p>
  <div class="boxout-vspace"/>
  <p>In some cases we can be lazy and call <code>Object.prototype</code> methods like normal methods: If we know the receivers and they are fixed-layout objects.</p>
  <p>If, on the other hand, we don’t know their receivers and/or they are dictionary objects, then we need to take precautions.</p>
</div>
<h4 id="Object.prototype.toString"><a class="heading-id-link" href="#Object.prototype.toString">31.9.2 <code>Object.prototype.toString()</code><span> <sup>ES1</sup></span></a></h4>
<p>By overriding <code>.toString()</code> (in a subclass or an instance), we can configure how objects are converted to strings:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">String</span>({<span class="hljs-title function_">toString</span>(<span class="hljs-params"/>) { <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello!'</span> }})</span>
'Hello!'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">String</span>({})</span>
'[object Object]'
</pre>
<p>For converting objects to strings it’s better to use <code>String()</code> because that also works with <code>undefined</code> and <code>null</code>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">undefined</span>.<span class="hljs-title function_">toString</span>()</span>
TypeError: Cannot read properties of undefined (reading 'toString')
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">null</span>.<span class="hljs-title function_">toString</span>()</span>
TypeError: Cannot read properties of null (reading 'toString')
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">String</span>(<span class="hljs-literal">undefined</span>)</span>
'undefined'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">String</span>(<span class="hljs-literal">null</span>)</span>
'null'
</pre>
<h4 id="Object.prototype.toLocaleString"><a class="heading-id-link" href="#Object.prototype.toLocaleString">31.9.3 <code>Object.prototype.toLocaleString()</code><span> <sup>ES3</sup></span></a></h4>
<p><code>.toLocaleString()</code> is a version of <code>.toString()</code> that can be configured via a locale and often additional options. Any class or instance can implement this method. In the standard library, the following classes do:</p>
<ul>
  <li>
    <p><code>Number.prototype.toLocaleString()</code></p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">123.45</span>.<span class="hljs-title function_">toLocaleString</span>(<span class="hljs-string">'en'</span>) <span class="hljs-comment">// English</span></span>
'123.45'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">123.45</span>.<span class="hljs-title function_">toLocaleString</span>(<span class="hljs-string">'fr'</span>) <span class="hljs-comment">// French</span></span>
'123,45'
</pre>
  </li>
  <li>
    <p><code>BigInt.prototype.toLocaleString()</code></p>
  </li>
  <li>
    <p><code>Array.prototype.toLocaleString()</code></p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">1.25</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">toLocaleString</span>(<span class="hljs-string">'en'</span>) <span class="hljs-comment">// English</span></span>
'1.25,3'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-number">1.25</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">toLocaleString</span>(<span class="hljs-string">'fr'</span>) <span class="hljs-comment">// French</span></span>
'1,25,3'
</pre>
  </li>
  <li>
    <p><code>TypedArray.prototype.toLocaleString()</code></p>
  </li>
  <li>
    <p><code>Date.prototype.toLocaleString()</code></p>
  </li>
</ul>
<p>Thanks to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Internationalization">ECMAScript Internationalization API</a> (<code>Intl</code> etc.), there are a variety of formatting options:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-number">17.50</span>.<span class="hljs-title function_">toLocaleString</span>(<span class="hljs-string">'en'</span>, {
    <span class="hljs-attr">style</span>: <span class="hljs-string">'currency'</span>,
    <span class="hljs-attr">currency</span>: <span class="hljs-string">'USD'</span>,
  }),
  <span class="hljs-string">'$17.50'</span>
);
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-number">17.50</span>.<span class="hljs-title function_">toLocaleString</span>(<span class="hljs-string">'fr'</span>, {
    <span class="hljs-attr">style</span>: <span class="hljs-string">'currency'</span>,
    <span class="hljs-attr">currency</span>: <span class="hljs-string">'USD'</span>,
  }),
  <span class="hljs-string">'17,50 $US'</span>
);
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-number">17.50</span>.<span class="hljs-title function_">toLocaleString</span>(<span class="hljs-string">'de'</span>, {
    <span class="hljs-attr">style</span>: <span class="hljs-string">'currency'</span>,
    <span class="hljs-attr">currency</span>: <span class="hljs-string">'USD'</span>,
  }),
  <span class="hljs-string">'17,50 $'</span>
);
<code/>
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-number">17.50</span>.<span class="hljs-title function_">toLocaleString</span>(<span class="hljs-string">'en'</span>, {
    <span class="hljs-attr">style</span>: <span class="hljs-string">'currency'</span>,
    <span class="hljs-attr">currency</span>: <span class="hljs-string">'EUR'</span>,
  }),
  <span class="hljs-string">'€17.50'</span>
);
</pre>
<h4 id="Object.prototype.valueOf"><a class="heading-id-link" href="#Object.prototype.valueOf">31.9.4 <code>Object.prototype.valueOf()</code><span> <sup>ES1</sup></span></a></h4>
<p>By overriding <code>.valueOf()</code> (in a subclass or an instance), we can configure how objects are converted to non-string values (often numbers):</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>({<span class="hljs-title function_">valueOf</span>(<span class="hljs-params"/>) { <span class="hljs-keyword">return</span> <span class="hljs-number">123</span> }})</span>
123
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>({})</span>
NaN
</pre>
<h4 id="Object.prototype.isPrototypeOf"><a class="heading-id-link" href="#Object.prototype.isPrototypeOf">31.9.5 <code>Object.prototype.isPrototypeOf()</code><span> <sup>ES3</sup></span></a></h4>
<p><code>proto.isPrototypeOf(obj)</code> returns <code>true</code> if <code>proto</code> is in the prototype chain of <code>obj</code> and <code>false</code> otherwise.</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> a = {};
<span class="hljs-keyword">const</span> b = {<span class="hljs-attr">__proto__</span>: a};
<span class="hljs-keyword">const</span> c = {<span class="hljs-attr">__proto__</span>: b};
<code/>
assert.<span class="hljs-title function_">equal</span>(a.<span class="hljs-title function_">isPrototypeOf</span>(b), <span class="hljs-literal">true</span>);
assert.<span class="hljs-title function_">equal</span>(a.<span class="hljs-title function_">isPrototypeOf</span>(c), <span class="hljs-literal">true</span>);
<code/>
assert.<span class="hljs-title function_">equal</span>(a.<span class="hljs-title function_">isPrototypeOf</span>(a), <span class="hljs-literal">false</span>);
assert.<span class="hljs-title function_">equal</span>(c.<span class="hljs-title function_">isPrototypeOf</span>(a), <span class="hljs-literal">false</span>);
</pre>
<p>This is how to use this method safely (for details see <a href="#using-object-methods-safely">“Using <code>Object.prototype</code> methods safely” (§31.9.1)</a>):</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> obj = {
  <span class="hljs-comment">// Overrides Object.prototype.isPrototypeOf</span>
  <span class="hljs-attr">isPrototypeOf</span>: <span class="hljs-literal">true</span>,
};
<span class="hljs-comment">// Doesn’t work in this case:</span>
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> obj.<span class="hljs-title function_">isPrototypeOf</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>),
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'TypeError'</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">'obj.isPrototypeOf is not a function'</span>,
  }
);
<span class="hljs-comment">// Safe way of using .isPrototypeOf():</span>
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">isPrototypeOf</span>.<span class="hljs-title function_">call</span>(obj, <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>), <span class="hljs-literal">false</span>
);
</pre>
<p>An object is an instance of a class <code>C</code> if <code>C.prototype</code> is in its chain of prototypes:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">isInstanceOf</span>(<span class="hljs-params">obj, aClass</span>) {
  <span class="hljs-keyword">return</span> {}.<span class="hljs-property">isPrototypeOf</span>.<span class="hljs-title function_">call</span>(aClass.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, obj);
}
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title function_">isInstanceOf</span>([], <span class="hljs-title class_">Object</span>), <span class="hljs-literal">true</span>
);
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title function_">isInstanceOf</span>([], <span class="hljs-title class_">Array</span>), <span class="hljs-literal">true</span>
);
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title function_">isInstanceOf</span>(<span class="hljs-regexp">/x/</span>, <span class="hljs-title class_">Array</span>), <span class="hljs-literal">false</span>
);
</pre>
<h4 id="Object.prototype.propertyIsEnumerable"><a class="heading-id-link" href="#Object.prototype.propertyIsEnumerable">31.9.6 <code>Object.prototype.propertyIsEnumerable()</code><span> <sup>ES3</sup></span></a></h4>
<p><code>obj.propertyIsEnumerable(propKey)</code> returns <code>true</code> if <code>obj</code> has an own enumerable property whose key is <code>propKey</code> and <code>false</code> otherwise.</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> proto = {
  <span class="hljs-attr">enumerableProtoProp</span>: <span class="hljs-literal">true</span>,
};
<span class="hljs-keyword">const</span> obj = {
  <span class="hljs-attr">__proto__</span>: proto,
  <span class="hljs-attr">enumerableObjProp</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">nonEnumObjProp</span>: <span class="hljs-literal">true</span>,
};
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(
  obj, <span class="hljs-string">'nonEnumObjProp'</span>,
  {
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
  }
);
<code/>
assert.<span class="hljs-title function_">equal</span>(
  obj.<span class="hljs-title function_">propertyIsEnumerable</span>(<span class="hljs-string">'enumerableProtoProp'</span>),
  <span class="hljs-literal">false</span> <span class="hljs-comment">// not an own property</span>
);
assert.<span class="hljs-title function_">equal</span>(
  obj.<span class="hljs-title function_">propertyIsEnumerable</span>(<span class="hljs-string">'enumerableObjProp'</span>),
  <span class="hljs-literal">true</span>
);
assert.<span class="hljs-title function_">equal</span>(
  obj.<span class="hljs-title function_">propertyIsEnumerable</span>(<span class="hljs-string">'nonEnumObjProp'</span>),
  <span class="hljs-literal">false</span> <span class="hljs-comment">// not enumerable</span>
);
assert.<span class="hljs-title function_">equal</span>(
  obj.<span class="hljs-title function_">propertyIsEnumerable</span>(<span class="hljs-string">'unknownProp'</span>),
  <span class="hljs-literal">false</span> <span class="hljs-comment">// not a property</span>
);
</pre>
<p>This is how to use this method safely (for details see <a href="#using-object-methods-safely">“Using <code>Object.prototype</code> methods safely” (§31.9.1)</a>):</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> obj = {
  <span class="hljs-comment">// Overrides Object.prototype.propertyIsEnumerable</span>
  <span class="hljs-attr">propertyIsEnumerable</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">enumerableProp</span>: <span class="hljs-string">'yes'</span>,
};
<span class="hljs-comment">// Doesn’t work in this case:</span>
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> obj.<span class="hljs-title function_">propertyIsEnumerable</span>(<span class="hljs-string">'enumerableProp'</span>),
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'TypeError'</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">'obj.propertyIsEnumerable is not a function'</span>,
  }
);
<span class="hljs-comment">// Safe way of using .propertyIsEnumerable():</span>
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">propertyIsEnumerable</span>.<span class="hljs-title function_">call</span>(obj, <span class="hljs-string">'enumerableProp'</span>),
  <span class="hljs-literal">true</span>
);
</pre>
<p>Another safe alternative is to use <a href="ch_objects.html#property-attributes-property-descriptors">property descriptors</a>:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(obj, <span class="hljs-string">'enumerableProp'</span>),
  {
    <span class="hljs-attr">value</span>: <span class="hljs-string">'yes'</span>,
    <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
  }
);
</pre>
<h4 id="Object.prototype.__proto__"><a class="heading-id-link" href="#Object.prototype.__proto__">31.9.7 <code>Object.prototype.__proto__</code> (accessor)<span> <sup>ES6</sup></span></a></h4>
<p>Property <code>__proto__</code> exists in two versions:</p>
<ul>
  <li>
    An accessor that all instances of <code>Object</code> have.
  </li>
  <li>
    A property of object literals that sets the prototypes of the objects created by them.
  </li>
</ul>
<p>I recommend to avoid the former feature:</p>
<ul>
  <li>
    As explained in <a href="#using-object-methods-safely">“Using <code>Object.prototype</code> methods safely” (§31.9.1)</a>, it doesn’t work with all objects.
  </li>
  <li>
    The ECMAScript specification has deprecated it and calls it <a href="https://tc39.es/ecma262/#sec-object.prototype.__proto__">“optional” and “legacy”</a>.
  </li>
</ul>
<p>In contrast, <code>__proto__</code> in object literals always works and is not deprecated.</p>
<p>Read on if you are interested in how the accessor <code>__proto__</code> works.</p>
<p><code>__proto__</code> is an accessor of <code>Object.prototype</code> that is inherited by all instances of <code>Object</code>. Implementing it via a class would look like this:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> {
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">__proto__</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-variable language_">this</span>);
  }
  <span class="hljs-keyword">set</span> <span class="hljs-title function_">__proto__</span>(<span class="hljs-params">other</span>) {
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(<span class="hljs-variable language_">this</span>, other);
  }
  <span class="hljs-comment">// ···</span>
}
</pre>
<p>Since <code>__proto__</code> is inherited from <code>Object.prototype</code>, we can remove this feature by creating an object that doesn’t have <code>Object.prototype</code> in its prototype chain (see <a href="#non-instances-of-object">“Not all objects are instances of <code>Object</code><span> (advanced)</span>” (§31.7.4)</a>):</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'__proto__'</span> <span class="hljs-keyword">in</span> {}</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'__proto__'</span> <span class="hljs-keyword">in</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)</span>
false
</pre>
<h4 id="Object.prototype.hasOwnProperty"><a class="heading-id-link" href="#Object.prototype.hasOwnProperty">31.9.8 <code>Object.prototype.hasOwnProperty()</code><span> <sup>ES3</sup></span></a></h4>
<div class="boxout">
  <p><img src="../Images/5aa4bf88dc66ecb2bac6be4022a1fed4.png" class="boxout-icon" height="24" alt="Icon “warning”" data-original-src="https://exploringjs.com/js/book/icon/warning.svg"/> <strong>Better alternative to <code>.hasOwnProperty()</code>: <code>Object.hasOwn()</code> <sup>ES2022</sup></strong></p>
  <div class="boxout-vspace"/>
  <p>See <a href="ch_objects.html#Object.hasOwn">“<code>Object.hasOwn()</code>: Is a given property own (non-inherited)?<span> <sup>ES2022</sup></span>” (§30.8.4)</a>.</p>
</div>
<p><code>obj.hasOwnProperty(propKey)</code> returns <code>true</code> if <code>obj</code> has an own (non-inherited) property whose key is <code>propKey</code> and <code>false</code> otherwise.</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">ownProp</span>: <span class="hljs-literal">true</span> };
assert.<span class="hljs-title function_">equal</span>(
  obj.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'ownProp'</span>), <span class="hljs-literal">true</span> <span class="hljs-comment">// own</span>
);
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-string">'toString'</span> <span class="hljs-keyword">in</span> obj, <span class="hljs-literal">true</span> <span class="hljs-comment">// inherited</span>
);
assert.<span class="hljs-title function_">equal</span>(
  obj.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'toString'</span>), <span class="hljs-literal">false</span>
);
</pre>
<p>This is how to use this method safely (for details see <a href="#using-object-methods-safely">“Using <code>Object.prototype</code> methods safely” (§31.9.1)</a>):</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> obj = {
  <span class="hljs-comment">// Overrides Object.prototype.hasOwnProperty</span>
  <span class="hljs-attr">hasOwnProperty</span>: <span class="hljs-literal">true</span>,
};
<span class="hljs-comment">// Doesn’t work in this case:</span>
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> obj.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'anyPropKey'</span>),
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'TypeError'</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">'obj.hasOwnProperty is not a function'</span>,
  }
);
<span class="hljs-comment">// Safe way of using .hasOwnProperty():</span>
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(obj, <span class="hljs-string">'anyPropKey'</span>), <span class="hljs-literal">false</span>
);
</pre>
<h3 id="quickref-object-prototype"><a class="heading-id-link" href="#quickref-object-prototype">31.10 Quick reference: <code>Object.prototype.*</code></a></h3>
<p><span id="index-entry-Object.prototype-methods"/></p>
<h4 id="objectprototype-configuring-how-objects-are-converted-to-primitive-values"><a class="heading-id-link" href="#objectprototype-configuring-how-objects-are-converted-to-primitive-values">31.10.1 <code>Object.prototype.*</code>: configuring how objects are converted to primitive values</a></h4>
<p>The following methods have default implementations but are often overridden in subclasses or instances. They determine how objects are converted to primitive values (e.g. by the <code>+</code> operator).</p>
<ul>
  <li>
    <p><code id="qref-Object.prototype.toString">Object.prototype.toString()</code> <span class="ibox ibox-small" size="small">ES1</span></p>
    <p>Configures how an object is converted to a string.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'Object: '</span> + {<span class="hljs-title function_">toString</span>(<span class="hljs-params"/>) {<span class="hljs-keyword">return</span> <span class="hljs-string">'Hello!'</span>}}</span>
'Object: Hello!'
</pre>
    <p><a href="#Object.prototype.toString">More information</a>.</p>
  </li>
  <li>
    <p><code id="qref-Object.prototype.toLocaleString">Object.prototype.toLocaleString()</code> <span class="ibox ibox-small" size="small">ES3</span></p>
    <p>A version of <code>.toString()</code> that can be configured in various ways via arguments (language, region, etc.). <a href="#Object.prototype.toLocaleString">More information</a>.</p>
  </li>
  <li>
    <p><code id="qref-Object.prototype.valueOf">Object.prototype.valueOf()</code> <span class="ibox ibox-small" size="small">ES1</span></p>
    <p>Configures how an object is converted to a non-string primitive value (often a number).</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">1</span> + {<span class="hljs-title function_">valueOf</span>(<span class="hljs-params"/>) {<span class="hljs-keyword">return</span> <span class="hljs-number">123</span>}}</span>
124
</pre>
    <p><a href="#Object.prototype.valueOf">More information</a>.</p>
  </li>
</ul>
<h4 id="objectprototype-useful-methods-with-pitfalls"><a class="heading-id-link" href="#objectprototype-useful-methods-with-pitfalls">31.10.2 <code>Object.prototype.*</code>: useful methods with pitfalls</a></h4>
<p>The following methods are useful but can’t be invoked on an object if:</p>
<ul>
  <li>
    <code>Object.prototype</code> isn’t a prototype of that object.
  </li>
  <li>
    The <code>Object.prototype</code> method is overridden somewhere in the prototype chain.
  </li>
</ul>
<p>How to work around that limitation is explained in <a href="#using-object-methods-safely">“Using <code>Object.prototype</code> methods safely” (§31.9.1)</a>.</p>
<p>These are the methods:</p>
<ul>
  <li>
    <p><code id="qref-Object.prototype.isPrototypeOf">Object.prototype.isPrototypeOf()</code> <span class="ibox ibox-small" size="small">ES3</span></p>
    <p>Is the receiver in the prototype chain of a given object?</p>
    <p>You’ll usually be fine if you invoke this method on an object. If you want to be safe, you can use the following pattern (line A):</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">isInstanceOf</span>(<span class="hljs-params">obj, aClass</span>) {
  <span class="hljs-keyword">return</span> {}.<span class="hljs-property">isPrototypeOf</span>.<span class="hljs-title function_">call</span>(aClass.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, obj); <span class="hljs-comment">// (A)</span>
}
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title function_">isInstanceOf</span>([], <span class="hljs-title class_">Object</span>), <span class="hljs-literal">true</span>
);
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title function_">isInstanceOf</span>([], <span class="hljs-title class_">Array</span>), <span class="hljs-literal">true</span>
);
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title function_">isInstanceOf</span>(<span class="hljs-regexp">/x/</span>, <span class="hljs-title class_">Array</span>), <span class="hljs-literal">false</span>
);
</pre>
    <p><a href="#Object.prototype.isPrototypeOf">More information</a>.</p>
  </li>
  <li>
    <p><code id="qref-Object.prototype.propertyIsEnumerable">Object.prototype.propertyIsEnumerable()</code> <span class="ibox ibox-small" size="small">ES3</span></p>
    <p>Does the receiver have an enumerable own property with the given key?</p>
    <p>You’ll usually be fine if you invoke this method on an object. If you want to be safe, you can use the following pattern:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">{}.<span class="hljs-property">propertyIsEnumerable</span>.<span class="hljs-title function_">call</span>([<span class="hljs-string">'a'</span>], <span class="hljs-string">'length'</span>)</span>
false
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">{}.<span class="hljs-property">propertyIsEnumerable</span>.<span class="hljs-title function_">call</span>([<span class="hljs-string">'a'</span>], <span class="hljs-string">'0'</span>)</span>
true
</pre>
    <p><a href="#Object.prototype.propertyIsEnumerable">More information</a>.</p>
  </li>
</ul>
<h4 id="objectprototype-methods-to-avoid"><a class="heading-id-link" href="#objectprototype-methods-to-avoid">31.10.3 <code>Object.prototype.*</code>: methods to avoid</a></h4>
<p>Avoid the following features (there are better alternatives):</p>
<ul>
  <li>
    <p><code id="qref-get-Object.prototype.__proto__">get Object.prototype.__proto__</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>Avoid:</p>
    <ul>
      <li>
        Instead, use <code>Object.getPrototypeOf()</code>.
      </li>
      <li>
        <a href="#Object.prototype.__proto__">More information</a>.
      </li>
    </ul>
  </li>
  <li>
    <p><code id="qref-set-Object.prototype.__proto__">set Object.prototype.__proto__</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>Avoid:</p>
    <ul>
      <li>
        Instead, use <code>Object.setPrototypeOf()</code>.
      </li>
      <li>
        <a href="#Object.prototype.__proto__">More information</a>.
      </li>
    </ul>
  </li>
  <li>
    <p><code id="qref-Object.prototype.hasOwnProperty">Object.prototype.hasOwnProperty</code> <span class="ibox ibox-small" size="small">ES3</span></p>
    <p>Avoid:</p>
    <ul>
      <li>
        Instead, use <code>Object.hasOwn()</code> <sup>ES2022</sup>
      </li>
      <li>
        <a href="#Object.prototype.hasOwnProperty">More information</a>.
      </li>
    </ul>
  </li>
</ul>
<h3 id="faq-classes"><a class="heading-id-link" href="#faq-classes">31.11 FAQ: classes</a></h3>
<h4 id="why-are-they-called-instance-private-fields-in-this-book-and-not-private-instance-fields"><a class="heading-id-link" href="#why-are-they-called-instance-private-fields-in-this-book-and-not-private-instance-fields">31.11.1 Why are they called “instance private fields” in this book and not “private instance fields”?</a></h4>
<p>That is done to highlight how different properties (public slots) and private slots are: By changing the order of the adjectives, the words “public” and “field” and the words “private” and “field” are always mentioned together.</p>
<h4 id="why-the-identifier-prefix--why-not-declare-private-fields-via-private"><a class="heading-id-link" href="#why-the-identifier-prefix--why-not-declare-private-fields-via-private">31.11.2 Why the identifier prefix <code>#</code>? Why not declare private fields via <code>private</code>?</a></h4>
<p>Could private fields be declared via <code>private</code> and use normal identifiers? Let’s examine what would happen if that were possible:</p>
<pre class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  private value; <span class="hljs-comment">// (A)</span>
  <span class="hljs-title function_">compare</span>(<span class="hljs-params">other</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> === other.<span class="hljs-property">value</span>;
  }
}
</pre>
<p>Whenever an expression such as <code>other.value</code> appears in the body of <code>MyClass</code>, JavaScript has to decide:</p>
<ul>
  <li>
    Is <code>.value</code> a property?
  </li>
  <li>
    Is <code>.value</code> a private field?
  </li>
</ul>
<p>At compile time, JavaScript doesn’t know if the declaration in line A applies to <code>other</code> (due to it being an instance of <code>MyClass</code>) or not. That leaves two options for making the decision:</p>
<ol>
  <li>
    <code>.value</code> is always interpreted as a private field.
  </li>
  <li>
    JavaScript decides at runtime:
    <ul>
      <li>
        If <code>other</code> is an instance of <code>MyClass</code>, then <code>.value</code> is interpreted as a private field.
      </li>
      <li>
        Otherwise <code>.value</code> is interpreted as a property.
      </li>
    </ul>
  </li>
</ol>
<p>Both options have downsides:</p>
<ul>
  <li>
    With option (1), we can’t use <code>.value</code> as a property, anymore – for any object.
  </li>
  <li>
    With option (2), performance is affected negatively.
  </li>
</ul>
<p>That’s why the name prefix <code>#</code> was introduced. The decision is now easy: If we use <code>#</code>, we want to access a private field. If we don’t, we want to access a property.</p>
<p><code>private</code> works for statically typed languages (such as TypeScript) because they know at compile time if <code>other</code> is an instance of <code>MyClass</code> and can then treat <code>.value</code> as private or public.</p>

    
      
</body>
</html>