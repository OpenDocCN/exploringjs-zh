<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>23 Using template literals and tagged templates ES6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>23 Using template literals and tagged templates ES6</h1>
<blockquote>原文：<a href="https://exploringjs.com/js/book/ch_template-literals.html">https://exploringjs.com/js/book/ch_template-literals.html</a></blockquote>

        
    
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#disambiguation-template">23.1 Disambiguation: “template”</a>
    </li>
    <li>
      <a href="#template-literals">23.2 Template literals</a>
    </li>
    <li>
      <a href="#tagged-templates">23.3 Tagged templates</a>
      <ol>
        <li>
          <a href="#template-strings-cooked-vs-raw">23.3.1 Cooked vs. raw template strings<span> (advanced)</span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#examples-of-tagged-templates-as-provided-via-libraries">23.4 Examples of tagged templates (as provided via libraries)</a>
      <ol>
        <li>
          <a href="#tag-function-library-lithtml">23.4.1 Tag function library: lit-html</a>
        </li>
        <li>
          <a href="#regex-library">23.4.2 Tag function library: regex</a>
        </li>
        <li>
          <a href="#tag-function-library-graphqltag">23.4.3 Tag function library: graphql-tag</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#raw-string-literals">23.5 Raw string literals via the template tag <code>String.raw</code></a>
    </li>
    <li>
      <a href="#multiline-template-literals">23.6 Multiline template literals and indentation</a>
      <ol>
        <li>
          <a href="#fix-indenting-the-text-and-removing-the-indentation-via-a-template-tag">23.6.1 Fix: indenting the text and removing the indentation via a template tag</a>
        </li>
        <li>
          <a href="#fix-not-indenting-the-text-and-removing-leading-and-trailing-whitespace-via-trim">23.6.2 Fix: not indenting the text and removing leading and trailing whitespace via <code>.trim()</code></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#simple-templating-via-template-literals-advanced">23.7 Simple templating via template literals<span> (advanced)</span></a>
      <ol>
        <li>
          <a href="#a-more-complex-example">23.7.1 A more complex example</a>
        </li>
        <li>
          <a href="#simple-html-escaping">23.7.2 Simple HTML-escaping</a>
        </li>
      </ol>
    </li>
  </ol>
</nav>
<p>Before we dig into the two features <em>template literal</em> and <em>tagged template</em>, let’s first examine the multiple meanings of the term <em>template</em>.</p>
<h3 id="disambiguation-template"><a class="heading-id-link" href="#disambiguation-template">23.1 Disambiguation: “template”</a></h3>
<p>The following three things are significantly different despite all having <em>template</em> in their names and despite all of them looking similar:</p>
<ul>
  <li>
    <p>A <em>text template</em> is a function from data to text. It is frequently used in web development and often defined via text files. For example, the following text defines a template for the library <a href="https://handlebarsjs.com">Handlebars</a>:</p>
<pre class="language-html">
<code><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"entry"</span>&gt;</span></code>
<code>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{{title}}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code>
<code>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"body"</span>&gt;</span></code>
<code>    {{body}}</code>
<code>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code>
<code><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code>
</pre>
    <p>This template has two blanks to be filled in: <code>title</code> and <code>body</code>. It is used like this:</p>
<pre class="language-js">
<code><span class="hljs-comment">// First step: retrieve the template text, e.g. from a text file.</span></code>
<code><span class="hljs-keyword">const</span> tmplFunc = <span class="hljs-title class_">Handlebars</span>.<span class="hljs-title function_">compile</span>(<span class="hljs-variable constant_">TMPL_TEXT</span>); <span class="hljs-comment">// compile string</span></code>
<code><span class="hljs-keyword">const</span> data = {<span class="hljs-attr">title</span>: <span class="hljs-string">'My page'</span>, <span class="hljs-attr">body</span>: <span class="hljs-string">'Welcome to my page!'</span>};</code>
<code><span class="hljs-keyword">const</span> html = <span class="hljs-title function_">tmplFunc</span>(data);</code>
</pre>
  </li>
  <li>
    <p>A <em>template literal</em> is similar to a string literal, but has additional features – for example, interpolation. It is delimited by backticks:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> num = <span class="hljs-number">5</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-string">`Count: <span class="hljs-subst">${num}</span>!`</span>, <span class="hljs-string">'Count: 5!'</span>);</code>
</pre>
  </li>
  <li>
    <p>Syntactically, a <em>tagged template</em> is a template literal that follows a function (or rather, an expression that evaluates to a function). That leads to the function being called. Its arguments are derived from the contents of the template literal.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> <span class="hljs-title function_">getArgs</span> = (<span class="hljs-params">...args</span>) =&gt; args;</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  getArgs<span class="hljs-string">`Count: <span class="hljs-subst">${<span class="hljs-number">5</span>}</span>!`</span>,</code>
<code>  [[<span class="hljs-string">'Count: '</span>, <span class="hljs-string">'!'</span>], <span class="hljs-number">5</span>] );</code>
</pre>
    <p>Note that <code>getArgs()</code> receives both the text of the literal and the data interpolated via <code>${}</code>.</p>
  </li>
</ul>
<h3 id="template-literals"><a class="heading-id-link" href="#template-literals">23.2 Template literals</a></h3>
<p><span id="index-entry-template-literal"/></p>
<p>A template literal has two new features compared to a normal string literal.</p>
<p>First, it supports <em>string interpolation</em>: if we put a dynamically computed value inside a <code>${}</code>, it is converted to a string and inserted into the string returned by the literal.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MAX</span> = <span class="hljs-number">100</span>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomeWork</span>(<span class="hljs-params">x</span>) {</code>
<code>  <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-variable constant_">MAX</span>) {</code>
<code>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`At most <span class="hljs-subst">${MAX}</span> allowed: <span class="hljs-subst">${x}</span>!`</span>);</code>
<code>  }</code>
<code>  <span class="hljs-comment">// ···</span></code>
<code>}</code>
<code>assert.<span class="hljs-title function_">throws</span>(</code>
<code>  <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">doSomeWork</span>(<span class="hljs-number">101</span>),</code>
<code>  {<span class="hljs-attr">message</span>: <span class="hljs-string">'At most 100 allowed: 101!'</span>});</code>
</pre>
<p>Second, template literals can span multiple lines:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> str = <span class="hljs-string">`this is</span></code>
<code><span class="hljs-string">a text with</span></code>
<code><span class="hljs-string">multiple lines`</span>;</code>
</pre>
<p>Template literals always produce strings.</p>
<h3 id="tagged-templates"><a class="heading-id-link" href="#tagged-templates">23.3 Tagged templates</a></h3>
<p><span id="index-entry-tagged-template"/></p>
<p>The expression in line A is a <em>tagged template</em>. It is equivalent to invoking <code>tagFunc()</code> with the arguments shown below line A.</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">tagFunc</span>(<span class="hljs-params">templateStrings, ...substitutions</span>) {</code>
<code>  <span class="hljs-keyword">return</span> {templateStrings, substitutions};</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">const</span> setting = <span class="hljs-string">'dark mode'</span>;</code>
<code><span class="hljs-keyword">const</span> value = <span class="hljs-literal">true</span>;</code>
<code/>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  tagFunc<span class="hljs-string">`Setting <span class="hljs-subst">${setting}</span> is <span class="hljs-subst">${value}</span>!`</span>, <span class="hljs-comment">// (A)</span></code>
<code>  {</code>
<code>    <span class="hljs-attr">templateStrings</span>: [<span class="hljs-string">'Setting '</span>, <span class="hljs-string">' is '</span>, <span class="hljs-string">'!'</span>],</code>
<code>    <span class="hljs-attr">substitutions</span>: [<span class="hljs-string">'dark mode'</span>, <span class="hljs-literal">true</span>],</code>
<code>  }</code>
<code>  <span class="hljs-comment">// tagFunc(['Setting ', ' is ', '!'], 'dark mode', true)</span></code>
<code>);</code>
</pre>
<p>The function <code>tagFunc</code> before the first backtick is called a <em>tag function</em>. Its arguments are:</p>
<ul>
  <li>
    <p><em>Template strings</em> (first argument): an Array with the text fragments surrounding the interpolations <code>${}</code>.</p>
    <ul>
      <li>
        In the example: <code>['Setting ', ' is ', '!']</code>
      </li>
    </ul>
  </li>
  <li>
    <p><em>Substitutions</em> (remaining arguments): the interpolated values.</p>
    <ul>
      <li>
        In the example: <code>'dark mode'</code> and <code>true</code>
      </li>
    </ul>
  </li>
</ul>
<p>The static (fixed) parts of the literal (the template strings) are kept separate from the dynamic parts (the substitutions).</p>
<p>A tag function can return arbitrary values.</p>
<h4 id="template-strings-cooked-vs-raw"><a class="heading-id-link" href="#template-strings-cooked-vs-raw">23.3.1 Cooked vs. raw template strings<span> (advanced)</span></a></h4>
<p>So far, we have only seen the <em>cooked interpretation</em> of template strings. But tag functions actually get two interpretations:</p>
<ul>
  <li>
    <p>A <em>cooked interpretation</em> where backslashes have special meaning. For example, <code>\t</code> produces a tab character. This interpretation of the template strings is stored as an Array in the first argument.</p>
  </li>
  <li>
    <p>A <em>raw interpretation</em> where backslashes do not have special meaning. For example, <code>\t</code> produces two characters – a backslash and a <code>t</code>. This interpretation of the template strings is stored in property <code>.raw</code> of the first argument (an Array).</p>
  </li>
</ul>
<p>The raw interpretation enables raw string literals via <code>String.raw</code> <a href="#raw-string-literals">(described later)</a> and similar applications.</p>
<p>The following tag function <code>cookedRaw</code> uses both interpretations:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">cookedRaw</span>(<span class="hljs-params">templateStrings, ...substitutions</span>) {</code>
<code>  <span class="hljs-keyword">return</span> {</code>
<code>    <span class="hljs-attr">cooked</span>: <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(templateStrings), <span class="hljs-comment">// copy only Array elements</span></code>
<code>    <span class="hljs-attr">raw</span>: templateStrings.<span class="hljs-property">raw</span>,</code>
<code>    substitutions,</code>
<code>  };</code>
<code>}</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  cookedRaw<span class="hljs-string">`\tab<span class="hljs-subst">${<span class="hljs-string">'subst'</span>}</span>\newline\\`</span>,</code>
<code>  {</code>
<code>    <span class="hljs-attr">cooked</span>: [<span class="hljs-string">'\tab'</span>, <span class="hljs-string">'\newline\\'</span>],</code>
<code>    <span class="hljs-attr">raw</span>:    [<span class="hljs-string">'\\tab'</span>, <span class="hljs-string">'\\newline\\\\'</span>],</code>
<code>    <span class="hljs-attr">substitutions</span>: [<span class="hljs-string">'subst'</span>],</code>
<code>  });</code>
</pre>
<p>We can also use Unicode code point escapes (<code>\u{1F642}</code>), Unicode code unit escapes (<code>\u03A9</code>), and ASCII escapes (<code>\x52</code>) in tagged templates:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  cookedRaw<span class="hljs-string">`\u{54}\u0065\x78t`</span>,</code>
<code>  {</code>
<code>    <span class="hljs-attr">cooked</span>: [<span class="hljs-string">'Text'</span>],</code>
<code>    <span class="hljs-attr">raw</span>:    [<span class="hljs-string">'\\u{54}\\u0065\\x78t'</span>],</code>
<code>    <span class="hljs-attr">substitutions</span>: [],</code>
<code>  });</code>
</pre>
<p>If the syntax of one of these escapes isn’t correct, the corresponding cooked template string is <code>undefined</code>, while the raw version is still verbatim:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  cookedRaw<span class="hljs-string">`\uu\xx <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> after`</span>,</code>
<code>  {</code>
<code>    <span class="hljs-attr">cooked</span>: [<span class="hljs-literal">undefined</span>, <span class="hljs-string">' after'</span>],</code>
<code>    <span class="hljs-attr">raw</span>:    [<span class="hljs-string">'\\uu\\xx '</span>, <span class="hljs-string">' after'</span>],</code>
<code>    <span class="hljs-attr">substitutions</span>: [<span class="hljs-number">1</span>],</code>
<code>  });</code>
</pre>
<p>Incorrect escapes produce syntax errors in template literals and string literals. Before ES2018, they even produced errors in tagged templates. Why was that changed? We can now use tagged templates for text that was previously illegal – for example:</p>
<pre class="language-txt">
<code>windowsPath`C:\uuu\xxx\111`</code>
<code>latex`\unicode`</code>
</pre>
<h3 id="examples-of-tagged-templates-as-provided-via-libraries"><a class="heading-id-link" href="#examples-of-tagged-templates-as-provided-via-libraries">23.4 Examples of tagged templates (as provided via libraries)</a></h3>
<p>Tagged templates are great for supporting small embedded languages (so-called <em>domain-specific languages</em>). We’ll continue with a few examples.</p>
<h4 id="tag-function-library-lithtml"><a class="heading-id-link" href="#tag-function-library-lithtml">23.4.1 Tag function library: lit-html</a></h4>
<p><a href="https://lit.dev">Lit</a> is a library for building web components that uses tagged templates for HTML templating:</p>
<pre class="language-js">
<code>@<span class="hljs-title function_">customElement</span>(<span class="hljs-string">'my-element'</span>)</code>
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">LitElement</span> {</code>
<code/>
<code>  <span class="hljs-comment">// ···</span></code>
<code/>
<code>  <span class="hljs-title function_">render</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> html`</span></code>
<code><span class="hljs-params"><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span></span></code>
<code><span class="hljs-params"><span class="language-xml">        </span><span class="hljs-subst">${repeat(</span></span></code>
<code><span class="hljs-params"><span class="hljs-subst">          <span class="hljs-variable language_">this</span>.items,</span></span></code>
<code><span class="hljs-params"><span class="hljs-subst">          (item) =&gt; item.id,</span></span></code>
<code><span class="hljs-params"><span class="hljs-subst">          (item, index) =&gt; html`<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><span class="hljs-subst">${index}</span><span class="language-xml">: </span><span class="hljs-subst">${item.name}</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>`</span></span></span></code>
<code><span class="hljs-params"><span class="hljs-subst">        )}</span></span></code>
<code><span class="hljs-params"><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span></span></code>
<code><span class="hljs-params"><span class="language-xml">    `</span>;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p><code>repeat()</code> is a custom function for looping. Its second parameter produces unique keys for the values returned by the third parameter. Note the nested tagged template used by that parameter.</p>
<h4 id="regex-library"><a class="heading-id-link" href="#regex-library">23.4.2 Tag function library: regex</a></h4>
<p><a href="https://github.com/slevithan/regex">The library “regex”</a> by Steven Levithan provides template tags that help with creating regular expressions and enable advanced features. The following example demonstrates how it works:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> {regex, pattern} <span class="hljs-keyword">from</span> <span class="hljs-string">'regex'</span>;</code>
<code/>
<code><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RE_YEAR</span> = pattern<span class="hljs-string">`(?&lt;year&gt;[0-9]{4})`</span>;</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RE_MONTH</span> = pattern<span class="hljs-string">`(?&lt;month&gt;[0-9]{2})`</span>;</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RE_DAY</span> = pattern<span class="hljs-string">`(?&lt;day&gt;[0-9]{2})`</span>;</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RE_DATE</span> = <span class="hljs-title function_">regex</span>(<span class="hljs-string">'g'</span>)<span class="hljs-string">`</span></code>
<code><span class="hljs-string">  <span class="hljs-subst">${RE_YEAR}</span> # 4 digits</span></code>
<code><span class="hljs-string">  -</span></code>
<code><span class="hljs-string">  <span class="hljs-subst">${RE_MONTH}</span> # 2 digits</span></code>
<code><span class="hljs-string">  -</span></code>
<code><span class="hljs-string">  <span class="hljs-subst">${RE_DAY}</span> # 2 digits</span></code>
<code><span class="hljs-string">`</span>;</code>
<code/>
<code><span class="hljs-keyword">const</span> match = <span class="hljs-variable constant_">RE_DATE</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'2017-01-27'</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(match.<span class="hljs-property">groups</span>.<span class="hljs-property">year</span>, <span class="hljs-string">'2017'</span>);</code>
</pre>
<p>The following flags are switched on by default:</p>
<ul>
  <li>
    Flag <code>/v</code>
  </li>
  <li>
    Flag <code>/x</code> (emulated) enables insignificant whitespace and line comments via <code>#</code>.
  </li>
  <li>
    Flag <code>/n</code> (emulated) enables <em>named capture only mode</em>, which prevents the grouping metacharacters <code>(···)</code> from capturing.
  </li>
</ul>
<h4 id="tag-function-library-graphqltag"><a class="heading-id-link" href="#tag-function-library-graphqltag">23.4.3 Tag function library: graphql-tag</a></h4>
<p><a href="https://github.com/apollographql/graphql-tag">The library graphql-tag</a> lets us create GraphQL queries via tagged templates:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> gql <span class="hljs-keyword">from</span> <span class="hljs-string">'graphql-tag'</span>;</code>
<code/>
<code><span class="hljs-keyword">const</span> query = gql`</code>
<code><span class="language-graphql">  <span class="hljs-punctuation">{</span></span></code>
<code><span class="language-graphql">    user<span class="hljs-punctuation">(</span><span class="hljs-symbol">id</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">{</span></span></code>
<code><span class="language-graphql">      firstName</span></code>
<code><span class="language-graphql">      lastName</span></code>
<code><span class="language-graphql">    <span class="hljs-punctuation">}</span></span></code>
<code><span class="language-graphql">  <span class="hljs-punctuation">}</span></span></code>
<code><span class="language-graphql">  `</span>;</code>
</pre>
<p>Additionally, there are plugins for pre-compiling such queries in Babel, TypeScript, etc.</p>
<h3 id="raw-string-literals"><a class="heading-id-link" href="#raw-string-literals">23.5 Raw string literals via the template tag <code>String.raw</code></a></h3>
<p><span id="index-entry-String.raw"/></p>
<p>Raw string literals are implemented via the tag function <code>String.raw</code>. They are string literals where backslashes don’t do anything special (such as escaping characters, etc.):</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`\back`</span>,</code>
<code>  <span class="hljs-string">'\\back'</span></code>
<code>);</code>
</pre>
<p>This helps whenever data contains backslashes – for example, strings with regular expressions:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> regex1 = <span class="hljs-regexp">/^\./</span>;</code>
<code><span class="hljs-keyword">const</span> regex2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">'^\\.'</span>);</code>
<code><span class="hljs-keyword">const</span> regex3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`^\.`</span>);</code>
</pre>
<p>All three regular expressions are equivalent. With a normal string literal, we have to write the backslash twice, to escape it for that literal. With a raw string literal, we don’t have to do that.</p>
<p>Raw string literals are also useful for specifying Windows filename paths:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">WIN_PATH</span> = <span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`C:\Users\Robin\Documents`</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-variable constant_">WIN_PATH</span>, <span class="hljs-string">'C:\\Users\\Robin\\Documents'</span></code>
<code>);</code>
</pre>
<h3 id="multiline-template-literals"><a class="heading-id-link" href="#multiline-template-literals">23.6 Multiline template literals and indentation</a></h3>
<p>If we put multiline text in template literals, two goals are in conflict: On one hand, the template literal should be indented to fit inside the source code. On the other hand, the lines of its content should start in the leftmost column.</p>
<p>For example:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">div</span>(<span class="hljs-params">text</span>) {</code>
<code>  <span class="hljs-keyword">return</span> <span class="hljs-string">`</span></code>
<code><span class="hljs-string">    &lt;div&gt;</span></code>
<code><span class="hljs-string">      <span class="hljs-subst">${text}</span></span></code>
<code><span class="hljs-string">    &lt;/div&gt;</span></code>
<code><span class="hljs-string">  `</span>;</code>
<code>}</code>
<code><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Output:'</span>);</code>
<code><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(</code>
<code>  <span class="hljs-title function_">div</span>(<span class="hljs-string">'Hello!'</span>)</code>
<code>  <span class="hljs-comment">// Replace spaces with mid-dots:</span></code>
<code>  .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/ /g</span>, <span class="hljs-string">'·'</span>)</code>
<code>  <span class="hljs-comment">// Replace \n with #\n:</span></code>
<code>  .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\n/g</span>, <span class="hljs-string">'#\n'</span>)</code>
<code>);</code>
</pre>
<p>Due to the indentation, the template literal fits well into the source code. Alas, the output is also indented. And we don’t want the return at the beginning and the return plus two spaces at the end.</p>
<pre class="language-html">
<code>Output:</code>
<code>#</code>
<code>····<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>#</code>
<code>······Hello!#</code>
<code>····<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>#</code>
<code>··</code>
</pre>
<p>There are two ways to fix this: via a tagged template or by trimming the result of the template literal.</p>
<h4 id="fix-indenting-the-text-and-removing-the-indentation-via-a-template-tag"><a class="heading-id-link" href="#fix-indenting-the-text-and-removing-the-indentation-via-a-template-tag">23.6.1 Fix: indenting the text and removing the indentation via a template tag</a></h4>
<p>The first fix is to use a custom template tag that removes the unwanted whitespace. It uses the first line after the initial line break to determine in which column the text starts and shortens the indentation everywhere. It also removes the line break at the very beginning and the indentation at the very end. One such template tag is <a href="https://github.com/dmnd/dedent"><code>dedent</code> by Desmond Brand</a>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">import</span> dedent <span class="hljs-keyword">from</span> <span class="hljs-string">'dedent'</span>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">divDedented</span>(<span class="hljs-params">text</span>) {</code>
<code>  <span class="hljs-keyword">return</span> dedent<span class="hljs-string">`</span></code>
<code><span class="hljs-string">    &lt;div&gt;</span></code>
<code><span class="hljs-string">      <span class="hljs-subst">${text}</span></span></code>
<code><span class="hljs-string">    &lt;/div&gt;</span></code>
<code><span class="hljs-string">  `</span>;</code>
<code>}</code>
<code><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Output:'</span>);</code>
<code><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">divDedented</span>(<span class="hljs-string">'Hello!'</span>));</code>
</pre>
<p>The output is not indented:</p>
<pre class="language-html">
<code>Output:</code>
<code><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></code>
<code>  Hello!</code>
<code><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code>
</pre>
<h4 id="fix-not-indenting-the-text-and-removing-leading-and-trailing-whitespace-via-trim"><a class="heading-id-link" href="#fix-not-indenting-the-text-and-removing-leading-and-trailing-whitespace-via-trim">23.6.2 Fix: not indenting the text and removing leading and trailing whitespace via <code>.trim()</code></a></h4>
<p>The second fix is quicker, but also dirtier:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">divDedented</span>(<span class="hljs-params">text</span>) {</code>
<code>  <span class="hljs-keyword">return</span> <span class="hljs-string">`</span></code>
<code><span class="hljs-string">&lt;div&gt;</span></code>
<code><span class="hljs-string">  <span class="hljs-subst">${text}</span></span></code>
<code><span class="hljs-string">&lt;/div&gt;</span></code>
<code><span class="hljs-string">  `</span>.<span class="hljs-title function_">trim</span>();</code>
<code>}</code>
<code><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Output:'</span>);</code>
<code><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">divDedented</span>(<span class="hljs-string">'Hello!'</span>));</code>
</pre>
<p>The string method <code>.trim()</code> removes the superfluous whitespace at the beginning and at the end, but the content itself can’t be indented – it must start in the leftmost column. The advantage of this solution is that we don’t need a custom tag function. The downside is that the unindented text doesn’t fit well into its surroundings.</p>
<p>The output is the same as with <code>dedent</code>:</p>
<pre class="language-html">
<code>Output:</code>
<code><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></code>
<code>  Hello!</code>
<code><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code>
</pre>
<h3 id="simple-templating-via-template-literals-advanced"><a class="heading-id-link" href="#simple-templating-via-template-literals-advanced">23.7 Simple templating via template literals<span> (advanced)</span></a></h3>
<p>While template literals look like text templates, it is not immediately obvious how to use them for (text) templating: A text template gets its data from an object, while a template literal gets its data from variables. The solution is to use a template literal in the body of a function whose parameter receives the templating data – for example:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> <span class="hljs-title function_">tmpl</span> = (<span class="hljs-params">data</span>) =&gt; <span class="hljs-string">`Hello <span class="hljs-subst">${data.name}</span>!`</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">tmpl</span>({<span class="hljs-attr">name</span>: <span class="hljs-string">'Jane'</span>}), <span class="hljs-string">'Hello Jane!'</span>);</code>
</pre>
<h4 id="a-more-complex-example"><a class="heading-id-link" href="#a-more-complex-example">23.7.1 A more complex example</a></h4>
<p>As a more complex example, we’d like to take an Array of addresses and produce an HTML table. This is the Array:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> addresses = [</code>
<code>  { <span class="hljs-attr">first</span>: <span class="hljs-string">'&lt;Jane&gt;'</span>, <span class="hljs-attr">last</span>: <span class="hljs-string">'Bond'</span> },</code>
<code>  { <span class="hljs-attr">first</span>: <span class="hljs-string">'Lars'</span>, <span class="hljs-attr">last</span>: <span class="hljs-string">'&lt;Croft&gt;'</span> },</code>
<code>];</code>
</pre>
<p>The function <code>tmpl()</code> that produces the HTML table looks as follows:</p>
<pre class="language-js numberLines">
<code><span class="hljs-keyword">const</span> <span class="hljs-title function_">tmpl</span> = (<span class="hljs-params">addrs</span>) =&gt; <span class="hljs-string">`</span></code>
<code><span class="hljs-string">&lt;table&gt;</span></code>
<code><span class="hljs-string">  <span class="hljs-subst">${addrs.map(</span></span></code>
<code><span class="hljs-string"><span class="hljs-subst">    (addr) =&gt; <span class="hljs-string">`</span></span></span></code>
<code><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">      &lt;tr&gt;</span></span></span></code>
<code><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">        &lt;td&gt;<span class="hljs-subst">${escapeHtml(addr.first)}</span>&lt;/td&gt;</span></span></span></code>
<code><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">        &lt;td&gt;<span class="hljs-subst">${escapeHtml(addr.last)}</span>&lt;/td&gt;</span></span></span></code>
<code><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">      &lt;/tr&gt;</span></span></span></code>
<code><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">      `</span>.trim()</span></span></code>
<code><span class="hljs-string"><span class="hljs-subst">  ).join(<span class="hljs-string">''</span>)}</span></span></code>
<code><span class="hljs-string">&lt;/table&gt;</span></code>
<code><span class="hljs-string">`</span>.<span class="hljs-title function_">trim</span>();</code>
</pre>
<p>This code contains two templating functions:</p>
<ul>
  <li>
    The first one (line 1) takes <code>addrs</code>, an Array with addresses, and returns a string with a table.
  </li>
  <li>
    The second one (line 4) takes <code>addr</code>, an object containing an address, and returns a string with a table row. Note the <code>.trim()</code> at the end, which removes unnecessary whitespace.
  </li>
</ul>
<p>The first templating function produces its result by wrapping a table element around an Array that it joins into a string (line 10). That Array is produced by mapping the second templating function to each element of <code>addrs</code> (line 3). It therefore contains strings with table rows.</p>
<p>The helper function <code>escapeHtml()</code> is used to escape special HTML characters (line 6 and line 7). Its implementation is shown in <span refcheck="#simple-html-escaping">the next subsection</span>.</p>
<p>Let us call <code>tmpl()</code> with the addresses and log the result:</p>
<pre class="language-js">
<code><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">tmpl</span>(addresses));</code>
</pre>
<p>The output is:</p>
<pre class="language-html">
<code><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></code>
<code>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></code>
<code>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>Jane<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></code>
<code>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Bond<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></code>
<code>      <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></code>
<code>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Lars<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></code>
<code>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>Croft<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></code>
<code>      <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></code>
<code><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code>
</pre>
<h4 id="simple-html-escaping"><a class="heading-id-link" href="#simple-html-escaping">23.7.2 Simple HTML-escaping</a></h4>
<p><span id="index-entry-escaping-HTML"/></p>
<p>The following function escapes plain text so that it is displayed verbatim in HTML:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">escapeHtml</span>(<span class="hljs-params">str</span>) {</code>
<code>  <span class="hljs-keyword">return</span> str</code>
<code>    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&amp;/g</span>, <span class="hljs-string">'&amp;amp;'</span>) <span class="hljs-comment">// first!</span></code>
<code>    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&gt;/g</span>, <span class="hljs-string">'&amp;gt;'</span>)</code>
<code>    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&lt;/g</span>, <span class="hljs-string">'&amp;lt;'</span>)</code>
<code>    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/"/g</span>, <span class="hljs-string">'&amp;quot;'</span>)</code>
<code>    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/'/g</span>, <span class="hljs-string">'&amp;#39;'</span>)</code>
<code>    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/`/g</span>, <span class="hljs-string">'&amp;#96;'</span>)</code>
<code>    ;</code>
<code>}</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  escapeHtml(<span class="hljs-string">'Rock &amp; Roll'</span>), <span class="hljs-string">'Rock &amp;amp; Roll'</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  escapeHtml(<span class="hljs-string">'&lt;blank&gt;'</span>), <span class="hljs-string">'&amp;lt;blank&amp;gt;'</span>);</code>
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: HTML templating</strong></p>
  <div class="boxout-vspace"/>
  <p>Exercise with bonus challenge: <code>exercises/template-literals/templating_test.mjs</code></p>
</div>

    
      
</body>
</html>