["```ts\n{\n [Key in «KeySet»]: «PropValue»\n}\n\n```", "```ts\ntype Obj = {\n [K in 'a' | 'b' | 'c']: number\n};\ntype _ = Assert<Equal<\n Obj,\n {\n a: number,\n b: number,\n c: number,\n }\n>>;\n\n```", "```ts\ntype StrToNum = {\n [key: string]: number, // index signature\n};\n\n```", "```ts\nconst obj1: StrToNum = {};\nconst obj2: StrToNum = { a: 1 };\nconst obj3: StrToNum = { a: 1, b: 2, hello: 3 };\n\n```", "```ts\ntype _ = [\n Assert<Equal<\n // Type-level function applied to a finite type\n {\n [K in 'a' | 'b' | 'c']: number\n },\n // Result: object literal type with normal properties\n {\n a: number,\n b: number,\n c: number,\n }\n >>,\n Assert<Equal<\n // Type-level function applied to an infinite type\n {\n [K in string]: number\n },\n // Result: object literal type with index signature\n {\n [x: string]: number\n }\n >>,\n];\n\n```", "```ts\ntype Arrayify<Obj> = {\n [K in keyof Obj]: Array<Obj[K]> // (A)\n};\n\ntype InputObj = {\n str: string,\n num: number,\n};\ntype _ = Assert<Equal<\n Arrayify<InputObj>,\n {\n str: Array<string>,\n num: Array<number>,\n }\n>>;\n\n```", "```ts\ntype WrapValues<T> = {\n [Key in keyof T]: Promise<T[Key]>\n};\n\ntype _ = [\n // Read-only tuple in, read-only tuple out\n Assert<Equal<\n WrapValues<readonly ['a', 'b']>,\n readonly [Promise<'a'>, Promise<'b'>]\n >>,\n\n // Tuple labels are preserved\n Assert<Equal<\n WrapValues<[labelA: 'a', labelB: 'b']>,\n [labelA: Promise<'a'>, labelB: Promise<'b'>]\n >>,\n\n // Array in, Array out\n Assert<Equal<\n WrapValues<Array<string>>,\n Array<Promise<string>>\n >>,\n\n // ReadonlyArray in, ReadonlyArray out\n Assert<Equal<\n WrapValues<ReadonlyArray<string>>,\n ReadonlyArray<Promise<string>>\n >>,\n\n // Object in, object out\n Assert<Equal<\n WrapValues<{ a: 1, b: 2 }>,\n { a: Promise<1>, b: Promise<2> }\n >>,\n\n // Read-only properties are preserved\n Assert<Equal<\n WrapValues<{ readonly a: 1, readonly b: 2 }>,\n { readonly a: Promise<1>, readonly b: Promise<2> }\n >>,\n];\n\n```", "```ts\ninterface SyncService {\n factorize(num: number): Array<number>;\n createDigest(text: string): string;\n}\ntype AsyncService = Asyncify<SyncService>;\ntype _ = Assert<Equal<\n AsyncService,\n {\n factorize: (num: number) => Promise<Array<number>>,\n createDigest: (text: string) => Promise<string>,\n }\n>>;\n\n```", "```ts\ntype Asyncify<Intf> = {\n [K in keyof Intf]: // (A)\n Intf[K] extends (...args: infer A) => infer R // (B)\n ? (...args: A) => Promise<R> // (C)\n : Intf[K] // (D)\n};\n\n```", "```ts\nconst tokenDefs = {\n number: {\n key: 'number',\n re: /[0-9]+/,\n description: 'integer number',\n },\n identifier: {\n key: 'identifier',\n re: /[a-z]+/,\n },\n} as const;\n\n```", "```ts\nconst tokenDefs = addKeys({\n number: {\n re: /[0-9]+/,\n description: 'integer number',\n },\n identifier: {\n re: /[a-z]+/,\n },\n} as const);\n\nassert.deepEqual(\n tokenDefs,\n {\n number: {\n key: 'number',\n re: /[0-9]+/,\n description: 'integer number',\n },\n identifier: {\n key: 'identifier',\n re: /[a-z]+/,\n },\n }\n);\n\nassertType<\n {\n readonly number: {\n readonly re: RegExp,\n readonly description: 'integer number',\n key: string,\n },\n readonly identifier: {\n readonly re: RegExp,\n key: string,\n },\n }\n>(tokenDefs);\n\n```", "```ts\nfunction addKeys<\n T extends Record<string, InputTokenDef>\n>(tokenDefs: T)\n: {[K in keyof T]: T[K] & {key: string}} // (A)\n{\n const entries = Object.entries(tokenDefs);\n const pairs = entries.map(\n ([key, def]) => [key, {key, ...def}]\n );\n return Object.fromEntries(pairs);\n}\n\n// Information we have to provide\ninterface InputTokenDef {\n re: RegExp,\n description?: string,\n}\n\n// Information addKeys() adds for us\ninterface TokenDef extends InputTokenDef {\n key: string,\n}\n\n```", "```ts\n{ [P in K as N]: X }\n\n```", "```ts\ntype Point = {\n x: number,\n y: number,\n};\ntype PrefixUnderscore<Obj> = {\n [K in keyof Obj & string as `_${K}`]: Obj[K] // (A)\n};\ntype X = PrefixUnderscore<Point>;\ntype _ = Assert<Equal<\n PrefixUnderscore<Point>,\n {\n _x: number,\n _y: number,\n }\n>>;\n\n```", "```ts\ntype KeyAsKeyToKey<T> = {\n [K in keyof T as K]: K\n};\ntype _ = Assert<Equal<\n // Use Pick<> because result of KeyAsKeyToKey<> is large\n Pick<\n KeyAsKeyToKey<['a', 'b']>,\n '0' | '1' | 'length' | 'push' | 'join'\n >,\n // Result is an object, not a tuple\n {\n length: 'length';\n push: 'push';\n join: 'join';\n 0: '0';\n 1: '1';\n }\n>>;\n\n```", "```ts\ntype KeepStrProps<Obj> = {\n [\n Key in keyof Obj\n as Obj[Key] extends string ? Key : never\n ]: Obj[Key]\n};\n\ntype Obj = {\n strPropA: 'A',\n strPropB: 'B',\n numProp1: 1,\n numProp2: 2,\n};\ntype _ = Assert<Equal<\n KeepStrProps<Obj>,\n {\n strPropA: 'A',\n strPropB: 'B',\n }\n>>;\n\n```", "```ts\ntype Obj = {\n strPropA: 'A',\n strPropB: 'B',\n numProp1: 1,\n numProp2: 2,\n};\n\n```", "```ts\ntype KeysOfStrProps<T> = {\n [K in keyof T]: T[K] extends string ? K : never // (A)\n}[keyof T]; // (B)\n\ntype _1 = Assert<Equal<\n KeysOfStrProps<Obj>,\n 'strPropA' | 'strPropB'\n>>;\n\n```", "```ts\ntype KeepStrProps<Obj> = {\n [Key in KeysOfStrProps<Obj>]: Obj[Key]\n};\ntype _2 = Assert<Equal<\n KeepStrProps<Obj>,\n {\n strPropA: 'A',\n strPropB: 'B',\n }\n>>;\n\n```", "```ts\n/**\n * From T, pick a set of properties whose keys are in the union K\n */\ntype Pick<T, K extends keyof T> = {\n [P in K]: T[P];\n};\n\n```", "```ts\ntype ObjectLiteralType = {\n eeny: 1,\n meeny: 2,\n miny: 3,\n moe: 4,\n};\n\ntype _ = Assert<Equal<\n Pick<ObjectLiteralType, 'eeny' | 'miny'>,\n { eeny: 1, miny: 3 }\n>>;\n\n```", "```ts\nfunction pick<\n O extends Record<string, unknown>,\n K extends keyof O\n>(\n object: O,\n ...keys: Array<K>\n): Pick<O, K> {\n return Object.fromEntries(\n Object.entries(object)\n .filter(\n ([key, _value]) => keys.includes(key as K)\n )\n ) as any;\n}\n\nconst address = {\n street: 'Evergreen Terrace',\n number: '742',\n city: 'Springfield',\n state: 'NT',\n zip: '49007',\n};\nconst result = pick(address, 'street', 'number');\n\n// Correct value?\nassert.deepEqual(\n result,\n {\n street: 'Evergreen Terrace',\n number: '742',\n }\n);\n\n// Correct type?\nassertType<\n {\n street: string,\n number: string,\n }\n>(result);\n\n```", "```ts\ntype Obj = {\n '0': 'a',\n '1': 'b',\n length: 2,\n};\n// @ts-expect-error: Type '`${number}`' does not satisfy the constraint\n// 'keyof Obj'.\ntype _1 = Pick<Obj, `${number}`>\n\n```", "```ts\ntype PickFreely<T, K> = {\n [P in K & keyof T]: T[P];\n};\n\n```", "```ts\ntype _2 = Assert<Equal<\n PickFreely<Obj, `${number}`>,\n {\n '0': 'a',\n '1': 'b',\n }\n>>;\n\n```", "```ts\n/**\n * Construct a type with the properties of T except for those in\n * type K.\n */\ntype Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;\n\n```", "```ts\n    type _ = Assert<Equal<\n     keyof any,\n     string | number | symbol\n    >>;\n\n    ```", "```ts\ntype ObjectLiteralType = {\n eeny: 1,\n meeny: 2,\n miny: 3,\n moe: 4,\n};\n\ntype _ = Assert<Equal<\n Omit<ObjectLiteralType, 'eeny' | 'miny'>,\n { meeny: 2; moe: 4; }\n>>;\n\n```", "```ts\ntype AddOptional<T> = {\n [K in keyof T]+?: T[K]\n};\ntype RequiredArticle = {\n title: string,\n tags: Array<string>,\n score: number,\n};\ntype OptionalArticle = AddOptional<RequiredArticle>;\ntype _ = Assert<Equal<\n OptionalArticle,\n {\n title?: string | undefined;\n tags?: Array<string> | undefined;\n score?: number | undefined;\n }\n>>;\n\n```", "```ts\ntype RemoveOptional<T> = {\n [K in keyof T]-?: T[K]\n};\ntype OptionalArticle = {\n title?: string,\n tags?: Array<string>,\n score: number,\n};\ntype RequiredArticle = RemoveOptional<OptionalArticle>;\ntype _ = Assert<Equal<\n RequiredArticle,\n {\n title: string,\n tags: Array<string>,\n score: number,\n }\n>>;\n\n```", "```ts\ntype AddReadonly<Obj> = {\n +readonly [K in keyof Obj]: Obj[K]\n};\ntype MutableArticle = {\n title: string,\n tags: Array<string>,\n score: number,\n};\ntype ImmutableArticle = AddReadonly<MutableArticle>;\ntype _ = Assert<Equal<\n ImmutableArticle,\n {\n readonly title: string,\n readonly tags: Array<string>,\n readonly score: number,\n }\n>>;\n\n```", "```ts\ntype RemoveReadonly<Obj> = {\n -readonly [K in keyof Obj]: Obj[K]\n};\ntype ImmutableArticle = {\n readonly title: string,\n readonly tags: Array<string>,\n score: number,\n};\ntype MutableArticle = RemoveReadonly<ImmutableArticle>;\ntype _ = Assert<Equal<\n MutableArticle,\n {\n title: string,\n tags: Array<string>,\n score: number,\n }\n>>;\n\n```", "```ts\ninterface Car {\n readonly year: number,\n get maker(): string, // technically `readonly`\n owner: string,\n}\n\ntype _1 = [\n Assert<Equal<\n IsReadonly<Car, 'year'>, true\n >>,\n Assert<Equal<\n IsReadonly<Car, 'maker'>, true\n >>,\n Assert<Equal<\n IsReadonly<Car, 'owner'>, false\n >>,\n];\n\n```", "```ts\ntype SimpleEqual<T1, T2> =\n [T1] extends [T2]\n ? [T2] extends [T1] ? true : false\n : false\n;\ntype _2 = Assert<Equal<\n SimpleEqual<\n {readonly year: number},\n {year: number}\n >,\n true\n>>;\n\n```", "```ts\ntype StrictEqual<X, Y> =\n (<T>() => T extends X ? 1 : 2) extends\n (<T>() => T extends Y ? 1 : 2) ? true : false\n;\ntype _3 = [\n Assert<Equal<\n StrictEqual<\n {readonly year: number},\n {year: number}\n >,\n false\n >>,\n Assert<Equal<\n StrictEqual<\n {year: number},\n {year: number}\n >,\n true\n >>,\n Assert<Equal<\n StrictEqual<\n {readonly year: number},\n {readonly year: number}\n >,\n true\n >>,\n];\n\n```", "```ts\ntype IsReadonly<T, K extends keyof T> =\n StrictEqual<\n Pick<T, K>, // (A)\n Readonly<Pick<T, K>> // (B)\n >\n;\n\n```", "```ts\ninterface Person {\n name: undefined | string;\n age?: number;\n}\n\ntype _1 = [\n Assert<Equal<\n IsOptional<Person, 'name'>, false\n >>,\n Assert<Equal<\n IsOptional<Person, 'age'>, true\n >>,\n];\n\n```", "```ts\ntype IsOptional<T extends Record<any, any>, K extends keyof T> =\n {} extends Pick<T, K> ? true : false\n;\n\n```", "```ts\ntype _2 = [\n Assert<Equal<\n Pick<Person, 'name'>,\n { name: undefined | string }\n >>,\n Assert<Equal<\n Pick<Person, 'age'>,\n { age?: number | undefined }\n >>,\n];\n\n```", "```ts\n/**\n * Construct a type with a set of properties K of type T\n */\ntype Record<K extends keyof any, T> = {\n [P in K]: T;\n};\n\n```", "```ts\ntype _ = Assert<Equal<\n keyof any,\n string | number | symbol\n>>;\n\n```", "```ts\ntype _ = [\n Assert<Equal<\n // Finite key type\n Record<'a' | 'b', RegExp>,\n {\n a: RegExp,\n b: RegExp,\n }\n >>,\n Assert<Equal<\n // Infinite key type\n Record<string, boolean>,\n {\n [x: string]: boolean // index signature\n }\n >>,\n];\n\n```"]