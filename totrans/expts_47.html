<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>39 Testing types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>39 Testing types</h1>
<blockquote>原文：<a href="https://exploringjs.com/ts/book/ch_testing-types.html">https://exploringjs.com/ts/book/ch_testing-types.html</a></blockquote>

    
        <div id="adbox">
      <div id="adbox-explain">(Ad, please don’t block.)</div>
              
          </div>
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#asserting-at-the-type-level">39.1 Asserting at the type level</a>
    </li>
    <li>
      <a href="#checking-if-type-is-any">39.2 How to check if a type is <code>any</code>?</a>
    </li>
    <li>
      <a href="#checking-type-equality">39.3 How to check if two types are equal?</a>
      <ol>
        <li>
          <a href="#a-first-attempt-tmutuallyassignable">39.3.1 A first attempt: <code>TMutuallyAssignable</code></a>
        </li>
        <li>
          <a href="#disabling-distribution">39.3.2 Disabling distribution</a>
        </li>
        <li>
          <a href="#TEqual">39.3.3 Ensuring the <code>any</code> is only equal to itself</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#how-do-we-assert-that-something-must-be-true">39.4 How do we assert that something must be <code>true</code>?</a>
      <ol>
        <li>
          <a href="#not-utility-type-for-boolean-negation">39.4.1 <code>Not</code>: utility type for boolean negation</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#asserting-errors">39.5 Asserting errors</a>
      <ol>
        <li>
          <a href="#a-more-complex-example">39.5.1 A more complex example</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#asserting-the-type-of-a-value">39.6 Asserting the type of a value</a>
    </li>
    <li>
      <a href="#type-level-assertions-in-normal-code">39.7 A use case for a type-level assertion in normal code</a>
    </li>
    <li>
      <a href="#running-type-level-tests">39.8 Running type-level tests</a>
    </li>
    <li>
      <a href="#further-reading-11">39.9 Further reading</a>
    </li>
  </ol>
</nav>
<p>In this chapter, we explore how we can test that complicated TypeScript types work as expected. To do that, we need assertions at the type level and other tools.</p>
<h3 id="asserting-at-the-type-level"><a class="heading-id-link" href="#asserting-at-the-type-level">39.1 Asserting at the type level</a></h3>
<p>Writing more complicated types is like programming at a different level:</p>
<ul>
  <li>
    At the program level, we use JavaScript – e.g.:
    <ul>
      <li>
        Values
      </li>
      <li>
        Functions with parameters
      </li>
    </ul>
  </li>
  <li>
    At the type level, we use (non-JavaScript) TypeScript – e.g.:
    <ul>
      <li>
        Types
      </li>
      <li>
        Generic types with type parameters
      </li>
    </ul>
  </li>
</ul>
<p>At the program level, we can use assertions such as <a href="https://nodejs.org/api/assert.html#assertdeepequalactual-expected-message"><code>assert.deepEqual()</code></a> to test our code:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> <span class="hljs-title function_">pair</span> = (<span class="hljs-params">x</span>) =&gt; [x, x];</code>
<code><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">pair</span>(<span class="hljs-string">'abc'</span>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  result, [<span class="hljs-string">'abc'</span>, <span class="hljs-string">'abc'</span>]</code>
<code>);</code>
</pre>
<p>So how can we test type-level code – which is important for complicated types? We also need assertions – e.g.:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; = [T, T];</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span> = <span class="hljs-title class_">Pair</span>&lt;<span class="hljs-string">'abc'</span>&gt;;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Result</span>, [<span class="hljs-string">'abc'</span>, <span class="hljs-string">'abc'</span>]</code>
<code>&gt;&gt;;</code>
</pre>
<p>The generic types <code>Assert</code> and <code>Equal</code> are part of my npm package <a href="https://github.com/rauschma/asserttt"><code>asserttt</code></a>. In this chapter, we’ll use this package in two ways:</p>
<ul>
  <li>
    On one hand, we reimplement its API to see how it works.
  </li>
  <li>
    On the other hand, we use its API to check that what we have implemented works as desired.
  </li>
</ul>
<p>To avoid confusion, the names of our types always start with <code>T</code>:</p>
<ul>
  <li>
    <code>asserttt</code> type: <code>MutuallyAssignable</code>
  </li>
  <li>
    Our version: <code>TMutuallyAssignable</code>
  </li>
</ul>
<h3 id="checking-if-type-is-any"><a class="heading-id-link" href="#checking-if-type-is-any">39.2 How to check if a type is <code>any</code>?</a></h3>
<p>In this section, we explore how to check if a given type is <code>any</code>. That will help us later with defining <code>TEqual&lt;X, Y&gt;</code>.</p>
<p>How can we detect <code>any</code> by only checking assignability via <code>extends</code>? Special types we have to consider:</p>
<ul>
  <li>
    <code>any</code> is assignable to and from any type – with one exception: It’s not assignable to <code>never</code>.
  </li>
  <li>
    Any type is assignable to <code>unknown</code>. <code>unknown</code> is not assignable to any type (other than <code>unknown</code> and <code>any</code>).
  </li>
  <li>
    <code>never</code> is assignable to any type. No type (other than <code>never</code>) is assignable to <code>never</code>; not even <code>any</code> can be assigned to <code>never</code>.
  </li>
</ul>
<p>Therefore, a type <code>T</code> is <code>any</code> if both:</p>
<ol>
  <li>
    <code>T</code> is assignable to the number literal type <code>1</code>.
  </li>
  <li>
    The number literal type <code>2</code> is assignable to <code>T</code>.
  </li>
</ol>
<p>After check 1, <code>T</code> can be <code>1</code>, <code>never</code> or <code>any</code>. Check 2 excludes <code>1</code> and <code>never</code>. This is an implementation of the two checks:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">TIsAny</span>&lt;T&gt; = [T, <span class="hljs-number">2</span>] <span class="hljs-keyword">extends</span> [<span class="hljs-number">1</span>, T] ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;</code>
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">TIsAny</span>&lt;<span class="hljs-built_in">any</span>&gt;, <span class="hljs-literal">true</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">TIsAny</span>&lt;<span class="hljs-built_in">unknown</span>&gt;, <span class="hljs-literal">false</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">TIsAny</span>&lt;<span class="hljs-built_in">never</span>&gt;, <span class="hljs-literal">false</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">TIsAny</span>&lt;<span class="hljs-number">1</span>&gt;, <span class="hljs-literal">false</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">TIsAny</span>&lt;<span class="hljs-number">2</span>&gt;, <span class="hljs-literal">false</span></code>
<code>  &gt;&gt;,</code>
<code>];</code>
</pre>
<p><a href="https://stackoverflow.com/questions/49927523/disallow-call-with-any/49928360#49928360">An even more concise solution</a> was proposed by Joe Calzaretta:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">TIsAny</span>&lt;T&gt; = <span class="hljs-number">0</span> <span class="hljs-keyword">extends</span> (<span class="hljs-number">1</span> &amp; T) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;</code>
</pre>
<p>How does this code work?</p>
<ul>
  <li>
    <p>The condition <code>0 extends 1</code> fails. It checks if <code>0</code> is a subset of <code>1</code> (if <code>0</code> is assignable to <code>1</code>).</p>
  </li>
  <li>
    <p>For all normal types <code>T</code>, the intersection <code>1 &amp; T</code> is as big as the type <code>1</code> or smaller. Therefore, the result of the check stays the same.</p>
  </li>
  <li>
    <p>Only the type <code>any</code> is different, because <code>1 &amp; any</code> is <code>any</code> and <code>0</code> is a subset of <code>any</code>.</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _X = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-number">1</span> &amp; <span class="hljs-built_in">any</span>,</code>
<code>  <span class="hljs-built_in">any</span></code>
<code>&gt;&gt;;</code>
</pre>
  </li>
</ul>
<h3 id="checking-type-equality"><a class="heading-id-link" href="#checking-type-equality">39.3 How to check if two types are equal?</a></h3>
<p>The most important part of a type-level assertion API is checking whether two types are equal. As it turns out, that is surprisingly difficult.</p>
<h4 id="a-first-attempt-tmutuallyassignable"><a class="heading-id-link" href="#a-first-attempt-tmutuallyassignable">39.3.1 A first attempt: <code>TMutuallyAssignable</code></a></h4>
<p>What does two <code>X</code> and <code>Y</code> being equal actually mean? One reasonable definition is:</p>
<ul>
  <li>
    <code>X</code> is assignable to <code>Y</code> and
  </li>
  <li>
    <code>Y</code> is assignable to <code>X</code>.
  </li>
</ul>
<p>We check assignability via <code>extends</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">TMutuallyAssignable</span>&lt;X, Y&gt; =</code>
<code>  X <span class="hljs-keyword">extends</span> Y</code>
<code>    ? (Y <span class="hljs-keyword">extends</span> X ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>)</code>
<code>    : <span class="hljs-literal">false</span></code>
<code>;</code>
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">TMutuallyAssignable</span>&lt;<span class="hljs-string">'hello'</span>, <span class="hljs-string">'hello'</span>&gt;, <span class="hljs-comment">// (A)</span></code>
<code>    <span class="hljs-literal">true</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">TMutuallyAssignable</span>&lt;<span class="hljs-string">'yes'</span>, <span class="hljs-string">'no'</span>&gt;, <span class="hljs-comment">// (B)</span></code>
<code>    <span class="hljs-literal">false</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">TMutuallyAssignable</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-string">'yes'</span>&gt;, <span class="hljs-comment">// (C)</span></code>
<code>    <span class="hljs-literal">false</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">TMutuallyAssignable</span>&lt;<span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>|<span class="hljs-string">'b'</span>&gt;, <span class="hljs-comment">// (D)</span></code>
<code>    <span class="hljs-literal">true</span> | <span class="hljs-literal">false</span></code>
<code>  &gt;&gt;,</code>
<code>];</code>
</pre>
<p>The test cases start off well: line A and line B produce the expected results and even the more tricky check in line C works correctly.</p>
<p>Alas, in line D, the result is both <code>true</code> and <code>false</code>. Why is that? <code>TMutuallyAssignable</code> is defined using conditional types and those are distributive over union types (<a href="ch_conditional-types.html#distributivity-of-conditional-types">more information</a>).</p>
<h4 id="disabling-distribution"><a class="heading-id-link" href="#disabling-distribution">39.3.2 Disabling distribution</a></h4>
<p>In order for <code>TMutuallyAssignable</code> to work as desired, we need to switch off distribution. A conditional type is only distributive if the left-hand side of <code>extends</code> is a bare type variable (<a href="ch_conditional-types.html#preventing-distributivity">more information</a>). Therefore, we can disable distribution by turning both sides of <code>extends</code> into single-element tuples:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">TMutuallyAssignable</span>&lt;X, Y&gt; =</code>
<code>  [X] <span class="hljs-keyword">extends</span> [Y]</code>
<code>    ? ([Y] <span class="hljs-keyword">extends</span> [X] ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>)</code>
<code>    : <span class="hljs-literal">false</span></code>
<code>;</code>
</pre>
<p>We can simplify this <code>TMutuallyAssignable</code> a little by doing both <code>extends</code> checks at the same time (the square brackets still ensure that no distribution happens):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">TMutuallyAssignable</span>&lt;X, Y&gt; =</code>
<code>  [X, Y] <span class="hljs-keyword">extends</span> [Y, X] ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span></code>
<code>  ;</code>
</pre>
<p>Let’s test the non-distributive version of <code>TMutuallyAssignable</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">TMutuallyAssignable</span>&lt;<span class="hljs-string">'hello'</span>, <span class="hljs-string">'hello'</span>&gt;,</code>
<code>    <span class="hljs-literal">true</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">TMutuallyAssignable</span>&lt;<span class="hljs-string">'yes'</span>, <span class="hljs-string">'no'</span>&gt;,</code>
<code>    <span class="hljs-literal">false</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">TMutuallyAssignable</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-string">'yes'</span>&gt;,</code>
<code>    <span class="hljs-literal">false</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">TMutuallyAssignable</span>&lt;<span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>|<span class="hljs-string">'b'</span>&gt;, <span class="hljs-comment">// (A)</span></code>
<code>    <span class="hljs-literal">false</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">TMutuallyAssignable</span>&lt;<span class="hljs-built_in">any</span>, <span class="hljs-number">123</span>&gt;, <span class="hljs-comment">// (B)</span></code>
<code>    <span class="hljs-literal">true</span></code>
<code>  &gt;&gt;,</code>
<code>];</code>
</pre>
<p>Now we can also handle union types correctly (line A). However, one problem remains (line B): <code>any</code> is equal to any other type:</p>
<ul>
  <li>
    If the expected type is <code>any</code> then all actual types are equal to it.
  </li>
  <li>
    If we expect a specific type then the actual type <code>any</code> will always be equal, too.
  </li>
</ul>
<h4 id="TEqual"><a class="heading-id-link" href="#TEqual">39.3.3 Ensuring the <code>any</code> is only equal to itself</a></h4>
<p>We can use <code>TMutuallyAssignable</code> to define a generic type <code>TEqual</code> that fixes the issues with <code>any</code> (we use the utility <code>TIsAny</code> from earlier):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">TEqual</span>&lt;X, Y&gt; =</code>
<code>  [<span class="hljs-title class_">TIsAny</span>&lt;X&gt;, <span class="hljs-title class_">TIsAny</span>&lt;Y&gt;] <span class="hljs-keyword">extends</span> [<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>] ? <span class="hljs-literal">true</span></code>
<code>  : [<span class="hljs-title class_">TIsAny</span>&lt;X&gt;, <span class="hljs-title class_">TIsAny</span>&lt;Y&gt;] <span class="hljs-keyword">extends</span> [<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>] ? <span class="hljs-title class_">MutuallyAssignable</span>&lt;X, Y&gt;</code>
<code>  : <span class="hljs-literal">false</span></code>
<code>  ;</code>
</pre>
<p>Our approach is:</p>
<ul>
  <li>
    If both <code>X</code> and <code>Y</code> are <code>any</code>, they are equal.
  </li>
  <li>
    If neither <code>X</code> nor <code>Y</code> is <code>any</code>, they are equal if they are mutually assignable.
  </li>
  <li>
    Otherwise, only <code>X</code> or only <code>Y</code> is <code>any</code> and they are not equal.
  </li>
</ul>
<p><code>TEqual</code> passes all of the following tests:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">TEqual</span>&lt;<span class="hljs-string">'hello'</span>, <span class="hljs-string">'hello'</span>&gt;,</code>
<code>    <span class="hljs-literal">true</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">TEqual</span>&lt;<span class="hljs-string">'yes'</span>, <span class="hljs-string">'no'</span>&gt;,</code>
<code>    <span class="hljs-literal">false</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">TEqual</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-string">'yes'</span>&gt;,</code>
<code>    <span class="hljs-literal">false</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">TEqual</span>&lt;<span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>|<span class="hljs-string">'b'</span>&gt;,</code>
<code>    <span class="hljs-literal">false</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">TEqual</span>&lt;<span class="hljs-built_in">any</span>, <span class="hljs-number">123</span>&gt;, <span class="hljs-comment">// (A)</span></code>
<code>    <span class="hljs-literal">false</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">TEqual</span>&lt;<span class="hljs-built_in">any</span>, <span class="hljs-built_in">any</span>&gt;, <span class="hljs-comment">// (B)</span></code>
<code>    <span class="hljs-literal">true</span></code>
<code>  &gt;&gt;,</code>
<code>];</code>
</pre>
<p><code>TEqual</code> passes the test in line A, which <code>TMutuallyAssignable</code> failed. Line B contains an addition check for <code>any</code> – to make sure everything works correctly.</p>
<h3 id="how-do-we-assert-that-something-must-be-true"><a class="heading-id-link" href="#how-do-we-assert-that-something-must-be-true">39.4 How do we assert that something must be <code>true</code>?</a></h3>
<p>At the program/JavaScript level, we can throw an exception if an assertion fails:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">assert</span>(<span class="hljs-params">condition</span>) {</code>
<code>  <span class="hljs-keyword">if</span> (condition === <span class="hljs-literal">false</span>) {</code>
<code>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Assertion failed'</span>);</code>
<code>  }</code>
<code>}</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">equal</span>(<span class="hljs-params">x, y</span>) {</code>
<code>  <span class="hljs-keyword">return</span> x === y;</code>
<code>}</code>
<code/>
<code><span class="hljs-title function_">assert</span>(<span class="hljs-title function_">equal</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// throws an exception</span></code>
</pre>
<p>Alas, there is no way to fail at compile time in TypeScript. If there were, it could look like this:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">AssertType1</span>&lt;B <span class="hljs-keyword">extends</span> <span class="hljs-built_in">boolean</span>&gt; = B <span class="hljs-keyword">extends</span> <span class="hljs-literal">true</span> ? <span class="hljs-built_in">void</span> : fail;</code>
</pre>
<p>This type has the same result as a <code>void</code> function if <code>B</code> is <code>true</code>. If it is <code>false</code> then it fails at the type level, via the invented directive <code>fail</code>. The closest thing to <code>fail</code> that TypeScript currently has, is returning <code>never</code>. However, <code>never</code> does not immediately cause type checking errors.</p>
<p>Thankfully, there is a decent workaround that mostly gives us what we want:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">AssertType2</span>&lt;_B <span class="hljs-keyword">extends</span> <span class="hljs-literal">true</span>&gt; = <span class="hljs-built_in">void</span>; <span class="hljs-comment">// (A)</span></code>
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">AssertType2</span>&lt;<span class="hljs-literal">true</span>&gt;, <span class="hljs-comment">// OK</span></code>
<code>  <span class="hljs-comment">// @ts-expect-error: Type 'false' does not satisfy</span></code>
<code>  <span class="hljs-comment">// the constraint 'true'.</span></code>
<code>  <span class="hljs-title class_">AssertType2</span>&lt;<span class="hljs-literal">false</span>&gt;,</code>
<code>];</code>
</pre>
<p>When we pass arguments to a generic type, the <code>extends</code> constraints of all of its parameters must be fulfilled. Otherwise, we get a type-level failure. That’s what we use in line A: The value we pass to <code>AssertType2</code> must be <code>true</code> or the type checker complains.</p>
<p>This workaround has limits, though. The following functionality can only be implemented via <code>fail</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">AssertEqual</span>&lt;X, Y&gt; = <span class="hljs-title class_">Equal</span>&lt;X, Y&gt; <span class="hljs-keyword">extends</span> <span class="hljs-literal">true</span> ? <span class="hljs-built_in">void</span> : fail;</code>
</pre>
<h4 id="not-utility-type-for-boolean-negation"><a class="heading-id-link" href="#not-utility-type-for-boolean-negation">39.4.1 <code>Not</code>: utility type for boolean negation</a></h4>
<p>Once we have <code>Equal</code> and <code>Assert</code>, we can implement more helper types – e.g. <code>Not&lt;B&gt;</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">TNot</span>&lt;B <span class="hljs-keyword">extends</span> <span class="hljs-built_in">boolean</span>&gt; = [B] <span class="hljs-keyword">extends</span> [<span class="hljs-literal">true</span>] ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;</code>
</pre>
<p>The square brackets around <code>B</code> prevent distribution. <code>TNot</code> enables us to assert that one type is <em>not</em> equal to another type:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">TNot</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-string">'yes'</span>, <span class="hljs-string">'no'</span></code>
<code>&gt;&gt;&gt;;</code>
</pre>
<p>A generic type whose result is <code>true</code> or <code>false</code> is called a <em>predicate</em>. Such types can be used with <code>Assert</code>. <code>Equal</code> and <code>Not</code> are predicates. But more predicates are conceivable and useful – e.g.:</p>
<pre class="language-ts">
<code><span class="hljs-comment">/**</span></code>
<code><span class="hljs-comment"> * Is type `Target` assignable from type `Source`?</span></code>
<code><span class="hljs-comment"> */</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">TAssignable</span>&lt;<span class="hljs-title class_">Target</span>, <span class="hljs-title class_">Source</span>&gt; = [<span class="hljs-title class_">Source</span>] <span class="hljs-keyword">extends</span> [<span class="hljs-title class_">Target</span>] ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;</code>
<code/>
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">TAssignable</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-number">123</span>&gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">TAssignable</span>&lt;<span class="hljs-number">123</span>, <span class="hljs-number">123</span>&gt;&gt;,</code>
<code/>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Not</span>&lt;<span class="hljs-title class_">TAssignable</span>&lt;<span class="hljs-number">123</span>, <span class="hljs-built_in">number</span>&gt;&gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Not</span>&lt;<span class="hljs-title class_">TAssignable</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-string">'abc'</span>&gt;&gt;&gt;,</code>
<code>];</code>
</pre>
<p><code>asserttt</code> defines <a href="https://github.com/rauschma/asserttt/blob/main/src/asserttt.ts">more predicates</a>.</p>
<h3 id="asserting-errors"><a class="heading-id-link" href="#asserting-errors">39.5 Asserting errors</a></h3>
<p>Sometimes, we need to test that an error happens where we expect it. At the JavaScript level, we can use functions such as <code>assert.throws()</code>:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">throws</span>(</code>
<code>  <span class="hljs-function">() =&gt;</span> <span class="hljs-literal">null</span>.<span class="hljs-property">prop</span>,</code>
<code>  {</code>
<code>    <span class="hljs-attr">name</span>: <span class="hljs-string">'TypeError'</span>,</code>
<code>    <span class="hljs-attr">message</span>: <span class="hljs-string">"Cannot read properties of null (reading 'prop')"</span>,</code>
<code>  }</code>
<code>);</code>
</pre>
<p>At the type level, we can use <code>@ts-expect-error</code>:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// @ts-expect-error: The value 'null' cannot be used here.</span></code>
<code><span class="hljs-literal">null</span>.<span class="hljs-property">prop</span>;</code>
</pre>
<p>By default, <code>@ts-expect-error</code> only checks <em>that</em> an error exists not which error it is. To check the latter, we can use a tool such as <a href="https://www.npmjs.com/package/ts-expect-error">ts-expect-error</a>.</p>
<h4 id="a-more-complex-example"><a class="heading-id-link" href="#a-more-complex-example">39.5.1 A more complex example</a></h4>
<p>For fun, let’s compare another JavaScript-level test with its analog at the type level. This is the JavaScript code:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">upperCase</span>(<span class="hljs-params">str</span>) {</code>
<code>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> str !== str) {</code>
<code>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">'Not a string: '</span> + str);</code>
<code>  }</code>
<code>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">toUpperCase</span>();</code>
<code>}</code>
<code>assert.<span class="hljs-title function_">throws</span>(</code>
<code>  <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">upperCase</span>(<span class="hljs-number">123</span>),</code>
<code>  {</code>
<code>    <span class="hljs-attr">name</span>: <span class="hljs-string">'TypeError'</span>,</code>
<code>    <span class="hljs-attr">message</span>: <span class="hljs-string">'Not a string: 123'</span>,</code>
<code>  }</code>
<code>);</code>
</pre>
<p>For the type-level code, I’m omitting the runtime type check – even though that can often still make sense.</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">upperCase</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span></span>) {</code>
<code>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">toUpperCase</span>();</code>
<code>}</code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Argument of type 'number' is not assignable to</span></code>
<code><span class="hljs-comment">// parameter of type 'string'.</span></code>
<code><span class="hljs-title function_">upperCase</span>(<span class="hljs-number">123</span>);</code>
</pre>
<h3 id="asserting-the-type-of-a-value"><a class="heading-id-link" href="#asserting-the-type-of-a-value">39.6 Asserting the type of a value</a></h3>
<p>When testing types, we also may want to check if a value has a given type – as provided via inference or a generic type. One way of doing so is via the <code>typeof</code> operator (line A):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> pair = &lt;T&gt;(<span class="hljs-attr">x</span>: T): [T, T] =&gt; [x, x];</code>
<code><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">pair</span>(<span class="hljs-string">'a'</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>);</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-keyword">typeof</span> value, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>] <span class="hljs-comment">// (A)</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>Another option is via a helper function <code>assertType()</code>:</p>
<pre class="language-ts">
<code>assertType&lt;[<span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>]&gt;(value);</code>
</pre>
<p>Using a program-level function makes this check less verbose because we can directly accept program-level values, we don’t have to convert them to type-level values via <code>typeof</code>. This is what <code>assertType()</code> looks like:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> assertType&lt;T&gt;(<span class="hljs-attr">_value</span>: T): <span class="hljs-built_in">void</span> { }</code>
</pre>
<p>We don’t do anything with the parameter <code>_value</code>; we only statically check if it is assignable to the type parameter <code>T</code>. One limitation of <code>assertType()</code> is that it only checks assignability; it does not check type equality. For example, we can’t check that a value has the type <code>string</code> and not a more specific type:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">value_string</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">'abc'</span>;</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">value_abc</span>: <span class="hljs-string">'abc'</span> = <span class="hljs-string">'abc'</span>;</code>
<code/>
<code>assertType&lt;<span class="hljs-built_in">string</span>&gt;(value_string);</code>
<code>assertType&lt;<span class="hljs-built_in">string</span>&gt;(value_abc);</code>
</pre>
<p>In line A, the type of <code>value_abc</code> is assignable to <code>string</code> but it is not equal to <code>string</code>.</p>
<p>In contrast, <code>Equal</code> enables us to check that a value does not have a type that is more specific than <code>string</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-keyword">typeof</span> value_string, <span class="hljs-built_in">string</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Not</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-keyword">typeof</span> value_abc, <span class="hljs-built_in">string</span></code>
<code>  &gt;&gt;&gt;,</code>
<code>];</code>
</pre>
<h3 id="type-level-assertions-in-normal-code"><a class="heading-id-link" href="#type-level-assertions-in-normal-code">39.7 A use case for a type-level assertion in normal code</a></h3>
<p>Occasionally, type-level assertions are even useful in normal (non-test) code. For example, consider the following enum pattern:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-title class_">OutputFormat</span> = {</code>
<code>  <span class="hljs-attr">html</span>: <span class="hljs-string">'HTML'</span>,</code>
<code>  <span class="hljs-attr">epub</span>: <span class="hljs-string">'EPUB'</span>,</code>
<code>  <span class="hljs-attr">pdf</span>: <span class="hljs-string">'PDF'</span>,</code>
<code>} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">OutputFormatType</span> = (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">OutputFormat</span>)[keyof <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">OutputFormat</span>];</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">OutputFormatKey</span> = keyof (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">OutputFormat</span>);</code>
</pre>
<p>Let’s assume we want to use <a href="ch_validating-external-data.html#ch_validating-external-data">Zod</a> to validate a JSON property whose value is one of the keys of <code>OutputFormat</code>. Then we need an Array that we can pass to <a href="https://zod.dev/?id=zod-enums"><code>z.enum()</code></a>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">OUTPUT_FORMAT_KEYS</span> = [<span class="hljs-string">'html'</span>, <span class="hljs-string">'epub'</span>, <span class="hljs-string">'pdf'</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code>
</pre>
<p>Why don’t we create <code>OUTPUT_FORMAT_KEYS</code> via <code>Object.keys()</code>? Zod needs a tuple so that it can infer a static type.</p>
<p>To ensure that <code>OUTPUT_FORMAT_KEYS</code> is consistent with <code>OutputFormatKey</code>, we can use the following type-level assertion:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  (<span class="hljs-keyword">typeof</span> <span class="hljs-variable constant_">OUTPUT_FORMAT_KEYS</span>)[<span class="hljs-built_in">number</span>], <span class="hljs-comment">// (A)</span></code>
<code>  <span class="hljs-title class_">OutputFormatKey</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>In line A, we use an indexed access type <code>T[K]</code> to convert the Array <code>OUTPUT_FORMAT_KEYS</code> to a union of the types of its elements (<a href="ch_computing-with-tuple-types.html#from-tuple-to-union">more information</a>).</p>
<h3 id="running-type-level-tests"><a class="heading-id-link" href="#running-type-level-tests">39.8 Running type-level tests</a></h3>
<p>To run normal tests written in TypeScript, we run the transpiled JavaScript. If tests include type-level assertions, we need to additionally type check them. Two options are:</p>
<ul>
  <li>
    First run the JavaScript. Then type-check the tests via <code>tsc</code>.
  </li>
  <li>
    Run the tests via a tool such as <a href="https://tsx.is">tsx</a> that type checks code before running it.
  </li>
</ul>
<h3 id="further-reading-11"><a class="heading-id-link" href="#further-reading-11">39.9 Further reading</a></h3>
<ul>
  <li>
    Overview of various type testing approaches: 2ality blog post <a href="https://2ality.com/2022/11/testing-static-types-typescript.html">“Testing static types in TypeScript”</a>
  </li>
</ul>

    
      
</body>
</html>