- en: 22 Symbols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/impatient-js/ch_symbols.html](https://exploringjs.com/impatient-js/ch_symbols.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 22.1 [Symbols are primitives that are also like objects](ch_symbols.html#symbols-are-primitives-that-are-also-like-objects)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.1.1 [Symbols are primitive values](ch_symbols.html#symbols-are-primitive-values)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.1.2 [Symbols are also like objects](ch_symbols.html#symbols-are-also-like-objects)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.2 [The descriptions of symbols](ch_symbols.html#symbol-descriptions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.3 [Use cases for symbols](ch_symbols.html#use-cases-for-symbols)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.3.1 [Symbols as values for constants](ch_symbols.html#symbols-as-values-for-constants)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.3.2 [Symbols as unique property keys](ch_symbols.html#symbols-as-unique-property-keys)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.4 [Publicly known symbols](ch_symbols.html#publicly-known-symbols)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.5 [Converting symbols](ch_symbols.html#converting-symbols)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 22.1 Symbols are primitives that are also like objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Symbols are primitive values that are created via the factory function `Symbol()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The parameter is optional and provides a description, which is mainly useful
    for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 22.1.1 Symbols are primitive values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Symbols are primitive values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'They have to be categorized via `typeof`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'They can be property keys in objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 22.1.2 Symbols are also like objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Even though symbols are primitives, they are also like objects in that each
    value created by `Symbol()` is unique and not compared by value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Prior to symbols, objects were the best choice if we needed values that were
    unique (only equal to themselves):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 22.2 The descriptions of symbols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The parameter we pass to the symbol factory function provides a description
    for the created symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The description can be accessed in two ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it is part of the string returned by `.toString()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, since ES2019, we can retrieve the description via the property `.description`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 22.3 Use cases for symbols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main use cases for symbols, are:'
  prefs: []
  type: TYPE_NORMAL
- en: Values for constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unique property keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.3.1 Symbols as values for constants
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s assume you want to create constants representing the colors red, orange,
    yellow, green, blue, and violet. One simple way of doing so would be to use strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'On the plus side, logging that constant produces helpful output. On the minus
    side, there is a risk of mistaking an unrelated value for a color because two
    strings with the same content are considered equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can fix that problem via symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s use symbol-valued constants to implement a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 22.3.2 Symbols as unique property keys
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The keys of properties (fields) in objects are used at two levels:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The program operates at a *base level*. The keys at that level reflect the
    *problem domain* – the area in which a program solves a problem – for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a program manages employees, the property keys may be about job titles, salary
    categories, department IDs, etc.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the program is a chess app, the property keys may be about chess pieces,
    chess boards, player colors, etc.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ECMAScript and many libraries operate at a *meta-level*. They manage data and
    provide services that are not part of the problem domain – for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The standard method `.toString()` is used by ECMAScript when creating a string
    representation of an object (line A):'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`.x` and `.y` are base-level properties – they are used to solve the problem
    of computing with points. `.toString()` is a meta-level property – it doesn’t
    have anything to do with the problem domain.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The standard ECMAScript method `.toJSON()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`.x` and `.y` are base-level properties, `.toJSON()` is a meta-level property.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The base level and the meta-level of a program must be independent: Base-level
    property keys should not be in conflict with meta-level property keys.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use names (strings) as property keys, we are facing two challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: When a language is first created, it can use any meta-level names it wants.
    Base-level code is forced to avoid those names. Later, however, when much base-level
    code already exists, meta-level names can’t be chosen freely, anymore.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We could introduce naming rules to separate base level and meta-level. For
    example, Python brackets meta-level names with two underscores: `__init__`, `__iter__`,
    `__hash__`, etc. However, the meta-level names of the language and the meta-level
    names of libraries would still exist in the same namespace and can clash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are two examples of where the latter was an issue for JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: In May 2018, the Array method `.flatten()` had to be renamed to `.flat()` because
    the former name was already used by libraries ([source](https://github.com/tc39/proposal-flatMap/commit/093eacc7fe0906e70f7626bf6c7d6e9dfc53cce9)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In November 2020, the Array method `.item()` had to be renamed to `.at()` because
    the former name was already used by library ([source](https://github.com/tc39/proposal-relative-indexing-method#web-incompatibility-history)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Symbols, used as property keys, help us here: Each symbol is unique and a symbol
    key never clashes with any other string or symbol key.'
  prefs: []
  type: TYPE_NORMAL
- en: '22.3.2.1 Example: a library with a meta-level method'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As an example, let’s assume we are writing a library that treats objects differently
    if they implement a special method. This is what defining a property key for such
    a method and implementing it for an object would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The square brackets in line A enable us to specify that the method must have
    the key `specialMethod`. More details are explained in [§28.7.2 “Computed keys
    in object literals”](ch_objects.html#object-literals-computed-keys).
  prefs: []
  type: TYPE_NORMAL
- en: 22.4 Publicly known symbols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Symbols that play special roles within ECMAScript are called *publicly known
    symbols*. Examples include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Symbol.iterator`: makes an object *iterable*. It’s the key of a method that
    returns an iterator. For more information on this topic, see [§30 “Synchronous
    iteration”](ch_sync-iteration.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol.hasInstance`: customizes how `instanceof` works. If an object implements
    a method with that key, it can be used at the right-hand side of that operator.
    For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Symbol.toStringTag`: influences the default `.toString()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note: It’s usually better to override `.toString()`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercises: Publicly
    known symbols**'
  prefs: []
  type: TYPE_NORMAL
- en: '`Symbol.toStringTag`: `exercises/symbols/to_string_tag_test.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol.hasInstance`: `exercises/symbols/has_instance_test.mjs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.5 Converting symbols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What happens if we convert a symbol `sym` to another primitive type? Tbl. [15](#tbl:converting-to-symbol)
    has the answers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 15: The results of converting symbols to other primitive types.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Convert to | Explicit conversion | Coercion (implicit conv.) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| boolean | `Boolean(sym)` `→` OK | `!sym` `→` OK |'
  prefs: []
  type: TYPE_TB
- en: '| number | `Number(sym)` `→` `TypeError` | `sym*2` `→` `TypeError` |'
  prefs: []
  type: TYPE_TB
- en: '| string | `String(sym)` `→` OK | `''''+sym` `→` `TypeError` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `sym.toString()` `→` OK | ``${sym}`` `→` `TypeError` |'
  prefs: []
  type: TYPE_TB
- en: 'One key pitfall with symbols is how often exceptions are thrown when converting
    them to something else. What is the thinking behind that? First, conversion to
    number never makes sense and should be warned about. Second, converting a symbol
    to a string is indeed useful for diagnostic output. But it also makes sense to
    warn about accidentally turning a symbol into a string (which is a different kind
    of property key):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The downside is that the exceptions make working with symbols more complicated.
    You have to explicitly convert symbols when assembling strings via the plus operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz**'
  prefs: []
  type: TYPE_NORMAL
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  prefs: []
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/15)'
  prefs: []
  type: TYPE_NORMAL
