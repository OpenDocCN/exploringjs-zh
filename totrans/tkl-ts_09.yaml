- en: 7 The essentials of TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/tackling-ts/ch_typescript-essentials.html](https://exploringjs.com/tackling-ts/ch_typescript-essentials.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 7.1 [What you’ll learn](ch_typescript-essentials.html#what-youll-learn)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.2 [Specifying the comprehensiveness of type checking](ch_typescript-essentials.html#specifying-the-comprehensiveness-of-type-checking)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.3 [Types in TypeScript](ch_typescript-essentials.html#types-in-typescript)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.4 [Type annotations](ch_typescript-essentials.html#type-annotations)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.5 [Type inference](ch_typescript-essentials.html#type-inference)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.6 [Specifying types via type expressions](ch_typescript-essentials.html#specifying-types-via-type-expressions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '7.7 [The two language levels: dynamic vs. static](ch_typescript-essentials.html#language-levels)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.8 [Type aliases](ch_typescript-essentials.html#type-aliases)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.9 [Typing Arrays](ch_typescript-essentials.html#typing-arrays)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.9.1 [Arrays as lists](ch_typescript-essentials.html#arrays-as-lists)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.9.2 [Arrays as tuples](ch_typescript-essentials.html#arrays-as-tuples)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.10 [Function types](ch_typescript-essentials.html#function-types)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.10.1 [A more complicated example](ch_typescript-essentials.html#a-more-complicated-example)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.10.2 [Return types of function declarations](ch_typescript-essentials.html#return-types-of-function-declarations)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.10.3 [Optional parameters](ch_typescript-essentials.html#optional-parameters)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.10.4 [Rest parameters](ch_typescript-essentials.html#rest-parameters)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.11 [Union types](ch_typescript-essentials.html#union-types)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.11.1 [By default, `undefined` and `null` are not included in types](ch_typescript-essentials.html#by-default-undefined-and-null-are-not-included-in-types)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.11.2 [Making omissions explicit](ch_typescript-essentials.html#making-omissions-explicit)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.12 [Optional vs. default value vs. `undefined|T`](ch_typescript-essentials.html#optional-vs.-default-value-vs.-undefinedt)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.13 [Typing objects](ch_typescript-essentials.html#typing-objects)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.13.1 [Typing objects-as-records via interfaces](ch_typescript-essentials.html#typing-objects-as-records-via-interfaces)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.13.2 [TypeScript’s structural typing vs. nominal typing](ch_typescript-essentials.html#typescripts-structural-typing-vs.-nominal-typing)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.13.3 [Object literal types](ch_typescript-essentials.html#object-literal-types)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.13.4 [Optional properties](ch_typescript-essentials.html#optional-properties)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.13.5 [Methods](ch_typescript-essentials.html#methods)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.14 [Type variables and generic types](ch_typescript-essentials.html#type-variables-and-generic-types)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '7.14.1 [Example: a container for values](ch_typescript-essentials.html#example-a-container-for-values)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '7.15 [Example: a generic class](ch_typescript-essentials.html#example-a-generic-class)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '7.15.1 [Example: Maps](ch_typescript-essentials.html#example-maps)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.15.2 [Type variables for functions and methods](ch_typescript-essentials.html#type-variables-for-functions-and-methods)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.15.3 [A more complicated function example](ch_typescript-essentials.html#a-more-complicated-function-example)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '7.16 [Conclusion: understanding the initial example](ch_typescript-essentials.html#conclusion-understanding-the-initial-example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explains the essentials of TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1 What you’ll learn
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After reading this chapter, you should be able to understand the following
    TypeScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You may think that this is cryptic. And I agree with you! But (as I hope to
    prove) this syntax is relatively easy to learn. And once you understand it, it
    gives you immediate, precise and comprehensive summaries of how code behaves –
    without having to read long descriptions in English.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2 Specifying the comprehensiveness of type checking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many ways in which the TypeScript compiler can be configured. One
    important group of options controls how thoroughly the compiler checks TypeScript
    code. The maximum setting is activated via `--strict` and I recommend to always
    use it. It makes programs slightly harder to write, but we also gain the full
    benefits of static type checking.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/65d35c0a2478236e12cc4321e1b02db6.png)  **That’s everything about
    `--strict` you need to know for now**'
  prefs: []
  type: TYPE_NORMAL
- en: Read on if you want to know more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting `--strict` to `true`, sets all of the following options to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--noImplicitAny`: If TypeScript can’t infer a type, we must specify it. This
    mainly applies to parameters of functions and methods: With this settings, we
    must annotate them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--noImplicitThis`: Complain if the type of `this` isn’t clear.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--alwaysStrict`: Use JavaScript’s strict mode whenever possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--strictNullChecks`: `null` is not part of any type (other than its own type,
    `null`) and must be explicitly mentioned if it is a acceptable value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--strictFunctionTypes`: enables stronger checks for function types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--strictPropertyInitialization`: Properties in class definitions must be initialized,
    unless they can have the value `undefined`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will see more compiler options later in this book, when we get to creating
    [npm packages](ch_npm-cjs-typescript.html) and [web apps](ch_webpack-typescript.html)
    with TypeScript. The TypeScript handbook has [comprehensive documentation](https://www.typescriptlang.org/docs/handbook/compiler-options.html)
    on them.
  prefs: []
  type: TYPE_NORMAL
- en: 7.3 Types in TypeScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, a type is simply a set of values. The JavaScript language
    (not TypeScript!) has only eight types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Undefined: the set with the only element `undefined`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Null: the set with the only element `null`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Boolean: the set with the two elements `false` and `true`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Number: the set of all numbers'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'BigInt: the set of all arbitrary-precision integers'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'String: the set of all strings'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Symbol: the set of all symbols'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Object: the set of all objects (which includes functions and arrays)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All of these types are *dynamic*: we can use them at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript brings an additional layer to JavaScript: *static types*. These
    only exist when compiling or type-checking source code. Each storage location
    (variable, property, etc.) has a static type that predicts its dynamic values.
    Type checking ensures that these predictions come true.'
  prefs: []
  type: TYPE_NORMAL
- en: And there is a lot that can be checked *statically* (without running the code).
    If, for example the parameter `num` of a function `toString(num)` has the static
    type `number`, then the function call `toString('abc')` is illegal, because the
    argument `'abc'` has the wrong static type.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4 Type annotations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two type annotations in the previous function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameter `num`: colon followed by `number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Result of `toString()`: colon followed by `string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both `number` and `string` are *type expressions* that specify the types of
    storage locations.
  prefs: []
  type: TYPE_NORMAL
- en: 7.5 Type inference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Often, TypeScript can *infer* a static type if there is no type annotation.
    For example, if we omit the return type of `toString()`, TypeScript infers that
    it is `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Type inference is not guesswork: It follows clear rules (similar to arithmetic)
    for deriving types where they haven’t been specified explicitly. In this case,
    the return statement applies a function `String()` that maps arbitrary values
    to strings, to a value `num` of type `number` and returns the result. That’s why
    the inferred return type is `string`.'
  prefs: []
  type: TYPE_NORMAL
- en: If the type of a location is neither explicitly specified nor inferrable, TypeScript
    uses the type `any` for it. This is the type of all values and a wildcard, in
    that we can do everything if a value has that type.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `--strict`, `any` is only allowed if we use it explicitly. In other words:
    Every location must have an explicit or inferred static type. In the following
    example, parameter `num` has neither and we get a compile-time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 7.6 Specifying types via type expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The type expressions after the colons of type annotations range from simple
    to complex and are created as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basic types are valid type expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Static types for JavaScript’s dynamic types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`undefined`, `null`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean`, `number`, `bigint`, `string`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symbol`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TypeScript-specific types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array` (not technically a type in JavaScript)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`any` (the type of all values)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Etc.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many ways of combining basic types to produce new, *compound types*.
    For example, via *type operators* that combine types similarly to how the set
    operators *union* (`∪`) and *intersection* (`∩`) combine sets. We’ll see how to
    do that soon.
  prefs: []
  type: TYPE_NORMAL
- en: '7.7 The two language levels: dynamic vs. static'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'TypeScript has two language levels:'
  prefs: []
  type: TYPE_NORMAL
- en: The *dynamic level* is managed by JavaScript and consists of code and values,
    at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *static level* is managed by TypeScript (excluding JavaScript) and consists
    of static types, at compile time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see these two levels in the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At the dynamic level, we use JavaScript to declare a variable `undef` and initialize
    it with the value `undefined`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the static level, we use TypeScript to specify that variable `undef` has
    the static type `undefined`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the same syntax, `undefined`, means different things depending on
    whether it is used at the dynamic level or at the static level.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6a9318e9b4540abb73475976e01d55f9.png)  **Try to develop an awareness
    of the two language levels**'
  prefs: []
  type: TYPE_NORMAL
- en: That helps considerably with making sense of TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 7.8 Type aliases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With `type` we can create a new name (an alias) for an existing type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 7.9 Typing Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Arrays play two roles in JavaScript (either one or both):'
  prefs: []
  type: TYPE_NORMAL
- en: 'List: All elements have the same type. The length of the Array varies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tuple: The length of the Array is fixed. The elements generally don’t have
    the same type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.9.1 Arrays as lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two ways to express the fact that the Array `arr` is used as a list
    whose elements are all numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Normally, TypeScript can infer the type of a variable if there is an assignment.
    In this case, we actually have to help it, because with an empty Array, it can’t
    determine the type of the elements.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll get back to the angle brackets notation (`Array<number>`) later.
  prefs: []
  type: TYPE_NORMAL
- en: 7.9.2 Arrays as tuples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we store a two-dimensional point in an Array, then we are using that Array
    as a tuple. That looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The type annotation is needed for Arrays-as-tuples because, for Array literals,
    TypeScript infers list types, not tuple types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example for tuples is the result of `Object.entries(obj)`: an Array
    with one [key, value] pair for each property of `obj`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The inferred type is an Array of tuples.
  prefs: []
  type: TYPE_NORMAL
- en: 7.10 Function types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is an example of a function type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This type comprises every function that accepts a single parameter of type
    number and return a string. Let’s use this type in a type annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, we must specify parameter types for functions. But in this case,
    the type of `num` in line B can be inferred from the function type in line A and
    we can omit it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we omit the type annotation for `toString`, TypeScript infers a type from
    the arrow function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This time, `num` must have a type annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 7.10.1 A more complicated example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following example is more complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We are using a function type to describe the parameter `callback` of `stringify123()`.
    Due to this type annotation, TypeScript rejects the following function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'But it accepts this function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 7.10.2 Return types of function declarations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TypeScript can usually infer the return types of functions, but specifying them
    explicitly is allowed and occasionally useful (at the very least, it doesn’t do
    any harm).
  prefs: []
  type: TYPE_NORMAL
- en: 'For `stringify123()`, specifying a return type is optional and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 7.10.2.1 The special return type `void`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`void` is a special return type for a function: It tells TypeScript that the
    function always returns `undefined`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It may do so explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Or it may do so implicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'However, such a function cannot explicitly return values other than `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 7.10.3 Optional parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A question mark after an identifier means that the parameter is optional. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript only lets us make the function call in line A if we make sure that
    `callback` isn’t `undefined` (which it is if the parameter was omitted).
  prefs: []
  type: TYPE_NORMAL
- en: 7.10.3.1 Parameter default values
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'TypeScript supports [parameter default values](https://exploringjs.com/impatient-js/ch_callables.html#parameter-default-values):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Default values make parameters optional. We can usually omit type annotations,
    because TypeScript can infer the types. For example, it can infer that `x` and
    `y` both have the type `number`.
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to add type annotations, that would look as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 7.10.4 Rest parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can also use [rest parameters](https://exploringjs.com/impatient-js/ch_callables.html#rest-parameters)
    in TypeScript parameter definitions. Their static types must be Arrays (lists
    or tuples):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 7.11 Union types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The values that are held by a variable (one value at a time) may be members
    of different types. In that case, we need a *union type*. For example, in the
    following code, `stringOrNumber` is either of type `string` or of type `number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`stringOrNumber` has the type `string|number`. The result of the type expression
    `s|t` is the set-theoretic union of the types `s` and `t` (interpreted as sets).'
  prefs: []
  type: TYPE_NORMAL
- en: 7.11.1 By default, `undefined` and `null` are not included in types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In many programming languages, `null` is part of all object types. For example,
    whenever the type of a variable is `String` in Java, we can set it to `null` and
    Java won’t complain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, in TypeScript, `undefined` and `null` are handled by separate,
    disjoint types. We need union types such as `undefined|string` and `null|string`,
    if we want to allow them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that TypeScript does not force us to initialize immediately (as long as
    we don’t read from the variable before initializing it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 7.11.2 Making omissions explicit
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Recall this function from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s rewrite `stringify123()` so that parameter `callback` isn’t optional
    anymore: If a caller doesn’t want to provide a function, they must explicitly
    pass `null`. The result looks as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we have to handle the case of `callback` not being a function (line
    A) before we can make the function call in line B. If we hadn’t done so, TypeScript
    would have reported an error in that line.
  prefs: []
  type: TYPE_NORMAL
- en: 7.12 Optional vs. default value vs. `undefined|T`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following three parameter declarations are quite similar:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameter is optional: `x?: number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameter has a default value: `x = 456`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameter has a union type: `x: undefined | number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the parameter is optional, it can be omitted. In that case, it has the value
    `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If the parameter has a default value, that value is used when the parameter
    is either omitted or set to `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If the parameter has a union type, it can’t be omitted, but we can set it to
    `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 7.13 Typing objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similarly to Arrays, objects play two roles in JavaScript (that are occasionally
    mixed):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Records: A fixed number of properties that are known at development time. Each
    property can have a different type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dictionaries: An arbitrary number of properties whose names are not known at
    development time. All properties have the same type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are ignoring objects-as-dictionaries in this chapter – they are covered
    in [§15.4.5 “Index signatures: objects as dicts”](ch_typing-objects.html#index-signatures).
    As an aside, Maps are usually a better choice for dictionaries, anyway.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.13.1 Typing objects-as-records via interfaces
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Interfaces describe objects-as-records. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also separate members via commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 7.13.2 TypeScript’s structural typing vs. nominal typing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One big advantage of TypeScript’s type system is that it works *structurally*,
    not *nominally*. That is, interface `Point` matches all objects that have the
    appropriate structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Conversely, in Java’s nominal type system, we must explicitly declare with each
    class which interfaces it implements. Therefore, a class can only implement interfaces
    that exist at its creation time.
  prefs: []
  type: TYPE_NORMAL
- en: 7.13.3 Object literal types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Object literal types* are anonymous interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'One benefit of object literal types is that they can be used inline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 7.13.4 Optional properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a property can be omitted, we put a question mark after its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, both `john` and `jane` match the interface `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 7.13.5 Methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Interfaces can also contain methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As far as TypeScript’s type system is concerned, method definitions and properties
    whose values are functions, are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: My recommendation is to use whichever syntax best expresses how a property should
    be set up.
  prefs: []
  type: TYPE_NORMAL
- en: 7.14 Type variables and generic types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recall [the two language levels of TypeScript](ch_typescript-essentials.html#language-levels):'
  prefs: []
  type: TYPE_NORMAL
- en: Values exist at the *dynamic level*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types exist at the *static level*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Normal functions exist at the dynamic level, are factories for values and have
    parameters representing values. Parameters are declared between parentheses:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Generic types* exist at the static level, are factories for types and have
    parameters representing types. Parameters are declared between angle brackets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![](../Images/6a9318e9b4540abb73475976e01d55f9.png)  **Naming type parameters**'
  prefs: []
  type: TYPE_NORMAL
- en: In TypeScript, it is common to use a single uppercase character (such as `T`,
    `I`, and `O`) for a type parameter. However, any legal JavaScript identifier is
    allowed and longer names often make code easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: '7.14.1 Example: a container for values'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`Value` is a *type variable*. One or more type variables can be introduced
    between angle brackets.'
  prefs: []
  type: TYPE_NORMAL
- en: '7.15 Example: a generic class'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Classes can have type parameters, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Class `SimpleStack` has the type parameter `Elem`. When we instantiate the
    class, we also provide a value for the type parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '7.15.1 Example: Maps'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Maps are typed generically in TypeScript. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to type inference (based on the argument of `new Map()`), we can omit
    the type parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 7.15.2 Type variables for functions and methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Function definitions can introduce type variables like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We use the function as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to type inference, we can once again omit the type parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that TypeScript inferred the type `123`, which is a set with one number
    and more specific than the type `number`.
  prefs: []
  type: TYPE_NORMAL
- en: 7.15.2.1 Arrow functions and methods
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Arrow functions can also have type parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the type parameter syntax for methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 7.15.3 A more complicated function example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The type variable `T` appears four times in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: It is introduced via `fillArray<T>`. Therefore, its scope is the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is used for the first time in the type annotation for the parameter `elem`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is used for the second second time to specify the return type of `fillArray()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also used as a type argument for the constructor `Array()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can omit the type parameter when calling `fillArray()` (line A) because
    TypeScript can infer `T` from the parameter `elem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '7.16 Conclusion: understanding the initial example'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s use what we have learned to understand the piece of code we have seen
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an interface for Arrays whose elements are of type `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: method `.concat()` has zero or more parameters (defined via a rest parameter).
    Each of those parameters has the type `T[]|T`. That is, it is either an Array
    of `T` values or a single `T` value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'method `.reduce()` introduces its own type variable `U`. `U` is used to express
    the fact that the following entities all have the same type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameter `state` of `callback()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Result of `callback()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional parameter `firstState` of `.reduce()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Result of `.reduce()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to `state`, `callback()` has the following parameters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`element`, which has the same type `T` as the Array elements'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index`; a number'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array` with elements of type `T`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/tackling-ts/issues/7)'
  prefs: []
  type: TYPE_NORMAL
