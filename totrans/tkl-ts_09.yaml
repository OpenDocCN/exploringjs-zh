- en: 7 The essentials of TypeScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 TypeScript的基本要点
- en: 原文：[https://exploringjs.com/tackling-ts/ch_typescript-essentials.html](https://exploringjs.com/tackling-ts/ch_typescript-essentials.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/tackling-ts/ch_typescript-essentials.html](https://exploringjs.com/tackling-ts/ch_typescript-essentials.html)
- en: '* * *'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 7.1 [What you’ll learn](ch_typescript-essentials.html#what-youll-learn)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.1 [你将学到什么](ch_typescript-essentials.html#what-youll-learn)
- en: 7.2 [Specifying the comprehensiveness of type checking](ch_typescript-essentials.html#specifying-the-comprehensiveness-of-type-checking)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.2 [指定类型检查的全面性](ch_typescript-essentials.html#specifying-the-comprehensiveness-of-type-checking)
- en: 7.3 [Types in TypeScript](ch_typescript-essentials.html#types-in-typescript)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.3 [TypeScript中的类型](ch_typescript-essentials.html#types-in-typescript)
- en: 7.4 [Type annotations](ch_typescript-essentials.html#type-annotations)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.4 [类型注解](ch_typescript-essentials.html#type-annotations)
- en: 7.5 [Type inference](ch_typescript-essentials.html#type-inference)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.5 [类型推断](ch_typescript-essentials.html#type-inference)
- en: 7.6 [Specifying types via type expressions](ch_typescript-essentials.html#specifying-types-via-type-expressions)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.6 [通过类型表达式指定类型](ch_typescript-essentials.html#specifying-types-via-type-expressions)
- en: '7.7 [The two language levels: dynamic vs. static](ch_typescript-essentials.html#language-levels)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.7 [两种语言级别：动态 vs. 静态](ch_typescript-essentials.html#language-levels)
- en: 7.8 [Type aliases](ch_typescript-essentials.html#type-aliases)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.8 [类型别名](ch_typescript-essentials.html#type-aliases)
- en: 7.9 [Typing Arrays](ch_typescript-essentials.html#typing-arrays)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.9 [数组类型标注](ch_typescript-essentials.html#typing-arrays)
- en: 7.9.1 [Arrays as lists](ch_typescript-essentials.html#arrays-as-lists)
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.9.1 [数组作为列表](ch_typescript-essentials.html#arrays-as-lists)
- en: 7.9.2 [Arrays as tuples](ch_typescript-essentials.html#arrays-as-tuples)
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.9.2 [数组作为元组](ch_typescript-essentials.html#arrays-as-tuples)
- en: 7.10 [Function types](ch_typescript-essentials.html#function-types)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.10 [函数类型](ch_typescript-essentials.html#function-types)
- en: 7.10.1 [A more complicated example](ch_typescript-essentials.html#a-more-complicated-example)
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.10.1 [更复杂的示例](ch_typescript-essentials.html#a-more-complicated-example)
- en: 7.10.2 [Return types of function declarations](ch_typescript-essentials.html#return-types-of-function-declarations)
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.10.2 [函数声明的返回类型](ch_typescript-essentials.html#return-types-of-function-declarations)
- en: 7.10.3 [Optional parameters](ch_typescript-essentials.html#optional-parameters)
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.10.3 [可选参数](ch_typescript-essentials.html#optional-parameters)
- en: 7.10.4 [Rest parameters](ch_typescript-essentials.html#rest-parameters)
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.10.4 [剩余参数](ch_typescript-essentials.html#rest-parameters)
- en: 7.11 [Union types](ch_typescript-essentials.html#union-types)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.11 [联合类型](ch_typescript-essentials.html#union-types)
- en: 7.11.1 [By default, `undefined` and `null` are not included in types](ch_typescript-essentials.html#by-default-undefined-and-null-are-not-included-in-types)
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.11.1 [默认情况下，`undefined`和`null`不包括在类型中](ch_typescript-essentials.html#by-default-undefined-and-null-are-not-included-in-types)
- en: 7.11.2 [Making omissions explicit](ch_typescript-essentials.html#making-omissions-explicit)
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.11.2 [明确省略](ch_typescript-essentials.html#making-omissions-explicit)
- en: 7.12 [Optional vs. default value vs. `undefined|T`](ch_typescript-essentials.html#optional-vs.-default-value-vs.-undefinedt)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.12 [可选 vs. 默认值 vs. `undefined|T`](ch_typescript-essentials.html#optional-vs.-default-value-vs.-undefinedt)
- en: 7.13 [Typing objects](ch_typescript-essentials.html#typing-objects)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.13 [对象类型标注](ch_typescript-essentials.html#typing-objects)
- en: 7.13.1 [Typing objects-as-records via interfaces](ch_typescript-essentials.html#typing-objects-as-records-via-interfaces)
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.13.1 [通过接口将对象作为记录进行类型标注](ch_typescript-essentials.html#typing-objects-as-records-via-interfaces)
- en: 7.13.2 [TypeScript’s structural typing vs. nominal typing](ch_typescript-essentials.html#typescripts-structural-typing-vs.-nominal-typing)
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.13.2 [TypeScript的结构类型 vs. 名义类型](ch_typescript-essentials.html#typescripts-structural-typing-vs.-nominal-typing)
- en: 7.13.3 [Object literal types](ch_typescript-essentials.html#object-literal-types)
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.13.3 [对象字面量类型](ch_typescript-essentials.html#object-literal-types)
- en: 7.13.4 [Optional properties](ch_typescript-essentials.html#optional-properties)
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.13.4 [可选属性](ch_typescript-essentials.html#optional-properties)
- en: 7.13.5 [Methods](ch_typescript-essentials.html#methods)
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.13.5 [方法](ch_typescript-essentials.html#methods)
- en: 7.14 [Type variables and generic types](ch_typescript-essentials.html#type-variables-and-generic-types)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.14 [类型变量和泛型类型](ch_typescript-essentials.html#type-variables-and-generic-types)
- en: '7.14.1 [Example: a container for values](ch_typescript-essentials.html#example-a-container-for-values)'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.14.1 [示例：值的容器](ch_typescript-essentials.html#example-a-container-for-values)
- en: '7.15 [Example: a generic class](ch_typescript-essentials.html#example-a-generic-class)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.15 [示例：泛型类](ch_typescript-essentials.html#example-a-generic-class)
- en: '7.15.1 [Example: Maps](ch_typescript-essentials.html#example-maps)'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.15.1 [示例：映射](ch_typescript-essentials.html#example-maps)
- en: 7.15.2 [Type variables for functions and methods](ch_typescript-essentials.html#type-variables-for-functions-and-methods)
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.15.2 [函数和方法的类型变量](ch_typescript-essentials.html#type-variables-for-functions-and-methods)
- en: 7.15.3 [A more complicated function example](ch_typescript-essentials.html#a-more-complicated-function-example)
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.15.3 [更复杂的函数示例](ch_typescript-essentials.html#a-more-complicated-function-example)
- en: '7.16 [Conclusion: understanding the initial example](ch_typescript-essentials.html#conclusion-understanding-the-initial-example)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.16 [结论：理解初始示例](ch_typescript-essentials.html#conclusion-understanding-the-initial-example)
- en: '* * *'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: This chapter explains the essentials of TypeScript.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了TypeScript的基本要点。
- en: 7.1 What you’ll learn
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1 你将学到什么
- en: 'After reading this chapter, you should be able to understand the following
    TypeScript code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，你应该能够理解以下TypeScript代码：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You may think that this is cryptic. And I agree with you! But (as I hope to
    prove) this syntax is relatively easy to learn. And once you understand it, it
    gives you immediate, precise and comprehensive summaries of how code behaves –
    without having to read long descriptions in English.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这很神秘。我同意你的看法！但是（正如我希望证明的那样），这种语法相对容易学习。一旦你理解了它，它可以立即、准确和全面地总结代码的行为方式，而无需阅读冗长的英文描述。
- en: 7.2 Specifying the comprehensiveness of type checking
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2 指定类型检查的全面性
- en: There are many ways in which the TypeScript compiler can be configured. One
    important group of options controls how thoroughly the compiler checks TypeScript
    code. The maximum setting is activated via `--strict` and I recommend to always
    use it. It makes programs slightly harder to write, but we also gain the full
    benefits of static type checking.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器可以配置的方式有很多。一个重要的选项组控制编译器对TypeScript代码的检查程度。通过`--strict`激活最大设置，我建议始终使用它。这使得程序稍微难以编写，但我们也获得了静态类型检查的全部好处。
- en: '![](../Images/65d35c0a2478236e12cc4321e1b02db6.png)  **That’s everything about
    `--strict` you need to know for now**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/65d35c0a2478236e12cc4321e1b02db6.png) **这就是你现在需要了解的关于`--strict`的一切**'
- en: Read on if you want to know more details.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果想了解更多细节，请继续阅读。
- en: 'Setting `--strict` to `true`, sets all of the following options to `true`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将`--strict`设置为`true`，会将以下所有选项设置为`true`：
- en: '`--noImplicitAny`: If TypeScript can’t infer a type, we must specify it. This
    mainly applies to parameters of functions and methods: With this settings, we
    must annotate them.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--noImplicitAny`：如果TypeScript无法推断类型，我们必须指定类型。这主要适用于函数和方法的参数：使用这个设置，我们必须注释它们。'
- en: '`--noImplicitThis`: Complain if the type of `this` isn’t clear.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--noImplicitThis`：如果`this`的类型不清晰，则会报错。'
- en: '`--alwaysStrict`: Use JavaScript’s strict mode whenever possible.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--alwaysStrict`：尽可能使用JavaScript的严格模式。'
- en: '`--strictNullChecks`: `null` is not part of any type (other than its own type,
    `null`) and must be explicitly mentioned if it is a acceptable value.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--strictNullChecks`：`null`不是任何类型的一部分（除了它自己的类型`null`），如果它是可接受的值，必须明确提及。'
- en: '`--strictFunctionTypes`: enables stronger checks for function types.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--strictFunctionTypes`：启用对函数类型的更严格检查。'
- en: '`--strictPropertyInitialization`: Properties in class definitions must be initialized,
    unless they can have the value `undefined`.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--strictPropertyInitialization`：类定义中的属性必须初始化，除非它们可以有值`undefined`。'
- en: We will see more compiler options later in this book, when we get to creating
    [npm packages](ch_npm-cjs-typescript.html) and [web apps](ch_webpack-typescript.html)
    with TypeScript. The TypeScript handbook has [comprehensive documentation](https://www.typescriptlang.org/docs/handbook/compiler-options.html)
    on them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面看到更多的编译器选项，当我们开始使用TypeScript创建[npm包](ch_npm-cjs-typescript.html)和[web应用](ch_webpack-typescript.html)时。TypeScript手册中有关于它们的[全面文档](https://www.typescriptlang.org/docs/handbook/compiler-options.html)。
- en: 7.3 Types in TypeScript
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3 TypeScript中的类型
- en: 'In this chapter, a type is simply a set of values. The JavaScript language
    (not TypeScript!) has only eight types:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，类型只是一组值。JavaScript语言（不是TypeScript！）只有八种类型：
- en: 'Undefined: the set with the only element `undefined`'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 未定义：只有一个元素`undefined`的集合
- en: 'Null: the set with the only element `null`'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Null：只有一个元素`null`的集合
- en: 'Boolean: the set with the two elements `false` and `true`'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布尔：只有两个元素`false`和`true`的集合
- en: 'Number: the set of all numbers'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数字：所有数字的集合
- en: 'BigInt: the set of all arbitrary-precision integers'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BigInt：所有任意精度整数的集合
- en: 'String: the set of all strings'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符串：所有字符串的集合
- en: 'Symbol: the set of all symbols'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 符号：所有符号的集合
- en: 'Object: the set of all objects (which includes functions and arrays)'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象：所有对象的集合（包括函数和数组）
- en: 'All of these types are *dynamic*: we can use them at runtime.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些类型都是*动态*的：我们可以在运行时使用它们。
- en: 'TypeScript brings an additional layer to JavaScript: *static types*. These
    only exist when compiling or type-checking source code. Each storage location
    (variable, property, etc.) has a static type that predicts its dynamic values.
    Type checking ensures that these predictions come true.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript为JavaScript带来了一个额外的层次：*静态类型*。这些只在编译或类型检查源代码时存在。每个存储位置（变量、属性等）都有一个静态类型，用于预测其动态值。类型检查确保这些预测成真。
- en: And there is a lot that can be checked *statically* (without running the code).
    If, for example the parameter `num` of a function `toString(num)` has the static
    type `number`, then the function call `toString('abc')` is illegal, because the
    argument `'abc'` has the wrong static type.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多可以*静态*检查的内容（不运行代码）。例如，如果函数`toString(num)`的参数`num`的静态类型是`number`，那么函数调用`toString('abc')`是非法的，因为参数`'abc'`的静态类型错误。
- en: 7.4 Type annotations
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4 类型注释
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are two type annotations in the previous function declaration:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个函数声明中有两种类型注释：
- en: 'Parameter `num`: colon followed by `number`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数`num`：冒号后跟`number`
- en: 'Result of `toString()`: colon followed by `string`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toString()`的结果：冒号后跟`string`'
- en: Both `number` and `string` are *type expressions* that specify the types of
    storage locations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`number`和`string`都是*类型表达式*，用于指定存储位置的类型。'
- en: 7.5 Type inference
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5 类型推断
- en: 'Often, TypeScript can *infer* a static type if there is no type annotation.
    For example, if we omit the return type of `toString()`, TypeScript infers that
    it is `string`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果没有类型注释，TypeScript可以*推断*出静态类型。例如，如果我们省略`toString()`的返回类型，TypeScript会推断它是`string`：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Type inference is not guesswork: It follows clear rules (similar to arithmetic)
    for deriving types where they haven’t been specified explicitly. In this case,
    the return statement applies a function `String()` that maps arbitrary values
    to strings, to a value `num` of type `number` and returns the result. That’s why
    the inferred return type is `string`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断不是猜测：它遵循清晰的规则（类似于算术）来推导未明确指定类型的地方的类型。在这种情况下，返回语句应用了一个将任意值映射到字符串的函数`String()`，将类型为`number`的值`num`映射到字符串并返回结果。这就是为什么推断的返回类型是`string`。
- en: If the type of a location is neither explicitly specified nor inferrable, TypeScript
    uses the type `any` for it. This is the type of all values and a wildcard, in
    that we can do everything if a value has that type.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果位置的类型既没有明确指定也无法推断，TypeScript会使用类型`any`。这是所有值的类型和通配符，如果一个值具有该类型，我们可以做任何事情。
- en: 'With `--strict`, `any` is only allowed if we use it explicitly. In other words:
    Every location must have an explicit or inferred static type. In the following
    example, parameter `num` has neither and we get a compile-time error:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在`--strict`中，只有在显式使用`any`时才允许使用它。换句话说：每个位置必须有一个显式或推断的静态类型。在下面的例子中，参数`num`都没有，我们会得到一个编译时错误：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 7.6 Specifying types via type expressions
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6 通过类型表达式指定类型
- en: The type expressions after the colons of type annotations range from simple
    to complex and are created as follows.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注解的冒号后面的类型表达式从简单到复杂不等，创建方式如下。
- en: 'Basic types are valid type expressions:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 基本类型是有效的类型表达式：
- en: 'Static types for JavaScript’s dynamic types:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript的动态类型的静态类型：
- en: '`undefined`, `null`'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`，`null`'
- en: '`boolean`, `number`, `bigint`, `string`'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean`，`number`，`bigint`，`string`'
- en: '`symbol`'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symbol`'
- en: '`object`.'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object`。'
- en: 'TypeScript-specific types:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定于TypeScript的类型：
- en: '`Array` (not technically a type in JavaScript)'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array`（在JavaScript中不是严格的类型）'
- en: '`any` (the type of all values)'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any`（所有值的类型）'
- en: Etc.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等等。
- en: There are many ways of combining basic types to produce new, *compound types*.
    For example, via *type operators* that combine types similarly to how the set
    operators *union* (`∪`) and *intersection* (`∩`) combine sets. We’ll see how to
    do that soon.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多种方式将基本类型组合成新的*复合类型*。例如，通过*类型运算符*，它们类似于集合运算符*并集*（`∪`）和*交集*（`∩`）组合集合的方式。我们很快会看到如何做到这一点。
- en: '7.7 The two language levels: dynamic vs. static'
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7 两种语言级别：动态 vs. 静态
- en: 'TypeScript has two language levels:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript有两种语言级别：
- en: The *dynamic level* is managed by JavaScript and consists of code and values,
    at runtime.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动态级别*由JavaScript管理，并且包括运行时的代码和值。'
- en: The *static level* is managed by TypeScript (excluding JavaScript) and consists
    of static types, at compile time.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*静态级别*由TypeScript（不包括JavaScript）管理，并且在编译时包括静态类型。'
- en: 'We can see these two levels in the syntax:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在语法中看到这两个级别：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At the dynamic level, we use JavaScript to declare a variable `undef` and initialize
    it with the value `undefined`.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在动态级别上，我们使用JavaScript声明一个变量`undef`并用值`undefined`初始化它。
- en: At the static level, we use TypeScript to specify that variable `undef` has
    the static type `undefined`.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在静态级别上，我们使用TypeScript指定变量`undef`的静态类型为`undefined`。
- en: Note that the same syntax, `undefined`, means different things depending on
    whether it is used at the dynamic level or at the static level.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，相同的语法`undefined`，根据它是在动态级别还是静态级别使用，意思不同。
- en: '![](../Images/6a9318e9b4540abb73475976e01d55f9.png)  **Try to develop an awareness
    of the two language levels**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/6a9318e9b4540abb73475976e01d55f9.png) 尝试培养对两种语言级别的认识'
- en: That helps considerably with making sense of TypeScript.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这在很大程度上有助于理解TypeScript。
- en: 7.8 Type aliases
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.8 类型别名
- en: 'With `type` we can create a new name (an alias) for an existing type:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`type`我们可以为现有类型创建一个新名称（别名）：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 7.9 Typing Arrays
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.9 数组的类型
- en: 'Arrays play two roles in JavaScript (either one or both):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 数组在JavaScript中扮演两种角色（可能是一种或两种）：
- en: 'List: All elements have the same type. The length of the Array varies.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表：所有元素具有相同的类型。数组的长度不同。
- en: 'Tuple: The length of the Array is fixed. The elements generally don’t have
    the same type.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组：数组的长度是固定的。元素通常不具有相同的类型。
- en: 7.9.1 Arrays as lists
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.9.1 数组作为列表
- en: 'There are two ways to express the fact that the Array `arr` is used as a list
    whose elements are all numbers:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式来表达数组`arr`被用作一个所有元素都是数字的列表的事实：
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Normally, TypeScript can infer the type of a variable if there is an assignment.
    In this case, we actually have to help it, because with an empty Array, it can’t
    determine the type of the elements.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，如果有赋值，TypeScript可以推断变量的类型。在这种情况下，我们实际上必须帮助它，因为对于空数组，它无法确定元素的类型。
- en: We’ll get back to the angle brackets notation (`Array<number>`) later.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们会回到尖括号表示法（`Array<number>`）。
- en: 7.9.2 Arrays as tuples
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.9.2 数组作为元组
- en: 'If we store a two-dimensional point in an Array, then we are using that Array
    as a tuple. That looks as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将二维点存储在一个数组中，那么我们使用该数组作为元组。看起来是这样的：
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The type annotation is needed for Arrays-as-tuples because, for Array literals,
    TypeScript infers list types, not tuple types:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组字面量，类型注解是必需的，因为TypeScript会推断列表类型，而不是元组类型：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Another example for tuples is the result of `Object.entries(obj)`: an Array
    with one [key, value] pair for each property of `obj`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的另一个例子是`Object.entries(obj)`的结果：一个数组，每个`obj`的属性都有一个[key, value]对。
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The inferred type is an Array of tuples.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 推断的类型是元组的数组。
- en: 7.10 Function types
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.10 函数类型
- en: 'This is an example of a function type:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个函数类型的例子：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This type comprises every function that accepts a single parameter of type
    number and return a string. Let’s use this type in a type annotation:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型包括每个接受一个`number`类型的参数并返回一个`string`的函数。让我们在类型注解中使用这种类型：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Normally, we must specify parameter types for functions. But in this case,
    the type of `num` in line B can be inferred from the function type in line A and
    we can omit it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们必须为函数指定参数类型。但在这种情况下，`num`在B行的类型可以从A行的函数类型中推断出来，我们可以省略它：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we omit the type annotation for `toString`, TypeScript infers a type from
    the arrow function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们省略`toString`的类型注解，TypeScript会从箭头函数中推断出类型：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This time, `num` must have a type annotation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`num`必须有一个类型注解。
- en: 7.10.1 A more complicated example
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.10.1 更复杂的例子
- en: 'The following example is more complicated:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子更加复杂：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are using a function type to describe the parameter `callback` of `stringify123()`.
    Due to this type annotation, TypeScript rejects the following function call.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用函数类型来描述`stringify123()`的参数`callback`。由于这个类型注解，TypeScript拒绝了以下函数调用。
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'But it accepts this function call:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 但它接受这个函数调用：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 7.10.2 Return types of function declarations
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.10.2 函数声明的返回类型
- en: TypeScript can usually infer the return types of functions, but specifying them
    explicitly is allowed and occasionally useful (at the very least, it doesn’t do
    any harm).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript通常可以推断函数的返回类型，但允许显式指定它们并且偶尔是有用的（至少，它不会有害）。
- en: 'For `stringify123()`, specifying a return type is optional and looks like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`stringify123()`，指定返回类型是可选的，看起来像这样：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 7.10.2.1 The special return type `void`
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.10.2.1 特殊的返回类型`void`
- en: '`void` is a special return type for a function: It tells TypeScript that the
    function always returns `undefined`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`void`是函数的一个特殊返回类型：它告诉TypeScript函数总是返回`undefined`。'
- en: 'It may do so explicitly:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能会显式地这样做：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Or it may do so implicitly:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它可能会隐式地这样做：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'However, such a function cannot explicitly return values other than `undefined`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样的函数不能明确返回除`undefined`之外的值：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 7.10.3 Optional parameters
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.10.3 可选参数
- en: 'A question mark after an identifier means that the parameter is optional. For
    example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符后面的问号表示参数是可选的。例如：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: TypeScript only lets us make the function call in line A if we make sure that
    `callback` isn’t `undefined` (which it is if the parameter was omitted).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript只有在确保`callback`不是`undefined`时才允许我们在A行进行函数调用（如果参数被省略，则它是`undefined`）。
- en: 7.10.3.1 Parameter default values
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.10.3.1 参数默认值
- en: 'TypeScript supports [parameter default values](https://exploringjs.com/impatient-js/ch_callables.html#parameter-default-values):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript支持[参数默认值](https://exploringjs.com/impatient-js/ch_callables.html#parameter-default-values)：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Default values make parameters optional. We can usually omit type annotations,
    because TypeScript can infer the types. For example, it can infer that `x` and
    `y` both have the type `number`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值使参数变为可选。通常我们可以省略类型注释，因为TypeScript可以推断类型。例如，它可以推断`x`和`y`都是`number`类型。
- en: If we wanted to add type annotations, that would look as follows.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想添加类型注释，那么会是这样的。
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 7.10.4 Rest parameters
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.10.4 剩余参数
- en: 'We can also use [rest parameters](https://exploringjs.com/impatient-js/ch_callables.html#rest-parameters)
    in TypeScript parameter definitions. Their static types must be Arrays (lists
    or tuples):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在TypeScript参数定义中使用[剩余参数](https://exploringjs.com/impatient-js/ch_callables.html#rest-parameters)。它们的静态类型必须是数组（列表或元组）：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 7.11 Union types
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.11 联合类型
- en: 'The values that are held by a variable (one value at a time) may be members
    of different types. In that case, we need a *union type*. For example, in the
    following code, `stringOrNumber` is either of type `string` or of type `number`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 变量持有的值（一次一个值）可能是不同类型的成员。在这种情况下，我们需要*联合类型*。例如，在以下代码中，`stringOrNumber`的类型是`string`或`number`：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`stringOrNumber` has the type `string|number`. The result of the type expression
    `s|t` is the set-theoretic union of the types `s` and `t` (interpreted as sets).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`stringOrNumber`的类型是`string|number`。类型表达式`s|t`的结果是类型`s`和`t`的集合论并集（解释为集合）。'
- en: 7.11.1 By default, `undefined` and `null` are not included in types
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.11.1 默认情况下，`undefined`和`null`不包括在类型中
- en: In many programming languages, `null` is part of all object types. For example,
    whenever the type of a variable is `String` in Java, we can set it to `null` and
    Java won’t complain.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多编程语言中，`null`是所有对象类型的一部分。例如，在Java中，当变量的类型是`String`时，我们可以将其设置为`null`，Java不会抱怨。
- en: 'Conversely, in TypeScript, `undefined` and `null` are handled by separate,
    disjoint types. We need union types such as `undefined|string` and `null|string`,
    if we want to allow them:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在TypeScript中，`undefined`和`null`由单独的不相交类型处理。如果我们想允许它们，我们需要联合类型，如`undefined|string`和`null|string`：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Otherwise, we get an error:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们会得到一个错误：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note that TypeScript does not force us to initialize immediately (as long as
    we don’t read from the variable before initializing it):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，TypeScript不强制我们立即初始化（只要我们在初始化之前不从变量中读取）：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 7.11.2 Making omissions explicit
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.11.2 明确省略
- en: 'Recall this function from earlier:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下之前的这个函数：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let’s rewrite `stringify123()` so that parameter `callback` isn’t optional
    anymore: If a caller doesn’t want to provide a function, they must explicitly
    pass `null`. The result looks as follows.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写`stringify123()`，使参数`callback`不再是可选的：如果调用者不想提供一个函数，他们必须明确传递`null`。结果如下。
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once again, we have to handle the case of `callback` not being a function (line
    A) before we can make the function call in line B. If we hadn’t done so, TypeScript
    would have reported an error in that line.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们必须在进行函数调用之前处理`callback`不是函数的情况（A行），否则我们会得到一个错误。
- en: 7.12 Optional vs. default value vs. `undefined|T`
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.12 可选 vs. 默认值 vs. `undefined|T`
- en: 'The following three parameter declarations are quite similar:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个参数声明非常相似：
- en: 'Parameter is optional: `x?: number`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '参数是可选的：`x?: number`'
- en: 'Parameter has a default value: `x = 456`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数有默认值：`x = 456`
- en: 'Parameter has a union type: `x: undefined | number`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '参数有联合类型：`x: undefined | number`'
- en: 'If the parameter is optional, it can be omitted. In that case, it has the value
    `undefined`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数是可选的，可以省略。在这种情况下，它的值是`undefined`：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If the parameter has a default value, that value is used when the parameter
    is either omitted or set to `undefined`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数有默认值，则在参数被省略或设置为`undefined`时使用该值：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If the parameter has a union type, it can’t be omitted, but we can set it to
    `undefined`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数具有联合类型，则不能省略，但是我们可以将其设置为`undefined`：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 7.13 Typing objects
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.13 对象类型
- en: 'Similarly to Arrays, objects play two roles in JavaScript (that are occasionally
    mixed):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组类似，对象在JavaScript中扮演两种角色（有时混合在一起）：
- en: 'Records: A fixed number of properties that are known at development time. Each
    property can have a different type.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录：在开发时已知的固定数量的属性。每个属性可以具有不同的类型。
- en: 'Dictionaries: An arbitrary number of properties whose names are not known at
    development time. All properties have the same type.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典：在开发时不知道名称的任意数量的属性。所有属性都具有相同的类型。
- en: 'We are ignoring objects-as-dictionaries in this chapter – they are covered
    in [§15.4.5 “Index signatures: objects as dicts”](ch_typing-objects.html#index-signatures).
    As an aside, Maps are usually a better choice for dictionaries, anyway.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们忽略了对象作为字典的部分-它们在[§15.4.5“索引签名：对象作为字典”](ch_typing-objects.html#index-signatures)中有涵盖。顺便说一句，Map通常是字典的更好选择。
- en: 7.13.1 Typing objects-as-records via interfaces
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.13.1 通过接口对对象作为记录进行类型标注
- en: 'Interfaces describe objects-as-records. For example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接口描述对象作为记录。例如：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can also separate members via commas:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用逗号分隔成员：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 7.13.2 TypeScript’s structural typing vs. nominal typing
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.13.2 TypeScript的结构类型与名义类型
- en: 'One big advantage of TypeScript’s type system is that it works *structurally*,
    not *nominally*. That is, interface `Point` matches all objects that have the
    appropriate structure:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript类型系统的一个重要优势是它是*结构化*的，而不是*名义化*的。也就是说，接口`Point`匹配所有具有适当结构的对象：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Conversely, in Java’s nominal type system, we must explicitly declare with each
    class which interfaces it implements. Therefore, a class can only implement interfaces
    that exist at its creation time.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在Java的名义类型系统中，我们必须在每个类中明确声明它实现的接口。因此，一个类只能实现在其创建时存在的接口。
- en: 7.13.3 Object literal types
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.13.3对象文字类型
- en: '*Object literal types* are anonymous interfaces:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象文字类型*是匿名接口：'
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'One benefit of object literal types is that they can be used inline:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对象文字类型的一个好处是它们可以内联使用：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 7.13.4 Optional properties
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.13.4可选属性
- en: 'If a property can be omitted, we put a question mark after its name:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性可以省略，我们在其名称后面加上一个问号：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the following example, both `john` and `jane` match the interface `Person`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，`john`和`jane`都符合接口`Person`：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 7.13.5 Methods
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.13.5方法
- en: 'Interfaces can also contain methods:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接口也可以包含方法：
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As far as TypeScript’s type system is concerned, method definitions and properties
    whose values are functions, are equivalent:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 就TypeScript的类型系统而言，方法定义和其值为函数的属性是等价的：
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: My recommendation is to use whichever syntax best expresses how a property should
    be set up.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是使用最能表达属性设置方式的语法。
- en: 7.14 Type variables and generic types
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.14类型变量和通用类型
- en: 'Recall [the two language levels of TypeScript](ch_typescript-essentials.html#language-levels):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾[TypeScript的两个语言级别](ch_typescript-essentials.html#language-levels)：
- en: Values exist at the *dynamic level*.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值存在于*动态级别*。
- en: Types exist at the *static level*.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型存在于*静态级别*。
- en: 'Similarly:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 同样：
- en: 'Normal functions exist at the dynamic level, are factories for values and have
    parameters representing values. Parameters are declared between parentheses:'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通函数存在于动态级别，是值的工厂，并且具有表示值的参数。参数在括号之间声明：
- en: '[PRE43]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Generic types* exist at the static level, are factories for types and have
    parameters representing types. Parameters are declared between angle brackets:'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通用类型*存在于静态级别，是类型的工厂，并且具有表示类型的参数。参数在尖括号之间声明：'
- en: '[PRE44]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![](../Images/6a9318e9b4540abb73475976e01d55f9.png)  **Naming type parameters**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/6a9318e9b4540abb73475976e01d55f9.png) **命名类型参数**'
- en: In TypeScript, it is common to use a single uppercase character (such as `T`,
    `I`, and `O`) for a type parameter. However, any legal JavaScript identifier is
    allowed and longer names often make code easier to understand.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，通常使用单个大写字符（如`T`，`I`和`O`）作为类型参数。但是，任何合法的JavaScript标识符都是允许的，而且更长的名称通常使代码更容易理解。
- en: '7.14.1 Example: a container for values'
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.14.1示例：值的容器
- en: '[PRE45]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`Value` is a *type variable*. One or more type variables can be introduced
    between angle brackets.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`Value`是一个*类型变量*。可以在尖括号之间引入一个或多个类型变量。'
- en: '7.15 Example: a generic class'
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.15示例：一个通用类
- en: 'Classes can have type parameters, too:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 类也可以有类型参数：
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Class `SimpleStack` has the type parameter `Elem`. When we instantiate the
    class, we also provide a value for the type parameter:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 类`SimpleStack`具有类型参数`Elem`。当我们实例化类时，我们还为类型参数提供一个值：
- en: '[PRE47]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '7.15.1 Example: Maps'
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.15.1示例：Maps
- en: 'Maps are typed generically in TypeScript. For example:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，Map是带有泛型的。例如：
- en: '[PRE48]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Thanks to type inference (based on the argument of `new Map()`), we can omit
    the type parameters:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型推断（基于`new Map()`的参数），我们可以省略类型参数：
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 7.15.2 Type variables for functions and methods
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.15.2函数和方法的类型变量
- en: 'Function definitions can introduce type variables like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义可以像这样引入类型变量：
- en: '[PRE50]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We use the function as follows.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用函数如下。
- en: '[PRE51]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Due to type inference, we can once again omit the type parameter:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型推断，我们可以再次省略类型参数：
- en: '[PRE52]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that TypeScript inferred the type `123`, which is a set with one number
    and more specific than the type `number`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，TypeScript推断出了类型`123`，这是一个具有一个数字的集合，比类型`number`更具体。
- en: 7.15.2.1 Arrow functions and methods
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.15.2.1箭头函数和方法
- en: 'Arrow functions can also have type parameters:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数也可以有类型参数：
- en: '[PRE53]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This is the type parameter syntax for methods:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这是方法的类型参数语法：
- en: '[PRE54]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 7.15.3 A more complicated function example
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.15.3更复杂的函数示例
- en: '[PRE55]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The type variable `T` appears four times in this code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 类型变量`T`在此代码中出现了四次：
- en: It is introduced via `fillArray<T>`. Therefore, its scope is the function.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是通过`fillArray<T>`引入的。因此，它的范围是函数。
- en: It is used for the first time in the type annotation for the parameter `elem`.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它首次用于参数`elem`的类型注释。
- en: It is used for the second second time to specify the return type of `fillArray()`.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它第二次用于指定`fillArray()`的返回类型。
- en: It is also used as a type argument for the constructor `Array()`.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它也被用作构造函数`Array()`的类型参数。
- en: 'We can omit the type parameter when calling `fillArray()` (line A) because
    TypeScript can infer `T` from the parameter `elem`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在调用`fillArray()`（行A）时省略类型参数，因为TypeScript可以从参数`elem`中推断出`T`：
- en: '[PRE56]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '7.16 Conclusion: understanding the initial example'
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.16结论：理解初始示例
- en: 'Let’s use what we have learned to understand the piece of code we have seen
    earlier:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们之前学到的知识来理解我们之前看到的代码片段：
- en: '[PRE57]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This is an interface for Arrays whose elements are of type `T`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个数组的接口，其元素的类型为`T`：
- en: method `.concat()` has zero or more parameters (defined via a rest parameter).
    Each of those parameters has the type `T[]|T`. That is, it is either an Array
    of `T` values or a single `T` value.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法`.concat()`有零个或多个参数（通过rest参数定义）。每个参数的类型为`T[]|T`。也就是说，它要么是`T`值的数组，要么是单个`T`值。
- en: 'method `.reduce()` introduces its own type variable `U`. `U` is used to express
    the fact that the following entities all have the same type:'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法`.reduce()`引入了自己的类型变量`U`。`U`用于表示以下实体都具有相同类型的事实：
- en: Parameter `state` of `callback()`
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback()`的`state`参数'
- en: Result of `callback()`
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback()`的结果'
- en: Optional parameter `firstState` of `.reduce()`
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.reduce()`的可选参数`firstState`'
- en: Result of `.reduce()`
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.reduce()`的结果'
- en: 'In addition to `state`, `callback()` has the following parameters:'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了`state`，`callback()`还有以下参数：
- en: '`element`, which has the same type `T` as the Array elements'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`element`，其类型与数组元素的类型`T`相同'
- en: '`index`; a number'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`；一个数字'
- en: '`array` with elements of type `T`'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有类型`T`的元素的`array`
- en: '[Comments](https://github.com/rauschma/tackling-ts/issues/7)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[评论](https://github.com/rauschma/tackling-ts/issues/7)'
