<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>46â€ƒRegular expressions (RegExp)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>46â€ƒRegular expressions (RegExp)</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://exploringjs.com/js/book/ch_regexps.html">https://exploringjs.com/js/book/ch_regexps.html</a></blockquote>

        
    
    
    
<p><span id="index-entry-regular-expression"/><span id="index-entry-RegExp"/></p>
<nav class="local-toc">
  <ol>
    <li>
      <a href="#creating-regular-expressions">46.1â€ƒCreating regular expressions</a>
      <ol>
        <li>
          <a href="#regex-literal-vs-constructor">46.1.1â€ƒLiteral vs. constructor</a>
        </li>
        <li>
          <a href="#tip-use-stringraw-literals-with-new-regexp">46.1.2â€ƒTip: Use <code>String.raw</code> literals with <code>new RegExp()</code></a>
        </li>
        <li>
          <a href="#cloning-regexps">46.1.3â€ƒCloning and non-destructively modifying regular expressions</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#escaping-for-regexp">46.2â€ƒSyntax characters and escaping</a>
      <ol>
        <li>
          <a href="#syntax-characters">46.2.1â€ƒSyntax characters</a>
        </li>
        <li>
          <a href="#illegal-toplevel-escaping">46.2.2â€ƒIllegal top-level escaping</a>
        </li>
        <li>
          <a href="#escaping-inside-character-classes">46.2.3â€ƒEscaping inside character classes (<code>[Â·Â·Â·]</code>)</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#regular-expression-character">46.3â€ƒRegular expressions: the concept of a character</a>
    </li>
    <li>
      <a href="#syntax-matching-single-characters">46.4â€ƒSyntax: matching single characters</a>
    </li>
    <li>
      <a href="#syntax-character-class-escapes">46.5â€ƒSyntax: character class escapes</a>
      <ol>
        <li>
          <a href="#basic-character-class-escapes">46.5.1â€ƒBasic character class escapes (sets of code units): <code>\d \D \s \S \w \W</code></a>
        </li>
        <li>
          <a href="#unicode-property-escapes">46.5.2â€ƒUnicode property escapes: <code>\p{}</code> and <code>\P{}</code></a>
        </li>
        <li>
          <a href="#unicode-character-property-escapes">46.5.3â€ƒUnicode character property escapes<span> <sup>ES2018</sup></span></a>
        </li>
        <li>
          <a href="#unicode-string-property-escapes">46.5.4â€ƒUnicode string property escapes<span> <sup>ES2024</sup></span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#syntax-character-classes">46.6â€ƒSyntax: character classes</a>
      <ol>
        <li>
          <a href="#character-class-code-point-sequences">46.6.1â€ƒCode point sequences in character classes<span> <sup>ES2024</sup></span></a>
        </li>
        <li>
          <a href="#regexp-character-class-set-operations">46.6.2â€ƒSet operations for character classes<span> <sup>ES2024</sup></span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#regexp-capture-groups">46.7â€ƒSyntax: capture groups</a>
    </li>
    <li>
      <a href="#regexp-quantifiers">46.8â€ƒSyntax: quantifiers</a>
    </li>
    <li>
      <a href="#regexp-assertions">46.9â€ƒSyntax: assertions</a>
      <ol>
        <li>
          <a href="#regexp-lookahead-assertions">46.9.1â€ƒLookahead assertions</a>
        </li>
        <li>
          <a href="#regexp-lookbehind-assertions">46.9.2â€ƒLookbehind assertions<span> <sup>ES2018</sup></span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#syntax-disjunction-">46.10â€ƒSyntax: disjunction (<code>|</code>)</a>
    </li>
    <li>
      <a href="#regexp-flags">46.11â€ƒRegular expression flags</a>
      <ol>
        <li>
          <a href="#order-of-regexp-flags">46.11.1â€ƒHow to order regular expression flags?</a>
        </li>
        <li>
          <a href="#without-the-unicode-flags-u-and-v-characters-are-utf16-code-units">46.11.2â€ƒWithout the Unicode flags <code>/u</code> and <code>/v</code>: characters are UTF-16 code units</a>
        </li>
        <li>
          <a href="#regexp-flag-unicode">46.11.3â€ƒFlag <code>/u</code>: characters are code points<span> <sup>ES6</sup></span></a>
        </li>
        <li>
          <a href="#regexp-flag-unicode-sets">46.11.4â€ƒFlag <code>/v</code>: limited support for multi-code-point grapheme clusters<span> <sup>ES2024</sup></span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#regexp-pattern-modifiers">46.12â€ƒPattern modifiers (inline flags)<span> <sup>ES2025</sup></span></a>
      <ol>
        <li>
          <a href="#the-syntax-of-pattern-modifiers">46.12.1â€ƒThe syntax of pattern modifiers</a>
        </li>
        <li>
          <a href="#which-flags-are-supported">46.12.2â€ƒWhich flags are supported?</a>
        </li>
        <li>
          <a href="#use-case-changing-flags-for-part-of-a-regular-expression">46.12.3â€ƒUse case: changing flags for part of a regular expression</a>
        </li>
        <li>
          <a href="#use-case-inlining-flags">46.12.4â€ƒUse case: inlining flags</a>
        </li>
        <li>
          <a href="#use-case-regular-expression-fragments-that-change-flags">46.12.5â€ƒUse case: regular expression fragments that change flags</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#properties-of-regular-expression-objects">46.13â€ƒProperties of regular expression objects</a>
      <ol>
        <li>
          <a href="#flags-as-properties">46.13.1â€ƒFlags as properties</a>
        </li>
        <li>
          <a href="#other-properties">46.13.2â€ƒOther properties</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#match-objects">46.14â€ƒMatch objects</a>
      <ol>
        <li>
          <a href="#regexp-match-indices">46.14.1â€ƒMatch indices in match objects<span> <sup>ES2022</sup></span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#methods-for-working-with-regular-expressions">46.15â€ƒMethods for working with regular expressions</a>
      <ol>
        <li>
          <a href="#by-default-regular-expressions-match-anywhere-in-a-string">46.15.1â€ƒBy default, regular expressions match anywhere in a string</a>
        </li>
        <li>
          <a href="#String.prototype.match">46.15.2â€ƒ<code>string.match(regExp)</code> without <code>/g</code>: getting a match object for the first match</a>
        </li>
        <li>
          <a href="#stringmatchregexp-with-g-getting-all-group-0-captures-es3">46.15.3â€ƒ<code>string.match(regExp)</code> with <code>/g</code>: getting all group 0 captures<span> <sup>ES3</sup></span></a>
        </li>
        <li>
          <a href="#String.prototype.matchAll">46.15.4â€ƒ<code>string.matchAll(regExp)</code>: getting an iterable over all match objects<span> <sup>ES2020</sup></span></a>
        </li>
        <li>
          <a href="#RegExp.prototype.exec">46.15.5â€ƒ<code>regExp.exec(str)</code>: capturing groups<span> <sup>ES3</sup></span></a>
        </li>
        <li>
          <a href="#match-vs-matchall-vs-exec">46.15.6â€ƒ<code>string.match()</code> vs. <code>string.matchAll()</code> vs. <code>regExp.exec()</code></a>
        </li>
        <li>
          <a href="#replace-replaceAll">46.15.7â€ƒReplacing with <code>string.replace()</code> and <code>string.replaceAll()</code></a>
        </li>
        <li>
          <a href="#RegExp.prototype.test">46.15.8â€ƒ<code>regExp.test(str)</code>: is there a match?<span> <sup>ES3</sup></span></a>
        </li>
        <li>
          <a href="#String.prototype.search">46.15.9â€ƒ<code>string.search(regExp)</code>: at what index is the match?<span> <sup>ES3</sup></span></a>
        </li>
        <li>
          <a href="#String.prototype.split">46.15.10â€ƒ<code>string.split(separator, limit?)</code>: splitting strings<span> <sup>ES3</sup></span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#regexp-flags-gy">46.16â€ƒThe flags <code>/g</code> and <code>/y</code>, and the property <code>.lastIndex</code><span> (advanced)</span></a>
      <ol>
        <li>
          <a href="#the-flags-g-and-y">46.16.1â€ƒThe flags <code>/g</code> and <code>/y</code></a>
        </li>
        <li>
          <a href="#how-exactly-are-methods-affected-by-g-and-y">46.16.2â€ƒHow exactly are methods affected by <code>/g</code> and <code>/y</code>?</a>
        </li>
        <li>
          <a href="#four-pitfalls-of-g-and-y-and-how-to-deal-with-them">46.16.3â€ƒFour pitfalls of <code>/g</code> and <code>/y</code> and how to deal with them</a>
        </li>
        <li>
          <a href="#use-case-for-lastindex-starting-matching-at-a-given-index">46.16.4â€ƒUse case for <code>.lastIndex</code>: starting matching at a given index</a>
        </li>
        <li>
          <a href="#regexp-lastindex-upsides-downsides">46.16.5â€ƒThe downsides and an upside of <code>.lastIndex</code></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#RegExp.escape">46.17â€ƒ<code>RegExp.escape()</code>: escaping text so that it can be used inside a regular expression<span> <sup>ES2025</sup></span></a>
      <ol>
        <li>
          <a href="#use-case-for-regexpescape-replacing-all-occurrences-of-a-text">46.17.1â€ƒUse case for <code>RegExp.escape()</code>: replacing all occurrences of a text</a>
        </li>
        <li>
          <a href="#use-case-for-regexpescape-part-of-a-regular-expression-must-match-a-given-text">46.17.2â€ƒUse case for <code>RegExp.escape()</code>: part of a regular expression must match a given text</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#matching-everything-or-nothing">46.18â€ƒMatching everything or nothing</a>
    </li>
    <li>
      <a href="#tips-for-making-regular-expressions-easier-to-use">46.19â€ƒTips for making regular expressions easier to use</a>
      <ol>
        <li>
          <a href="#tip-use-flag-v">46.19.1â€ƒTip: Use flag <code>/v</code></a>
        </li>
        <li>
          <a href="#tip-order-flags-alphabetically">46.19.2â€ƒTip: order flags alphabetically</a>
        </li>
        <li>
          <a href="#tip-use-named-capture-groups">46.19.3â€ƒTip: Use named capture groups</a>
        </li>
        <li>
          <a href="#tip-insignificant-whitespace-and-line-comments-via-">46.19.4â€ƒTip: insignificant whitespace and line comments via <code>#</code></a>
        </li>
        <li>
          <a href="#tip-write-tests-for-your-regular-expression">46.19.5â€ƒTip: Write tests for your regular expression</a>
        </li>
        <li>
          <a href="#tip-mention-examples-in-your-documentation">46.19.6â€ƒTip: Mention examples in your documentation</a>
        </li>
        <li>
          <a href="#bonus-tip-use-interpolation-to-reuse-patterns">46.19.7â€ƒBonus tip: Use interpolation to reuse patterns</a>
        </li>
        <li>
          <a href="#bonus-tip-insignificant-whitespace-without-a-library">46.19.8â€ƒBonus tip: insignificant whitespace without a library</a>
        </li>
        <li>
          <a href="#conclusion-this-is-how-regular-expressions-are-meant-to-be-written">46.19.9â€ƒConclusion: This is how regular expressions are meant to be written</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#quickref-RegExp">46.20â€ƒQuick reference: regular expression functionality</a>
      <ol>
        <li>
          <a href="#summary-flags-global-sticky">46.20.1â€ƒSummary: <code>.global</code> (<code>/g</code>) and <code>.sticky</code> (<code>/y</code>)</a>
        </li>
        <li>
          <a href="#stringprototype-matching-and-searching">46.20.2â€ƒ<code>String.prototype.*</code>: matching and searching</a>
        </li>
        <li>
          <a href="#stringprototype-splitting-and-replacing">46.20.3â€ƒ<code>String.prototype.*</code>: splitting and replacing</a>
        </li>
        <li>
          <a href="#regexpprototype">46.20.4â€ƒ<code>RegExp.prototype.*</code></a>
        </li>
      </ol>
    </li>
  </ol>
</nav>
<div class="boxout">
  <p><img src="../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png" class="boxout-icon" height="24" alt="Icon â€œreadingâ€" data-original-src="https://exploringjs.com/js/book/icon/reading.svg"/>â€‚<strong>Availability of features</strong></p>
  <div class="boxout-vspace"/>
  <p>Unless stated otherwise, each regular expression feature has been available since ES3.</p>
</div>
<h3 id="creating-regular-expressions"><a class="heading-id-link" href="#creating-regular-expressions">46.1â€ƒCreating regular expressions</a></h3>
<h4 id="regex-literal-vs-constructor"><a class="heading-id-link" href="#regex-literal-vs-constructor">46.1.1â€ƒLiteral vs. constructor</a></h4>
<p><span id="index-entry-regular-expression-literal"/>
<span id="index-entry-pattern--regular-expression-"/><span id="index-entry-flags--regular-expression-"/></p>
<p>The two main ways of creating regular expressions are:</p>
<ul>
  <li>
    <p>Literal: compiled statically (at load time).</p>
<pre class="language-js">
/abc/iv
</pre>
  </li>
  <li>
    <p>Constructor: compiled dynamically (at runtime).</p>
<pre class="language-js">
<span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">'abc'</span>, <span class="hljs-string">'iv'</span>)
</pre>
  </li>
</ul>
<p>Both regular expressions have the same two parts:</p>
<ul>
  <li>
    The <em>body</em> <code>abc</code> â€“ the actual regular expression.
  </li>
  <li>
    The <em>flags</em> <code>i</code> and <code>v</code>. Flags configure how the pattern is interpreted. For example, <code>i</code> enables case-insensitive matching. A list of available flags is given <a href="#regexp-flags">later in this chapter</a>.
  </li>
</ul>
<div class="boxout">
  <p><img src="../Images/8440b17bb8219cda9f9405ac83c36db0.png" class="boxout-icon" height="24" alt="Icon â€œtipâ€" data-original-src="https://exploringjs.com/js/book/icon/tip.svg"/>â€‚<strong>Recommended: flag <code>/v</code> <sup>ES2024</sup></strong></p>
  <div class="boxout-vspace"/>
  <p>Flag <code>/v</code> enables important features and is recommended for all regular expressions.</p>
</div>
<h4 id="tip-use-stringraw-literals-with-new-regexp"><a class="heading-id-link" href="#tip-use-stringraw-literals-with-new-regexp">46.1.2â€ƒTip: Use <code>String.raw</code> literals with <code>new RegExp()</code></a></h4>
<p>If we use a normal string literal as an argument for <code>new RegExp()</code>, every regular expression backslash has to be escaped. If we use <a href="ch_template-literals.html#raw-string-literals"><code>String.raw</code></a> as a template tag then thatâ€™s not necessary. The following three regular expressions are all equivalent:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\*$/.<span class="hljs-title function_">test</span>(<span class="hljs-string">'*'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">'^\\*$'</span>, <span class="hljs-string">'v'</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'*'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`^\*$`</span>, <span class="hljs-string">'v'</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'*'</span>)</span>
true
</pre>
<p>If we use <code>String.raw</code> often, we can abbreviate it:</p>
<pre class="language-js">
<span class="hljs-comment">// â€œImportâ€ from namespace `String`</span>
<span class="hljs-keyword">const</span> {raw} = <span class="hljs-title class_">String</span>;
<code/>
<span class="hljs-keyword">const</span> regExp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(raw<span class="hljs-string">`^\*$`</span>, <span class="hljs-string">'v'</span>);
</pre>
<h4 id="cloning-regexps"><a class="heading-id-link" href="#cloning-regexps">46.1.3â€ƒCloning and non-destructively modifying regular expressions</a></h4>
<p>There are two variants of the constructor <code>RegExp()</code>:</p>
<ul>
  <li>
    <p><code>new RegExp(pattern : string, flags = '')</code> <sup>ES3</sup></p>
    <p>A new regular expression is created as specified via <code>pattern</code>. If <code>flags</code> is missing, the empty string <code>''</code> is used.</p>
  </li>
  <li>
    <p><code>new RegExp(regExp : RegExp, flags = regExp.flags)</code> <sup>ES6</sup></p>
    <p><code>regExp</code> is cloned. If <code>flags</code> is provided, then it determines the flags of the clone.</p>
  </li>
</ul>
<p>The second variant is useful for cloning regular expressions, optionally while modifying them. Flags are immutable and this is the only way of changing them â€“ for example:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">copyAndAddFlags</span>(<span class="hljs-params">regExp, flagsToAdd=<span class="hljs-string">''</span></span>) {
  <span class="hljs-comment">// The constructor doesnâ€™t allow duplicate flags;</span>
  <span class="hljs-comment">// make sure there arenâ€™t any:</span>
  <span class="hljs-keyword">const</span> newFlags = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(regExp.<span class="hljs-property">flags</span> + flagsToAdd)
  ).<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(regExp, newFlags);
}
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-regexp">/abc/i</span>.<span class="hljs-property">flags</span>, <span class="hljs-string">'i'</span>);
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">copyAndAddFlags</span>(<span class="hljs-regexp">/abc/i</span>, <span class="hljs-string">'g'</span>).<span class="hljs-property">flags</span>, <span class="hljs-string">'gi'</span>);
</pre>
<p><code>new Set()</code> iterates over its argument which means that a string is split into code points. Those code points become Set elements, which eliminates duplicates. Before we can join them into a string, we have to convert them to an Array and do so via <code>Array.from()</code>.</p>
<h3 id="escaping-for-regexp"><a class="heading-id-link" href="#escaping-for-regexp">46.2â€ƒSyntax characters and escaping</a></h3>
<h4 id="syntax-characters"><a class="heading-id-link" href="#syntax-characters">46.2.1â€ƒSyntax characters</a></h4>
<p>At the top level of a regular expression, the following <a href="https://tc39.es/ecma262/#prod-SyntaxCharacter"><em>Syntax Characters</em></a> are special. They are escaped by prefixing a backslash (<code>\</code>).</p>
<pre>
^ $ \ . * + ? ( ) [ ] { } |
</pre>
<p>This is an example:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/\*/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'*'</span>)</span>
true
</pre>
<p>In regular expression literals, we must escape slashes:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/\<span class="hljs-comment">//v.test('/')</span></span>
true
</pre>
<p>In the argument of <code>new RegExp()</code>, we donâ€™t have to escape slashes:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">'/'</span>, <span class="hljs-string">'v'</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'/'</span>)</span>
true
</pre>
<h4 id="illegal-toplevel-escaping"><a class="heading-id-link" href="#illegal-toplevel-escaping">46.2.2â€ƒIllegal top-level escaping</a></h4>
<p>With a Unicode flag (<code>/u</code> or <code>/v</code>), escaping a non-syntax character at the top level is a syntax error. That enables syntax such as <code>\p{Â·Â·Â·}</code>.</p>
<pre class="language-js">
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">eval</span>(<span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`/\a/v`</span>),
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'SyntaxError'</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">'Invalid regular expression: /\\a/v: Invalid escape'</span>,
  }
);
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">eval</span>(<span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`/\-/v`</span>),
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'SyntaxError'</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">'Invalid regular expression: /\\-/v: Invalid escape'</span>,
  }
);
</pre>
<p>Without flag <code>/u</code> and <code>/v</code>, an escaped non-syntax character at the top level matches itself:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/\a/.<span class="hljs-title function_">test</span>(<span class="hljs-string">'a'</span>)</span>
true
</pre>
<h4 id="escaping-inside-character-classes"><a class="heading-id-link" href="#escaping-inside-character-classes">46.2.3â€ƒEscaping inside character classes (<code>[Â·Â·Â·]</code>)</a></h4>
<p>The rules for escaping inside character classes are different if we use the recommended flag <code>/v</code>. We look at those first before we look at the rules for regular expressions that have no Unicode flag (neither <code>/u</code> nor <code>/v</code>).</p>
<h5 id="escaping-inside-character-classes-flag-v"><a class="heading-id-link" href="#escaping-inside-character-classes-flag-v">46.2.3.1â€ƒEscaping inside character classes: flag <code>/v</code></a></h5>
<p>The following characters can be escaped via backslash:</p>
<ul>
  <li>
    <p><a href="https://tc39.es/ecma262/#prod-SyntaxCharacter"><em>Syntax Characters</em></a>:</p>
<pre>
^ $ \ . * + ? ( ) [ ] { } |
</pre>
  </li>
  <li>
    <p>Slash:</p>
<pre>
/
</pre>
  </li>
  <li>
    <p><a href="https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator"><em>Class Set Reserved Punctuators</em></a>:</p>
<pre>
&amp; - ! # % , : ; &lt; = &gt; @ ` ~
</pre>
  </li>
</ul>
<p>Interestingly, we donâ€™t always have to escape these characters. Only the following sequences of characters donâ€™t match themselves and have to be escaped:</p>
<ul>
  <li>
    <p>A single <code>^</code> only has to be escaped if it comes first.</p>
  </li>
  <li>
    <p><a href="https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter"><em>Class Set Syntax Characters</em></a> must always be escaped:</p>
<pre>
( ) [ ] { } / - \ |
</pre>
  </li>
  <li>
    <p><a href="https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator"><em>Class Set Reserved Double Punctuators</em></a> must always be escaped (at least one of them):</p>
<pre>
&amp;&amp; !! ## $$ %% ** ++ ,, .. :: ;; &lt;&lt; == &gt;&gt; ?? @@ ^^ `` ~~
</pre>
  </li>
</ul>
<h5 id="escaping-inside-character-classes-no-unicode-flag-neither-u-nor-v"><a class="heading-id-link" href="#escaping-inside-character-classes-no-unicode-flag-neither-u-nor-v">46.2.3.2â€ƒEscaping inside character classes: no Unicode flag (neither <code>/u</code> nor <code>/v</code>)</a></h5>
<ul>
  <li>
    <p>We always must escape: <code>\ ]</code></p>
  </li>
  <li>
    <p>Some characters only have to be escaped in some locations:</p>
    <ul>
      <li>
        <code>^</code> only has to be escaped if it comes first.
      </li>
      <li>
        <code>-</code> only has to be escaped if it doesnâ€™t come first or last.
      </li>
    </ul>
  </li>
</ul>
<h3 id="regular-expression-character"><a class="heading-id-link" href="#regular-expression-character">46.3â€ƒRegular expressions: the concept of a character</a></h3>
<p>In the context of regular expressions, â€œcharacterâ€ means â€œatomic unit of textâ€:</p>
<ul>
  <li>
    Without the Unicode flags (<code>/u</code> and <code>/v</code>), a character is a JavaScript character (a UTF-16 code unit).
  </li>
  <li>
    With a Unicode flag, a character is a code point.
  </li>
</ul>
<p>For example, a dot (<code>.</code>) matches a single character:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'ğŸ™‚'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/./g</span>) <span class="hljs-comment">// code point with 2 code units</span></span>
[ '\uD83D', '\uDE42' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'ğŸ™‚'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/./g</span>v)</span>
[ 'ğŸ™‚' ]
</pre>
<h3 id="syntax-matching-single-characters"><a class="heading-id-link" href="#syntax-matching-single-characters">46.4â€ƒSyntax: matching single characters</a></h3>
<p>These constructs match single characters:</p>
<ul>
  <li>
    <p><em>Pattern characters</em> are all characters <em>except</em> syntax characters (<code>^</code>, <code>$</code>, etc.). Pattern characters match themselves. Examples: <code>A b % -</code></p>
  </li>
  <li>
    <p><code>.</code> matches any character. We can use <a href="#regexp-dot-all-flag">flag <code>/s</code> (<code>dotAll</code>)</a> to control if the dot matches line terminators or not.</p>
  </li>
  <li>
    <p><em>Character escapes</em> (each escape matches a single fixed character):</p>
    <ul>
      <li>
        Control escapes (for a few control characters):
        <ul>
          <li>
            <code>\f</code>: form feed (FF)
          </li>
          <li>
            <code>\n</code>: line feed (LF)
          </li>
          <li>
            <code>\r</code>: carriage return (CR)
          </li>
          <li>
            <code>\t</code>: character tabulation
          </li>
          <li>
            <code>\v</code>: line tabulation
          </li>
        </ul>
      </li>
      <li>
        Control characters: <code>\cA</code> (Ctrl-A), â€¦,  <code>\cZ</code> (Ctrl-Z)
      </li>
      <li>
        Hex escape (first 256 Unicode code points): <code>\x20</code> (space)
      </li>
      <li>
        Unicode code unit escapes: <code>\u00E4</code> (Ã¤)
      </li>
      <li>
        Unicode code point escapes (require Unicode flag <code>/u</code> or <code>/v</code>): <code>\u{1F642}</code> (ğŸ™‚)
      </li>
      <li>
        Identity escapes match the escaped characters (these are the rules with a Unicode flag <code>/u</code> or <code>/v</code>; without them, most characters can be identity-escaped):
        <ul>
          <li>
            <p>We can escape the following <a href="https://tc39.es/ecma262/#prod-SyntaxCharacter">syntax characters</a> by prefixing them with backslashes:</p>
<pre>
^ $ \ . * + ? ( ) [ ] { } |
</pre>
          </li>
          <li>
            <p>We can also escape a slash like this: <code>\/</code></p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<h3 id="syntax-character-class-escapes"><a class="heading-id-link" href="#syntax-character-class-escapes">46.5â€ƒSyntax: character class escapes</a></h3>
<p>Character class escapes match sets of code units, sets of code points or sets of code point sequences.</p>
<h4 id="basic-character-class-escapes"><a class="heading-id-link" href="#basic-character-class-escapes">46.5.1â€ƒBasic character class escapes (sets of code units): <code>\d \D \s \S \w \W</code></a></h4>
<p>The following character class escapes and their complements are always supported:</p>
<table class="framed">
  <style>
    th:nth-child(1), td:nth-child(1) {
      text-align: left;
    }
    th:nth-child(2), td:nth-child(2) {
      text-align: left;
    }
    th:nth-child(3), td:nth-child(3) {
      text-align: left;
    }
    th:nth-child(4), td:nth-child(4) {
      text-align: left;
    }
  </style>
  <thead>
    <tr>
      <th/><th>Escape</th><th>Equivalent</th><th>Complement</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Digits</td><td><code>\d</code></td><td><code>[0-9]</code></td><td><code>\D</code></td>
    </tr>
    <tr>
      <td>â€œWordâ€ characters</td><td><code>\w</code></td><td><code>[a-zA-Z0-9_]</code></td><td><code>\W</code></td>
    </tr>
    <tr>
      <td>Whitespace</td><td><code>\s</code></td><td/><td><code>\S</code></td>
    </tr>
  </tbody>
</table>
<p>Note:</p>
<ul>
  <li>
    Whitespace: <code>\s</code> matches all whitespace code points: space, tab, line terminators, etc. They all fit into single UTF-16 code units.
  </li>
  <li>
    â€œWordâ€ characters are related to identifiers in programming languages.
  </li>
</ul>
<p>Examples:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'a7x4'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d/g</span>)</span>
[ '7', '4' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'a7x4'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\D/g</span>)</span>
[ 'a', 'x' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'high - low'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\w+/g</span>)</span>
[ 'high', 'low' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'hello\t\n everyone'</span>.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-regexp">/\s/g</span>, <span class="hljs-string">'-'</span>)</span>
'hello---everyone'
</pre>
<h4 id="unicode-property-escapes"><a class="heading-id-link" href="#unicode-property-escapes">46.5.2â€ƒUnicode property escapes: <code>\p{}</code> and <code>\P{}</code></a></h4>
<p>Unicode property escapes look like this:</p>
<ul>
  <li>
    Positive escape: <code>\p{UP}</code> matches Unicode characters or Unicode strings that have the Unicode property <code>UP</code>.
  </li>
  <li>
    Negative escape: <code>\P{UP}</code> matches Unicode characters that do not have the Unicode property <code>UP</code>.
  </li>
</ul>
<p>There are two kinds of Unicode properties:</p>
<ul>
  <li>
    <p><em>Unicode character properties</em> are properties of code points. They specify sets of code points.</p>
    <ul>
      <li>
        Example: <code>White_Space</code>
      </li>
      <li>
        Supported by flag <code>/u</code> and flag <code>/v</code>
      </li>
      <li>
        Introduced in ES2018
      </li>
    </ul>
  </li>
  <li>
    <p><em>Unicode string properties</em> are properties of sequences of code points. They specify sets of code point strings. String property escapes can only be positive.</p>
    <ul>
      <li>
        Example: <code>RGI_Emoji</code>
      </li>
      <li>
        Only supported by flag <code>/v</code>
      </li>
      <li>
        Introduced in ES2024
      </li>
    </ul>
  </li>
</ul>
<p>A quick example before we look at everything in more detail. This is how we can escape the Unicode character property <code>White_Space</code>:</p>
<pre class="language-js">
<span class="hljs-comment">// Match all code points that are whitespace</span>
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-string">'a\tb c'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\p{White_Space}/g</span>v),
  [<span class="hljs-string">'\t'</span>, <span class="hljs-string">' '</span>]
);
<code/>
<span class="hljs-comment">// Match all code points that are not whitespace</span>
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-string">'a\tb c'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\P{White_Space}/g</span>v),
  [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]
);
</pre>
<h4 id="unicode-character-property-escapes"><a class="heading-id-link" href="#unicode-character-property-escapes">46.5.3â€ƒUnicode character property escapes<span> <sup>ES2018</sup></span></a></h4>
<p>With flag <code>/u</code> or flag <code>/v</code>, we can use <code>\p{}</code> and <code>\P{}</code> to specify sets of code points via <em>Unicode character properties</em> (weâ€™ll learn more about those in the next subsection). That looks like this:</p>
<ol>
  <li>
    <code>\p{prop=value}</code>: matches all characters whose Unicode character property <code>prop</code> has the value <code>value</code>.
  </li>
  <li>
    <code>\P{prop=value}</code>: matches all characters that do not have a Unicode character property <code>prop</code> whose value is <code>value</code>.
  </li>
  <li>
    <code>\p{bin_prop}</code>: matches all characters whose binary Unicode character property <code>bin_prop</code> is True.
  </li>
  <li>
    <code>\P{bin_prop}</code>: matches all characters whose binary Unicode character property <code>bin_prop</code> is False.
  </li>
</ol>
<p>Comments:</p>
<ul>
  <li>
    <p>Forms (3) and (4) can be used as abbreviations if the property is <code>General_Category</code>. For example, the following two escapes are equivalent:</p>
<pre class="language-txt">
\p{Uppercase_Letter}
\p{General_Category=Uppercase_Letter}
</pre>
  </li>
  <li>
    <p>Without the flags <code>/u</code> and <code>/v</code>, <code>\p</code> is the same as <code>p</code>.</p>
  </li>
</ul>
<p>Examples:</p>
<ul>
  <li>
    <p>Checking for whitespace:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\p{<span class="hljs-title class_">White</span>_Space}+$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'\t \n\r'</span>)</span>
true
</pre>
  </li>
  <li>
    <p>Checking for Greek letters:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\p{<span class="hljs-title class_">Script</span>=<span class="hljs-title class_">Greek</span>}+$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'Î¼ÎµÏ„Î¬'</span>)</span>
true
</pre>
  </li>
  <li>
    <p>Deleting any letters:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'1Ï€2Ã¼3Ã©4'</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\p{Letter}/g</span>v, <span class="hljs-string">''</span>)</span>
'1234'
</pre>
  </li>
  <li>
    <p>Deleting lowercase letters:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'AbCdEf'</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\p{Lowercase_Letter}/g</span>v, <span class="hljs-string">''</span>)</span>
'ACE'
</pre>
  </li>
</ul>
<h5 id="unicode-character-properties"><a class="heading-id-link" href="#unicode-character-properties">46.5.3.1â€ƒUnicode character properties</a></h5>
<p>In the Unicode standard, each character has <em>properties</em> â€“ metadata describing it. Properties play an important role in defining the nature of a character. Quoting <a href="http://www.unicode.org/versions/Unicode9.0.0/ch03.pdf">the Unicode Standard, Sect. 3.3, D3</a>:</p>
<blockquote>
  <p>The semantics of a character are determined by its identity, normative properties, and behavior.</p>
</blockquote>
<p>These are a few examples of properties:</p>
<ul>
  <li>
    <code>Name</code>: a unique name, composed of uppercase letters, digits, hyphens, and spaces â€“ for example:
    <ul>
      <li>
        A: <code>Name = LATIN CAPITAL LETTER A</code>
      </li>
      <li>
        ğŸ™‚: <code>Name = SLIGHTLY SMILING FACE</code>
      </li>
    </ul>
  </li>
  <li>
    <code>General_Category</code>: categorizes characters â€“ for example:
    <ul>
      <li>
        x: <code>General_Category = Lowercase_Letter</code>
      </li>
      <li>
        3: <code>General_Category = Number</code>
      </li>
      <li>
        $: <code>General_Category = Currency_Symbol</code>
      </li>
    </ul>
  </li>
  <li>
    <code>White_Space</code>: used for marking invisible spacing characters, such as spaces, tabs and newlines â€“ for example:
    <ul>
      <li>
        \t: <code>White_Space = True</code>
      </li>
      <li>
        Ï€: <code>White_Space = False</code>
      </li>
    </ul>
  </li>
  <li>
    <code>Age</code>: version of the Unicode Standard in which a character was introduced â€“ for example: The Euro sign â‚¬ was added in version 2.1 of the Unicode standard.
    <ul>
      <li>
        â‚¬: <code>Age = 2.1</code>
      </li>
    </ul>
  </li>
  <li>
    <code>Block</code>: a contiguous range of code points. Blocks donâ€™t overlap and their names are unique. For example:
    <ul>
      <li>
        S: <code>Block = Basic_Latin</code> (range 0x0000..0x007F)
      </li>
      <li>
        ğŸ™‚: <code>Block = Emoticons</code> (range 0x1F600..0x1F64F)
      </li>
    </ul>
  </li>
  <li>
    <code>Script</code>: is a collection of characters used by one or more writing systems.
    <ul>
      <li>
        Some scripts support several writing systems. For example, the Latin script supports the writing systems English, French, German, Latin, etc.
      </li>
      <li>
        Some languages can be written in multiple alternate writing systems that are supported by multiple scripts. For example, Turkish used the Arabic script before it transitioned to the Latin script in the early 20th century.
      </li>
      <li>
        Examples:
        <ul>
          <li>
            Î±: <code>Script = Greek</code>
          </li>
          <li>
            Ğ”: <code>Script = Cyrillic</code>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p>Further reading:</p>
<ul>
  <li>
    Lists of Unicode properties and their values: <a href="https://unicode.org/reports/tr44/#Properties">â€œUnicode Standard Annex #44: Unicode Character Databaseâ€</a> (Editors: Mark Davis, LaurenÈ›iu Iancu, Ken Whistler)
  </li>
</ul>
<h4 id="unicode-string-property-escapes"><a class="heading-id-link" href="#unicode-string-property-escapes">46.5.4â€ƒUnicode string property escapes<span> <sup>ES2024</sup></span></a></h4>
<p>Only flag <code>/v</code> lets us use <code>\p{}</code> to specify sets of code point sequences via <em>Unicode string properties</em> (negation via <code>\P{}</code> is not supported). For example, <code>RGI_Emoji</code> is a Unicode string property:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\p{RGI_Emoji}$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'â›”'</span>) <span class="hljs-comment">// 1 code point (1 code unit)</span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\p{RGI_Emoji}$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'ğŸ™‚'</span>) <span class="hljs-comment">// 1 code point (2 code units)</span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\p{RGI_Emoji}$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'ğŸ˜µâ€ğŸ’«'</span>) <span class="hljs-comment">// 3 code points</span></span>
true
</pre>
<p>Letâ€™s see how the Unicode character property <code>Emoji</code> does with these inputs:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\p{<span class="hljs-title class_">Emoji</span>}$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'â›”'</span>) <span class="hljs-comment">// 1 code point (1 code unit)</span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\p{<span class="hljs-title class_">Emoji</span>}$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'ğŸ™‚'</span>) <span class="hljs-comment">// 1 code point (2 code units)</span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\p{<span class="hljs-title class_">Emoji</span>}$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'ğŸ˜µâ€ğŸ’«'</span>) <span class="hljs-comment">// 3 code points</span></span>
false
</pre>
<p>As expected, it only matches single code points.</p>
<h5 id="unicode-string-properties"><a class="heading-id-link" href="#unicode-string-properties">46.5.4.1â€ƒUnicode string properties</a></h5>
<p>For now, only the following Unicode string properties are supported by JavaScript:</p>
<ul>
  <li>
    <code>Basic_Emoji</code>: single code points
  </li>
  <li>
    <code>Emoji_Keycap_Sequence</code>
  </li>
  <li>
    <code>RGI_Emoji_Modifier_Sequence</code>
  </li>
  <li>
    <code>RGI_Emoji_Flag_Sequence</code>
  </li>
  <li>
    <code>RGI_Emoji_Tag_Sequence</code>
  </li>
  <li>
    <code>RGI_Emoji_ZWJ_Sequence</code>
  </li>
  <li>
    <code>RGI_Emoji</code>: union of all of the above sets
  </li>
</ul>
<p>The semantics of Unicode string properties are defined in <a href="https://www.unicode.org/reports/tr51/#Emoji_Properties_and_Data_Files">text files</a> that enumerate code point sequences likes this (<code>\x{23}</code> is <code>#</code>):</p>
<pre>
0023 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: \x{23}
002A FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: *
0030 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 0
0031 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 1
0032 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 2
0033 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 3
0034 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 4
0035 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 5
0036 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 6
0037 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 7
0038 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 8
0039 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 9
</pre>
<p>Further reading:</p>
<ul>
  <li>
    <p><a href="https://www.unicode.org/reports/tr23/#PropertyStringsDefinitions">Section â€œProperties of Stringsâ€</a> in â€œUnicode Technical Report #23: The Unicode Character Property Modelâ€ defines what properties of strings are.</p>
  </li>
  <li>
    <p><a href="https://tc39.es/ecma262/#table-binary-unicode-properties-of-strings">Table â€œBinary Unicode properties of stringsâ€</a> in the ECMAScript specification lists the properties of strings that are supported by JavaScript.</p>
  </li>
</ul>
<h3 id="syntax-character-classes"><a class="heading-id-link" href="#syntax-character-classes">46.6â€ƒSyntax: character classes</a></h3>
<p>A <em>character class</em> wraps <em>class ranges</em> in square brackets. The class ranges specify a set of characters:</p>
<ul>
  <li>
    <code>[Â«class rangesÂ»]</code> matches any character in the set.
  </li>
  <li>
    <code>[^Â«class rangesÂ»]</code> matches any character not in the set.
  </li>
</ul>
<p>Rules for class ranges:</p>
<ul>
  <li>
    <p>Non-syntax characters stand for themselves: <code>[abc]</code></p>
  </li>
  <li>
    <p>What characters must be escaped depends on the flags:</p>
    <ul>
      <li>
        <p>Flag <code>/v</code>: Some of the following characters only have to be escaped if they appear twice, but itâ€™s easier to always escape them. For details, see <a href="#escaping-inside-character-classes">â€œEscaping inside character classes (<code>[Â·Â·Â·]</code>)â€ (Â§46.2.3)</a>.</p>
        <ul>
          <li>
            <p><a href="https://tc39.es/ecma262/#prod-SyntaxCharacter">Syntax Characters</a>:</p>
<pre>
^ $ \ . * + ? ( ) [ ] { } |
</pre>
          </li>
          <li>
            <p>Slash:</p>
<pre>
/
</pre>
          </li>
          <li>
            <p><a href="https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator">Class Set Reserved Punctuators</a>:</p>
<pre>
&amp; - ! # % , : ; &lt; = &gt; @ ` ~
</pre>
          </li>
        </ul>
      </li>
      <li>
        <p>No Unicode flag (neither <code>/v</code> nor <code>/u</code>):</p>
        <ul>
          <li>
            <p>We always must escape: <code>\ ]</code></p>
          </li>
          <li>
            <p>Some characters only have to be escaped in some locations:</p>
            <ul>
              <li>
                <code>^</code> only has to be escaped if it comes first.
              </li>
              <li>
                <code>-</code> only has to be escaped if it doesnâ€™t come first or last.
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Character escapes (<code>\n</code>, <code>\x20</code>, <code>\u{1F44D}</code>, etc.) have the usual meanings.</p>
    <ul>
      <li>
        Watch out: <code>\b</code> stands for backspace. Elsewhere in a regular expression, it matches word boundaries.
      </li>
    </ul>
  </li>
  <li>
    <p>Character class escapes (<code>\d</code>, <code>\P{White_Space}</code>, <code>\p{RGI_Emoji}</code>, etc.) have the usual meanings.</p>
  </li>
  <li>
    <p>A range of characters is specified via a dash: <code>[a-z]</code></p>
  </li>
</ul>
<h4 id="character-class-code-point-sequences"><a class="heading-id-link" href="#character-class-code-point-sequences">46.6.1â€ƒCode point sequences in character classes<span> <sup>ES2024</sup></span></a></h4>
<p><span id="index-entry-class-string-disjunction"/>
<span id="index-entry-string-literal--regular-expression"/>
<span id="index-entry-regular-expression-string-literal"/></p>
<p>With flag <code>/v</code>, we can use <code>\q{}</code> to add code point sequences to the set defined by a character class. This syntax is also called:</p>
<ul>
  <li>
    <em>Class string disjunction</em> (by <a href="https://tc39.es/ecma262/#prod-ClassStringDisjunction">the ECMAScript specification</a>)
  </li>
  <li>
    <em>String literal</em> (by <a href="https://github.com/tc39/proposal-regexp-v-flag">the ECMAScript proposal for flag <code>/v</code></a>)
  </li>
</ul>
<p>This is an example of using <code>\q{}</code>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\q{ğŸ˜µâ€ğŸ’«}]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'ğŸ˜µâ€ğŸ’«'</span>)</span>
true
</pre>
<p>Without <code>\q{}</code>, a <a href="ch_unicode.html#grapheme-clusters">grapheme cluster</a> with multiple code points is still treated as multiple characters:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[ğŸ˜µâ€ğŸ’«]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'ğŸ˜µâ€ğŸ’«'</span>)</span>
false
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\u{1F635}\u{200D}\u{1F4AB}]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'ğŸ˜µâ€ğŸ’«'</span>) <span class="hljs-comment">// equivalent</span></span>
false
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[ğŸ˜µâ€ğŸ’«]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'\u{1F635}'</span>)</span>
true
</pre>
<p>We can use a single <code>\q{}</code> to add multiple code point sequences â€“ if we separate them with pipes:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\q{abc|def}]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'abc'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\q{abc|def}]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'def'</span>)</span>
true
</pre>
<h4 id="regexp-character-class-set-operations"><a class="heading-id-link" href="#regexp-character-class-set-operations">46.6.2â€ƒSet operations for character classes<span> <sup>ES2024</sup></span></a></h4>
<p>Flag <code>/v</code> enables set operations for character classes.</p>
<h5 id="nesting-character-classes"><a class="heading-id-link" href="#nesting-character-classes">46.6.2.1â€ƒNesting character classes</a></h5>
<p>To enable set operations for character classes, we must be able to nest them. Character class escapes already provide some kind of nesting:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\d\w]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'7'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\d\w]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'H'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\d\w]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'?'</span>)</span>
false
</pre>
<p>With flag <code>/v</code>, we can additionally nest character classes (the regular expression below is equivalent to the regular expression in the previous example):</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>][A-<span class="hljs-title class_">Za</span>-z0-9_]]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'7'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>][A-<span class="hljs-title class_">Za</span>-z0-9_]]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'H'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>][A-<span class="hljs-title class_">Za</span>-z0-9_]]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'?'</span>)</span>
false
</pre>
<h5 id="subtraction-of-character-sets-via-"><a class="heading-id-link" href="#subtraction-of-character-sets-via-">46.6.2.2â€ƒSubtraction of character sets via <code>--</code></a></h5>
<p>We can use the <code>--</code> operator to set-theoretically subtract the character sets defined by character classes or character class escapes:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\w--[a-g]]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'a'</span>)</span>
false
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\w--[a-g]]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'h'</span>)</span>
true
<code/>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\p{<span class="hljs-title class_">Number</span>}--[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'Ù£'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\p{<span class="hljs-title class_">Number</span>}--[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'3'</span>)</span>
false
<code/>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\p{RGI_Emoji}--\q{ğŸ˜µâ€ğŸ’«}]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'ğŸ˜µâ€ğŸ’«'</span>) <span class="hljs-comment">// emoji has 3 code points</span></span>
false
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\p{RGI_Emoji}--\q{ğŸ˜µâ€ğŸ’«}]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'ğŸ™‚'</span>)</span>
true
</pre>
<p>Single code points can also be used on either side of the <code>--</code> operator:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\w--a]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'a'</span>)</span>
false
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\w--a]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'b'</span>)</span>
true
</pre>
<h5 id="intersection-of-character-sets-via-"><a class="heading-id-link" href="#intersection-of-character-sets-via-">46.6.2.3â€ƒIntersection of character sets via <code>&amp;&amp;</code></a></h5>
<p>We can use the <code>&amp;&amp;</code> operator to set-theoretically intersect the character sets defined by character classes or character class escapes:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/[\p{<span class="hljs-variable constant_">ASCII</span>}&amp;&amp;\p{<span class="hljs-title class_">Letter</span>}]/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'D'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/[\p{<span class="hljs-variable constant_">ASCII</span>}&amp;&amp;\p{<span class="hljs-title class_">Letter</span>}]/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'Î”'</span>)</span>
false
<code/>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\p{<span class="hljs-title class_">Script</span>=<span class="hljs-title class_">Arabic</span>}&amp;&amp;\p{<span class="hljs-title class_">Number</span>}]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'Ù£'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\p{<span class="hljs-title class_">Script</span>=<span class="hljs-title class_">Arabic</span>}&amp;&amp;\p{<span class="hljs-title class_">Number</span>}]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'Ø¬'</span>)</span>
false
</pre>
<h5 id="union-of-characters-sets"><a class="heading-id-link" href="#union-of-characters-sets">46.6.2.4â€ƒUnion of characters sets</a></h5>
<p>Two compute the set-theoretical union of character sets, we only need to write their definining constructs next to each other inside a character class:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\p{<span class="hljs-title class_">Emoji</span>_Keycap_Sequence}[a-z]]+$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'a2ï¸âƒ£c'</span>)</span>
true
</pre>
<h3 id="regexp-capture-groups"><a class="heading-id-link" href="#regexp-capture-groups">46.7â€ƒSyntax: capture groups</a></h3>
<ul>
  <li>
    Numbered capture group: <code>(a+)</code>
    <ul>
      <li>
        Backreference: <code>\1</code>, <code>\2</code>, etc.
      </li>
    </ul>
  </li>
  <li>
    Named capture group <sup>ES2018</sup>: <code>(?&lt;as&gt;a+)</code>
    <ul>
      <li>
        Backreference: <code>\k&lt;as&gt;</code>
      </li>
    </ul>
  </li>
  <li>
    Noncapturing group: <code>(?:a+)</code>
  </li>
</ul>
<h3 id="regexp-quantifiers"><a class="heading-id-link" href="#regexp-quantifiers">46.8â€ƒSyntax: quantifiers</a></h3>
<p>By default, all of the following quantifiers are <em>greedy</em> (they match as many characters as possible):</p>
<ul>
  <li>
    <code>?</code>: match never or once
  </li>
  <li>
    <code>*</code>: match zero or more times
  </li>
  <li>
    <code>+</code>: match one or more times
  </li>
  <li>
    <code>{n}</code>: match <code>n</code> times
  </li>
  <li>
    <code>{n,}</code>: match <code>n</code> or more times
  </li>
  <li>
    <code>{n,m}</code>: match at least <code>n</code> times, at most <code>m</code> times.
  </li>
</ul>
<p>To make them <em>reluctant</em> (so that they match as few characters as possible), put question marks (<code>?</code>) after them:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/X.*X/.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'XabcXdefX'</span>)[<span class="hljs-number">0</span>]  <span class="hljs-comment">// greedy</span></span>
'XabcXdefX'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/X.*?X/.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'XabcXdefX'</span>)[<span class="hljs-number">0</span>] <span class="hljs-comment">// reluctant</span></span>
'XabcX'
</pre>
<h3 id="regexp-assertions"><a class="heading-id-link" href="#regexp-assertions">46.9â€ƒSyntax: assertions</a></h3>
<ul>
  <li>
    <code>^</code> matches only at the beginning of the input
  </li>
  <li>
    <code>$</code> matches only at the end of the input
  </li>
  <li>
    <code>\b</code> matches only at a word boundary
    <ul>
      <li>
        <code>\B</code> matches only when not at a word boundary
      </li>
    </ul>
  </li>
</ul>
<p>Overview of available lookaround assertions:</p>
<table class="framed">
  <style>
    th:nth-child(1), td:nth-child(1) {
      text-align: left;
    }
    th:nth-child(2), td:nth-child(2) {
      text-align: left;
    }
    th:nth-child(3), td:nth-child(3) {
      text-align: left;
    }
  </style>
  <thead>
    <tr>
      <th>Pattern</th><th>Name</th><th/>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>(?=Â«patternÂ»)</code></td><td>Positive lookahead</td><td>ES3</td>
    </tr>
    <tr>
      <td><code>(?!Â«patternÂ»)</code></td><td>Negative lookahead</td><td>ES3</td>
    </tr>
    <tr>
      <td><code>(?&lt;=Â«patternÂ»)</code></td><td>Positive lookbehind</td><td>ES2018</td>
    </tr>
    <tr>
      <td><code>(?&lt;!Â«patternÂ»)</code></td><td>Negative lookbehind</td><td>ES2018</td>
    </tr>
  </tbody>
</table>
<h4 id="regexp-lookahead-assertions"><a class="heading-id-link" href="#regexp-lookahead-assertions">46.9.1â€ƒLookahead assertions</a></h4>
<p><strong>Positive lookahead:</strong> <code>(?=Â«patternÂ»)</code> matches if <code>pattern</code> matches what comes next.</p>
<p>Example: sequences of lowercase letters that are followed by an <code>X</code>. </p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'abcX def'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/[a-z]+(?=X)/g</span>)</span>
[ 'abc' ]
</pre>
<p>Note that the <code>X</code> itself is not part of the matched substring.</p>
<p><strong>Negative lookahead:</strong> <code>(?!Â«patternÂ»)</code> matches if <code>pattern</code> does not match what comes next.</p>
<p>Example: sequences of lowercase letters that are not followed by an <code>X</code>.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'abcX def'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/[a-z]+(?!X)/g</span>)</span>
[ 'ab', 'def' ]
</pre>
<h4 id="regexp-lookbehind-assertions"><a class="heading-id-link" href="#regexp-lookbehind-assertions">46.9.2â€ƒLookbehind assertions<span> <sup>ES2018</sup></span></a></h4>
<p><strong>Positive lookbehind:</strong> <code>(?&lt;=Â«patternÂ»)</code> matches if <code>pattern</code> matches what came before.</p>
<p>Example: sequences of lowercase letters that are preceded by an <code>X</code>.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'Xabc def'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/(?&lt;=X)[a-z]+/g</span>)</span>
[ 'abc' ]
</pre>
<p><strong>Negative lookbehind:</strong> <code>(?&lt;!Â«patternÂ»)</code> matches if <code>pattern</code> does not match what came before.</p>
<p>Example: sequences of lowercase letters that are not preceded by an <code>X</code>.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'Xabc def'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/(?&lt;!X)[a-z]+/g</span>)</span>
[ 'bc', 'def' ]
</pre>
<p>Example: replace â€œ.jsâ€ with â€œ.htmlâ€, but not in â€œNode.jsâ€.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'Node.js: index.js and main.js'</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(?&lt;!Node)\.js/g</span>, <span class="hljs-string">'.html'</span>)</span>
'Node.js: index.html and main.html'
</pre>
<h3 id="syntax-disjunction-"><a class="heading-id-link" href="#syntax-disjunction-">46.10â€ƒSyntax: disjunction (<code>|</code>)</a></h3>
<p>Caveat: this operator has low precedence (binds very weakly). Use groups if necessary:</p>
<ul>
  <li>
    <code>^aa|zz$</code> matches all strings that start with <code>aa</code> and/or end with <code>zz</code>.
    <ul>
      <li>
        Note that <code>|</code> has a lower precedence than <code>^</code> and <code>$</code>.
      </li>
    </ul>
  </li>
  <li>
    <code>^(aa|zz)$</code> matches the two strings <code>'aa'</code> and <code>'zz'</code>.
  </li>
  <li>
    <code>^a(a|z)z$</code> matches the two strings <code>'aaz'</code> and <code>'azz'</code>.
  </li>
</ul>
<h3 id="regexp-flags"><a class="heading-id-link" href="#regexp-flags">46.11â€ƒRegular expression flags</a></h3>
<figure id="tbl:reg-exp-flags-table" class="float">
  <table class="framed">
    <style>
      th:nth-child(1), td:nth-child(1) {
        text-align: left;
      }
      th:nth-child(2), td:nth-child(2) {
        text-align: left;
      }
      th:nth-child(3), td:nth-child(3) {
        text-align: left;
      }
      th:nth-child(4), td:nth-child(4) {
        text-align: left;
      }
    </style>
    <thead>
      <tr>
        <th>Literal flag</th><th>Property name</th><th>ES</th><th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>d</code></td><td><code>hasIndices</code></td><td>ES2022</td><td>Switch on match indices</td>
      </tr>
      <tr>
        <td><code>g</code></td><td><code>global</code></td><td>ES3</td><td>Match multiple times</td>
      </tr>
      <tr>
        <td><code>i</code></td><td><code>ignoreCase</code></td><td>ES3</td><td>Match case-insensitively</td>
      </tr>
      <tr>
        <td><code>m</code></td><td><code>multiline</code></td><td>ES3</td><td><code>^</code> and <code>$</code> match per line</td>
      </tr>
      <tr>
        <td><code>s</code></td><td><code>dotAll</code></td><td>ES2018</td><td>Dot matches line terminators</td>
      </tr>
      <tr>
        <td><code>u</code></td><td><code>unicode</code></td><td>ES6</td><td>Unicode mode</td>
      </tr>
      <tr>
        <td><code>v</code></td><td><code>unicodeSets</code></td><td>ES2024</td><td>Unicode sets mode (<strong>recommended</strong>)</td>
      </tr>
      <tr>
        <td><code>y</code></td><td><code>sticky</code></td><td>ES6</td><td>No characters between matches</td>
      </tr>
    </tbody>
  </table>
  <figcaption>
    <p><span class="float-label">Table 46.1:</span> These are the regular expression flags supported by JavaScript.</p>
  </figcaption>
</figure>
<p>The following regular expression flags are available in JavaScript (<a href="#tbl:reg-exp-flags-table">table 46.1</a> provides a compact overview):</p>
<ul>
  <li>
    <p><code>/d</code> (<code>.hasIndices</code>): Some RegExp-related methods return <em>match objects</em> that describe where the regular expression matched in an input string. If this flag is on, each match object includes <em>match indices</em> which tell us where each group capture starts and ends. More information: <a href="#regexp-match-indices">â€œMatch indices in match objects<span> <sup>ES2022</sup></span>â€ (Â§46.14.1)</a>.</p>
  </li>
  <li>
    <p><code>/g</code> (<code>.global</code>) fundamentally changes how the following methods work.</p>
    <ul>
      <li>
        <code>String.prototype.match()</code>
      </li>
      <li>
        <code>RegExp.prototype.exec()</code>
      </li>
      <li>
        <code>RegExp.prototype.test()</code>
      </li>
    </ul>
    <p>How, is explained in <a href="#regexp-flags-gy">â€œThe flags <code>/g</code> and <code>/y</code>, and the property <code>.lastIndex</code><span> (advanced)</span>â€ (Â§46.16)</a>. In a nutshell: Without <code>/g</code>, the methods only consider the first match for a regular expression in an input string. With <code>/g</code>, they consider all matches.</p>
  </li>
  <li>
    <p><code>/i</code> (<code>.ignoreCase</code>) switches on case-insensitive matching:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/a/.<span class="hljs-title function_">test</span>(<span class="hljs-string">'A'</span>)</span>
false
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/a/i.<span class="hljs-title function_">test</span>(<span class="hljs-string">'A'</span>)</span>
true
</pre>
  </li>
  <li>
    <p><code>/m</code> (<code>.multiline</code>): If this flag is on, <code>^</code> matches the beginning of each line and <code>$</code> matches the end of each line. If it is off, <code>^</code> matches the beginning of the whole input string and <code>$</code> matches the end of the whole input string.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'a1\na2\na3'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^a./gm</span>)</span>
[ 'a1', 'a2', 'a3' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'a1\na2\na3'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^a./g</span>)</span>
[ 'a1' ]
</pre>
  </li>
  <li>
    <p><span id="regexp-dot-all-flag"><code>/s</code> (<code>.dotAll</code>)</span>: By default, the dot does not match line terminators. With this flag, it does:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/./.<span class="hljs-title function_">test</span>(<span class="hljs-string">'\n'</span>)</span>
false
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/./s.<span class="hljs-title function_">test</span>(<span class="hljs-string">'\n'</span>)</span>
true
</pre>
    <p>Workaround: If <code>/s</code> isnâ€™t supported, we can use <code>[^]</code> instead of a dot.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/[^]/.<span class="hljs-title function_">test</span>(<span class="hljs-string">'\n'</span>)</span>
true
</pre>
  </li>
  <li>
    <p>Better support for Unicode (the â€œUnicode flagsâ€):</p>
    <ul>
      <li>
        <p><code>/u</code> (<code>.unicode</code>): By default, the atomic units of matching are JavaScript characters (Unicode code units). This flag switches to Unicode code points as atomic units. It is explained in <a href="#regexp-flag-unicode">â€œFlag <code>/u</code>: characters are code points<span> <sup>ES6</sup></span>â€ (Â§46.11.3)</a>.</p>
      </li>
      <li>
        <p><code>/v</code> (<code>.unicodeSets</code>): This flag improves and replaces flag <code>/u</code>. It supports multi-code-point grapheme clusters and set operations in character classes. It is explained in <a href="#regexp-flag-unicode-sets">â€œFlag <code>/v</code>: limited support for multi-code-point grapheme clusters<span> <sup>ES2024</sup></span>â€ (Â§46.11.4)</a>. <strong>I recommend to use flag <code>/v</code> with all regular expressions</strong> â€“ due to all the features it enables.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><code>/y</code> (<code>.sticky</code>): This flag mainly makes sense in conjunction with <code>/g</code>. When both are switched on, any match must directly follow the previous one (that is, it must start at index <code>.lastIndex</code> of the regular expression object). Therefore, the first match must be at index 0.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'a1a2 a3'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/a./gy</span>)</span>
[ 'a1', 'a2' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'_a1a2 a3'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/a./gy</span>) <span class="hljs-comment">// first match must be at index 0</span></span>
null
<code/>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'a1a2 a3'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/a./g</span>)</span>
[ 'a1', 'a2', 'a3' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'_a1a2 a3'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/a./g</span>)</span>
[ 'a1', 'a2', 'a3' ]
</pre>
    <p>The main use case for <code>/y</code> is tokenization (during parsing). More information on this flag: <a href="#regexp-flags-gy">â€œThe flags <code>/g</code> and <code>/y</code>, and the property <code>.lastIndex</code><span> (advanced)</span>â€ (Â§46.16)</a>.</p>
  </li>
</ul>
<h4 id="order-of-regexp-flags"><a class="heading-id-link" href="#order-of-regexp-flags">46.11.1â€ƒHow to order regular expression flags?</a></h4>
<p>Consider the following regular expression: <code>/â€œ([^â€]+)â€/vdg</code></p>
<p>In which order should we list its flags? Two options are:</p>
<ol>
  <li>
    Alphabetical order: <code>/dgv</code>
  </li>
  <li>
    In order of importance (arguably, <code>/v</code> is most fundamental etc.): <code>/vgd</code>
  </li>
</ol>
<p>Given that (2) is not obvious, (1) is the better choice. JavaScript also uses it for the RegExp property <code>.flags</code> :</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/-/gymdivs.<span class="hljs-property">flags</span></span>
'dgimsvy'
</pre>
<h4 id="without-the-unicode-flags-u-and-v-characters-are-utf16-code-units"><a class="heading-id-link" href="#without-the-unicode-flags-u-and-v-characters-are-utf16-code-units">46.11.2â€ƒWithout the Unicode flags <code>/u</code> and <code>/v</code>: characters are UTF-16 code units</a></h4>
<p>Without the Unicode flags <code>/u</code> and <code>/v</code>, most constructs work with single UTF-16 code units, which is problematic whenever a character has more than one code unit â€“ e.g. ğŸ™‚:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'ğŸ™‚'</span>.<span class="hljs-property">length</span></span>
2
</pre>
<p>Without Unicode flags, the largest character we can escape is a code unit, via a <em>code unit escape</em>. It consists of <code>\u</code> followed by four hexadecimal digits:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\uD83D\uDE42$/.<span class="hljs-title function_">test</span>(<span class="hljs-string">'ğŸ™‚'</span>)</span>
true
</pre>
<p>The dot operator (<code>.</code>) matches code units, which is why we get two matches instead of one:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'ğŸ™‚'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/./g</span>)</span>
[ '\uD83D', '\uDE42' ]
</pre>
<p>Quantifiers apply to code units and therefore only repeat the second half of ğŸ™‚:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^ğŸ™‚{<span class="hljs-number">2</span>}$/.<span class="hljs-title function_">test</span>(<span class="hljs-string">'\uD83D\uDE42\uDE42'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\uD83D\uDE42{<span class="hljs-number">2</span>}$/.<span class="hljs-title function_">test</span>(<span class="hljs-string">'\uD83D\uDE42\uDE42'</span>) <span class="hljs-comment">// equivalent</span></span>
true
</pre>
<p>Character class escapes define sets of code units. Therefore, the class escape <code>\D</code> for â€œnot a decimal digitâ€ gets two matches:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'ğŸ™‚'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\D/g</span>)</span>
[ '\uD83D', '\uDE42' ]
</pre>
<p>Character classes define sets of code units. Therefore, putting ğŸ™‚ in a character class has unintuitive consequences:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[ğŸ™‚]$/.<span class="hljs-title function_">test</span>(<span class="hljs-string">'ğŸ™‚'</span>)</span>
false
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\uD83D\uDE42]$/.<span class="hljs-title function_">test</span>(<span class="hljs-string">'\uD83D\uDE42'</span>) <span class="hljs-comment">// equivalent</span></span>
false
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[ğŸ™‚]$/.<span class="hljs-title function_">test</span>(<span class="hljs-string">'\uD83D'</span>)</span>
true
</pre>
<h4 id="regexp-flag-unicode"><a class="heading-id-link" href="#regexp-flag-unicode">46.11.3â€ƒFlag <code>/u</code>: characters are code points<span> <sup>ES6</sup></span></a></h4>
<p>In the previous subsection, we encountered problems when we wanted to match a code point with more than one UTF-16 code unit â€“ such as ğŸ™‚. Flag <code>/u</code> enables support for code points and fixes those problems.</p>
<p>We can escape code points via <em>code point escapes</em> â€“ <code>\u{}</code> with one to six hexadecimal digits:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\u{1F642}$/u.<span class="hljs-title function_">test</span>(<span class="hljs-string">'ğŸ™‚'</span>)</span>
true
</pre>
<p>The dot operator (<code>.</code>) matches code points:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'ğŸ™‚'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/./gu</span>)</span>
[ 'ğŸ™‚' ]
</pre>
<p>Quantifiers apply to code points:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^ğŸ™‚{<span class="hljs-number">2</span>}$/u.<span class="hljs-title function_">test</span>(<span class="hljs-string">'ğŸ™‚ğŸ™‚'</span>)</span>
true
</pre>
<p>Character class escapes define sets of code points:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'ğŸ™‚'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\D/gu</span>)</span>
[ 'ğŸ™‚' ]
</pre>
<p>A new kind of character class escapes is supported â€“ <a href="#unicode-character-property-escapes">Unicode character property escapes</a> specify sets of code points:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\p{<span class="hljs-title class_">Emoji</span>}$/u.<span class="hljs-title function_">test</span>(<span class="hljs-string">'â›”'</span>) <span class="hljs-comment">// 1 code point (1 code unit)</span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\p{<span class="hljs-title class_">Emoji</span>}$/u.<span class="hljs-title function_">test</span>(<span class="hljs-string">'ğŸ™‚'</span>) <span class="hljs-comment">// 1 code point (2 code units)</span></span>
true
</pre>
<p>Character classes also define sets of code points:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[ğŸ™‚]$/u.<span class="hljs-title function_">test</span>(<span class="hljs-string">'ğŸ™‚'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[ğŸ™‚]$/u.<span class="hljs-title function_">test</span>(<span class="hljs-string">'\uD83D'</span>)</span>
false
</pre>
<h4 id="regexp-flag-unicode-sets"><a class="heading-id-link" href="#regexp-flag-unicode-sets">46.11.4â€ƒFlag <code>/v</code>: limited support for multi-code-point grapheme clusters<span> <sup>ES2024</sup></span></a></h4>
<div class="boxout">
  <p><img src="../Images/8440b17bb8219cda9f9405ac83c36db0.png" class="boxout-icon" height="24" alt="Icon â€œtipâ€" data-original-src="https://exploringjs.com/js/book/icon/tip.svg"/>â€‚<strong>Use flag <code>/v</code> whenever you can</strong></p>
  <div class="boxout-vspace"/>
  <p>This flag improves many aspects of JavaScriptâ€™s regular expressions and should be used by default. If a platform doesnâ€™t support it yet, you should at least use <code>/u</code>.</p>
</div>
<ul>
  <li>
    <p>Flag <code>/v</code> builds on the improvements brought by flag <code>/u</code> and fixes several of its shortcomings.</p>
  </li>
  <li>
    <p>Note that flag <code>/v</code> and flag <code>/u</code> are mutually exclusive â€“ we canâ€™t use both at the same time:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">eval</span>(<span class="hljs-string">'/-/uv'</span>),
  <span class="hljs-title class_">SyntaxError</span>
);
</pre>
  </li>
</ul>
<h5 id="limitation-of-flag-u-handling-grapheme-clusters-with-more-than-one-code-point"><a class="heading-id-link" href="#limitation-of-flag-u-handling-grapheme-clusters-with-more-than-one-code-point">46.11.4.1â€ƒLimitation of flag <code>/u</code>: handling grapheme clusters with more than one code point</a></h5>
<p>Some font glyphs are represented by <em>grapheme clusters</em> (code point sequences) with more than one code point â€“Â e.g. ğŸ˜µâ€ğŸ’«:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'ğŸ˜µâ€ğŸ’«'</span>).<span class="hljs-property">length</span> <span class="hljs-comment">// count code points</span></span>
3
</pre>
<p>Flag <code>/u</code> does not help us with those kinds of grapheme clusters:</p>
<pre class="language-js">
<span class="hljs-comment">// Grapheme cluster is not matched by single dot</span>
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-string">'ğŸ˜µâ€ğŸ’«'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/./gu</span>).<span class="hljs-property">length</span>, <span class="hljs-number">3</span>
);
<code/>
<span class="hljs-comment">// Quantifiers only repeat last code point of grapheme cluster</span>
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-regexp">/^ğŸ˜µâ€ğŸ’«{2}$/u</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">'ğŸ˜µâ€ğŸ’«ğŸ˜µâ€ğŸ’«'</span>), <span class="hljs-literal">false</span>
);
<code/>
<span class="hljs-comment">// Character class escapes only match single code points</span>
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-regexp">/^\p{Emoji}$/u</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">'ğŸ˜µâ€ğŸ’«'</span>), <span class="hljs-literal">false</span>
);
<code/>
<span class="hljs-comment">// Character classes only match single code points</span>
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-regexp">/^[ğŸ˜µâ€ğŸ’«]$/u</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">'ğŸ˜µâ€ğŸ’«'</span>), <span class="hljs-literal">false</span>
);
</pre>
<h5 id="flag-v-unicode-string-property-escapes-and-character-class-string-literals"><a class="heading-id-link" href="#flag-v-unicode-string-property-escapes-and-character-class-string-literals">46.11.4.2â€ƒFlag <code>/v</code>: Unicode string property escapes and character class string literals</a></h5>
<p>Flag <code>/v</code> works like flag <code>/u</code> but provides better support for multi-code-point grapheme clusters. It doesnâ€™t switch from code points to grapheme clusters everywhere, but it does fix the last two issues we encountered in the previous subsection â€“ by adding support for multi-code-point grapheme clusters to:</p>
<ul>
  <li>
    <p>Character class escapes: We can refer to <a href="#unicode-string-properties">Unicode string properties</a> via <code>\p{}</code>.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\p{RGI_Emoji}$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'â›”'</span>) <span class="hljs-comment">// 1 code point (1 code unit)</span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\p{RGI_Emoji}$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'ğŸ™‚'</span>) <span class="hljs-comment">// 1 code point (2 code units)</span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\p{RGI_Emoji}$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'ğŸ˜µâ€ğŸ’«'</span>) <span class="hljs-comment">// 3 code points</span></span>
true
</pre>
  </li>
  <li>
    <p>Character classes: <code>\q{}</code> lets us define <a href="#character-class-code-point-sequences">code point sequences</a>.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\q{ğŸ˜µâ€ğŸ’«}]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'ğŸ˜µâ€ğŸ’«'</span>)</span>
true
</pre>
  </li>
</ul>
<h5 id="flag-v-character-class-set-operations"><a class="heading-id-link" href="#flag-v-character-class-set-operations">46.11.4.3â€ƒFlag <code>/v</code>: character class set operations</a></h5>
<p>Character classes can be nested and combined via the set operations subtraction and intersection â€“ see <a href="#regexp-character-class-set-operations">â€œSet operations for character classes<span> <sup>ES2024</sup></span>â€ (Â§46.6.2)</a>.</p>
<h5 id="flag-v-improved-caseinsensitive-matching"><a class="heading-id-link" href="#flag-v-improved-caseinsensitive-matching">46.11.4.4â€ƒFlag <code>/v</code>: improved case-insensitive matching</a></h5>
<p>Flag <code>/u</code> has a quirk when it comes to case-insensitive matching: Using <code>\P{Â·Â·Â·}</code> produces different results than <code>[^\p{Â·Â·Â·}]</code>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\P{<span class="hljs-title class_">Lowercase</span>_Letter}$/iu.<span class="hljs-title function_">test</span>(<span class="hljs-string">'A'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\P{<span class="hljs-title class_">Lowercase</span>_Letter}$/iu.<span class="hljs-title function_">test</span>(<span class="hljs-string">'a'</span>)</span>
true
<code/>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[^\p{<span class="hljs-title class_">Lowercase</span>_Letter}]$/iu.<span class="hljs-title function_">test</span>(<span class="hljs-string">'A'</span>)</span>
false
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[^\p{<span class="hljs-title class_">Lowercase</span>_Letter}]$/iu.<span class="hljs-title function_">test</span>(<span class="hljs-string">'a'</span>)</span>
false
</pre>
<p>Observations:</p>
<ul>
  <li>
    Both ways of negating should produce the same results.
  </li>
  <li>
    Intuitively, if we add <code>/i</code> to a regular expression, it should match at least as many strings as before â€“ not fewer.
  </li>
</ul>
<p>Flag <code>/v</code> fixes that quirk:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\P{<span class="hljs-title class_">Lowercase</span>_Letter}$/iv.<span class="hljs-title function_">test</span>(<span class="hljs-string">'A'</span>)</span>
false
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\P{<span class="hljs-title class_">Lowercase</span>_Letter}$/iv.<span class="hljs-title function_">test</span>(<span class="hljs-string">'a'</span>)</span>
false
<code/>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[^\p{<span class="hljs-title class_">Lowercase</span>_Letter}]$/iv.<span class="hljs-title function_">test</span>(<span class="hljs-string">'A'</span>)</span>
false
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[^\p{<span class="hljs-title class_">Lowercase</span>_Letter}]$/iv.<span class="hljs-title function_">test</span>(<span class="hljs-string">'a'</span>)</span>
false
</pre>
<p>Further reading:</p>
<ul>
  <li>
    <a href="https://2ality.com/2022/11/regexp-v-flag.html#improved-case-insensitive-matching">A 2ality blog post</a> explains why <code>/u</code> causes this behavior.
  </li>
  <li>
    Source of this section: <a href="https://github.com/tc39/proposal-regexp-v-flag/issues/30">GitHub issue â€œIgnoreCase vs. complement vs. nested classâ€</a>
  </li>
</ul>
<h3 id="regexp-pattern-modifiers"><a class="heading-id-link" href="#regexp-pattern-modifiers">46.12â€ƒPattern modifiers (inline flags)<span> <sup>ES2025</sup></span></a></h3>
<p>Pattern modifiers let us apply a flag to a part of a regular expression (vs. all of the regular expression) â€“ for example, in the following regular expression, the flag <code>i</code> is only applied to â€œHELLOâ€:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^<span class="hljs-title function_">x</span>(?<span class="hljs-attr">i</span>:<span class="hljs-variable constant_">HELLO</span>)x$/.<span class="hljs-title function_">test</span>(<span class="hljs-string">'xHELLOx'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^<span class="hljs-title function_">x</span>(?<span class="hljs-attr">i</span>:<span class="hljs-variable constant_">HELLO</span>)x$/.<span class="hljs-title function_">test</span>(<span class="hljs-string">'xhellox'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^<span class="hljs-title function_">x</span>(?<span class="hljs-attr">i</span>:<span class="hljs-variable constant_">HELLO</span>)x$/.<span class="hljs-title function_">test</span>(<span class="hljs-string">'XhelloX'</span>)</span>
false
</pre>
<h4 id="the-syntax-of-pattern-modifiers"><a class="heading-id-link" href="#the-syntax-of-pattern-modifiers">46.12.1â€ƒThe syntax of pattern modifiers</a></h4>
<p>This is what the syntax looks like:</p>
<pre>
(?ims-ims:pattern)
(?ims:pattern)
(?-ims:pattern)
</pre>
<p>Notes:</p>
<ul>
  <li>
    A flag that follows the question mark (<code>?</code>) is activated.
  </li>
  <li>
    A flag that follows the hyphen (<code>-</code>) is deactivated.
  </li>
  <li>
    A flag cannot appear in both the â€œactivation sectionâ€ and the â€œdeactivation sectionâ€.
  </li>
  <li>
    Without any flags, this syntax is simply a non-capturing group: <code>(?:pattern)</code>
  </li>
</ul>
<p>Letâ€™s change the previous example: Now all of the regular expression is case-insensitive â€“ except for â€œHELLOâ€:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^<span class="hljs-title function_">x</span>(?-<span class="hljs-attr">i</span>:<span class="hljs-variable constant_">HELLO</span>)x$/i.<span class="hljs-title function_">test</span>(<span class="hljs-string">'xHELLOx'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^<span class="hljs-title function_">x</span>(?-<span class="hljs-attr">i</span>:<span class="hljs-variable constant_">HELLO</span>)x$/i.<span class="hljs-title function_">test</span>(<span class="hljs-string">'XHELLOX'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^<span class="hljs-title function_">x</span>(?-<span class="hljs-attr">i</span>:<span class="hljs-variable constant_">HELLO</span>)x$/i.<span class="hljs-title function_">test</span>(<span class="hljs-string">'XhelloX'</span>)</span>
false
</pre>
<h4 id="which-flags-are-supported"><a class="heading-id-link" href="#which-flags-are-supported">46.12.2â€ƒWhich flags are supported?</a></h4>
<p>The following flags can be used in pattern modifiers:</p>
<table class="framed">
  <style>
    th:nth-child(1), td:nth-child(1) {
      text-align: left;
    }
    th:nth-child(2), td:nth-child(2) {
      text-align: left;
    }
    th:nth-child(3), td:nth-child(3) {
      text-align: left;
    }
    th:nth-child(4), td:nth-child(4) {
      text-align: left;
    }
  </style>
  <thead>
    <tr>
      <th>Literal flag</th><th>Property name</th><th>ES</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>i</td><td>ignoreCase</td><td>ES3</td><td>Match case-insensitively</td>
    </tr>
    <tr>
      <td>m</td><td>multiline</td><td>ES3</td><td><code>^</code> and <code>$</code> match per line</td>
    </tr>
    <tr>
      <td>s</td><td>dotAll</td><td>ES2018</td><td>Dot matches line terminators</td>
    </tr>
  </tbody>
</table>
<p>For more information, see <a href="#regexp-flags">â€œRegular expression flagsâ€ (Â§46.11)</a>.</p>
<p>The remaining flags are not supported because they would either make regular expression semantics too complicated (e.g. flag <code>v</code>) or because they only make sense if applied to the whole regular expression (e.g. flag <code>g</code>).</p>
<h4 id="use-case-changing-flags-for-part-of-a-regular-expression"><a class="heading-id-link" href="#use-case-changing-flags-for-part-of-a-regular-expression">46.12.3â€ƒUse case: changing flags for part of a regular expression</a></h4>
<p>Itâ€™s sometimes useful to change flags for part of a regular expression. For example, Ron Buckton <a href="https://github.com/tc39/proposal-regexp-modifiers/issues/1">explains</a> that changing flag <code>m</code> helps with matching a Markdown frontmatter block at the start of a file (I slightly edited his version):</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/(?-m:^)---\r?\n((?:^(?!---$).*\r?\n)*)^---$/m</span>;
assert.<span class="hljs-title function_">equal</span>(re.<span class="hljs-title function_">test</span>(<span class="hljs-string">'---a'</span>), <span class="hljs-literal">false</span>);
assert.<span class="hljs-title function_">equal</span>(re.<span class="hljs-title function_">test</span>(<span class="hljs-string">'---\n---'</span>), <span class="hljs-literal">true</span>);
assert.<span class="hljs-title function_">equal</span>(
  re.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'---\n---'</span>)[<span class="hljs-number">1</span>],
  <span class="hljs-string">''</span>
);
assert.<span class="hljs-title function_">equal</span>(
  re.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'---\na: b\n---'</span>)[<span class="hljs-number">1</span>],
  <span class="hljs-string">'a: b\n'</span>
);
</pre>
<p>How does this regular expression work?</p>
<ul>
  <li>
    By default, flag <code>m</code> is on and the anchor <code>^</code> matches at the beginning of a line and the anchor <code>$</code> matches at the end of a line.
  </li>
  <li>
    The very first <code>^</code> is different: It must match at the beginning of a string. Thatâ€™s why we use a pattern modifier there and switch flag <code>m</code> off.
  </li>
</ul>
<p>This is the regular expression, formatted with insignificant whitespace and explanatory comments:</p>
<pre>
(?-m:^)---\r?\n  # first line of string
(  # capturing group for the frontmatter
  (?:  # pattern for one line (non-capturing group)
    ^(?!---$)  # line must not start with "---" + EOL (lookahead)
    .*\r?\n
  )*
)
^---$  # closing delimiter of frontmatter
</pre>
<h4 id="use-case-inlining-flags"><a class="heading-id-link" href="#use-case-inlining-flags">46.12.4â€ƒUse case: inlining flags</a></h4>
<p>In some situations, flags being outside the actual regular expressions is inconvenient. Then pattern modifiers help. Examples include:</p>
<ul>
  <li>
    <p>Storing regular expressions in configuration files, e.g. in JSON format.</p>
  </li>
  <li>
    <p><a href="https://github.com/slevithan/regex">The Regex+ library</a> provides a template literal that makes creating regular expressions much more convenient. The syntax for specifying flags adds a bit of clutter that can be avoided via pattern modifiers (if they support the required flags):</p>
<pre class="language-js">
<span class="hljs-title function_">regex</span>(<span class="hljs-string">'i'</span>)<span class="hljs-string">`world`</span>
regex<span class="hljs-string">`(?i:world)`</span>
</pre>
  </li>
</ul>
<h4 id="use-case-regular-expression-fragments-that-change-flags"><a class="heading-id-link" href="#use-case-regular-expression-fragments-that-change-flags">46.12.5â€ƒUse case: regular expression fragments that change flags</a></h4>
<p>In complex applications, it helps if you can compose large regular expressions out of smaller regular expressions. The aforementioned Regex+ library supports that. If a smaller regular expression needs different flags (e.g. because it wants to ignore case) then it can â€“ thanks to pattern modifiers.</p>
<h3 id="properties-of-regular-expression-objects"><a class="heading-id-link" href="#properties-of-regular-expression-objects">46.13â€ƒProperties of regular expression objects</a></h3>
<p>Noteworthy:</p>
<ul>
  <li>
    Strictly speaking, only <code>.lastIndex</code> is a real instance property. All other properties are implemented via getters.
  </li>
  <li>
    Accordingly, <code>.lastIndex</code> is the only mutable property. All other properties are read-only. If we want to change them, we need to copy the regular expression (see <a href="#cloning-regexps">â€œCloning and non-destructively modifying regular expressionsâ€ (Â§46.1.3)</a> for details).
  </li>
</ul>
<h4 id="flags-as-properties"><a class="heading-id-link" href="#flags-as-properties">46.13.1â€ƒFlags as properties</a></h4>
<p>Each regular expression flag exists as a property with a longer, more descriptive name:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/a/i.<span class="hljs-property">ignoreCase</span></span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/a/.<span class="hljs-property">ignoreCase</span></span>
false
</pre>
<p>This is the complete list of flag properties:</p>
<ul>
  <li>
    <code>.dotAll</code> (<code>/s</code>)
  </li>
  <li>
    <code>.global</code> (<code>/g</code>)
  </li>
  <li>
    <code>.hasIndices</code> (<code>/d</code>)
  </li>
  <li>
    <code>.ignoreCase</code> (<code>/i</code>)
  </li>
  <li>
    <code>.multiline</code> (<code>/m</code>)
  </li>
  <li>
    <code>.sticky</code> (<code>/y</code>)
  </li>
  <li>
    <code>.unicode</code> (<code>/u</code>)
  </li>
  <li>
    <code>.unicodeSets</code> (<code>/v</code>)
  </li>
</ul>
<h4 id="other-properties"><a class="heading-id-link" href="#other-properties">46.13.2â€ƒOther properties</a></h4>
<p>Each regular expression also has the following properties:</p>
<ul>
  <li>
    <p><code>.source</code> <sup>ES3</sup>: The regular expression pattern</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/abc/ig.<span class="hljs-property">source</span></span>
'abc'
</pre>
  </li>
  <li>
    <p><code>.flags</code> <sup>ES6</sup>: The flags of the regular expression</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/abc/ig.<span class="hljs-property">flags</span></span>
'gi'
</pre>
  </li>
  <li>
    <p><code>.lastIndex</code> <sup>ES3</sup>: Used when flag <code>/g</code> is switched on. See <a href="#regexp-flags-gy">â€œThe flags <code>/g</code> and <code>/y</code>, and the property <code>.lastIndex</code><span> (advanced)</span>â€ (Â§46.16)</a> for details.</p>
  </li>
</ul>
<h3 id="match-objects"><a class="heading-id-link" href="#match-objects">46.14â€ƒMatch objects</a></h3>
<p>Several regular expression-related methods return so-called <em>match objects</em> to provide detailed information for the locations where a regular expression matches an input string. These methods are:</p>
<ul>
  <li>
    <code>RegExp.prototype.exec()</code> returns <code>null</code> or a single match object.
  </li>
  <li>
    <code>String.prototype.match()</code> returns <code>null</code> or a single match object (if flag <code>/g</code> is not set).
  </li>
  <li>
    <code>String.prototype.matchAll()</code> returns an iterable of match objects (flag <code>/g</code> must be set; otherwise, an exception is thrown).
  </li>
</ul>
<p>This is an example:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-regexp">/(a+)b/</span>d.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'ab aaab'</span>),
  {
    <span class="hljs-number">0</span>: <span class="hljs-string">'ab'</span>,
    <span class="hljs-number">1</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-attr">index</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">input</span>: <span class="hljs-string">'ab aaab'</span>,
    <span class="hljs-attr">groups</span>: <span class="hljs-literal">undefined</span>,
    <span class="hljs-attr">indices</span>: {
      <span class="hljs-number">0</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>],
      <span class="hljs-number">1</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>],
      <span class="hljs-attr">groups</span>: <span class="hljs-literal">undefined</span>
    },
  }
);
</pre>
<p>The result of <code>.exec()</code> is a <em>match object</em> for the first match with the following properties:</p>
<ul>
  <li>
    <code>[0]</code>: the complete substring matched by the regular expression
  </li>
  <li>
    <code>[1]</code>: capture of numbered group 1 (etc.)
  </li>
  <li>
    <code>.index</code>: where did the match occur?
  </li>
  <li>
    <code>.input</code>: the string that was matched against
  </li>
  <li>
    <code>.groups</code>: captures of named groups (see <a href="#named-capture-groups">â€œNamed capture groups<span> <sup>ES2018</sup></span>â€ (Â§46.15.2.1)</a>)
  </li>
  <li>
    <code>.indices</code>: the index ranges of captured groups
    <ul>
      <li>
        This property is only created if flag <code>/d</code> is switched on.
      </li>
    </ul>
  </li>
</ul>
<h4 id="regexp-match-indices"><a class="heading-id-link" href="#regexp-match-indices">46.14.1â€ƒMatch indices in match objects<span> <sup>ES2022</sup></span></a></h4>
<p><em>Match indices</em> are a feature of match objects: If we turn it on via the regular expression flag <code>/d</code> (property <code>.hasIndices</code>), they record the start and end indices of where groups were captured.</p>
<h5 id="match-indices-for-numbered-groups"><a class="heading-id-link" href="#match-indices-for-numbered-groups">46.14.1.1â€ƒMatch indices for numbered groups</a></h5>
<p>This is how we access the captures of numbered groups:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> matchObj = <span class="hljs-regexp">/(a+)(b+)/</span>d.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'aaaabb'</span>);
assert.<span class="hljs-title function_">equal</span>(
  matchObj[<span class="hljs-number">1</span>], <span class="hljs-string">'aaaa'</span>
);
assert.<span class="hljs-title function_">equal</span>(
  matchObj[<span class="hljs-number">2</span>], <span class="hljs-string">'bb'</span>
);
</pre>
<p>Due to the regular expression flag <code>/d</code>, <code>matchObj</code> also has a property <code>.indices</code> that records for each numbered group where it was captured in the input string:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">deepEqual</span>(
  matchObj.<span class="hljs-property">indices</span>[<span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">4</span>]
);
assert.<span class="hljs-title function_">deepEqual</span>(
  matchObj.<span class="hljs-property">indices</span>[<span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">6</span>]
);
</pre>
<h5 id="match-indices-for-named-groups"><a class="heading-id-link" href="#match-indices-for-named-groups">46.14.1.2â€ƒMatch indices for named groups</a></h5>
<p>The captures of named groups are accessed like this:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> matchObj = <span class="hljs-regexp">/(?&lt;as&gt;a+)(?&lt;bs&gt;b+)/</span>d.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'aaaabb'</span>);
assert.<span class="hljs-title function_">equal</span>(
  matchObj.<span class="hljs-property">groups</span>.<span class="hljs-property">as</span>, <span class="hljs-string">'aaaa'</span>
);
assert.<span class="hljs-title function_">equal</span>(
  matchObj.<span class="hljs-property">groups</span>.<span class="hljs-property">bs</span>, <span class="hljs-string">'bb'</span>
);
</pre>
<p>Their indices are stored in <code>matchObj.indices.groups</code>:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">deepEqual</span>(
  matchObj.<span class="hljs-property">indices</span>.<span class="hljs-property">groups</span>.<span class="hljs-property">as</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">4</span>]
);
assert.<span class="hljs-title function_">deepEqual</span>(
  matchObj.<span class="hljs-property">indices</span>.<span class="hljs-property">groups</span>.<span class="hljs-property">bs</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">6</span>]
);
</pre>
<h5 id="a-more-realistic-example"><a class="heading-id-link" href="#a-more-realistic-example">46.14.1.3â€ƒA more realistic example</a></h5>
<p>One important use case for match indices are parsers that point to where exactly a syntactic error is located. The following code solves a related problem: It points to where quoted content starts and where it ends (see demonstration at the end).</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> reQuoted = <span class="hljs-regexp">/â€œ([^â€]+)â€/</span>dgv;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">pointToQuotedText</span>(<span class="hljs-params">str</span>) {
  <span class="hljs-keyword">const</span> startIndices = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
  <span class="hljs-keyword">const</span> endIndices = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> match <span class="hljs-keyword">of</span> str.<span class="hljs-title function_">matchAll</span>(reQuoted)) {
    <span class="hljs-keyword">const</span> [start, end] = match.<span class="hljs-property">indices</span>[<span class="hljs-number">1</span>];
    startIndices.<span class="hljs-title function_">add</span>(start);
    endIndices.<span class="hljs-title function_">add</span>(end);
  }
  <span class="hljs-keyword">let</span> result = <span class="hljs-string">''</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index=<span class="hljs-number">0</span>; index &lt; str.<span class="hljs-property">length</span>; index++) {
    <span class="hljs-keyword">if</span> (startIndices.<span class="hljs-title function_">has</span>(index)) {
      result += <span class="hljs-string">'['</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (endIndices.<span class="hljs-title function_">has</span>(index+<span class="hljs-number">1</span>)) {
      result += <span class="hljs-string">']'</span>;
    } <span class="hljs-keyword">else</span> {
      result += <span class="hljs-string">' '</span>;
    }
  }
  <span class="hljs-keyword">return</span> result;
}
<code/>
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title function_">pointToQuotedText</span>(
    <span class="hljs-string">'They said â€œhelloâ€ and â€œgoodbyeâ€.'</span>),
    <span class="hljs-string">'           [   ]       [     ]  '</span>
);
</pre>
<h3 id="methods-for-working-with-regular-expressions"><a class="heading-id-link" href="#methods-for-working-with-regular-expressions">46.15â€ƒMethods for working with regular expressions</a></h3>
<h4 id="by-default-regular-expressions-match-anywhere-in-a-string"><a class="heading-id-link" href="#by-default-regular-expressions-match-anywhere-in-a-string">46.15.1â€ƒBy default, regular expressions match anywhere in a string</a></h4>
<p>By default, regular expressions match anywhere in a string:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/a/.<span class="hljs-title function_">test</span>(<span class="hljs-string">'__a__'</span>)</span>
true
</pre>
<p>We can change that by using assertions such as <code>^</code> (or by using the flag <code>/y</code>):</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^a/.<span class="hljs-title function_">test</span>(<span class="hljs-string">'__a__'</span>)</span>
false
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^a/.<span class="hljs-title function_">test</span>(<span class="hljs-string">'a__'</span>)</span>
true
</pre>
<h4 id="String.prototype.match"><a class="heading-id-link" href="#String.prototype.match">46.15.2â€ƒ<code>string.match(regExp)</code> without <code>/g</code>: getting a match object for the first match</a></h4>
<p>Without the flag <code>/g</code>, <code>string.match(regExp)</code> returns <a href="#match-objects">a match object</a> for the first match of <code>regExp</code> in <code>str</code>:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-string">'ab aab'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/(a+)b/</span>),
  {
    <span class="hljs-number">0</span>: <span class="hljs-string">'ab'</span>,
    <span class="hljs-number">1</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-attr">index</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">input</span>: <span class="hljs-string">'ab aab'</span>,
    <span class="hljs-attr">groups</span>: <span class="hljs-literal">undefined</span>,
  }
);
</pre>
<h5 id="named-capture-groups"><a class="heading-id-link" href="#named-capture-groups">46.15.2.1â€ƒNamed capture groups<span> <sup>ES2018</sup></span></a></h5>
<p>The previous example contained a single numbered group. The following example demonstrates named groups:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-string">'ab aab'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/(?&lt;as&gt;a+)b/</span>),
  {
    <span class="hljs-number">0</span>: <span class="hljs-string">'ab'</span>,
    <span class="hljs-number">1</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-attr">index</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">input</span>: <span class="hljs-string">'ab aab'</span>,
    <span class="hljs-attr">groups</span>: { <span class="hljs-attr">as</span>: <span class="hljs-string">'a'</span> },
  }
);
</pre>
<p>In the result of <code>.match()</code>, we can see that a named group is also a numbered group â€“ its capture exists twice:</p>
<ul>
  <li>
    Once as a numbered capture (property <code>'1'</code>).
  </li>
  <li>
    Once as a named capture (property <code>groups.as</code>).
  </li>
</ul>
<h5 id="duplicate-named-capture-groups"><a class="heading-id-link" href="#duplicate-named-capture-groups">46.15.2.2â€ƒDuplicate named capture groups<span> <sup>ES2025</sup></span></a></h5>
<p>Since ECMAScript 2025, we can use the same group name twice â€“ as long as it appears in different alternatives:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RE</span> = <span class="hljs-regexp">/(?&lt;a&gt;a(?&lt;xs&gt;x+))|(?&lt;b&gt;b(?&lt;xs&gt;x+))/</span>v;
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-string">'axx'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-variable constant_">RE</span>).<span class="hljs-property">groups</span>,
  {
    <span class="hljs-attr">a</span>: <span class="hljs-string">'axx'</span>,
    <span class="hljs-attr">xs</span>: <span class="hljs-string">'xx'</span>,
    <span class="hljs-attr">b</span>: <span class="hljs-literal">undefined</span>,
    <span class="hljs-attr">__proto__</span>: <span class="hljs-literal">null</span>,
  }
);
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-string">'bxx'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-variable constant_">RE</span>).<span class="hljs-property">groups</span>,
  {
    <span class="hljs-attr">a</span>: <span class="hljs-literal">undefined</span>,
    <span class="hljs-attr">xs</span>: <span class="hljs-string">'xx'</span>,
    <span class="hljs-attr">b</span>: <span class="hljs-string">'bxx'</span>,
    <span class="hljs-attr">__proto__</span>: <span class="hljs-literal">null</span>,
  }
);
</pre>
<p>The following is not allowed (group <code>xs</code> would match twice):</p>
<pre class="language-js">
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">eval</span>(<span class="hljs-string">'/(?&lt;a&gt;a(?&lt;xs&gt;x+))(?&lt;b&gt;b(?&lt;xs&gt;x+))/v'</span>),
  <span class="hljs-regexp">/^SyntaxError:.* Duplicate capture group name$/</span>
);
</pre>
<h4 id="stringmatchregexp-with-g-getting-all-group-0-captures-es3"><a class="heading-id-link" href="#stringmatchregexp-with-g-getting-all-group-0-captures-es3">46.15.3â€ƒ<code>string.match(regExp)</code> with <code>/g</code>: getting all group 0 captures<span> <sup>ES3</sup></span></a></h4>
<p>With flag <code>/g</code>, <code>string.match(regExp)</code> returns all substrings of <code>str</code> that match <code>regExp</code>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'ab aab'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/(a+)b/g</span>)</span>
[ 'ab', 'aab' ]
</pre>
<p>If there is no match, <code>.match()</code> returns <code>null</code>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'xyz'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/(a+)b/g</span>)</span>
null
</pre>
<p>We can use <a href="ch_undefined-null.html#nullish-coalescing-operator">the nullish coalescing operator (<code>??</code>)</a> to protect ourselves against <code>null</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> numberOfMatches = (str.<span class="hljs-title function_">match</span>(regExp) ?? []).<span class="hljs-property">length</span>;
</pre>
<p>We can also use <a href="ch_objects.html#optional-chaining">optional chaining (<code>?.</code>)</a> and combine it with the nullish coalescing operator:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> numberOfMatches = str.<span class="hljs-title function_">match</span>(regExp)?.<span class="hljs-property">length</span> ?? <span class="hljs-number">0</span>;
</pre>
<h4 id="String.prototype.matchAll"><a class="heading-id-link" href="#String.prototype.matchAll">46.15.4â€ƒ<code>string.matchAll(regExp)</code>: getting an iterable over all match objects<span> <sup>ES2020</sup></span></a></h4>
<p>This is how <code>.matchAll()</code> is invoked:</p>
<pre class="language-txt">
const matchIterable = str.matchAll(regExp);
</pre>
<p>Given a string and a regular expression, <code>.matchAll()</code> returns an iterable over the match objects of all matches.</p>
<p>In the following example, we use <a href="ch_arrays.html#Array.from"><code>Array.from()</code></a> to convert iterables to Arrays so that we can compare them better.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'-a-a-a'</span>.<span class="hljs-title function_">matchAll</span>(<span class="hljs-regexp">/-(a)/g</span>v))</span>
[
  { 0:'-a', 1:'a', index: 0, input: '-a-a-a', groups: undefined },
  { 0:'-a', 1:'a', index: 2, input: '-a-a-a', groups: undefined },
  { 0:'-a', 1:'a', index: 4, input: '-a-a-a', groups: undefined },
]
</pre>
<p>Flag <code>/g</code> must be set:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'-a-a-a'</span>.<span class="hljs-title function_">matchAll</span>(<span class="hljs-regexp">/-(a)/</span>v))</span>
TypeError: String.prototype.matchAll called with a non-global
RegExp argument
</pre>
<p><code>.matchAll()</code> isnâ€™t affected by <code>regExp.lastIndex</code> and doesnâ€™t change it.</p>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon â€œexerciseâ€" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/>â€‚<strong>Exercise: Extracting quoted text via <code>.matchAll()</code></strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/regexps/extract_quoted_test.mjs</code></p>
</div>
<h5 id="implementing-matchall"><a class="heading-id-link" href="#implementing-matchall">46.15.4.1â€ƒImplementing <code>.matchAll()</code></a></h5>
<p><code>.matchAll()</code> could be implemented via <code>.exec()</code> as follows:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span>* <span class="hljs-title function_">matchAll</span>(<span class="hljs-params">str, regExp</span>) {
  <span class="hljs-keyword">if</span> (!regExp.<span class="hljs-property">global</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">'Flag /g must be set!'</span>);
  }
  <span class="hljs-comment">// Preserve and reset flags</span>
  <span class="hljs-keyword">const</span> localCopy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(regExp, regExp.<span class="hljs-property">flags</span>);
  <span class="hljs-keyword">let</span> match;
  <span class="hljs-keyword">while</span> (match = localCopy.<span class="hljs-title function_">exec</span>(str)) {
    <span class="hljs-keyword">yield</span> match;
  }
}
</pre>
<p>Making a local copy ensures two things:</p>
<ul>
  <li>
    <code>regex.lastIndex</code> isnâ€™t changed.
  </li>
  <li>
    <code>localCopy.lastIndex</code> is zero.
  </li>
</ul>
<p>Using <code>matchAll()</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> str = <span class="hljs-string">'"fee" "fi" "fo" "fum"'</span>;
<span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/"([^"]*)"/g</span>;
<code/>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> match <span class="hljs-keyword">of</span> <span class="hljs-title function_">matchAll</span>(str, regex)) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(match[<span class="hljs-number">1</span>]);
}
</pre>
<p>Output:</p>
<pre>
fee
fi
fo
fum
</pre>
<h4 id="RegExp.prototype.exec"><a class="heading-id-link" href="#RegExp.prototype.exec">46.15.5â€ƒ<code>regExp.exec(str)</code>: capturing groups<span> <sup>ES3</sup></span></a></h4>
<h5 id="regexpexecstr-without-g-getting-a-match-object-for-the-first-match"><a class="heading-id-link" href="#regexpexecstr-without-g-getting-a-match-object-for-the-first-match">46.15.5.1â€ƒ<code>regExp.exec(str)</code> without <code>/g</code>: getting a match object for the first match</a></h5>
<p>Without flag <code>/g</code>, <code>regExp.exec()</code> works like <code>string.match()</code> â€“ it returns a single match object.</p>
<h5 id="regexpexecstr-with-g-looping-over-all-matches"><a class="heading-id-link" href="#regexpexecstr-with-g-looping-over-all-matches">46.15.5.2â€ƒ<code>regExp.exec(str)</code> with <code>/g</code>: looping over all matches</a></h5>
<div class="boxout">
  <p><img src="../Images/8440b17bb8219cda9f9405ac83c36db0.png" class="boxout-icon" height="24" alt="Icon â€œtipâ€" data-original-src="https://exploringjs.com/js/book/icon/tip.svg"/>â€‚<strong>Better alternative for retrieving all matches: <code>string.matchAll(regExp)</code> <sup>ES2020</sup></strong></p>
  <div class="boxout-vspace"/>
  <p>Since ECMAScript 2020, JavaScript has another method for retrieving all matches: <a href="#String.prototype.matchAll"><code>string.matchAll(regExp)</code></a>. That method is easier and safer to use: It returns an iterable, is unaffected by <code>.lastIndex</code> and throws an exception if flag <code>/g</code> is missing.</p>
</div>
<p>If we want to retrieve all matches of a regular expression (not just the first one), we need to switch on the flag <code>/g</code>. Then we can call <code>.exec()</code> multiple times and get one match each time. After the last match, <code>.exec()</code> returns <code>null</code>.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> regExp = <span class="hljs-regexp">/(a+)b/g</span>;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">regExp.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'ab aab'</span>)</span>
{ 0: 'ab', 1: 'a', index: 0, input: 'ab aab', groups: undefined }
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">regExp.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'ab aab'</span>)</span>
{ 0: 'aab', 1: 'aa', index: 3, input: 'ab aab', groups: undefined }
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">regExp.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'ab aab'</span>)</span>
null
</pre>
<p>Therefore, we can loop over all matches as follows:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> regExp = <span class="hljs-regexp">/(a+)b/g</span>;
<span class="hljs-keyword">const</span> str = <span class="hljs-string">'ab aab'</span>;
<code/>
<span class="hljs-keyword">let</span> match;
<span class="hljs-comment">// Check for null via truthiness</span>
<span class="hljs-comment">// Alternative: while ((match = regExp.exec(str)) !== null)</span>
<span class="hljs-keyword">while</span> (match = regExp.<span class="hljs-title function_">exec</span>(str)) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(match[<span class="hljs-number">1</span>]);
}
</pre>
<p>Output:</p>
<pre>
a
aa
</pre>
<h4 id="match-vs-matchall-vs-exec"><a class="heading-id-link" href="#match-vs-matchall-vs-exec">46.15.6â€ƒ<code>string.match()</code> vs. <code>string.matchAll()</code> vs. <code>regExp.exec()</code></a></h4>
<p>The following table summarizes the differences between three methods:</p>
<table class="framed">
  <style>
    th:nth-child(1), td:nth-child(1) {
      text-align: left;
    }
    th:nth-child(2), td:nth-child(2) {
      text-align: left;
    }
    th:nth-child(3), td:nth-child(3) {
      text-align: left;
    }
  </style>
  <thead>
    <tr>
      <th/><th>Without <code>/g</code></th><th>With <code>/g</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>string.match(regExp)</code></td><td>First match object</td><td>Array of group 0 captures</td>
    </tr>
    <tr>
      <td><code>string.matchAll(regExp)</code></td><td><code>TypeError</code></td><td>Iterable over match objects</td>
    </tr>
    <tr>
      <td><code>regExp.exec(string)</code></td><td>First match object</td><td>Next match object or <code>null</code></td>
    </tr>
  </tbody>
</table>
<h4 id="replace-replaceAll"><a class="heading-id-link" href="#replace-replaceAll">46.15.7â€ƒReplacing with <code>string.replace()</code> and <code>string.replaceAll()</code></a></h4>
<p>Both replacing methods have two parameters:</p>
<ul>
  <li>
    <code>string.replace(searchValue, replacementValue)</code>
  </li>
  <li>
    <code>string.replaceAll(searchValue, replacementValue)</code>
  </li>
</ul>
<p><code>searchValue</code> can be:</p>
<ul>
  <li>
    A string
  </li>
  <li>
    A regular expression
  </li>
</ul>
<p><code>replacementValue</code> can be:</p>
<ul>
  <li>
    String: Replace matches with this string. The character <code>$</code> has special meaning and lets us insert captures of groups and more (details are explained later).
  </li>
  <li>
    Function: Compute strings that replace matches via this function.
  </li>
</ul>
<p>The two methods differ as follows:</p>
<ul>
  <li>
    <code>.replace()</code> replaces the first occurrence of a string or a regular expression without <code>/g</code>.
  </li>
  <li>
    <code>.replaceAll()</code> replaces all occurrences of a string or a regular expression with <code>/g</code>.
  </li>
</ul>
<p>This table summarizes how that works:</p>
<table class="framed">
  <style>
    th:nth-child(1), td:nth-child(1) {
      text-align: left;
    }
    th:nth-child(2), td:nth-child(2) {
      text-align: left;
    }
    th:nth-child(3), td:nth-child(3) {
      text-align: left;
    }
    th:nth-child(4), td:nth-child(4) {
      text-align: left;
    }
  </style>
  <thead>
    <tr>
      <th>Search for: â†’</th><th>string</th><th>RegExp w/o <code>/g</code></th><th>RegExp with <code>/g</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>.replace</code></td><td>First occurrence</td><td>First occurrence</td><td>(All occurrences)</td>
    </tr>
    <tr>
      <td><code>.replaceAll</code></td><td>All occurrences</td><td><code>TypeError</code></td><td>All occurrences</td>
    </tr>
  </tbody>
</table>
<p>The last column of <code>.replace()</code> is in parentheses because this method existed long before <code>.replaceAll()</code> and therefore supports functionality that should now be handled via the latter method. If we could change that, <code>.replace()</code> would throw a <code>TypeError</code> here.</p>
<p>We first explore how <code>.replace()</code> and <code>.replaceAll()</code> work individually when <code>replacementValue</code> is a simple string (without the character <code>$</code>). Then we examine how both are affected by more complicated replacement values.</p>
<h5 id="String.prototype.replace"><a class="heading-id-link" href="#String.prototype.replace">46.15.7.1â€ƒ<code>string.replace(searchValue, replacementValue)</code><span> <sup>ES3</sup></span></a></h5>
<p>How <code>.replace()</code> operates is influenced by its first parameter <code>searchValue</code>:</p>
<ul>
  <li>
    <p>Regular expression without <code>/g</code>: Replace first match of this regular expression.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'aaa'</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/a/</span>, <span class="hljs-string">'x'</span>)</span>
'xaa'
</pre>
  </li>
  <li>
    <p>String: Replace first occurrence of this string (the string is interpreted verbatim, not as a regular expression).</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'aaa'</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'x'</span>)</span>
'xaa'
</pre>
  </li>
  <li>
    <p>Regular expression with <code>/g</code>: Replace all matches of this regular expression.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'aaa'</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/a/g</span>, <span class="hljs-string">'x'</span>)</span>
'xxx'
</pre>
    <p>Recommendation: If <code>.replaceAll()</code> is available, itâ€™s better to use that method in this case â€“ its purpose is to replace multiple occurrences.</p>
  </li>
</ul>
<p>If we want to replace every occurrence of a string, we have two options:</p>
<ul>
  <li>
    <p>We can use <code>.replaceAll()</code> (which was introduced in ES2021).</p>
  </li>
  <li>
    <p>Later in this chapter, we will encounter [the tool function <code>escapeForRegExp()</code>) which will help us convert a string into a regular expression that matches that string multiple times (e.g., <code>'*'</code> becomes <code>/\*/g</code>).</p>
  </li>
</ul>
<h5 id="String.prototype.replaceAll"><a class="heading-id-link" href="#String.prototype.replaceAll">46.15.7.2â€ƒ<code>string.replaceAll(searchValue, replacementValue)</code><span> <sup>ES2021</sup></span></a></h5>
<p>How <code>.replaceAll()</code> operates is influenced by its first parameter <code>searchValue</code>:</p>
<ul>
  <li>
    <p>Regular expression with <code>/g</code>: Replace all matches of this regular expression.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'aaa'</span>.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-regexp">/a/g</span>, <span class="hljs-string">'x'</span>)</span>
'xxx'
</pre>
  </li>
  <li>
    <p>String: Replace all occurrences of this string (the string is interpreted verbatim, not as a regular expression).</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'aaa'</span>.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'x'</span>)</span>
'xxx'
</pre>
  </li>
  <li>
    <p>Regular expression without <code>/g</code>: A <code>TypeError</code> is thrown (because the purpose of <code>.replaceAll()</code> is to replace multiple occurrences).</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'aaa'</span>.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-regexp">/a/</span>, <span class="hljs-string">'x'</span>)</span>
TypeError: String.prototype.replaceAll called with
a non-global RegExp argument
</pre>
  </li>
</ul>
<h5 id="the-parameter-replacementvalue-of-replace-and-replaceall"><a class="heading-id-link" href="#the-parameter-replacementvalue-of-replace-and-replaceall">46.15.7.3â€ƒThe parameter <code>replacementValue</code> of <code>.replace()</code> and <code>.replaceAll()</code></a></h5>
<p>So far, we have only used the parameter <code>replacementValue</code> with simple strings, but it can do more. If its value is:</p>
<ul>
  <li>
    <p>A string, then matches are replaced with this string. The character <code>$</code> has special meaning and lets us insert captures of groups and more (read on for details).</p>
  </li>
  <li>
    <p>A function, then matches are replaced by strings that are computed via this function.</p>
  </li>
</ul>
<h5 id="replacementvalue-is-a-string"><a class="heading-id-link" href="#replacementvalue-is-a-string">46.15.7.4â€ƒ<code>replacementValue</code> is a string</a></h5>
<p>If the replacement value is a string, the dollar sign has special meaning â€“ it inserts text matched by the regular expression:</p>
<table class="framed">
  <style>
    th:nth-child(1), td:nth-child(1) {
      text-align: left;
    }
    th:nth-child(2), td:nth-child(2) {
      text-align: left;
    }
  </style>
  <thead>
    <tr>
      <th>Text</th><th>Result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>$$</code></td><td>single <code>$</code></td>
    </tr>
    <tr>
      <td><code>$&amp;</code></td><td>complete match</td>
    </tr>
    <tr>
      <td><code>$`</code></td><td>text before match</td>
    </tr>
    <tr>
      <td><code>$'</code></td><td>text after match</td>
    </tr>
    <tr>
      <td><code>$n</code></td><td>capture of numbered group <code>n</code> (<code>n</code> &gt; 0)</td>
    </tr>
    <tr>
      <td><code>$&lt;name&gt;</code></td><td>capture of named group <code>name</code> (ES2018)</td>
    </tr>
  </tbody>
</table>
<p>Example: Inserting the text before, inside, and after the matched substring.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'a1 a2'</span>.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-regexp">/a/g</span>, <span class="hljs-string">"($`|$&amp;|$')"</span>)</span>
'(|a|1 a2)1 (a1 |a|2)2'
</pre>
<p>Example: Inserting the captures of numbered groups.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> regExp = <span class="hljs-regexp">/^([A-Za-z]+): (.*)$/g</span>v;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'first: Jane'</span>.<span class="hljs-title function_">replaceAll</span>(regExp, <span class="hljs-string">'KEY: $1, VALUE: $2'</span>)</span>
'KEY: first, VALUE: Jane'
</pre>
<p>Example: Inserting the captures of named groups.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> regExp = <span class="hljs-regexp">/^(?&lt;key&gt;[A-Za-z]+): (?&lt;value&gt;.*)$/g</span>v;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'first: Jane'</span>.<span class="hljs-title function_">replaceAll</span>(regExp, <span class="hljs-string">'KEY: $&lt;key&gt;, VALUE: $&lt;value&gt;'</span>)</span>
'KEY: first, VALUE: Jane'
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon â€œexerciseâ€" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/>â€‚<strong>Exercise: Change quotes via <code>.replace()</code> and a named group</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/regexps/change_quotes_test.mjs</code></p>
</div>
<h5 id="replacementvalue-is-a-function"><a class="heading-id-link" href="#replacementvalue-is-a-function">46.15.7.5â€ƒ<code>replacementValue</code> is a function</a></h5>
<p>If the replacement value is a function, we can compute each replacement. In the following example, we multiply each non-negative integer that we find by two.</p>
<pre class="language-js">
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-string">'3 cats and 4 dogs'</span>.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-regexp">/[0-9]+/g</span>, <span class="hljs-function">(<span class="hljs-params">all</span>) =&gt;</span> <span class="hljs-number">2</span> * <span class="hljs-title class_">Number</span>(all)),
  <span class="hljs-string">'6 cats and 8 dogs'</span>
);
</pre>
<p>The replacement function gets the following parameters. Note how similar they are to match objects. These parameters are all positional, but Iâ€™ve included how one might name them:</p>
<ul>
  <li>
    <code>all</code>: complete match
  </li>
  <li>
    <code>g1</code>: capture of numbered group 1
  </li>
  <li>
    Etc.
  </li>
  <li>
    <code>index</code>: where did the match occur?
  </li>
  <li>
    <code>input</code>: the string in which we are replacing
  </li>
  <li>
    <code>groups</code> <sup>ES2018</sup>: captures of named groups (an object). Always the last parameter.
  </li>
</ul>
<p>If we are only interested in <code>groups</code>, we can use the following technique:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> result = <span class="hljs-string">'first=jane, last=doe'</span>.<span class="hljs-title function_">replace</span>(
  <span class="hljs-regexp">/(?&lt;key&gt;[a-z]+)=(?&lt;value&gt;[a-z]+)/g</span>,
  <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> { <span class="hljs-comment">// (A)</span>
    <span class="hljs-keyword">const</span> groups = args.<span class="hljs-title function_">at</span>(-<span class="hljs-number">1</span>); <span class="hljs-comment">// (B)</span>
    <span class="hljs-keyword">const</span> {key, value} = groups;
    <span class="hljs-keyword">return</span> key.<span class="hljs-title function_">toUpperCase</span>() + <span class="hljs-string">'='</span> + value.<span class="hljs-title function_">toUpperCase</span>();
  });
assert.<span class="hljs-title function_">equal</span>(result, <span class="hljs-string">'FIRST=JANE, LAST=DOE'</span>);
</pre>
<p>Due to the <a href="ch_callables.html#rest-parameters">rest parameter</a> in line A, <code>args</code> contains an Array with all parameters. We access the last parameter via <a href="ch_arrays.html#Array.prototype.at">the Array method <code>.at()</code></a> in line B.</p>
<h4 id="RegExp.prototype.test"><a class="heading-id-link" href="#RegExp.prototype.test">46.15.8â€ƒ<code>regExp.test(str)</code>: is there a match?<span> <sup>ES3</sup></span></a></h4>
<p>The regular expression method <code>regExp.test(str)</code> returns <code>true</code> if <code>regExp</code> matches <code>str</code>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/bc/.<span class="hljs-title function_">test</span>(<span class="hljs-string">'ABCD'</span>)</span>
false
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/bc/i.<span class="hljs-title function_">test</span>(<span class="hljs-string">'ABCD'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/\.<span class="hljs-property">mjs$</span>/.<span class="hljs-title function_">test</span>(<span class="hljs-string">'main.mjs'</span>)</span>
true
</pre>
<p>With <code>.test()</code> we should normally avoid the <code>/g</code> flag. If we use it, we generally donâ€™t get the same result every time we call the method:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> r = <span class="hljs-regexp">/a/g</span>;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">r.<span class="hljs-title function_">test</span>(<span class="hljs-string">'aab'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">r.<span class="hljs-title function_">test</span>(<span class="hljs-string">'aab'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">r.<span class="hljs-title function_">test</span>(<span class="hljs-string">'aab'</span>)</span>
false
</pre>
<p>The results are due to <code>/a/</code> having two matches in the string. After all of those were found, <code>.test()</code> returns <code>false</code>. For more information, see <a href="#regexp-flags-gy">â€œThe flags <code>/g</code> and <code>/y</code>, and the property <code>.lastIndex</code><span> (advanced)</span>â€ (Â§46.16)</a>.</p>
<h4 id="String.prototype.search"><a class="heading-id-link" href="#String.prototype.search">46.15.9â€ƒ<code>string.search(regExp)</code>: at what index is the match?<span> <sup>ES3</sup></span></a></h4>
<p>The string method <code>.search()</code> returns the first index of <code>str</code> at which there is a match for <code>regExp</code>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'_abc_'</span>.<span class="hljs-title function_">search</span>(<span class="hljs-regexp">/abc/</span>)</span>
1
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'main.mjs'</span>.<span class="hljs-title function_">search</span>(<span class="hljs-regexp">/\.mjs$/</span>)</span>
4
</pre>
<h4 id="String.prototype.split"><a class="heading-id-link" href="#String.prototype.split">46.15.10â€ƒ<code>string.split(separator, limit?)</code>: splitting strings<span> <sup>ES3</sup></span></a></h4>
<p>Splits the string into an Array of substrings â€“ the strings that occur between the separators.</p>
<p>The separator can be a string:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'a : b : c'</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">':'</span>)</span>
[ 'a ', ' b ', ' c' ]
</pre>
<p>It can also be a regular expression:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'a x:yyy b'</span>.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/x+:y+/</span>)</span>
[ 'a ', ' b' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'a x:yyy b'</span>.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/(x+):(y+)/</span>)</span>
[ 'a ', 'x', 'yyy', ' b' ]
</pre>
<p>The last invocation demonstrates that captures made by groups in the regular expression become elements of the returned Array.</p>
<p>If we want the separators to be part of the returned string fragments, we can use a regular expression with a <a href="#regexp-lookbehind-assertions">lookbehind assertion</a> or a <a href="#regexp-lookahead-assertions">lookahead assertion</a>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'a: b: c'</span>.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/(?&lt;=:) */</span>)</span>
[ 'a:', 'b:', 'c' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'a :b :c'</span>.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/ *(?=:)/</span>)</span>
[ 'a', ':b', ':c' ]
</pre>
<p>Thanks to the lookaround assertions, the regular expression used for splitting leaves the colons in the fragments and only removes the spaces following or preceding the colons.</p>
<p><strong>Pitfall:</strong> <code>.split('')</code> splits into JavaScript characters, but we usually want to split into grapheme clusters or at least Unicode code points. Therefore, itâ€™s better to use <code>Intl.Segmenter</code> or <code>Array.from()</code> for splitting. For more information, see <a href="ch_strings.html#atoms-of-text">â€œAtoms of text: code points, JavaScript characters, grapheme clustersâ€ (Â§22.7)</a>.</p>
<h3 id="regexp-flags-gy"><a class="heading-id-link" href="#regexp-flags-gy">46.16â€ƒThe flags <code>/g</code> and <code>/y</code>, and the property <code>.lastIndex</code><span> (advanced)</span></a></h3>
<p>In this section, we examine how the RegExp flags <code>/g</code> and <code>/y</code> work and how they depend on the RegExp property <code>.lastIndex</code>. Weâ€™ll also discover an interesting use case for <code>.lastIndex</code> that you may find surprising.</p>
<h4 id="the-flags-g-and-y"><a class="heading-id-link" href="#the-flags-g-and-y">46.16.1â€ƒThe flags <code>/g</code> and <code>/y</code></a></h4>
<p>Every method reacts differently to <code>/g</code> and <code>/y</code>; this gives us a rough general idea:</p>
<ul>
  <li>
    <code>/g</code> (<code>.global</code>, ES3): The regular expression should match multiple times, anywhere in a string.
  </li>
  <li>
    <code>/y</code> (<code>.sticky</code>, ES6): Any match inside a string should immediately follow a previous match (the matches â€œstickâ€Â together).
  </li>
</ul>
<p>If a regular expression has neither the flag <code>/g</code> nor the flag <code>/y</code>, matching happens once and starts at the beginning.</p>
<p>With either <code>/g</code> or <code>/y</code>, matching is performed relative to a â€œcurrent positionâ€ inside the input string. That position is stored in the regular expression property <code>.lastIndex</code>.</p>
<p>There are three groups of regular-expression-related methods:</p>
<ol>
  <li>
    <p>The string methods <code>.search(regExp)</code> and <code>.split(regExp)</code> completely ignore <code>/g</code> and <code>/y</code> (and therefore also <code>.lastIndex</code>).</p>
  </li>
  <li>
    <p>The <code>RegExp</code> methods <code>.exec(str)</code> and <code>.test(str)</code> change in two ways if either <code>/g</code> or <code>/y</code> is set.</p>
    <p>First, we get multiple matches, by calling one method repeatedly. Each time, it returns either another result (a match object or <code>true</code>) or an â€œend of resultsâ€ value (<code>null</code> or <code>false</code>).</p>
    <p>Second, the regular expression property <code>.lastIndex</code> is used to step through the input string. On one hand, <code>.lastIndex</code> determines where matching starts:</p>
    <ul>
      <li>
        <p><code>/g</code> means that a match must begin at <code>.lastIndex</code> or later.</p>
      </li>
      <li>
        <p><code>/y</code> means that a match must begin at <code>.lastIndex</code>. That is, the beginning of the regular expression is anchored to <code>.lastIndex</code>.</p>
        <p>Note that <code>^</code> and <code>$</code> continue to work as usually: They anchor matches to the beginning or end of the input string, unless <code>.multiline</code> is set. Then they anchor to the beginnings or ends of lines.</p>
      </li>
    </ul>
    <p>On the other hand, <code>.lastIndex</code> is set to one plus the last index of the previous match.</p>
  </li>
  <li>
    <p>The remaining methods are:</p>
    <ul>
      <li>
        The string methods <code>.match(regExp)</code> and <code>.matchAll(regExp)</code> (throws without <code>/g</code>)
      </li>
      <li>
        The string methods <code>.replace(regExp, str)</code> and <code>.replaceAll(regExp, str)</code> (throws without <code>/g</code>)
      </li>
    </ul>
    <p>These are all affected as follows:</p>
    <ul>
      <li>
        <code>/g</code> leads to multiple matches.
      </li>
      <li>
        <code>/y</code> leads to a single match that must start at <code>.lastIndex</code>.
      </li>
      <li>
        <code>/gy</code> leads to multiple matches without gaps.
      </li>
    </ul>
  </li>
</ol>
<p>This was a first overview. The next sections get into more details.</p>
<h4 id="how-exactly-are-methods-affected-by-g-and-y"><a class="heading-id-link" href="#how-exactly-are-methods-affected-by-g-and-y">46.16.2â€ƒHow exactly are methods affected by <code>/g</code> and <code>/y</code>?</a></h4>
<p>The following methods are unaffected by <code>/g</code> and <code>/y</code>:</p>
<ul>
  <li>
    <code>string.search(regExp)</code>
  </li>
  <li>
    <code>string.split(regExp)</code>
  </li>
</ul>
<h5 id="stringmatchregexp-es3"><a class="heading-id-link" href="#stringmatchregexp-es3">46.16.2.1â€ƒ<code>string.match(regExp)</code><span> <sup>ES3</sup></span></a></h5>
<p>Without <code>/g</code> and <code>/y</code>, <code>.match()</code> ignores <code>.lastIndex</code> and always returns a match object for the first match.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/#/</span>; re.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">1</span>;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'##-#'</span>.<span class="hljs-title function_">match</span>(re), re.<span class="hljs-property">lastIndex</span>]</span>
[{ 0: '#', index: 0, input: '##-#' }, 1]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'##-#'</span>.<span class="hljs-title function_">match</span>(re), re.<span class="hljs-property">lastIndex</span>]</span>
[{ 0: '#', index: 0, input: '##-#' }, 1]
</pre>
<p>With <code>/y</code>, the match must start at exactly <code>.lastIndex</code>. <code>.lastIndex</code> is updated. If there is no match, <code>null</code> is returned.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/#/y</span>; re.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">1</span>;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'##-#'</span>.<span class="hljs-title function_">match</span>(re), re.<span class="hljs-property">lastIndex</span>]</span>
[{ 0: '#', index: 1, input: '##-#' }, 2]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'##-#'</span>.<span class="hljs-title function_">match</span>(re), re.<span class="hljs-property">lastIndex</span>]</span>
[null, 0]
</pre>
<p>With <code>/g</code>, we get all matches (group 0) in an Array. <code>.lastIndex</code> is ignored and reset to zero.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/#/g</span>; re.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">1</span>;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'##-#'</span>.<span class="hljs-title function_">match</span>(re)</span>
['#', '#', '#']
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">re.<span class="hljs-property">lastIndex</span></span>
0
</pre>
<p><code>/gy</code> works similarly to <code>/g</code>, but no gaps between matches are allowed:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/#/gy</span>; re.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">1</span>;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'##-#'</span>.<span class="hljs-title function_">match</span>(re)</span>
['#', '#']
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">re.<span class="hljs-property">lastIndex</span></span>
0
</pre>
<h5 id="stringmatchallregexp-es2020"><a class="heading-id-link" href="#stringmatchallregexp-es2020">46.16.2.2â€ƒ<code>string.matchAll(regExp)</code><span> <sup>ES2020</sup></span></a></h5>
<p>If <code>/g</code> is not set, <code>.matchAll()</code> throws an exception:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/#/y</span>; re.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">1</span>;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'##-#'</span>.<span class="hljs-title function_">matchAll</span>(re)</span>
TypeError: String.prototype.matchAll called with
a non-global RegExp argument
</pre>
<p>If <code>/g</code> is set, matching starts at <code>.lastIndex</code> and that property isnâ€™t changed:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/#/g</span>; re.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">1</span>;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'##-#'</span>.<span class="hljs-title function_">matchAll</span>(re))</span>
[
  { 0: '#', index: 1, input: '##-#' },
  { 0: '#', index: 3, input: '##-#' },
]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">re.<span class="hljs-property">lastIndex</span></span>
1
</pre>
<p><code>/gy</code> works similarly to <code>/g</code>, but no gaps between matches are allowed:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/#/gy</span>; re.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">1</span>;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'##-#'</span>.<span class="hljs-title function_">matchAll</span>(re))</span>
[
  { 0: '#', index: 1, input: '##-#' },
]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">re.<span class="hljs-property">lastIndex</span></span>
1
</pre>
<h5 id="regexpexecstr-es3"><a class="heading-id-link" href="#regexpexecstr-es3">46.16.2.3â€ƒ<code>regExp.exec(str)</code><span> <sup>ES3</sup></span></a></h5>
<p>Without <code>/g</code> and <code>/y</code>, <code>.exec()</code> ignores <code>.lastIndex</code> and always returns a match object for the first match:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/#/</span>; re.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">1</span>;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[re.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'##-#'</span>), re.<span class="hljs-property">lastIndex</span>]</span>
[{ 0: '#', index: 0, input: '##-#' }, 1]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[re.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'##-#'</span>), re.<span class="hljs-property">lastIndex</span>]</span>
[{ 0: '#', index: 0, input: '##-#' }, 1]
</pre>
<p>With <code>/g</code>, the match must start at <code>.lastIndex</code> or later. <code>.lastIndex</code> is updated. If there is no match, <code>null</code> is returned.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/#/g</span>; re.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">1</span>;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[re.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'##-#'</span>), re.<span class="hljs-property">lastIndex</span>]</span>
[{ 0: '#', index: 1, input: '##-#' }, 2]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[re.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'##-#'</span>), re.<span class="hljs-property">lastIndex</span>]</span>
[{ 0: '#', index: 3, input: '##-#' }, 4]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[re.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'##-#'</span>), re.<span class="hljs-property">lastIndex</span>]</span>
[null, 0]
</pre>
<p>With <code>/y</code>, the match must start at exactly <code>.lastIndex</code>. <code>.lastIndex</code> is updated. If there is no match, <code>null</code> is returned.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/#/y</span>; re.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">1</span>;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[re.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'##-#'</span>), re.<span class="hljs-property">lastIndex</span>]</span>
[{ 0: '#', index: 1, input: '##-#' }, 2]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[re.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'##-#'</span>), re.<span class="hljs-property">lastIndex</span>]</span>
[null, 0]
</pre>
<p>With <code>/gy</code>, <code>.exec()</code> behaves the same as with <code>/y</code>.</p>
<h5 id="stringreplaceregexp-str-es3"><a class="heading-id-link" href="#stringreplaceregexp-str-es3">46.16.2.4â€ƒ<code>string.replace(regExp, str)</code><span> <sup>ES3</sup></span></a></h5>
<p>Without <code>/g</code> and <code>/y</code>, only the first occurrence is replaced:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/#/</span>; re.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">1</span>;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'##-#'</span>.<span class="hljs-title function_">replace</span>(re, <span class="hljs-string">'x'</span>)</span>
'x#-#'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">re.<span class="hljs-property">lastIndex</span></span>
1
</pre>
<p>With <code>/g</code>, all occurrences are replaced. <code>.lastIndex</code> is ignored but reset to zero.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/#/g</span>; re.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">1</span>;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'##-#'</span>.<span class="hljs-title function_">replace</span>(re, <span class="hljs-string">'x'</span>)</span>
'xx-x'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">re.<span class="hljs-property">lastIndex</span></span>
0
</pre>
<p>With <code>/y</code>, only the (first) occurrence at <code>.lastIndex</code> is replaced. <code>.lastIndex</code> is updated.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/#/y</span>; re.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">1</span>;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'##-#'</span>.<span class="hljs-title function_">replace</span>(re, <span class="hljs-string">'x'</span>)</span>
'#x-#'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">re.<span class="hljs-property">lastIndex</span></span>
2
</pre>
<p><code>/gy</code> works like <code>/g</code>, but gaps between matches are not allowed:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/#/gy</span>; re.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">1</span>;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'##-#'</span>.<span class="hljs-title function_">replace</span>(re, <span class="hljs-string">'x'</span>)</span>
'xx-#'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">re.<span class="hljs-property">lastIndex</span></span>
0
</pre>
<h5 id="stringreplaceallregexp-str-es2021"><a class="heading-id-link" href="#stringreplaceallregexp-str-es2021">46.16.2.5â€ƒ<code>string.replaceAll(regExp, str)</code><span> <sup>ES2021</sup></span></a></h5>
<p><code>.replaceAll()</code> works like <code>.replace()</code> but throws an exception if <code>/g</code> is not set:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/#/y</span>; re.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">1</span>;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'##-#'</span>.<span class="hljs-title function_">replaceAll</span>(re, <span class="hljs-string">'x'</span>)</span>
TypeError: String.prototype.replaceAll called
with a non-global RegExp argument
</pre>
<h5 id="regexpteststr-es3"><a class="heading-id-link" href="#regexpteststr-es3">46.16.2.6â€ƒ<code>regExp.test(str)</code><span> <sup>ES3</sup></span></a></h5>
<p>This method behaves the same same as <code>.exec()</code>, but instead of returning a match object, it returns <code>true</code>, and instead of returning <code>null</code>, it returns <code>false</code>.</p>
<p>For example, without either <code>/g</code> or <code>/y</code>, the result is always <code>true</code>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/#/</span>; re.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">1</span>;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[re.<span class="hljs-title function_">test</span>(<span class="hljs-string">'##-#'</span>), re.<span class="hljs-property">lastIndex</span>]</span>
[true, 1]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[re.<span class="hljs-title function_">test</span>(<span class="hljs-string">'##-#'</span>), re.<span class="hljs-property">lastIndex</span>]</span>
[true, 1]
</pre>
<p>With <code>/g</code>, there are two matches:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/#/g</span>; re.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">1</span>;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[re.<span class="hljs-title function_">test</span>(<span class="hljs-string">'##-#'</span>), re.<span class="hljs-property">lastIndex</span>]</span>
[true, 2]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[re.<span class="hljs-title function_">test</span>(<span class="hljs-string">'##-#'</span>), re.<span class="hljs-property">lastIndex</span>]</span>
[true, 4]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[re.<span class="hljs-title function_">test</span>(<span class="hljs-string">'##-#'</span>), re.<span class="hljs-property">lastIndex</span>]</span>
[false, 0]
</pre>
<p>With <code>/y</code>, there is only one match:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/#/y</span>; re.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">1</span>;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[re.<span class="hljs-title function_">test</span>(<span class="hljs-string">'##-#'</span>), re.<span class="hljs-property">lastIndex</span>]</span>
[true, 2]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[re.<span class="hljs-title function_">test</span>(<span class="hljs-string">'##-#'</span>), re.<span class="hljs-property">lastIndex</span>]</span>
[false, 0]
</pre>
<p>With <code>/gy</code>, <code>.test()</code> behaves the same as with <code>/y</code>.</p>
<h4 id="four-pitfalls-of-g-and-y-and-how-to-deal-with-them"><a class="heading-id-link" href="#four-pitfalls-of-g-and-y-and-how-to-deal-with-them">46.16.3â€ƒFour pitfalls of <code>/g</code> and <code>/y</code> and how to deal with them</a></h4>
<p>We will first look at four pitfalls of <code>/g</code> and <code>/y</code> and then at ways of dealing with those pitfalls.</p>
<h5 id="pitfall-1-we-cant-inline-a-regular-expression-with-g-or-y"><a class="heading-id-link" href="#pitfall-1-we-cant-inline-a-regular-expression-with-g-or-y">46.16.3.1â€ƒPitfall 1: We canâ€™t inline a regular expression with <code>/g</code> or <code>/y</code></a></h5>
<p>A regular expression with <code>/g</code> canâ€™t be inlined. For example, in the following <code>while</code> loop, the regular expression is created fresh, every time the condition is checked. Therefore, its <code>.lastIndex</code> is always zero and the loop never terminates.</p>
<pre class="language-js">
<span class="hljs-keyword">let</span> matchObj;
<span class="hljs-comment">// Infinite loop</span>
<span class="hljs-keyword">while</span> (matchObj = <span class="hljs-regexp">/a+/g</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'bbbaabaaa'</span>)) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(matchObj[<span class="hljs-number">0</span>]);
}
</pre>
<p>With <code>/y</code>, the problem is the same.</p>
<h5 id="pitfall-2-removing-g-or-y-can-break-code"><a class="heading-id-link" href="#pitfall-2-removing-g-or-y-can-break-code">46.16.3.2â€ƒPitfall 2: Removing <code>/g</code> or <code>/y</code> can break code</a></h5>
<p>If code expects a regular expression with <code>/g</code> and has a loop over the results of <code>.exec()</code> or <code>.test()</code>, then a regular expression without <code>/g</code> can cause an infinite loop:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">collectMatches</span>(<span class="hljs-params">regExp, str</span>) {
  <span class="hljs-keyword">const</span> matches = [];
  <span class="hljs-keyword">let</span> matchObj;
  <span class="hljs-comment">// Infinite loop</span>
  <span class="hljs-keyword">while</span> (matchObj = regExp.<span class="hljs-title function_">exec</span>(str)) {
    matches.<span class="hljs-title function_">push</span>(matchObj[<span class="hljs-number">0</span>]);
  }
  <span class="hljs-keyword">return</span> matches;
}
<span class="hljs-title function_">collectMatches</span>(<span class="hljs-regexp">/a+/</span>, <span class="hljs-string">'bbbaabaaa'</span>); <span class="hljs-comment">// Missing: flag /g</span>
</pre>
<p>Why is there an infinite loop? Because <code>.exec()</code> always returns the first result, a match object, and never <code>null</code>.</p>
<p>With <code>/y</code>, the problem is the same.</p>
<h5 id="pitfall-3-adding-g-or-y-can-break-code"><a class="heading-id-link" href="#pitfall-3-adding-g-or-y-can-break-code">46.16.3.3â€ƒPitfall 3: Adding <code>/g</code> or <code>/y</code> can break code</a></h5>
<p>With <code>.test()</code>, there is another caveat: It is affected by <code>.lastIndex</code>. Therefore, if we want to check exactly once if a regular expression matches a string, then the regular expression must not have <code>/g</code>. Otherwise, we generally get a different result every time we call <code>.test()</code>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> regExp = <span class="hljs-regexp">/^X/g</span>;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[regExp.<span class="hljs-title function_">test</span>(<span class="hljs-string">'Xa'</span>), regExp.<span class="hljs-property">lastIndex</span>]</span>
[ true, 1 ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[regExp.<span class="hljs-title function_">test</span>(<span class="hljs-string">'Xa'</span>), regExp.<span class="hljs-property">lastIndex</span>]</span>
[ false, 0 ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[regExp.<span class="hljs-title function_">test</span>(<span class="hljs-string">'Xa'</span>), regExp.<span class="hljs-property">lastIndex</span>]</span>
[ true, 1 ]
</pre>
<p>The first invocation produces a match and updates <code>.lastIndex</code>. The second invocation does not find a match and resets <code>.lastIndex</code> to zero.</p>
<p>If we create a regular expression specifically for <code>.test()</code>, then we probably wonâ€™t add <code>/g</code>. However, the likeliness of encountering <code>/g</code> increases if we use the same regular expression for replacing and for testing.</p>
<p>Once again, this problem also exists with <code>/y</code>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> regExp = <span class="hljs-regexp">/^X/y</span>;</span>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">regExp.<span class="hljs-title function_">test</span>(<span class="hljs-string">'Xa'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">regExp.<span class="hljs-title function_">test</span>(<span class="hljs-string">'Xa'</span>)</span>
false
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">regExp.<span class="hljs-title function_">test</span>(<span class="hljs-string">'Xa'</span>)</span>
true
</pre>
<h5 id="pitfall-4-code-can-produce-unexpected-results-if-lastindex-isnt-zero"><a class="heading-id-link" href="#pitfall-4-code-can-produce-unexpected-results-if-lastindex-isnt-zero">46.16.3.4â€ƒPitfall 4: Code can produce unexpected results if <code>.lastIndex</code> isnâ€™t zero</a></h5>
<p>If an operation uses regular expression methods that are affected by <code>.lastIndex</code>, then we must ensure that <code>.lastIndex</code> is zero at the beginning. Otherwise, we may get unexpected results:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">countMatches</span>(<span class="hljs-params">regExp, str</span>) {
  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (regExp.<span class="hljs-title function_">test</span>(str)) {
    count++;
  }
  <span class="hljs-keyword">return</span> count;
}
<code/>
<span class="hljs-keyword">const</span> myRegExp = <span class="hljs-regexp">/a/g</span>;
myRegExp.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">4</span>;
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title function_">countMatches</span>(myRegExp, <span class="hljs-string">'babaa'</span>), <span class="hljs-number">1</span> <span class="hljs-comment">// should be 3</span>
);
</pre>
<p>Normally, <code>.lastIndex</code> is zero in newly created regular expressions and we wonâ€™t change it explicitly like we did in the example. But <code>.lastIndex</code> can still end up not being zero if we use the regular expression multiple times.</p>
<h5 id="how-to-avoid-the-pitfalls-of-g-and-y"><a class="heading-id-link" href="#how-to-avoid-the-pitfalls-of-g-and-y">46.16.3.5â€ƒHow to avoid the pitfalls of <code>/g</code> and <code>/y</code></a></h5>
<p>As an example of dealing with <code>/g</code> and <code>.lastIndex</code>, we revisit <code>countMatches()</code> from the previous example. How do we prevent a wrong regular expression from breaking our code? Letâ€™s look at three approaches.</p>
<h6 id="throwing-exceptions"><a class="heading-id-link" href="#throwing-exceptions">46.16.3.5.1â€ƒThrowing exceptions</a></h6>
<p>First, we can throw an exception if <code>/g</code> isnâ€™t set or <code>.lastIndex</code> isnâ€™t zero:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">countMatches</span>(<span class="hljs-params">regExp, str</span>) {
  <span class="hljs-keyword">if</span> (!regExp.<span class="hljs-property">global</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Flag /g of regExp must be set'</span>);
  }
  <span class="hljs-keyword">if</span> (regExp.<span class="hljs-property">lastIndex</span> !== <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'regExp.lastIndex must be zero'</span>);
  }
  
  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (regExp.<span class="hljs-title function_">test</span>(str)) {
    count++;
  }
  <span class="hljs-keyword">return</span> count;
}
</pre>
<h6 id="cloning-regular-expressions"><a class="heading-id-link" href="#cloning-regular-expressions">46.16.3.5.2â€ƒCloning regular expressions</a></h6>
<p>Second, we can clone the parameter. That has the added benefit that <code>regExp</code> wonâ€™t be changed.</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">countMatches</span>(<span class="hljs-params">regExp, str</span>) {
  <span class="hljs-keyword">const</span> cloneFlags = regExp.<span class="hljs-property">flags</span> + (regExp.<span class="hljs-property">global</span> ? <span class="hljs-string">''</span> : <span class="hljs-string">'g'</span>);
  <span class="hljs-keyword">const</span> clone = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(regExp, cloneFlags);
<code/>
  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (clone.<span class="hljs-title function_">test</span>(str)) {
    count++;
  }
  <span class="hljs-keyword">return</span> count;
}
</pre>
<h6 id="using-an-operation-that-isnt-affected-by-lastindex-or-flags"><a class="heading-id-link" href="#using-an-operation-that-isnt-affected-by-lastindex-or-flags">46.16.3.5.3â€ƒUsing an operation that isnâ€™t affected by <code>.lastIndex</code> or flags</a></h6>
<p>Several regular expression operations are not affected by <code>.lastIndex</code> or by flags. For example, <code>.match()</code> ignores <code>.lastIndex</code> if <code>/g</code> is present:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">countMatches</span>(<span class="hljs-params">regExp, str</span>) {
  <span class="hljs-keyword">if</span> (!regExp.<span class="hljs-property">global</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Flag /g of regExp must be set'</span>);
  }
  <span class="hljs-keyword">return</span> (str.<span class="hljs-title function_">match</span>(regExp) ?? []).<span class="hljs-property">length</span>;
}
<code/>
<span class="hljs-keyword">const</span> myRegExp = <span class="hljs-regexp">/a/g</span>;
myRegExp.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">4</span>;
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">countMatches</span>(myRegExp, <span class="hljs-string">'babaa'</span>), <span class="hljs-number">3</span>); <span class="hljs-comment">// OK!</span>
</pre>
<p>Here, <code>countMatches()</code> works even though we didnâ€™t check or fix <code>.lastIndex</code>.</p>
<h4 id="use-case-for-lastindex-starting-matching-at-a-given-index"><a class="heading-id-link" href="#use-case-for-lastindex-starting-matching-at-a-given-index">46.16.4â€ƒUse case for <code>.lastIndex</code>: starting matching at a given index</a></h4>
<p>Apart from storing the current position when matching multiple times, <code>.lastIndex</code> can also be used to:</p>
<ul>
  <li>
    Match once at exactly a given position (via flag <code>/y</code>)
  </li>
  <li>
    Match once at a given position or later (via flag <code>/g</code>)
  </li>
</ul>
<p>Weâ€™ll look at examples next.</p>
<h5 id="example-checking-if-a-regular-expression-matches-at-a-given-index"><a class="heading-id-link" href="#example-checking-if-a-regular-expression-matches-at-a-given-index">46.16.4.1â€ƒExample: Checking if a regular expression matches at a given index</a></h5>
<p>Given that <code>.test()</code> is affected by <code>/y</code> and <code>.lastIndex</code>, we can use it to check if a regular expression <code>regExp</code> matches a string <code>str</code> at exactly a given <code>index</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">startsWith</span>(<span class="hljs-params">regExp, str, index</span>) {
  <span class="hljs-keyword">if</span> (!regExp.<span class="hljs-property">sticky</span> || regExp.<span class="hljs-property">global</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Flag /y must be set. Flag /g must not be set.'</span>);
  }
  regExp.<span class="hljs-property">lastIndex</span> = index;
  <span class="hljs-keyword">return</span> regExp.<span class="hljs-title function_">test</span>(str);
}
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title function_">startsWith</span>(<span class="hljs-regexp">/x+/y</span>, <span class="hljs-string">'aaxxx'</span>, <span class="hljs-number">0</span>), <span class="hljs-literal">false</span>
);
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title function_">startsWith</span>(<span class="hljs-regexp">/x+/y</span>, <span class="hljs-string">'aaxxx'</span>, <span class="hljs-number">2</span>), <span class="hljs-literal">true</span>
);
</pre>
<p><code>regExp</code> is anchored to <code>.lastIndex</code> due to <code>/y</code>.</p>
<p>Note that we must not use the assertion <code>^</code> which would anchor <code>regExp</code> to the beginning of the input string.</p>
<h5 id="example-finding-the-location-of-a-match-starting-at-a-given-index"><a class="heading-id-link" href="#example-finding-the-location-of-a-match-starting-at-a-given-index">46.16.4.2â€ƒExample: Finding the location of a match, starting at a given index</a></h5>
<p><code>.search()</code> lets us find the location where a regular expression matches:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'#--#'</span>.<span class="hljs-title function_">search</span>(<span class="hljs-regexp">/#/</span>)</span>
0
</pre>
<p>Alas, we canâ€™t change where <code>.search()</code> starts looking for matches. As a workaround, we can use <code>.exec()</code> for searching:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">searchFrom</span>(<span class="hljs-params">regExp, str, index</span>) {
  <span class="hljs-keyword">if</span> (!regExp.<span class="hljs-property">global</span> || regExp.<span class="hljs-property">sticky</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Flag /g must be set. Flag /y must not be set.'</span>);
  }
  regExp.<span class="hljs-property">lastIndex</span> = index;
  <span class="hljs-keyword">const</span> match = regExp.<span class="hljs-title function_">exec</span>(str);
  <span class="hljs-keyword">if</span> (match) {
    <span class="hljs-keyword">return</span> match.<span class="hljs-property">index</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
  }
}
<code/>
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title function_">searchFrom</span>(<span class="hljs-regexp">/#/g</span>, <span class="hljs-string">'#--#'</span>, <span class="hljs-number">0</span>), <span class="hljs-number">0</span>
);
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title function_">searchFrom</span>(<span class="hljs-regexp">/#/g</span>, <span class="hljs-string">'#--#'</span>, <span class="hljs-number">1</span>), <span class="hljs-number">3</span>
);
</pre>
<h5 id="example-replacing-an-occurrence-at-a-given-index"><a class="heading-id-link" href="#example-replacing-an-occurrence-at-a-given-index">46.16.4.3â€ƒExample: Replacing an occurrence at a given index</a></h5>
<p>When used without <code>/g</code> and with <code>/y</code>, <code>.replace()</code> makes one replacement â€“ if there is a match at <code>.lastIndex</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">replaceOnceAt</span>(<span class="hljs-params">str, regExp, replacement, index</span>) {
  <span class="hljs-keyword">if</span> (!regExp.<span class="hljs-property">sticky</span> || regExp.<span class="hljs-property">global</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Flag /y must be set. Flag /g must not be set.'</span>);
  }
  regExp.<span class="hljs-property">lastIndex</span> = index;
  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">replace</span>(regExp, replacement);
}
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title function_">replaceOnceAt</span>(<span class="hljs-string">'aa aaaa a'</span>, <span class="hljs-regexp">/a+/y</span>, <span class="hljs-string">'X'</span>, <span class="hljs-number">0</span>), <span class="hljs-string">'X aaaa a'</span>)
;
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title function_">replaceOnceAt</span>(<span class="hljs-string">'aa aaaa a'</span>, <span class="hljs-regexp">/a+/y</span>, <span class="hljs-string">'X'</span>, <span class="hljs-number">3</span>), <span class="hljs-string">'aa X a'</span>
);
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title function_">replaceOnceAt</span>(<span class="hljs-string">'aa aaaa a'</span>, <span class="hljs-regexp">/a+/y</span>, <span class="hljs-string">'X'</span>, <span class="hljs-number">8</span>), <span class="hljs-string">'aa aaaa X'</span>
);
</pre>
<h4 id="regexp-lastindex-upsides-downsides"><a class="heading-id-link" href="#regexp-lastindex-upsides-downsides">46.16.5â€ƒThe downsides and an upside of <code>.lastIndex</code></a></h4>
<p>The regular expression property <code>.lastIndex</code> has two significant downsides:</p>
<ul>
  <li>
    It makes regular expressions stateful:
    <ul>
      <li>
        We now have to be mindful of the states of regular expressions and how we share them.
      </li>
      <li>
        For many use cases, we canâ€™t make them immutable via freezing, either.
      </li>
    </ul>
  </li>
  <li>
    Support for <code>.lastIndex</code> is inconsistent among regular expression operations.
  </li>
</ul>
<p>On the upside, <code>.lastIndex</code> also gives us additional useful functionality: We can dictate where matching should begin (for some operations). Ideally, such functionality would be provided via an assertion such as <code>\G</code> (vs. a flag <code>/y</code>) and an index as an argument for various regular-expression-related methods (vs. a regular expression property <code>.lastIndex</code>). But itâ€™s better than not having it at all.</p>
<h3 id="RegExp.escape"><a class="heading-id-link" href="#RegExp.escape">46.17â€ƒ<code>RegExp.escape()</code>: escaping text so that it can be used inside a regular expression<span> <sup>ES2025</sup></span></a></h3>
<p>For a string <code>text</code>, <code>RegExp.escape(text)</code> creates a regular expression pattern that matches <code>text</code>.</p>
<p>Characters that have special meaning in regular expressions canâ€™t be used verbatim and have to be escaped:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">RegExp</span>.<span class="hljs-built_in">escape</span>(<span class="hljs-string">'(*)'</span>)</span>
'\\(\\*\\)'
</pre>
<p>Note that we see each regular expression backslash twice: One of them is the actual backslash, the other one escapes it inside the string literal:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'\\(\\*\\)'</span> === <span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`\(\*\)`</span></span>
true
</pre>
<p>Characters that have no special meaning donâ€™t have to be escaped:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">RegExp</span>.<span class="hljs-built_in">escape</span>(<span class="hljs-string">'_abc123'</span>)</span>
'_abc123'
</pre>
<h4 id="use-case-for-regexpescape-replacing-all-occurrences-of-a-text"><a class="heading-id-link" href="#use-case-for-regexpescape-replacing-all-occurrences-of-a-text">46.17.1â€ƒUse case for <code>RegExp.escape()</code>: replacing all occurrences of a text</a></h4>
<p>The classic use case for escaping was searching and replacing text:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">replacePlainText</span>(<span class="hljs-params">str, searchText, replace</span>) {
  <span class="hljs-keyword">const</span> searchRegExp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(
    <span class="hljs-title class_">RegExp</span>.<span class="hljs-built_in">escape</span>(searchText),
    <span class="hljs-string">'gu'</span>
  );
  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">replace</span>(searchRegExp, replace)
}
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title function_">replacePlainText</span>(<span class="hljs-string">'(a) and (a)'</span>, <span class="hljs-string">'(a)'</span>, <span class="hljs-string">'@'</span>),
  <span class="hljs-string">'@ and @'</span>
);
</pre>
<p>However, since ES2021, we have <a href="#String.prototype.replaceAll"><code>.replaceAll()</code></a>:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-string">'(a) and (a)'</span>.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-string">'(a)'</span>, <span class="hljs-string">'@'</span>),
  <span class="hljs-string">'@ and @'</span>
);
</pre>
<h4 id="use-case-for-regexpescape-part-of-a-regular-expression-must-match-a-given-text"><a class="heading-id-link" href="#use-case-for-regexpescape-part-of-a-regular-expression-must-match-a-given-text">46.17.2â€ƒUse case for <code>RegExp.escape()</code>: part of a regular expression must match a given text</a></h4>
<p>The following code removes all occurrences of <code>text</code> inside <code>str</code> that are not quoted:</p>
<pre class="language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">removeUnquotedText</span>(<span class="hljs-params">str, text</span>) {
  <span class="hljs-keyword">const</span> regExp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(
    <span class="hljs-string">`(?&lt;!â€œ)<span class="hljs-subst">${<span class="hljs-built_in">RegExp</span>.<span class="hljs-built_in">escape</span>(text)}</span>(?!â€)`</span>,
    <span class="hljs-string">'gu'</span>
  );
  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">replaceAll</span>(regExp, <span class="hljs-string">'â€¢'</span>);
}
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title function_">removeUnquotedText</span>(<span class="hljs-string">'â€œyesâ€ and yes and â€œyesâ€'</span>, <span class="hljs-string">'yes'</span>),
  <span class="hljs-string">'â€œyesâ€ and â€¢ and â€œyesâ€'</span>
);
</pre>
<p>The same approach can also be used to find or count unquoted text.</p>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon â€œexerciseâ€" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/>â€‚<strong>Exercise: Searching for text that contains a wildcard</strong></p>
  <div class="boxout-vspace"/>
  <p>âœ… <code>exercises/regexps/includes-with-elision_test.mjs</code></p>
</div>
<h3 id="matching-everything-or-nothing"><a class="heading-id-link" href="#matching-everything-or-nothing">46.18â€ƒMatching everything or nothing</a></h3>
<p>Sometimes, we may need a regular expression that matches everything or nothing â€“ for example, as a default value.</p>
<ul>
  <li>
    <p>Match everything: <code>/(?:)/</code></p>
    <p>The empty group <code>()</code> matches everything. We make it non-capturing (via <code>?:</code>), to avoid unnecessary work.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/(?:)/.<span class="hljs-title function_">test</span>(<span class="hljs-string">''</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/(?:)/.<span class="hljs-title function_">test</span>(<span class="hljs-string">'abc'</span>)</span>
true
</pre>
  </li>
  <li>
    <p>Match nothing: <code>/.^/</code></p>
    <p><code>^</code> only matches at the beginning of a string. The dot moves matching beyond the first character and now <code>^</code> doesnâ€™t match anymore.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/.^/.<span class="hljs-title function_">test</span>(<span class="hljs-string">''</span>)</span>
false
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/.^/.<span class="hljs-title function_">test</span>(<span class="hljs-string">'abc'</span>)</span>
false
</pre>
  </li>
</ul>
<p>Regular expression literals canâ€™t be empty because <code>//</code> starts a single-line comment. Therefore, the first of the previous two regular expressions is used in this case:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">''</span>)</span>
/(?:)/
</pre>
<h3 id="tips-for-making-regular-expressions-easier-to-use"><a class="heading-id-link" href="#tips-for-making-regular-expressions-easier-to-use">46.19â€ƒTips for making regular expressions easier to use</a></h3>
<p>In this section, we explore ways in which we can make regular expressions easier to use. Weâ€™ll use the following regular expression as an example:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RE_API_SIGNATURE</span> =
  <span class="hljs-regexp">/^(new |get )?([A-Za-z0-9_.\[\]]+)/</span>;
</pre>
<p>Right now, it is still fairly cryptic. It will be much easier to understand once we get to â€œinsignificant whitespaceâ€.</p>
<h4 id="tip-use-flag-v"><a class="heading-id-link" href="#tip-use-flag-v">46.19.1â€ƒTip: Use flag <code>/v</code></a></h4>
<p>If we add flag <code>/v</code> to our regular expression, we get fewer quirks and more features:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RE_API_SIGNATURE</span> =
  <span class="hljs-regexp">/^(new |get )?([A-Za-z0-9_.\[\]]+)/</span>v;
</pre>
<p><code>/v</code> doesnâ€™t change anything in this particular case, but it helps us if we add grapheme clusters with more than one code point or if we want features such as set operations in character classes.</p>
<h4 id="tip-order-flags-alphabetically"><a class="heading-id-link" href="#tip-order-flags-alphabetically">46.19.2â€ƒTip: order flags alphabetically</a></h4>
<p>If there is more than one flag, we should <a href="#order-of-regexp-flags">order the flags alphabetically</a> â€“Â e.g.:</p>
<pre class="language-js">
/pattern/giv
</pre>
<p>That makes ordering consistent and is also how JavaScript displays regular expressions:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">String</span>(<span class="hljs-regexp">/pattern/</span>vgi)</span>
'/pattern/giv'
</pre>
<h4 id="tip-use-named-capture-groups"><a class="heading-id-link" href="#tip-use-named-capture-groups">46.19.3â€ƒTip: Use named capture groups</a></h4>
<p>Our regular expression contains two positional capture groups. If we name them, they describe their purposes and we need less external documentation:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RE_API_SIGNATURE</span> =
  <span class="hljs-regexp">/^(?&lt;prefix&gt;new |get )?(?&lt;name&gt;[A-Za-z0-9_.\[\]]+)/</span>;
</pre>
<h4 id="tip-insignificant-whitespace-and-line-comments-via-"><a class="heading-id-link" href="#tip-insignificant-whitespace-and-line-comments-via-">46.19.4â€ƒTip: insignificant whitespace and line comments via <code>#</code></a></h4>
<p>So far, the regular expression is still fairly hard to read. We can change that by adding spaces and line breaks. Since regular expression literals donâ€™t allow us to do that, we use the library <a href="https://github.com/slevithan/regex">Regex+</a> which provides us with the template tag <code>regex</code>:</p>
<pre class="language-js">
<span class="hljs-keyword">import</span> {regex} <span class="hljs-keyword">from</span> <span class="hljs-string">'regex'</span>;
<code/>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RE_API_SIGNATURE</span> = regex<span class="hljs-string">`</span>
<span class="hljs-string">  ^</span>
<span class="hljs-string">  (?&lt;prefix&gt;</span>
<span class="hljs-string">    new \x20  # constructor</span>
<span class="hljs-string">    |</span>
<span class="hljs-string">    get \x20  # getter</span>
<span class="hljs-string">  )?</span>
<span class="hljs-string">  (?&lt;name&gt;</span>
<span class="hljs-string">    # Square brackets are needed for symbol keys</span>
<span class="hljs-string">    [</span>
<span class="hljs-string">      A-Z a-z 0-9 _</span>
<span class="hljs-string">      .</span>
<span class="hljs-string">      \[ \]</span>
<span class="hljs-string">    ]+</span>
<span class="hljs-string">  )</span>
<span class="hljs-string">`</span>;
</pre>
<p>The feature of ignoring whitespace in regular expression patterns is called <em>insignificant whitespace</em>. Additionally, we used a feature called <em>inline comments</em> â€“ which are started by hash symbols (<code>#</code>).</p>
<p>Two observations:</p>
<ul>
  <li>
    Since all spaces are removed, we use the hex escape <code>\x20</code> to express that there is a space after <code>new</code> and after <code>get</code>.
  </li>
  <li>
    Alas, line comments are not allowed inside character classes. Thatâ€™s why the comment about square brackets comes before the character class.
  </li>
</ul>
<p>In the future, JavaScript may get built-in support for insignificant whitespace via a flag <code>/x</code> (<a href="https://github.com/tc39/proposal-regexp-x-mode">ECMAScript proposal</a>).</p>
<p>With the <code>regex</code> template tag, the following flags are always active:</p>
<ul>
  <li>
    Flag <code>/v</code>
  </li>
  <li>
    Flag <code>/x</code> (emulated) enables insignificant whitespace and line comments via <code>#</code>.
  </li>
  <li>
    Flag <code>/n</code> (emulated) enables <em>named capture only mode</em>, which prevents numbered groups from capturing. In other words: <code>(pattern)</code> is treated like <code>(?:pattern)</code>.
  </li>
</ul>
<h4 id="tip-write-tests-for-your-regular-expression"><a class="heading-id-link" href="#tip-write-tests-for-your-regular-expression">46.19.5â€ƒTip: Write tests for your regular expression</a></h4>
<p>To make sure that a regular expression works as intended, we can write tests for it. These are tests for <code>RE_API_SIGNATURE</code>:</p>
<pre class="language-js">
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title function_">getCaptures</span>(<span class="hljs-string">`get Map.prototype.size`</span>),
  {
    <span class="hljs-attr">prefix</span>: <span class="hljs-string">'get '</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Map.prototype.size'</span>,
  }
);
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title function_">getCaptures</span>(<span class="hljs-string">`new Array(len = 0)`</span>),
  {
    <span class="hljs-attr">prefix</span>: <span class="hljs-string">'new '</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Array'</span>,
  }
);
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title function_">getCaptures</span>(<span class="hljs-string">`Array.prototype.push(...items)`</span>),
  {
    <span class="hljs-attr">prefix</span>: <span class="hljs-literal">undefined</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Array.prototype.push'</span>,
  }
);
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title function_">getCaptures</span>(<span class="hljs-string">`Map.prototype[Symbol.iterator]()`</span>),
  {
    <span class="hljs-attr">prefix</span>: <span class="hljs-literal">undefined</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Map.prototype[Symbol.iterator]'</span>,
  }
);
<code/>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getCaptures</span>(<span class="hljs-params">apiSignature</span>) {
  <span class="hljs-keyword">const</span> match = <span class="hljs-variable constant_">RE_API_SIGNATURE</span>.<span class="hljs-title function_">exec</span>(apiSignature);
  <span class="hljs-comment">// Spread so that the result does not have a null prototype</span>
  <span class="hljs-comment">// and is easier to compare.</span>
  <span class="hljs-keyword">return</span> {...match.<span class="hljs-property">groups</span>};
}
</pre>
<h4 id="tip-mention-examples-in-your-documentation"><a class="heading-id-link" href="#tip-mention-examples-in-your-documentation">46.19.6â€ƒTip: Mention examples in your documentation</a></h4>
<p>Seeing strings that match, helps with understanding what a regular expression is supposed to do:</p>
<pre class="language-js">
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Matches API signatures â€“ e.g.:</span>
<span class="hljs-comment"> * ```</span>
<span class="hljs-comment"> * `get Map.prototype.size`</span>
<span class="hljs-comment"> * `new Array(len = 0)`</span>
<span class="hljs-comment"> * `Array.prototype.push(...items)`</span>
<span class="hljs-comment"> * `Map.prototype[Symbol.iterator]()`</span>
<span class="hljs-comment"> * ```</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RE_API_SIGNATURE</span> = regex<span class="hljs-string">`</span>
<span class="hljs-string">  Â·Â·Â·</span>
<span class="hljs-string">`</span>;
</pre>
<p>Some documentation tools let us refer to unit tests in doc comments and show their code in the documentation. Thatâ€™s a good alternative to what we have done above.</p>
<h4 id="bonus-tip-use-interpolation-to-reuse-patterns"><a class="heading-id-link" href="#bonus-tip-use-interpolation-to-reuse-patterns">46.19.7â€ƒBonus tip: Use interpolation to reuse patterns</a></h4>
<p>The Regex+ library lets us interpolate regular expression fragments (â€œpatternsâ€), which helps with reuse. The following example defines a simple markup syntax that is reminiscent of HTML:</p>
<pre class="language-js">
<span class="hljs-keyword">import</span> { pattern, regex } <span class="hljs-keyword">from</span> <span class="hljs-string">'regex'</span>;
<code/>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">LABEL</span> = pattern<span class="hljs-string">`[a-z\-]+`</span>;
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ARGS</span> = pattern<span class="hljs-string">`</span>
<span class="hljs-string">  (?&lt;args&gt;</span>
<span class="hljs-string">    \x20+</span>
<span class="hljs-string">    <span class="hljs-subst">${LABEL}</span></span>
<span class="hljs-string">  )*</span>
<span class="hljs-string">`</span>;
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">NAME</span> = pattern<span class="hljs-string">`</span>
<span class="hljs-string">  (?&lt;name&gt; <span class="hljs-subst">${LABEL}</span> )</span>
<span class="hljs-string">`</span>;
<code/>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TAG</span> = regex<span class="hljs-string">`</span>
<span class="hljs-string">  (?&lt;openingTag&gt;</span>
<span class="hljs-string">    \[</span>
<span class="hljs-string">    \x20*</span>
<span class="hljs-string">    <span class="hljs-subst">${NAME}</span></span>
<span class="hljs-string">    <span class="hljs-subst">${ARGS}</span></span>
<span class="hljs-string">    \x20*</span>
<span class="hljs-string">    \]</span>
<span class="hljs-string">  )</span>
<span class="hljs-string">  |</span>
<span class="hljs-string">  (?&lt;singletonTag&gt;</span>
<span class="hljs-string">    \[</span>
<span class="hljs-string">    \x20*</span>
<span class="hljs-string">    <span class="hljs-subst">${NAME}</span></span>
<span class="hljs-string">    <span class="hljs-subst">${ARGS}</span></span>
<span class="hljs-string">    \x20*</span>
<span class="hljs-string">    / \]</span>
<span class="hljs-string">  )</span>
<span class="hljs-string">`</span>;
<code/>
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-variable constant_">TAG</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'[pre js line-numbers]'</span>).<span class="hljs-property">groups</span>,
  {
    <span class="hljs-attr">openingTag</span>: <span class="hljs-string">'[pre js line-numbers]'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'pre'</span>,
    <span class="hljs-attr">args</span>: <span class="hljs-string">' line-numbers'</span>,
    <span class="hljs-attr">singletonTag</span>: <span class="hljs-literal">undefined</span>,
    <span class="hljs-attr">__proto__</span>: <span class="hljs-literal">null</span>,
  }
);
<code/>
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-variable constant_">TAG</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'[hr /]'</span>).<span class="hljs-property">groups</span>,
  {
    <span class="hljs-attr">openingTag</span>: <span class="hljs-literal">undefined</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'hr'</span>,
    <span class="hljs-attr">args</span>: <span class="hljs-literal">undefined</span>,
    <span class="hljs-attr">singletonTag</span>: <span class="hljs-string">'[hr /]'</span>,
    <span class="hljs-attr">__proto__</span>: <span class="hljs-literal">null</span>,
  }
);
</pre>
<p>The regular expression <code>TAG</code> uses the regular expression fragments <code>NAME</code> and <code>ARGS</code> twice â€“Â which reduces redundancy.</p>
<h4 id="bonus-tip-insignificant-whitespace-without-a-library"><a class="heading-id-link" href="#bonus-tip-insignificant-whitespace-without-a-library">46.19.8â€ƒBonus tip: insignificant whitespace without a library</a></h4>
<p>With the following trick, we donâ€™t need a library to write a regular expression with insignificant whitespace:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RE_API_SIGNATURE</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(
  <span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`</span>
<span class="hljs-string">    ^</span>
<span class="hljs-string">    (?&lt;prefix&gt;</span>
<span class="hljs-string">      new \x20</span>
<span class="hljs-string">      |</span>
<span class="hljs-string">      get \x20</span>
<span class="hljs-string">    )?</span>
<span class="hljs-string">    (?&lt;name&gt;</span>
<span class="hljs-string">      [</span>
<span class="hljs-string">        A-Z a-z 0-9 _</span>
<span class="hljs-string">        .</span>
<span class="hljs-string">        \[ \]</span>
<span class="hljs-string">      ]+</span>
<span class="hljs-string">    )</span>
<span class="hljs-string">  `</span>.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-regexp">/\s+/g</span>, <span class="hljs-string">''</span>), <span class="hljs-comment">// (A)</span>
  <span class="hljs-string">'v'</span>
);
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title class_">String</span>(<span class="hljs-variable constant_">RE_API_SIGNATURE</span>),
  <span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`/^(?&lt;prefix&gt;new\x20|get\x20)?(?&lt;name&gt;[A-Za-z0-9_.\[\]]+)/v`</span>
);
</pre>
<p>How does this code work?</p>
<ul>
  <li>
    <a href="ch_template-literals.html#raw-string-literals"><code>String.raw</code></a> enables two things:
    <ul>
      <li>
        We donâ€™t have to escape regular expression backslashes for this kind of string literal.
      </li>
      <li>
        The regular expression can span multiple lines.
      </li>
    </ul>
  </li>
  <li>
    <code>.replaceAll()</code> removes all whitespace (spaces, tabs, line breaks, etc.) so that the end result looks almost like the initial version of the regular expression. There is one difference, though: Since literal spaces are removed, we have to find a different way to specify that there is a space after <code>new</code> and after <code>get</code>. One option is the hex escape <code>\x20</code>: hexadecimal 20 (decimal 32) is the code point SPACE.
  </li>
</ul>
<p>We can even emulate inline comments like this:</p>
<pre class="language-js">
<span class="hljs-comment">// Template tag function</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">cmt</span> = (<span class="hljs-params">) =&gt; <span class="hljs-string">''</span>;</span>
<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RE</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(</span>
<span class="hljs-params">  <span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`</span></span>
<span class="hljs-params"><span class="hljs-string">    a+ <span class="hljs-subst">${cmt<span class="hljs-string">`one or more as`</span>}</span></span></span>
<span class="hljs-params"><span class="hljs-string">  `</span>.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-regexp">/\s+/g</span>, <span class="hljs-string">''</span>),</span>
<span class="hljs-params">  <span class="hljs-string">'v'</span></span>
<span class="hljs-params">);</span>
<span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span>
<span class="hljs-params">  <span class="hljs-title class_">String</span>(<span class="hljs-variable constant_">RE</span>), <span class="hljs-string">'/a+/v'</span></span>
<span class="hljs-params">);</span>
</pre>
<p>Alas, itâ€™s more syntactically noisy than Iâ€™d like.</p>
<h4 id="conclusion-this-is-how-regular-expressions-are-meant-to-be-written"><a class="heading-id-link" href="#conclusion-this-is-how-regular-expressions-are-meant-to-be-written">46.19.9â€ƒConclusion: This is how regular expressions are meant to be written</a></h4>
<p>One reason why many people donâ€™t like regular expressions is that they find them difficult to read. However, that is much less of a problem with insignificant whitespace and comments. Iâ€™d argue that is the proper way of writing regular expressions: Think what JavaScript code would look like if we had to write it without whitespace and comments.</p>
<h3 id="quickref-RegExp"><a class="heading-id-link" href="#quickref-RegExp">46.20â€ƒQuick reference: regular expression functionality</a></h3>
<h4 id="summary-flags-global-sticky"><a class="heading-id-link" href="#summary-flags-global-sticky">46.20.1â€ƒSummary: <code>.global</code> (<code>/g</code>) and <code>.sticky</code> (<code>/y</code>)</a></h4>
<p>The following two methods are completely unaffected by <code>/g</code> and <code>/y</code>:</p>
<ul>
  <li>
    <code>String.prototype.search()</code>
  </li>
  <li>
    <code>String.prototype.split()</code>
  </li>
</ul>
<p>This table explains how the remaining regular-expression-related methods are affected by these two flags (if neither <code>/g</code> nor <code>/y</code> are there, <code>regExp.lastIndex</code> is always ignored):</p>
<table class="framed">
  <style>
    th:nth-child(1), td:nth-child(1) {
      text-align: left;
    }
    th:nth-child(2), td:nth-child(2) {
      text-align: left;
    }
    th:nth-child(3), td:nth-child(3) {
      text-align: left;
    }
    th:nth-child(4), td:nth-child(4) {
      text-align: left;
    }
  </style>
  <thead>
    <tr>
      <th/><th>Flags</th><th>Honors <code>.lastIndex</code>?</th><th>Updates <code>.lastIndex</code>?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>s.match</code></td><td><code>/y</code></td><td>âœ”</td><td>âœ”</td>
    </tr>
    <tr>
      <td/><td><code>/g /gy</code></td><td>âœ˜</td><td>0</td>
    </tr>
    <tr>
      <td><code>s.matchAll</code></td><td><code>/g /gy</code></td><td>âœ”</td><td>âœ˜</td>
    </tr>
    <tr>
      <td><code>r.exec</code></td><td><code>/g /y /gy</code></td><td>âœ”</td><td>âœ”</td>
    </tr>
    <tr>
      <td><code>s.replace</code></td><td><code>/y</code></td><td>âœ”</td><td>âœ”</td>
    </tr>
    <tr>
      <td/><td><code>/g /gy</code></td><td>âœ˜</td><td>0</td>
    </tr>
    <tr>
      <td><code>s.replaceAll</code></td><td><code>/g /gy</code></td><td>âœ˜</td><td>0</td>
    </tr>
    <tr>
      <td><code>r.test</code></td><td><code>/g /y /gy</code></td><td>âœ”</td><td>âœ”</td>
    </tr>
  </tbody>
</table>
<div class="boxout">
  <p><img src="../Images/38e6ff55e8d602659f3cdb8893e63f62.png" class="boxout-icon" height="24" alt="Icon â€œexternalâ€" data-original-src="https://exploringjs.com/js/book/icon/external.svg"/>â€‚<strong>A longer overview</strong></p>
  <div class="boxout-vspace"/>
  <p>I posted <a href="https://gist.github.com/rauschma/5c90e6c19923611521a61e199d8cb15b">a longer table</a> online that was created via a Node.js script.</p>
</div>
<h4 id="stringprototype-matching-and-searching"><a class="heading-id-link" href="#stringprototype-matching-and-searching">46.20.2â€ƒ<code>String.prototype.*</code>: matching and searching</a></h4>
<ul>
  <li>
    <p><code id="qref-String.prototype.match">String.prototype.match(regExpOrString)</code><br/><span class="ibox ibox-small" size="small">ES3 | <code>/y</code> honors and updates <code>.lastIndex</code> | <code>/g /gy</code> ignore and reset <code>.lastIndex</code> </span></p>
    <ul>
      <li>
        <p>(1 of 3) <code>regExpOrString</code> is a string.</p>
        <p>If <code>regExpOrString</code> is a string, it defines a pattern for a regular expression without <code>/g</code> (think parameter of <code>new RegExp()</code>). That regular expression is used as explained in the next list item.</p>
      </li>
      <li>
        <p>(2 of 3) <code>regExpOrString</code> is a RegExp without <code>/g</code>.</p>
<pre class="language-ts">
<span class="hljs-title function_">match</span>(
  <span class="hljs-attr">regExpOrString</span>: <span class="hljs-built_in">string</span> | <span class="hljs-title class_">RegExp</span>
): <span class="hljs-literal">null</span> | <span class="hljs-title class_">RegExpMatchArray</span>
<code/>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">RegExpMatchArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; {
  <span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">input</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">groups</span>: <span class="hljs-literal">undefined</span> | {
    [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>
  };
}
</pre>
        <p>If <code>regExpOrString</code> is a regular expression with flag <code>/g</code> not set, then <code>.match()</code> returns the first match for <code>regExpOrString</code> within the string. Or <code>null</code> if there is no match.</p>
        <ul>
          <li>
            Numbered capture groups become Array elements (which is why <code>RegExpMatchArray</code> extends <code>Array</code>).
          </li>
          <li>
            <a href="#named-capture-groups">Named capture groups</a> <sup>ES2018</sup> become properties of <code>.groups</code>.
          </li>
        </ul>
        <p>Examples:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'ababb'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/a(b+)/</span>)</span>
{ 0: 'ab', 1: 'b', index: 0, input: 'ababb', groups: undefined }
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'ababb'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/a(?&lt;bs&gt;b+)/</span>)</span>
{ 0: 'ab', 1: 'b', index: 0, input: 'ababb', groups: { bs: 'b' } }
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'abab'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/x/</span>)</span>
null
</pre>
      </li>
      <li>
        <p>(3 of 3) <code>regExpOrString</code> is RegExp with <code>/g</code>.</p>
<pre class="language-ts">
<span class="hljs-title function_">match</span>(
  <span class="hljs-attr">regExpOrString</span>: <span class="hljs-title class_">RegExp</span>
): <span class="hljs-literal">null</span> | <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;
</pre>
        <p>If flag <code>/g</code> of <code>regExpOrString</code> is set, <code>.match()</code> returns either an Array with all matches or <code>null</code> if there was no match.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'ababb'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/a(b+)/g</span>)</span>
[ 'ab', 'abb' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'ababb'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/a(?&lt;bs&gt;b+)/g</span>)</span>
[ 'ab', 'abb' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'abab'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/x/g</span>)</span>
null
</pre>
      </li>
    </ul>
  </li>
  <li>
    <p><code id="qref-String.prototype.matchAll">String.prototype.matchAll(regExp)</code><br/><span class="ibox ibox-small" size="small">ES2020 | <code>/g /gy</code> honor and preserve <code>.lastIndex</code></span></p>
<pre class="language-ts">
<span class="hljs-title function_">matchAll</span>(<span class="hljs-attr">regexp</span>: <span class="hljs-title class_">RegExp</span>): <span class="hljs-title class_">Iterator</span>&lt;<span class="hljs-title class_">RegExpExecArray</span>&gt;
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">RegExpMatchArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; {
  <span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">input</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">groups</span>: <span class="hljs-literal">undefined</span> | {
    [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>
  };
}
</pre>
    <ul>
      <li>
        Throws an exception if flag <code>/g</code> is not set.
      </li>
      <li>
        Returns an iterator over zero or more matches. Per match:
        <ul>
          <li>
            Numbered capture groups become Array elements (which is why <code>RegExpMatchArray</code> extends <code>Array</code>).
          </li>
          <li>
            <a href="#named-capture-groups">Named capture groups</a> <sup>ES2018</sup> become properties of <code>.groups</code>.
          </li>
        </ul>
      </li>
    </ul>
    <p>Example:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'yes'</span>.<span class="hljs-title function_">matchAll</span>(<span class="hljs-regexp">/(y|s)/g</span>v).<span class="hljs-title function_">toArray</span>()</span>
[
  { 0: 'y', 1: 'y', index: 0, input: 'yes', groups: undefined },
  { 0: 's', 1: 's', index: 2, input: 'yes', groups: undefined },
]
</pre>
  </li>
  <li>
    <p><code id="qref-String.prototype.search">String.prototype.search(regExpOrString)</code><br/><span class="ibox ibox-small" size="small">ES3 | Ignores <code>.lastIndex</code></span></p>
    <p>Returns the index at which <code>regExpOrString</code> occurs within the string. If <code>regExpOrString</code> is a string, it is used to create a regular expression (think parameter of <code>new RegExp()</code>).</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'a2b'</span>.<span class="hljs-title function_">search</span>(<span class="hljs-regexp">/[0-9]/</span>)</span>
1
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'a2b'</span>.<span class="hljs-title function_">search</span>(<span class="hljs-string">'[0-9]'</span>)</span>
1
</pre>
  </li>
</ul>
<h4 id="stringprototype-splitting-and-replacing"><a class="heading-id-link" href="#stringprototype-splitting-and-replacing">46.20.3â€ƒ<code>String.prototype.*</code>: splitting and replacing</a></h4>
<ul>
  <li>
    <p><code id="qref-String.prototype.split">String.prototype.split(separator, limit?)</code><br/><span class="ibox ibox-small" size="small">ES3 | Ignores <code>.lastIndex</code></span></p>
<pre class="language-ts">
<span class="hljs-title function_">split</span>(<span class="hljs-attr">separator</span>: <span class="hljs-built_in">string</span> | <span class="hljs-title class_">RegExp</span>, limit?: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;
</pre>
    <p>The separator can be a string (which is interpreted as plain text, not as a regular expression pattern) or a regular expression.</p>
    <p>Examples:</p>
<pre class="language-js">
<span class="hljs-comment">// Splitting with a string</span>
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-string">'a.b.c'</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">'.'</span>),
  [ <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span> ]
);
<code/>
<span class="hljs-comment">// Splitting with a regular expression</span>
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-string">'a x:yyy b'</span>.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/x+:y+/</span>),
  [ <span class="hljs-string">'a '</span>, <span class="hljs-string">' b'</span> ]
);
<code/>
<span class="hljs-comment">// Group captures appear in the result</span>
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-string">'a x:yyy b'</span>.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/(x+):(y+)/</span>),
  [ <span class="hljs-string">'a '</span>, <span class="hljs-string">'x'</span>, <span class="hljs-string">'yyy'</span>, <span class="hljs-string">' b'</span> ]
);
</pre>
    <p>If we want the separators to be part of the returned string fragments, we can use a regular expression with a <a href="#regexp-lookbehind-assertions">lookbehind assertion</a> or a <a href="#regexp-lookahead-assertions">lookahead assertion</a>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'a: b: c'</span>.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/(?&lt;=:) */</span>)</span>
[ 'a:', 'b:', 'c' ]
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'a :b :c'</span>.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/ *(?=:)/</span>)</span>
[ 'a', ':b', ':c' ]
</pre>
    <p><strong>Pitfall:</strong> <code>.split('')</code> splits into JavaScript characters, but we usually want to split into grapheme clusters or at least Unicode code points. Therefore, itâ€™s better to use <code>Array.from()</code> or <code>Intl.Segmenter</code> for splitting. For more information, see <a href="ch_strings.html#atoms-of-text">â€œAtoms of text: code points, JavaScript characters, grapheme clustersâ€ (Â§22.7)</a>.</p>
  </li>
  <li>
    <p><code id="qref-String.prototype.replace">String.prototype.replace(searchValue, replaceValue)</code><br/><span class="ibox ibox-small" size="small">ES3 | <code>/y</code> honors and updates <code>.lastIndex</code> | <code>/g /gy</code> ignore and reset <code>.lastIndex</code></span></p>
    <p>For more information on this method, see <a href="#String.prototype.replace">its section</a> earlier in this chapter.</p>
    <ul>
      <li>
        <p>(1 of 2) <code>searchValue</code> is string or RegExp without <code>/g</code>.</p>
<pre class="language-ts">
<span class="hljs-title function_">replace</span>(
  <span class="hljs-attr">searchValue</span>: <span class="hljs-built_in">string</span> | <span class="hljs-title class_">RegExp</span>,
  <span class="hljs-attr">replaceValue</span>: <span class="hljs-built_in">string</span> | <span class="hljs-function">(<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) =&gt;</span> <span class="hljs-built_in">string</span>
): <span class="hljs-built_in">string</span>
</pre>
        <p>Works similarly to <code>.replaceAll()</code>, but only replaces the first occurrence:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'x.x.'</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">'.'</span>, <span class="hljs-string">'#'</span>) <span class="hljs-comment">// interpreted literally</span></span>
'x#x.'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'x.x.'</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/./</span>, <span class="hljs-string">'#'</span>)</span>
'#.x.'
</pre>
      </li>
      <li>
        <p>(1 of 2) <code>searchValue</code> is RegExp with <code>/g</code>.</p>
<pre class="language-ts">
<span class="hljs-title function_">replace</span>(
  <span class="hljs-attr">searchValue</span>: <span class="hljs-title class_">RegExp</span>,
  <span class="hljs-attr">replaceValue</span>: <span class="hljs-built_in">string</span> | <span class="hljs-function">(<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) =&gt;</span> <span class="hljs-built_in">string</span>
): <span class="hljs-built_in">string</span>
</pre>
        <p>Works exactly like <code>.replaceAll()</code>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'x.x.'</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/./g</span>, <span class="hljs-string">'#'</span>)</span>
'####'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'x.x.'</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\./g</span>, <span class="hljs-string">'#'</span>)</span>
'x#x#'
</pre>
      </li>
    </ul>
  </li>
  <li>
    <p><code id="qref-String.prototype.replaceAll">String.prototype.replaceAll(searchValue, replaceValue)</code><br/><span class="ibox ibox-small" size="small">ES2021 | <code>/g /gy</code> ignore and reset <code>.lastIndex</code></span></p>
    <ul>
      <li>
        <p>(1 of 2) <code>replaceValue</code> is a string.</p>
<pre class="language-ts">
<span class="hljs-title function_">replaceAll</span>(
  <span class="hljs-attr">searchValue</span>: <span class="hljs-built_in">string</span> | <span class="hljs-title class_">RegExp</span>,
  <span class="hljs-attr">replaceValue</span>: <span class="hljs-built_in">string</span>
): <span class="hljs-built_in">string</span>
</pre>
        <p>Replaces all matches of <code>searchValue</code> with <code>replaceValue</code>. If <code>searchValue</code> is a regular expression without flag <code>/g</code>, a <code>TypeError</code> is thrown.</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'x.x.'</span>.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-string">'.'</span>, <span class="hljs-string">'#'</span>) <span class="hljs-comment">// interpreted literally</span></span>
'x#x#'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'x.x.'</span>.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-regexp">/./g</span>, <span class="hljs-string">'#'</span>)</span>
'####'
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'x.x.'</span>.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-regexp">/./</span>, <span class="hljs-string">'#'</span>)</span>
TypeError: String.prototype.replaceAll called with
a non-global RegExp argument
</pre>
        <p>Special characters in <code>replaceValue</code> are:</p>
        <ul>
          <li>
            <code>$$</code>: becomes <code>$</code>
          </li>
          <li>
            <code>$n</code>: becomes the capture of numbered group <code>n</code> (alas, <code>$0</code> stands for the string <code>'$0'</code>, it does not refer to the complete match)
          </li>
          <li>
            <code>$&amp;</code>: becomes the complete match
          </li>
          <li>
            <code> $`</code>: becomes everything before the match
          </li>
          <li>
            <code>$'</code>: becomes everything after the match
          </li>
          <li>
            <code>$&lt;name&gt;</code> becomes the capture of named group <code>name</code>
          </li>
        </ul>
      </li>
      <li>
        <p>(2 of 2) <code>replaceValue</code> is a function.</p>
<pre class="language-ts">
<span class="hljs-title function_">replaceAll</span>(
  <span class="hljs-attr">searchValue</span>: <span class="hljs-built_in">string</span> | <span class="hljs-title class_">RegExp</span>,
  <span class="hljs-attr">replaceValue</span>: <span class="hljs-function">(<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) =&gt;</span> <span class="hljs-built_in">string</span>
): <span class="hljs-built_in">string</span>
</pre>
        <p>If the second parameter is a function, occurrences are replaced with the strings it returns. Its parameters <code>args</code> are:</p>
        <ul>
          <li>
            <code>matched: string</code>. The complete match
          </li>
          <li>
            <code>g1: string|undefined</code>. The capture of numbered group 1
          </li>
          <li>
            <code>g2: string|undefined</code>. The capture of numbered group 2
          </li>
          <li>
            (Etc.)
          </li>
          <li>
            <code>offset: number</code>. Where was the match found in the input string?
          </li>
          <li>
            <code>input: string</code>. The whole input string
          </li>
        </ul>
<pre class="language-js">
<span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/([0-9]{2})\.([0-9]{4})/g</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">replacer</span> = (<span class="hljs-params">all, month, year</span>) =&gt; <span class="hljs-string">`|<span class="hljs-subst">${year}</span>-<span class="hljs-subst">${month}</span>|`</span>;
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-string">'a 12.1995 b'</span>.<span class="hljs-title function_">replaceAll</span>(regexp, replacer),
  <span class="hljs-string">'a |1995-12| b'</span>
);
</pre>
        <p><a href="#named-capture-groups">Named capture groups</a> (ES2018) are supported, too. If there are any, an argument is added at the end with an object whose properties contain the captures:</p>
<pre class="language-js">
<span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/(?&lt;month&gt;[0-9]{2})\.(?&lt;year&gt;[0-9]{4})/g</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">replacer</span> = (<span class="hljs-params">...args</span>) =&gt; {
  <span class="hljs-keyword">const</span> groups = args.<span class="hljs-title function_">at</span>(-<span class="hljs-number">1</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-string">`|<span class="hljs-subst">${groups.year}</span>-<span class="hljs-subst">${groups.month}</span>|`</span>;
};
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-string">'a 12.1995 b'</span>.<span class="hljs-title function_">replaceAll</span>(regexp, replacer),
  <span class="hljs-string">'a |1995-12| b'</span>
);
</pre>
      </li>
    </ul>
  </li>
</ul>
<h4 id="regexpprototype"><a class="heading-id-link" href="#regexpprototype">46.20.4â€ƒ<code>RegExp.prototype.*</code></a></h4>
<ul>
  <li>
    <p><code id="qref-RegExp.prototype.test">RegExp.prototype.test(string)</code><br/><span class="ibox ibox-small" size="small">ES3 | <code>/g /y /gy</code> honor and update <code>.lastIndex</code></span></p>
<pre class="language-ts">
<span class="hljs-title function_">test</span>(<span class="hljs-attr">string</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>
</pre>
    <p>Returns <code>true</code> if the receiver matches <code>string</code>:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^# /.<span class="hljs-title function_">test</span>(<span class="hljs-string">'# comment'</span>)</span>
true
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^# /.<span class="hljs-title function_">test</span>(<span class="hljs-string">'#comment'</span>)</span>
false
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^# /.<span class="hljs-title function_">test</span>(<span class="hljs-string">'abc'</span>)</span>
false
</pre>
    <p><strong>Pitfall:</strong> Donâ€™t use this method with a regular expression that has flag <code>/g</code>. Then <code>regExp.test()</code> starts matching at <code>regExp.lastIndex</code> and also updates that property.</p>
  </li>
  <li>
    <p><code id="qref-RegExp.prototype.exec">RegExp.prototype.exec(string)</code><br/><span class="ibox ibox-small" size="small">ES3 | <code>/g /y /gy</code> honor and update <code>.lastIndex</code></span></p>
    <ul>
      <li>
        <p>(1 of 2) Receiver is a RegExp without <code>/g</code>.</p>
        <p>Without flag <code>/g</code>, <code>regExp.exec(string)</code> works like <a href="#qref-String.prototype.match"><code>string.match(regExp)</code></a> â€“ it returns a single match object.</p>
      </li>
      <li>
        <p>(2 of 2) Receiver is a RegExp with <code>/g</code>.</p>
<pre class="language-ts">
<span class="hljs-title function_">exec</span>(<span class="hljs-attr">string</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">RegExpExecArray</span> | <span class="hljs-literal">null</span>
<code/>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">RegExpExecArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; {
  <span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">input</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">groups</span>: <span class="hljs-literal">undefined</span> | {
    [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>
  };
}
</pre>
        <p>If <code>regExp</code> has flag <code>/g</code> then <code>regExp.exec(str)</code> returns an object for the first match starting at <code>regExp.lastIndex</code> â€“ or <code>null</code> if it canâ€™t find a match. It also updates <code>regExp.lastIndex</code> so that it points to the index after the match.</p>
        <ul>
          <li>
            Numbered capture groups become Array elements (which is why <code>RegExpExecArray</code> extends <code>Array</code>).
          </li>
          <li>
            <a href="#named-capture-groups">Named capture groups</a> <sup>ES2018</sup> become properties of <code>.groups</code>.
          </li>
        </ul>
        <p>Examples:</p>
<pre class="language-node-repl">
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> regExp = <span class="hljs-regexp">/(a+)b/g</span>, str = <span class="hljs-string">'ab aab'</span>;</span>
<code/>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">regExp.<span class="hljs-title function_">exec</span>(str)</span>
{0: 'ab', 1: 'a', index: 0, input: 'ab aab', groups: undefined}
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">regExp.<span class="hljs-property">lastIndex</span></span>
2
<code/>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">regExp.<span class="hljs-title function_">exec</span>(str)</span>
{0: 'aab', 1: 'aa', index: 3, input: 'ab aab', groups: undefined}
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">regExp.<span class="hljs-property">lastIndex</span></span>
6
<code/>
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">regExp.<span class="hljs-title function_">exec</span>(str)</span>
null
<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">regExp.<span class="hljs-property">lastIndex</span></span>
0
</pre>
      </li>
    </ul>
  </li>
</ul>

    
      
</body>
</html>