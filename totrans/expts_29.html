<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>24 Typing Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>24 Typing Arrays</h1>
<blockquote>原文：<a href="https://exploringjs.com/ts/book/ch_typing-arrays.html">https://exploringjs.com/ts/book/ch_typing-arrays.html</a></blockquote>

    
        <div id="adbox">
      <div id="adbox-explain">(Ad, please don’t block.)</div>
              
          </div>
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#ways-of-typing-arrays">24.1 Ways of typing Arrays</a>
      <ol>
        <li>
          <a href="#array-types-array-type-literal-t-vs-generic-type-array-t">24.1.1 Array types: Array type literal <code>T[]</code> vs. generic type <code>Array&lt;T&gt;</code></a>
        </li>
        <li>
          <a href="#tuple-types-tuple-type-literals">24.1.2 Tuple types: tuple type literals</a>
        </li>
        <li>
          <a href="#objects-that-are-also-array-ish-interfaces-with-index-signatures">24.1.3 Objects that are also Array-ish: interfaces with index signatures</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#pitfall-type-inference-doesn-t-always-get-array-types-right">24.2 Pitfall: type inference doesn’t always get Array types right</a>
      <ol>
        <li>
          <a href="#inferring-types-of-arrays-is-difficult">24.2.1 Inferring types of Arrays is difficult</a>
        </li>
        <li>
          <a href="#type-inference-for-non-empty-array-literals">24.2.2 Type inference for non-empty Array literals</a>
        </li>
        <li>
          <a href="#type-inference-for-empty-array-literals">24.2.3 Type inference for empty Array literals</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#const-assertions-for-arrays-and-their-effect-on-type-inference">24.3 Const assertions for Arrays and their effect on type inference</a>
      <ol>
        <li>
          <a href="#as-const-pitfall-a-const-tuple-is-not-assignable-to-a-mutable-type">24.3.1 <code>as const</code> pitfall: A const tuple is not assignable to a mutable type</a>
        </li>
        <li>
          <a href="#as-const-pitfall-the-inferred-type-is-very-narrow">24.3.2 <code>as const</code> pitfall: The inferred type is very narrow</a>
        </li>
        <li>
          <a href="#more-information-on-read-only-arrays-and-tuples">24.3.3 More information on read-only Arrays and tuples</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#array-pitfall-checking-if-an-element-exists">24.4 Array pitfall: checking if an element exists</a>
    </li>
    <li>
      <a href="#why-are-there-two-notations-why-does-typescript-prefer-t">24.5 Why are there two notations? Why does TypeScript prefer <code>T[]</code>?</a>
      <ol>
        <li>
          <a href="#why-i-prefer-the-notation-array-t">24.5.1 Why I prefer the notation <code>Array&lt;T&gt;</code></a>
        </li>
        <li>
          <a href="#one-point-in-favor-of-t">24.5.2 One point in favor of <code>T[]</code></a>
        </li>
        <li>
          <a href="#syntactic-caveat-the-in-t-binds-strongly">24.5.3 Syntactic caveat: The <code>[]</code> in <code>T[]</code> binds strongly</a>
        </li>
        <li>
          <a href="#linting-array-notations">24.5.4 Linting Array notations</a>
        </li>
      </ol>
    </li>
  </ol>
</nav>
<p>In this chapter, we examine how Arrays can be typed in TypeScript.</p>
<h3 id="ways-of-typing-arrays"><a class="heading-id-link" href="#ways-of-typing-arrays">24.1 Ways of typing Arrays</a></h3>
<p>TypeScript has two kinds of Array types:</p>
<ul>
  <li>
    Array types: All elements have the same type. The length of the Array varies.
  </li>
  <li>
    Tuple types: The length of the Array is fixed. The elements do not necessarily have the same type.
  </li>
</ul>
<h4 id="array-types-array-type-literal-t-vs-generic-type-array-t"><a class="heading-id-link" href="#array-types-array-type-literal-t-vs-generic-type-array-t">24.1.1 Array types: Array type literal <code>T[]</code> vs. generic type <code>Array&lt;T&gt;</code></a></h4>
<p>An Array type literal consists of the element type followed by <code>[]</code>. In the following code, the Array type literal is <code>string[]</code>:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// Each Array element has the type `string`:</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">myStringArray</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">'fee'</span>, <span class="hljs-string">'fi'</span>, <span class="hljs-string">'fo'</span>, <span class="hljs-string">'fum'</span>];</code>
</pre>
<p>An Array type literal is equivalent to using the generic type <code>Array</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">myStringArray</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; = [<span class="hljs-string">'fee'</span>, <span class="hljs-string">'fi'</span>, <span class="hljs-string">'fo'</span>, <span class="hljs-string">'fum'</span>];</code>
</pre>
<p>If the element type is more complicated, we need parentheses for Array type literals:</p>
<pre class="language-ts">
<code>(<span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span>)[]</code>
<code>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">boolean</span>)[]</code>
</pre>
<p>The generic type <code>Array</code> works better in this case:</p>
<pre class="language-ts">
<code><span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span>&gt;</code>
<code><span class="hljs-title class_">Array</span>&lt;<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">boolean</span>&gt;</code>
</pre>
<h4 id="tuple-types-tuple-type-literals"><a class="heading-id-link" href="#tuple-types-tuple-type-literals">24.1.2 Tuple types: tuple type literals</a></h4>
<p>If the Array has a fixed length and each element has a different, fixed type that depends on its position, then we can use tuple type literals such as <code>[string, string, boolean]</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">yes</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>] = [<span class="hljs-string">'oui'</span>, <span class="hljs-string">'sí'</span>, <span class="hljs-literal">true</span>];</code>
</pre>
<h4 id="objects-that-are-also-array-ish-interfaces-with-index-signatures"><a class="heading-id-link" href="#objects-that-are-also-array-ish-interfaces-with-index-signatures">24.1.3 Objects that are also Array-ish: interfaces with index signatures</a></h4>
<p>If an interface only has an index signature, we can use it for Arrays:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">StringArray</span> {</code>
<code>  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span>;</code>
<code>}</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">strArr</span>: <span class="hljs-title class_">StringArray</span> = [<span class="hljs-string">'Huey'</span>, <span class="hljs-string">'Dewey'</span>, <span class="hljs-string">'Louie'</span>];</code>
</pre>
<p>An interface that has both an index signature and property signatures, only works for objects (because indexed elements and properties need to be defined at the same time):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">FirstNamesAndLastName</span> {</code>
<code>  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span>;</code>
<code>  <span class="hljs-attr">lastName</span>: <span class="hljs-built_in">string</span>;</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">ducks</span>: <span class="hljs-title class_">FirstNamesAndLastName</span> = {</code>
<code>  <span class="hljs-number">0</span>: <span class="hljs-string">'Huey'</span>,</code>
<code>  <span class="hljs-number">1</span>: <span class="hljs-string">'Dewey'</span>,</code>
<code>  <span class="hljs-number">2</span>: <span class="hljs-string">'Louie'</span>,</code>
<code>  <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Duck'</span>,</code>
<code>};</code>
</pre>
<h3 id="pitfall-type-inference-doesn-t-always-get-array-types-right"><a class="heading-id-link" href="#pitfall-type-inference-doesn-t-always-get-array-types-right">24.2 Pitfall: type inference doesn’t always get Array types right</a></h3>
<h4 id="inferring-types-of-arrays-is-difficult"><a class="heading-id-link" href="#inferring-types-of-arrays-is-difficult">24.2.1 Inferring types of Arrays is difficult</a></h4>
<p>Due to the two kinds of Array types, it is impossible for TypeScript to always guess the right type. As an example, consider the following Array literal that is assigned to the variable <code>fields</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">fields</span>: <span class="hljs-title class_">Fields</span> = [</code>
<code>  [<span class="hljs-string">'first'</span>, <span class="hljs-string">'string'</span>, <span class="hljs-literal">true</span>],</code>
<code>  [<span class="hljs-string">'last'</span>, <span class="hljs-string">'string'</span>, <span class="hljs-literal">true</span>],</code>
<code>  [<span class="hljs-string">'age'</span>, <span class="hljs-string">'number'</span>, <span class="hljs-literal">false</span>],</code>
<code>];</code>
</pre>
<p>What is the best type for <code>fields</code>? The following are all reasonable choices:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Fields</span> = <span class="hljs-title class_">Array</span>&lt;[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>]&gt;;</code>
</pre>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Fields</span> = <span class="hljs-title class_">Array</span>&lt;[<span class="hljs-built_in">string</span>, (<span class="hljs-string">'string'</span>|<span class="hljs-string">'number'</span>), <span class="hljs-built_in">boolean</span>]&gt;;</code>
</pre>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Fields</span> = <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>|<span class="hljs-built_in">boolean</span>&gt;&gt;;</code>
</pre>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Fields</span> = [</code>
<code>  [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>],</code>
<code>  [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>],</code>
<code>  [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>],</code>
<code>];</code>
</pre>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Fields</span> = [</code>
<code>  [<span class="hljs-built_in">string</span>, <span class="hljs-string">'string'</span>, <span class="hljs-built_in">boolean</span>],</code>
<code>  [<span class="hljs-built_in">string</span>, <span class="hljs-string">'string'</span>, <span class="hljs-built_in">boolean</span>],</code>
<code>  [<span class="hljs-built_in">string</span>, <span class="hljs-string">'number'</span>, <span class="hljs-built_in">boolean</span>],</code>
<code>];</code>
</pre>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Fields</span> = [</code>
<code>  <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>|<span class="hljs-built_in">boolean</span>&gt;,</code>
<code>  <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>|<span class="hljs-built_in">boolean</span>&gt;,</code>
<code>  <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>|<span class="hljs-built_in">boolean</span>&gt;,</code>
<code>];</code>
</pre>
<h4 id="type-inference-for-non-empty-array-literals"><a class="heading-id-link" href="#type-inference-for-non-empty-array-literals">24.2.2 Type inference for non-empty Array literals</a></h4>
<p>When we use non-empty Array literals, TypeScript’s default is to infer Array types (not tuple types):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">123</span>, <span class="hljs-string">'abc'</span>];</code>
<code>assertType&lt;(<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[]&gt;(arr);</code>
</pre>
<p>Alas, that’s not always what we want:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">p: <span class="hljs-keyword">readonly</span> [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>]</span>) { <span class="hljs-comment">// (A)</span></code>
<code>  <span class="hljs-keyword">return</span> p;</code>
<code>}</code>
<code><span class="hljs-keyword">const</span> pair1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];</code>
<code>assertType&lt;<span class="hljs-built_in">number</span>[]&gt;(pair1);</code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Argument of type 'number[]' is not assignable to</span></code>
<code><span class="hljs-comment">// parameter of type 'readonly [number, number]'. [...]</span></code>
<code><span class="hljs-title function_">func</span>(pair1); <span class="hljs-comment">// (B)</span></code>
</pre>
<p>We need the keyword <code>readonly</code> in this line so that <code>pair3</code> (see below) is accepted.</p>
<p>We can fix the error in line B via a type annotation:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">pair2</span>: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];</code>
<code><span class="hljs-title function_">func</span>(pair2); <span class="hljs-comment">// OK</span></code>
</pre>
<p>Another option is a const assertion (<code>as const</code>):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> pair3 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code>
<code><span class="hljs-title function_">func</span>(pair3); <span class="hljs-comment">// OK</span></code>
</pre>
<p>More on const assertions soon.</p>
<h4 id="type-inference-for-empty-array-literals"><a class="heading-id-link" href="#type-inference-for-empty-array-literals">24.2.3 Type inference for empty Array literals</a></h4>
<p>If we initialize a variable with an empty Array literal, then TypeScript initially infers the type <code>any[]</code> and incrementally updates that type as we make changes:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// @ts-expect-error: Variable 'arr' implicitly has type 'any[]' in some</span></code>
<code><span class="hljs-comment">// locations where its type cannot be determined.</span></code>
<code><span class="hljs-keyword">const</span> arr = []; <span class="hljs-comment">// (A)</span></code>
<code><span class="hljs-comment">// @ts-expect-error: Variable 'arr' implicitly has an 'any[]' type.</span></code>
<code>assertType&lt;<span class="hljs-built_in">any</span>[]&gt;(arr); <span class="hljs-comment">// (B)</span></code>
<code/>
<code>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">123</span>);</code>
<code>assertType&lt;<span class="hljs-built_in">number</span>[]&gt;(arr);</code>
<code/>
<code>arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">'abc'</span>);</code>
<code>assertType&lt;(<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[]&gt;(arr);</code>
</pre>
<p>Interestingly, the error in line A goes away if we remove line B: TypeScript only complains about <code>any[]</code> if that type is observed in some manner.</p>
<p>If we use assignment instead of <code>.push()</code>, things work the same:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// @ts-expect-error: Variable 'arr' implicitly has type 'any[]' in some</span></code>
<code><span class="hljs-comment">// locations where its type cannot be determined.</span></code>
<code><span class="hljs-keyword">const</span> arr = [];</code>
<code><span class="hljs-comment">// @ts-expect-error: Variable 'arr' implicitly has an 'any[]' type.</span></code>
<code>assertType&lt;<span class="hljs-built_in">any</span>[]&gt;(arr);</code>
<code/>
<code>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">123</span>;</code>
<code>assertType&lt;<span class="hljs-built_in">number</span>[]&gt;(arr);</code>
<code/>
<code>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">'abc'</span>;</code>
<code>assertType&lt;(<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[]&gt;(arr);</code>
</pre>
<p>In contrast, if the Array literal has at least one element, then the element type is fixed and doesn’t change later:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">123</span>];</code>
<code>assertType&lt;<span class="hljs-built_in">number</span>[]&gt;(arr);</code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Argument of type 'string' is not assignable to</span></code>
<code><span class="hljs-comment">// parameter of type 'number'.</span></code>
<code>arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">'abc'</span>);</code>
</pre>
<h3 id="const-assertions-for-arrays-and-their-effect-on-type-inference"><a class="heading-id-link" href="#const-assertions-for-arrays-and-their-effect-on-type-inference">24.3 Const assertions for Arrays and their effect on type inference</a></h3>
<p>We can suffix an Array literal with <a href="ch_readonly.html#const-assertions">a const assertion</a>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> rockCategories =</code>
<code>  [<span class="hljs-string">'igneous'</span>, <span class="hljs-string">'metamorphic'</span>, <span class="hljs-string">'sedimentary'</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code>
<code>assertType&lt;</code>
<code>  <span class="hljs-keyword">readonly</span> [<span class="hljs-string">'igneous'</span>, <span class="hljs-string">'metamorphic'</span>, <span class="hljs-string">'sedimentary'</span>]</code>
<code>&gt;(rockCategories);</code>
</pre>
<p>We are declaring that <code>rockCategories</code> won’t change. That has the following effects:</p>
<ul>
  <li>
    <p>The Array becomes <code>readonly</code> – we can’t use operations that change it:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// @ts-expect-error: Property 'push' does not exist on type</span></code>
<code><span class="hljs-comment">// 'readonly ["igneous", "metamorphic", "sedimentary"]'.</span></code>
<code>rockCategories.<span class="hljs-title function_">push</span>(<span class="hljs-string">'sand'</span>);</code>
</pre>
  </li>
  <li>
    <p>TypeScript infers a tuple. Compare:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> rockCategories2 = [<span class="hljs-string">'igneous'</span>, <span class="hljs-string">'metamorphic'</span>, <span class="hljs-string">'sedimentary'</span>];</code>
<code>assertType&lt;<span class="hljs-built_in">string</span>[]&gt;(rockCategories2);</code>
</pre>
  </li>
  <li>
    <p>TypeScript infers narrow literal types (<code>'igneous'</code> etc.) instead of more general types. That is, the inferred tuple type is not <code>[string, string, string]</code>.</p>
  </li>
</ul>
<p>Here are more examples of Array literals with and without const assertions:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> numbers1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code>
<code>assertType&lt;<span class="hljs-keyword">readonly</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]&gt;(numbers1);</code>
<code><span class="hljs-keyword">const</span> numbers2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];</code>
<code>assertType&lt;<span class="hljs-built_in">number</span>[]&gt;(numbers2);</code>
<code/>
<code><span class="hljs-keyword">const</span> booleanAndString1 = [<span class="hljs-literal">true</span>, <span class="hljs-string">'abc'</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code>
<code>assertType&lt;<span class="hljs-keyword">readonly</span> [<span class="hljs-literal">true</span>, <span class="hljs-string">'abc'</span>]&gt;(booleanAndString1);</code>
<code><span class="hljs-keyword">const</span> booleanAndString2 = [<span class="hljs-literal">true</span>, <span class="hljs-string">'abc'</span>];</code>
<code>assertType&lt;(<span class="hljs-built_in">string</span> | <span class="hljs-built_in">boolean</span>)[]&gt;(booleanAndString2);</code>
</pre>
<h4 id="as-const-pitfall-a-const-tuple-is-not-assignable-to-a-mutable-type"><a class="heading-id-link" href="#as-const-pitfall-a-const-tuple-is-not-assignable-to-a-mutable-type">24.3.1 <code>as const</code> pitfall: A const tuple is not assignable to a mutable type</a></h4>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">argIsArray</span>(<span class="hljs-params">arg: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;</span>) {}</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">argIsReadonlyArray</span>(<span class="hljs-params">arg: ReadonlyArray&lt;<span class="hljs-built_in">string</span>&gt;</span>) {}</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">argIsTuple</span>(<span class="hljs-params">arg: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>]</span>) {}</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">argIsReadonlyTuple</span>(<span class="hljs-params">arg: <span class="hljs-keyword">readonly</span> [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>]</span>) {}</code>
<code/>
<code><span class="hljs-keyword">const</span> constTuple = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code>
<code><span class="hljs-comment">// @ts-expect-error: Argument of type 'readonly ["a", "b"]' is not</span></code>
<code><span class="hljs-comment">// assignable to parameter of type '[string, string]'. The type 'readonly</span></code>
<code><span class="hljs-comment">// ["a", "b"]' is 'readonly' and cannot be assigned to the mutable type</span></code>
<code><span class="hljs-comment">// '[string, string]'.</span></code>
<code><span class="hljs-title function_">argIsTuple</span>(constTuple);</code>
<code><span class="hljs-title function_">argIsReadonlyTuple</span>(constTuple);</code>
<code><span class="hljs-comment">// @ts-expect-error: Argument of type 'readonly ["a", "b"]' is not</span></code>
<code><span class="hljs-comment">// assignable to parameter of type 'string[]'. The type 'readonly</span></code>
<code><span class="hljs-comment">// ["a", "b"]' is 'readonly' and cannot be assigned to the mutable type</span></code>
<code><span class="hljs-comment">// 'string[]'.</span></code>
<code><span class="hljs-title function_">argIsArray</span>(constTuple);</code>
<code><span class="hljs-title function_">argIsReadonlyArray</span>(constTuple);</code>
</pre>
<p>A mutable tuple does not have this issue:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">mutableTuple</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>] = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];</code>
<code><span class="hljs-title function_">argIsTuple</span>(mutableTuple);</code>
<code><span class="hljs-title function_">argIsReadonlyTuple</span>(mutableTuple);</code>
<code><span class="hljs-title function_">argIsArray</span>(mutableTuple);</code>
<code><span class="hljs-title function_">argIsReadonlyArray</span>(mutableTuple);</code>
</pre>
<p>Lesson for us: If possible, we should use <code>readonly</code> for tuple parameters of functions and methods.</p>
<h4 id="as-const-pitfall-the-inferred-type-is-very-narrow"><a class="heading-id-link" href="#as-const-pitfall-the-inferred-type-is-very-narrow">24.3.2 <code>as const</code> pitfall: The inferred type is very narrow</a></h4>
<p>The inferred type of a const-asserted Array literal is as narrow as possible. That causes an issue for <code>let</code>-declared variables: We cannot assign any tuple other than the one that we used for intialization:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code>
<code/>
<code>arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]; <span class="hljs-comment">// OK</span></code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Type '3' is not assignable to type '2'.</span></code>
<code>arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>];</code>
</pre>
<h4 id="more-information-on-read-only-arrays-and-tuples"><a class="heading-id-link" href="#more-information-on-read-only-arrays-and-tuples">24.3.3 More information on read-only Arrays and tuples</a></h4>
<p>See <a href="ch_readonly.html#ch_readonly">“Read-only accessibility (<code>readonly</code> etc.)” (§25)</a>.</p>
<h3 id="array-pitfall-checking-if-an-element-exists"><a class="heading-id-link" href="#array-pitfall-checking-if-an-element-exists">24.4 Array pitfall: checking if an element exists</a></h3>
<p>With <a href="ch_tsconfig-json.html#noUncheckedIndexedAccess">the compiler option <code>noUncheckedIndexedAccess</code></a>, TypeScript always infers the type <code>undefined | T</code> for elements of an <code>Array&lt;T&gt;</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">arr: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;</span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// (A)</span></code>
<code>    <span class="hljs-keyword">const</span> elem = arr[<span class="hljs-number">0</span>];</code>
<code>    assertType&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>&gt;(elem);</code>
<code>  }</code>
<code>}</code>
</pre>
<p>Even checking <code>.length</code> in line A doesn’t change that. However, the <code>in</code> operator works better:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">arr: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;</span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> <span class="hljs-keyword">in</span> arr) {</code>
<code>    <span class="hljs-keyword">const</span> elem = arr[<span class="hljs-number">0</span>];</code>
<code>    assertType&lt;<span class="hljs-built_in">string</span>&gt;(elem);</code>
<code>  }</code>
<code>}</code>
</pre>
<p>Alternatively, we can check for <code>undefined</code> after accessing the Array element:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">arr: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;</span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">const</span> elem = arr[<span class="hljs-number">0</span>];</code>
<code>  <span class="hljs-keyword">if</span> (elem !== <span class="hljs-literal">undefined</span>) {</code>
<code>    assertType&lt;<span class="hljs-built_in">string</span>&gt;(elem);</code>
<code>  }</code>
<code>}</code>
</pre>
<h3 id="why-are-there-two-notations-why-does-typescript-prefer-t"><a class="heading-id-link" href="#why-are-there-two-notations-why-does-typescript-prefer-t">24.5 Why are there two notations? Why does TypeScript prefer <code>T[]</code>?</a></h3>
<p>The following two notations for an Array of strings are completely equivalent:</p>
<ul>
  <li>
    <code>string[]</code>
  </li>
  <li>
    <code>Array&lt;string&gt;</code>
  </li>
</ul>
<p>Why are there two notations?</p>
<ul>
  <li>
    <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-0-9/">TypeScript 0.9</a> introduced generics to the language and enabled the notation <code>Array&lt;T&gt;</code>.
  </li>
  <li>
    Before that, <code>T[]</code> was the only notation for Arrays.
  </li>
</ul>
<p>So it looks like TypeScript simply stuck with the status quo when version 0.9 came along: It still exclusively uses <code>T[]</code> – e.g., when inferring types or even when displaying a type that was written <code>Array&lt;T&gt;</code>.</p>
<p>Even though I have read once or twice that JSX is the cause of TypeScript’s preference, I don’t think that’s the case:</p>
<ul>
  <li>
    <p>The <code>Array&lt;T&gt;</code> notation is compatible with JSX: It only exists at the type level and can be used without any problems in <code>.jsx</code> files.</p>
  </li>
  <li>
    <p>JSX does, however, make one syntax impossible to use – <a href="https://www.typescriptlang.org/docs/handbook/jsx.html#the-as-operator">type assertions via angle brackets</a>:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// Not possible in .tsx files:</span></code>
<code><span class="hljs-keyword">const</span> value1 = &lt;<span class="hljs-title class_">DesiredType</span>&gt;valueWithWrongType;</code>
<code/>
<code><span class="hljs-comment">// Can be used everywhere:</span></code>
<code><span class="hljs-keyword">const</span> value2 = valueWithWrongType <span class="hljs-keyword">as</span> <span class="hljs-title class_">DesiredType</span>;</code>
</pre>
  </li>
</ul>
<h4 id="why-i-prefer-the-notation-array-t"><a class="heading-id-link" href="#why-i-prefer-the-notation-array-t">24.5.1 Why I prefer the notation <code>Array&lt;T&gt;</code></a></h4>
<p>I find it often looks better – especially if constructs related to element types get more complicated:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// Array of tuples</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">AT1</span> = <span class="hljs-title class_">Array</span>&lt;[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>]&gt;;</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">AT2</span> = [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>][];</code>
<code/>
<code><span class="hljs-comment">// Array of union elements</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">AU1</span> = <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>&gt;;</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">AU2</span> = (<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>)[];</code>
<code/>
<code><span class="hljs-comment">// Inferring type variables</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ExtractElem1</span>&lt;A&gt; = A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;infer <span class="hljs-title class_">Elem</span>&gt; ? <span class="hljs-title class_">Elem</span> : <span class="hljs-built_in">never</span>;</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ExtractElem2</span>&lt;A&gt; = A <span class="hljs-keyword">extends</span> (infer <span class="hljs-title class_">Elem</span>)[] ? <span class="hljs-title class_">Elem</span> : <span class="hljs-built_in">never</span>;</code>
<code/>
<code><span class="hljs-comment">// Readonly types</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">RO1</span> = <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">unknown</span>&gt;;</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">RO2</span> = <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">unknown</span>[];</code>
<code>  <span class="hljs-comment">// `readonly` applies to `[]` not to `unknown`!</span></code>
</pre>
<p>More reasons:</p>
<ul>
  <li>
    <p><code>Array&lt;T&gt;</code> looks similar to <code>Set&lt;T&gt;</code> and <code>Map&lt;K,V&gt;</code>.</p>
  </li>
  <li>
    <p><code>T[]</code> can be confused with <code>[T]</code> (tuples that have a single component whose type is <code>T</code>) – especially by people new to TypeScript.</p>
  </li>
  <li>
    <p>If we want to create an empty Array without a type annotation then that syntax is more consistent with the angle bracket type notation:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> strArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;();</code>
</pre>
  </li>
</ul>
<h4 id="one-point-in-favor-of-t"><a class="heading-id-link" href="#one-point-in-favor-of-t">24.5.2 One point in favor of <code>T[]</code></a></h4>
<p>Because TypeScript always uses <code>T[]</code>, code that uses that notation is more consistent with language tooling.</p>
<h4 id="syntactic-caveat-the-in-t-binds-strongly"><a class="heading-id-link" href="#syntactic-caveat-the-in-t-binds-strongly">24.5.3 Syntactic caveat: The <code>[]</code> in <code>T[]</code> binds strongly</a></h4>
<p>The square brackets in <code>T[]</code> bind strongly. Therefore, we need to parenthesize any type <code>T</code> that consists of more than a single token – e.g. (line A, line B):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ArrayOfStringOrNumber</span> = (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[]; <span class="hljs-comment">// (A)</span></code>
<code/>
<code><span class="hljs-keyword">const</span> <span class="hljs-title class_">Activation</span> = {</code>
<code>  <span class="hljs-title class_">Active</span>: <span class="hljs-string">'Active'</span>,</code>
<code>  <span class="hljs-title class_">Inactive</span>: <span class="hljs-string">'Inactive'</span>,</code>
<code>} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ActivationKeys</span> = (keyof <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Activation</span>)[]; <span class="hljs-comment">// (B)</span></code>
<code>  <span class="hljs-comment">// ("Active" | "Inactive")[]</span></code>
</pre>
<h4 id="linting-array-notations"><a class="heading-id-link" href="#linting-array-notations">24.5.4 Linting Array notations</a></h4>
<p>typescript-eslint has the rule <a href="https://typescript-eslint.io/rules/array-type/"><code>array-type</code></a> for enforcing a consistent Array notation style. The options are:</p>
<ul>
  <li>
    Always <code>T[]</code>
  </li>
  <li>
    Always <code>Array&lt;T&gt;</code>
  </li>
  <li>
    <code>T[]</code> for single-token <code>T</code>; otherwise <code>Array&lt;T&gt;</code>
  </li>
</ul>

    
      
</body>
</html>