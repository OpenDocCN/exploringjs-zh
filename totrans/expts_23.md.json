["```ts\n    const fixedLayoutObject: FixedLayoutObjectType = {\n     product: 'carrot',\n     quantity: 4,\n    };\n\n    ```", "```ts\n    const dictionaryObject: DictionaryObjectType = {\n     ['one']: 1,\n     ['two']: 2,\n    };\n\n    ```", "```ts\ntype FixedLayoutObjectType = {\n product: string,\n quantity: number,\n};\ntype DictionaryObjectType = Record<string, number>;\n\n```", "```ts\nconst myPoint = {x: 1, y: 2};\n\nfunction logPoint(point: {x: number, y: number}): void {\n console.log(point);\n}\n\nlogPoint(myPoint); // Works!\n\n```", "```ts\ntype ExampleObjectType = {\n // Property signature\n myProperty: boolean,\n\n // Method signature\n myMethod(str: string): number,\n\n // Index signature\n [key: string]: any,\n\n // Call signature\n (num: number): string,\n\n // Construct signature\n new(str: string): ExampleInstanceType, \n};\n\ntype ExampleInstanceType = {};\n\n```", "```ts\n    myProperty: boolean;\n\n    ```", "```ts\n    myMethod(str: string): number;\n\n    ```", "```ts\n    [key: string]: any;\n\n    ```", "```ts\n    (num: number): string;\n\n    ```", "```ts\n    new(str: string): ExampleInstanceType; \n\n    ```", "```ts\ntype HasMethodDef = {\n simpleMethod(flag: boolean): void,\n};\ntype HasFuncProp = {\n simpleMethod: (flag: boolean) => void,\n};\ntype _ = Assert<Equal<\n HasMethodDef,\n HasFuncProp\n>>;\n\nconst objWithMethod = {\n simpleMethod(flag: boolean): void {},\n};\nassertType<HasMethodDef>(objWithMethod);\nassertType<HasFuncProp>(objWithMethod);\n\nconst objWithOrdinaryFunction: HasMethodDef = {\n simpleMethod: function (flag: boolean): void {},\n};\nassertType<HasMethodDef>(objWithOrdinaryFunction);\nassertType<HasFuncProp>(objWithOrdinaryFunction);\n\nconst objWithArrowFunction: HasMethodDef = {\n simpleMethod: (flag: boolean): void => {},\n};\nassertType<HasMethodDef>(objWithArrowFunction);\nassertType<HasFuncProp>(objWithArrowFunction);\n\n```", "```ts\ntype Obj = { 'hello everyone!': string };\n\n```", "```ts\ntype _ = Assert<Equal<\n keyof {0: 'a', 1: 'b'},\n 0 | 1\n>>;\n\n```", "```ts\nassert.deepEqual(\n Object.keys({0: 'a', 1: 'b'}),\n [ '0', '1' ]\n);\n\n```", "```ts\ntype ExampleObjectType = {\n // Property signature with computed key\n [Symbol.toStringTag]: string,\n\n // Method signature with computed key\n [Symbol.iterator](): IteratorObject<string>,\n};\n\n```", "```ts\ntype _ = Assert<Equal<\n { ['hello']: string },\n { hello: string }\n>>;\n\n```", "```ts\ntype Name = {\n first: string;\n middle?: string;\n last: string;\n};\n\n```", "```ts\nconst john: Name = {first: 'Doe', last: 'Doe'}; // (A)\nconst jane: Name = {first: 'Jane', middle: 'Cecily', last: 'Doe'};\n\n```", "```ts\ntype Obj = {\n prop1?: string;\n prop2: undefined | string; \n};\n\nconst obj1: Obj = { prop1: 'a', prop2: 'b' };\n\n// .prop1 can be omitted; .prop2 can be `undefined`\nconst obj2: Obj = { prop2: undefined };\n\n// @ts-expect-error: Type '{ prop1: undefined; prop2: string; }' is not\n// assignable to type 'Obj' with 'exactOptionalPropertyTypes: true'.\n// Consider adding 'undefined' to the types of the target's properties.\n// Types of property 'prop1' are incompatible. Type 'undefined' is not\n// assignable to type 'string'.\nconst obj3: Obj = { prop1: undefined, prop2: 'b' };\n\n// @ts-expect-error: Property 'prop2' is missing in type '{ prop1: string;\n// }' but required in type 'Obj'.\nconst obj4: Obj = { prop1: 'a' };\n\n```", "```ts\ntype Obj = {\n prop1?: string;\n prop2: undefined | string; \n};\n\nconst obj1: Obj = { prop1: undefined, prop2: undefined };\n\n```", "```ts\ntype MyObj = {\n readonly prop: number;\n};\n\n```", "```ts\nconst obj: MyObj = {\n prop: 1,\n};\n\nconsole.log(obj.prop); // OK\n\n// @ts-expect-error: Cannot assign to 'prop' because it is a read-only\n// property.\nobj.prop = 2;\n\n```", "```ts\ntype Point = {\n x: number,\n y: number,\n};\n\n```", "```ts\nfunction computeDistance(point: Point) { /*...*/ }\n\n```", "```ts\nconst obj = { x: 1, y: 2, z: 3 };\ncomputeDistance(obj); // OK\n\n```", "```ts\n// @ts-expect-error: Object literal may only specify known properties, and\n// 'z' does not exist in type 'Point'.\ncomputeDistance({ x: 1, y: 2, z: 3 }); // error\n\ncomputeDistance({x: 1, y: 2}); // OK\n\n```", "```ts\ntype Person = {\n first: string,\n middle?: string,\n last: string,\n};\nfunction computeFullName(person: Person) { /*...*/ }\n\n```", "```ts\n// @ts-expect-error: Object literal may only specify known properties, but\n// 'mdidle' does not exist in type 'Person'. Did you mean to write\n// 'middle'?\ncomputeFullName({first: 'Jane', mdidle: 'Cecily', last: 'Doe'});\n\n```", "```ts\ntype HasYear = {\n year: number,\n};\n\nfunction getAge(obj: HasYear) {\n const yearNow = new Date().getFullYear();\n return yearNow - obj.year;\n}\n\n```", "```ts\ntype Empty = {};\ntype OneProp = {\n myProp: number,\n};\n\n// @ts-expect-error: Object literal may only specify known properties, and\n// 'anotherProp' does not exist in type 'OneProp'.\nconst a: OneProp = { myProp: 1, anotherProp: 2 };\nconst b: Empty = { myProp: 1, anotherProp: 2 }; // OK\n\n```", "```ts\ntype WithoutProperties = {\n [key: string]: never,\n};\n\n// @ts-expect-error: Type 'number' is not assignable to type 'never'.\nconst a: WithoutProperties = { prop: 1 };\nconst b: WithoutProperties = {}; // OK\n\n```", "```ts\ntype Point = {\n x: number,\n y: number,\n};\n\nfunction computeDistance1(point: Point) { /*...*/ }\n\n// @ts-expect-error: Object literal may only specify known properties, and\n// 'z' does not exist in type 'Point'.\ncomputeDistance1({ x: 1, y: 2, z: 3 });\n\n```", "```ts\nconst obj = { x: 1, y: 2, z: 3 };\ncomputeDistance1(obj);\n\n```", "```ts\ncomputeDistance1({ x: 1, y: 2, z: 3 } as Point); // OK\n\n```", "```ts\nfunction computeDistance2<P extends Point>(point: P) { /*...*/ }\ncomputeDistance2({ x: 1, y: 2, z: 3 }); // OK\n\n```", "```ts\ntype PointEtc = Point & {\n [key: string]: any;\n};\nfunction computeDistance3(point: PointEtc) { /*...*/ }\n\ncomputeDistance3({ x: 1, y: 2, z: 3 }); // OK\n\n```", "```ts\ntype Incrementor = {\n inc(): number,\n};\nfunction createIncrementor(): Incrementor {\n return {\n // @ts-expect-error: Object literal may only specify known properties, and\n // 'counter' does not exist in type 'Incrementor'.\n counter: 0,\n inc() {\n // @ts-expect-error: Property 'counter' does not exist on type\n // 'Incrementor'.\n return this.counter++;\n },\n };\n}\n\n```", "```ts\nfunction createIncrementor2(): Incrementor {\n return {\n counter: 0,\n inc() {\n // @ts-expect-error: Property 'counter' does not exist on type\n // 'Incrementor'.\n return this.counter++;\n },\n } as Incrementor;\n}\n\n```", "```ts\nfunction createIncrementor3(): Incrementor {\n const incrementor = {\n counter: 0,\n inc() {\n return this.counter++;\n },\n };\n return incrementor;\n}\n\n```", "```ts\nfunction compareDateStrings(\n a: {dateStr: string}, b: {dateStr: string}) {\n if (a.dateStr < b.dateStr) {\n return +1;\n } else if (a.dateStr > b.dateStr) {\n return -1;\n } else {\n return 0;\n }\n }\n\n```", "```ts\ntype MyType = {\n toString(): string, // inherited property\n prop: number, // own property\n};\nconst obj: MyType = { // OK\n prop: 123,\n};\n\n```", "```ts\nfunction f1(x: {}): Object {\n return x;\n}\n\n```", "```ts\nfunction f2(x: {}): { toString(): string } {\n return x;\n}\n\n```", "```ts\n// Object literal type\ntype ObjType1 = {\n a: boolean,\n b: number,\n c: string,\n};\n\n// Interface\ninterface ObjType2 {\n a: boolean;\n b: number;\n c: string;\n}\n\n```", "```ts\n// The object literal type is inlined\n// (mentioned inside the parameter definition)\nfunction f1(x: {prop: number}) {}\n\n// We can’t mention the interface inside the parameter definition.\n// We can only define it externally and refer to it.\nfunction f2(x: ObjectInterface) {} \ninterface ObjectInterface {\n prop: number;\n}\n\n```", "```ts\n// @ts-expect-error: Duplicate identifier 'PersonAlias'.\ntype PersonAlias = {first: string};\n// @ts-expect-error: Duplicate identifier 'PersonAlias'.\ntype PersonAlias = {last: string};\n\n```", "```ts\ninterface PersonInterface {\n first: string;\n}\ninterface PersonInterface {\n last: string;\n}\nconst jane: PersonInterface = {\n first: 'Jane',\n last: 'Doe',\n};\n\n```", "```ts\ninterface ArrayConstructor {\n fromAsync<T>(···): Promise<T[]>;\n}\n\n```", "```ts\ntype Point = {\n x: number,\n y: number,\n};\n\ntype PointCopy1 = {\n [Key in keyof Point]: Point[Key] // (A)\n};\n\n```", "```ts\ninterface AddsStrings {\n add(str: string): this;\n};\n\nclass StringBuilder implements AddsStrings {\n result = '';\n add(str: string): this {\n this.result += str;\n return this;\n }\n}\n\n```", "```ts\ninterface A {\n propA: number;\n}\ninterface B extends A {\n propB: number;\n}\ntype _ = Assert<Equal<\n B,\n {\n propA: number,\n propB: number,\n }\n>>;\n\n```", "```ts\ntype A = {\n propA: number,\n};\ntype B = {\n propB: number,\n} & A;\ntype _ = Assert<Equal<\n B,\n {\n propA: number,\n propB: number,\n }\n>>;\n\n```", "```ts\ninterface A {\n prop: string;\n}\n// @ts-expect-error: Interface 'B' incorrectly extends interface 'A'.\n// Types of property 'prop' are incompatible.\ninterface B extends A {\n prop: number;\n}\n\n```", "```ts\ntype A = {\n prop: string,\n};\ntype B = {\n prop: number,\n} & A;\ntype _ = Assert<Equal<\n B,\n {\n prop: number & string, // never\n }\n>>;\n\n```", "```ts\ninterface A {\n m(x: string): Object;\n}\ninterface B extends A {\n m(x: string | number): RegExp;\n}\n\ntype _ = Assert<Equal<\n B,\n {\n m(x: string | number): RegExp,\n }\n>>;\n\nfunction f(x: B) {\n assertType<RegExp>(x.m('abc'));\n}\n\n```", "```ts\ntype A = {\n m(x: string): Object,\n};\ntype B = {\n m(x: string | number): RegExp,\n};\n\ntype _ = [\n Assert<Equal<\n A & B,\n {\n m: ((x: string) => Object) & ((x: string | number) => RegExp),\n }\n >>,\n Assert<Equal<\n B & A,\n {\n m: ((x: string | number) => RegExp) & ((x: string) => Object),\n }\n >>,\n];\n\nfunction f1(x: A & B) {\n assertType<Object>(x.m('abc')); // (A)\n}\nfunction f2(x: B & A) {\n assertType<RegExp>(x.m('abc')); // (B)\n}\n\n```", "```ts\ntype B1 = {\n prop: number,\n} & A;\ntype B2 = A & {\n prop: number,\n};\n\n```", "```ts\ntype EmptyObject = Record<string, never>;\n\n// @ts-expect-error: Type 'number' is not assignable to type 'never'.\nconst obj1: EmptyObject = { prop: 123 };\nconst obj2: EmptyObject = {}; // OK\n\n```", "```ts\nconst obj3: {} = { prop: 123 };\n\n```", "```ts\ntype NoIndices = Record<number, never> & { prop?: boolean };\n\n//===== Objects =====\nconst obj1: NoIndices = {}; // OK\nconst obj2: NoIndices = { prop: true }; // OK\n// @ts-expect-error: Type 'string' is not assignable to type 'never'.\nconst obj3: NoIndices = { 0: 'a' }; // OK\n\n//===== Arrays =====\nconst arr1: NoIndices = []; // OK\n// @ts-expect-error: Type 'string' is not assignable to type 'never'.\nconst arr2: NoIndices = ['a'];\n\n```", "```ts\nfunction translate(dict: TranslationDict, english: string): string {\n const translation = dict[english];\n if (translation === undefined) {\n throw new Error();\n }\n return translation;\n}\n\n```", "```ts\ntype TranslationDict = {\n [key: string]: string, // (A)\n};\nconst dict = {\n 'yes': 'sí',\n 'no': 'no',\n 'maybe': 'tal vez',\n};\nassert.equal(\n translate(dict, 'maybe'),\n 'tal vez');\n\n```", "```ts\ntype IndexSignature1 = {\n [key: string]: boolean,\n};\n// Template string literal with infinite primitive type\ntype IndexSignature2 = {\n [key: `${bigint}`]: string,\n};\n// Union of previous types\ntype IndexSignature3 = {\n [key: string | `${bigint}`]: string,\n};\n\n```", "```ts\ntype StringAndNumberKeys = {\n [key: string]: Object,\n [key: number]: RegExp,\n};\n\n```", "```ts\nfunction f(x: StringAndNumberKeys) {\n return {\n str: x['abc'],\n num: x[123],\n };\n}\nassertType<\n (x: StringAndNumberKeys) => {\n str: Object | undefined,\n num: RegExp | undefined,\n }\n>(f);\n\n```", "```ts\ntype T1 = {\n [key: string]: boolean,\n\n // @ts-expect-error: Property 'myProp' of type 'number' is not assignable\n // to 'string' index type 'boolean'.\n myProp: number,\n\n // @ts-expect-error: Property 'myMethod' of type '() => string' is not\n // assignable to 'string' index type 'boolean'.\n myMethod(): string,\n};\n\n```", "```ts\ntype T2 = {\n [key: string]: number,\n myProp: number,\n};\n\ntype T3 = {\n [key: string]: () => string,\n myMethod(): string,\n}\n\n```", "```ts\nconst dict: Record<string, number> = {\n one: 1,\n two: 2,\n three: 3,\n};\n\n```", "```ts\ntype Key = 'A' | 'B' | 'C';\n\n// @ts-expect-error: An index signature parameter type cannot be a literal\n// type or generic type. Consider using a mapped object type instead.\nconst dict: {[key: Key]: true} = {\n A: true,\n C: true,\n};\n\n```", "```ts\ntype T = 'A' | 'B' | 'C';\n\n// @ts-expect-error: Property 'C' is missing in type '{ A: true; B: true; }'\n// but required in type 'Record<T, true>'.\nconst nonExhaustiveKeys: Record<T, true> = {\n A: true,\n B: true,\n};\n\nconst exhaustiveKeys: Record<T, true> = {\n A: true,\n B: true,\n C: true,\n};\n\n```", "```ts\nconst wrongKey: Record<T, true> = {\n A: true,\n B: true,\n // @ts-expect-error: Object literal may only specify known properties,\n // and 'D' does not exist in type 'Record<T, true>'.\n D: true,\n};\n\n```", "```ts\ntype T = 'A' | 'B' | 'C';\nconst nonExhaustiveKeys: Partial<Record<T, true>> = {\n A: true,\n};\nconst wrongKey: Partial<Record<T, true>> = {\n // @ts-expect-error: Object literal may only specify known properties,\n // and 'D' does not exist in type 'Partial<Record<T, true>>'.\n D: true,\n};\n\n```", "```ts\n    const obj1: object = {};\n    const obj2: object = [];\n    // @ts-expect-error: Type 'number' is not assignable to type 'object'.\n    const obj3: object = 123;\n\n    ```", "```ts\n    const obj1: Object = new Object();\n\n    ```", "```ts\n    const obj2: Object = 123;\n\n    ```", "```ts\n    const obj1: {} = { toString: true }; // OK\n    const obj2: Object = {\n     // @ts-expect-error: Type 'boolean' is not assignable to\n     // type '() => string'.\n     toString: true,\n    };\n\n    ```", "```ts\n> const obj1 = {};\n> obj1 instanceof Object\ntrue\n\n```", "```ts\n    > Object.prototype.isPrototypeOf(obj1)\n    true\n\n    ```", "```ts\n    > obj1.toString === Object.prototype.toString\n    true\n\n    ```", "```ts\n> const obj2 = Object.create(null);\n> Object.getPrototypeOf(obj2)\nnull\n\n```", "```ts\n> typeof obj2\n'object'\n> obj2 instanceof Object\nfalse\n\n```", "```ts\ninterface Object { // (A)\n constructor: Function;\n toString(): string;\n toLocaleString(): string;\n /** Returns the primitive value of the specified object. */\n valueOf(): Object; // (B)\n hasOwnProperty(v: PropertyKey): boolean;\n isPrototypeOf(v: Object): boolean;\n propertyIsEnumerable(v: PropertyKey): boolean;\n}\n\ninterface ObjectConstructor {\n /** Invocation via `new` */\n new(value?: any): Object;\n /** Invocation via function calls */\n (value?: any): any;\n\n readonly prototype: Object; // (C)\n\n getPrototypeOf(o: any): any;\n // ···\n}\ndeclare var Object: ObjectConstructor; // (D)\n\n```", "```ts\nconst v1: {} = 123;\nconst v2: {} = 123;\nconst v3: {} = {};\nconst v4: {} = { prop: true };\n\n// @ts-expect-error: Type 'undefined' is not assignable to type '{}'.\nconst v5: {} = undefined;\n// @ts-expect-error: Type 'null' is not assignable to type '{}'.\nconst v6: {} = null;\n\n```", "```ts\n/**\n * Exclude null and undefined from T\n */\ntype NonNullable<T> = T & {};\n\ntype _ = [\n Assert<Equal<\n NonNullable<undefined | string>,\n string\n >>,\n Assert<Equal<\n NonNullable<null | string>,\n string\n >>,\n Assert<Equal<\n NonNullable<string>,\n string\n >>,\n];\n\n```", "```ts\nconst obj1 = new Object();\nassertType<Object>(obj1);\n\nconst obj2 = Object.create(null);\nassertType<any>(obj2);\n\nconst obj3 = {};\nassertType<{}>(obj3);\n\nconst obj4 = {prop: 123};\nassertType<{prop: number}>(obj4);\n\nconst obj5 = Reflect.getPrototypeOf({});\nassertType<object | null>(obj5);\n\n```", "```ts\ntype _ = [\n Assert<Not<Assignable<\n object, undefined\n >>>,\n Assert<Not<Assignable<\n Object, undefined\n >>>,\n Assert<Not<Assignable<\n {}, undefined\n >>>,\n Assert<Not<Assignable<\n Record<keyof any, any>, undefined\n >>>,\n];\n\n```", "```ts\ntype _ = [\n Assert<Not<Assignable<\n object, 123\n >>>,\n Assert<Assignable<\n Object, 123\n >>,\n Assert<Assignable<\n {}, 123\n >>,\n Assert<Not<Assignable<\n Record<keyof any, any>, 123\n >>>,\n];\n\n```", "```ts\ntype _ = [\n Assert<Assignable<\n { toString(): string }, object\n >>,\n Assert<Assignable<\n { toString(): string }, Object\n >>,\n Assert<Assignable<\n { toString(): string }, {}\n >>,\n];\n\n```", "```ts\ntype _ = [\n Assert<Assignable<\n object, { toString(): number }\n >>,\n Assert<Not<Assignable<\n Object, { toString(): number }\n >>>,\n Assert<Assignable<\n {}, { toString(): number }\n >>,\n];\n\n```"]