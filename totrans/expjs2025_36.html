<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>30 Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>30 Objects</h1>
<blockquote>原文：<a href="https://exploringjs.com/js/book/ch_objects.html">https://exploringjs.com/js/book/ch_objects.html</a></blockquote>

        
    
    
    
<p><span id="index-entry-object"/></p>
<nav class="local-toc">
  <ol>
    <li>
      <a href="#cheat-sheet-objects">30.1 Cheat sheet: objects</a>
      <ol>
        <li>
          <a href="#cheat-sheet-single-objects">30.1.1 Cheat sheet: single objects</a>
        </li>
        <li>
          <a href="#cheat-sheet-prototype-chains">30.1.2 Cheat sheet: prototype chains</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#what-is-an-object">30.2 What is an object?</a>
      <ol>
        <li>
          <a href="#ways-of-using-objects">30.2.1 The two ways of using objects</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#fixed-layout-objects">30.3 Fixed-layout objects</a>
      <ol>
        <li>
          <a href="#object-literals">30.3.1 Object literals: properties</a>
        </li>
        <li>
          <a href="#object-literals-property-value-shorthands">30.3.2 Object literals: property value shorthands</a>
        </li>
        <li>
          <a href="#getting-properties">30.3.3 Getting properties</a>
        </li>
        <li>
          <a href="#setting-properties">30.3.4 Setting properties</a>
        </li>
        <li>
          <a href="#object-literals-methods">30.3.5 Object literals: methods</a>
        </li>
        <li>
          <a href="#object-literal-accessors">30.3.6 Object literals: accessors</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#spreading-into-object-literals">30.4 Spreading into object literals (<code>...</code>)<span> <sup>ES2018</sup></span></a>
      <ol>
        <li>
          <a href="#use-case-for-spreading-default-values-for-missing-properties">30.4.1 Use case for spreading: default values for missing properties</a>
        </li>
        <li>
          <a href="#use-case-for-spreading-nondestructively-changing-properties">30.4.2 Use case for spreading: non-destructively changing properties</a>
        </li>
        <li>
          <a href="#Object.assign">30.4.3 “Destructive spreading”: <code>Object.assign()</code><span> <sup>ES6</sup></span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#copying-objects">30.5 Copying objects: spreading vs. <code>Object.assign()</code> vs. <code>structuredClone()</code></a>
      <ol>
        <li>
          <a href="#copying-objects-via-spreading-is-shallow">30.5.1 Copying objects via spreading is <em>shallow</em></a>
        </li>
        <li>
          <a href="#structuredClone">30.5.2 Copying objects deeply via <code>structuredClone()</code></a>
        </li>
        <li>
          <a href="#which-values-can-structuredclone-copy">30.5.3 Which values can <code>structuredClone()</code> copy?</a>
        </li>
        <li>
          <a href="#the-property-attributes-of-copied-objects">30.5.4 The property attributes of copied objects</a>
        </li>
        <li>
          <a href="#alternatives-without-the-limitations-of-structuredclone">30.5.5 Alternatives without the limitations of <code>structuredClone()</code>?</a>
        </li>
        <li>
          <a href="#sources-of-this-section-1">30.5.6 Sources of this section</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#methods-and-this">30.6 Methods and the special variable <code>this</code></a>
      <ol>
        <li>
          <a href="#methods-are-properties-whose-values-are-functions">30.6.1 Methods are properties whose values are functions</a>
        </li>
        <li>
          <a href="#the-special-variable-this">30.6.2 The special variable <code>this</code></a>
        </li>
        <li>
          <a href="#methods-call">30.6.3 Methods and <code>.call()</code></a>
        </li>
        <li>
          <a href="#methods-bind">30.6.4 Methods and <code>.bind()</code></a>
        </li>
        <li>
          <a href="#extracting-methods">30.6.5 <code>this</code> pitfall: extracting methods</a>
        </li>
        <li>
          <a href="#shadowing-this">30.6.6 <code>this</code> pitfall: accidentally shadowing <code>this</code></a>
        </li>
        <li>
          <a href="#the-value-of-this-in-various-contexts-advanced">30.6.7 The value of <code>this</code> in various contexts<span> (advanced)</span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#optional-chaining">30.7 Optional chaining for property getting and method calls<span> <sup>ES2020</sup> (advanced)</span></a>
      <ol>
        <li>
          <a href="#example-optional-fixed-property-getting">30.7.1 Example: optional fixed property getting</a>
        </li>
        <li>
          <a href="#the-operators-in-more-detail-advanced">30.7.2 The operators in more detail<span> (advanced)</span></a>
        </li>
        <li>
          <a href="#shortcircuiting-with-optional-property-getting">30.7.3 Short-circuiting with optional property getting</a>
        </li>
        <li>
          <a href="#optional-chaining-downsides-and-alternatives">30.7.4 Optional chaining: downsides and alternatives</a>
        </li>
        <li>
          <a href="#frequently-asked-questions">30.7.5 Frequently asked questions</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#prototype-chains">30.8 Prototype chains</a>
      <ol>
        <li>
          <a href="#javascripts-operations-all-properties-vs-own-properties">30.8.1 JavaScript’s operations: all properties vs. own properties</a>
        </li>
        <li>
          <a href="#pitfall-only-the-first-member-of-a-prototype-chain-is-mutated">30.8.2 Pitfall: only the first member of a prototype chain is mutated</a>
        </li>
        <li>
          <a href="#tips-for-working-with-prototypes-advanced">30.8.3 Tips for working with prototypes<span> (advanced)</span></a>
        </li>
        <li>
          <a href="#Object.hasOwn">30.8.4 <code>Object.hasOwn()</code>: Is a given property own (non-inherited)?<span> <sup>ES2022</sup></span></a>
        </li>
        <li>
          <a href="#sharing-data-via-prototypes">30.8.5 Sharing data via prototypes</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#dictionary-objects">30.9 Dictionary objects<span> (advanced)</span></a>
      <ol>
        <li>
          <a href="#object-literals-quoted-keys">30.9.1 Quoted keys in object literals</a>
        </li>
        <li>
          <a href="#object-literals-computed-keys">30.9.2 Computed keys in object literals</a>
        </li>
        <li>
          <a href="#in-operator">30.9.3 The <code>in</code> operator: is there a property with a given key?</a>
        </li>
        <li>
          <a href="#deleting-properties">30.9.4 Deleting properties</a>
        </li>
        <li>
          <a href="#enumerability">30.9.5 Enumerability</a>
        </li>
        <li>
          <a href="#listing-property-keys">30.9.6 Listing property keys via <code>Object.keys()</code> etc.</a>
        </li>
        <li>
          <a href="#Object.values">30.9.7 Listing property values via <code>Object.values()</code></a>
        </li>
        <li>
          <a href="#Object.entries">30.9.8 Listing property entries via <code>Object.entries()</code><span> <sup>ES2017</sup></span></a>
        </li>
        <li>
          <a href="#order-of-properties">30.9.9 Properties are listed deterministically</a>
        </li>
        <li>
          <a href="#Object.fromEntries">30.9.10 Assembling objects via <code>Object.fromEntries()</code><span> <sup>ES2019</sup></span></a>
        </li>
        <li>
          <a href="#null-prototype-objects">30.9.11 Objects with <code>null</code> prototypes make good dictionaries and lookup tables</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#property-attributes-property-descriptors">30.10 Property attributes and property descriptors<span> <sup>ES5</sup> (advanced)</span></a>
    </li>
    <li>
      <a href="#protecting-objects">30.11 Protecting objects from being changed<span> <sup>ES5</sup> (advanced)</span></a>
    </li>
    <li>
      <a href="#quickref-object-api">30.12 Quick reference: <code>Object</code></a>
      <ol>
        <li>
          <a href="#object-creating-objects-handling-prototypes">30.12.1 <code>Object.*</code>: creating objects, handling prototypes</a>
        </li>
        <li>
          <a href="#object-property-attributes">30.12.2 <code>Object.*</code>: property attributes</a>
        </li>
        <li>
          <a href="#object-property-keys-values-entries">30.12.3 <code>Object.*</code>: property keys, values, entries</a>
        </li>
        <li>
          <a href="#object-protecting-objects">30.12.4 <code>Object.*</code>: protecting objects</a>
        </li>
        <li>
          <a href="#object-miscellaneous">30.12.5 <code>Object.*</code>: miscellaneous</a>
        </li>
        <li>
          <a href="#objectprototype">30.12.6 <code>Object.prototype.*</code></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#quickref-reflect">30.13 Quick reference: <code>Reflect</code></a>
      <ol>
        <li>
          <a href="#reflect-vs-object">30.13.1 <code>Reflect.*</code> vs. <code>Object.*</code></a>
        </li>
      </ol>
    </li>
  </ol>
</nav>
<p>In this book, JavaScript’s style of object-oriented programming (OOP) is introduced in four steps. This chapter covers step 1 and 2; <a href="ch_classes.html#ch_classes">the next chapter</a> covers step 3 and 4. The steps are (<a href="#fig:oop_steps_1_2">figure 30.1</a>):</p>
<ol>
  <li>
    <strong>Single objects (this chapter):</strong> How do <em>objects</em>, JavaScript’s basic OOP building blocks, work in isolation?
  </li>
  <li>
    <strong>Prototype chains (this chapter):</strong> Each object has a chain of zero or more <em>prototype objects</em>. Prototypes are JavaScript’s core inheritance mechanism.
  </li>
  <li>
    <strong>Classes (next chapter):</strong> JavaScript’s <em>classes</em> are factories for objects. The relationship between a class and its instances is based on prototypal inheritance (step 2).
  </li>
  <li>
    <strong>Subclassing (next chapter):</strong> The relationship between a <em>subclass</em> and its <em>superclass</em> is also based on prototypal inheritance.
  </li>
</ol>
<figure id="fig:oop_steps_1_2" class="float">
  <p><img src="../Images/98f9d262c296ae1a67f569088f87168c.png" alt="" style="width:435.701px; height:194.19883px" data-original-src="https://exploringjs.com/js/book/img/objects/oop_steps_1_2.svg"/></p>
  <figcaption>
    <p><span class="float-label">Figure 30.1:</span> This book introduces object-oriented programming in JavaScript in four steps.</p>
  </figcaption>
</figure>
<h3 id="cheat-sheet-objects"><a class="heading-id-link" href="#cheat-sheet-objects">30.1 Cheat sheet: objects</a></h3>
<h4 id="cheat-sheet-single-objects"><a class="heading-id-link" href="#cheat-sheet-single-objects">30.1.1 Cheat sheet: single objects</a></h4>
<p>Creating an object via an <em>object literal</em> (starts and ends with a curly brace):</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> myObject = { <span class="hljs-comment">// object literal</span></code>
<code>  <span class="hljs-attr">myProperty</span>: <span class="hljs-number">1</span>,</code>
<code>  <span class="hljs-title function_">myMethod</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;</span></code>
<code><span class="hljs-params">  }, <span class="hljs-comment">// comma!</span></span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">get</span> <span class="hljs-title function_">myAccessor</span>() {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">myProperty</span>;</span></code>
<code><span class="hljs-params">  }, <span class="hljs-comment">// comma!</span></span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">set</span> <span class="hljs-title function_">myAccessor</span>(<span class="hljs-params">value</span>) {</span></code>
<code><span class="hljs-params">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">myProperty</span> = value;</span></code>
<code><span class="hljs-params">  }, <span class="hljs-comment">// last comma is optional</span></span></code>
<code><span class="hljs-params">};</span></code>
<code/>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span></code>
<code><span class="hljs-params">  myObject.<span class="hljs-property">myProperty</span>, <span class="hljs-number">1</span></span></code>
<code><span class="hljs-params">);</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span></code>
<code><span class="hljs-params">  myObject.<span class="hljs-title function_">myMethod</span>(), <span class="hljs-number">2</span></span></code>
<code><span class="hljs-params">);</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span></code>
<code><span class="hljs-params">  myObject.<span class="hljs-property">myAccessor</span>, <span class="hljs-number">1</span></span></code>
<code><span class="hljs-params">);</span></code>
<code><span class="hljs-params">myObject.<span class="hljs-property">myAccessor</span> = <span class="hljs-number">3</span>;</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span></code>
<code><span class="hljs-params">  myObject.<span class="hljs-property">myProperty</span>, <span class="hljs-number">3</span></span></code>
<code><span class="hljs-params">);</span></code>
</pre>
<p>Being able to create objects directly (without classes) is one of the highlights of JavaScript.</p>
<p>Spreading into objects:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> original = {</code>
<code>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,</code>
<code>  <span class="hljs-attr">b</span>: {</code>
<code>    <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>,</code>
<code>  },</code>
<code>};</code>
<code/>
<code><span class="hljs-comment">// Spreading (...) copies one object “into” another one:</span></code>
<code><span class="hljs-keyword">const</span> modifiedCopy = {</code>
<code>  ...original, <span class="hljs-comment">// spreading</span></code>
<code>  <span class="hljs-attr">d</span>: <span class="hljs-number">4</span>,</code>
<code>};</code>
<code/>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  modifiedCopy,</code>
<code>  {</code>
<code>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,</code>
<code>    <span class="hljs-attr">b</span>: {</code>
<code>      <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>,</code>
<code>    },</code>
<code>    <span class="hljs-attr">d</span>: <span class="hljs-number">4</span>,</code>
<code>  }</code>
<code>);</code>
<code/>
<code><span class="hljs-comment">// Caveat: spreading copies shallowly (property values are shared)</span></code>
<code>modifiedCopy.<span class="hljs-property">a</span> = <span class="hljs-number">5</span>; <span class="hljs-comment">// does not affect `original`</span></code>
<code>modifiedCopy.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-number">6</span>; <span class="hljs-comment">// affects `original`</span></code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  original,</code>
<code>  {</code>
<code>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// unchanged</span></code>
<code>    <span class="hljs-attr">b</span>: {</code>
<code>      <span class="hljs-attr">c</span>: <span class="hljs-number">6</span>, <span class="hljs-comment">// changed</span></code>
<code>    },</code>
<code>  },</code>
<code>);</code>
</pre>
<p>We can also use spreading to make an unmodified (shallow) copy of an object:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> exactCopy = {...obj};</code>
</pre>
<h4 id="cheat-sheet-prototype-chains"><a class="heading-id-link" href="#cheat-sheet-prototype-chains">30.1.2 Cheat sheet: prototype chains</a></h4>
<p>Prototypes are JavaScript’s fundamental inheritance mechanism. Even classes are based on it. Each object has <code>null</code> or an object as its prototype. The latter object can also have a prototype, etc. In general, we get <em>chains</em> of prototypes.</p>
<p>Prototypes are managed like this:</p>
<pre class="language-js">
<code><span class="hljs-comment">// `obj1` has no prototype (its prototype is `null`)</span></code>
<code><span class="hljs-keyword">const</span> obj1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// (A)</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj1), <span class="hljs-literal">null</span> <span class="hljs-comment">// (B)</span></code>
<code>);</code>
<code/>
<code><span class="hljs-comment">// `obj2` has the prototype `proto`</span></code>
<code><span class="hljs-keyword">const</span> proto = {</code>
<code>  <span class="hljs-attr">protoProp</span>: <span class="hljs-string">'protoProp'</span>,</code>
<code>};</code>
<code><span class="hljs-keyword">const</span> obj2 = {</code>
<code>  <span class="hljs-attr">__proto__</span>: proto, <span class="hljs-comment">// (C)</span></code>
<code>  <span class="hljs-attr">objProp</span>: <span class="hljs-string">'objProp'</span>,</code>
<code>}</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj2), proto</code>
<code>);</code>
</pre>
<p>Notes:</p>
<ul>
  <li>
    Setting an object’s prototype while creating the object: line A, line C
  </li>
  <li>
    Retrieving the prototype of an object: line B
  </li>
</ul>
<p>Each object inherits all the properties of its prototype:</p>
<pre class="language-js">
<code><span class="hljs-comment">// `obj2` inherits .protoProp from `proto`</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  obj2.<span class="hljs-property">protoProp</span>, <span class="hljs-string">'protoProp'</span></code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj2),</code>
<code>  [<span class="hljs-string">'objProp'</span>] <span class="hljs-comment">// own properties of `obj2`</span></code>
<code>);</code>
</pre>
<p>The non-inherited properties of an object are called its <em>own</em> properties.</p>
<p>The most important use case for prototypes is that several objects can share methods by inheriting them from a common prototype.</p>
<h3 id="what-is-an-object"><a class="heading-id-link" href="#what-is-an-object">30.2 What is an object?</a></h3>
<p><span id="index-entry-property--object-"/></p>
<p>Objects in JavaScript:</p>
<ul>
  <li>
    An object is a set of <em>slots</em> (key-value entries).
  </li>
  <li>
    Public slots are called <em>properties</em>:
    <ul>
      <li>
        A property key can only be a string or a symbol.
      </li>
    </ul>
  </li>
  <li>
    Private slots can only be created via classes and are explained in <a href="ch_classes.html#private-slots">“Public slots (properties) vs. private slots” (§31.2.4)</a>.
  </li>
</ul>
<h4 id="ways-of-using-objects"><a class="heading-id-link" href="#ways-of-using-objects">30.2.1 The two ways of using objects</a></h4>
<p><span id="index-entry-fixed-layout-object"/><span id="index-entry-object--fixed-layout"/>
<span id="index-entry-dictionary-object"/><span id="index-entry-object--dictionary"/></p>
<p>There are two ways of using objects in JavaScript:</p>
<ul>
  <li>
    <p>Fixed-layout objects: Used this way, objects work like records in databases. They have a fixed number of properties, whose keys are known at development time. Their values generally have different types.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> fixedLayoutObject = {</code>
<code>  <span class="hljs-attr">product</span>: <span class="hljs-string">'carrot'</span>,</code>
<code>  <span class="hljs-attr">quantity</span>: <span class="hljs-number">4</span>,</code>
<code>};</code>
</pre>
  </li>
  <li>
    <p>Dictionary objects: Used this way, objects work like lookup tables or maps. They have a variable number of properties, whose keys are not known at development time. All of their values have the same type.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> dictionaryObject = {</code>
<code>  [<span class="hljs-string">'one'</span>]: <span class="hljs-number">1</span>,</code>
<code>  [<span class="hljs-string">'two'</span>]: <span class="hljs-number">2</span>,</code>
<code>};</code>
</pre>
  </li>
</ul>
<p>Note that the two ways can also be mixed: Some objects are both fixed-layout objects and dictionary objects.</p>
<p>The ways of using objects influence how they are explained in this chapter:</p>
<ul>
  <li>
    <a href="#fixed-layout-objects">First, we’ll explore fixed-layout objects.</a> Even though property keys are strings or symbols under the hood, they will appear as fixed identifiers to us.
  </li>
  <li>
    <a href="#dictionary-objects">Later, we’ll explore dictionary objects.</a> Note that <a href="ch_maps.html#ch_maps">Maps</a> are usually better dictionaries than objects. However, some of the operations that we’ll encounter are also useful for fixed-layout objects.
  </li>
</ul>
<h3 id="fixed-layout-objects"><a class="heading-id-link" href="#fixed-layout-objects">30.3 Fixed-layout objects</a></h3>
<p>Let’s first explore <em>fixed-layout objects</em>.</p>
<h4 id="object-literals"><a class="heading-id-link" href="#object-literals">30.3.1 Object literals: properties</a></h4>
<p><span id="index-entry-object-literal"/></p>
<p><em>Object literals</em> are one way of creating fixed-layout objects. They are a stand-out feature of JavaScript: we can directly create objects – no need for classes! This is an example:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> jane = {</code>
<code>  <span class="hljs-attr">first</span>: <span class="hljs-string">'Jane'</span>,</code>
<code>  <span class="hljs-attr">last</span>: <span class="hljs-string">'Doe'</span>, <span class="hljs-comment">// optional trailing comma</span></code>
<code>};</code>
</pre>
<p>In the example, we created an object via an object literal, which starts and ends with curly braces <code>{}</code>. Inside it, we defined two <em>properties</em> (key-value entries):</p>
<ul>
  <li>
    The first property has the key <code>first</code> and the value <code>'Jane'</code>.
  </li>
  <li>
    The second property has the key <code>last</code> and the value <code>'Doe'</code>.
  </li>
</ul>
<p><span id="index-entry-trailing-commas-in-object-literals"/></p>
<p>Since ES5, trailing commas are allowed in object literals.</p>
<p>We will later see other ways of specifying property keys, but with this way of specifying them, they must follow the rules of JavaScript variable names. For example, we can use <code>first_name</code> as a property key, but not <code>first-name</code>). However, reserved words are allowed:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  <span class="hljs-attr">if</span>: <span class="hljs-literal">true</span>,</code>
<code>  <span class="hljs-attr">const</span>: <span class="hljs-literal">true</span>,</code>
<code>};</code>
</pre>
<p>In order to check the effects of various operations on objects, we’ll occasionally use <code>Object.keys()</code> in this part of the chapter. It lists property keys:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>({<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">b</span>:<span class="hljs-number">2</span>})</span></code>
<code>[ 'a', 'b' ]</code>
</pre>
<h4 id="object-literals-property-value-shorthands"><a class="heading-id-link" href="#object-literals-property-value-shorthands">30.3.2 Object literals: property value shorthands</a></h4>
<p><span id="index-entry-property-value-shorthand"/></p>
<p>Whenever the value of a property is defined via a variable that has the same name as the key, we can omit the key.</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">createPoint</span>(<span class="hljs-params">x, y</span>) {</code>
<code>  <span class="hljs-keyword">return</span> {x, y}; <span class="hljs-comment">// Same as: {x: x, y: y}</span></code>
<code>}</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title function_">createPoint</span>(<span class="hljs-number">9</span>, <span class="hljs-number">2</span>),</code>
<code>  { <span class="hljs-attr">x</span>: <span class="hljs-number">9</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> }</code>
<code>);</code>
</pre>
<h4 id="getting-properties"><a class="heading-id-link" href="#getting-properties">30.3.3 Getting properties</a></h4>
<p>This is how we <em>get</em> (read) a property (line A):</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> jane = {</code>
<code>  <span class="hljs-attr">first</span>: <span class="hljs-string">'Jane'</span>,</code>
<code>  <span class="hljs-attr">last</span>: <span class="hljs-string">'Doe'</span>,</code>
<code>};</code>
<code/>
<code><span class="hljs-comment">// Get property .first</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(jane.<span class="hljs-property">first</span>, <span class="hljs-string">'Jane'</span>); <span class="hljs-comment">// (A)</span></code>
</pre>
<p>Getting an unknown property produces <code>undefined</code>:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(jane.<span class="hljs-property">unknownProperty</span>, <span class="hljs-literal">undefined</span>);</code>
</pre>
<h4 id="setting-properties"><a class="heading-id-link" href="#setting-properties">30.3.4 Setting properties</a></h4>
<p>This is how we <em>set</em> (write to) a property (line A):</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  <span class="hljs-attr">prop</span>: <span class="hljs-number">1</span>,</code>
<code>};</code>
<code>assert.<span class="hljs-title function_">equal</span>(obj.<span class="hljs-property">prop</span>, <span class="hljs-number">1</span>);</code>
<code>obj.<span class="hljs-property">prop</span> = <span class="hljs-number">2</span>; <span class="hljs-comment">// (A)</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(obj.<span class="hljs-property">prop</span>, <span class="hljs-number">2</span>);</code>
</pre>
<p>We just changed an existing property via setting. If we set an unknown property, we create a new entry:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {}; <span class="hljs-comment">// empty object</span></code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj), []);</code>
<code/>
<code>obj.<span class="hljs-property">unknownProperty</span> = <span class="hljs-string">'abc'</span>;</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj), [<span class="hljs-string">'unknownProperty'</span>]);</code>
</pre>
<h4 id="object-literals-methods"><a class="heading-id-link" href="#object-literals-methods">30.3.5 Object literals: methods</a></h4>
<p><span id="index-entry-method--object-literal-"/></p>
<p>The following code shows how to create the method <code>.says()</code> via an object literal:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> jane = {</code>
<code>  <span class="hljs-attr">first</span>: <span class="hljs-string">'Jane'</span>, <span class="hljs-comment">// value property</span></code>
<code>  <span class="hljs-title function_">says</span>(<span class="hljs-params">text</span>) {   <span class="hljs-comment">// method</span></code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.first}</span> says “<span class="hljs-subst">${text}</span>”`</span>; <span class="hljs-comment">// (A)</span></code>
<code>  }, <span class="hljs-comment">// comma as separator (optional at end)</span></code>
<code>};</code>
<code>assert.<span class="hljs-title function_">equal</span>(jane.<span class="hljs-title function_">says</span>(<span class="hljs-string">'hello'</span>), <span class="hljs-string">'Jane says “hello”'</span>);</code>
</pre>
<p>During the method call <code>jane.says('hello')</code>, <code>jane</code> is called the <em>receiver</em> of the method call and assigned to the special variable <code>this</code> (more on <code>this</code> in <a href="#methods-and-this">“Methods and the special variable <code>this</code>” (§30.6)</a>). That enables method <code>.says()</code> to access the sibling property <code>.first</code> in line A.</p>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Creating an object via an object literal</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/objects/color_point_object_test.mjs</code></p>
</div>
<h4 id="object-literal-accessors"><a class="heading-id-link" href="#object-literal-accessors">30.3.6 Object literals: accessors</a></h4>
<p><span id="index-entry-accessor--object-literal-"/></p>
<p><em>Accessors</em> are methods that are invoked by accessing a property. It consists of either or both of:</p>
<ul>
  <li>
    A <em>getter</em> is invoked by getting a property.
  </li>
  <li>
    A <em>setter</em> is invoked by setting a property.
  </li>
</ul>
<h5 id="getters"><a class="heading-id-link" href="#getters">30.3.6.1 Getters</a></h5>
<p><span id="index-entry-getter--object-literal-"/></p>
<p>A getter is created by prefixing a method definition with the modifier <code>get</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> jane = {</code>
<code>  <span class="hljs-attr">first</span>: <span class="hljs-string">'Jane'</span>,</code>
<code>  <span class="hljs-attr">last</span>: <span class="hljs-string">'Doe'</span>,</code>
<code>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">full</span>() {</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.first}</span> <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.last}</span>`</span>;</code>
<code>  },</code>
<code>};</code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(jane.<span class="hljs-property">full</span>, <span class="hljs-string">'Jane Doe'</span>);</code>
<code>jane.<span class="hljs-property">first</span> = <span class="hljs-string">'John'</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(jane.<span class="hljs-property">full</span>, <span class="hljs-string">'John Doe'</span>);</code>
</pre>
<h5 id="setters"><a class="heading-id-link" href="#setters">30.3.6.2 Setters</a></h5>
<p><span id="index-entry-setter--object-literal-"/></p>
<p>A setter is created by prefixing a method definition with the modifier <code>set</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> jane = {</code>
<code>  <span class="hljs-attr">first</span>: <span class="hljs-string">'Jane'</span>,</code>
<code>  <span class="hljs-attr">last</span>: <span class="hljs-string">'Doe'</span>,</code>
<code>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">full</span>(<span class="hljs-params">fullName</span>) {</code>
<code>    <span class="hljs-keyword">const</span> parts = fullName.<span class="hljs-title function_">split</span>(<span class="hljs-string">' '</span>);</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">first</span> = parts[<span class="hljs-number">0</span>];</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">last</span> = parts[<span class="hljs-number">1</span>];</code>
<code>  },</code>
<code>};</code>
<code/>
<code>jane.<span class="hljs-property">full</span> = <span class="hljs-string">'Richard Roe'</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(jane.<span class="hljs-property">first</span>, <span class="hljs-string">'Richard'</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(jane.<span class="hljs-property">last</span>, <span class="hljs-string">'Roe'</span>);</code>
</pre>
<h5 id="use-case-for-getters-readyonly-properties-whose-values-change"><a class="heading-id-link" href="#use-case-for-getters-readyonly-properties-whose-values-change">30.3.6.3 Use case for getters: ready-only properties whose values change</a></h5>
<p>In the following code, the actual value of the counter is private. From the outside, it can only be read, via a getter:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-comment">// Private data via closure</span></span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">let</span> value = <span class="hljs-number">0</span>;</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">return</span> {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() {</span></code>
<code><span class="hljs-params">      <span class="hljs-keyword">return</span> value;</span></code>
<code><span class="hljs-params">    },</span></code>
<code><span class="hljs-params">    <span class="hljs-title function_">inc</span>(<span class="hljs-params"/>) {</span></code>
<code><span class="hljs-params">      value++;</span></code>
<code><span class="hljs-params">    },</span></code>
<code><span class="hljs-params">  };</span></code>
<code><span class="hljs-params">}</span></code>
<code/>
<code><span class="hljs-params"><span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">createCounter</span>();</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(counter.<span class="hljs-property">value</span>, <span class="hljs-number">0</span>);</span></code>
<code/>
<code><span class="hljs-params">counter.<span class="hljs-title function_">inc</span>();</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(counter.<span class="hljs-property">value</span>, <span class="hljs-number">1</span>);</span></code>
<code/>
<code><span class="hljs-params">assert.<span class="hljs-title function_">throws</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-function">() =&gt;</span> counter.<span class="hljs-property">value</span> = <span class="hljs-number">5</span>,</span></code>
<code><span class="hljs-params">  <span class="hljs-regexp">/^TypeError: Cannot set property value of #&lt;Object&gt; which has only a getter$/</span></span></code>
<code><span class="hljs-params">);</span></code>
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Implementing a stack via an object</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/objects/stack-via-object_test.mjs</code></p>
</div>
<h5 id="use-case-for-getters-switching-from-a-property-to-more-encapsulation"><a class="heading-id-link" href="#use-case-for-getters-switching-from-a-property-to-more-encapsulation">30.3.6.4 Use case for getters: switching from a property to more encapsulation</a></h5>
<p>In object-oriented programming, we worry about exposing too much internal state. Accessors enable us to change our mind about properties without breaking existing code: We can start exposed, with a normal property and later switch to an accessor and more encapsulation.</p>
<h3 id="spreading-into-object-literals"><a class="heading-id-link" href="#spreading-into-object-literals">30.4 Spreading into object literals (<code>...</code>)<span> <sup>ES2018</sup></span></a></h3>
<p><span id="index-entry-spreading-into-an-object-literal"/></p>
<p>Inside an object literal, a <em>spread property</em> adds the properties of another object to the current one:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj1 = {<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>};</code>
<code><span class="hljs-keyword">const</span> obj2 = {<span class="hljs-attr">c</span>: <span class="hljs-number">3</span>};</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  {...obj1, ...obj2, <span class="hljs-attr">d</span>: <span class="hljs-number">4</span>},</code>
<code>  {<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">d</span>: <span class="hljs-number">4</span>}</code>
<code>);</code>
</pre>
<p>If property keys clash, the property that is mentioned last “wins”:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> obj = {<span class="hljs-attr">one</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">two</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">three</span>: <span class="hljs-number">3</span>};</span></code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">{...obj, <span class="hljs-attr">one</span>: <span class="hljs-literal">true</span>}</span></code>
<code>{ one: true, two: 2, three: 3 }</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">{<span class="hljs-attr">one</span>: <span class="hljs-literal">true</span>, ...obj}</span></code>
<code>{ one: 1, two: 2, three: 3 }</code>
</pre>
<p>All values are spreadable, even <code>undefined</code> and <code>null</code>:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">{...<span class="hljs-literal">undefined</span>}</span></code>
<code>{}</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">{...<span class="hljs-literal">null</span>}</span></code>
<code>{}</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">{...<span class="hljs-number">123</span>}</span></code>
<code>{}</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">{...<span class="hljs-string">'abc'</span>}</span></code>
<code>{ '0': 'a', '1': 'b', '2': 'c' }</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">{...[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]}</span></code>
<code>{ '0': 'a', '1': 'b' }</code>
</pre>
<p>Property <code>.length</code> of strings and Arrays is hidden from this kind of operation (it is not <em>enumerable</em>; see <a href="#property-attributes-property-descriptors">“Property attributes and property descriptors<span> <sup>ES5</sup> (advanced)</span>” (§30.10)</a> for more information).</p>
<p>Spreading includes properties whose keys are symbols (which are ignored by <code>Object.keys()</code>, <code>Object.values()</code> and <code>Object.entries()</code>):</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> symbolKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'symbolKey'</span>);</code>
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  <span class="hljs-attr">stringKey</span>: <span class="hljs-number">1</span>,</code>
<code>  [symbolKey]: <span class="hljs-number">2</span>,</code>
<code>};</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  {...obj, <span class="hljs-attr">anotherStringKey</span>: <span class="hljs-number">3</span>},</code>
<code>  {</code>
<code>    <span class="hljs-attr">stringKey</span>: <span class="hljs-number">1</span>,</code>
<code>    [symbolKey]: <span class="hljs-number">2</span>,</code>
<code>    <span class="hljs-attr">anotherStringKey</span>: <span class="hljs-number">3</span>,</code>
<code>  }</code>
<code>);</code>
</pre>
<h4 id="use-case-for-spreading-default-values-for-missing-properties"><a class="heading-id-link" href="#use-case-for-spreading-default-values-for-missing-properties">30.4.1 Use case for spreading: default values for missing properties</a></h4>
<p>If one of the inputs of our code is an object with data, we can make properties optional by specifying default values that are used if those properties are missing. One technique for doing so is via an object whose properties contain the default values. In the following example, that object is <code>DEFAULTS</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DEFAULTS</span> = {<span class="hljs-attr">alpha</span>: <span class="hljs-string">'a'</span>, <span class="hljs-attr">beta</span>: <span class="hljs-string">'b'</span>};</code>
<code><span class="hljs-keyword">const</span> providedData = {<span class="hljs-attr">alpha</span>: <span class="hljs-number">1</span>};</code>
<code/>
<code><span class="hljs-keyword">const</span> allData = {...<span class="hljs-variable constant_">DEFAULTS</span>, ...providedData};</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(allData, {<span class="hljs-attr">alpha</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">beta</span>: <span class="hljs-string">'b'</span>});</code>
</pre>
<p>The result, the object <code>allData</code>, is created by copying <code>DEFAULTS</code> and overriding its properties with those of <code>providedData</code>.</p>
<p>But we don’t need an object to specify the default values; we can also specify them inside the object literal, individually:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> providedData = {<span class="hljs-attr">alpha</span>: <span class="hljs-number">1</span>};</code>
<code/>
<code><span class="hljs-keyword">const</span> allData = {<span class="hljs-attr">alpha</span>: <span class="hljs-string">'a'</span>, <span class="hljs-attr">beta</span>: <span class="hljs-string">'b'</span>, ...providedData};</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(allData, {<span class="hljs-attr">alpha</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">beta</span>: <span class="hljs-string">'b'</span>});</code>
</pre>
<h4 id="use-case-for-spreading-nondestructively-changing-properties"><a class="heading-id-link" href="#use-case-for-spreading-nondestructively-changing-properties">30.4.2 Use case for spreading: non-destructively changing properties</a></h4>
<p>So far, we have encountered one way of changing a property <code>.alpha</code> of an object: We <em>set</em> it (line A) and mutate the object. That is, this way of changing a property is destructive.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {<span class="hljs-attr">alpha</span>: <span class="hljs-string">'a'</span>, <span class="hljs-attr">beta</span>: <span class="hljs-string">'b'</span>};</code>
<code>obj.<span class="hljs-property">alpha</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// (A)</span></code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(obj, {<span class="hljs-attr">alpha</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">beta</span>: <span class="hljs-string">'b'</span>});</code>
</pre>
<p>With spreading, we can change <code>.alpha</code> non-destructively – we make a copy of <code>obj</code> where <code>.alpha</code> has a different value:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {<span class="hljs-attr">alpha</span>: <span class="hljs-string">'a'</span>, <span class="hljs-attr">beta</span>: <span class="hljs-string">'b'</span>};</code>
<code><span class="hljs-keyword">const</span> updatedObj = {...obj, <span class="hljs-attr">alpha</span>: <span class="hljs-number">1</span>};</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(updatedObj, {<span class="hljs-attr">alpha</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">beta</span>: <span class="hljs-string">'b'</span>});</code>
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Non-destructively updating a property via spreading (fixed key)</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/objects/update_name_test.mjs</code></p>
</div>
<h4 id="Object.assign"><a class="heading-id-link" href="#Object.assign">30.4.3 “Destructive spreading”: <code>Object.assign()</code><span> <sup>ES6</sup></span></a></h4>
<p><code>Object.assign()</code> is a tool method:</p>
<pre class="language-js">
<code><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(target, source_1, source_2, ···)</code>
</pre>
<p>This expression assigns all properties of <code>source_1</code> to <code>target</code>, then all properties of <code>source_2</code>, etc. At the end, it returns <code>target</code> – for example:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> target = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> };</code>
<code/>
<code><span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(</code>
<code>  target,</code>
<code>  {<span class="hljs-attr">b</span>: <span class="hljs-number">2</span>},</code>
<code>  {<span class="hljs-attr">c</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">b</span>: <span class="hljs-literal">true</span>}</code>
<code>);</code>
<code/>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  result, { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> }</code>
<code>);</code>
<code><span class="hljs-comment">// target was modified and returned:</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(result, target);</code>
</pre>
<p>The use cases for <code>Object.assign()</code> are similar to those for spread properties. In a way, it spreads destructively.</p>
<h3 id="copying-objects"><a class="heading-id-link" href="#copying-objects">30.5 Copying objects: spreading vs. <code>Object.assign()</code> vs. <code>structuredClone()</code></a></h3>
<h4 id="copying-objects-via-spreading-is-shallow"><a class="heading-id-link" href="#copying-objects-via-spreading-is-shallow">30.5.1 Copying objects via spreading is <em>shallow</em></a></h4>
<p>One common way of copying Arrays and plain objects in JavaScript is via spreading. This code demonstrates the latter:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {<span class="hljs-attr">id</span>: <span class="hljs-string">'e1fd960b'</span>, <span class="hljs-attr">values</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]};</code>
<code><span class="hljs-keyword">const</span> shallowCopy = {...obj};</code>
</pre>
<p>Alas, this way of copying is <em>shallow</em>: The properties (key-value entries) are copied but not the property values.</p>
<p>On one hand, the key-value entry <code>shallowCopy.id</code> is a copy, so changing it does not change <code>obj</code>:</p>
<pre class="language-js">
<code>shallowCopy.<span class="hljs-property">id</span> = <span class="hljs-string">'yes'</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(obj.<span class="hljs-property">id</span>, <span class="hljs-string">'e1fd960b'</span>);</code>
</pre>
<p>On the other hand, the Array in <code>shallowCopy.values</code> is shared with <code>obj</code>. If we change it, we also change <code>obj</code>:</p>
<pre class="language-js">
<code>shallowCopy.<span class="hljs-property">values</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'x'</span>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  shallowCopy, {<span class="hljs-attr">id</span>: <span class="hljs-string">'yes'</span>, <span class="hljs-attr">values</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'x'</span>]}</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  obj, {<span class="hljs-attr">id</span>: <span class="hljs-string">'e1fd960b'</span>, <span class="hljs-attr">values</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'x'</span>]}</code>
<code>);</code>
</pre>
<p>Copying via <code>Object.assign()</code> is similar to copying via spreading and also shallow:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {<span class="hljs-attr">id</span>: <span class="hljs-string">'e1fd960b'</span>, <span class="hljs-attr">values</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]};</code>
<code><span class="hljs-comment">// Copy the properties of `obj` into a new object</span></code>
<code><span class="hljs-keyword">const</span> shallowCopy = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, obj);</code>
</pre>
<h4 id="structuredClone"><a class="heading-id-link" href="#structuredClone">30.5.2 Copying objects deeply via <code>structuredClone()</code></a></h4>
<p><code id="index-entry-structuredClone--">structuredClone()</code> is a function for copying objects. Even though it is not part of ECMAScript, it is <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/structuredClone#browser_compatibility">well-supported</a> on all major JavaScript platforms. It has the following typeSignature:</p>
<pre class="language-ts">
<code><span class="hljs-title function_">structuredClone</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">any</span></code>
</pre>
<p><code>structuredClone()</code> copies objects deeply:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {<span class="hljs-attr">id</span>: <span class="hljs-string">'e1fd960b'</span>, <span class="hljs-attr">values</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]};</code>
<code><span class="hljs-keyword">const</span> deepCopy = <span class="hljs-title function_">structuredClone</span>(obj);</code>
<code/>
<code>deepCopy.<span class="hljs-property">values</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'x'</span>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  deepCopy, {<span class="hljs-attr">id</span>: <span class="hljs-string">'e1fd960b'</span>, <span class="hljs-attr">values</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'x'</span>]}</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  obj, {<span class="hljs-attr">id</span>: <span class="hljs-string">'e1fd960b'</span>, <span class="hljs-attr">values</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]}</code>
<code>);</code>
</pre>
<div class="boxout">
  <p><img src="../Images/38ba63de820aae6f94a019538ae0f222.png" class="boxout-icon" height="24" alt="Icon “details”" data-original-src="https://exploringjs.com/js/book/icon/details.svg"/> <strong><code>structuredClone()</code> has a second paramater</strong></p>
  <div class="boxout-vspace"/>
  <p><code>structuredClone()</code> has a second parameter which is beyond the scope of this chapter. For more information, see:</p>
  <ul>
    <li>
      <a href="ch_typed-arrays.html#transferring-arraybuffers-via-structuredclone">“Transferring ArrayBuffers via <code>structuredClone()</code>” (§35.7.3)</a>
    </li>
    <li>
      <a href="https://developer.mozilla.org/en-US/docs/Web/API/structuredClone">The MDN page for <code>structuredClone()</code></a>
    </li>
  </ul>
</div>
<h4 id="which-values-can-structuredclone-copy"><a class="heading-id-link" href="#which-values-can-structuredclone-copy">30.5.3 Which values can <code>structuredClone()</code> copy?</a></h4>
<ul>
  <li>
    It can copy all primitive values except symbols.
  </li>
  <li>
    It can copy all built-in objects except functions and DOM nodes.
  </li>
  <li>
    Instances of user-defined classes become plain objects.
  </li>
  <li>
    Private fields are not copied.
  </li>
  <li>
    Cyclical references are copied correctly.
  </li>
</ul>
<p>Given that the original use case for <code>structuredClone()</code> was copying objects to other processes, these limitations make sense.</p>
<p>Read on for more information.</p>
<h5 id="most-primitive-values-can-be-copied"><a class="heading-id-link" href="#most-primitive-values-can-be-copied">30.5.3.1 Most primitive values can be copied</a></h5>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-title function_">structuredClone</span>(<span class="hljs-literal">true</span>)</span></code>
<code>'boolean'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-title function_">structuredClone</span>(<span class="hljs-number">123</span>)</span></code>
<code>'number'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-title function_">structuredClone</span>(<span class="hljs-number">123n</span>)</span></code>
<code>'bigint'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-title function_">structuredClone</span>(<span class="hljs-string">'abc'</span>)</span></code>
<code>'string'</code>
</pre>
<h5 id="most-builtin-objects-can-be-copied"><a class="heading-id-link" href="#most-builtin-objects-can-be-copied">30.5.3.2 Most built-in objects can be copied</a></h5>
<p>Arrays and plain objects can be copied:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">structuredClone</span>({<span class="hljs-attr">prop</span>: <span class="hljs-literal">true</span>})</span></code>
<code>{ prop: true }</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">structuredClone</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])</span></code>
<code>[ 'a', 'b', 'c' ]</code>
</pre>
<p>Instances of most built-in classes can be copied – even though they have internal slots. They remain instances of their classes.</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">structuredClone</span>(<span class="hljs-regexp">/^a+$/</span>) <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span></span></code>
<code>true</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">structuredClone</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()) <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span></span></code>
<code>true</code>
</pre>
<h5 id="copying-symbols-and-some-objects-produces-exceptions"><a class="heading-id-link" href="#copying-symbols-and-some-objects-produces-exceptions">30.5.3.3 Copying symbols and some objects produces exceptions</a></h5>
<p>Symbols and some objects cannot be copied – <code>structuredClone()</code> throws a <code>DOMException</code> if we try to copy them or if we try to copy an object that contains them:</p>
<ul>
  <li>
    Symbols
  </li>
  <li>
    Functions (ordinary functions, arrow functions, classes, methods)
  </li>
  <li>
    DOM nodes
  </li>
</ul>
<p>Examples – cloning symbols:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">structuredClone</span>(<span class="hljs-title class_">Symbol</span>())</span></code>
<code>DOMException [DataCloneError]: Symbol() could not be cloned.</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">structuredClone</span>({[<span class="hljs-title class_">Symbol</span>()]: <span class="hljs-literal">true</span>}) <span class="hljs-comment">// property is ignored</span></span></code>
<code>{}</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">structuredClone</span>({<span class="hljs-attr">prop</span>: <span class="hljs-title class_">Symbol</span>()})</span></code>
<code>DOMException [DataCloneError]: Symbol() could not be cloned.</code>
</pre>
<p>Examples – cloning functions:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">structuredClone</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {}) <span class="hljs-comment">// ordinary function</span></span></code>
<code>DOMException [DataCloneError]: function () {} could not be cloned.</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">structuredClone</span>(<span class="hljs-function">() =&gt;</span> {}) <span class="hljs-comment">// arrow function</span></span></code>
<code>DOMException [DataCloneError]: () =&gt; {} could not be cloned.</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">structuredClone</span>(<span class="hljs-keyword">class</span> {})</span></code>
<code>DOMException [DataCloneError]: class {} could not be cloned.</code>
<code/>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">structuredClone</span>({ <span class="hljs-title function_">m</span>(<span class="hljs-params"/>){} }.<span class="hljs-property">m</span>) <span class="hljs-comment">// method</span></span></code>
<code>DOMException [DataCloneError]: m(){} could not be cloned.</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">structuredClone</span>({ <span class="hljs-title function_">m</span>(<span class="hljs-params"/>){} }) <span class="hljs-comment">// object with method</span></span></code>
<code>DOMException [DataCloneError]: m(){} could not be cloned.</code>
</pre>
<p>What does the exception look like that is thrown by <code>structuredClone()</code>?</p>
<pre class="language-js">
<code><span class="hljs-keyword">try</span> {</code>
<code>  <span class="hljs-title function_">structuredClone</span>(<span class="hljs-function">() =&gt;</span> {});</code>
<code>} <span class="hljs-keyword">catch</span> (err) {</code>
<code>  assert.<span class="hljs-title function_">equal</span>(</code>
<code>    err <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">DOMException</span>, <span class="hljs-literal">true</span></code>
<code>  );</code>
<code>  assert.<span class="hljs-title function_">equal</span>(</code>
<code>    err.<span class="hljs-property">name</span>, <span class="hljs-string">'DataCloneError'</span></code>
<code>  );</code>
<code>  assert.<span class="hljs-title function_">equal</span>(</code>
<code>    err.<span class="hljs-property">code</span>, <span class="hljs-title class_">DOMException</span>.<span class="hljs-property">DATA_CLONE_ERR</span></code>
<code>  );</code>
<code>}</code>
</pre>
<h5 id="instances-of-userdefined-classes-become-plain-objects"><a class="heading-id-link" href="#instances-of-userdefined-classes-become-plain-objects">30.5.3.4 Instances of user-defined classes become plain objects</a></h5>
<p>In the following example, we copy an instance of the class <code>C</code>. The result, <code>copy</code>, is not an instance of <code>C</code>.</p>
<pre class="language-js">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {}</code>
<code><span class="hljs-keyword">const</span> copy = <span class="hljs-title function_">structuredClone</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>());</code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(copy <span class="hljs-keyword">instanceof</span> C, <span class="hljs-literal">false</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(copy),</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></code>
<code>);</code>
</pre>
<h5 id="private-fields-are-not-copied"><a class="heading-id-link" href="#private-fields-are-not-copied">30.5.3.5 Private fields are not copied</a></h5>
<p>This limitation is related to the previous subsection – private fields are not copied by <code>structuredClone()</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {</code>
<code>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">hasPrivateField</span>(<span class="hljs-params">value</span>) {</code>
<code>    <span class="hljs-keyword">return</span> #privateField <span class="hljs-keyword">in</span> value;</code>
<code>  }</code>
<code>  #privateField = <span class="hljs-literal">true</span>;</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">const</span> original = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  C.<span class="hljs-title function_">hasPrivateField</span>(original), <span class="hljs-literal">true</span></code>
<code>);</code>
<code><span class="hljs-keyword">const</span> copy = <span class="hljs-title function_">structuredClone</span>(original);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  C.<span class="hljs-title function_">hasPrivateField</span>(copy), <span class="hljs-literal">false</span></code>
<code>);</code>
</pre>
<h5 id="cyclical-references-are-copied-correctly"><a class="heading-id-link" href="#cyclical-references-are-copied-correctly">30.5.3.6 Cyclical references are copied correctly</a></h5>
<p>If we copy an object with a reference cycle, the result has the same structure:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> cycle = {};</code>
<code>cycle.<span class="hljs-property">prop</span> = cycle;</code>
<code/>
<code><span class="hljs-keyword">const</span> copy = <span class="hljs-title function_">structuredClone</span>(cycle);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  copy.<span class="hljs-property">prop</span>, copy</code>
<code>);</code>
</pre>
<h4 id="the-property-attributes-of-copied-objects"><a class="heading-id-link" href="#the-property-attributes-of-copied-objects">30.5.4 The property attributes of copied objects</a></h4>
<p><code>structuredClone()</code> doesn’t always faithfully copy the <a href="#property-attributes-property-descriptors">property attributes</a> of objects:</p>
<ul>
  <li>
    Accessors are turned into data properties.
  </li>
  <li>
    In copies, the property attributes always have default values.
  </li>
</ul>
<p>Read on for more information.</p>
<h5 id="accessors-become-data-properties"><a class="heading-id-link" href="#accessors-become-data-properties">30.5.4.1 Accessors become data properties</a></h5>
<p>Accessors become data properties:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(</code>
<code>  {},</code>
<code>  {</code>
<code>    <span class="hljs-attr">accessor</span>: {</code>
<code>      <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">        <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;</span></code>
<code><span class="hljs-params">      },</span></code>
<code><span class="hljs-params">      <span class="hljs-attr">set</span>: <span class="hljs-literal">undefined</span>,</span></code>
<code><span class="hljs-params">      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,</span></code>
<code><span class="hljs-params">      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,</span></code>
<code><span class="hljs-params">    },</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">);</span></code>
<code><span class="hljs-params"><span class="hljs-keyword">const</span> copy = <span class="hljs-title function_">structuredClone</span>(obj);</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(copy),</span></code>
<code><span class="hljs-params">  {</span></code>
<code><span class="hljs-params">    <span class="hljs-attr">accessor</span>: {</span></code>
<code><span class="hljs-params">      <span class="hljs-attr">value</span>: <span class="hljs-number">123</span>,</span></code>
<code><span class="hljs-params">      <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,</span></code>
<code><span class="hljs-params">      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,</span></code>
<code><span class="hljs-params">      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,</span></code>
<code><span class="hljs-params">    },</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">);</span></code>
</pre>
<h5 id="copies-of-properties-have-default-attribute-values"><a class="heading-id-link" href="#copies-of-properties-have-default-attribute-values">30.5.4.2 Copies of properties have default attribute values</a></h5>
<p>Data properties of copies always have the following attributes:</p>
<pre class="language-js">
<code><span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,</code>
<code><span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,</code>
<code><span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,</code>
</pre>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(</code>
<code>  {},</code>
<code>  {</code>
<code>    <span class="hljs-attr">readOnlyProp</span>: {</code>
<code>      <span class="hljs-attr">value</span>: <span class="hljs-string">'abc'</span>,</code>
<code>      <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,</code>
<code>      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,</code>
<code>      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>,</code>
<code>    },</code>
<code>  }</code>
<code>);</code>
<code><span class="hljs-keyword">const</span> copy = <span class="hljs-title function_">structuredClone</span>(obj);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(copy),</code>
<code>  {</code>
<code>    <span class="hljs-attr">readOnlyProp</span>: {</code>
<code>      <span class="hljs-attr">value</span>: <span class="hljs-string">'abc'</span>,</code>
<code>      <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,</code>
<code>      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,</code>
<code>      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,</code>
<code>    }</code>
<code>  }</code>
<code>);</code>
</pre>
<h4 id="alternatives-without-the-limitations-of-structuredclone"><a class="heading-id-link" href="#alternatives-without-the-limitations-of-structuredclone">30.5.5 Alternatives without the limitations of <code>structuredClone()</code>?</a></h4>
<p>If we can’t live with the limitations of <code>structuredClone()</code>, such as turning instances of classes into plain objects, we can use the Lodash function <a href="https://lodash.com/docs#cloneDeep"><code>cloneDeep()</code></a> – which has fewer limitations.</p>
<h4 id="sources-of-this-section-1"><a class="heading-id-link" href="#sources-of-this-section-1">30.5.6 Sources of this section</a></h4>
<ul>
  <li>
    <a href="https://html.spec.whatwg.org/#safe-passing-of-structured-data">Section “Safe passing of structured data”</a> in the WHATWG HTML standard
  </li>
  <li>
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm">“The structured clone algorithm”</a> on MDN
  </li>
  <li>
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/structuredClone">“<code>structuredClone()</code>”</a> on MDN
  </li>
</ul>
<h3 id="methods-and-this"><a class="heading-id-link" href="#methods-and-this">30.6 Methods and the special variable <code>this</code></a></h3>
<p><span id="index-entry-method"/></p>
<h4 id="methods-are-properties-whose-values-are-functions"><a class="heading-id-link" href="#methods-are-properties-whose-values-are-functions">30.6.1 Methods are properties whose values are functions</a></h4>
<p>Let’s revisit the example that was used to introduce methods:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> jane = {</code>
<code>  <span class="hljs-attr">first</span>: <span class="hljs-string">'Jane'</span>,</code>
<code>  <span class="hljs-title function_">says</span>(<span class="hljs-params">text</span>) {</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.first}</span> says “<span class="hljs-subst">${text}</span>”`</span>;</code>
<code>  },</code>
<code>};</code>
</pre>
<p>Somewhat surprisingly, methods are functions:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-keyword">typeof</span> jane.<span class="hljs-property">says</span>, <span class="hljs-string">'function'</span>);</code>
</pre>
<p>Why is that? We learned <a href="ch_callables.html#roles-of-ordinary-functions">in the chapter on callable values</a> that ordinary functions play several roles. <em>Method</em> is one of those roles. Therefore, internally, <code>jane</code> roughly looks as follows.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> jane = {</code>
<code>  <span class="hljs-attr">first</span>: <span class="hljs-string">'Jane'</span>,</code>
<code>  <span class="hljs-attr">says</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) {</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.first}</span> says “<span class="hljs-subst">${text}</span>”`</span>;</code>
<code>  },</code>
<code>};</code>
</pre>
<h4 id="the-special-variable-this"><a class="heading-id-link" href="#the-special-variable-this">30.6.2 The special variable <code>this</code></a></h4>
<p><span id="index-entry-receiver"/><span id="index-entry-this"/></p>
<p>Consider the following code:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  <span class="hljs-title function_">someMethod</span>(<span class="hljs-params">x, y</span>) {</code>
<code>    assert.<span class="hljs-title function_">equal</span>(<span class="hljs-variable language_">this</span>, obj); <span class="hljs-comment">// (A)</span></code>
<code>    assert.<span class="hljs-title function_">equal</span>(x, <span class="hljs-string">'a'</span>);</code>
<code>    assert.<span class="hljs-title function_">equal</span>(y, <span class="hljs-string">'b'</span>);</code>
<code>  }</code>
<code>};</code>
<code>obj.<span class="hljs-title function_">someMethod</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>); <span class="hljs-comment">// (B)</span></code>
</pre>
<p>In line B, <code>obj</code> is the <em>receiver</em> of a method call. It is passed to the function stored in <code>obj.someMethod</code> via an implicit (hidden) parameter whose name is <code>this</code> (line A).</p>
<div class="boxout">
  <p><img src="../Images/8440b17bb8219cda9f9405ac83c36db0.png" class="boxout-icon" height="24" alt="Icon “tip”" data-original-src="https://exploringjs.com/js/book/icon/tip.svg"/> <strong>How to understand <code>this</code></strong></p>
  <div class="boxout-vspace"/>
  <p>The best way to understand <code>this</code> is as an implicit parameter of ordinary functions and methods.</p>
</div>
<h4 id="methods-call"><a class="heading-id-link" href="#methods-call">30.6.3 Methods and <code>.call()</code></a></h4>
<p>Methods are functions and functions have methods themselves. One of those methods is <a href="ch_callables.html#Function.prototype.call"><code>.call()</code></a>. Let’s look at an example to understand how this method works.</p>
<p>In the previous section, there was this method invocation:</p>
<pre class="language-js">
<code>obj.<span class="hljs-title function_">someMethod</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>)</code>
</pre>
<p>This invocation is equivalent to:</p>
<pre class="language-js">
<code>obj.<span class="hljs-property">someMethod</span>.<span class="hljs-title function_">call</span>(obj, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>);</code>
</pre>
<p>Which is also equivalent to:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> func = obj.<span class="hljs-property">someMethod</span>;</code>
<code>func.<span class="hljs-title function_">call</span>(obj, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>);</code>
</pre>
<p><code>.call()</code> makes the normally implicit parameter <code>this</code> explicit: When invoking a function via <code>.call()</code>, the first parameter is <code>this</code>, followed by the regular (explicit) function parameters.</p>
<p>As an aside, this means that there are actually two different dot operators:</p>
<ol>
  <li>
    One for accessing properties: <code>obj.prop</code>
  </li>
  <li>
    Another one for calling methods: <code>obj.prop()</code>
  </li>
</ol>
<p>They are different in that (2) is not just (1) followed by the function call operator <code>()</code>. Instead, (2) additionally provides a value for <code>this</code>.</p>
<h4 id="methods-bind"><a class="heading-id-link" href="#methods-bind">30.6.4 Methods and <code>.bind()</code></a></h4>
<p><a href="ch_callables.html#Function.prototype.bind"><code>.bind()</code></a> is another method of function objects. In the following code, we use <code>.bind()</code> to turn method <code>.says()</code> into the stand-alone function <code>func()</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> jane = {</code>
<code>  <span class="hljs-attr">first</span>: <span class="hljs-string">'Jane'</span>,</code>
<code>  <span class="hljs-title function_">says</span>(<span class="hljs-params">text</span>) {</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.first}</span> says “<span class="hljs-subst">${text}</span>”`</span>; <span class="hljs-comment">// (A)</span></code>
<code>  },</code>
<code>};</code>
<code/>
<code><span class="hljs-keyword">const</span> func = jane.<span class="hljs-property">says</span>.<span class="hljs-title function_">bind</span>(jane, <span class="hljs-string">'hello'</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">func</span>(), <span class="hljs-string">'Jane says “hello”'</span>);</code>
</pre>
<p>Setting <code>this</code> to <code>jane</code> via <code>.bind()</code> is crucial here. Otherwise, <code>func()</code> wouldn’t work properly because <code>this</code> is used in line A. In the next section, we’ll explore why that is.</p>
<h4 id="extracting-methods"><a class="heading-id-link" href="#extracting-methods">30.6.5 <code>this</code> pitfall: extracting methods</a></h4>
<p><span id="index-entry-extracting-a-method"/><span id="index-entry-method--extracting-a"/></p>
<p>We now know quite a bit about functions and methods and are ready to take a look at the biggest pitfall involving methods and <code>this</code>: function-calling a method extracted from an object can fail if we are not careful.</p>
<p>In the following example, we fail when we extract method <code>jane.says()</code>, store it in the variable <code>func</code>, and function-call <code>func</code>.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> jane = {</code>
<code>  <span class="hljs-attr">first</span>: <span class="hljs-string">'Jane'</span>,</code>
<code>  <span class="hljs-title function_">says</span>(<span class="hljs-params">text</span>) {</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.first}</span> says “<span class="hljs-subst">${text}</span>”`</span>;</code>
<code>  },</code>
<code>};</code>
<code><span class="hljs-keyword">const</span> func = jane.<span class="hljs-property">says</span>; <span class="hljs-comment">// extract the method</span></code>
<code>assert.<span class="hljs-title function_">throws</span>(</code>
<code>  <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">func</span>(<span class="hljs-string">'hello'</span>), <span class="hljs-comment">// (A)</span></code>
<code>  {</code>
<code>    <span class="hljs-attr">name</span>: <span class="hljs-string">'TypeError'</span>,</code>
<code>    <span class="hljs-attr">message</span>: <span class="hljs-string">"Cannot read properties of undefined (reading 'first')"</span>,</code>
<code>  }</code>
<code>);</code>
</pre>
<p>In line A, we are making a normal function call. And in normal function calls, <code>this</code> is <code>undefined</code> (if <a href="ch_syntax.html#strict-mode">strict mode</a> is active, which it almost always is). Line A is therefore equivalent to:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">throws</span>(</code>
<code>  <span class="hljs-function">() =&gt;</span> jane.<span class="hljs-property">says</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-string">'hello'</span>), <span class="hljs-comment">// `this` is undefined!</span></code>
<code>  {</code>
<code>    <span class="hljs-attr">name</span>: <span class="hljs-string">'TypeError'</span>,</code>
<code>    <span class="hljs-attr">message</span>: <span class="hljs-string">"Cannot read properties of undefined (reading 'first')"</span>,</code>
<code>  }</code>
<code>);</code>
</pre>
<p>How do we fix this? We need to use <code>.bind()</code> to extract method <code>.says()</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> func2 = jane.<span class="hljs-property">says</span>.<span class="hljs-title function_">bind</span>(jane);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">func2</span>(<span class="hljs-string">'hello'</span>), <span class="hljs-string">'Jane says “hello”'</span>);</code>
</pre>
<p>The <code>.bind()</code> ensures that <code>this</code> is always <code>jane</code> when we call <code>func()</code>.</p>
<p>We can also use arrow functions to extract methods:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> <span class="hljs-title function_">func3</span> = text =&gt; jane.<span class="hljs-title function_">says</span>(text);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">func3</span>(<span class="hljs-string">'hello'</span>), <span class="hljs-string">'Jane says “hello”'</span>);</code>
</pre>
<h5 id="example-extracting-a-method"><a class="heading-id-link" href="#example-extracting-a-method">30.6.5.1 Example: extracting a method</a></h5>
<p>The following is a simplified version of code that we may see in actual web development:</p>
<pre class="language-js">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClickHandler</span> {</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">id, elem</span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id;</code>
<code>    elem.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>); <span class="hljs-comment">// (A)</span></code>
<code>  }</code>
<code>  <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">event</span>) {</code>
<code>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">'Clicked '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>);</code>
<code>  }</code>
<code>}</code>
</pre>
<p>In line A, we don’t extract the method <code>.handleClick()</code> properly. Instead, we should do:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> listener = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);</code>
<code>elem.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, listener);</code>
<code/>
<code><span class="hljs-comment">// Later, possibly:</span></code>
<code>elem.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'click'</span>, listener);</code>
</pre>
<p>Each invocation of <code>.bind()</code> creates a new function. That’s why we need to store the result somewhere if we want to remove it later on.</p>
<h5 id="how-to-avoid-the-pitfall-of-extracting-methods"><a class="heading-id-link" href="#how-to-avoid-the-pitfall-of-extracting-methods">30.6.5.2 How to avoid the pitfall of extracting methods</a></h5>
<p>Alas, there is no simple way around the pitfall of extracting methods: Whenever we extract a method, we have to be careful and do it properly – for example, by binding <code>this</code> or by using an arrow function.</p>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Extracting a method</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/objects/method_extraction_exrc.mjs</code></p>
</div>
<h4 id="shadowing-this"><a class="heading-id-link" href="#shadowing-this">30.6.6 <code>this</code> pitfall: accidentally shadowing <code>this</code></a></h4>
<div class="boxout">
  <p><img src="../Images/8440b17bb8219cda9f9405ac83c36db0.png" class="boxout-icon" height="24" alt="Icon “tip”" data-original-src="https://exploringjs.com/js/book/icon/tip.svg"/> <strong>Accidentally shadowing <code>this</code> is only an issue with ordinary functions</strong></p>
  <div class="boxout-vspace"/>
  <p>Arrow functions don’t shadow <code>this</code>.</p>
</div>
<p>Consider the following problem: when we are inside an ordinary function, we can’t access the <code>this</code> of the surrounding scope because the ordinary function has its own <code>this</code>. In other words, a variable in an inner scope hides a variable in an outer scope. That is called <a href="ch_variables-assignment.html#shadowing-variables"><em>shadowing</em></a>. The following code is an example:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> prefixer = {</code>
<code>  <span class="hljs-attr">prefix</span>: <span class="hljs-string">'==&gt; '</span>,</code>
<code>  <span class="hljs-title function_">prefixStringArray</span>(<span class="hljs-params">stringArray</span>) {</code>
<code>    <span class="hljs-keyword">return</span> stringArray.<span class="hljs-title function_">map</span>(</code>
<code>      <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) {</code>
<code>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">prefix</span> + x; <span class="hljs-comment">// (A)</span></code>
<code>      });</code>
<code>  },</code>
<code>};</code>
<code>assert.<span class="hljs-title function_">throws</span>(</code>
<code>  <span class="hljs-function">() =&gt;</span> prefixer.<span class="hljs-title function_">prefixStringArray</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]),</code>
<code>  {</code>
<code>    <span class="hljs-attr">name</span>: <span class="hljs-string">'TypeError'</span>,</code>
<code>    <span class="hljs-attr">message</span>: <span class="hljs-string">"Cannot read properties of undefined (reading 'prefix')"</span>,</code>
<code>  }</code>
<code>);</code>
</pre>
<p>In line A, we want to access the <code>this</code> of <code>.prefixStringArray()</code>. But we can’t since the surrounding ordinary function has its own <code>this</code> that <em>shadows</em> (and blocks access to) the <code>this</code> of the method. The value of the former <code>this</code> is <code>undefined</code> due to the callback being function-called. That explains the error message.</p>
<p>The simplest way to fix this problem is via an arrow function, which doesn’t have its own <code>this</code> and therefore doesn’t shadow anything:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> prefixer = {</code>
<code>  <span class="hljs-attr">prefix</span>: <span class="hljs-string">'==&gt; '</span>,</code>
<code>  <span class="hljs-title function_">prefixStringArray</span>(<span class="hljs-params">stringArray</span>) {</code>
<code>    <span class="hljs-keyword">return</span> stringArray.<span class="hljs-title function_">map</span>(</code>
<code>      <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> {</code>
<code>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">prefix</span> + x;</code>
<code>      });</code>
<code>  },</code>
<code>};</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  prefixer.<span class="hljs-title function_">prefixStringArray</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]),</code>
<code>  [<span class="hljs-string">'==&gt; a'</span>, <span class="hljs-string">'==&gt; b'</span>]);</code>
</pre>
<p>We can also store <code>this</code> in a different variable (line A), so that it doesn’t get shadowed:</p>
<pre class="language-js">
<code><span class="hljs-title function_">prefixStringArray</span>(<span class="hljs-params">stringArray</span>) {</code>
<code>  <span class="hljs-keyword">const</span> that = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// (A)</span></code>
<code>  <span class="hljs-keyword">return</span> stringArray.<span class="hljs-title function_">map</span>(</code>
<code>    <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) {</code>
<code>      <span class="hljs-keyword">return</span> that.<span class="hljs-property">prefix</span> + x;</code>
<code>    });</code>
<code>},</code>
</pre>
<p>Another option is to specify a fixed <code>this</code> for the callback via <code>.bind()</code> (line A):</p>
<pre class="language-js">
<code><span class="hljs-title function_">prefixStringArray</span>(<span class="hljs-params">stringArray</span>) {</code>
<code>  <span class="hljs-keyword">return</span> stringArray.<span class="hljs-title function_">map</span>(</code>
<code>    <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) {</code>
<code>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">prefix</span> + x;</code>
<code>    }.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)); <span class="hljs-comment">// (A)</span></code>
<code>},</code>
</pre>
<p>Lastly, <code>.map()</code> lets us specify a value for <code>this</code> (line A) that it uses when invoking the callback:</p>
<pre class="language-js">
<code><span class="hljs-title function_">prefixStringArray</span>(<span class="hljs-params">stringArray</span>) {</code>
<code>  <span class="hljs-keyword">return</span> stringArray.<span class="hljs-title function_">map</span>(</code>
<code>    <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) {</code>
<code>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">prefix</span> + x;</code>
<code>    },</code>
<code>    <span class="hljs-variable language_">this</span>); <span class="hljs-comment">// (A)</span></code>
<code>},</code>
</pre>
<h5 id="avoiding-the-pitfall-of-accidentally-shadowing-this"><a class="heading-id-link" href="#avoiding-the-pitfall-of-accidentally-shadowing-this">30.6.6.1 Avoiding the pitfall of accidentally shadowing <code>this</code></a></h5>
<p>If we follow the advice in <a href="ch_callables.html#prefer-specialized-functions">“Recommendation: prefer specialized functions over ordinary functions” (§27.3.4)</a>, we can avoid the pitfall of accidentally shadowing <code>this</code>. This is a summary:</p>
<ul>
  <li>
    <p>Use arrow functions as anonymous inline functions. They don’t have <code>this</code> as an implicit parameter and don’t shadow it.</p>
  </li>
  <li>
    <p>For named stand-alone function declarations we can either use arrow functions or function declarations. If we do the latter, we have to make sure <code>this</code> isn’t mentioned in their bodies.</p>
  </li>
</ul>
<h4 id="the-value-of-this-in-various-contexts-advanced"><a class="heading-id-link" href="#the-value-of-this-in-various-contexts-advanced">30.6.7 The value of <code>this</code> in various contexts<span> (advanced)</span></a></h4>
<p><span id="index-entry-this--values-of"/></p>
<p>What is the value of <code>this</code> in various contexts?</p>
<p>Inside a callable entity, the value of <code>this</code> depends on how the callable entity is invoked and what kind of callable entity it is:</p>
<ul>
  <li>
    Function call:
    <ul>
      <li>
        Ordinary functions: <code>this === undefined</code> (in <a href="ch_syntax.html#strict-mode">strict mode</a>)
      </li>
      <li>
        Arrow functions: <code>this</code> is same as in surrounding scope (lexical <code>this</code>)
      </li>
    </ul>
  </li>
  <li>
    Method call: <code>this</code> is receiver of call
  </li>
  <li>
    <code>new</code>: <code>this</code> refers to the newly created instance
  </li>
</ul>
<p>We can also access <code>this</code> in all common top-level scopes:</p>
<ul>
  <li>
    <code>&lt;script&gt;</code> element: <code>this === globalThis</code>
  </li>
  <li>
    ECMAScript modules: <code>this === undefined</code>
  </li>
  <li>
    CommonJS modules: <code>this === module.exports</code>
  </li>
</ul>
<div class="boxout">
  <p><img src="../Images/8440b17bb8219cda9f9405ac83c36db0.png" class="boxout-icon" height="24" alt="Icon “tip”" data-original-src="https://exploringjs.com/js/book/icon/tip.svg"/> <strong>Tip: pretend that <code>this</code> doesn’t exist in top-level scopes</strong></p>
  <div class="boxout-vspace"/>
  <p>I like to do that because top-level <code>this</code> is confusing and there are better alternatives for its (few) use cases.</p>
</div>
<h3 id="optional-chaining"><a class="heading-id-link" href="#optional-chaining">30.7 Optional chaining for property getting and method calls<span> <sup>ES2020</sup> (advanced)</span></a></h3>
<p><span id="index-entry-optional-chaining---.-"/>
<span id="index-entry--.p"/>
<span id="index-entry--.-"/>
<span id="index-entry--.-2"/></p>
<p>The following kinds of optional chaining operations exist:</p>
<pre class="language-js">
<code>obj?.<span class="hljs-property">prop</span>     <span class="hljs-comment">// optional fixed property getting</span></code>
<code>obj?.[«expr»] <span class="hljs-comment">// optional dynamic property getting</span></code>
<code>func?.(«arg0», «arg1», ···) <span class="hljs-comment">// optional function or method call</span></code>
</pre>
<p>The rough idea is:</p>
<ul>
  <li>
    If the value before the question mark is neither <code>undefined</code> nor <code>null</code>, then perform the operation after the question mark.
  </li>
  <li>
    Otherwise, return <code>undefined</code>.
  </li>
</ul>
<p>Each of the three syntaxes is covered in more detail later. These are a few first examples:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">null</span>?.<span class="hljs-property">prop</span></span></code>
<code>undefined</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">{<span class="hljs-attr">prop</span>: <span class="hljs-number">1</span>}?.<span class="hljs-property">prop</span></span></code>
<code>1</code>
<code/>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">null</span>?.(<span class="hljs-number">123</span>)</span></code>
<code>undefined</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">String</span>?.(<span class="hljs-number">123</span>)</span></code>
<code>'123'</code>
</pre>
<div class="boxout">
  <p><img src="../Images/8440b17bb8219cda9f9405ac83c36db0.png" class="boxout-icon" height="24" alt="Icon “tip”" data-original-src="https://exploringjs.com/js/book/icon/tip.svg"/> <strong>Mnemonic for the optional chaining operator (<code>?.</code>)</strong></p>
  <div class="boxout-vspace"/>
  <p>Are you occasionally unsure if the optional chaining operator starts with a dot (<code>.?</code>) or a question mark (<code>?.</code>)? Then this mnemonic may help you:</p>
  <ul>
    <li>
      <strong>If</strong> (<code>?</code>) the left-hand side is not nullish
    </li>
    <li>
      <strong>then</strong> (<code>.</code>) access a property.
    </li>
  </ul>
</div>
<h4 id="example-optional-fixed-property-getting"><a class="heading-id-link" href="#example-optional-fixed-property-getting">30.7.1 Example: optional fixed property getting</a></h4>
<p>Consider the following data:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> persons = [</code>
<code>  {</code>
<code>    <span class="hljs-attr">surname</span>: <span class="hljs-string">'Zoe'</span>,</code>
<code>    <span class="hljs-attr">address</span>: {</code>
<code>      <span class="hljs-attr">street</span>: {</code>
<code>        <span class="hljs-attr">name</span>: <span class="hljs-string">'Sesame Street'</span>,</code>
<code>        <span class="hljs-attr">number</span>: <span class="hljs-string">'123'</span>,</code>
<code>      },</code>
<code>    },</code>
<code>  },</code>
<code>  {</code>
<code>    <span class="hljs-attr">surname</span>: <span class="hljs-string">'Mariner'</span>,</code>
<code>  },</code>
<code>  {</code>
<code>    <span class="hljs-attr">surname</span>: <span class="hljs-string">'Carmen'</span>,</code>
<code>    <span class="hljs-attr">address</span>: {</code>
<code>    },</code>
<code>  },</code>
<code>];</code>
</pre>
<p>We can use optional chaining to safely extract street names:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> streetNames = persons.<span class="hljs-title function_">map</span>(</code>
<code>  <span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> p.<span class="hljs-property">address</span>?.<span class="hljs-property">street</span>?.<span class="hljs-property">name</span>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  streetNames, [<span class="hljs-string">'Sesame Street'</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>]</code>
<code>);</code>
</pre>
<h5 id="handling-defaults-via-nullish-coalescing"><a class="heading-id-link" href="#handling-defaults-via-nullish-coalescing">30.7.1.1 Handling defaults via nullish coalescing</a></h5>
<p>The <a href="ch_undefined-null.html#nullish-coalescing-operator">nullish coalescing operator</a> allows us to use the default value <code>'(no name)'</code> instead of <code>undefined</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> streetNames = persons.<span class="hljs-title function_">map</span>(</code>
<code>  <span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> p.<span class="hljs-property">address</span>?.<span class="hljs-property">street</span>?.<span class="hljs-property">name</span> ?? <span class="hljs-string">'(no name)'</span>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  streetNames, [<span class="hljs-string">'Sesame Street'</span>, <span class="hljs-string">'(no name)'</span>, <span class="hljs-string">'(no name)'</span>]</code>
<code>);</code>
</pre>
<h4 id="the-operators-in-more-detail-advanced"><a class="heading-id-link" href="#the-operators-in-more-detail-advanced">30.7.2 The operators in more detail<span> (advanced)</span></a></h4>
<h5 id="optional-fixed-property-getting"><a class="heading-id-link" href="#optional-fixed-property-getting">30.7.2.1 Optional fixed property getting</a></h5>
<p>The following two expressions are equivalent:</p>
<pre class="language-js">
<code>o?.<span class="hljs-property">prop</span></code>
<code>(o !== <span class="hljs-literal">undefined</span> &amp;&amp; o !== <span class="hljs-literal">null</span>) ? o.<span class="hljs-property">prop</span> : <span class="hljs-literal">undefined</span></code>
</pre>
<p>Examples:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-literal">undefined</span>?.<span class="hljs-property">prop</span>, <span class="hljs-literal">undefined</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-literal">null</span>?.<span class="hljs-property">prop</span>,      <span class="hljs-literal">undefined</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>({<span class="hljs-attr">prop</span>:<span class="hljs-number">1</span>}?.<span class="hljs-property">prop</span>,  <span class="hljs-number">1</span>);</code>
</pre>
<h5 id="optional-dynamic-property-getting"><a class="heading-id-link" href="#optional-dynamic-property-getting">30.7.2.2 Optional dynamic property getting</a></h5>
<p>The following two expressions are equivalent:</p>
<pre class="language-js">
<code>o?.[«expr»]</code>
<code>(o !== <span class="hljs-literal">undefined</span> &amp;&amp; o !== <span class="hljs-literal">null</span>) ? o[«expr»] : <span class="hljs-literal">undefined</span></code>
</pre>
<p>Examples:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> key = <span class="hljs-string">'prop'</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-literal">undefined</span>?.[key], <span class="hljs-literal">undefined</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-literal">null</span>?.[key], <span class="hljs-literal">undefined</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>({<span class="hljs-attr">prop</span>:<span class="hljs-number">1</span>}?.[key], <span class="hljs-number">1</span>);</code>
</pre>
<h5 id="optional-function-or-method-call"><a class="heading-id-link" href="#optional-function-or-method-call">30.7.2.3 Optional function or method call</a></h5>
<p>The following two expressions are equivalent:</p>
<pre class="language-js">
<code>f?.(arg0, arg1)</code>
<code>(f !== <span class="hljs-literal">undefined</span> &amp;&amp; f !== <span class="hljs-literal">null</span>) ? <span class="hljs-title function_">f</span>(arg0, arg1) : <span class="hljs-literal">undefined</span></code>
</pre>
<p>Examples:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-literal">undefined</span>?.(<span class="hljs-number">123</span>), <span class="hljs-literal">undefined</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-literal">null</span>?.(<span class="hljs-number">123</span>), <span class="hljs-literal">undefined</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">String</span>?.(<span class="hljs-number">123</span>), <span class="hljs-string">'123'</span>);</code>
</pre>
<p>Note that this operator produces an error if its left-hand side is not callable:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">throws</span>(</code>
<code>  <span class="hljs-function">() =&gt;</span> <span class="hljs-literal">true</span>?.(<span class="hljs-number">123</span>),</code>
<code>  <span class="hljs-title class_">TypeError</span>);</code>
</pre>
<p>Why? The idea is that the operator only tolerates deliberate omissions. An uncallable value (other than <code>undefined</code> and <code>null</code>) is probably an error and should be reported, rather than worked around.</p>
<h4 id="shortcircuiting-with-optional-property-getting"><a class="heading-id-link" href="#shortcircuiting-with-optional-property-getting">30.7.3 Short-circuiting with optional property getting</a></h4>
<p>In a chain of property gettings and method invocations, evaluation stops once the first optional operator encounters <code>undefined</code> or <code>null</code> at its left-hand side:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">invokeM</span>(<span class="hljs-params">value</span>) {</code>
<code>  <span class="hljs-keyword">return</span> value?.<span class="hljs-property">a</span>.<span class="hljs-property">b</span>.<span class="hljs-title function_">m</span>(); <span class="hljs-comment">// (A)</span></code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  <span class="hljs-attr">a</span>: {</code>
<code>    <span class="hljs-attr">b</span>: {</code>
<code>      <span class="hljs-title function_">m</span>(<span class="hljs-params">) { <span class="hljs-keyword">return</span> <span class="hljs-string">'result'</span> }</span></code>
<code><span class="hljs-params">    }</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">};</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-title function_">invokeM</span>(obj), <span class="hljs-string">'result'</span></span></code>
<code><span class="hljs-params">);</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-title function_">invokeM</span>(<span class="hljs-literal">undefined</span>), <span class="hljs-literal">undefined</span> <span class="hljs-comment">// (B)</span></span></code>
<code><span class="hljs-params">);</span></code>
</pre>
<p>Consider <code>invokeM(undefined)</code> in line B: <code>undefined?.a</code> is <code>undefined</code>. Therefore we’d expect <code>.b</code> to fail in line A. But it doesn’t: The <code>?.</code> operator encounters the value <code>undefined</code> and the evaluation of the whole expression immediately returns <code>undefined</code>.</p>
<p>This behavior differs from a normal operator where JavaScript always evaluates all operands before evaluating the operator. It is called <em>short-circuiting</em>. Other short-circuiting operators are:</p>
<ul>
  <li>
    <code>(a &amp;&amp; b)</code>: <code>b</code> is only evaluated if <code>a</code> is truthy.
  </li>
  <li>
    <code>(a || b)</code>: <code>b</code> is only evaluated if <code>a</code> is falsy.
  </li>
  <li>
    <code>(c ? t : e)</code>: If <code>c</code> is truthy, <code>t</code> is evaluated. Otherwise, <code>e</code> is evaluated.
  </li>
</ul>
<h4 id="optional-chaining-downsides-and-alternatives"><a class="heading-id-link" href="#optional-chaining-downsides-and-alternatives">30.7.4 Optional chaining: downsides and alternatives</a></h4>
<p>Optional chaining also has downsides:</p>
<ul>
  <li>
    Deeply nested structures are more difficult to manage. For example, refactoring is harder if there are many sequences of property names: Each one enforces the structure of multiple objects.
  </li>
  <li>
    Being so forgiving when accessing data hides problems that will surface much later and are then harder to debug. For example, a typo early in a sequence of optional property names has more negative effects than a normal typo.
  </li>
</ul>
<p>An alternative to optional chaining is to extract the information once, in a single location:</p>
<ul>
  <li>
    We can either write a helper function that extracts the data.
  </li>
  <li>
    Or we can write a function whose input is deeply nested data and whose output is simpler, normalized data.
  </li>
</ul>
<p>With either approach, it is possible to perform checks and to fail early if there are problems.</p>
<p>Further reading:</p>
<ul>
  <li>
    “<a href="https://blog.vcarl.com/overly-defensive-programming/">Overly defensive programming</a>” by Carl Vitullo
  </li>
</ul>
<h4 id="frequently-asked-questions"><a class="heading-id-link" href="#frequently-asked-questions">30.7.5 Frequently asked questions</a></h4>
<h5 id="why-are-there-dots-in-ox-and-f"><a class="heading-id-link" href="#why-are-there-dots-in-ox-and-f">30.7.5.1 Why are there dots in <code>o?.[x]</code> and <code>f?.()</code>?</a></h5>
<p>The syntaxes of the following two optional operator are not ideal:</p>
<pre class="language-js">
<code>obj?.[«expr»]          <span class="hljs-comment">// better: obj?[«expr»]</span></code>
<code>func?.(«arg0», «arg1») <span class="hljs-comment">// better: func?(«arg0», «arg1»)</span></code>
</pre>
<p>Alas, the less elegant syntax is necessary because distinguishing the ideal syntax (first expression) from the conditional operator (second expression) is too complicated:</p>
<pre class="language-js">
<code>obj?[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x+x)</code>
<code>obj ? [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x+x) : []</code>
</pre>
<h5 id="why-does-nullprop-evaluate-to-undefined-and-not-null"><a class="heading-id-link" href="#why-does-nullprop-evaluate-to-undefined-and-not-null">30.7.5.2 Why does <code>null?.prop</code> evaluate to <code>undefined</code> and not <code>null</code>?</a></h5>
<p>The operator <code>?.</code> is mainly about its right-hand side: Does property <code>.prop</code> exist? If not, stop early. Therefore, keeping information about its left-hand side is rarely useful. However, only having a single “early termination” value does simplify things.</p>
<h3 id="prototype-chains"><a class="heading-id-link" href="#prototype-chains">30.8 Prototype chains</a></h3>
<p><span id="index-entry-prototype"/>
<span id="index-entry-prototype-chain"/>
<span id="index-entry-__proto__"/>
<span id="index-entry-proto"/></p>
<p>Prototypes are JavaScript’s only inheritance mechanism: Each object has a prototype that is either <code>null</code> or an object. In the latter case, the object inherits all of the prototype’s properties.</p>
<p>In an object literal, we can set the prototype via the special property <code>__proto__</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> proto = {</code>
<code>  <span class="hljs-attr">protoProp</span>: <span class="hljs-string">'a'</span>,</code>
<code>};</code>
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  <span class="hljs-attr">__proto__</span>: proto,</code>
<code>  <span class="hljs-attr">objProp</span>: <span class="hljs-string">'b'</span>,</code>
<code>};</code>
<code/>
<code><span class="hljs-comment">// obj inherits .protoProp:</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(obj.<span class="hljs-property">protoProp</span>, <span class="hljs-string">'a'</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-string">'protoProp'</span> <span class="hljs-keyword">in</span> obj, <span class="hljs-literal">true</span>);</code>
</pre>
<p>Given that a prototype object can have a prototype itself, we get a chain of objects – the so-called <em>prototype chain</em>. Inheritance gives us the impression that we are dealing with single objects, but we are actually dealing with chains of objects.</p>
<p><a href="#fig:oo_proto_chain">Figure 30.2</a> shows what the prototype chain of <code>obj</code> looks like.</p>
<figure id="fig:oo_proto_chain" class="float">
  <p><img src="../Images/3f6a70b31e906acd64d926d104282b8f.png" width="114" alt="" style="height:190.69982px" data-original-src="https://exploringjs.com/js/book/img/objects/oo_proto_chain.svg"/></p>
  <figcaption>
    <p><span class="float-label">Figure 30.2:</span> <code>obj</code> starts a chain of objects that continues with <code>proto</code> and other objects.</p>
  </figcaption>
</figure>
<p>Non-inherited properties are called <em>own properties</em>. <code>obj</code> has one own property, <code>.objProp</code>.</p>
<h4 id="javascripts-operations-all-properties-vs-own-properties"><a class="heading-id-link" href="#javascripts-operations-all-properties-vs-own-properties">30.8.1 JavaScript’s operations: all properties vs. own properties</a></h4>
<p>Some operations consider all properties (own and inherited) – for example, getting properties:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">one</span>: <span class="hljs-number">1</span> };</span></code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">typeof</span> obj.<span class="hljs-property">one</span> <span class="hljs-comment">// own</span></span></code>
<code>'number'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">typeof</span> obj.<span class="hljs-property">toString</span> <span class="hljs-comment">// inherited</span></span></code>
<code>'function'</code>
</pre>
<p>Other operations only consider own properties – for example, <code>Object.keys()</code>:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)</span></code>
<code>[ 'one' ]</code>
</pre>
<p>Read on for another operation that also only considers own properties: setting properties.</p>
<h4 id="pitfall-only-the-first-member-of-a-prototype-chain-is-mutated"><a class="heading-id-link" href="#pitfall-only-the-first-member-of-a-prototype-chain-is-mutated">30.8.2 Pitfall: only the first member of a prototype chain is mutated</a></h4>
<p>Given an object <code>obj</code> with a chain of prototype objects, it makes sense that setting an own property of <code>obj</code> only changes <code>obj</code>. However, setting an inherited property via <code>obj</code> also only changes <code>obj</code>. It creates a new own property in <code>obj</code> that overrides the inherited property. Let’s explore how that works with the following object:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> proto = {</code>
<code>  <span class="hljs-attr">protoProp</span>: <span class="hljs-string">'a'</span>,</code>
<code>};</code>
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  <span class="hljs-attr">__proto__</span>: proto,</code>
<code>};</code>
</pre>
<p><span id="index-entry-overriding-a-property"/></p>
<p>In the next code snippet, we set the inherited property <code>obj.protoProp</code> (line A). That “changes” it by creating an own property: When reading <code>obj.protoProp</code>, the own property is found first and its value <em>overrides</em> the value of the inherited property.</p>
<pre class="language-js">
<code><span class="hljs-comment">// In the beginning, obj has no own properties</span></code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj), []);</code>
<code/>
<code>obj.<span class="hljs-property">protoProp</span> = <span class="hljs-string">'x'</span>; <span class="hljs-comment">// (A)</span></code>
<code/>
<code><span class="hljs-comment">// We created an own property:</span></code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj), [<span class="hljs-string">'protoProp'</span>]);</code>
<code/>
<code><span class="hljs-comment">// The inherited property itself is unchanged:</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(proto.<span class="hljs-property">protoProp</span>, <span class="hljs-string">'a'</span>);</code>
<code/>
<code><span class="hljs-comment">// The own property overrides the inherited property:</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(obj.<span class="hljs-property">protoProp</span>, <span class="hljs-string">'x'</span>);</code>
</pre>
<p>The prototype chain of <code>obj</code> is depicted in <a href="#fig:oo_overriding">figure 30.3</a>.</p>
<figure id="fig:oo_overriding" class="float">
  <p><img src="../Images/a36ba2c417a363309e1b3616c9d7810b.png" width="114" alt="" style="height:211.69982px" data-original-src="https://exploringjs.com/js/book/img/objects/oo_overriding.svg"/></p>
  <figcaption>
    <p><span class="float-label">Figure 30.3:</span> The own property <code>.protoProp</code> of <code>obj</code> overrides the property inherited from <code>proto</code>.</p>
  </figcaption>
</figure>
<h4 id="tips-for-working-with-prototypes-advanced"><a class="heading-id-link" href="#tips-for-working-with-prototypes-advanced">30.8.3 Tips for working with prototypes<span> (advanced)</span></a></h4>
<h5 id="get-set-prototype"><a class="heading-id-link" href="#get-set-prototype">30.8.3.1 Getting and setting prototypes</a></h5>
<p>Recommendations for the property key <code>__proto__</code>:</p>
<ul>
  <li>
    <p>Don’t use the accessor <code>Object.prototype.__proto__</code> that all instances of <code>Object</code> have:</p>
    <ul>
      <li>
        It can’t be used with all objects – e.g., objects that are not instances of <code>Object</code> don’t have it.
      </li>
      <li>
        It is deprecated in the ECMAScript specification.
      </li>
    </ul>
    <p>For more information on this feature see <a href="ch_classes.html#Object.prototype.__proto__">“<code>Object.prototype.__proto__</code> (accessor)<span> <sup>ES6</sup></span>” (§31.9.7)</a>.</p>
  </li>
  <li>
    <p>Using the property key <code>__proto__</code> in an object literal to specify a prototype is different: It’s a feature that is particular to object literals that just happens to have the same name as the deprecated accessor.</p>
  </li>
</ul>
<p>The recommended ways of getting and setting prototypes are:</p>
<ul>
  <li>
    <p>Getting the prototype of an object:</p>
<pre class="language-ts">
<code><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-attr">obj</span>: <span class="hljs-built_in">object</span>): <span class="hljs-built_in">object</span></code>
</pre>
  </li>
  <li>
    <p>The best time to set the prototype of an object is when we are creating it. We can do so via <code>__proto__</code> in an object literal or via:</p>
<pre class="language-ts">
<code><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-attr">proto</span>: <span class="hljs-built_in">object</span>): <span class="hljs-built_in">object</span></code>
</pre>
  </li>
  <li>
    <p>If we have to, we can use <code>Object.setPrototypeOf()</code> to change the prototype of an existing object. But that may affect the performance of that object negatively.</p>
  </li>
</ul>
<p>This is how these features are used:</p>
<pre class="language-js">
<code><span class="hljs-comment">// Two objects with null prototypes</span></code>
<code><span class="hljs-keyword">const</span> obj1 = {<span class="hljs-attr">__proto__</span>: <span class="hljs-literal">null</span>};</code>
<code><span class="hljs-keyword">const</span> obj2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);</code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj1), <span class="hljs-literal">null</span></code>
<code>);</code>
<code/>
<code><span class="hljs-keyword">const</span> proto = {};</code>
<code><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(obj1, proto);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj1), proto</code>
<code>);</code>
</pre>
<h5 id="check-if-object-in-prototype-chain"><a class="heading-id-link" href="#check-if-object-in-prototype-chain">30.8.3.2 Checking if an object is in the prototype chain of another object</a></h5>
<p>So far, “<code>proto</code> is a prototype of <code>obj</code>” always meant “<code>proto</code> is a <em>direct</em> prototype of <code>obj</code>”. But it can also be used more loosely and mean that <code>proto</code> is in the prototype chain of <code>obj</code>. That looser relationship can be checked via <code>.isPrototypeOf()</code>:</p>
<p>For example:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> a = {};</code>
<code><span class="hljs-keyword">const</span> b = {<span class="hljs-attr">__proto__</span>: a};</code>
<code><span class="hljs-keyword">const</span> c = {<span class="hljs-attr">__proto__</span>: b};</code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(a.<span class="hljs-title function_">isPrototypeOf</span>(b), <span class="hljs-literal">true</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(a.<span class="hljs-title function_">isPrototypeOf</span>(c), <span class="hljs-literal">true</span>);</code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(c.<span class="hljs-title function_">isPrototypeOf</span>(a), <span class="hljs-literal">false</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(a.<span class="hljs-title function_">isPrototypeOf</span>(a), <span class="hljs-literal">false</span>);</code>
</pre>
<p>For more information on this method see <a href="ch_classes.html#Object.prototype.isPrototypeOf">“<code>Object.prototype.isPrototypeOf()</code><span> <sup>ES3</sup></span>” (§31.9.5)</a>.</p>
<h4 id="Object.hasOwn"><a class="heading-id-link" href="#Object.hasOwn">30.8.4 <code>Object.hasOwn()</code>: Is a given property own (non-inherited)?<span> <sup>ES2022</sup></span></a></h4>
<p>The <code>in</code> operator (line A) checks if an object has a given property. In contrast, <code>Object.hasOwn()</code> (lines B and C) checks if a property is own.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> proto = {</code>
<code>  <span class="hljs-attr">protoProp</span>: <span class="hljs-string">'protoProp'</span>,</code>
<code>};</code>
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  <span class="hljs-attr">__proto__</span>: proto,</code>
<code>  <span class="hljs-attr">objProp</span>: <span class="hljs-string">'objProp'</span>,</code>
<code>}</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-string">'protoProp'</span> <span class="hljs-keyword">in</span> obj, <span class="hljs-literal">true</span>); <span class="hljs-comment">// (A)</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(obj, <span class="hljs-string">'protoProp'</span>), <span class="hljs-literal">false</span>); <span class="hljs-comment">// (B)</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(proto, <span class="hljs-string">'protoProp'</span>), <span class="hljs-literal">true</span>); <span class="hljs-comment">// (C)</span></code>
</pre>
<div class="boxout">
  <p><img src="../Images/8440b17bb8219cda9f9405ac83c36db0.png" class="boxout-icon" height="24" alt="Icon “tip”" data-original-src="https://exploringjs.com/js/book/icon/tip.svg"/> <strong>Alternative before ES2022: <code>.hasOwnProperty()</code></strong></p>
  <div class="boxout-vspace"/>
  <p>Before ES2022, we can use another feature: <a href="ch_classes.html#Object.prototype.hasOwnProperty">“<code>Object.prototype.hasOwnProperty()</code><span> <sup>ES3</sup></span>” (§31.9.8)</a>. This feature has pitfalls, but the referenced section explains how to work around them.</p>
</div>
<h4 id="sharing-data-via-prototypes"><a class="heading-id-link" href="#sharing-data-via-prototypes">30.8.5 Sharing data via prototypes</a></h4>
<p>Consider the following code:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> jane = {</code>
<code>  <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Jane'</span>,</code>
<code>  <span class="hljs-title function_">describe</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">'Person named '</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span>;</span></code>
<code><span class="hljs-params">  },</span></code>
<code><span class="hljs-params">};</span></code>
<code><span class="hljs-params"><span class="hljs-keyword">const</span> tarzan = {</span></code>
<code><span class="hljs-params">  <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Tarzan'</span>,</span></code>
<code><span class="hljs-params">  <span class="hljs-title function_">describe</span>(<span class="hljs-params"/>) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">'Person named '</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span>;</span></code>
<code><span class="hljs-params">  },</span></code>
<code><span class="hljs-params">};</span></code>
<code/>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(jane.<span class="hljs-title function_">describe</span>(), <span class="hljs-string">'Person named Jane'</span>);</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(tarzan.<span class="hljs-title function_">describe</span>(), <span class="hljs-string">'Person named Tarzan'</span>);</span></code>
</pre>
<p>We have two objects that are very similar. Both have two properties whose names are <code>.firstName</code> and <code>.describe</code>. Additionally, method <code>.describe()</code> is the same. How can we avoid duplicating that method?</p>
<p>We can move it to an object <code>PersonProto</code> and make that object a prototype of both <code>jane</code> and <code>tarzan</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> <span class="hljs-title class_">PersonProto</span> = {</code>
<code>  <span class="hljs-title function_">describe</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">'Person named '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span>;</span></code>
<code><span class="hljs-params">  },</span></code>
<code><span class="hljs-params">};</span></code>
<code><span class="hljs-params"><span class="hljs-keyword">const</span> jane = {</span></code>
<code><span class="hljs-params">  <span class="hljs-attr">__proto__</span>: <span class="hljs-title class_">PersonProto</span>,</span></code>
<code><span class="hljs-params">  <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Jane'</span>,</span></code>
<code><span class="hljs-params">};</span></code>
<code><span class="hljs-params"><span class="hljs-keyword">const</span> tarzan = {</span></code>
<code><span class="hljs-params">  <span class="hljs-attr">__proto__</span>: <span class="hljs-title class_">PersonProto</span>,</span></code>
<code><span class="hljs-params">  <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Tarzan'</span>,</span></code>
<code><span class="hljs-params">};</span></code>
</pre>
<p>The name of the prototype reflects that both <code>jane</code> and <code>tarzan</code> are persons.</p>
<figure id="fig:oo_person_shared" class="float">
  <p><img src="../Images/54ca73b37654dc412734fbf20bbd28dd.png" alt="" style="width:313.5px; height:132.5px" data-original-src="https://exploringjs.com/js/book/img/objects/oo_person_shared.svg"/></p>
  <figcaption>
    <p><span class="float-label">Figure 30.4:</span> Objects <code>jane</code> and <code>tarzan</code> share method <code>.describe()</code>, via their common prototype <code>PersonProto</code>.</p>
  </figcaption>
</figure>
<p><a href="#fig:oo_person_shared">Figure 30.4</a> illustrates how the three objects are connected: The objects at the bottom now contain the properties that are specific to <code>jane</code> and <code>tarzan</code>. The object at the top contains the properties that are shared between them.</p>
<p>When we make the method call <code>jane.describe()</code>, <code>this</code> points to the receiver of that method call, <code>jane</code> (in the bottom-left corner of the diagram). That’s why the method still works. <code>tarzan.describe()</code> works similarly.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(jane.<span class="hljs-title function_">describe</span>(), <span class="hljs-string">'Person named Jane'</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(tarzan.<span class="hljs-title function_">describe</span>(), <span class="hljs-string">'Person named Tarzan'</span>);</code>
</pre>
<p>Looking ahead to the next chapter on classes – this is how classes are organized internally:</p>
<ul>
  <li>
    All instances share a common prototype with methods.
  </li>
  <li>
    Instance-specific data is stored in own properties in each instance.
  </li>
</ul>
<p><a href="ch_classes.html#internals-of-classes">“The internals of classes” (§31.3)</a> explains this in more detail.</p>
<h3 id="dictionary-objects"><a class="heading-id-link" href="#dictionary-objects">30.9 Dictionary objects<span> (advanced)</span></a></h3>
<p>Objects work best as fixed-layout objects. But before ES6, JavaScript did not have a data structure for dictionaries (ES6 brought <a href="ch_maps.html#ch_maps">Maps</a>). Therefore, objects had to be used as dictionaries, which imposed a signficant constraint: Dictionary keys had to be strings (symbols were also introduced with ES6).</p>
<p>We first look at features of objects that are related to dictionaries but also useful for fixed-layout objects. This section concludes with tips for actually using objects as dictionaries. (Spoiler: If possible, it’s better to use Maps.)</p>
<h4 id="object-literals-quoted-keys"><a class="heading-id-link" href="#object-literals-quoted-keys">30.9.1 Quoted keys in object literals</a></h4>
<p>So far, we have always used fixed-layout objects. Property keys were fixed tokens that had to be valid identifiers and internally became strings:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  <span class="hljs-attr">mustBeAnIdentifier</span>: <span class="hljs-number">123</span>,</code>
<code>};</code>
<code/>
<code><span class="hljs-comment">// Get property</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(obj.<span class="hljs-property">mustBeAnIdentifier</span>, <span class="hljs-number">123</span>);</code>
<code/>
<code><span class="hljs-comment">// Set property</span></code>
<code>obj.<span class="hljs-property">mustBeAnIdentifier</span> = <span class="hljs-string">'abc'</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(obj.<span class="hljs-property">mustBeAnIdentifier</span>, <span class="hljs-string">'abc'</span>);</code>
</pre>
<p>As a next step, we’ll go beyond this limitation for property keys: In this subsection, we’ll use arbitrary fixed strings as keys. In <span refcheck="#object-literals-computed-keys">the next subsection</span>, we’ll dynamically compute keys.</p>
<p>Two syntaxes enable us to use arbitrary strings as property keys.</p>
<p><span id="index-entry-quoted-property-key"/><span id="index-entry-property-key--quoted"/></p>
<p>First, when creating property keys via object literals, we can quote property keys (with single or double quotes):</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  <span class="hljs-string">'Can be any string!'</span>: <span class="hljs-number">123</span>,</code>
<code>};</code>
</pre>
<p>Second, when getting or setting properties, we can use square brackets with strings inside them:</p>
<pre class="language-js">
<code><span class="hljs-comment">// Get property</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(obj[<span class="hljs-string">'Can be any string!'</span>], <span class="hljs-number">123</span>);</code>
<code/>
<code><span class="hljs-comment">// Set property</span></code>
<code>obj[<span class="hljs-string">'Can be any string!'</span>] = <span class="hljs-string">'abc'</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(obj[<span class="hljs-string">'Can be any string!'</span>], <span class="hljs-string">'abc'</span>);</code>
</pre>
<p>We can also use these syntaxes for methods:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  <span class="hljs-string">'A nice method'</span>() {</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-string">'Yes!'</span>;</code>
<code>  },</code>
<code>};</code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(obj[<span class="hljs-string">'A nice method'</span>](), <span class="hljs-string">'Yes!'</span>);</code>
</pre>
<h4 id="object-literals-computed-keys"><a class="heading-id-link" href="#object-literals-computed-keys">30.9.2 Computed keys in object literals</a></h4>
<p><span id="index-entry-computed-property-key"/><span id="index-entry-property-key--computed"/></p>
<p>In the previous subsection, property keys were specified via fixed strings inside object literals. In this section we learn how to dynamically compute property keys. That enables us to use either arbitrary strings or symbols.</p>
<p>The syntax of dynamically computed property keys in object literals is inspired by dynamically accessing properties. That is, we can use square brackets to wrap expressions:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  [<span class="hljs-string">'Hello world!'</span>]: <span class="hljs-literal">true</span>,</code>
<code>  [<span class="hljs-string">'p'</span>+<span class="hljs-string">'r'</span>+<span class="hljs-string">'o'</span>+<span class="hljs-string">'p'</span>]: <span class="hljs-number">123</span>,</code>
<code>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]: <span class="hljs-string">'Goodbye'</span>, <span class="hljs-comment">// (A)</span></code>
<code>};</code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(obj[<span class="hljs-string">'Hello world!'</span>], <span class="hljs-literal">true</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(obj.<span class="hljs-property">prop</span>, <span class="hljs-number">123</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(obj[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>], <span class="hljs-string">'Goodbye'</span>);</code>
</pre>
<p>The main use case for computed keys is having symbols as property keys (line A).</p>
<p>Note that the square brackets operator for getting and setting properties works with arbitrary expressions:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(obj[<span class="hljs-string">'p'</span>+<span class="hljs-string">'r'</span>+<span class="hljs-string">'o'</span>+<span class="hljs-string">'p'</span>], <span class="hljs-number">123</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(obj[<span class="hljs-string">'==&gt; prop'</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">4</span>)], <span class="hljs-number">123</span>);</code>
</pre>
<p>Methods can have computed property keys, too:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> methodKey = <span class="hljs-title class_">Symbol</span>();</code>
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  [methodKey]() {</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-string">'Yes!'</span>;</code>
<code>  },</code>
<code>};</code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(obj[methodKey](), <span class="hljs-string">'Yes!'</span>);</code>
</pre>
<p>For the remainder of this chapter, we’ll mostly use fixed property keys again (because they are syntactically more convenient). But all features are also available for arbitrary strings and symbols.</p>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Non-destructively updating a property via spreading (computed key)</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/objects/update_property_test.mjs</code></p>
</div>
<h4 id="in-operator"><a class="heading-id-link" href="#in-operator">30.9.3 The <code>in</code> operator: is there a property with a given key?</a></h4>
<p><span id="index-entry-in"/></p>
<p>The <code>in</code> operator checks if an object has a property with a given key:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  <span class="hljs-attr">alpha</span>: <span class="hljs-string">'abc'</span>,</code>
<code>  <span class="hljs-attr">beta</span>: <span class="hljs-literal">false</span>,</code>
<code>};</code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-string">'alpha'</span> <span class="hljs-keyword">in</span> obj, <span class="hljs-literal">true</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-string">'beta'</span> <span class="hljs-keyword">in</span> obj, <span class="hljs-literal">true</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-string">'unknownKey'</span> <span class="hljs-keyword">in</span> obj, <span class="hljs-literal">false</span>);</code>
</pre>
<h5 id="checking-if-a-property-exists-via-truthiness"><a class="heading-id-link" href="#checking-if-a-property-exists-via-truthiness">30.9.3.1 Checking if a property exists via truthiness</a></h5>
<p>We can also use a truthiness check to determine if a property exists:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  obj.<span class="hljs-property">alpha</span> ? <span class="hljs-string">'exists'</span> : <span class="hljs-string">'does not exist'</span>,</code>
<code>  <span class="hljs-string">'exists'</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  obj.<span class="hljs-property">unknownKey</span> ? <span class="hljs-string">'exists'</span> : <span class="hljs-string">'does not exist'</span>,</code>
<code>  <span class="hljs-string">'does not exist'</span>);</code>
</pre>
<p>The previous checks work because <code>obj.alpha</code> is truthy and because reading a missing property returns <code>undefined</code> (which is falsy).</p>
<p>There is, however, one important caveat: truthiness checks fail if the property exists, but has a falsy value (<code>undefined</code>, <code>null</code>, <code>false</code>, <code>0</code>, <code>""</code>, etc.):</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  obj.<span class="hljs-property">beta</span> ? <span class="hljs-string">'exists'</span> : <span class="hljs-string">'does not exist'</span>,</code>
<code>  <span class="hljs-string">'does not exist'</span>); <span class="hljs-comment">// should be: 'exists'</span></code>
</pre>
<h4 id="deleting-properties"><a class="heading-id-link" href="#deleting-properties">30.9.4 Deleting properties</a></h4>
<p><span id="index-entry-delete"/><span id="index-entry-deleting-a-property"/><span id="index-entry-property--deleting-a"/></p>
<p>We can delete properties via the <code>delete</code> operator:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  <span class="hljs-attr">myProp</span>: <span class="hljs-number">123</span>,</code>
<code>};</code>
<code/>
<code>assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj), [<span class="hljs-string">'myProp'</span>]);</code>
<code><span class="hljs-keyword">delete</span> obj.<span class="hljs-property">myProp</span>;</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj), []);</code>
</pre>
<h4 id="enumerability"><a class="heading-id-link" href="#enumerability">30.9.5 Enumerability</a></h4>
<p><span id="index-entry-enumerability"/>
<span id="index-entry-enumerable--property-attribute-"/></p>
<p><em>Enumerability</em> is an <a href="#property-attributes-property-descriptors"><em>attribute</em></a> of a property. Non-enumerable properties are ignored by some operations – for example, by <code>Object.keys()</code> and when spreading properties. By default, most properties are enumerable. The next example shows how to change that and how it affects spreading.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> enumerableSymbolKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'enumerableSymbolKey'</span>);</code>
<code><span class="hljs-keyword">const</span> nonEnumSymbolKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'nonEnumSymbolKey'</span>);</code>
<code/>
<code><span class="hljs-comment">// We create enumerable properties via an object literal</span></code>
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  <span class="hljs-attr">enumerableStringKey</span>: <span class="hljs-number">1</span>,</code>
<code>  [enumerableSymbolKey]: <span class="hljs-number">2</span>,</code>
<code>}</code>
<code/>
<code><span class="hljs-comment">// For non-enumerable properties, we need a more powerful tool</span></code>
<code><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(obj, {</code>
<code>  <span class="hljs-attr">nonEnumStringKey</span>: {</code>
<code>    <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>,</code>
<code>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,</code>
<code>  },</code>
<code>  [nonEnumSymbolKey]: {</code>
<code>    <span class="hljs-attr">value</span>: <span class="hljs-number">4</span>,</code>
<code>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,</code>
<code>  },</code>
<code>});</code>
<code/>
<code><span class="hljs-comment">// Non-enumerable properties are ignored by spreading:</span></code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  {...obj},</code>
<code>  {</code>
<code>    <span class="hljs-attr">enumerableStringKey</span>: <span class="hljs-number">1</span>,</code>
<code>    [enumerableSymbolKey]: <span class="hljs-number">2</span>,</code>
<code>  }</code>
<code>);</code>
</pre>
<p><code>Object.defineProperties()</code> is explained <a href="#property-attributes-property-descriptors">later in this chapter</a>. The next subsection shows how these operations are affected by enumerability: </p>
<h4 id="listing-property-keys"><a class="heading-id-link" href="#listing-property-keys">30.9.6 Listing property keys via <code>Object.keys()</code> etc.</a></h4>
<p><span id="index-entry-listing-properties"/><span id="index-entry-properties--listing"/>
<span id="index-entry-property-key"/><span id="index-entry-property-name"/><span id="index-entry-property-symbol"/></p>
<figure id="tbl:listing-property-keys" class="float">
  <table class="framed">
    <style>
      th:nth-child(1), td:nth-child(1) {
        text-align: left;
      }
      th:nth-child(2), td:nth-child(2) {
        text-align: left;
      }
      th:nth-child(3), td:nth-child(3) {
        text-align: left;
      }
      th:nth-child(4), td:nth-child(4) {
        text-align: left;
      }
      th:nth-child(5), td:nth-child(5) {
        text-align: left;
      }
    </style>
    <thead>
      <tr>
        <th/><th>enumerable</th><th>non-e.</th><th>string</th><th>symbol</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>Object.keys()</code></td><td>✔</td><td/><td>✔</td><td/>
      </tr>
      <tr>
        <td><code>Object.getOwnPropertyNames()</code></td><td>✔</td><td>✔</td><td>✔</td><td/>
      </tr>
      <tr>
        <td><code>Object.getOwnPropertySymbols()</code></td><td>✔</td><td>✔</td><td/><td>✔</td>
      </tr>
      <tr>
        <td><code>Reflect.ownKeys()</code></td><td>✔</td><td>✔</td><td>✔</td><td>✔</td>
      </tr>
    </tbody>
  </table>
  <figcaption>
    <p><span class="float-label">Table 30.1:</span> Standard library methods for listing <em>own</em> (non-inherited) property keys. All of them return Arrays with strings and/or symbols.</p>
  </figcaption>
</figure>
<p>Each of the methods in <a href="#tbl:listing-property-keys">table 30.1</a> returns an Array with the own property keys of the parameter. In the names of the methods, we can see that the following distinction is made:</p>
<ul>
  <li>
    A <em>property key</em> can be either a string or a symbol. (<code>Object.keys()</code> is older and does not yet follow this convention.)
  </li>
  <li>
    A <em>property name</em> is a property key whose value is a string.
  </li>
  <li>
    A <em>property symbol</em> is a property key whose value is a symbol.
  </li>
</ul>
<p>To demonstrate the four operations, we revisit the example from the previous subsection:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> enumerableSymbolKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'enumerableSymbolKey'</span>);</code>
<code><span class="hljs-keyword">const</span> nonEnumSymbolKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'nonEnumSymbolKey'</span>);</code>
<code/>
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  <span class="hljs-attr">enumerableStringKey</span>: <span class="hljs-number">1</span>,</code>
<code>  [enumerableSymbolKey]: <span class="hljs-number">2</span>,</code>
<code>}</code>
<code><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(obj, {</code>
<code>  <span class="hljs-attr">nonEnumStringKey</span>: {</code>
<code>    <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>,</code>
<code>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,</code>
<code>  },</code>
<code>  [nonEnumSymbolKey]: {</code>
<code>    <span class="hljs-attr">value</span>: <span class="hljs-number">4</span>,</code>
<code>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,</code>
<code>  },</code>
<code>});</code>
<code/>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj),</code>
<code>  [<span class="hljs-string">'enumerableStringKey'</span>]</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(obj),</code>
<code>  [<span class="hljs-string">'enumerableStringKey'</span>, <span class="hljs-string">'nonEnumStringKey'</span>]</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(obj),</code>
<code>  [enumerableSymbolKey, nonEnumSymbolKey]</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj),</code>
<code>  [</code>
<code>    <span class="hljs-string">'enumerableStringKey'</span>, <span class="hljs-string">'nonEnumStringKey'</span>,</code>
<code>    enumerableSymbolKey, nonEnumSymbolKey,</code>
<code>  ]</code>
<code>);</code>
</pre>
<h4 id="Object.values"><a class="heading-id-link" href="#Object.values">30.9.7 Listing property values via <code>Object.values()</code></a></h4>
<p><code>Object.values()</code> lists the values of all own enumerable string-keyed properties of an object:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> firstName = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'firstName'</span>);</code>
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  [firstName]: <span class="hljs-string">'Jane'</span>,</code>
<code>  <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Doe'</span>,</code>
<code>};</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(obj),</code>
<code>  [<span class="hljs-string">'Doe'</span>]);</code>
</pre>
<h4 id="Object.entries"><a class="heading-id-link" href="#Object.entries">30.9.8 Listing property entries via <code>Object.entries()</code><span> <sup>ES2017</sup></span></a></h4>
<p><code>Object.entries(obj)</code> returns an Array with one key-value pair for each of its properties:</p>
<ul>
  <li>
    Each pair is encoded as a two-element Array.
  </li>
  <li>
    Only own enumerable properties with string keys are included.
  </li>
</ul>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> firstName = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'firstName'</span>);</code>
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  [firstName]: <span class="hljs-string">'Jane'</span>,</code>
<code>  <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Doe'</span>,</code>
<code>};</code>
<code><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(</code>
<code>  obj, <span class="hljs-string">'city'</span>, {<span class="hljs-attr">value</span>: <span class="hljs-string">'Metropolis'</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>}</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj),</code>
<code>  [</code>
<code>    [<span class="hljs-string">'lastName'</span>, <span class="hljs-string">'Doe'</span>],</code>
<code>  ]);</code>
</pre>
<h5 id="a-simple-implementation-of-objectentries"><a class="heading-id-link" href="#a-simple-implementation-of-objectentries">30.9.8.1 A simple implementation of <code>Object.entries()</code></a></h5>
<p>The following function is a simplified version of <code>Object.entries()</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">entries</span>(<span class="hljs-params">obj</span>) {</code>
<code>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)</code>
<code>  .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> [key, obj[key]]);</code>
<code>}</code>
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: <code>Object.entries()</code></strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/objects/find_key_test.mjs</code></p>
</div>
<h4 id="order-of-properties"><a class="heading-id-link" href="#order-of-properties">30.9.9 Properties are listed deterministically</a></h4>
<p>Own (non-inherited) properties of objects are always listed in the following order:</p>
<ol>
  <li>
    Properties with string keys that contain integer indices:<br/>
    In ascending numeric order
  </li>
  <li>
    Remaining properties with string keys:<br/>
    In the order in which they were added
  </li>
  <li>
    Properties with symbol keys:<br/>
    In the order in which they were added
  </li>
</ol>
<p>The following example demonstrates that property keys are sorted according to these rules:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  <span class="hljs-attr">b</span>: <span class="hljs-literal">true</span>,</code>
<code>  <span class="hljs-attr">a</span>: <span class="hljs-literal">true</span>,</code>
<code>  <span class="hljs-number">10</span>: <span class="hljs-literal">true</span>,</code>
<code>  <span class="hljs-number">2</span>: <span class="hljs-literal">true</span>,</code>
<code>};</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj),</code>
<code>  [<span class="hljs-string">'2'</span>, <span class="hljs-string">'10'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>]</code>
<code>);</code>
</pre>
<div class="boxout">
  <p><img src="../Images/38ba63de820aae6f94a019538ae0f222.png" class="boxout-icon" height="24" alt="Icon “details”" data-original-src="https://exploringjs.com/js/book/icon/details.svg"/> <strong>The order of properties</strong></p>
  <div class="boxout-vspace"/>
  <p><a href="https://tc39.es/ecma262/#sec-ordinaryownpropertykeys">The ECMAScript specification</a> describes in more detail how properties are ordered.</p>
</div>
<h5 id="why-is-the-order-of-properties-deterministic"><a class="heading-id-link" href="#why-is-the-order-of-properties-deterministic">30.9.9.1 Why is the order of properties deterministic?</a></h5>
<p>As a data structure, objects are mainly unordered. Therefore, we wouldn’t expect, e.g., <code>Object.keys()</code> to always return property keys in the same order. However, JavaScript does define a deterministic order for properties because that helps with testing and other use cases.</p>
<h4 id="Object.fromEntries"><a class="heading-id-link" href="#Object.fromEntries">30.9.10 Assembling objects via <code>Object.fromEntries()</code><span> <sup>ES2019</sup></span></a></h4>
<p>Given an iterable over [key, value] pairs, <code>Object.fromEntries()</code> creates an object:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> symbolKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'symbolKey'</span>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(</code>
<code>    [</code>
<code>      [<span class="hljs-string">'stringKey'</span>, <span class="hljs-number">1</span>],</code>
<code>      [symbolKey, <span class="hljs-number">2</span>],</code>
<code>    ]</code>
<code>  ),</code>
<code>  {</code>
<code>    <span class="hljs-attr">stringKey</span>: <span class="hljs-number">1</span>,</code>
<code>    [symbolKey]: <span class="hljs-number">2</span>,</code>
<code>  }</code>
<code>);</code>
</pre>
<p><code>Object.fromEntries()</code> does the opposite of <a href="#Object.entries"><code>Object.entries()</code></a>. However, while <code>Object.entries()</code> ignores symbol-keyed properties, <code>Object.fromEntries()</code> doesn’t (see previous example).</p>
<p>To demonstrate both, we’ll use them to implement two tool functions from the library <a href="https://underscorejs.org">Underscore</a> in <span refcheck="#underscore-pick #underscore-invert">the next subsubsections</span>.</p>
<h5 id="underscore-pick"><a class="heading-id-link" href="#underscore-pick">30.9.10.1 Example: <code>pick()</code></a></h5>
<p><a href="https://underscorejs.org/#pick">The Underscore function <code>pick()</code></a> has the following signature:</p>
<pre class="language-js">
<code><span class="hljs-title function_">pick</span>(object, ...keys)</code>
</pre>
<p>It returns a copy of <code>object</code> that has only those properties whose keys are mentioned in the trailing arguments:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> address = {</code>
<code>  <span class="hljs-attr">street</span>: <span class="hljs-string">'Evergreen Terrace'</span>,</code>
<code>  <span class="hljs-attr">number</span>: <span class="hljs-string">'742'</span>,</code>
<code>  <span class="hljs-attr">city</span>: <span class="hljs-string">'Springfield'</span>,</code>
<code>  <span class="hljs-attr">state</span>: <span class="hljs-string">'NT'</span>,</code>
<code>  <span class="hljs-attr">zip</span>: <span class="hljs-string">'49007'</span>,</code>
<code>};</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title function_">pick</span>(address, <span class="hljs-string">'street'</span>, <span class="hljs-string">'number'</span>),</code>
<code>  {</code>
<code>    <span class="hljs-attr">street</span>: <span class="hljs-string">'Evergreen Terrace'</span>,</code>
<code>    <span class="hljs-attr">number</span>: <span class="hljs-string">'742'</span>,</code>
<code>  }</code>
<code>);</code>
</pre>
<p>We can implement <code>pick()</code> as follows:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">pick</span>(<span class="hljs-params">object, ...keys</span>) {</code>
<code>  <span class="hljs-keyword">const</span> filteredEntries = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(object)</code>
<code>    .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">[key, _value]</span>) =&gt;</span> keys.<span class="hljs-title function_">includes</span>(key));</code>
<code>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(filteredEntries);</code>
<code>}</code>
</pre>
<h5 id="underscore-invert"><a class="heading-id-link" href="#underscore-invert">30.9.10.2 Example: <code>invert()</code></a></h5>
<p><a href="https://underscorejs.org/#invert">The Underscore function <code>invert()</code></a> has the following signature:</p>
<pre class="language-js">
<code><span class="hljs-title function_">invert</span>(object)</code>
</pre>
<p>It returns a copy of <code>object</code> where the keys and values of all properties are swapped:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title function_">invert</span>({<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>}),</code>
<code>  {<span class="hljs-number">1</span>: <span class="hljs-string">'a'</span>, <span class="hljs-number">2</span>: <span class="hljs-string">'b'</span>, <span class="hljs-number">3</span>: <span class="hljs-string">'c'</span>}</code>
<code>);</code>
</pre>
<p>We can implement <code>invert()</code> like this:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">invert</span>(<span class="hljs-params">object</span>) {</code>
<code>  <span class="hljs-keyword">const</span> reversedEntries = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(object)</code>
<code>    .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> [value, key]);</code>
<code>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(reversedEntries);</code>
<code>}</code>
</pre>
<h5 id="a-simple-implementation-of-objectfromentries"><a class="heading-id-link" href="#a-simple-implementation-of-objectfromentries">30.9.10.3 A simple implementation of <code>Object.fromEntries()</code></a></h5>
<p>The following function is a simplified version of <code>Object.fromEntries()</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">fromEntries</span>(<span class="hljs-params">iterable</span>) {</code>
<code>  <span class="hljs-keyword">const</span> result = {};</code>
<code>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> iterable) {</code>
<code>    <span class="hljs-keyword">let</span> coercedKey;</code>
<code>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key === <span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> key === <span class="hljs-string">'symbol'</span>) {</code>
<code>      coercedKey = key;</code>
<code>    } <span class="hljs-keyword">else</span> {</code>
<code>      coercedKey = <span class="hljs-title class_">String</span>(key);</code>
<code>    }</code>
<code>    result[coercedKey] = value;</code>
<code>  }</code>
<code>  <span class="hljs-keyword">return</span> result;</code>
<code>}</code>
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Using <code>Object.entries()</code> and <code>Object.fromEntries()</code></strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/objects/omit_properties_test.mjs</code></p>
</div>
<h4 id="null-prototype-objects"><a class="heading-id-link" href="#null-prototype-objects">30.9.11 Objects with <code>null</code> prototypes make good dictionaries and lookup tables</a></h4>
<p><span id="index-entry-null-prototype-object"/>
<span id="index-entry-object--null-prototype"/></p>
<p>If we use plain objects (created via object literals) as dictionaries, we have to look out for two pitfalls.</p>
<h5 id="pitfall-1-getting-inherited-properties"><a class="heading-id-link" href="#pitfall-1-getting-inherited-properties">30.9.11.1 Pitfall 1: getting inherited properties</a></h5>
<p>The following dictionary object should be empty. However, we get a value (and not <code>undefined</code>) if we read an inherited property:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> dict = {};</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-keyword">typeof</span> dict[<span class="hljs-string">'toString'</span>], <span class="hljs-string">'function'</span></code>
<code>);</code>
</pre>
<p><code>dict</code> is an instance of <code>Object</code> and inherits <code>.toString()</code> from <code>Object.prototype</code>.</p>
<h5 id="pitfall-2-checking-if-a-property-exists"><a class="heading-id-link" href="#pitfall-2-checking-if-a-property-exists">30.9.11.2 Pitfall 2: checking if a property exists</a></h5>
<p>If we use the <code>in</code> operator to check if a property exists, we again detect inherited properties:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> dict = {};</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-string">'toString'</span> <span class="hljs-keyword">in</span> dict, <span class="hljs-literal">true</span></code>
<code>);</code>
</pre>
<p>As an aside: <code>Object.hasOwn()</code> does not have this pitfall. As its name indicates, it only considers <em>own</em> (non-inherited) properties:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> dict = {};</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(dict, <span class="hljs-string">'toString'</span>), <span class="hljs-literal">false</span></code>
<code>);</code>
</pre>
<h5 id="pitfall-3-property-key-proto"><a class="heading-id-link" href="#pitfall-3-property-key-proto">30.9.11.3 Pitfall 3: property key <code>'__proto__'</code></a></h5>
<p>We can’t use the property key <code>'__proto__'</code> because it has special powers (it sets the prototype of the object):</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> dict = {};</code>
<code/>
<code>dict[<span class="hljs-string">'__proto__'</span>] = <span class="hljs-number">123</span>;</code>
<code><span class="hljs-comment">// No property was added to dict:</span></code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(dict), []</code>
<code>);</code>
</pre>
<h5 id="dictionary-objects-with-null-prototypes"><a class="heading-id-link" href="#dictionary-objects-with-null-prototypes">30.9.11.4 Objects with <code>null</code> prototypes as dictionaries</a></h5>
<p>Maps are usually the best choice when it comes to dictionaries: They have a convenient method-based API and support keys beyond strings and symbols.</p>
<p>However, objects with <code>null</code> prototypes are also decent dictionaries and don’t have the pitfalls we just encountered:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> dict = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);</code>
<code/>
<code><span class="hljs-comment">// No inherited properties</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  dict[<span class="hljs-string">'toString'</span>], <span class="hljs-literal">undefined</span></code>
<code>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-string">'toString'</span> <span class="hljs-keyword">in</span> dict, <span class="hljs-literal">false</span></code>
<code>);</code>
<code/>
<code><span class="hljs-comment">// No special behavior with key '__proto__'</span></code>
<code>dict[<span class="hljs-string">'__proto__'</span>] = <span class="hljs-literal">true</span>;</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(dict), [<span class="hljs-string">'__proto__'</span>]</code>
<code>);</code>
</pre>
<p>We avoided the pitfalls:</p>
<ul>
  <li>
    An object without a prototype does not inherit anything. Therefore, it is always safe to get properties and to use the <code>in</code> operator.
  </li>
  <li>
    The accessor <code>Object.prototype.__proto__</code> is switched off because <code>Object.prototype</code> is not in the prototype chain of <code>dict</code>.
  </li>
</ul>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercises: Objects as dictionaries</strong></p>
  <div class="boxout-vspace"/>
  <ul>
    <li>
      A <code>null</code> prototype object as a dictionary: <code>exercises/objects/null-proto-obj-dict_test.mjs</code>
    </li>
    <li>
      A plain object as a dictionary: <code>exercises/objects/plain-obj-dict_test.mjs</code>
    </li>
  </ul>
</div>
<h5 id="lookup-tables-with-null-prototypes"><a class="heading-id-link" href="#lookup-tables-with-null-prototypes">30.9.11.5 Objects with <code>null</code> prototypes as fixed lookup tables</a></h5>
<p>Null prototypes are also useful for objects that we use as fixed lookup tables:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> htmlToLatex = {</code>
<code>  <span class="hljs-attr">__proto__</span>: <span class="hljs-literal">null</span>,</code>
<code>  <span class="hljs-string">'i'</span>: <span class="hljs-string">'textit'</span>,</code>
<code>  <span class="hljs-string">'b'</span>: <span class="hljs-string">'textbf'</span>,</code>
<code>  <span class="hljs-string">'u'</span>: <span class="hljs-string">'underline'</span>,</code>
<code>};</code>
</pre>
<h5 id="null-prototypes-in-standard-library"><a class="heading-id-link" href="#null-prototypes-in-standard-library">30.9.11.6 <code>null</code> prototypes in the standard library</a></h5>
<p>Because they are good dictionaries, the standard library also uses objects with <code>null</code> prototype in some locations – e.g.:</p>
<ul>
  <li>
    <p>The value of <code>import.meta</code>:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>), <span class="hljs-literal">null</span></code>
<code>);</code>
</pre>
  </li>
  <li>
    <p>The result of <code>Object.groupBy()</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> grouped = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">groupBy</span>([], <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(grouped), <span class="hljs-literal">null</span></code>
<code>);</code>
</pre>
  </li>
  <li>
    <p>When matching regular expressions – the value of <code>matchObj.groups</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> matchObj = <span class="hljs-regexp">/(?&lt;group&gt;x)/</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'x'</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(matchObj.<span class="hljs-property">groups</span>), <span class="hljs-literal">null</span></code>
<code>);</code>
</pre>
  </li>
</ul>
<h3 id="property-attributes-property-descriptors"><a class="heading-id-link" href="#property-attributes-property-descriptors">30.10 Property attributes and property descriptors<span> <sup>ES5</sup> (advanced)</span></a></h3>
<p><span id="index-entry-property-attribute"/><span id="index-entry-attribute-of-a-property"/>
<span id="index-entry-property-descriptor"/><span id="index-entry-descriptor-of-a-property"/></p>
<p>Just as objects are composed of properties, properties are composed of <em>attributes</em>. There are two kinds of properties and they are characterized by their attributes:</p>
<ul>
  <li>
    A <em>data property</em> stores data. Its attribute <code>value</code> holds any JavaScript value.
    <ul>
      <li>
        Methods are data properties whose values are functions.
      </li>
    </ul>
  </li>
  <li>
    An <em>accessor property</em> consists of a getter function and/or a setter function. The former is stored in the attribute <code>get</code>, the latter in the attribute <code>set</code>.
  </li>
</ul>
<p>Additionally, there are attributes that both kinds of properties have. The following table lists all attributes and their default values.</p>
<table class="framed">
  <style>
    th:nth-child(1), td:nth-child(1) {
      text-align: left;
    }
    th:nth-child(2), td:nth-child(2) {
      text-align: left;
    }
    th:nth-child(3), td:nth-child(3) {
      text-align: left;
    }
  </style>
  <thead>
    <tr>
      <th>Kind of property</th><th>Name and type of attribute</th><th>Default value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>All properties</td><td><code>configurable: boolean</code></td><td><code>false</code></td>
    </tr>
    <tr>
      <td/><td><code>enumerable: boolean</code></td><td><code>false</code></td>
    </tr>
    <tr>
      <td>Data property</td><td><code>value: any</code></td><td><code>undefined</code></td>
    </tr>
    <tr>
      <td/><td><code>writable: boolean</code></td><td><code>false</code></td>
    </tr>
    <tr>
      <td>Accessor property</td><td><code>get: (this: any) =&gt; any</code></td><td><code>undefined</code></td>
    </tr>
    <tr>
      <td/><td><code>set: (this: any, v: any) =&gt; void</code></td><td><code>undefined</code></td>
    </tr>
  </tbody>
</table>
<p>We have already encountered the attributes <code>value</code>, <code>get</code>, and <code>set</code>. The other attributes work as follows:</p>
<ul>
  <li>
    <code>writable</code> determines if the value of a data property can be changed.
  </li>
  <li>
    <code>configurable</code> determines if the attributes of a property can be changed. If it is <code>false</code>, then:
    <ul>
      <li>
        We cannot delete the property.
      </li>
      <li>
        We cannot change a property from a data property to an accessor property or vice versa.
      </li>
      <li>
        We cannot change any attribute other than <code>value</code>.
      </li>
      <li>
        However, one more attribute change is allowed: We can change <code>writable</code> from <code>true</code> to <code>false</code>. The rationale behind this anomaly is <a href="https://stackoverflow.com/questions/9829817/why-can-i-set-enumerability-and-writability-of-unconfigurable-property-descrip/9843191#9843191">historical</a>: Property <code>.length</code> of Arrays has always been writable and non-configurable. Allowing its <code>writable</code> attribute to be changed enables us to freeze Arrays.
      </li>
    </ul>
  </li>
  <li>
    <code>enumerable</code> influences some operations (such as <code>Object.keys()</code>). If it is <code>false</code>, then those operations ignore the property. Enumerability is covered in greater detail <a href="#enumerability">earlier in this chapter</a>.
  </li>
</ul>
<p>When we are using one of the operations for handling property attributes, attributes are specified via <em>property descriptors</em>: objects where each property represents one attribute. For example, this is how we read the attributes of a property <code>obj.myProp</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">myProp</span>: <span class="hljs-number">123</span> };</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(obj, <span class="hljs-string">'myProp'</span>),</code>
<code>  {</code>
<code>    <span class="hljs-attr">value</span>: <span class="hljs-number">123</span>,</code>
<code>    <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,</code>
<code>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,</code>
<code>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,</code>
<code>  });</code>
</pre>
<p>And this is how we change the attributes of <code>obj.myProp</code>:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj), [<span class="hljs-string">'myProp'</span>]);</code>
<code/>
<code><span class="hljs-comment">// Hide property `myProp` from Object.keys()</span></code>
<code><span class="hljs-comment">// by making it non-enumerable</span></code>
<code><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">'myProp'</span>, {</code>
<code>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,</code>
<code>});</code>
<code/>
<code>assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj), []);</code>
</pre>
<p>Lastly, let’s see what methods and getters look like:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  <span class="hljs-title function_">myMethod</span>(<span class="hljs-params">) {},</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">get</span> <span class="hljs-title function_">myGetter</span>() {},</span></code>
<code><span class="hljs-params">};</span></code>
<code><span class="hljs-params"><span class="hljs-keyword">const</span> propDescs = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(obj);</span></code>
<code><span class="hljs-params">propDescs.<span class="hljs-property">myMethod</span>.<span class="hljs-property">value</span> = <span class="hljs-keyword">typeof</span> propDescs.<span class="hljs-property">myMethod</span>.<span class="hljs-property">value</span>;</span></code>
<code><span class="hljs-params">propDescs.<span class="hljs-property">myGetter</span>.<span class="hljs-property">get</span> = <span class="hljs-keyword">typeof</span> propDescs.<span class="hljs-property">myGetter</span>.<span class="hljs-property">get</span>;</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span></code>
<code><span class="hljs-params">  propDescs,</span></code>
<code><span class="hljs-params">  {</span></code>
<code><span class="hljs-params">    <span class="hljs-attr">myMethod</span>: {</span></code>
<code><span class="hljs-params">      <span class="hljs-attr">value</span>: <span class="hljs-string">'function'</span>,</span></code>
<code><span class="hljs-params">      <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,</span></code>
<code><span class="hljs-params">      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,</span></code>
<code><span class="hljs-params">      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span></span></code>
<code><span class="hljs-params">    },</span></code>
<code><span class="hljs-params">    <span class="hljs-attr">myGetter</span>: {</span></code>
<code><span class="hljs-params">      <span class="hljs-attr">get</span>: <span class="hljs-string">'function'</span>,</span></code>
<code><span class="hljs-params">      <span class="hljs-attr">set</span>: <span class="hljs-literal">undefined</span>,</span></code>
<code><span class="hljs-params">      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,</span></code>
<code><span class="hljs-params">      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span></span></code>
<code><span class="hljs-params">    }</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">);</span></code>
</pre>
<div class="boxout">
  <p><img src="../Images/38e6ff55e8d602659f3cdb8893e63f62.png" class="boxout-icon" height="24" alt="Icon “external”" data-original-src="https://exploringjs.com/js/book/icon/external.svg"/> <strong>Further reading</strong></p>
  <div class="boxout-vspace"/>
  <p>For more information on property attributes and property descriptors, see <a href="https://exploringjs.com/deep-js/ch_property-attributes-intro.html"><em>Deep JavaScript</em></a>.</p>
</div>
<h3 id="protecting-objects"><a class="heading-id-link" href="#protecting-objects">30.11 Protecting objects from being changed<span> <sup>ES5</sup> (advanced)</span></a></h3>
<p>JavaScript has three levels of protecting objects:</p>
<ul>
  <li>
    <em>Preventing extensions</em> makes it impossible to add new properties to an object and to change its prototype. We can still delete and change properties, though.
    <ul>
      <li>
        Apply: <code>Object.preventExtensions(obj)</code>
      </li>
      <li>
        Check: <code>Object.isExtensible(obj)</code>
      </li>
    </ul>
  </li>
  <li>
    <em>Sealing</em> prevents extensions and makes all properties <em>unconfigurable</em> (roughly: we can’t change how a property works anymore).
    <ul>
      <li>
        Apply: <code>Object.seal(obj)</code>
      </li>
      <li>
        Check: <code>Object.isSealed(obj)</code>
      </li>
    </ul>
  </li>
  <li>
    <em>Freezing</em> seals an object after making all of its properties non-writable. That is, the object is not extensible, all properties are read-only and there is no way to change that.
    <ul>
      <li>
        Apply: <code>Object.freeze(obj)</code>
      </li>
      <li>
        Check: <code>Object.isFrozen(obj)</code>
      </li>
    </ul>
  </li>
</ul>
<div class="boxout">
  <p><img src="../Images/5aa4bf88dc66ecb2bac6be4022a1fed4.png" class="boxout-icon" height="24" alt="Icon “warning”" data-original-src="https://exploringjs.com/js/book/icon/warning.svg"/> <strong>Caveat: Objects are only protected shallowly</strong></p>
  <div class="boxout-vspace"/>
  <p>All three of the aforementioned <code>Object.*</code> methods only affect the top level of an object, not objects nested inside it.</p>
</div>
<p>This is what using <code>Object.freeze()</code> looks like:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> frozen = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">5</span> });</code>
<code>assert.<span class="hljs-title function_">throws</span>(</code>
<code>  <span class="hljs-function">() =&gt;</span> frozen.<span class="hljs-property">x</span> = <span class="hljs-number">7</span>,</code>
<code>  {</code>
<code>    <span class="hljs-attr">name</span>: <span class="hljs-string">'TypeError'</span>,</code>
<code>    <span class="hljs-attr">message</span>: <span class="hljs-regexp">/^Cannot assign to read only property 'x'/</span>,</code>
<code>  }</code>
<code>);</code>
</pre>
<p>Changing frozen properties only causes an exception in <a href="ch_syntax.html#strict-mode">strict mode</a>. In sloppy mode, it fails silently.</p>
<div class="boxout">
  <p><img src="../Images/38e6ff55e8d602659f3cdb8893e63f62.png" class="boxout-icon" height="24" alt="Icon “external”" data-original-src="https://exploringjs.com/js/book/icon/external.svg"/> <strong>Further reading</strong></p>
  <div class="boxout-vspace"/>
  <p>For more information on freezing and other ways of locking down objects, see <a href="https://exploringjs.com/deep-js/ch_protecting-objects.html"><em>Deep JavaScript</em></a>.</p>
</div>
<h3 id="quickref-object-api"><a class="heading-id-link" href="#quickref-object-api">30.12 Quick reference: <code>Object</code></a></h3>
<h4 id="object-creating-objects-handling-prototypes"><a class="heading-id-link" href="#object-creating-objects-handling-prototypes">30.12.1 <code>Object.*</code>: creating objects, handling prototypes</a></h4>
<ul>
  <li>
    <p><code id="qref-Object.create">Object.create(proto, propDescObj?)</code> <span class="ibox ibox-small" size="small">ES5</span></p>
    <ul>
      <li>
        Returns a new object whose prototype is <code>proto</code>.
      </li>
      <li>
        The optional <code>propDescObj</code> is an object with <a href="#property-attributes-property-descriptors">property descriptors</a> that is used to define properties in the new object.
      </li>
    </ul>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);</span></code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj)</span></code>
<code>null</code>
</pre>
    <p>In the following example, we define own properties via the second parameter:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(</code>
<code>  <span class="hljs-literal">null</span>,</code>
<code>  {</code>
<code>    <span class="hljs-attr">color</span>: {</code>
<code>      <span class="hljs-attr">value</span>: <span class="hljs-string">'green'</span>,</code>
<code>      <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,</code>
<code>      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,</code>
<code>      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,</code>
<code>    },</code>
<code>  }</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  obj,</code>
<code>  {</code>
<code>    <span class="hljs-attr">__proto__</span>: <span class="hljs-literal">null</span>,</code>
<code>    <span class="hljs-attr">color</span>: <span class="hljs-string">'green'</span>,</code>
<code>  }</code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Object.getPrototypeOf">Object.getPrototypeOf(obj)</code> <span class="ibox ibox-small" size="small">ES5</span></p>
    <p>Return the prototype of <code>obj</code> – which is either an object or <code>null</code>.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>({<span class="hljs-attr">__proto__</span>: <span class="hljs-literal">null</span>}), <span class="hljs-literal">null</span></code>
<code>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>({}), <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></code>
<code>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>), <span class="hljs-literal">null</span></code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Object.setPrototypeOf">Object.setPrototypeOf(obj, proto)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>Sets the prototype of <code>obj</code> to <code>proto</code> (which must be <code>null</code> or an object) and returns the former.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {};</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj), <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></code>
<code>);</code>
<code><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(obj, <span class="hljs-literal">null</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj), <span class="hljs-literal">null</span></code>
<code>);</code>
</pre>
  </li>
</ul>
<h4 id="object-property-attributes"><a class="heading-id-link" href="#object-property-attributes">30.12.2 <code>Object.*</code>: property attributes</a></h4>
<ul>
  <li>
    <p><code id="qref-Object.defineProperty">Object.defineProperty(obj, propKey, propDesc)</code> <span class="ibox ibox-small" size="small">ES5</span></p>
    <ul>
      <li>
        Defines one property in <code>obj</code>, as specified by the property key <code>propKey</code> and the <a href="#property-attributes-property-descriptors">property descriptor</a> <code>propDesc</code>.
      </li>
      <li>
        Returns <code>obj</code>.
      </li>
    </ul>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {};</code>
<code><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(</code>
<code>  obj, <span class="hljs-string">'color'</span>,</code>
<code>  {</code>
<code>    <span class="hljs-attr">value</span>: <span class="hljs-string">'green'</span>,</code>
<code>    <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,</code>
<code>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,</code>
<code>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,</code>
<code>  }</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  obj,</code>
<code>  {</code>
<code>    <span class="hljs-attr">color</span>: <span class="hljs-string">'green'</span>,</code>
<code>  }</code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Object.defineProperties">Object.defineProperties(obj, propDescObj)</code> <span class="ibox ibox-small" size="small">ES5</span></p>
    <ul>
      <li>
        Defines properties in <code>obj</code>, as specified by the object <code>propDescObj</code> with <a href="#property-attributes-property-descriptors">property descriptors</a>.
      </li>
      <li>
        Returns <code>obj</code>.
      </li>
    </ul>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {};</code>
<code><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(</code>
<code>  obj,</code>
<code>  {</code>
<code>    <span class="hljs-attr">color</span>: {</code>
<code>      <span class="hljs-attr">value</span>: <span class="hljs-string">'green'</span>,</code>
<code>      <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,</code>
<code>      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,</code>
<code>      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,</code>
<code>    },</code>
<code>  }</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  obj,</code>
<code>  {</code>
<code>    <span class="hljs-attr">color</span>: <span class="hljs-string">'green'</span>,</code>
<code>  }</code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Object.getOwnPropertyDescriptor">Object.getOwnPropertyDescriptor(obj, propKey)</code> <span class="ibox ibox-small" size="small">ES5</span></p>
    <ul>
      <li>
        Returns a property descriptor for the own property of <code>obj</code> whose key is <code>propKey</code>. If no such property exists, it returns <code>undefined</code>.
      </li>
      <li>
        More information on property descriptors: <a href="#property-attributes-property-descriptors">“Property attributes and property descriptors<span> <sup>ES5</sup> (advanced)</span>” (§30.10)</a>
      </li>
    </ul>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>({<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>}, <span class="hljs-string">'a'</span>)</span></code>
<code>{ value: 1, writable: true, enumerable: true, configurable: true }</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>({<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>}, <span class="hljs-string">'x'</span>)</span></code>
<code>undefined</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Object.getOwnPropertyDescriptors">Object.getOwnPropertyDescriptors(obj)</code> <span class="ibox ibox-small" size="small">ES2017</span></p>
    <ul>
      <li>
        Returns an object with property descriptors, one for each own property of <code>obj</code>.
      </li>
      <li>
        More information on property descriptors: <a href="#property-attributes-property-descriptors">“Property attributes and property descriptors<span> <sup>ES5</sup> (advanced)</span>” (§30.10)</a>
      </li>
    </ul>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>({<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>})</span></code>
<code>{</code>
<code>  a: { value: 1, writable: true, enumerable: true, configurable: true },</code>
<code>  b: { value: 2, writable: true, enumerable: true, configurable: true },</code>
<code>}</code>
</pre>
  </li>
</ul>
<h4 id="object-property-keys-values-entries"><a class="heading-id-link" href="#object-property-keys-values-entries">30.12.3 <code>Object.*</code>: property keys, values, entries</a></h4>
<ul>
  <li>
    <p><code id="qref-Object.keys">Object.keys(obj)</code> <span class="ibox ibox-small" size="small">ES5</span></p>
    <p>Returns an Array with all own enumerable property keys that are strings.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> enumSymbolKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'enumSymbolKey'</span>);</code>
<code><span class="hljs-keyword">const</span> nonEnumSymbolKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'nonEnumSymbolKey'</span>);</code>
<code/>
<code><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(</code>
<code>  {},</code>
<code>  {</code>
<code>    <span class="hljs-attr">enumStringKey</span>: {</code>
<code>      <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,</code>
<code>    },</code>
<code>    [enumSymbolKey]: {</code>
<code>      <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,</code>
<code>    },</code>
<code>    <span class="hljs-attr">nonEnumStringKey</span>: {</code>
<code>      <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,</code>
<code>    },</code>
<code>    [nonEnumSymbolKey]: {</code>
<code>      <span class="hljs-attr">value</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,</code>
<code>    },</code>
<code>  }</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj),</code>
<code>  [<span class="hljs-string">'enumStringKey'</span>]</code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Object.getOwnPropertyNames">Object.getOwnPropertyNames(obj)</code> <span class="ibox ibox-small" size="small">ES5</span></p>
    <p>Returns an Array with all own property keys that are strings (enumerable and non-enumerable ones).</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> enumSymbolKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'enumSymbolKey'</span>);</code>
<code><span class="hljs-keyword">const</span> nonEnumSymbolKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'nonEnumSymbolKey'</span>);</code>
<code/>
<code><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(</code>
<code>  {},</code>
<code>  {</code>
<code>    <span class="hljs-attr">enumStringKey</span>: {</code>
<code>      <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,</code>
<code>    },</code>
<code>    [enumSymbolKey]: {</code>
<code>      <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,</code>
<code>    },</code>
<code>    <span class="hljs-attr">nonEnumStringKey</span>: {</code>
<code>      <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,</code>
<code>    },</code>
<code>    [nonEnumSymbolKey]: {</code>
<code>      <span class="hljs-attr">value</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,</code>
<code>    },</code>
<code>  }</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(obj),</code>
<code>  [<span class="hljs-string">'enumStringKey'</span>, <span class="hljs-string">'nonEnumStringKey'</span>]</code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Object.getOwnPropertySymbols">Object.getOwnPropertySymbols(obj)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>Returns an Array with all own property keys that are symbols (enumerable and non-enumerable ones).</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> enumSymbolKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'enumSymbolKey'</span>);</code>
<code><span class="hljs-keyword">const</span> nonEnumSymbolKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'nonEnumSymbolKey'</span>);</code>
<code/>
<code><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(</code>
<code>  {},</code>
<code>  {</code>
<code>    <span class="hljs-attr">enumStringKey</span>: {</code>
<code>      <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,</code>
<code>    },</code>
<code>    [enumSymbolKey]: {</code>
<code>      <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,</code>
<code>    },</code>
<code>    <span class="hljs-attr">nonEnumStringKey</span>: {</code>
<code>      <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,</code>
<code>    },</code>
<code>    [nonEnumSymbolKey]: {</code>
<code>      <span class="hljs-attr">value</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,</code>
<code>    },</code>
<code>  }</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(obj),</code>
<code>  [enumSymbolKey, nonEnumSymbolKey]</code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Object.values">Object.values(obj)</code> <span class="ibox ibox-small" size="small">ES2017</span></p>
    <p>Returns an Array with the values of all enumerable own string-keyed properties.</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>({<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>})</span></code>
<code>[ 1, 2 ]</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Object.entries">Object.entries(obj)</code> <span class="ibox ibox-small" size="small">ES2017</span></p>
    <ul>
      <li>
        Returns an Array with one key-value pair (encoded as a two-element Array) per property of <code>obj</code>.
      </li>
      <li>
        Only own enumerable properties with string keys are included.
      </li>
      <li>
        Inverse operation: <a href="#qref-Object.fromEntries"><code>Object.fromEntries()</code></a>
      </li>
    </ul>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,</code>
<code>  <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,</code>
<code>  [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'myKey'</span>)]: <span class="hljs-number">3</span>,</code>
<code>};</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj),</code>
<code>  [</code>
<code>    [<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>],</code>
<code>    [<span class="hljs-string">'b'</span>, <span class="hljs-number">2</span>],</code>
<code>    <span class="hljs-comment">// Property with symbol key is ignored</span></code>
<code>  ]</code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Object.fromEntries">Object.fromEntries(keyValueIterable)</code> <span class="ibox ibox-small" size="small">ES2019</span></p>
    <ul>
      <li>
        Creates an object whose own properties are specified by <code>keyValueIterable</code>.
      </li>
      <li>
        Inverse operation: <a href="#qref-Object.entries"><code>Object.entries()</code></a>
      </li>
    </ul>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>([[<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>], [<span class="hljs-string">'b'</span>, <span class="hljs-number">2</span>]])</span></code>
<code>{ a: 1, b: 2 }</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Object.hasOwn">Object.hasOwn(obj, key)</code> <span class="ibox ibox-small" size="small">ES2022</span></p>
    <ul>
      <li>
        Returns <code>true</code> if <code>obj</code> has an own property whose key is <code>key</code>. If not, it returns <code>false</code>.
      </li>
    </ul>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>({<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>}, <span class="hljs-string">'a'</span>)</span></code>
<code>true</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>({<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>}, <span class="hljs-string">'x'</span>)</span></code>
<code>false</code>
</pre>
  </li>
</ul>
<h4 id="object-protecting-objects"><a class="heading-id-link" href="#object-protecting-objects">30.12.4 <code>Object.*</code>: protecting objects</a></h4>
<p>More information: <a href="#protecting-objects">“Protecting objects from being changed<span> <sup>ES5</sup> (advanced)</span>” (§30.11)</a></p>
<ul>
  <li>
    <p><code id="qref-Object.preventExtensions">Object.preventExtensions(obj)</code> <span class="ibox ibox-small" size="small">ES5</span></p>
    <ul>
      <li>
        Makes <code>obj</code> non-extensible and returns it.
      </li>
      <li>
        Effect:
        <ul>
          <li>
            <code>obj</code> is non-extensible: We can’t add properties or change its prototype.
          </li>
        </ul>
      </li>
      <li>
        Only the top level of <code>obj</code> is changed (shallow change). Nested objects are not affected.
      </li>
      <li>
        Related: <a href="#qref-Object.isExtensible"><code>Object.isExtensible()</code></a>
      </li>
    </ul>
  </li>
  <li>
    <p><code id="qref-Object.isExtensible">Object.isExtensible(obj)</code> <span class="ibox ibox-small" size="small">ES5</span></p>
    <ul>
      <li>
        Returns <code>true</code> if <code>obj</code> is extensible and <code>false</code> if it isn’t.
      </li>
      <li>
        Related: <a href="#qref-Object.preventExtensions"><code>Object.preventExtensions()</code></a>
      </li>
    </ul>
  </li>
  <li>
    <p><code id="qref-Object.seal">Object.seal(obj)</code> <span class="ibox ibox-small" size="small">ES5</span></p>
    <ul>
      <li>
        Seals <code>obj</code> and returns it.
      </li>
      <li>
        Effect:
        <ul>
          <li>
            <code>obj</code> is non-extensible: We can’t add properties or change its prototype.
          </li>
          <li>
            <code>obj</code> is sealed: Additionally, all of its properties are unconfigurable.
          </li>
        </ul>
      </li>
      <li>
        Only the top level of <code>obj</code> is changed (shallow change). Nested objects are not affected.
      </li>
      <li>
        Related: <a href="#qref-Object.isSealed"><code>Object.isSealed()</code></a>
      </li>
    </ul>
  </li>
  <li>
    <p><code id="qref-Object.isSealed">Object.isSealed(obj)</code> <span class="ibox ibox-small" size="small">ES5</span></p>
    <ul>
      <li>
        Returns <code>true</code> if <code>obj</code> is sealed and <code>false</code> if it isn’t.
      </li>
      <li>
        Related: <a href="#qref-Object.seal"><code>Object.seal()</code></a>
      </li>
    </ul>
  </li>
  <li>
    <p><code id="qref-Object.freeze">Object.freeze(obj)</code> <span class="ibox ibox-small" size="small">ES5</span></p>
    <ul>
      <li>
        Freezes <code>obj</code> and returns it.
      </li>
      <li>
        Effect:
        <ul>
          <li>
            <code>obj</code> is non-extensible: We can’t add properties or change its prototype.
          </li>
          <li>
            <code>obj</code> is sealed: Additionally, all of its properties are unconfigurable.
          </li>
          <li>
            <code>obj</code> is frozen: Additionally, all of its properties are non-writable.
          </li>
        </ul>
      </li>
      <li>
        Only the top level of <code>obj</code> is changed (shallow change). Nested objects are not affected.
      </li>
      <li>
        Related: <a href="#qref-Object.isFrozen"><code>Object.isFrozen()</code></a>
      </li>
    </ul>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> frozen = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">5</span> });</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isFrozen</span>(frozen), <span class="hljs-literal">true</span></code>
<code>);</code>
<code>assert.<span class="hljs-title function_">throws</span>(</code>
<code>  <span class="hljs-function">() =&gt;</span> frozen.<span class="hljs-property">x</span> = <span class="hljs-number">7</span>,</code>
<code>  {</code>
<code>    <span class="hljs-attr">name</span>: <span class="hljs-string">'TypeError'</span>,</code>
<code>    <span class="hljs-attr">message</span>: <span class="hljs-regexp">/^Cannot assign to read only property 'x'/</span>,</code>
<code>  }</code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Object.isFrozen">Object.isFrozen(obj)</code> <span class="ibox ibox-small" size="small">ES5</span></p>
    <ul>
      <li>
        Returns <code>true</code> if <code>obj</code> is frozen.
      </li>
      <li>
        Related: <a href="#qref-Object.freeze"><code>Object.freeze()</code></a>
      </li>
    </ul>
  </li>
</ul>
<h4 id="object-miscellaneous"><a class="heading-id-link" href="#object-miscellaneous">30.12.5 <code>Object.*</code>: miscellaneous</a></h4>
<ul>
  <li>
    <p><code id="qref-Object.assign">Object.assign(target, ...sources)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>Assigns all enumerable own string-keyed properties of each of the <code>sources</code> to <code>target</code> and returns <code>target</code>.</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> obj = {<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">1</span>};</span></code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(obj, {<span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">2</span>}, {<span class="hljs-attr">d</span>: <span class="hljs-number">3</span>})</span></code>
<code>{ a: 1, b: 2, c: 2, d: 3 }</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">obj</span></code>
<code>{ a: 1, b: 2, c: 2, d: 3 }</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Object.groupBy">Object.groupBy(items, computeGroupKey)</code> <span class="ibox ibox-small" size="small">ES2024</span></p>
<pre class="language-ts">
<code><span class="hljs-title class_">Object</span>.<span class="hljs-property">groupBy</span>&lt;K <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PropertyKey</span>, T&gt;(</code>
<code>  <span class="hljs-attr">items</span>: <span class="hljs-title class_">Iterable</span>&lt;T&gt;,</code>
<code>  <span class="hljs-attr">computeGroupKey</span>: <span class="hljs-function">(<span class="hljs-params">item: T, index: <span class="hljs-built_in">number</span></span>) =&gt;</span> K,</code>
<code>): {[<span class="hljs-attr">key</span>: K]: <span class="hljs-title class_">Array</span>&lt;T&gt;}</code>
</pre>
    <ul>
      <li>
        The callback <code>computeGroupKey</code> returns a <em>group key</em> for each of the <code>items</code>.
      </li>
      <li>
        The result of <code>Object.groupBy()</code> is an object where:
        <ul>
          <li>
            The key of each property is a group key and
          </li>
          <li>
            its value is an Array with all items that have that group key.
          </li>
        </ul>
      </li>
    </ul>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">groupBy</span>(</code>
<code>    [<span class="hljs-string">'orange'</span>, <span class="hljs-string">'apricot'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'apple'</span>, <span class="hljs-string">'blueberry'</span>],</code>
<code>    <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> str[<span class="hljs-number">0</span>] <span class="hljs-comment">// compute group key</span></code>
<code>  ),</code>
<code>  {</code>
<code>    <span class="hljs-attr">__proto__</span>: <span class="hljs-literal">null</span>,</code>
<code>    <span class="hljs-string">'o'</span>: [<span class="hljs-string">'orange'</span>],</code>
<code>    <span class="hljs-string">'a'</span>: [<span class="hljs-string">'apricot'</span>, <span class="hljs-string">'apple'</span>],</code>
<code>    <span class="hljs-string">'b'</span>: [<span class="hljs-string">'banana'</span>, <span class="hljs-string">'blueberry'</span>],</code>
<code>  }</code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Object.is">Object.is(value1, value2)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>Is mostly equivalent to <code>value1 === value2</code> – with two exceptions:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">NaN</span> === <span class="hljs-title class_">NaN</span></span></code>
<code>false</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">NaN</span>)</span></code>
<code>true</code>
<code/>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">-<span class="hljs-number">0</span> === <span class="hljs-number">0</span></span></code>
<code>true</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(-<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></code>
<code>false</code>
</pre>
    <ul>
      <li>
        Considering all <code>NaN</code> values to be equal can be useful – e.g., when searching for a value in an Array.
      </li>
      <li>
        The value <code>-0</code> is rare and it’s usually best to pretend it is the same as <code>0</code>.
      </li>
    </ul>
  </li>
</ul>
<h4 id="objectprototype"><a class="heading-id-link" href="#objectprototype">30.12.6 <code>Object.prototype.*</code></a></h4>
<p><code>Object.prototype</code> has the following properties:</p>
<ul>
  <li>
    <code>Object.prototype.__proto__</code> (getter and setter)
  </li>
  <li>
    <code>Object.prototype.hasOwnProperty()</code>
  </li>
  <li>
    <code>Object.prototype.isPrototypeOf()</code>
  </li>
  <li>
    <code>Object.prototype.propertyIsEnumerable()</code>
  </li>
  <li>
    <code>Object.prototype.toLocaleString()</code>
  </li>
  <li>
    <code>Object.prototype.toString()</code>
  </li>
  <li>
    <code>Object.prototype.valueOf()</code>
  </li>
</ul>
<p>These methods are explained in detail in <a href="ch_classes.html#quickref-object-prototype">“Quick reference: <code>Object.prototype.*</code>” (§31.10)</a>.</p>
<h3 id="quickref-reflect"><a class="heading-id-link" href="#quickref-reflect">30.13 Quick reference: <code>Reflect</code></a></h3>
<p><code>Reflect</code> provides functionality for <a href="https://exploringjs.com/deep-js/ch_proxies.html">JavaScript proxies</a> that is also occasionally useful elsewhere:</p>
<ul>
  <li>
    <p><code id="qref-Reflect.apply">Reflect.apply(target, thisArgument, argumentsList)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <ul>
      <li>
        Invokes <code>target</code> with the arguments provided by <code>argumentsList</code> and <code>this</code> set to <code>thisArgument</code>.
      </li>
      <li>
        Equivalent to <code>target.apply(thisArgument, argumentsList)</code>
      </li>
    </ul>
  </li>
  <li>
    <p><code id="qref-Reflect.construct">Reflect.construct(target, argumentsList, newTarget=target)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <ul>
      <li>
        The <code>new</code> operator as a function.
      </li>
      <li>
        <code>target</code> is the constructor to invoke.
      </li>
      <li>
        The optional parameter <code>newTarget</code> points to the constructor that started the current chain of constructor calls.
      </li>
    </ul>
  </li>
  <li>
    <p><code id="qref-Reflect.defineProperty">Reflect.defineProperty(target, propertyKey, propDesc)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <ul>
      <li>
        Similar to <code>Object.defineProperty()</code>.
      </li>
      <li>
        Returns a boolean indicating whether or not the operation succeeded.
      </li>
    </ul>
  </li>
  <li>
    <p><code id="qref-Reflect.deleteProperty">Reflect.deleteProperty(target, propertyKey)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>The <code>delete</code> operator as a function. It works slightly differently, though:</p>
    <ul>
      <li>
        It returns <code>true</code> if it successfully deleted the property or if the property never existed.
      </li>
      <li>
        It returns <code>false</code> if the property could not be deleted and still exists.
      </li>
    </ul>
    <p>In sloppy mode, the <code>delete</code> operator returns the same results as this method. But in strict mode, it throws a <code>TypeError</code> instead of returning <code>false</code>.</p>
    <p>The only way to protect properties from deletion is by making them non-configurable.</p>
  </li>
  <li>
    <p><code id="qref-Reflect.get">Reflect.get(target, propertyKey, receiver=target)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>A function that gets properties. The optional parameter <code>receiver</code> is needed if <code>get</code> reaches a getter (somewhere in the prototype chain). Then it provides the value for <code>this</code>.</p>
  </li>
  <li>
    <p><code id="qref-Reflect.getOwnPropertyDescriptor">Reflect.getOwnPropertyDescriptor(target, propertyKey)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>Same as <code>Object.getOwnPropertyDescriptor()</code>.</p>
  </li>
  <li>
    <p><code id="qref-Reflect.getPrototypeOf">Reflect.getPrototypeOf(target)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>Same as <code>Object.getPrototypeOf()</code>.</p>
  </li>
  <li>
    <p><code id="qref-Reflect.has">Reflect.has(target, propertyKey)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>The <code>in</code> operator as a function.</p>
  </li>
  <li>
    <p><code id="qref-Reflect.isExtensible">Reflect.isExtensible(target)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>Same as <code>Object.isExtensible()</code>.</p>
  </li>
  <li>
    <p><code id="qref-Reflect.ownKeys">Reflect.ownKeys(target)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>Returns all own property keys (strings and symbols) in an Array.</p>
  </li>
  <li>
    <p><code id="qref-Reflect.preventExtensions">Reflect.preventExtensions(target)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <ul>
      <li>
        Similar to <code>Object.preventExtensions()</code>.
      </li>
      <li>
        Returns a boolean indicating whether or not the operation succeeded.
      </li>
    </ul>
  </li>
  <li>
    <p><code id="qref-Reflect.set">Reflect.set(target, propertyKey, value, receiver=target)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <ul>
      <li>
        Sets properties.
      </li>
      <li>
        Returns a boolean indicating whether or not the operation succeeded.
      </li>
    </ul>
  </li>
  <li>
    <p><code id="qref-Reflect.setPrototypeOf">Reflect.setPrototypeOf(target, proto)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <ul>
      <li>
        Same as <code>Object.setPrototypeOf()</code>.
      </li>
      <li>
        Returns a boolean indicating whether or not the operation succeeded.
      </li>
    </ul>
  </li>
</ul>
<h4 id="reflect-vs-object"><a class="heading-id-link" href="#reflect-vs-object">30.13.1 <code>Reflect.*</code> vs. <code>Object.*</code></a></h4>
<p>General recommendations:</p>
<ul>
  <li>
    Use <code>Object.*</code> whenever you can.
  </li>
  <li>
    Use <code>Reflect.*</code> when working with <a href="https://exploringjs.com/deep-js/ch_proxies.html">ECMAScript proxies</a>. Its methods are well adapted to ECMAScript’s meta-object protocol (MOP) which also return boolean error flags instead of exceptions.
  </li>
</ul>
<p>What are use cases for <code>Reflect</code> beyond proxies?</p>
<ul>
  <li>
    <p><code>Reflect.ownKeys()</code> lists all own property keys – functionality that isn’t provided anywhere else.</p>
  </li>
  <li>
    <p>Same functionality as <code>Object</code> but different return values: <code>Reflect</code> duplicates the following methods of <code>Object</code>, but its methods return booleans indicating whether the operation succeeded (where the <code>Object</code> methods return the object that was modified).</p>
    <ul>
      <li>
        <code>Object.defineProperty(obj, propKey, propDesc)</code>
      </li>
      <li>
        <code>Object.preventExtensions(obj)</code>
      </li>
      <li>
        <code>Object.setPrototypeOf(obj, proto)</code>
      </li>
    </ul>
  </li>
  <li>
    <p>Operators as functions: The following <code>Reflect</code> methods implement functionality that is otherwise only available via operators:</p>
    <ul>
      <li>
        <code>Reflect.construct(target, argumentsList, newTarget=target)</code>
      </li>
      <li>
        <code>Reflect.deleteProperty(target, propertyKey)</code>
      </li>
      <li>
        <code>Reflect.get(target, propertyKey, receiver=target)</code>
      </li>
      <li>
        <code>Reflect.has(target, propertyKey)</code>
      </li>
      <li>
        <code>Reflect.set(target, propertyKey, value, receiver=target)</code>
      </li>
    </ul>
  </li>
  <li>
    <p>Shorter version of <code>apply()</code>: If we want to be completely safe about invoking the method <code>apply()</code> on a function, we can’t do so via dynamic dispatch, because the function may have an own property with the key <code>'apply'</code>:</p>
<pre class="language-js">
<code>func.<span class="hljs-title function_">apply</span>(thisArg, argArray) <span class="hljs-comment">// not safe</span></code>
<code><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">apply</span>.<span class="hljs-title function_">call</span>(func, thisArg, argArray) <span class="hljs-comment">// safe</span></code>
</pre>
    <p>Using <code>Reflect.apply()</code> is shorter:</p>
<pre class="language-js">
<code><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(func, thisArg, argArray)</code>
</pre>
  </li>
  <li>
    <p>No exceptions when deleting properties: the <code>delete</code> operator throws in strict mode if we try to delete a non-configurable own property. <code>Reflect.deleteProperty()</code> returns <code>false</code> in that case.</p>
  </li>
</ul>

    
      
</body>
</html>