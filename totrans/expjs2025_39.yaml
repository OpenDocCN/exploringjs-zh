- en: 32 Synchronous iteration ES6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_sync-iteration.html](https://exploringjs.com/js/book/ch_sync-iteration.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[32.1 What is synchronous iteration about?](#motivation-sync-iteration)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.2 Core iteration roles: iterables and iterators](#iterable-iterator-iteratorresult)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.3 Iterating over data](#iterating-over-data)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.3.1 Manually iterating over data](#manually-iterating-over-data)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.3.2 Using `while` to iterate manually](#using-while-to-iterate-manually)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.3.3 Retrieving an iterator via `Iterator.from()` ^(ES2024)](#retrieving-an-iterator-via-iteratorfrom-es2024)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.3.4 Iterating via iteration-based language constructs](#iterating-via-iterationbased-language-constructs)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.3.5 Converting iterables to Arrays: `[...i]` and `Array.from(i)`](#converting-iterables-to-arrays-i-and-arrayfromi)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.4 Processing iterables via generators](#processing-iterables-via-generators)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.5 The inheritance of the iteration API (advanced)](#the-inheritance-of-the-iteration-api-advanced)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.5.1 Array iterators](#array-iterators)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.5.2 Generator objects](#generator-objects)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.6 Iterable iterators](#iterable-iterators)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.6.1 Why are the built-in iterators iterable?](#why-are-the-builtin-iterators-iterable)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.6.2 An iterator returns itself when asked for an iterator](#an-iterator-returns-itself-when-asked-for-an-iterator)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.6.3 Iteration quirk: two kinds of iterables](#one-time-iterable-vs-many-times-iterable)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.7 Class `Iterator` and iterator helper methods ^(ES2025)](#class-iterator)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.7.1 `Iterator.prototype.*` methods](#iteratorprototype-methods)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.7.2 The benefits of iterator helper methods](#benefits-of-iterator-helper-methods)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.7.3 `Iterator.from()`: creating API iterators](#Iterator.from)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.7.4 Iterator methods change how we use iteration](#iterator-methods-change-how-we-use-iteration)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.7.5 Upgrading a legacy iterable to the `Iterator` API](#upgrading-a-legacy-iterable-to-the-iterator-api)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.8 Grouping iterables ^(ES2024)](#grouping-sync-iterables)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.8.1 Choosing between `Map.groupBy()` and `Object.groupBy()`](#choosing-between-mapgroupby-and-objectgroupby)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.8.2 Example: handling cases](#example-handling-cases)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.8.3 Example: grouping by property value](#example-grouping-by-property-value)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.9 Quick reference: synchronous iteration](#quickref-sync-iteration)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.9.1 Synchronous iteration: data producers](#synchronous-iteration-data-producers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.9.2 Synchronous iteration: data consumers](#synchronous-iteration-data-consumers)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.10 Quick reference: class `Iterator` ^(ES2025)](#quickref-iterator)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.10.1 Creating iterators](#creating-iterators)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.10.2 `Iterator.*`](#iterator)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.10.3 `Iterator.prototype.*`: methods that pass indices to callbacks](#iteratorprototype-methods-that-pass-indices-to-callbacks)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.10.4 `Iterator.prototype.*`: methods that return iterators](#iteratorprototype-methods-that-return-iterators)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.10.5 `Iterator.prototype.*`: methods that return booleans](#iteratorprototype-methods-that-return-booleans)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.10.6 `Iterator.prototype.*`: methods that return other kinds of values](#iteratorprototype-methods-that-return-other-kinds-of-values)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.10.7 `Iterator.prototype.*`: other methods](#iteratorprototype-other-methods)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[32.1 What is synchronous iteration about?](#motivation-sync-iteration)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Synchronous iteration is a *protocol* (interfaces plus rules for using them)
    that connects two groups of entities in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data sources:** On one hand, data comes in all shapes and sizes. In JavaScript’s
    standard library, we have the linear data structure Array, the ordered collection
    Set (elements are ordered by time of addition), the ordered dictionary Map (entries
    are ordered by time of addition), and more. In libraries, we may find tree-shaped
    data structures and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data consumers:** On the other hand, we have a whole class of constructs
    and algorithms that only need to access their input *sequentially*: one value
    at a time, until all values were visited. Examples include the `for-of` loop and
    spreading into Array literals (via `...`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The iteration protocol connects these two groups via the interface `Iterable`:
    data sources deliver their contents sequentially “through it”; data consumers
    get their input from it.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/52bbdbeebda7e97eed377dd5c6cf02df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 32.1: Data consumers such as the `for-of` loop use the interface `Iterable`.
    Data sources such as `Arrays` implement that interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 32.1](#fig:iterable-implementers-clients) illustrates how iteration
    works: data consumers use the interface `Iterable`; data sources implement it.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **The JavaScript
    way of implementing interfaces**'
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, an object *implements* an interface if it has all the methods
    that it describes. The interfaces mentioned in this chapter only exist in the
    ECMAScript specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both sources and consumers of data profit from this arrangement:'
  prefs: []
  type: TYPE_NORMAL
- en: If we develop a new data structure, we only need to implement `Iterable` and
    a raft of tools can immediately be applied to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we write code that uses iteration, it automatically works with many sources
    of data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[32.2 Core iteration roles: iterables and iterators](#iterable-iterator-iteratorresult)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Two roles (described by interfaces) form the core of iteration ([figure 32.2](#fig:iteration-protocol)):'
  prefs: []
  type: TYPE_NORMAL
- en: An *iterable* is an object whose contents can be traversed sequentially.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An *iterator* is the pointer used for the traversal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/18a5343baba7051a9127cee5ee460844.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 32.2: Iteration has two main interfaces: `Iterable` and `Iterator`.
    The former has a method that returns the latter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are type definitions (in TypeScript’s notation) for the interfaces of
    the iteration protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1][PRE2][PRE3][PRE4]js[PRE5]js[PRE6]``js[PRE7]js[PRE8]js[PRE9]`js[PRE10]js[PRE11][PRE12][PRE13]js[PRE14]js[PRE15][PRE16]
    [PRE17] ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Implementing `.filter()` and `.map()` for Sets via iterator methods**    `exercises/sync-iteration/set-operations-via-iterators_test.mjs`    #####
    [32.7.2.2 Benefit: no intermediate Arrays and incremental processing](#benefit-no-intermediate-arrays-and-incremental-processing)    If
    we chain operations that return Arrays (line A, line B, line C) then each operation
    produces a new Array:    [PRE18]    The regular expression in line A contains
    [a lookbehind assertion](ch_regexps.html#regexp-lookbehind-assertions) which ensures
    that the lines returned by `.split()` includes line terminators.    In contrast,
    each operation (line A, line B, line C) in the following code returns an iterator
    and no intermediate Arrays are created:    [PRE19]   [PRE20][PRE21]``js[PRE22]``
    If we want `ValueIterable` to support the `Iterator` API, we have to make its
    iterators instances of `Iterator`:    [PRE23]    This is another option (albeit
    a less efficient one):    [PRE24]    We can also create a class for iterators:    [PRE25]    ###
    [32.8 Grouping iterables ^(ES2024)](#grouping-sync-iterables)    `Map.groupBy()`
    groups the items of an iterable into Map entries whose keys are provided by a
    callback:    [PRE26]    The items to be grouped can come from any iterable:    [PRE27]    There
    is also `Object.groupBy()` which produces an object instead of a Map:    [PRE28]    ####
    [32.8.1 Choosing between `Map.groupBy()` and `Object.groupBy()`](#choosing-between-mapgroupby-and-objectgroupby)    *   Do
    you want group keys other than strings and symbols?     *   Then you need a Map.
    Objects can only have strings and symbols as keys. *   Do you want to destructure
    the result of `.groupBy()` (see example later in this section)?     *   Then you
    need an object. *   Otherwise, you are free to choose what you prefer.    ####
    [32.8.2 Example: handling cases](#example-handling-cases)    The Promise combinator
    [`Promise.allSettled()`](ch_promises.html#Promise.allSettled) returns Arrays such
    as the following one:    [PRE29]    We can group the Array elements as follows:    [PRE30]   [PRE31]``
    [PRE32]` For this use case, `Object.groupBy()` works better because we can use
    destructuring (line A).    #### [32.8.3 Example: grouping by property value](#example-grouping-by-property-value)    In
    the next example, we’d like to group persons by country:    [PRE33]   [PRE34]
    For this use case, `Map.groupBy()` is a better choice because we can use arbitrary
    keys in Maps whereas in objects, keys are limited to strings and symbols.    ![Icon
    “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Using
    `Map.groupBy()` for an Array of objects**    `exercises/sync-iteration/count-cities_test.mjs`    ###
    [32.9 Quick reference: synchronous iteration](#quickref-sync-iteration)    ####
    [32.9.1 Synchronous iteration: data producers](#synchronous-iteration-data-producers)    These
    data structures are iterable:    *   Strings *   Arrays *   Sets *   Maps *   (Browsers:
    DOM data structures)    The following data structures have the methods `.keys()`,
    `.values()`, and `.entries()` that return iterables that are not Arrays:    *   Arrays
    *   Sets *   Maps    As an aside – the following static methods list property
    keys, values and entries (they are not normal methods because those can be accidentally
    overridden). They return Arrays.    *   `Object.keys(obj)` *   `Object.values(obj)`
    *   `Object.entries(obj)`    Synchronous generator functions and methods expose
    their yielded values via iterable objects that they return:    [PRE35]js   [PRE36]`js
    [PRE37]js`` [PRE38]js[PRE39][PRE40][PRE41][PRE42]js[PRE43]js` [PRE44]`js`` [PRE45]`js[PRE46][PRE47][PRE48]
    [PRE49][PRE50][PRE51][PRE52][PRE53]`` [PRE54][PRE55][PRE56] [PRE57]`js[PRE58]js[PRE59]js[PRE60]`'
  prefs: []
  type: TYPE_NORMAL
