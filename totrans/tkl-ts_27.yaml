- en: 22 Type guards and assertion functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/tackling-ts/ch_type-guards-assertion-functions.html](https://exploringjs.com/tackling-ts/ch_type-guards-assertion-functions.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 22.1 [When are static types too general?](ch_type-guards-assertion-functions.html#when-are-static-types-too-general)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.1.1 [Narrowing via `if` and type guards](ch_type-guards-assertion-functions.html#narrowing-via-if-and-type-guards)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.1.2 [Narrowing via `switch` and a type guard](ch_type-guards-assertion-functions.html#narrowing-via-switch-and-a-type-guard)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.1.3 [More cases of types being too general](ch_type-guards-assertion-functions.html#more-cases-of-types-being-too-general)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.1.4 [The type `unknown`](ch_type-guards-assertion-functions.html#the-type-unknown)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.2 [Narrowing via built-in type guards](ch_type-guards-assertion-functions.html#narrowing-via-built-in-type-guards)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.2.1 [Strict equality (`===`)](ch_type-guards-assertion-functions.html#strict-equality)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.2.2 [`typeof`, `instanceof`, `Array.isArray`](ch_type-guards-assertion-functions.html#typeof-instanceof-array.isarray)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.2.3 [Checking for distinct properties via the operator `in`](ch_type-guards-assertion-functions.html#checking-for-distinct-properties-via-the-operator-in)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.2.4 [Checking the value of a shared property (discriminated unions)](ch_type-guards-assertion-functions.html#checking-the-value-of-a-shared-property-discriminated-unions)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.2.5 [Narrowing dotted names](ch_type-guards-assertion-functions.html#narrowing-dotted-names)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.2.6 [Narrowing Array element types](ch_type-guards-assertion-functions.html#narrowing-array-element-types)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.3 [User-defined type guards](ch_type-guards-assertion-functions.html#user-defined-type-guards)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '22.3.1 [Example of a user-defined type guard: `isArrayWithInstancesOf()`](ch_type-guards-assertion-functions.html#example-of-a-user-defined-type-guard-isarraywithinstancesof)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '22.3.2 [Example of a user-defined type guard: `isTypeof()`](ch_type-guards-assertion-functions.html#example-of-a-user-defined-type-guard-istypeof)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.4 [Assertion functions](ch_type-guards-assertion-functions.html#assertion-functions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.4.1 [TypeScript’s support for assertion functions](ch_type-guards-assertion-functions.html#typescripts-support-for-assertion-functions)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '22.4.2 [Asserting a boolean argument: `asserts «cond»`](ch_type-guards-assertion-functions.html#asserting-a-boolean-argument-asserts-cond)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '22.4.3 [Asserting the type of an argument: `asserts «arg» is «type»`](ch_type-guards-assertion-functions.html#asserting-the-type-of-an-argument-asserts-arg-is-type)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '22.5 [Quick reference: user-defined type guards and assertion functions](ch_type-guards-assertion-functions.html#quick-reference-user-defined-type-guards-and-assertion-functions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.5.1 [User-defined type guards](ch_type-guards-assertion-functions.html#user-defined-type-guards-1)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.5.2 [Assertion functions](ch_type-guards-assertion-functions.html#assertion-functions-1)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.6 [Alternatives to assertion functions](ch_type-guards-assertion-functions.html#alternatives-to-assertion-functions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '22.6.1 [Technique: forced conversion](ch_type-guards-assertion-functions.html#technique-forced-conversion)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '22.6.2 [Technique: throwing an exception](ch_type-guards-assertion-functions.html#technique-throwing-an-exception)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '22.7 [`@hqoss/guards`: library with type guards](ch_type-guards-assertion-functions.html#hqossguards-library-with-type-guards)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'In TypeScript, a value can have a type that is too general for some operations
    – for example, a union type. This chapter answers the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is *narrowing* of types?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spoiler: *Narrowing* means changing the static type `T` of a storage location
    (such as a variable or a property) to a subset of `T`. For example, it is often
    useful to narrow the type `null|string` to the type `string`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What are *type guards* and *assertion functions* and how can we use them to
    narrow types?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spoiler: `typeof` and `instanceof` are type guards.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.1 When are static types too general?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To see how a static type can be too general, consider the following function
    `getScore()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The skeleton of `getScore()` looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Inside the body of `getScore()`, we don’t know if the type of `value` `number`
    or `string`. Before we do, we can’t really work with `value`.
  prefs: []
  type: TYPE_NORMAL
- en: 22.1.1 Narrowing via `if` and type guards
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The solution is to check the type of `value` at runtime, via `typeof` (line
    A and line B):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this chapter, we interpret types as sets of values. (For more information
    on this interpretation and another one, see [[content not included]](ch_missing-chapters-online.html).)
  prefs: []
  type: TYPE_NORMAL
- en: Inside the then-blocks starting in line A and line B, the static type of `value`
    changes, due to the checks we performed. We are now working with subsets of the
    original type `number|string`. This way of reducing the size of a type is called
    *narrowing*. Checking the result of `typeof` and similar runtime operations are
    called *type guards*.
  prefs: []
  type: TYPE_NORMAL
- en: Note that narrowing does not change the original type of `value`, it only makes
    it more specific as we pass more checks.
  prefs: []
  type: TYPE_NORMAL
- en: 22.1.2 Narrowing via `switch` and a type guard
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Narrowing also works if we use `switch` instead of `if`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 22.1.3 More cases of types being too general
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These are more examples of types being too general:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nullable types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Discriminated unions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Types of optional parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that these types are all union types!
  prefs: []
  type: TYPE_NORMAL
- en: 22.1.4 The type `unknown`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a value has [the type `unknown`](ch_any-unknown.html), we can do almost
    nothing with it and have to narrow its type first (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words: The type `unknown` is too general and we must narrow it. In
    a way, `unknown` is also a union type (the union of all types).'
  prefs: []
  type: TYPE_NORMAL
- en: 22.2 Narrowing via built-in type guards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have seen, a *type guard* is an operation that returns either `true` or
    `false` – depending on whether its operand meets certain criteria at runtime.
    TypeScript’s type inference supports type guards by narrowing the static type
    of an operand when the result is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 22.2.1 Strict equality (`===`)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Strict equality works as a type guard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For some union types, we can use `===` to differentiate between their components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using `===` for including and `!===` for excluding a union type component only
    works if that component is a *singleton type* (a set with one member). The type
    `null` is a singleton type. Its only member is the value `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 22.2.2 `typeof`, `instanceof`, `Array.isArray`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These are three common built-in type guards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note how the static type of `value` is narrowed inside the then-blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 22.2.3 Checking for distinct properties via the operator `in`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If used to check for distinct properties, the operator `in` is a type guard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the following check would not have worked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The problem in this case is that, without narrowing, we can’t access property
    `.second` of a value whose type is `FirstOrSecond`.
  prefs: []
  type: TYPE_NORMAL
- en: 22.2.3.1 The operator `in` doesn’t narrow non-union types
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Alas, `in` only helps us with union types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 22.2.4 Checking the value of a shared property (discriminated unions)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a discriminated union, the components of a union type have one or more properties
    in common whose values are different for each component. Such properties are called
    *discriminants*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking the value of a discriminant is a type guard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, `.kind` is a discriminant: Each components of the
    union type `Attendee` has this property, with a unique value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An `if` statement and equality checks work similarly to a `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 22.2.5 Narrowing dotted names
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can also narrow the types of properties (even of nested ones that we access
    via chains of property names):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a look at several locations in the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Line A: We narrowed the type of `arg.prop` via a type guard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line B: Callbacks may be executed much later (think of asynchronous code),
    which is why TypeScript undoes narrowing inside callbacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line C: The preceding assignment also undid narrowing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.2.6 Narrowing Array element types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 22.2.6.1 The Array method `.every()` does not narrow
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If we use `.every()` to check that all Array elements are non-nullish, TypeScript
    does not narrow the type of `mixedValues` (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that `mixedValues` has to be read-only. If it weren’t, another reference
    to it would statically allow us to push `null` into `mixedValues` inside the `if`
    statement. But that renders the narrowed type of `mixedValues` incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code uses the following *user-defined type guard* (more on what
    that is soon):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`NonNullable<Union>` (line A) is [a utility type](https://www.typescriptlang.org/docs/handbook/utility-types.html)
    that removes the types `undefined` and `null` from union type `Union`.'
  prefs: []
  type: TYPE_NORMAL
- en: 22.2.6.2 The Array method `.filter()` produces Arrays with narrower types
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`.filter()` produces Arrays that have narrower types (i.e., it doesn’t really
    narrow existing types):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Alas, we must use a type guard function directly – an arrow function with a
    type guard is not enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 22.3 User-defined type guards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'TypeScript lets us define our own type guards – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The return type `value is Function` is a *type predicate*. It is part of the
    type signature of `isFunction()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A user-defined type guard must always return booleans. If `isFunction(x)` returns
    `true`, TypeScript narrows the type of the actual argument `x` to `Function`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that TypeScript doesn’t care how we compute the result of a user-defined
    type guard. That gives us a lot of freedom w.r.t. the checks we use. For example,
    we could have implemented `isFunction()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Alas, we have to use the type `any` for the parameter `value` because the type
    `unknown` does not let us make the function call in line A.
  prefs: []
  type: TYPE_NORMAL
- en: '22.3.1 Example of a user-defined type guard: `isArrayWithInstancesOf()`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In line A, we can see that the inferred type of `arr` is *not* `Array<T>`,
    but our checks have ensured that it currently is. That’s why we can return `true`.
    TypeScript trusts us and narrows to `Array<T>` when we use `isArrayWithInstancesOf()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '22.3.2 Example of a user-defined type guard: `isTypeof()`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 22.3.2.1 A first attempt
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This is a first attempt to implement `typeof` in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Ideally, we’d be able to specify the expected type of `value` via a string
    (i.e., one of the results of `typeof`). But then we would have to derive the type
    `T` from that string and it’s not immediately obvious how to do that (there is
    a way, as we’ll see soon). As a workaround, we specify `T` via a member `prim`
    of `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 22.3.2.2 Using overloading
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A better solution is to use overloading (several cases are omitted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: (This approach is an idea by [Nick Fisher](https://twitter.com/spadgos/status/1266839605883666432).)
  prefs: []
  type: TYPE_NORMAL
- en: 22.3.2.3 Using an interface as a type map
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An alternative is to use an interface as a map from strings to types (several
    cases are omitted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: (This approach is an idea by [Ran Lottem](https://dev.to/krumpet/generic-type-guard-in-typescript-258l).)
  prefs: []
  type: TYPE_NORMAL
- en: 22.4 Assertion functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An assertion function checks if its parameter fulfills certain criteria and
    throws an exception if it doesn’t. For example, one assertion function supported
    by many languages, is `assert()`. `assert(cond)` throws an exception if the boolean
    condition `cond` is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Node.js, `assert()` is supported via [the built-in module `assert`](https://nodejs.org/api/assert.html).
    The following code uses it in line A:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 22.4.1 TypeScript’s support for assertion functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TypeScript’s type inference provides special support for assertion functions,
    if we mark such functions with *assertion signatures* as return types. W.r.t.
    how and what we can return from a function, an assertion signature is equivalent
    to `void`. However, it additionally triggers narrowing.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of assertion signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Asserting a boolean argument: `asserts «cond»`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Asserting the type of an argument: `asserts «arg» is «type»`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '22.4.2 Asserting a boolean argument: `asserts «cond»`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the following example, the assertion signature `asserts condition` states
    that the parameter `condition` must be `true`. Otherwise, an exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how `assertTrue()` causes narrowing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We are using the argument `value instanceof Set` similarly to a type guard,
    but instead of skipping part of a conditional statement, `false` triggers an exception.
  prefs: []
  type: TYPE_NORMAL
- en: '22.4.3 Asserting the type of an argument: `asserts «arg» is «type»`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the following example, the assertion signature `asserts value is number`
    states that the parameter `value` must have the type `number`. Otherwise, an exception
    is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, calling the assertion function, narrows the type of its argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '22.4.3.1 Example assertion function: adding properties to an object'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The function `addXY()` adds properties to existing objects and updates their
    types accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: An intersection type `S & T` has the properties of both type `S` and type `T`.
  prefs: []
  type: TYPE_NORMAL
- en: '22.5 Quick reference: user-defined type guards and assertion functions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 22.5.1 User-defined type guards
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Type predicate: `value is string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Result: `boolean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.5.2 Assertion functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '22.5.2.1 Assertion signature: `asserts «cond»`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Assertion signature: `asserts condition`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Result: `void`, exception'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '22.5.2.2 Assertion signature: `asserts «arg» is «type»`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Assertion signature: `asserts value is string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Result: `void`, exception'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 22.6 Alternatives to assertion functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '22.6.1 Technique: forced conversion'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An assertion function narrows the type of an existing value. A forced conversion
    function returns an existing value with a new type – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding assertion function looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Forced conversion is a versatile technique with uses beyond those of assertion
    functions. For example, we can convert:'
  prefs: []
  type: TYPE_NORMAL
- en: From an input format (think JSON schema) that is easy to write
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Into an output format that is easy to work with in code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information, see [[content not included]](ch_missing-chapters-online.html).
  prefs: []
  type: TYPE_NORMAL
- en: '22.6.2 Technique: throwing an exception'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of the `if` statement that starts in line A, we also could have used
    an assertion function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Throwing an exception is a quick alternative if we don’t want to write such
    a function. Similarly to calling an assertion function, this technique also updates
    the static type.
  prefs: []
  type: TYPE_NORMAL
- en: '22.7 `@hqoss/guards`: library with type guards'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[The library `@hqoss/guards`](https://github.com/hqoss/guards) provides a collection
    of type guards for TypeScript – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Primitives: `isBoolean()`, `isNumber()`, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Specific types: `isObject()`, `isNull()`, `isFunction()`, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Various checks: `isNonEmptyArray()`, `isInteger()`, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/tackling-ts/issues/23)'
  prefs: []
  type: TYPE_NORMAL
