["```ts\nfunction repeat1(str: string, times: number): string { // (A)\n return str.repeat(times);\n}\nassert.equal(\n repeat1('*', 5), '*****'\n);\n\n```", "```ts\nconst repeat2 = (str: string, times: number): string => {\n return str.repeat(times);\n};\n\n```", "```ts\nconst repeat3 = (str: string, times: number): string =>\n str.repeat(times);\n\n```", "```ts\ntype Repeat = (str: string, times: number) => string;\n\n```", "```ts\ninterface Repeat {\n (str: string, times: number): string; // (A)\n}\n\n```", "```ts\ninterface Incrementor1 {\n (x: number): number;\n increment: number;\n}\n\n```", "```ts\ntype Incrementor2 =\n & ((x: number) => number)\n & { increment: number }\n;\n\n```", "```ts\ntype StringPredicate = (str: string) => boolean;\n\n```", "```ts\nconst pred1: StringPredicate = (str) => str.length > 0;\n\n```", "```ts\nfunction pred2(str: string): boolean {\n return str.length > 0;\n}\n\n```", "```ts\nconst pred2ImplementsStringPredicate: StringPredicate = pred2;\npred2 satisfies StringPredicate;\n\n```", "```ts\nassertType<StringPredicate>(pred2);\ntype _ = Assert<Assignable<\n StringPredicate,\n typeof pred2\n>>;\n\n```", "```ts\nfunction pred3(\n ...[str]: Parameters<StringPredicate>\n): ReturnType<StringPredicate>\n{\n return str.length > 0;\n}\n\n```", "```ts\nfunction twice(str: string) {\n return str + str;\n}\n\n```", "```ts\ntype StringMapFunction = (str: string) => string;\nconst twice: StringMapFunction = (str) => str + str; // (A)\n\n```", "```ts\nassert.deepEqual(\n ['a', 'b', 'c'].map((str) => str + str),\n ['aa', 'bb', 'cc']\n);\n\n```", "```ts\ninterface Array<T> {\n map<U>(\n callbackfn: (value: T, index: number, array: T[]) => U,\n thisArg?: any\n ): U[];\n // ···\n}\n\n```", "```ts\nfunction trim1(str?: string): string {\n // Internal type of str:\n assertType<string | undefined>(str);\n\n if (str === undefined) {\n return '';\n }\n return str.trim();\n}\n\n// External type of trim1:\ntype _ = Assert<Equal<\n typeof trim1,\n (str?: string | undefined) => string\n>>;\n\n```", "```ts\nassert.equal(\n trim1('\\n  abc \\t'), 'abc'\n);\n\nassert.equal(\n trim1(), ''\n);\n\n// `undefined` is equivalent to omitting the parameter\nassert.equal(\n trim1(undefined), ''\n);\n\n```", "```ts\ntype _ = Assert<Equal<\n (str?: string | undefined) => string,\n (str?: string) => string\n>>;\n\n```", "```ts\nfunction trim2(str: string | undefined): string {\n // Internal type of str:\n assertType<string | undefined>(str);\n\n if (str === undefined) {\n return '';\n }\n return str.trim();\n}\n\n// External type of trim2:\ntype _ = Assert<Equal<\n typeof trim2,\n (str: string | undefined) => string\n>>;\n\n```", "```ts\nassert.equal(\n trim2('\\n  abc \\t'), 'abc'\n);\n\n// @ts-expect-error: Expected 1 arguments, but got 0.\ntrim2(); // (A)\n\nassert.equal(\n trim2(undefined), '' // OK!\n);\n\n```", "```ts\nfunction trim3(str = ''): string {\n // Internal type of str:\n assertType<string>(str);\n\n return str.trim();\n}\n\n// External type of trim3:\ntype _ = Assert<Equal<\n typeof trim3,\n (str?: string | undefined) => string\n>>;\n\n```", "```ts\nassert.equal(\n trim3('\\n  abc \\t'), 'abc');\n\n// Omitting the parameter triggers the parameter default value:\nassert.equal(\n trim3(), '');\n\n// `undefined` is allowed and triggers the parameter default value:\nassert.equal(\n trim3(undefined), '');\n\n```", "```ts\nfunction trim4(str: string = ''): string {\n return str.trim();\n}\n\n```", "```ts\nfunction join(separator: string, ...parts: Array<string>) {\n return parts.join(separator);\n}\nassert.equal(\n join('-', 'state', 'of', 'the', 'art'),\n 'state-of-the-art');\n\n```", "```ts\nfunction repeat1(...[str, times]: [string, number]): string {\n return str.repeat(times);\n}\n\n```", "```ts\nfunction repeat2(str: string, times: number): string {\n return str.repeat(times);\n}\n\n```", "```ts\nassert.equal(\n padStart({str: '7', len: 3, fillStr: '0'}),\n '007'\n);\n\n```", "```ts\nfunction padStart(\n { str, len, fillStr = ' ' } // (A)\n : { str: string, len: number, fillStr: string } // (B)\n): string {\n return str.padStart(len, fillStr);\n}\n\n```", "```ts\nfunction padStart(\n { str, len, fillStr = ' ' }: PadStartArgs\n): string {\n return str.padStart(len, fillStr);\n}\ntype PadStartArgs = {\n str: string,\n len: number,\n fillStr: string,\n};\n\n```", "```ts\ninterface EventSource {\n addEventListener(\n type: string,\n listener: (this: EventSource, ev: Event) => any,\n options?: boolean | AddEventListenerOptions\n ): void;\n // ···\n}\n\n```", "```ts\nfunction toIsoString(this: Date): string {\n return this.toISOString();\n}\n\n// @ts-expect-error: Argument of type 'string' is not assignable to\n// parameter of type 'Date'.\nassert.throws(() => toIsoString.call('abc')); // (A) error\n\ntoIsoString.call(new Date()); // (B) OK\n\n```", "```ts\nconst obj = { toIsoString };\n// @ts-expect-error: The 'this' context of type\n// '{ toIsoString: (this: Date) => string; }' is not assignable to\n// method's 'this' of type 'Date'.\nassert.throws(() => obj.toIsoString()); // error\nobj.toIsoString.call(new Date()); // OK\n\n```", "```ts\nfunction throwError(message: string): never {\n throw new Error(message);\n}\nfunction infiniteLoop(): never {\n while (true) {}\n}\n\n```", "```ts\nfunction returnStringIfTrue(flag: boolean) {\n if (flag) {\n return 'abc';\n }\n throwError('Flag must be true'); // (A)\n}\ntype _ = Assert<Equal<\n ReturnType<typeof returnStringIfTrue>,\n string\n>>;\n\n```", "```ts\n// @ts-expect-error: Not all code paths return a value.\nfunction returnStringIfTrue(flag: boolean) {\n if (flag) {\n return 'abc';\n }\n}\ntype _ = Assert<Equal<\n ReturnType<typeof returnStringIfTrue>,\n 'abc' | undefined\n>>;\n\n```", "```ts\ninterface Customer {\n id: string;\n fullName: string;\n}\nconst jane = {id: '1234', fullName: 'Jane Bond'};\nconst lars = {id: '5678', fullName: 'Lars Croft'};\nconst idToCustomer = new Map<string, Customer>([\n ['1234', jane],\n ['5678', lars],\n]);\n\nassert.equal(\n getFullName(idToCustomer, '1234'), 'Jane Bond' // (A)\n);\nassert.equal(\n getFullName(lars), 'Lars Croft' // (B)\n);\n\n```", "```ts\nfunction getFullName(\n customerOrMap: Customer | Map<string, Customer>,\n id?: string\n): string {\n if (customerOrMap instanceof Map) {\n if (id === undefined) throw new Error();\n const customer = customerOrMap.get(id);\n if (customer === undefined) {\n throw new Error('Unknown ID: ' + id);\n }\n customerOrMap = customer;\n } else {\n if (id !== undefined) throw new Error();\n }\n return customerOrMap.fullName;\n}\n\n```", "```ts\nassert.throws(() => getFullName(idToCustomer)); // missing ID\nassert.throws(() => getFullName(lars, '5678')); // ID not allowed\n\n```", "```ts\nfunction getFullName(customer: Customer): string; // (A)\nfunction getFullName( // (B)\n map: Map<string, Customer>, id: string\n): string;\nfunction getFullName( // (C)\n customerOrMap: Customer | Map<string, Customer>,\n id?: string\n): string {\n // ···\n}\n\n// @ts-expect-error: Argument of type 'Map<string, Customer>' is not\n// assignable to parameter of type 'Customer'.\ngetFullName(idToCustomer); // missing ID\n\n// @ts-expect-error: Argument of type '{ id: string; fullName: string; }'\n// is not assignable to parameter of type 'Map<string, Customer>'.\n// [...]\ngetFullName(lars, '5678'); // ID not allowed\n\n```", "```ts\ninterface Customer {\n id: string;\n fullName: string;\n}\nfunction getFullName(\n ...args: // (A)\n | [customer: Customer]\n | [map: Map<string, Customer>, id: string]\n): string {\n if (args.length === 2) {\n // Type is narrowed:\n assertType<\n [map: Map<string, Customer>, id: string]\n >(args);\n const [map, id] = args;\n const customer = map.get(id);\n if (customer === undefined) {\n throw new Error('Unknown ID: ' + id);\n }\n return customer.fullName;\n } else {\n const [customer] = args;\n return customer.fullName;\n }\n}\n\n```", "```ts\n[ customer: Customer ]\n[ map: Map<string, Customer>, id: string ]\n\n```", "```ts\n[ Customer ]\n[ Map<string, Customer>, string ]\n\n```", "```ts\ninterface Customer {\n id: string;\n fullName: string;\n}\n\ninterface GetFullName {\n (customerOrMap: Customer): string;\n (customerOrMap: Map<string, Customer>, id: string): string;\n}\n\nconst getFullName: GetFullName = (\n customerOrMap: Customer | Map<string, Customer>,\n id?: string\n): string => {\n if (customerOrMap instanceof Map) {\n if (id === undefined) throw new Error();\n const customer = customerOrMap.get(id);\n if (customer === undefined) {\n throw new Error('Unknown ID: ' + id);\n }\n customerOrMap = customer;\n } else {\n if (id !== undefined) throw new Error();\n }\n return customerOrMap.fullName;\n}\n\n```", "```ts\nfunction addEventListener(\n elem: HTMLElement, type: 'click',\n listener: (event: MouseEvent) => void\n): void;\nfunction addEventListener(\n elem: HTMLElement, type: 'keypress',\n listener: (event: KeyboardEvent) => void\n): void;\nfunction addEventListener( // (A)\n elem: HTMLElement, type: string,\n listener: (event: any) => void\n): void {\n elem.addEventListener(type, listener); // (B)\n}\n\n```", "```ts\nclass StringBuilder {\n #data = '';\n\n add(num: number): this;\n add(bool: boolean): this;\n add(str: string): this;\n add(value: any): this {\n this.#data += String(value);\n return this;\n }\n\n toString() {\n return this.#data;\n }\n}\n\nconst sb = new StringBuilder();\nsb\n .add('I can see ')\n .add(3)\n .add(' monkeys!')\n;\nassert.equal(\n sb.toString(), 'I can see 3 monkeys!'\n)\n\n```", "```ts\ninterface ArrayConstructor {\n from<T>(arrayLike: ArrayLike<T>): T[];\n from<T, U>(\n arrayLike: ArrayLike<T>,\n mapfn: (v: T, k: number) => U,\n thisArg?: any\n ): U[];\n}\n\n```", "```ts\nconst targetFunc: Trg = sourceFunc;\n\n```", "```ts\nconst trg1: (x: RegExp) => Object = (x: Object) => /abc/;\n\n```", "```ts\nconst trg2: () => void = () => new Date();\n\n```", "```ts\n// @ts-expect-error: Type '(x: string) => string' is not assignable to\n// type '() => string'.\nconst trg3: () => string = (x: string) => 'abc';\n\n```", "```ts\nconst trg4: (x: string) => string = () => 'abc';\n\n```", "```ts\n['a', 'b'].map(x => x + x)\n\n```", "```ts\nmap<U>(\n callback: (value: T, index: number, array: T[]) => U,\n thisArg?: any\n): U[];\n\n```"]