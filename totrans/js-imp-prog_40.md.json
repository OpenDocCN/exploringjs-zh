["```js\nconst emptyMap = new Map();\nassert.equal(emptyMap.size, 0);\n```", "```js\nconst map = new Map([\n [1, 'one'],\n [2, 'two'],\n [3, 'three'], // trailing comma is ignored\n]);\n```", "```js\nconst map = new Map()\n .set(1, 'one')\n .set(2, 'two')\n .set(3, 'three');\n```", "```js\nconst original = new Map()\n .set(false, 'no')\n .set(true, 'yes');\n\nconst copy = new Map(original);\nassert.deepEqual(original, copy);\n```", "```js\nconst map = new Map();\n\nmap.set('foo', 123);\n\nassert.equal(map.get('foo'), 123);\n// Unknown key:\nassert.equal(map.get('bar'), undefined);\n// Use the default value '' if an entry is missing:\nassert.equal(map.get('bar') ?? '', '');\n```", "```js\nconst map = new Map([['foo', 123]]);\n\nassert.equal(map.has('foo'), true);\nassert.equal(map.delete('foo'), true)\nassert.equal(map.has('foo'), false)\n```", "```js\nconst map = new Map()\n .set('foo', true)\n .set('bar', false)\n;\n\nassert.equal(map.size, 2)\nmap.clear();\nassert.equal(map.size, 0)\n```", "```js\nconst map = new Map()\n .set(false, 'no')\n .set(true, 'yes')\n;\n\nfor (const key of map.keys()) {\n console.log(key);\n}\n// Output:\n// false\n// true\n```", "```js\nassert.deepEqual(\n Array.from(map.keys()),\n [false, true]);\n```", "```js\nconst map = new Map()\n .set(false, 'no')\n .set(true, 'yes')\n;\n\nfor (const entry of map.entries()) {\n console.log(entry);\n}\n// Output:\n// [false, 'no']\n// [true, 'yes']\n```", "```js\nassert.deepEqual(\n Array.from(map.entries()),\n [[false, 'no'], [true, 'yes']]);\n```", "```js\nfor (const [key, value] of map) {\n console.log(key, value);\n}\n// Output:\n// false, 'no'\n// true, 'yes'\n```", "```js\nconst map1 = new Map([\n ['a', 1],\n ['b', 2],\n]);\nassert.deepEqual(\n Array.from(map1.keys()), ['a', 'b']);\n\nconst map2 = new Map([\n ['b', 2],\n ['a', 1],\n]);\nassert.deepEqual(\n Array.from(map2.keys()), ['b', 'a']);\n```", "```js\nconst map = new Map([\n ['a', 1],\n ['b', 2],\n]);\nconst obj = Object.fromEntries(map);\nassert.deepEqual(\n obj, {a: 1, b: 2});\n```", "```js\nconst obj = {\n a: 1,\n b: 2,\n};\nconst map = new Map(Object.entries(obj));\nassert.deepEqual(\n map, new Map([['a', 1], ['b', 2]]));\n```", "```js\nfunction countChars(chars) {\n const charCounts = new Map();\n for (let ch of chars) {\n ch = ch.toLowerCase();\n const prevCount = charCounts.get(ch) ?? 0;\n charCounts.set(ch, prevCount+1);\n }\n return charCounts;\n}\n\nconst result = countChars('AaBccc');\nassert.deepEqual(\n Array.from(result),\n [\n ['a', 2],\n ['b', 1],\n ['c', 3],\n ]\n);\n```", "```js\nconst map = new Map();\n\nconst KEY1 = {};\nconst KEY2 = {};\n\nmap.set(KEY1, 'hello');\nmap.set(KEY2, 'world');\n\nassert.equal(map.get(KEY1), 'hello');\nassert.equal(map.get(KEY2), 'world');\n```", "```js\n> const map = new Map();\n\n> map.set(NaN, 123);\n> map.get(NaN)\n123\n```", "```js\n> new Map().set({}, 1).set({}, 2).size\n2\n```", "```js\nconst originalMap = new Map()\n.set(1, 'a')\n.set(2, 'b')\n.set(3, 'c');\n```", "```js\nconst mappedMap = new Map( // step 3\n Array.from(originalMap) // step 1\n .map(([k, v]) => [k * 2, '_' + v]) // step 2\n);\nassert.deepEqual(\n Array.from(mappedMap),\n [[2,'_a'], [4,'_b'], [6,'_c']]);\n```", "```js\nconst filteredMap = new Map( // step 3\n Array.from(originalMap) // step 1\n .filter(([k, v]) => k < 3) // step 2\n);\nassert.deepEqual(Array.from(filteredMap),\n [[1,'a'], [2,'b']]);\n```", "```js\nconst map1 = new Map()\n .set(1, '1a')\n .set(2, '1b')\n .set(3, '1c')\n;\n\nconst map2 = new Map()\n .set(2, '2b')\n .set(3, '2c')\n .set(4, '2d')\n;\n```", "```js\nconst combinedMap = new Map([...map1, ...map2]); // (A)\nassert.deepEqual(\n Array.from(combinedMap), // convert to Array for comparison\n [ [ 1, '1a' ],\n [ 2, '2b' ],\n [ 3, '2c' ],\n [ 4, '2d' ] ]\n);\n```", "```js\n    const map = new Map([\n     [ 1, 'one' ],\n     [ 2, 'two' ],\n     [ 3, 'three' ], // trailing comma is ignored\n    ]);\n    ```", "```js\n    const map = new Map([[1, 'one'], [2, 'two']]);\n    assert.equal(map.get(1), 'one');\n    assert.equal(map.get(5), undefined);\n    ```", "```js\n    const map = new Map([[1, 'one'], [2, 'two']]);\n    map.set(1, 'ONE!')\n     .set(3, 'THREE!');\n    assert.deepEqual(\n     Array.from(map.entries()),\n     [[1, 'ONE!'], [2, 'two'], [3, 'THREE!']]);\n    ```", "```js\n    const map = new Map([[1, 'one'], [2, 'two']]);\n    assert.equal(map.has(1), true); // key exists\n    assert.equal(map.has(5), false); // key does not exist\n    ```", "```js\n    const map = new Map([[1, 'one'], [2, 'two']]);\n    assert.equal(map.delete(1), true);\n    assert.equal(map.delete(5), false); // nothing happens\n    assert.deepEqual(\n     Array.from(map.entries()),\n     [[2, 'two']]);\n    ```", "```js\n    const map = new Map([[1, 'one'], [2, 'two']]);\n    assert.equal(map.size, 2);\n    ```", "```js\n    const map = new Map([[1, 'one'], [2, 'two']]);\n    assert.equal(map.size, 2);\n    map.clear();\n    assert.equal(map.size, 0);\n    ```", "```js\n    const map = new Map([[1, 'one'], [2, 'two']]);\n    for (const entry of map.entries()) {\n     console.log(entry);\n    }\n    // Output:\n    // [1, 'one']\n    // [2, 'two']\n    ```", "```js\n    const map = new Map([[1, 'one'], [2, 'two']]);\n    map.forEach((value, key) => console.log(value, key));\n    // Output:\n    // 'one', 1\n    // 'two', 2\n    ```", "```js\n    const map = new Map([[1, 'one'], [2, 'two']]);\n    for (const key of map.keys()) {\n     console.log(key);\n    }\n    // Output:\n    // 1\n    // 2\n    ```", "```js\n    const map = new Map([[1, 'one'], [2, 'two']]);\n    for (const value of map.values()) {\n     console.log(value);\n    }\n    // Output:\n    // 'one'\n    // 'two'\n    ```", "```js\n    const map = new Map([[1, 'one'], [2, 'two']]);\n    for (const [key, value] of map) {\n     console.log(key, value);\n    }\n    // Output:\n    // 1, 'one'\n    // 2, 'two'\n    ```", "```js\n    const value = obj.key;\n    ```", "```js\n    const theKey = 123;\n    map.get(theKey);\n    ```"]