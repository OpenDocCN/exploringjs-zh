["```js\nlet i;\ni = 0;\ni = i + 1;\nassert.equal(i, 1);\n```", "```js\nlet i = 0;\n```", "```js\nconst i = 0; // must initialize\n\nassert.throws(\n () => { i = i + 1 },\n {\n name: 'TypeError',\n message: 'Assignment to constant variable.',\n }\n);\n```", "```js\nconst obj = { prop: 0 };\n\n// Allowed: changing properties of `obj`\nobj.prop = obj.prop + 1;\nassert.equal(obj.prop, 1);\n\n// Not allowed: assigning to `obj`\nassert.throws(\n () => { obj = {} },\n {\n name: 'TypeError',\n message: 'Assignment to constant variable.',\n }\n);\n```", "```js\nconst arr = ['hello', 'world'];\nfor (const elem of arr) {\n console.log(elem);\n}\n// Output:\n// 'hello'\n// 'world'\n```", "```js\nconst arr = ['hello', 'world'];\nfor (let i=0; i<arr.length; i++) {\n const elem = arr[i];\n console.log(elem);\n}\n```", "```js\n{ // // Scope A. Accessible: x\n const x = 0;\n assert.equal(x, 0);\n { // Scope B. Accessible: x, y\n const y = 1;\n assert.equal(x, 0);\n assert.equal(y, 1);\n { // Scope C. Accessible: x, y, z\n const z = 2;\n assert.equal(x, 0);\n assert.equal(y, 1);\n assert.equal(z, 2);\n }\n }\n}\n// Outside. Not accessible: x, y, z\nassert.throws(\n () => console.log(x),\n {\n name: 'ReferenceError',\n message: 'x is not defined',\n }\n);\n```", "```js\nassert.throws(\n () => {\n eval('let x = 1; let x = 2;');\n },\n {\n name: 'SyntaxError',\n message: \"Identifier 'x' has already been declared\",\n });\n```", "```js\nconst x = 1;\nassert.equal(x, 1);\n{\n const x = 2;\n assert.equal(x, 2);\n}\nassert.equal(x, 1);\n```", "```js\nfunction f() {\n const x = 3;\n // \u00b7\u00b7\u00b7\n}\n```", "```js\nfunction g(x) {}\nfunction h(y) {\n if (Math.random()) g(y); // (A)\n}\n```", "```js\n<script>\n const declarativeVariable = 'd';\n var objectVariable = 'o';\n</script>\n<script>\n // All scripts share the same top-level scope:\n console.log(declarativeVariable); // 'd'\n console.log(objectVariable); // 'o'\n\n // Not all declarations create properties of the global object:\n console.log(globalThis.declarativeVariable); // undefined\n console.log(globalThis.objectVariable); // 'o'\n</script>\n```", "```js\nwindow.encodeURIComponent(str); // no\nencodeURIComponent(str); // yes\n```", "```js\n{\n console.log(x); // What happens here?\n const x;\n}\n```", "```js\nif (true) { // entering scope of `tmp`, TDZ starts\n // `tmp` is uninitialized:\n assert.throws(() => (tmp = 'abc'), ReferenceError);\n assert.throws(() => console.log(tmp), ReferenceError);\n\n let tmp; // TDZ ends\n assert.equal(tmp, undefined);\n}\n```", "```js\nif (true) { // entering scope of `myVar`, TDZ starts\n const func = () => {\n console.log(myVar); // executed later\n };\n\n // We are within the TDZ:\n // Accessing `myVar` causes `ReferenceError`\n\n let myVar = 3; // TDZ ends\n func(); // OK, called outside TDZ\n}\n```", "```js\nassert.equal(foo(), 123); // OK\nfunction foo() { return 123; }\n```", "```js\nfunction foo() { return 123; }\nassert.equal(foo(), 123);\n```", "```js\nassert.throws(\n () => bar(), // before declaration\n ReferenceError);\n\nconst bar = () => { return 123; };\n\nassert.equal(bar(), 123); // after declaration \n```", "```js\nconst f = () => g();\nconst g = () => 123;\n\n// We call f() after g() was declared:\nassert.equal(f(), 123);\n```", "```js\nfuncDecl();\n\nconst MY_STR = 'abc';\nfunction funcDecl() {\n assert.throws(\n () => MY_STR,\n ReferenceError);\n}\n```", "```js\nassert.throws(\n () => new MyClass(),\n ReferenceError);\n\nclass MyClass {}\n\nassert.equal(new MyClass() instanceof MyClass, true);\n```", "```js\nclass MyClass extends Object {}\n```", "```js\nconst identity = x => x;\nclass MyClass extends identity(Object) {}\n```", "```js\nvar x = 123;\n```", "```js\nfunction f() {\n // Partial early activation:\n assert.equal(x, undefined);\n if (true) {\n var x = 123;\n // The assignment is executed in place:\n assert.equal(x, 123);\n }\n // Scope is function, not block:\n assert.equal(x, 123);\n}\n```", "```js\nfunction func(x) {\n const y = 123;\n console.log(z);\n}\n```", "```js\nfunction funcFactory(value) {\n return () => {\n return value;\n };\n}\n\nconst func = funcFactory('abc');\nassert.equal(func(), 'abc'); // (A)\n```", "```js\nfunction createInc(startValue) {\n return (step) => { // (A)\n startValue += step;\n return startValue;\n };\n}\nconst inc = createInc(5);\nassert.equal(inc(2), 7);\n```", "```js\nfunction createInc(startValue) {\n let index = -1;\n return (step) => {\n startValue += step;\n index++;\n return [index, startValue];\n };\n}\nconst inc = createInc(5);\nassert.deepEqual(inc(2), [0, 7]);\nassert.deepEqual(inc(2), [1, 9]);\nassert.deepEqual(inc(2), [2, 11]);\n```"]