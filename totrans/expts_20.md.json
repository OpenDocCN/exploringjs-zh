["```ts\nlet value1 = 123;\nassertType<number>(value1);\n\nconst value2 = 123;\nassertType<123>(value2);\n\n```", "```ts\nlet SYM1 = Symbol('SYM1');\nassertType<symbol>(SYM1);\n\nconst SYM2 = Symbol('SYM2');\nassertType<typeof SYM2>(SYM2);\n\n```", "```ts\nfunction f(_sym: typeof SYM2) {}\n\nf(SYM2); // OK\n// @ts-expect-error: Argument of type 'symbol' is not assignable to\n// parameter of type 'unique symbol'.\nf(Symbol('SYM2')); // new, different value!\n\n```", "```ts\n> Symbol() === Symbol()\nfalse\n\n```", "```ts\n> {} === {}\nfalse\n\n```", "```ts\nconst SYM = Symbol('SYM'); // typeof SYM\n\nfunction getSym(): typeof SYM {\n const X = SYM; // symbol\n\n // @ts-expect-error: Type 'symbol' is not assignable to\n // type 'unique symbol'.\n return X;\n}\n\n```", "```ts\nconst SYM: unique symbol = Symbol('SYM');\nclass MyClass {\n static readonly SYM: unique symbol = Symbol('SYM');\n}\n\n```", "```ts\nconst SYM = Symbol('SYM');\nclass MyClass {\n static readonly SYM = Symbol('SYM');\n}\n\n```", "```ts\ninterface SymbolConstructor {\n readonly iterator: unique symbol;\n}\n\n```", "```ts\ninterface SymbolConstructor {\n readonly prototype: Symbol;\n (description?: string | number): symbol;\n for(key: string): symbol;\n keyFor(sym: symbol): string | undefined;\n}\n\ndeclare var Symbol: SymbolConstructor;\n\n```", "```ts\ntype Obj = {\n readonly sym: unique symbol,\n};\n\n```", "```ts\nconst obj1: Obj = {\n // @ts-expect-error: Type 'symbol' is not assignable to\n // type 'unique symbol'.\n sym: Symbol('SYM'),\n};\n\nconst SYM: unique symbol = Symbol('SYM');\nconst obj2: Obj = {\n // @ts-expect-error: Type 'typeof SYM' is not assignable to\n // type 'typeof sym'.\n sym: SYM,\n};\n\n```", "```ts\nconst ACTIVE = Symbol('ACTIVE');\nconst INACTIVE = Symbol('INACTIVE');\ntype ActSym = typeof ACTIVE | typeof INACTIVE;\n\nconst activation1: ActSym = ACTIVE;\nconst activation2: ActSym = INACTIVE;\n// @ts-expect-error: Type 'unique symbol' is not assignable to\n// type 'ActSym'.\nconst activation3: ActSym = Symbol('ACTIVE');\n\n```", "```ts\ntype ActStr = 'ACTIVE' | 'INACTIVE';\n\n```", "```ts\nconst ACTIVE = 'ACTIVE';\nconst INACTIVE = 'INACTIVE';\ntype ActStr = typeof ACTIVE | typeof INACTIVE;\n\nconst activation1: ActStr = ACTIVE;\nconst activation2: ActStr = INACTIVE;\nconst activation3: ActStr = 'ACTIVE'; // OK!\n\n```", "```ts\ntype StreamValue =\n | null // end of file\n | string\n;\n\n```", "```ts\nconst EOF = Symbol('EOF');\ntype StreamValue =\n | typeof EOF\n | string\n;\n\n```", "```ts\nconst Active = Symbol('Active');\nconst Inactive = Symbol('Inactive');\n\nconst Activation = {\n __proto__: null,\n Active, // (A)\n Inactive, // (B)\n} as const;\n\ntype ActivationType = PropertyValues<typeof Activation>;\ntype _ = Assert<Equal<\n ActivationType, typeof Active | typeof Inactive\n>>;\n\ntype PropertyValues<Obj> = Obj[Exclude<keyof Obj, '__proto__'>];\n\n```"]