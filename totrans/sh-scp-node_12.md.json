["```js\n/**\n * @returns an asynchronous iterable\n */\nasync function* asyncGenerator(asyncIterable) {\n for await (const item of asyncIterable) { // input\n if (\u00b7\u00b7\u00b7) {\n yield '> ' + item; // output\n }\n }\n}\n```", "```js\n/** @returns a Promise */\nasync function asyncFunction() { /*\u00b7\u00b7\u00b7*/ }\n\n/** @returns an async iterable */\nasync function* asyncGeneratorFunction() { /*\u00b7\u00b7\u00b7*/ }\n```", "```js\n    > buffer.Buffer.isEncoding('utf8')\n    true\n    > buffer.Buffer.isEncoding('utf-8')\n    true\n    > buffer.Buffer.isEncoding('UTF-8')\n    true\n    > buffer.Buffer.isEncoding('UTF:8')\n    false\n    ```", "```js\nimport * as stream from 'stream';\n\n/**\n * Reads all the text in a readable stream and returns it as a string,\n * via a Promise.\n * @param  {stream.Readable} readable\n */\nfunction readableToString(readable) {\n return new Promise((resolve, reject) => {\n let data = '';\n readable.on('data', function (chunk) {\n data += chunk;\n });\n readable.on('end', function () {\n resolve(data);\n });\n readable.on('error', function (err) {\n reject(err);\n });\n });\n}\n```", "```js\nimport * as fs from 'fs';\n\nconst readableStream = fs.createReadStream(\n 'tmp/test.txt', {encoding: 'utf8'});\n\nassert.equal(\n await readableToString(readableStream),\n 'This is a test!\\n');\n```", "```js\nimport * as stream from 'stream';\n\nfunction* gen() {\n yield 'One line\\n';\n yield 'Another line\\n';\n}\nconst readableStream = stream.Readable.from(gen(), {encoding: 'utf8'});\nassert.equal(\n await readableToString(readableStream),\n 'One line\\nAnother line\\n');\n```", "```js\nimport {Readable} from 'stream';\n\nconst str = 'Some text!';\nconst readable = Readable.from(str, {encoding: 'utf8'});\nassert.equal(\n await readableToString(readable),\n 'Some text!');\n```", "```js\nimport * as fs from 'fs';\n\nasync function logChunks(readable) {\n for await (const chunk of readable) {\n console.log(chunk);\n }\n}\n\nconst readable = fs.createReadStream(\n 'tmp/test.txt', {encoding: 'utf8'});\nlogChunks(readable);\n\n// Output:\n// 'This is a test!\\n'\n```", "```js\nimport {Readable} from 'stream';\n\nasync function readableToString2(readable) {\n let result = '';\n for await (const chunk of readable) {\n result += chunk;\n }\n return result;\n}\n\nconst readable = Readable.from('Good morning!', {encoding: 'utf8'});\nassert.equal(await readableToString2(readable), 'Good morning!');\n```", "```js\nimport * as fs from 'node:fs';\nimport * as readline from 'node:readline/promises';\n\nconst filePath = process.argv[2]; // first command line argument\n\nconst rl = readline.createInterface({\n input: fs.createReadStream(filePath, {encoding: 'utf-8'}),\n});\nfor await (const line of rl) {\n console.log('>', line);\n}\nrl.close();\n```", "```js\nimport {Readable} from 'stream';\n\n/**\n * @param  chunkIterable An asynchronous or synchronous iterable\n * over \u201cchunks\u201d (arbitrary strings)\n * @returns An asynchronous iterable over \u201clines\u201d\n * (strings with at most one newline that always appears at the end)\n */\nasync function* chunksToLines(chunkIterable) {\n let previous = '';\n for await (const chunk of chunkIterable) {\n let startSearch = previous.length;\n previous += chunk;\n while (true) {\n // Works for EOL === '\\n' and EOL === '\\r\\n'\n const eolIndex = previous.indexOf('\\n', startSearch);\n if (eolIndex < 0) break;\n // Line includes the EOL\n const line = previous.slice(0, eolIndex+1);\n yield line;\n previous = previous.slice(eolIndex+1);\n startSearch = 0;\n }\n }\n if (previous.length > 0) {\n yield previous;\n }\n}\n\nasync function* numberLines(lineIterable) {\n let lineNumber = 1;\n for await (const line of lineIterable) {\n yield lineNumber + ' ' + line;\n lineNumber++;\n }\n}\n\nasync function logLines(lineIterable) {\n for await (const line of lineIterable) {\n console.log(line);\n }\n}\n\nconst chunks = Readable.from(\n 'Text with\\nmultiple\\nlines.\\n',\n {encoding: 'utf8'});\nawait logLines(numberLines(chunksToLines(chunks))); // (A)\n\n// Output:\n// '1 Text with\\n'\n// '2 multiple\\n'\n// '3 lines.\\n'\n```", "```js\nconst writableStream = fs.createWriteStream(\n 'tmp/log.txt', {encoding: 'utf8'});\n```", "```js\nimport * as util from 'util';\nimport * as stream from 'stream';\nimport * as fs from 'fs';\nimport {once} from 'events';\n\nconst finished = util.promisify(stream.finished); // (A)\n\nasync function writeIterableToFile(iterable, filePath) {\n const writable = fs.createWriteStream(filePath, {encoding: 'utf8'});\n for await (const chunk of iterable) {\n if (!writable.write(chunk)) { // (B)\n // Handle backpressure\n await once(writable, 'drain');\n }\n }\n writable.end(); // (C)\n // Wait until done. Throws if there are errors.\n await finished(writable);\n}\n\nawait writeIterableToFile(\n ['One', ' line of text.\\n'], 'tmp/log.txt');\nassert.equal(\n fs.readFileSync('tmp/log.txt', {encoding: 'utf8'}),\n 'One line of text.\\n');\n```", "```js\n    if (!writable.write(chunk)) {\n     await once(writable, 'drain');\n    }\n    ```", "```js\n    writable.end();\n    await finished(writable);\n    ```", "```js\nimport * as stream from 'stream';\nimport * as fs from 'fs';\nconst pipeline = util.promisify(stream.pipeline);\n\nasync function writeIterableToFile(iterable, filePath) {\n const readable = stream.Readable.from(\n iterable, {encoding: 'utf8'});\n const writable = fs.createWriteStream(filePath);\n await pipeline(readable, writable); // (A)\n}\nawait writeIterableToFile(\n ['One', ' line of text.\\n'], 'tmp/log.txt');\n// \u00b7\u00b7\u00b7\n```", "```js\n    const finished = util.promisify(stream.finished);\n    ```", "```js\n    const pipeline = util.promisify(stream.pipeline);\n    ```", "```js\n    interface ReadableOptions {\n     highWaterMark?: number;\n     encoding?: string;\n     objectMode?: boolean;\n     read?(this: Readable, size: number): void;\n     destroy?(this: Readable, error: Error | null,\n     callback: (error: Error | null) => void): void;\n     autoDestroy?: boolean;\n    }\n    ```"]