<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>13 What is a type in TypeScript? Two perspectives</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>13 What is a type in TypeScript? Two perspectives</h1>
<blockquote>原文：<a href="https://exploringjs.com/ts/book/ch_what-is-a-type.html">https://exploringjs.com/ts/book/ch_what-is-a-type.html</a></blockquote>

    
        <div id="adbox">
      <div id="adbox-explain">(Ad, please don’t block.)</div>
              
          </div>
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#two-questions-for-each-perspective">13.1 Two questions for each perspective</a>
    </li>
    <li>
      <a href="#dynamic-perspective-a-type-is-a-set-of-values">13.2 Dynamic perspective: a type is a set of values</a>
    </li>
    <li>
      <a href="#static-perspective-relationships-between-types">13.3 Static perspective: relationships between types</a>
    </li>
    <li>
      <a href="#nominal-vs-structural-type-systems">13.4 Nominal type systems vs. structural type systems</a>
    </li>
    <li>
      <a href="#further-reading-5">13.5 Further reading</a>
    </li>
  </ol>
</nav>
<p>What are types in TypeScript? This chapter describes two perspectives that help with understanding them. Both are useful; they complement each other.</p>
<h3 id="two-questions-for-each-perspective"><a class="heading-id-link" href="#two-questions-for-each-perspective">13.1 Two questions for each perspective</a></h3>
<p>The following two questions are important for understanding how types work and need to be answered from each of the two perspectives.</p>
<ol>
  <li>
    <p>What does it mean for <code>arg</code> to have the type <code>MyType</code>?</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params">arg: MyType</span>): <span class="hljs-built_in">void</span> {}</code>
</pre>
  </li>
  <li>
    <p>How is <code>UnionType</code> derived from <code>Type1</code> and <code>Type2</code>?</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">UnionType</span> = <span class="hljs-title class_">Type1</span> | <span class="hljs-title class_">Type2</span>;</code>
</pre>
  </li>
</ol>
<h3 id="dynamic-perspective-a-type-is-a-set-of-values"><a class="heading-id-link" href="#dynamic-perspective-a-type-is-a-set-of-values">13.2 Dynamic perspective: a type is a set of values</a></h3>
<p>From this perspective, we are interested in values and a type is a set of values:</p>
<ol>
  <li>
    We can pass a given value to <code>myFunc()</code> if it is included in <code>MyType</code>.
  </li>
  <li>
    <code>UnionType</code> (a set) is defined as the set-theoretic union of <code>Type1</code> and <code>Type2</code>.
  </li>
</ol>
<h3 id="static-perspective-relationships-between-types"><a class="heading-id-link" href="#static-perspective-relationships-between-types">13.3 Static perspective: relationships between types</a></h3>
<p>From this perspective: </p>
<ul>
  <li>
    The source code has locations and each location has a static type. In a TypeScript-aware editor, we can see the static type of a location if we hover above it with the cursor.
  </li>
  <li>
    Types are defined via their relationships with other types.
  </li>
</ul>
<p>The most important type relationship is <em>assignment compatibility</em>: Can a location whose type is <code>Src</code> be assigned to a location whose type is <code>Trg</code>? The answer is yes if:</p>
<ul>
  <li>
    <code>Src</code> and <code>Trg</code> are identical types.
  </li>
  <li>
    <code>Src</code> or <code>Trg</code> is the type <code>any</code>.
  </li>
  <li>
    <code>Src</code> is a string literal type and <code>Trg</code> is the primitive type <code>string</code>.
  </li>
  <li>
    <code>Src</code> is a union type and each constituent type of <code>Src</code> is assignable to <code>Trg</code>.
  </li>
  <li>
    <code>Src</code> is an intersection type and at least one constituent type of <code>Src</code> is assignable to <code>Trg</code>.
  </li>
  <li>
    <code>Trg</code> is a union type and <code>Src</code> is assignable to at least one constituent type of <code>Trg</code>.
  </li>
  <li>
    <code>Trg</code> is an intersection type and <code>Src</code> is assignable to each constituent type of <code>Trg</code>.
  </li>
  <li>
    Etc.
  </li>
</ul>
<p>Let’s consider the questions:</p>
<ol>
  <li>
    Parameter <code>arg</code> having type <code>MyType</code> means that we can only pass a value to <code>myFunc()</code> whose type is assignable to <code>MyType</code>.
  </li>
  <li>
    <code>UnionType</code> is defined by the relationships it has with other types. Above, we have seen two rules for union types.
  </li>
</ol>
<h3 id="nominal-vs-structural-type-systems"><a class="heading-id-link" href="#nominal-vs-structural-type-systems">13.4 Nominal type systems vs. structural type systems</a></h3>
<p>One of the responsibilities of a static type system is to determine if two static types are compatible – e.g.:</p>
<ul>
  <li>
    The static type <code>Src</code> of an actual parameter (e.g., provided via a function call)
  </li>
  <li>
    The static type <code>Trg</code> of the corresponding formal parameter (e.g., specified as part of a function definition)
  </li>
</ul>
<p>The type system needs to check if <code>Src</code> is assignable to <code>Trg</code>. Two approaches for this check are (roughly):</p>
<ul>
  <li>
    <p>In a <em>nominal</em> or <em>nominative</em> type system, two static types are equal if they have the same identity (“name”). <code>Src</code> is only assignable to <code>Trg</code> if they are equal or if a relationship between them was specified explicitly – e.g., an inheritance relationship (<code>extends</code>).</p>
    <ul>
      <li>
        Languages with nominal type systems include C++, Java and C#.
      </li>
    </ul>
  </li>
  <li>
    <p>In a <em>structural</em> type system, a type <code>Src</code> is assignable to a type <code>Trg</code> if <code>Trg</code> has a structure that can receive what’s in <code>Src</code> — e.g.: For each field <code>Src.F</code>, there must be a field <code>Trg.F</code> such that <code>Src.F</code> is assignable to <code>Trg.F</code>.</p>
    <ul>
      <li>
        Languages with structural type systems include TypeScript, Go (interfaces) and OCaml (objects).
      </li>
    </ul>
  </li>
</ul>
<p>The following code produces a type error in the last line with a nominal type system, but is legal with TypeScript’s structural type system because class <code>A</code> and class <code>B</code> have the same structure:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {</code>
<code>  typeName = <span class="hljs-string">'A'</span>;</code>
<code>}</code>
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> {</code>
<code>  typeName = <span class="hljs-string">'B'</span>;</code>
<code>}</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">someVariable</span>: A = <span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>();</code>
</pre>
<p>TypeScript’s interfaces also work structurally – they don’t have to be implemented in order to match:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">HasTypeName</span> {</code>
<code>  <span class="hljs-attr">typeName</span>: <span class="hljs-built_in">string</span>;</code>
<code>}</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">hasTypeName</span>: <span class="hljs-title class_">HasTypeName</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>(); <span class="hljs-comment">// OK</span></code>
</pre>
<h3 id="further-reading-5"><a class="heading-id-link" href="#further-reading-5">13.5 Further reading</a></h3>
<ul>
  <li>
    <p><a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html">Chapter “Type Compatibility” in the TypeScript Handbook</a></p>
  </li>
  <li>
    <p>TypeScript Language Specification 1.8: TypeScript originally had a formal language specification but it was discontinued after TypeScript 1.8 (which came out in 2016). It has since been <a href="https://github.com/microsoft/TypeScript/pull/51791">removed</a> from TypeScript’s repositories, but <a href="https://github.com/microsoft/TypeScript/blob/3c99d50da5a579d9fa92d02664b1b66d4ff55944/doc/TypeScript%20Language%20Specification%20-%20ARCHIVED.pdf">a PDF file</a> can still be downloaded from an old commit. Especially helpful: section “3.11 Type Relationships”.</p>
  </li>
</ul>

    
      
</body>
</html>