<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>28 Evaluating code dynamically: eval(), new Function() (advanced)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>28 Evaluating code dynamically: eval(), new Function() (advanced)</h1>
<blockquote>原文：<a href="https://exploringjs.com/js/book/ch_dynamic-code-evaluation.html">https://exploringjs.com/js/book/ch_dynamic-code-evaluation.html</a></blockquote>

        
    
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#eval">28.1 <code>eval()</code></a>
    </li>
    <li>
      <a href="#new-function">28.2 <code>new Function()</code></a>
    </li>
    <li>
      <a href="#recommendations">28.3 Recommendations</a>
    </li>
  </ol>
</nav>
<p><span refcheck="#eval #new-function">In this chapter</span>, we’ll look at two ways of evaluating code dynamically: <code>eval()</code> and <code>new Function()</code>.</p>
<h3 id="eval"><a class="heading-id-link" href="#eval">28.1 <code>eval()</code></a></h3>
<p><span id="index-entry-eval--"/></p>
<p>Given a string <code>str</code> with JavaScript code, <code>eval(str)</code> evaluates that code and returns the result:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">'2 ** 4'</span>)</span></code>
<code>16</code>
</pre>
<p>There are two ways of invoking <code>eval()</code>:</p>
<ul>
  <li>
    <em>Directly</em>, via a function call. Then the code in its argument is evaluated inside the current scope.
  </li>
  <li>
    <em>Indirectly</em>, not via a function call. Then it evaluates its code in global scope.
  </li>
</ul>
<p>“Not via a function call” means “anything that looks different than <code>eval(···)</code>”:</p>
<ul>
  <li>
    <code>eval.call(undefined, '···')</code> (uses <a href="ch_callables.html#Function.prototype.call">method <code>.call()</code> of functions</a>)
  </li>
  <li>
    <code>eval?.('···')</code> (uses <a href="ch_objects.html#optional-chaining">optional chaining</a>)
  </li>
  <li>
    <code>(0, eval)('···')</code> (uses <a href="ch_operators.html#comma-operator">the comma operator</a>)
  </li>
  <li>
    <code>globalThis.eval('···')</code>
  </li>
  <li>
    <code>const e = eval; e('···')</code>
  </li>
  <li>
    Etc.
  </li>
</ul>
<p>The following code illustrates the difference:</p>
<pre class="language-js">
<code>globalThis.<span class="hljs-property">myVariable</span> = <span class="hljs-string">'global'</span>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">const</span> myVariable = <span class="hljs-string">'local'</span>;</span></code>
<code><span class="hljs-params">  </span></code>
<code><span class="hljs-params">  <span class="hljs-comment">// Direct eval</span></span></code>
<code><span class="hljs-params">  assert.<span class="hljs-title function_">equal</span>(<span class="hljs-built_in">eval</span>(<span class="hljs-string">'myVariable'</span>), <span class="hljs-string">'local'</span>);</span></code>
<code><span class="hljs-params">  </span></code>
<code><span class="hljs-params">  <span class="hljs-comment">// Indirect eval</span></span></code>
<code><span class="hljs-params">  assert.<span class="hljs-title function_">equal</span>(<span class="hljs-built_in">eval</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-string">'myVariable'</span>), <span class="hljs-string">'global'</span>);</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p>Evaluating code in global context is safer because the code has access to fewer internals.</p>
<h3 id="new-function"><a class="heading-id-link" href="#new-function">28.2 <code>new Function()</code></a></h3>
<p><code>new Function()</code> creates a function object and is invoked as follows:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> func = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">'«param_1»'</span>, ···, <span class="hljs-string">'«param_n»'</span>, <span class="hljs-string">'«func_body»'</span>);</code>
</pre>
<p>The previous statement is equivalent to the next statement. Note that <code>«param_1»</code>, etc., are not inside string literals, anymore.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> func = <span class="hljs-keyword">function</span> (<span class="hljs-params">«param_1», ···, «param_n»</span>) {</code>
<code>  «func_body»</code>
<code>};</code>
</pre>
<p>In the next example, we create the same function twice, first via <code>new Function()</code>, then via a function expression:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> times1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'return a * b'</span>);</code>
<code><span class="hljs-keyword">const</span> times2 = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) { <span class="hljs-keyword">return</span> a * b };</code>
</pre>
<div class="boxout">
  <p><img src="../Images/5aa4bf88dc66ecb2bac6be4022a1fed4.png" class="boxout-icon" height="24" alt="Icon “warning”" data-original-src="https://exploringjs.com/js/book/icon/warning.svg"/> <strong><code>new Function()</code> creates non-strict mode functions</strong></p>
  <div class="boxout-vspace"/>
  <p>By default, functions created via <code>new Function()</code> are <a href="ch_syntax.html#strict-mode">sloppy</a>. If we want the function body to be in strict mode, we have to <a href="ch_syntax.html#switching-on-strict-mode">switch it on manually</a>.</p>
</div>
<h3 id="recommendations"><a class="heading-id-link" href="#recommendations">28.3 Recommendations</a></h3>
<p>Avoid dynamic evaluation of code as much as you can:</p>
<ul>
  <li>
    It’s a security risk because it may enable an attacker to execute arbitrary code with the privileges of your code.
  </li>
  <li>
    It may be switched off – for example, in browsers, via <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">a Content Security Policy</a>.
  </li>
</ul>
<p>Very often, JavaScript is dynamic enough so that you don’t need <code>eval()</code> or similar. In the following example, what we are doing with <code>eval()</code> (line A) can be achieved just as well without it (line B).</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>};</code>
<code><span class="hljs-keyword">const</span> propKey = <span class="hljs-string">'b'</span>;</code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-built_in">eval</span>(<span class="hljs-string">'obj.'</span> + propKey), <span class="hljs-number">2</span>); <span class="hljs-comment">// (A)</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(obj[propKey], <span class="hljs-number">2</span>); <span class="hljs-comment">// (B)</span></code>
</pre>
<p>If you have to dynamically evaluate code:</p>
<ul>
  <li>
    Prefer <code>new Function()</code> over <code>eval()</code>: it always executes its code in global context and a function provides a clean interface to the evaluated code.
  </li>
  <li>
    Prefer indirect <code>eval</code> over direct <code>eval</code>: evaluating code in global context is safer.
  </li>
</ul>

    
      
</body>
</html>