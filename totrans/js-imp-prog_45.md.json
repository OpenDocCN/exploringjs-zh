["```js\n// Generator function declaration\nfunction* genFunc1() { /*\u00b7\u00b7\u00b7*/ }\n\n// Generator function expression\nconst genFunc2 = function* () { /*\u00b7\u00b7\u00b7*/ };\n\n// Generator method definition in an object literal\nconst obj = {\n * generatorMethod() {\n // \u00b7\u00b7\u00b7\n }\n};\n\n// Generator method definition in a class definition\n// (class declaration or class expression)\nclass MyClass {\n * generatorMethod() {\n // \u00b7\u00b7\u00b7\n }\n}\n```", "```js\nfunction* genFunc1() {\n yield 'a';\n yield 'b';\n}\n\nconst iterable = genFunc1();\n// Convert the iterable to an Array, to check what\u2019s inside:\nassert.deepEqual(\n Array.from(iterable), ['a', 'b']\n);\n\n// We can also use a for-of loop\nfor (const x of genFunc1()) {\n console.log(x);\n}\n// Output:\n// 'a'\n// 'b'\n```", "```js\nlet location = 0;\nfunction* genFunc2() {\n location = 1; yield 'a';\n location = 2; yield 'b';\n location = 3;\n}\n```", "```js\nconst iter = genFunc2();\n// genFunc2() is now paused \u201cbefore\u201d its body:\nassert.equal(location, 0);\n```", "```js\nassert.deepEqual(\n iter.next(), {value: 'a', done: false});\n// genFunc2() is now paused directly after the first `yield`:\nassert.equal(location, 1);\n```", "```js\nassert.deepEqual(\n iter.next(), {value: 'b', done: false});\n// genFunc2() is now paused directly after the second `yield`:\nassert.equal(location, 2);\n```", "```js\nassert.deepEqual(\n iter.next(), {value: undefined, done: true});\n// We have reached the end of genFunc2():\nassert.equal(location, 3);\n```", "```js\n/**\n * Returns an iterable over lines\n */\nfunction* genLines() {\n yield 'A line';\n yield 'Another line';\n yield 'Last line';\n}\n\n/**\n * Input: iterable over lines\n * Output: iterable over numbered lines\n */\nfunction* numberLines(lineIterable) {\n let lineNumber = 1;\n for (const line of lineIterable) { // input\n yield lineNumber + ': ' + line; // output\n lineNumber++;\n }\n}\n```", "```js\nconst numberedLines = numberLines(genLines());\nassert.deepEqual(\n numberedLines.next(), {value: '1: A line', done: false});\nassert.deepEqual(\n numberedLines.next(), {value: '2: Another line', done: false});\n```", "```js\nfunction* mapIter(iterable, func) {\n let index = 0;\n for (const x of iterable) {\n yield func(x, index);\n index++;\n }\n}\n\nconst iterable = mapIter(['a', 'b'], x => x + x);\nassert.deepEqual(\n Array.from(iterable), ['aa', 'bb']\n);\n```", "```js\nfunction* bar() {\n yield 'a';\n yield 'b';\n}\nfunction* foo() {\n // Nothing happens if we call `bar()`:\n bar();\n}\nassert.deepEqual(\n Array.from(foo()), []\n);\n```", "```js\nfunction* bar() {\n yield 'a';\n yield 'b';\n}\nfunction* foo() {\n yield* bar();\n}\nassert.deepEqual(\n Array.from(foo()), ['a', 'b']\n);\n```", "```js\nfunction* foo() {\n for (const x of bar()) {\n yield x;\n }\n}\n```", "```js\nfunction* gen() {\n yield* [1, 2];\n}\nassert.deepEqual(\n Array.from(gen()), [1, 2]\n);\n```", "```js\nclass BinaryTree {\n constructor(value, left=null, right=null) {\n this.value = value;\n this.left = left;\n this.right = right;\n }\n\n /** Prefix iteration: parent before children */\n * [Symbol.iterator]() {\n yield this.value;\n if (this.left) {\n // Same as yield* this.left[Symbol.iterator]()\n yield* this.left;\n }\n if (this.right) {\n yield* this.right;\n }\n }\n}\n```", "```js\nconst tree = new BinaryTree('a',\n new BinaryTree('b',\n new BinaryTree('c'),\n new BinaryTree('d')),\n new BinaryTree('e'));\n\nfor (const x of tree) {\n console.log(x);\n}\n// Output:\n// 'a'\n// 'b'\n// 'c'\n// 'd'\n// 'e'\n```", "```js\n    for (const x of ['a', 'b']) {\n     console.log(x);\n    }\n    // Output:\n    // 'a'\n    // 'b'\n    ```", "```js\n    ['a', 'b'].forEach((x) => {\n     console.log(x);\n    });\n    // Output:\n    // 'a'\n    // 'b'\n    ```", "```js\nfunction logPaths(dir) {\n for (const fileName of fs.readdirSync(dir)) {\n const filePath = path.resolve(dir, fileName);\n console.log(filePath);\n const stats = fs.statSync(filePath);\n if (stats.isDirectory()) {\n logPaths(filePath); // recursive call\n }\n }\n}\n```", "```js\nmydir/\n    a.txt\n    b.txt\n    subdir/\n        c.txt\n```", "```js\nlogPaths('mydir');\n\n// Output:\n// 'mydir/a.txt'\n// 'mydir/b.txt'\n// 'mydir/subdir'\n// 'mydir/subdir/c.txt'\n```", "```js\nfunction visitPaths(dir, callback) {\n for (const fileName of fs.readdirSync(dir)) {\n const filePath = path.resolve(dir, fileName);\n callback(filePath); // (A)\n const stats = fs.statSync(filePath);\n if (stats.isDirectory()) {\n visitPaths(filePath, callback);\n }\n }\n}\nconst paths = [];\nvisitPaths('mydir', p => paths.push(p));\nassert.deepEqual(\n paths,\n [\n 'mydir/a.txt',\n 'mydir/b.txt',\n 'mydir/subdir',\n 'mydir/subdir/c.txt',\n ]);\n```", "```js\nfunction* iterPaths(dir) {\n for (const fileName of fs.readdirSync(dir)) {\n const filePath = path.resolve(dir, fileName);\n yield filePath; // (A)\n const stats = fs.statSync(filePath);\n if (stats.isDirectory()) {\n yield* iterPaths(filePath);\n }\n }\n}\nconst paths = Array.from(iterPaths('mydir'));\n```"]