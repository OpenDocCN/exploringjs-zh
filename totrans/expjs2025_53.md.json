["```js\ninterface Iterable<T> {\n  [Symbol.iterator]() : Iterator<T>;\n}\ninterface Iterator<T> {\n  next() : IteratorResult<T>;\n}\ninterface IteratorResult<T> {\n  value: T;\n  done: boolean;\n}\n\n```", "```js\ninterface AsyncIterable<T> {\n  [Symbol.asyncIterator]() : AsyncIterator<T>;\n}\ninterface AsyncIterator<T> {\n  next() : Promise<IteratorResult<T>>; // (A)\n}\ninterface IteratorResult<T> {\n  value: T;\n  done: boolean;\n}\n\n```", "```js\nconst asyncIterable = syncToAsyncIterable(['a', 'b']); // (A)\nconst asyncIterator = asyncIterable[Symbol.asyncIterator]();\n\n// Call .next() until .done is true:\nasyncIterator.next() // (B)\n.then(iteratorResult => {\n  assert.deepEqual(\n    iteratorResult,\n    { value: 'a', done: false });\n  return asyncIterator.next(); // (C)\n})\n.then(iteratorResult => {\n  assert.deepEqual(\n    iteratorResult,\n    { value: 'b', done: false });\n  return asyncIterator.next(); // (D)\n})\n.then(iteratorResult => {\n  assert.deepEqual(\n    iteratorResult,\n     { value: undefined, done: true });\n})\n;\n\n```", "```js\nasync function f() {\n const asyncIterable = syncToAsyncIterable(['a', 'b']);\n const asyncIterator = asyncIterable[Symbol.asyncIterator]();\n\n // Call .next() until .done is true:\n assert.deepEqual(\n await asyncIterator.next(),\n { value: 'a', done: false });\n assert.deepEqual(\n await asyncIterator.next(),\n { value: 'b', done: false });\n assert.deepEqual(\n await asyncIterator.next(),\n { value: undefined, done: true });\n}\n\n```", "```js\nfor await (const x of syncToAsyncIterable(['a', 'b'])) {\n  console.log(x);\n}\n\n```", "```js\na\nb\n\n```", "```js\nfor await (const x of ['a', 'b']) {\n  console.log(x);\n}\n\n```", "```js\na\nb\n\n```", "```js\nconst arr = [Promise.resolve('a'), Promise.resolve('b')];\nfor await (const x of arr) {\n  console.log(x);\n}\n\n```", "```js\na\nb\n\n```", "```js\n// Input: Promise and async iterable\nasync function* asyncGen(somePromise, someAsyncIterable) {\n  const x = await somePromise;\n  for await (const y of someAsyncIterable) {\n    // ···\n  }\n\n  // Output: iterable async iterator\n  yield someValue;\n  yield* otherAsyncGen();\n}\n\n```", "```js\nasync function* yield123() {\n for (let i=1; i<=3; i++) {\n yield i;\n }\n}\n\n```", "```js\nasync function check() {\n const asyncIterable = yield123();\n const asyncIterator = asyncIterable[Symbol.asyncIterator]();\n assert.deepEqual(\n await asyncIterator.next(),\n { value: 1, done: false });\n assert.deepEqual(\n await asyncIterator.next(),\n { value: 2, done: false });\n assert.deepEqual(\n await asyncIterator.next(),\n { value: 3, done: false });\n assert.deepEqual(\n await asyncIterator.next(),\n { value: undefined, done: true });\n}\ncheck();\n\n```", "```js\nasync function* syncToAsyncIterable(syncIterable) {\n  for (const elem of syncIterable) {\n    yield elem;\n  }\n}\n\n```", "```js\nasync function asyncIterableToArray(asyncIterable) {\n  const result = [];\n  for await (const value of asyncIterable) {\n    result.push(value);\n  }\n  return result;\n}\n\n```", "```js\nasync function* createAsyncIterable() {\n yield 'a';\n yield 'b';\n}\nconst asyncIterable = createAsyncIterable();\nassert.deepEqual(\n await asyncIterableToArray(asyncIterable), // (A)\n ['a', 'b']\n);\n\n```", "```js\nasync function* timesTwo(asyncNumbers) {\n  for await (const x of asyncNumbers) {\n    yield x * 2;\n  }\n}\n\n```", "```js\nasync function* createAsyncIterable() {\n for (let i=1; i<=3; i++) {\n yield i;\n }\n}\nassert.deepEqual(\n await asyncIterableToArray(timesTwo(createAsyncIterable())),\n [2, 4, 6]\n);\n\n```", "```js\nfunction* mapSync(iterable, func) {\n  let index = 0;\n  for (const x of iterable) {\n    yield func(x, index);\n    index++;\n  }\n}\nconst syncIterable = mapSync(['a', 'b', 'c'], s => s.repeat(3));\nassert.deepEqual(\n  Array.from(syncIterable),\n  ['aaa', 'bbb', 'ccc']);\n\n```", "```js\nasync function* mapAsync(asyncIterable, func) { // (A)\n  let index = 0;\n  for await (const x of asyncIterable) { // (B)\n    yield func(x, index);\n    index++;\n  }\n}\n\n```", "```js\nasync function* createAsyncIterable() {\n yield 'a';\n yield 'b';\n}\nconst mapped = mapAsync(\n createAsyncIterable(), s => s.repeat(3));\nassert.deepEqual(\n await asyncIterableToArray(mapped), // (A)\n ['aaa', 'bbb']);\n\n```", "```js\nfunction main(inputFilePath) {\n  const readStream = fs.createReadStream(inputFilePath,\n    { encoding: 'utf-8', highWaterMark: 1024 });\n  readStream.on('data', (chunk) => {\n    console.log('>>> '+chunk);\n  });\n  readStream.on('end', () => {\n    console.log('### DONE ###');\n  });\n}\n\n```", "```js\nasync function main(inputFilePath) {\n  const readStream = fs.createReadStream(inputFilePath,\n    { encoding: 'utf-8', highWaterMark: 1024 });\n\n  for await (const chunk of readStream) {\n    console.log('>>> '+chunk);\n  }\n  console.log('### DONE ###');\n}\n\n```", "```js\n/**\n * @param chunkIterable An asynchronous or synchronous iterable\n * over “chunks” (arbitrary strings)\n * @returns An asynchronous iterable over “lines”\n * (strings with at most one newline that always appears at the end)\n */\nasync function* chunksToLines(chunkIterable) {\n  let previous = '';\n  for await (const chunk of chunkIterable) {\n    let startSearch = previous.length;\n    previous += chunk;\n    while (true) {\n      // Works for EOL === '\\n' and EOL === '\\r\\n'\n      const eolIndex = previous.indexOf('\\n', startSearch);\n      if (eolIndex < 0) break;\n      // Line includes the EOL\n      const line = previous.slice(0, eolIndex+1);\n      yield line;\n      previous = previous.slice(eolIndex+1);\n      startSearch = 0;\n    }\n  }\n  if (previous.length > 0) {\n    yield previous;\n  }\n}\n\n```", "```js\nasync function* chunkIterable() {\n yield 'First\\nSec';\n yield 'ond\\nThird\\nF';\n yield 'ourth';\n}\nconst linesIterable = chunksToLines(chunkIterable());\nassert.deepEqual(\n await asyncIterableToArray(linesIterable),\n [\n 'First\\n',\n 'Second\\n',\n 'Third\\n',\n 'Fourth',\n ]);\n\n```", "```js\nasync function* numberLines(linesAsync) {\n  let lineNumber = 1;\n  for await (const line of linesAsync) {\n    yield lineNumber + ': ' + line;\n    lineNumber++;\n  }\n}\nconst numberedLines = numberLines(chunksToLines(chunkIterable()));\nassert.deepEqual(\n  await asyncIterableToArray(numberedLines),\n  [\n    '1: First\\n',\n    '2: Second\\n',\n    '3: Third\\n',\n    '4: Fourth',\n  ]);\n\n```"]