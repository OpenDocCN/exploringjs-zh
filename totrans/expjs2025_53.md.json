["```js\ninterface Iterable<T> {\n [Symbol.iterator]() : Iterator<T>;\n}\ninterface Iterator<T> {\n next() : IteratorResult<T>;\n}\ninterface IteratorResult<T> {\n value: T;\n done: boolean;\n}\n\n```", "```js\ninterface AsyncIterable<T> {\n [Symbol.asyncIterator]() : AsyncIterator<T>;\n}\ninterface AsyncIterator<T> {\n next() : Promise<IteratorResult<T>>; // (A)\n}\ninterface IteratorResult<T> {\n value: T;\n done: boolean;\n}\n\n```", "```js\nconst asyncIterable = syncToAsyncIterable(['a', 'b']); // (A)\nconst asyncIterator = asyncIterable[Symbol.asyncIterator]();\n `// Call .next() until .done is true:`\n`asyncIterator.next() // (B)`\n`.then(iteratorResult => {`\n `assert.deepEqual(`\n `iteratorResult,`\n `{ value: 'a', done: false });`\n `return asyncIterator.next(); // (C)`\n`})`\n`.then(iteratorResult => {`\n `assert.deepEqual(`\n `iteratorResult,`\n `{ value: 'b', done: false });`\n `return asyncIterator.next(); // (D)`\n`})`\n`.then(iteratorResult => {`\n `assert.deepEqual(`\n `iteratorResult,`\n `{ value: undefined, done: true });`\n`})`\n`;` \n```", "```js```", "``` async function f() {  const asyncIterable = syncToAsyncIterable(['a', 'b']);  const asyncIterator = asyncIterable[Symbol.asyncIterator]();   // Call .next() until .done is true:  assert.deepEqual(  await asyncIterator.next(),  { value: 'a', done: false });  assert.deepEqual(  await asyncIterator.next(),  { value: 'b', done: false });  assert.deepEqual(  await asyncIterator.next(),  { value: undefined, done: true }); }  ```", "``` for await (const x of syncToAsyncIterable(['a', 'b'])) {  console.log(x); }  ```", "``` a b  ```", "``` for await (const x of ['a', 'b']) {  console.log(x); }  ```", "``` a b  ```", "``` const arr = [Promise.resolve('a'), Promise.resolve('b')]; for await (const x of arr) {  console.log(x); }  ```", "``` a b  ```", "``` // Input: Promise and async iterable async function* asyncGen(somePromise, someAsyncIterable) {  const x = await somePromise;  for await (const y of someAsyncIterable) {  // ···  }  `// Output: iterable async iterator`  `yield someValue;`  `yield* otherAsyncGen();` `}`  ```", "````` #### [45.2.1 Example: creating an async iterable via an async generator](#example-creating-an-async-iterable-via-an-async-generator)    Let’s look at an example. The following code creates an async iterable with three numbers:    ```js async function* yield123() {  for (let i=1; i<=3; i++) {  yield i;  } }  ```    Does the result of `yield123()` conform to the async iteration protocol?    ```js async function check() {  const asyncIterable = yield123();  const asyncIterator = asyncIterable[Symbol.asyncIterator]();  assert.deepEqual(  await asyncIterator.next(),  { value: 1, done: false });  assert.deepEqual(  await asyncIterator.next(),  { value: 2, done: false });  assert.deepEqual(  await asyncIterator.next(),  { value: 3, done: false });  assert.deepEqual(  await asyncIterator.next(),  { value: undefined, done: true }); } check();  ```    #### [45.2.2 Example: converting a sync iterable to an async iterable](#example-converting-a-sync-iterable-to-an-async-iterable)    The following asynchronous generator converts a synchronous iterable to an asynchronous iterable. It implements the function `syncToAsyncIterable()` that we have used previously.    ```js async function* syncToAsyncIterable(syncIterable) {  for (const elem of syncIterable) {  yield elem;  } }  ```    Note: The input is synchronous in this case (no `await` is needed).    #### [45.2.3 Example: converting an async iterable to an Array](#asyncIterableToArray)    The following function is a solution to a previous exercise. It converts an async iterable to an Array (think spreading, but for async iterables instead of sync iterables).    ```js async function asyncIterableToArray(asyncIterable) {  const result = [];  for await (const value of asyncIterable) {  result.push(value);  }  return result; }  ```    Note that we can’t use an async generator in this case: We get our input via `for-await-of` and return an Array wrapped in a Promise. The latter requirement rules out async generators.    This is a test for `asyncIterableToArray()`:    ```js async function* createAsyncIterable() {  yield 'a';  yield 'b'; } const asyncIterable = createAsyncIterable(); assert.deepEqual(  await asyncIterableToArray(asyncIterable), // (A)  ['a', 'b'] );  ```    Note the `await` in line A, which is needed to unwrap the Promise returned by `asyncIterableToArray()`. In order for `await` to work, this code fragment must be run inside an async function.    #### [45.2.4 Example: transforming an async iterable](#example-transforming-an-async-iterable)    Let’s implement an async generator that produces a new async iterable by transforming an existing async iterable.    ```js async function* timesTwo(asyncNumbers) {  for await (const x of asyncNumbers) {  yield x * 2;  } }  ```    To test this function, we use `asyncIterableToArray()` from the previous section.    ```js async function* createAsyncIterable() {  for (let i=1; i<=3; i++) {  yield i;  } } assert.deepEqual(  await asyncIterableToArray(timesTwo(createAsyncIterable())),  [2, 4, 6] );  ```    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Async generators**    Warning: We’ll soon see the solution for this exercise in this chapter.    *   `exercises/async-iteration/number_lines_test.mjs`    #### [45.2.5 Example: mapping over asynchronous iterables](#example-mapping-over-asynchronous-iterables)    As a reminder, this is how to map over synchronous iterables:    ```js function* mapSync(iterable, func) {  let index = 0;  for (const x of iterable) {  yield func(x, index);  index++;  } } const syncIterable = mapSync(['a', 'b', 'c'], s => s.repeat(3)); assert.deepEqual(  Array.from(syncIterable),  ['aaa', 'bbb', 'ccc']);  ```    The asynchronous version looks as follows:    ```js async function* mapAsync(asyncIterable, func) { // (A)  let index = 0;  for await (const x of asyncIterable) { // (B)  yield func(x, index);  index++;  } }  ```    Note how similar the sync implementation and the async implementation are. The only two differences are the `async` in line A and the `await` in line B. That is comparable to going from a synchronous function to an asynchronous function – we only need to add the keyword `async` and the occasional `await`.    To test `mapAsync()`, we use the helper function `asyncIterableToArray()` [(shown earlier in this chapter)](#asyncIterableToArray):    ```js async function* createAsyncIterable() {  yield 'a';  yield 'b'; } const mapped = mapAsync(  createAsyncIterable(), s => s.repeat(3)); assert.deepEqual(  await asyncIterableToArray(mapped), // (A)  ['aaa', 'bbb']);  ```    Once again, we `await` to unwrap a Promise (line A) and this code fragment must run inside an async function.    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: `filterAsyncIter()`**    `exercises/async-iteration/filter_async_iter_test.mjs`    ### [45.3 Async iteration over Node.js streams](#async-iteration-over-nodejs-streams)    Due to the asynchronous nature of data streams, asynchronous iteration works well as an abstraction for them. In particular, async generators are an elegant tool for *transforming* data streams (where both input and output are streams).    #### [45.3.1 Node.js streams: async via callbacks (push)](#nodejs-streams-async-via-callbacks-push)    Traditionally, reading asynchronously from Node.js streams is done via callbacks:    ```js function main(inputFilePath) {  const readStream = fs.createReadStream(inputFilePath,  { encoding: 'utf-8', highWaterMark: 1024 });  readStream.on('data', (chunk) => {  console.log('>>> '+chunk);  });  readStream.on('end', () => {  console.log('### DONE ###');  }); }  ```    That is, the stream is in control and pushes data to the reader.    #### [45.3.2 Node.js streams: async via async iteration (pull)](#nodejs-streams-async-via-async-iteration-pull)    Starting with Node.js 10, we can also use asynchronous iteration to read from streams:    ```js async function main(inputFilePath) {  const readStream = fs.createReadStream(inputFilePath,  { encoding: 'utf-8', highWaterMark: 1024 });  `for await (const chunk of readStream) {`  `console.log('>>> '+chunk);`  `}`  `console.log('### DONE ###');` `}`  ```   ```js` This time, the reader is in control and pulls data from the stream.    #### [45.3.3 Example: from chunks to lines](#example-from-chunks-to-lines)    Node.js streams contain *chunks* (arbitrarily long pieces) of data. The following asynchronous generator converts an async iterable over chunks to an async iterable over lines:    ``` /**  * @param chunkIterable An asynchronous or synchronous iterable  * over “chunks” (arbitrary strings)  * @returns An asynchronous iterable over “lines”  * (strings with at most one newline that always appears at the end)  */ async function* chunksToLines(chunkIterable) {  let previous = '';  for await (const chunk of chunkIterable) {  let startSearch = previous.length;  previous += chunk;  while (true) {  // Works for EOL === '\\n' and EOL === '\\r\\n'  const eolIndex = previous.indexOf('\\n', startSearch);  if (eolIndex < 0) break;  // Line includes the EOL  const line = previous.slice(0, eolIndex+1);  yield line;  previous = previous.slice(eolIndex+1);  startSearch = 0;  }  }  if (previous.length > 0) {  yield previous;  } }  ```js    Let’s apply `chunksToLines()` to an async iterable over chunks (as produced by `chunkIterable()`):    ``` async function* chunkIterable() {  yield 'First\\nSec';  yield 'ond\\nThird\\nF';  yield 'ourth'; } const linesIterable = chunksToLines(chunkIterable()); assert.deepEqual(  await asyncIterableToArray(linesIterable),  [  'First\\n',  'Second\\n',  'Third\\n',  'Fourth',  ]);  ```js    Now that we have an asynchronous iterable over lines, we can use the solution of a previous exercise, `numberLines()`, to number those lines:    ``` async function* numberLines(linesAsync) {  let lineNumber = 1;  for await (const line of linesAsync) {  yield lineNumber + ': ' + line;  lineNumber++;  } } const numberedLines = numberLines(chunksToLines(chunkIterable())); assert.deepEqual(  await asyncIterableToArray(numberedLines),  [  '1: First\\n',  '2: Second\\n',  '3: Third\\n',  '4: Fourth',  ]);  ```js ```` ```js`` `````"]