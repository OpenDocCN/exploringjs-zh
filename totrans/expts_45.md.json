["```ts\n[ Required, Optional?, ...RestElement[] ]\n\n```", "```ts\ntype T = [string, boolean?, ...number[]];\nconst v1: T = ['a', true, 1, 2, 3];\nconst v2: T = ['a', true];\nconst v3: T = ['a'];\n// @ts-expect-error: Type '[]' is not assignable to type 'T'.\nconst v4: T = [];\n\n```", "```ts\ntype T1 = [number, ...boolean[], string]; // OK\ntype T2 = [...boolean[], string]; // OK\n\n// @ts-expect-error: A required element cannot follow\n// an optional element.\ntype T3 = [number?, ...boolean[], string];\n\n```", "```ts\ntype T = [string, boolean?, ...number[]];\n\nconst v1: T = ['a', false, 1, 2, 3]; // OK\nconst v2: T = ['a']; // OK\n\n// @ts-expect-error: Type 'number' is not assignable to\n// type 'boolean'.\nconst v3: T = ['a', 1, 2, 3];\n\n```", "```ts\n// @ts-expect-error: Type '[string, undefined, number, number, number]' is\n// not assignable to type 'T'. Type at position 1 in source is not\n// compatible with type at position 1 in target. Type 'undefined' is not\n// assignable to type 'boolean'.\nconst v4: T = ['a', undefined, 1, 2, 3];\n\n```", "```ts\nfunction f(x, y=3, ...z) {\n return {x,y,z};\n}\n\n```", "```ts\n// The `boolean` element can be omitted:\ntype T =\n | [string, boolean, ...number[]]\n | [string, ...number[]]\n;\nconst v1: T = ['a', false, 1, 2, 3]; // OK\nconst v2: T = ['a', 1, 2, 3]; // OK\n\n```", "```ts\ntype Tuple1 = ['a', 'b'];\ntype Tuple2 = [1, 2];\ntype _ = Assert<Equal<\n [true, ...Tuple1, ...Tuple2, false], // type expression\n [ true, 'a', 'b', 1, 2, false ] // result\n>>;\n\n```", "```ts\nconst tuple1 = ['a', 'b'];\nconst tuple2 = [1, 2];\nassert.deepEqual(\n [true, ...tuple1, ...tuple2, false], // expression\n [ true, 'a', 'b', 1, 2, false ] // result\n);\n\n```", "```ts\ntype Spread1<T extends unknown[]> = [...T];\ntype Spread2<T1 extends unknown[], T2 extends unknown[]> =\n [...T1, ...T2]\n;\n\ntype _ = [\n // A tuple with only a spread Array becomes an Array:\n Assert<Equal<\n Spread1<Array<string>>,\n string[]\n >>,\n\n // If an Array is spread at the end, it becomes a rest element:\n Assert<Equal<\n Spread2<['a', 'b'], Array<number>>,\n ['a', 'b', ...number[]]\n >>,\n\n // If two Arrays are spread, they are merged so that there\n // is at most one rest element:\n Assert<Equal<\n Spread2<Array<string>, Array<number>>,\n [...(string | number)[]]\n >>,\n\n // Optional elements after an Array are merged into it:\n Assert<Equal<\n Spread2<Array<string>, [number?, boolean?]>,\n (string | number | boolean | undefined)[]\n >>,\n\n // Optional elements `T` before required ones become `undefined|T`:\n Assert<Equal<\n Spread2<[string?], [number]>,\n [string | undefined, number]\n >>,\n\n // Required elements between Arrays are also merged:\n Assert<Equal<\n Spread2<[boolean, ...number[]], [string, ...bigint[]]>,\n [boolean, ...(string | number | bigint)[]]\n >>,\n];\n\n```", "```ts\ntype Spread1a<T extends unknown[]> = [...T]; // OK\n// @ts-expect-error: A rest element type must be an array type.\ntype Spread1b<T> = [...T];\n\n```", "```ts\ntype Interval = [start: number, end: number];\n\n```", "```ts\ntype Tuple1 = [string, boolean?, ...number[]];\ntype Tuple2 = [requ: string, opt?: boolean, ...rest: number[]];\n\n```", "```ts\ntype _1 = Assert<Equal<\n Parameters<(sym: symbol, bool: boolean) => void>,\n [sym: symbol, bool: boolean]\n>>;\n\n```", "```ts\n// Different labels\ntype _2 = Assert<Equal<\n Parameters<(sym: symbol, bool: boolean) => void>,\n [HELLO: symbol, EVERYONE: boolean]\n>>;\n\n// No labels\ntype _3 = Assert<Equal<\n Parameters<(sym: symbol, bool: boolean) => void>,\n [symbol, boolean]\n>>;\n\n```", "```ts\nfunction f1(...args: [str: string, num: number]) {}\n // function f1(str: string, num: number): void\nfunction f2(...args: [string, number]) {}\n // function f2(args_0: string, args_1: number): void\n\n```", "```ts\n// Overloading with tuples\nfunction f(\n ...args:\n | [str: string, num: number]\n | [num: number]\n | [bool: boolean]\n): void {\n // 路路路\n}\n\n```", "```ts\n// Traditional overloading\nfunction f(str: string, num: number): void;\nfunction f(num: number): void;\nfunction f(bool: boolean): void;\nfunction f(arg0: string | number | boolean, num?: number): void {\n // 路路路\n}\n\n```", "```ts\nconst arr: Array<string> = ['a', 'b', 'c'];\nconst arrayElement = arr[1];\nassertType<string | undefined>(arrayElement);\n\n```", "```ts\nconst tuple: [string, string, string] = ['a', 'b', 'c'];\nconst tupleElement = tuple[1];\nassertType<string>(tupleElement);\n\n```", "```ts\n// Array\nconst value1 = ['a', 1];\nassertType<\n (string | number)[]\n>(value1);\n\n```", "```ts\n// Tuple\nconst value2 = ['a', 1] as const;\nassertType<\n readonly ['a', 1]\n>(value2);\n\n```", "```ts\n// Non-empty tuple\nconst value3 = ['a', 1] satisfies [unknown, ...unknown[]];\nassertType<\n [string, number]\n>(value3);\n\n// Tuple (possibly empty)\nconst value4 = ['a', 1] satisfies [unknown?, ...unknown[]];\nassertType<\n [string, number]\n>(value4);\n\n```", "```ts\n// Tuple\nconst value5 = [\n 'a' as const, 1 as const\n] satisfies [unknown?, ...unknown[]];\nassertType<\n ['a', 1]\n>(value5);\n\n```", "```ts\n// Array\nconst value6 = ['a', 1] satisfies [...unknown[]];\nassertType<\n (string | number)[]\n>(value6);\n\n```", "```ts\n// Tuple\nconst value7 = ['a', 1] satisfies unknown[] | [];\nassertType<\n [string, number]\n>(value7);\n\n```", "```ts\ntype Tuple<T extends Array<unknown>> = T;\nconst arr = ['a', 'b'] as const;\n// @ts-expect-error: Type 'readonly [\"a\", \"b\"]' does not satisfy\n// the constraint 'unknown[]'.\ntype _ = Tuple<typeof arr>;\n\n```", "```ts\ntype Tuple<T extends ReadonlyArray<unknown>> = T;\nconst arr = ['a', 'b'] as const;\ntype Result = Tuple<typeof arr>;\ntype _ = Assert<Equal<\n Result, readonly ['a', 'b']\n>>;\n\n```", "```ts\nReadonlyArray<unknown>\nreadonly unknown[]\n\n```", "```ts\nfunction join3<T extends string[] & {length: 3}>(...strs: T) {\n return strs.join('');\n}\njoin3('a', 'b', 'c'); // OK\n\n// @ts-expect-error: Argument of type '[\"a\", \"b\"]' is not assignable\n// to parameter of type 'string[] & { length: 3; }'.\njoin3('a', 'b');\n\n```", "```ts\nconst arr = ['a', 'b', 'c'];\n// @ts-expect-error: Argument of type 'string[]' is not assignable\n// to parameter of type 'string[] & { length: 3; }'.\njoin3(...arr);\n\n```", "```ts\nconst tuple = ['a', 'b', 'c'] as const;\njoin3(...tuple);\n\n```", "```ts\ntype _ = Assert<Includes<\n keyof Array<string>,\n number | 'length' | 'push' | 'join' // ...\n>>;\n\n```", "```ts\ntype _ = Assert<Includes<\n keyof ['a', 'b'],\n number | '0' | '1' | 'length' | 'push' | 'join'  // ...\n>>;\n\n```", "```ts\ntype _ = Assert<Includes<\n number | 0 | 1,\n number\n>>;\n\n```", "```ts\n> Object.keys(['a', 'b'])\n[ '0', '1' ]\n\n```", "```ts\ntype TupleIndexKeys<T extends ReadonlyArray<unknown>> =\n (keyof T) & `${number}`\n;\n\n```", "```ts\ntype _ = Assert<Equal<\n TupleIndexKeys<['a', 'b']>,\n '0' | '1'\n>>;\n\n```", "```ts\ntype TupleIndices<T extends ReadonlyArray<unknown>> =\n StrToNum<keyof T>\n;\n\n```", "```ts\ntype _ = Assert<Equal<\n TupleIndices<['a', 'b']>,\n 0 | 1\n>>;\n\n```", "```ts\ntype StrToNum<T> =\n T extends `${infer N extends number}` ? N : never // (A)\n;\n\n```", "```ts\ntype _ = Assert<Equal<\n StrToNum<number | '0' | '1' | 'length' | 'push' | 'join'>,\n 0 | 1\n>>;\n\n```", "```ts\ntype MapOverType<Type> = {\n [Key in keyof Type]: Promise<Type[Key]>\n};\n\n```", "```ts\ntype KeyToKey<T> = {\n [K in keyof T]: K\n};\ntype _ = Assert<Equal<\n KeyToKey<['a', 'b']>,\n // Result is a tuple\n ['0', '1']\n>>;\n\n```", "```ts\ntype WrapValues<T> = {\n [Key in keyof T]: Promise<T[Key]>\n};\ntype _ = Assert<Equal<\n WrapValues<[a: number, b: number]>,\n [a: Promise<number>, b: Promise<number>]\n>>;\n\n```", "```ts\ntype KeyAsKeyToKey<T> = {\n [K in keyof T as K]: K\n};\ntype _ = Assert<Equal<\n // Use Pick<> because result of KeyAsKeyToKey<> is large\n Pick<\n KeyAsKeyToKey<['a', 'b']>,\n '0' | '1' | 'length' | 'push' | 'join'\n >,\n // Result is an object, not a tuple\n {\n length: 'length';\n push: 'push';\n join: 'join';\n 0: '0';\n 1: '1';\n }\n>>;\n\n```", "```ts\ntype StringTupleToObject<T extends ReadonlyArray<string>> = {\n [K in TupleIndexKeys<T> as T[K]]: K\n};\ntype _ = Assert<Equal<\n StringTupleToObject<['a', 'b']>,\n {\n a: '0',\n b: '1',\n }\n>>;\n\n```", "```ts\ntype StringTupleToObject<T extends ReadonlyArray<string>> = {\n [K in TupleIndices<T> as T[K]]: K\n};\ntype _ = Assert<Equal<\n StringTupleToObject<['a', 'b']>,\n {\n a: 0,\n b: 1,\n }\n>>;\n\n```", "```ts\ntype AwaitedTuple<T extends ReadonlyArray<unknown>> = {\n -readonly [K in keyof T]: Awaited<T[K]> // (A)\n}\ntype _ = Assert<Equal<\n AwaitedTuple<readonly [Promise<number>, Promise<string>]>,\n [number, string]\n>>;\n\n```", "```ts\nfunction promiseAll<\n T extends ReadonlyArray<unknown> | [] // (A)\n>(values: T): Promise<AwaitedTuple<T>> {\n // 路路路\n}\nconst result = promiseAll(\n [Promise.resolve(123), Promise.resolve('abc')]\n);\nassertType<Promise<[number, string]>>(result);\n\n```", "```ts\ntype UnionOf<Tup extends ReadonlyArray<unknown>> = Tup[number];\n\nconst flowers = ['rose', 'sunflower', 'lavender'] as const;\ntype _ = Assert<Equal<\n UnionOf<typeof flowers>,\n 'rose' | 'sunflower' | 'lavender'\n>>;\n\n```", "```ts\nconst englishSpanishGerman = [\n ['yes', 's铆', 'ja'],\n ['no', 'no', 'nein'],\n ['maybe', 'tal vez', 'vielleicht'],\n] as const;\n\ntype English = (typeof englishSpanishGerman)[number][0];\ntype _1 = Assert<Equal<\n English, 'yes' | 'no' | 'maybe'\n>>;\n\ntype Spanish = (typeof englishSpanishGerman)[number][1];\ntype _2 = Assert<Equal<\n Spanish, 's铆' | 'no' | 'tal vez'\n>>;\n\n```", "```ts\nconst listCounterStyles = [\n { name: 'upperRoman', regExp: /^[IVXLCDM]+$/ },\n { name: 'lowerRoman', regExp: /^[ivxlcdm]+$/ },\n { name: 'upperLatin', regExp: /^[A-Z]$/ },\n { name: 'lowerLatin', regExp: /^[a-z]$/ },\n { name: 'decimal',    regExp: /^[0-9]+$/ },\n] as const satisfies Array<{regExp: RegExp, name: string}>;\n\ntype CounterNames = (typeof listCounterStyles)[number]['name'];\ntype _ = Assert<Equal<\n CounterNames,\n | 'upperRoman' | 'lowerRoman'\n | 'upperLatin' | 'lowerLatin'\n | 'decimal'\n>>;\n\n```", "```ts\ntype First<T extends Array<unknown>> =\nT extends [infer F, ...unknown[]]\n ? F\n : never\n;\ntype _ = Assert<Equal<\n First<['a', 'b', 'c']>,\n 'a'\n>>;\n\n```", "```ts\ntype Last<T extends Array<unknown>> =\nT extends [...unknown[], infer L]\n ? L\n : never\n;\ntype _ = Assert<Equal<\n Last<['a', 'b', 'c']>,\n 'c'\n>>;\n\n```", "```ts\ntype Rest<T extends Array<unknown>> =\nT extends [unknown, ...infer R]\n ? R\n : never\n;\ntype _ = Assert<Equal<\n Rest<['a', 'b', 'c']>,\n ['b', 'c']\n>>;\n\n```", "```ts\ntype LookupTable = {\n [1]: 'a',\n};\ntype _ = [\n Assert<Equal<\n LookupTable[1], 'a'\n >>,\n Assert<Equal<\n LookupTable['1'], 'a'\n >>,\n];\n\n```", "```ts\ntype LookupTable = [\n [undefined, 'undefined'],\n [null, 'null'],\n [boolean, 'boolean'],\n [number, 'number'],\n [bigint, 'bigint'],\n [string, 'string'],\n];\ntype R = Assert<Equal<\n Lookup<LookupTable, string>, 'string'\n>>;\n\n```", "```ts\ntype LookupOne<Pair extends readonly [unknown, unknown], Key> =\n Pair extends [Key, infer Value] ? Value : never;\ntype Lookup<Table extends ReadonlyArray<readonly [unknown, unknown]>, Key> =\n LookupOne<Table[number], Key>;\n\n```", "```ts\ntype _1 = Assert<Equal<\n LookupTable[number],\n | [undefined, 'undefined']\n | [null, 'null']\n | [boolean, 'boolean']\n | [number, 'number']\n | [bigint, 'bigint']\n | [string, 'string']\n>>;\n\n```", "```ts\ntype _2 = [\n Assert<Equal<\n LookupOne<[undefined, 'undefined'], string>,\n never\n >>,\n Assert<Equal<\n LookupOne<[string, 'string'], string>,\n 'string'\n >>,\n];\n\n```", "```ts\ntype _3 = Assert<Equal<\n never | never | never | never | never | 'string',\n 'string' // final result\n>>;\n\n```", "```ts\ntype Concat<T1 extends Array<unknown>, T2 extends Array<unknown>> =\n [...T1, ...T2]\n;\ntype _ = Assert<Equal<\n Concat<['a', 'b'], ['c', 'd']>,\n ['a', 'b', 'c', 'd']\n>>;\n\n```", "```ts\ntype WrapValues<Tup> =\n Tup extends [infer First, ...infer Rest] // (A)\n ? [Promise<First>, ...WrapValues<Rest>] // (B)\n : [] // (C)\n;\ntype _ = Assert<Equal<\n WrapValues<['a', 'b', 'c']>,\n [Promise<'a'>, Promise<'b'>, Promise<'c'>]\n>>;\n\n```", "```ts\ntype Flatten<Tups extends Array<Array<unknown>>> =\n Tups extends [\n infer Tup extends Array<unknown>, // (A)\n ...infer Rest extends Array<Array<unknown>> // (B)\n ]\n ? [...Tup, ...Flatten<Rest>]\n : []\n;\ntype _ = Assert<Equal<\n Flatten<[['a', 'b'], ['c', 'd'], ['e']]>,\n ['a', 'b', 'c', 'd', 'e']\n>>;\n\n```", "```ts\ntype RemoveEmptyStrings<T extends Array<string>> =\n T extends [\n infer First extends string,\n ...infer Rest extends Array<string>\n ]\n ? First extends ''\n ? RemoveEmptyStrings<Rest>\n : [First, ...RemoveEmptyStrings<Rest>]\n : []\n;\ntype _ = Assert<Equal<\n RemoveEmptyStrings<['', 'a', '', 'b', '']>,\n ['a', 'b']\n>>;\n\n```", "```ts\ntype RemoveEmptyStrings<T extends Array<string>> = {\n [K in keyof T as (T[K] extends '' ? never : K)]: T[K]\n};\ntype Filtered = RemoveEmptyStrings<['', 'a', '', 'b', '']>\n // type Filtered = {\n //   [x: number]: \"\" | \"a\" | \"b\";\n //   1: \"a\";\n //   3: \"b\";\n //   length: 5;\n //   toString: () => string;\n //   ...\n // }\n\n```", "```ts\ntype Repeat<\n Len extends number, Value,\n Acc extends Array<unknown> = []\n> = \n Acc['length'] extends Len // (A)\n ? Acc // (B)\n : Repeat<Len, Value, [...Acc, Value]> // (C)\n;\n\ntype _ = [\n Assert<Equal<\n Repeat<3, '*'>,\n ['*', '*', '*']\n >>,\n Assert<Equal<\n Repeat<3, string>,\n [string, string, string]\n >>,\n Assert<Equal<\n Repeat<3, unknown>,\n [unknown, unknown, unknown]\n >>,\n];\n\n```", "```ts\ntype NumRange<Upper extends number, Acc extends number[] = []> =\n Upper extends Acc['length']\n ? Acc\n : NumRange<Upper, [...Acc, Acc['length']]>\n;\ntype _ = Assert<Equal<\n NumRange<3>,\n [0, 1, 2]\n>>;\n\n```", "```ts\ntype Drop<\n Tuple extends Array<unknown>,\n Num extends number,\n Counter extends Array<boolean> = []\n> =\n Counter['length'] extends Num\n ? Tuple\n : Tuple extends [unknown, ...infer Rest extends Array<unknown>]\n ? Drop<Rest, Num, [true, ...Counter]>\n : Tuple\n;\ntype _ = Assert<Equal<\n Drop<['a', 'b', 'c'], 2>,\n ['c']\n>>;\n\n```", "```ts\ntype Drop<\n Tuple extends Array<unknown>,\n Num extends number\n> =\n Tuple extends [...Repeat<Num, unknown>, ...infer Rest]\n ? Rest\n : never\n;\n\n```", "```ts\nfunction applyPartial<\n Func extends (...args: any[]) => any,\n InitialArgs extends unknown[],\n>(func: Func, ...initialArgs: InitialArgs) {\n return (...remainingArgs: RemainingArgs<Func, InitialArgs>)\n : ReturnType<Func> => {\n return func(...initialArgs, ...remainingArgs);\n };\n}\n\n//----- Test -----\n\nfunction add(x: number, y: number): number {\n return x + y;\n}\nconst add3 = applyPartial(add, 3);\ntype _1 = Assert<Equal<\n typeof add3,\n // The parameter name is preserved!\n (y: number) => number\n>>;\n\n```", "```ts\ntype RemainingArgs<\n Func extends (...args: any[]) => any,\n InitialArgs extends unknown[],\n> =\n Func extends (\n ...args: [...InitialArgs,\n ...infer TrailingArgs]\n ) => unknown\n ? TrailingArgs\n : never\n;\n\n//----- Test -----\n\ntype _2 = Assert<Equal<\n RemainingArgs<typeof add, [number]>,\n [y: number]\n>>;\n\n```", "```ts\n> zip([[1, 2, 3], ['a', 'b', 'c']])\n[ [1, 'a'], [2, 'b'], [3, 'c'] ]\n\n```", "```ts\ntype Zip<Tuple extends Array<Iterable<unknown>>> =\n Iterable<\n { [Key in keyof Tuple]: UnwrapIterable<Tuple[Key]> }\n >\n;\ntype UnwrapIterable<Iter> =\n Iter extends Iterable<infer T>\n ? T\n : never\n;\n\ntype _ = Assert<Equal<\n Zip<[Iterable<string>, Iterable<number>]>,\n Iterable<[string, number]>\n>>;\n\n```", "```ts\n> zipObj({num: [1, 2, 3], str: ['a', 'b', 'c']})\n[ {num: 1, str: 'a'}, {num: 2, str: 'b'}, {num: 3, str: 'c'} ]\n\n```", "```ts\ntype ZipObj<Obj extends Record<string, Iterable<unknown>>> =\n Iterable<\n { [Key in keyof Obj]: UnwrapIterable<Obj[Key]> }\n >\n;\ntype UnwrapIterable<Iter> =\n Iter extends Iterable<infer T>\n ? T\n : never\n;\n\ntype _ = Assert<Equal<\n ZipObj<{a: Iterable<string>, b: Iterable<number>}>,\n Iterable<{a: string; b: number}>\n>>;\n\n```", "```ts\n// 0 arguments\nexport function promisify<TResult>(\n fn: (callback: (err: any, result: TResult) => void) => void,\n): () => Promise<TResult>;\nexport function promisify(\n fn: (callback: (err?: any) => void) => void\n): () => Promise<void>;\n\n// 1 argument\nexport function promisify<T1, TResult>(\n fn: (arg1: T1, callback: (err: any, result: TResult) => void) => void,\n): (arg1: T1) => Promise<TResult>;\nexport function promisify<T1>(\n fn: (arg1: T1, callback: (err?: any) => void) => void\n): (arg1: T1) => Promise<void>;\n\n// 2 arguments\nexport function promisify<T1, T2, TResult>(\n fn: (arg1: T1, arg2: T2, callback: (err: any, result: TResult) => void) => void,\n): (arg1: T1, arg2: T2) => Promise<TResult>;\nexport function promisify<T1, T2>(\n fn: (arg1: T1, arg2: T2, callback: (err?: any) => void) => void,\n): (arg1: T1, arg2: T2) => Promise<void>;\n\n// Etc.: up to 5 arguments\n\n```", "```ts\nfunction promisify<Args extends any[], CB extends NodeCallback>(\n fn: (...args: [...Args, CB]) => void,\n): (...args: Args) => Promise<ExtractResultType<CB>> {\n // 路路路\n}\ntype NodeCallback =\n | ((err: any, result: any) => void)\n | ((err: any) => void)\n;\n\n//----- Test -----\n\nfunction nodeFunc(\n arr: Array<string>,\n cb: (err: Error, str: string) => void\n) {}\nconst asyncFunc = promisify(nodeFunc);\nassertType<\n (arr: string[]) => Promise<string>\n>(asyncFunc);\n\n```", "```ts\ntype ExtractResultType<F extends NodeCallback> =\n F extends (err: any) => void\n ? void\n : F extends (err: any, result: infer TResult) => void\n ? TResult\n : never\n;\n\n//----- Test -----\n\ntype _ = [\n Assert<Equal<\n ExtractResultType<(err: Error, result: string) => void>,\n string\n >>,\n Assert<Equal<\n ExtractResultType<(err: Error) => void>,\n void\n >>,\n];\n\n```", "```ts\ntype Same<T> = {a: T, b: T};\n\nfunction one<T>(obj: Same<T>) {}\n// @ts-expect-error: Type 'string' is not assignable to type 'boolean'.\none({a: false, b: 'abc'}); //  error\n\nfunction many<A, B, C, D, E>(\n objs: [Same<A>, Same<B>]\n | [Same<A>, Same<B>, Same<C>]\n | [Same<A>, Same<B>, Same<C>, Same<D>]\n | [Same<A>, Same<B>, Same<C>, Same<D>, Same<E>,\n ...Array<Same<unknown>>]\n) {}\n\nmany([\n {a: true, b: true},\n {a: 'abc', b: 'abc'},\n // @ts-expect-error: Type 'boolean' is not assignable to type 'number'.\n {a: 7, b: false} //  error\n]);\n\n```"]