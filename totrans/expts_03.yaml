- en: 2 Sales pitch for TypeScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 TypeScript 的销售点
- en: 原文：[https://exploringjs.com/ts/book/ch_why-typescript.html](https://exploringjs.com/ts/book/ch_why-typescript.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/ts/book/ch_why-typescript.html](https://exploringjs.com/ts/book/ch_why-typescript.html)
- en: (Ad, please don’t block.)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: (广告，请勿屏蔽。)
- en: '[2.1 Notation used in this chapter](#notation-used-in-this-chapter)'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[2.1 本章使用的符号](#notation-used-in-this-chapter)'
- en: '[2.2 TypeScript benefit: auto-completion and detecting more errors during editing](#typescript-benefit-auto-completion-and-detecting-more-errors-during-editing)'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[2.2 TypeScript 优点：自动完成和编辑时检测更多错误](#typescript-benefit-auto-completion-and-detecting-more-errors-during-editing)'
- en: '[2.2.1 Example: typos, incorrect types, missing arguments](#example-typos-incorrect-types-missing-arguments)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[2.2.1 示例：打字错误、类型错误、缺少参数](#example-typos-incorrect-types-missing-arguments)'
- en: '[2.2.2 Example: getting function results wrong](#example-getting-function-results-wrong)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[2.2.2 示例：函数结果错误](#example-getting-function-results-wrong)'
- en: '[2.2.3 Example: working with optional properties](#example-working-with-optional-properties)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[2.2.3 示例：处理可选属性](#example-working-with-optional-properties)'
- en: '[2.2.4 Example: forgetting switch cases](#example-forgetting-switch-cases)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[2.2.4 示例：忘记 switch 情况](#example-forgetting-switch-cases)'
- en: '[2.2.5 Example: code handles some cases incorrectly](#example-code-handles-some-cases-incorrectly)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[2.2.5 示例：代码处理某些情况不正确](#example-code-handles-some-cases-incorrectly)'
- en: '[2.3 Type annotations for function parameters and results are good documentation](#type-annotations-for-function-parameters-and-results-are-good-documentation)'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[2.3 函数参数和结果的类型注解是良好的文档](#type-annotations-for-function-parameters-and-results-are-good-documentation)'
- en: '[2.4 TypeScript benefit: better refactoring](#typescript-benefit-better-refactoring)'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[2.4 TypeScript 优点：更好的重构](#typescript-benefit-better-refactoring)'
- en: '[2.5 Using TypeScript has become easier](#easier-typescript)'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[2.5 使用 TypeScript 已经变得更容易](#easier-typescript)'
- en: '[2.6 The downsides of using TypeScript](#the-downsides-of-using-typescript)'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[2.6 使用 TypeScript 的缺点](#the-downsides-of-using-typescript)'
- en: '[2.7 TypeScript FAQ](#typescript-faq)'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[2.7 TypeScript 常见问题解答](#typescript-faq)'
- en: '[2.7.1 Is TypeScript code heavyweight?](#is-typescript-code-heavyweight)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[2.7.1 TypeScript 代码是否重量级？](#is-typescript-code-heavyweight)'
- en: '[2.7.2 Is TypeScript trying to turn JavaScript into C# or Java?](#is-typescript-trying-to-turn-javascript-into-c-or-java)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[2.7.2 TypeScript 是否试图将 JavaScript 转变为 C# 或 Java？](#is-typescript-trying-to-turn-javascript-into-c-or-java)'
- en: '[2.7.3 Advanced usage of types seems very complicated. Do I really have to
    learn that?](#advanced-usage-of-types-seems-very-complicated-do-i-really-have-to-learn-that)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[2.7.3 TypeScript 类型的高级使用看起来非常复杂。我真的需要学习这些吗？](#advanced-usage-of-types-seems-very-complicated-do-i-really-have-to-learn-that)'
- en: '[2.7.4 How long does it take to learn TypeScript?](#how-long-does-it-take-to-learn-typescript)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[2.7.4 TypeScript 学习需要多长时间？](#how-long-does-it-take-to-learn-typescript)'
- en: Roughly, TypeScript is JavaScript plus type information. The latter is removed
    before TypeScript code is executed by JavaScript engines. Therefore, writing and
    deploying TypeScript is more work. Is that added work worth it? In this chapter,
    I’m going to argue that yes, it is. Read it if you are skeptical about TypeScript
    but interested in giving it a chance.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 大概来说，TypeScript 是 JavaScript 加上类型信息。后者在 TypeScript 代码由 JavaScript 引擎执行之前被移除。因此，编写和部署
    TypeScript 需要做更多工作。这种额外的工作值得吗？在本章中，我将论证是的，它是值得的。如果你对 TypeScript 持怀疑态度但想给它一个机会，请阅读。
- en: '![Icon “reading”](../Images/00b0d6029a045810b908b88d1a6733d2.png) **You can
    skip this chapter if you’re already sure you want to learn and use TypeScript**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![Icon “reading”](../Images/00b0d6029a045810b908b88d1a6733d2.png) **如果你已经确定想要学习和使用
    TypeScript，可以跳过这一章**'
- en: '[2.1 Notation used in this chapter](#notation-used-in-this-chapter)'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[2.1 本章使用的符号](#notation-used-in-this-chapter)'
- en: 'In TypeScript code, I’ll show the errors reported by TypeScript via comments
    that start with `@ts-expect-error` – e.g.:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 代码中，我将通过以 `@ts-expect-error` 开头的注释展示 TypeScript 报告的错误，例如：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That makes it easier to automatically test all the source code in this chapter.
    It’s also a built-in TypeScript feature that can be useful (albeit rarely).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得自动测试本章中的所有源代码变得更容易。这也是 TypeScript 内置的一个有用功能（尽管很少使用）。
- en: '[2.2 TypeScript benefit: auto-completion and detecting more errors during editing](#typescript-benefit-auto-completion-and-detecting-more-errors-during-editing)'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[2.2 TypeScript 优点：自动完成和编辑时检测更多错误](#typescript-benefit-auto-completion-and-detecting-more-errors-during-editing)'
- en: Let’s look at examples of code where TypeScript helps us – by auto-completing
    and by detecting errors. The first example is simple; later ones are more sophisticated.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 TypeScript 如何通过自动完成和错误检测帮助我们编写代码的示例。第一个示例很简单；后面的示例更复杂。
- en: '[2.2.1 Example: typos, incorrect types, missing arguments](#example-typos-incorrect-types-missing-arguments)'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[2.2.1 示例：拼写错误、类型不正确、缺少参数](#example-typos-incorrect-types-missing-arguments)'
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What is happening here?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？
- en: 'Line A: TypeScript knows the type of `point1` and it doesn’t have a property
    `.z`.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 A：TypeScript 知道 `point1` 的类型，并且它没有属性 `.z`。
- en: 'Line B: `point1.x` is a number and therefore doesn’t have the string method
    `.toUpperCase()`.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 B：`point1.x` 是一个数字，因此没有字符串方法 `.toUpperCase()`。
- en: 'Line C: This invocation works because the second argument of `new Point()`
    is optional.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 C：这个调用之所以有效，是因为 `new Point()` 的第二个参数是可选的。
- en: 'Line D: At least one argument must be provided.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 D：至少必须提供一个参数。
- en: 'Line E: The second argument of `new Point()` must be a number.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 E：`new Point()` 的第二个参数必须是一个数字。
- en: 'In line A, we get auto-completion after `point1.` (the properties `x` and `y`
    of that object):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 A，我们在 `point1.`（该对象的属性 `x` 和 `y`）之后获得自动完成：
- en: '![](../Images/7b1a3c569b4d72f4b590282515bc15ca.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7b1a3c569b4d72f4b590282515bc15ca.png)'
- en: '[2.2.2 Example: getting function results wrong](#example-getting-function-results-wrong)'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[2.2.2 示例：获取函数结果错误](#example-getting-function-results-wrong)'
- en: How many issues can you see in the following JavaScript code?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你能在以下 JavaScript 代码中看到多少问题？
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s see what TypeScript tells us if we add type annotations (line A):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们添加类型注解（行 A），TypeScript 会告诉我们什么：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'TypeScript tells us:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 告诉我们：
- en: 'At the end, there is no `return` statement – which is true: We forgot to start
    line B with `return` and therefore implicitly return `undefined` after line B.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，没有 `return` 语句——这是真的：我们忘记在行 B 中以 `return` 开头，因此在行 B 之后隐式返回 `undefined`。
- en: The implicitly returned `undefined`is incompatible with the return type `string`
    (line A).
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式返回的 `undefined` 与返回类型 `string`（行 A）不兼容。
- en: 'If we fix this issue, TypeScript points out another error:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们修复这个问题，TypeScript 会指出另一个错误：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In line B, we are returning an Array while the return type in line A says that
    we want to return a string. If we fix that issue too, TypeScript is finally happy
    with our code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 B 中，我们返回一个数组，而行 A 中的返回类型表明我们想要返回一个字符串。如果我们修复这个问题，TypeScript 最终会对我们的代码感到满意：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[2.2.3 Example: working with optional properties](#example-working-with-optional-properties)'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[2.2.3 示例：处理可选属性](#example-working-with-optional-properties)'
- en: 'In our next example, we work with names that are defined via objects. We define
    the structure of those objects via the following TypeScrip type:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个示例中，我们处理通过对象定义的名称。我们通过以下 TypeScript 类型定义这些对象的架构：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In other words: NameDef objects have two properties whose values are strings.
    Both properties are optional – which is indicated via the question marks in line
    A and line B.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：NameDef 对象有两个属性，其值是字符串。这两个属性都是可选的——这在行 A 和行 B 中的问号中表示。
- en: 'The following code contains an error and TypeScript warns us about it:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码包含一个错误，TypeScript 警告我们：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`??` is the nullish coalescing operator that returns its left-hand side – unless
    it is `undefined` or `null`. In that case, it returns its right-hand side. For
    more information, see [“Exploring JavaScript”](https://exploringjs.com/js/book/ch_undefined-null.html#nullish-coalescing-operator).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`??` 是空合并运算符，它返回其左侧值——除非它是 `undefined` 或 `null`。在这种情况下，它返回其右侧值。有关更多信息，请参阅[“探索
    JavaScript”](https://exploringjs.com/js/book/ch_undefined-null.html#nullish-coalescing-operator)。'
- en: '`nameDef.name` may be missing. In that case, the result is `undefined` and
    not a string. If we fix that, TypeScript does not report any more errors:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`nameDef.name` 可能不存在。在这种情况下，结果是 `undefined` 而不是字符串。如果我们修复这个问题，TypeScript 就不会再报告任何错误：'
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[2.2.4 Example: forgetting switch cases](#example-forgetting-switch-cases)'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[2.2.4 示例：忘记 switch 情况](#example-forgetting-switch-cases)'
- en: 'Consider the following type for colors:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下颜色类型：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In other words: a color is either the string `''red''` or the string `''green''`
    or the string `''blue''`. The following function translates such colors to CSS
    hexadecimal color values:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：颜色可以是字符串 `'red'`、`'green'` 或 `'blue'`。以下函数将此类颜色转换为 CSS 十六进制颜色值：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In line A, we get an error because we return a string that is incompatible
    with the return type `` `#${string}` ``: It does not start with a hash symbol.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 A，我们得到一个错误，因为我们返回了一个与返回类型 `` `#${string}` `` 不兼容的字符串：它不以井号符号开头。
- en: 'The error in line C means that we forgot a case (the value `''blue''`). To
    understand the error message, we must know that TypeScript continually adapts
    the type of `color`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 行 C 中的错误意味着我们忘记了一个情况（值 `'blue'`）。为了理解错误信息，我们必须知道 TypeScript 会持续调整 `color` 的类型：
- en: Before the `switch` statement, its type is `'red' | 'green' | 'blue'`.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `switch` 语句之前，其类型是 `'red' | 'green' | 'blue'`。
- en: After we crossed off the cases `'red'` and `'green'`, its type is `'blue'` in
    line B.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们划掉了`'red'`和`'green'`这两种情况后，它在B行中的类型是`'blue'`。
- en: And that type is incompatible with the special type `never` that the parameter
    of `new UnexpectedValueError()` has. That type is used for variables at locations
    that we never reach. For more information see [“The bottom type `never`” (§15)](ch_never.html#ch_never).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 而且这种类型与`new UnexpectedValueError()`参数的特殊类型`never`不兼容。这种类型用于我们永远不会到达的位置的变量。更多信息请参阅[“底类型`never`”（§15）](ch_never.html#ch_never)。
- en: 'After we fix both errors, our code looks like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 修复了这两个错误后，我们的代码看起来是这样的：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is what the error class `UnexpectedValueError` looks like:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是错误类`UnexpectedValueError`的样子：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Lastly, TypeScript gives us auto-completion for the argument of `getCssColor()`
    (the values `''blue''`, `''green''` and `''red''` that we can use for it):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，TypeScript为我们提供了`getCssColor()`（我们可以用于它的`'blue'`、`'green'`和`'red'`等值）参数的自动完成功能：
- en: '![](../Images/3912e75bc5156e6c1c88db9527658f69.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3912e75bc5156e6c1c88db9527658f69.png)'
- en: '[2.2.5 Example: code handles some cases incorrectly](#example-code-handles-some-cases-incorrectly)'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[2.2.5   示例：代码处理某些情况不正确](#example-code-handles-some-cases-incorrectly)'
- en: 'The following type describes content via objects. Content can be text, an image
    or a video:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类型通过对象描述内容。内容可以是文本、图片或视频：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the following code, we use content incorrectly:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们错误地使用了内容：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'TypeScript warns us because not all kinds of content have the property `.content`.
    However, they all do have the property `.kind` – which we can use to fix the error:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript会警告我们，因为并非所有内容都有`.content`属性。然而，它们都有`.kind`属性——我们可以用它来修复错误：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that TypeScript does not complain in line A, because we have excluded text
    content, which is the only content that does not have the property `.width`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，TypeScript在A行不会报错，因为我们排除了文本内容，这是唯一没有`.width`属性的内容。
- en: '[2.3 Type annotations for function parameters and results are good documentation](#type-annotations-for-function-parameters-and-results-are-good-documentation)'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[2.3   函数参数和结果的类型注解是良好的文档](#type-annotations-for-function-parameters-and-results-are-good-documentation)'
- en: 'Consider the following JavaScript code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下JavaScript代码：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That does not tell us much about the arguments expected by `filter()`. We also
    don’t know what it returns. In contrast, this is what the corresponding TypeScript
    code looks like:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有告诉我们`filter()`期望的参数很多。我们也不知道它返回什么。相比之下，这是相应的TypeScript代码的样子：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This information tells us:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这条信息告诉我们：
- en: Argument `items` is an iterable over strings.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数`items`是一个字符串的可迭代对象。
- en: The `callback` receives a string and an index and returns a boolean.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback`接收一个字符串和一个索引，并返回一个布尔值。'
- en: The result of `filter()` is another iterable over strings.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter()`的结果是另一个字符串的可迭代对象。'
- en: Yes, the type notation takes getting used to. But, once we understand it, we
    can quickly get a rough understand of what `filter()` does. More quickly than
    by reading prose in English (which, admittedly, is still needed to fill in the
    gaps left by the type notation and the name of the function).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，类型符号需要一段时间来习惯。但是，一旦我们理解了它，我们就可以快速地大致了解`filter()`函数的作用。比阅读英文散文（诚然，这仍然是必要的，以填补类型符号和函数名称留下的空白）要快。
- en: I find it easier to understand TypeScript code bases than JavaScript code bases
    because, to me, TypeScript provides an additional layer of documentation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现理解TypeScript代码库比JavaScript代码库更容易，因为对我来说，TypeScript提供了一层额外的文档。
- en: This additional documentation also helps when working in teams because it is
    clearer how code is to be used and TypeScript often warns us if we are doing something
    wrong.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这额外的文档也有助于团队协作，因为它更清楚地说明了代码应该如何使用，并且TypeScript经常警告我们如果我们在做错事。
- en: 'Whenever I migrate JavaScript code to TypeScript, I’m noticing an interesting
    phenomenon: In order to find the appropriate types for the parameters of a function
    or method, I have to check where it is invoked. That means that static types give
    me information locally that I otherwise have to look up elsewhere.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我将JavaScript代码迁移到TypeScript时，我都会注意到一个有趣的现象：为了找到函数或方法的参数的适当类型，我必须检查它在何处被调用。这意味着静态类型给了我本地信息，否则我必须在其他地方查找。
- en: '[2.4 TypeScript benefit: better refactoring](#typescript-benefit-better-refactoring)'
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[2.4   TypeScript的优势：更好的重构](#typescript-benefit-better-refactoring)'
- en: Refactorings are automated code transformations that many integrated development
    environments offer.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重构是许多集成开发环境提供的自动化代码转换。
- en: Renaming methods is an example of a refactoring. Doing so in plain JavaScript
    can be tricky because the same name might refer to different methods. TypeScript
    has more information on how methods and types are connected, which makes renaming
    methods safer there.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名方法是重构的一个例子。在纯JavaScript中这样做可能很棘手，因为同一个名称可能指向不同的方法。TypeScript有更多关于方法和类型之间联系的信息，这使得在TypeScript中重命名方法更安全。
- en: '[2.5 Using TypeScript has become easier](#easier-typescript)'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[2.5 使用TypeScript变得更容易](#easier-typescript)'
- en: 'We now often don’t need an extra build step compared to JavaScript:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与JavaScript相比，我们现在通常不需要额外的构建步骤：
- en: On server side JavaScript platforms such as Node.js, Deno and Bun, we can run
    TypeScript directly – without compiling it.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Node.js、Deno和Bun等服务器端JavaScript平台上，我们可以直接运行TypeScript——无需编译。
- en: Most bundlers such as Vite have built-in support for TypeScript.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数打包器，如Vite，都内置了对TypeScript的支持。
- en: 'More good news:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的消息：
- en: Compiling TypeScript to JavaScript has become more efficient – thanks to a technique
    called *type stripping* which simply removes the type part of TypeScript syntax
    and makes no other transformations ([more information](ch_tsconfig-json.html#type-stripping)).
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将TypeScript编译成JavaScript的效率已经提高——多亏了一种称为*类型剥离*的技术，它简单地移除了TypeScript语法中的类型部分，而没有进行其他转换（[更多信息](ch_tsconfig-json.html#type-stripping)）。
- en: 'Creating packages has also improved:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 创建包的功能也得到了改进：
- en: 'npm: Non-library packages can be published in TypeScript. Library packages
    must contain JavaScript plus *declaration files* (with type information). Generating
    the latter has also improved – thanks to a technique called [*isolated declarations*](ch_tsconfig-json.html#isolatedDeclarations).'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: npm：非库包可以用TypeScript发布。库包必须包含JavaScript以及*声明文件*（包含类型信息）。生成后者也得到了改进——多亏了一种称为[*隔离声明*](ch_tsconfig-json.html#isolatedDeclarations)的技术。
- en: '[JSR (JavaScript Registry)](https://jsr.io) is an alternative to npm where
    packages can be uploaded as TypeScript. It supports a variety of platforms. For
    Node.js, it automatically generates JavaScript files and declaration files.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[JSR (JavaScript Registry)](https://jsr.io) 是npm的一个替代品，其中可以上传TypeScript包。它支持多种平台。对于Node.js，它自动生成JavaScript文件和声明文件。'
- en: Alas, type checking is still relatively slow and must be performed via the TypeScript
    compiler `tsc`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，类型检查仍然相对较慢，必须通过TypeScript编译器`tsc`来执行。
- en: '[2.6 The downsides of using TypeScript](#the-downsides-of-using-typescript)'
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[2.6 使用TypeScript的缺点](#the-downsides-of-using-typescript)'
- en: 'It is an added layer on top of JavaScript: more complexity, more things to
    learn, etc.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是在JavaScript之上的一个附加层：更多的复杂性，更多需要学习的东西，等等。
- en: npm packages can only be used if they have static type definitions. These days,
    most packages either come with type definitions or there are type definitions
    available for them on [DefinitelyTyped](http://definitelytyped.org). However,
    especially the latter can occasionally be slightly wrong, which leads to issues
    that you don’t have without static typing.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: npm包只能在使用时具有静态类型定义。如今，大多数包都附带类型定义，或者可以在[DefinitelyTyped](http://definitelytyped.org)上找到它们的类型定义。然而，后者偶尔可能会有些许错误，这会导致在没有静态类型的情况下不会出现的问题。
- en: 'Configuring TypeScript via `tsconfig.json` also adds a bit of complexity and
    means that there is a lot of variation w.r.t. how TypeScript code bases are type-checked.
    There are two mitigating factors:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`tsconfig.json`配置TypeScript也增加了一点点复杂性，意味着TypeScript代码库的类型检查方式有很大的差异。有两个缓解因素：
- en: For my own projects, I’m now using [a maximally strict `tsconfig.json`](ch_tsconfig-json.html#tsconfig-summary)
    – which eliminated my doubts about what my `tsconfig.json` should look like.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于我自己的项目，我现在使用一个尽可能严格的`tsconfig.json`——这消除了我对`tsconfig.json`应该是什么样子的疑虑。
- en: 'Type stripping (see previous section) has clarified the role of `tsconfig.json`
    for me: With them, it only configures how type checking works. Generating JavaScript
    can be done without `tsconfig.json`.'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型剥离（见上一节）让我对`tsconfig.json`的作用有了更清晰的认识：有了它们，它只配置了类型检查的工作方式。生成JavaScript可以不使用`tsconfig.json`。
- en: '[2.7 TypeScript FAQ](#typescript-faq)'
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[2.7 TypeScript FAQ](#typescript-faq)'
- en: '[2.7.1 Is TypeScript code heavyweight?](#is-typescript-code-heavyweight)'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[2.7.1 TypeScript代码重量级吗？](#is-typescript-code-heavyweight)'
- en: 'TypeScript code *can* be heavyweight. But it doesn’t have to be. For example,
    due to type inference, we can often get away with relatively few type annotations:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript代码*可以是重量级的。但它不必是。例如，由于类型推断，我们通常可以少用一些类型注解：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The only non-JavaScript syntax in this code is `<T>`: Its first occurrence
    `setDifference<T>` means that the function `setDifference()` has a *type parameter*
    – a parameter at the type level. All later occurrences of `<T>` refer to that
    parameter. They mean:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中唯一的非 JavaScript 语法是 `<T>`：其首次出现 `setDifference<T>` 表示 `setDifference()`
    函数有一个 *类型参数*——一个在类型级别的参数。所有后续的 `<T>` 出现都指的是该参数。它们的意思是：
- en: The parameters `set1` and `set2` are Sets whose elements have the same type
    `T`.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数 `set1` 和 `set2` 是具有相同类型 `T` 的集合。
- en: The result is also a Set. Its elements have the same type as those of `set1`
    and `set2`.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果也是一个集合。其元素与 `set1` 和 `set2` 的元素具有相同的类型。
- en: 'Note that we normally don’t have to provide the type parameter `<T>` – TypeScript
    can extract it automatically from the types of the parameters:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们通常不需要提供类型参数 `<T>`——TypeScript 可以自动从参数的类型中提取它：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When it comes to *using* `setDifference()`, the TypeScript code is not different
    from JavaScript code in this case.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 *使用* `setDifference()` 时，TypeScript 代码在这种情况下与 JavaScript 代码没有区别。
- en: '[2.7.2 Is TypeScript trying to turn JavaScript into C# or Java?](#is-typescript-trying-to-turn-javascript-into-c-or-java)'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[2.7.2 TypeScript 是否试图将 JavaScript 转变为 C# 或 Java？](#is-typescript-trying-to-turn-javascript-into-c-or-java)'
- en: Over time, the nature of TypeScript has evolved.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，TypeScript 的本质已经发生了演变。
- en: TypeScript 0.8 was released in October 2012 when JavaScript had remained stagnant
    for a long time. Therefore, TypeScript added features that its team felt JavaScript
    was missing - e.g. classes, modules and enums.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 0.8 在 2012 年 10 月发布，当时 JavaScript 已经停滞不前很长时间。因此，TypeScript 添加了其团队认为
    JavaScript 缺失的功能——例如，类、模块和枚举。
- en: 'Since then, JavaScript has gained many new features. TypeScript now tracks
    what JavaScript provides and does not introduce new language-level features anymore
    – for example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，JavaScript 获得了许多新特性。现在 TypeScript 跟踪 JavaScript 提供的内容，并且不再引入新的语言级特性——例如：
- en: In 2012, TypeScript had its own way of doing modules. Now it supports ECMAScript
    modules and CommonJS.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2012 年，TypeScript 有自己的模块实现方式。现在它支持 ECMAScript 模块和 CommonJS。
- en: In 2012, TypeScript had classes that were transpiled to functions. Since ECMAScript
    6 came out in 2015, TypeScript has supported the built-in classes.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2012 年，TypeScript 有将类转换为函数的类。自从 2015 年 ECMAScript 6 发布以来，TypeScript 支持内置类。
- en: In 2015, TypeScript introduced its own flavor of decorators, in order to support
    Angular. In 2022, ECMAScript decorators reached stage 3 and TypeScript has supported
    them since. For more information, see section [“The history of decorators”](https://2ality.com/2022/10/javascript-decorators.html#the-history-of-decorators)
    in the 2ality post on ECMAScript decorators.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2015 年，TypeScript 引入了其自己的装饰器风格，以支持 Angular。到 2022 年，ECMAScript 装饰器达到了第 3 阶段，TypeScript
    一直支持它们。有关更多信息，请参阅 2ality 关于 ECMAScript 装饰器的帖子中的 [“装饰器的历史”](https://2ality.com/2022/10/javascript-decorators.html#the-history-of-decorators)
    部分。
- en: If the type checking option [`erasableSyntaxOnly`](ch_tsconfig-json.html#erasableSyntaxOnly)
    is active, TypeScript only supports JavaScript’s language features – e.g. we are
    not allowed to use enums. This option enables [type stripping](#easier-typescript)
    and is popular among TypeScript programmers. Thus it looks like in the future,
    most TypeScript will really be pure JavaScript plus type information.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类型检查选项 `erasableSyntaxOnly`（见 ch_tsconfig-json.html#erasableSyntaxOnly）处于激活状态，TypeScript
    仅支持 JavaScript 的语言特性——例如，我们不允许使用枚举。此选项启用 [类型剥离](#easier-typescript)，并且在 TypeScript
    程序员中很受欢迎。因此，看起来在将来，大多数 TypeScript 将真正是纯 JavaScript 加上类型信息。
- en: TypeScript will only get better enums or pattern matching if and when JavaScript
    gets them.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当 JavaScript 获得枚举或模式匹配时，TypeScript 才会得到更好的枚举或模式匹配。
- en: '[2.7.2.1 TypeScript is more than OOP](#typescript-is-more-than-oop)'
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[2.7.2.1 TypeScript 不仅仅是 OOP](#typescript-is-more-than-oop)'
- en: 'A common misconception is that TypeScript only supports a class-heavy OOP style;
    it supports many functional programming patterns just as well – e.g. *discriminated
    unions* which are a (slightly less elegant) version of algebraic data types:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的误解是 TypeScript 只支持以类为主的 OOP 风格；它同样支持许多函数式编程模式——例如，*区分联合*，它是代数数据类型的一个（稍微不那么优雅）版本：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In Haskell, this data type would look like this (without labels, for simplicity’s
    sake):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Haskell 中，这种数据类型看起来是这样的（为了简单起见，没有标签）：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'More information: [“TypeScript for functional programmers”](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html)
    in the TypeScript Handbook.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息：TypeScript 手册中的 [“TypeScript for functional programmers”](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html)。
- en: '[2.7.3 Advanced usage of types seems very complicated. Do I really have to
    learn that?](#advanced-usage-of-types-seems-very-complicated-do-i-really-have-to-learn-that)'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[2.7.3 TypeScript 类型的高级使用似乎非常复杂。我真的需要学习这些吗？](#advanced-usage-of-types-seems-very-complicated-do-i-really-have-to-learn-that)'
- en: Normal use of TypeScript almost always involves relatively simple types. For
    libraries, complicated types can be useful but then they are complicated to write
    and not complicated to use. My general recommendation is to make types as simple
    as possible and therefore easier to understand and maintain. If types for code
    are too complicated then it’s often possible to simplify them – e.g. by changing
    the code and using two functions instead of one or by not capturing every last
    detail with them.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的常规使用几乎总是涉及相对简单的类型。对于库来说，复杂的类型可能很有用，但编写起来复杂，使用起来并不复杂。我的总体建议是尽可能简化类型，这样更容易理解和维护。如果代码中的类型过于复杂，那么通常可以简化它们——例如，通过更改代码并使用两个函数而不是一个，或者不使用它们捕捉每一个细节。
- en: 'One key insight for making sense of advanced types, is that they are mostly
    like a new programming language at the type level and usually describe how input
    types are transformed into output types. In many ways, they are similar to JavaScript.
    There are:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 理解高级类型的一个关键见解是，它们在类型级别上大多像是一种新的编程语言，通常描述输入类型如何转换为输出类型。在许多方面，它们与 JavaScript 类似。包括：
- en: Variables (type variables)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量（类型变量）
- en: Functions with parameters (generic types with type parameters)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有参数的函数（具有类型参数的泛型类型）
- en: 'Conditional expressions `C ? T : F` (conditional types)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '条件表达式 `C ? T : F`（条件类型）'
- en: Loops over objects (mapped types)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象循环（映射类型）
- en: Etc.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等等。
- en: 'For more information on this topic, see [“Overview: computing with types” (§33)](ch_computing-with-types-overview.html#ch_computing-with-types-overview).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个主题的更多信息，请参阅[“概述：使用类型进行计算”（§33）](ch_computing-with-types-overview.html#ch_computing-with-types-overview)。
- en: '[2.7.3.1 Are complicated types worth it?](#are-complicated-types-worth-it)'
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[2.7.3.1 复杂类型值得学习吗？](#are-complicated-types-worth-it)'
- en: Sometimes they are – for example, as an experiment, I wrote [a simple SQL API](https://github.com/rauschma/simple-sql)
    that gives you a lot of type completions and warnings during editing (if you make
    typos etc). Note that writing that API involved some work; using it is simple.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候是这样的——例如，作为一个实验，我编写了一个简单的 SQL API（[a simple SQL API](https://github.com/rauschma/simple-sql)），在编辑过程中会提供大量的类型补全和警告（如果你输入了错误等）。请注意，编写这个
    API 涉及了一些工作；使用它很简单。
- en: '[2.7.4 How long does it take to learn TypeScript?](#how-long-does-it-take-to-learn-typescript)'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[2.7.4 TypeScript 学习需要多长时间？](#how-long-does-it-take-to-learn-typescript)'
- en: I believe that you can learn the basics of TypeScript within a day and be productive
    the next day. There is still more to learn after that, but you can do so while
    already using it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为你可以在一天内学会 TypeScript 的基础知识，并在第二天开始高效使用。在那之后，还有很多东西可以学习，但你可以在使用它的同时进行学习。
- en: '[“The basics of TypeScript” (§4)](ch_typescript-essentials.html#ch_typescript-essentials)
    teaches you those basics. If you are new to TypeScript, I’d love to hear from
    you: Is my assumption correct? Were you able to write (simple) TypeScript after
    reading it?'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[“TypeScript 的基础知识”（§4）](ch_typescript-essentials.html#ch_typescript-essentials)
    教授你这些基础知识。如果你是 TypeScript 的新手，我很乐意听到你的意见：我的假设正确吗？你在阅读之后能否写出（简单的）TypeScript 代码？'
