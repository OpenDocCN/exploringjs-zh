["```ts\ntype Shape = Triangle | Rectangle | Circle;\n\ntype Triangle = {\n corner1: Point,\n corner2: Point,\n corner3: Point,\n};\ntype Rectangle = {\n corner1: Point,\n corner2: Point,\n};\ntype Circle = {\n center: Point,\n radius: number,\n};\n\ntype Point = {\n x: number,\n y: number,\n};\n\n```", "```ts\ntype VirtualFileSystem = Map<string, FileEntry>;\n\ntype FileEntry = FileEntryData | FileEntryGenerator | FileEntryFile;\ntype FileEntryData = {\n data: string,\n};\ntype FileEntryGenerator = {\n generator: (path: string) => string,\n};\ntype FileEntryFile = {\n path: string,\n};\n\n```", "```ts\nconst vfs: VirtualFileSystem = new Map([\n [ '/tmp/file.txt',\n { data: 'Hello!' }\n ],\n [ '/tmp/echo.txt',\n { generator: (path: string) => path }\n ],\n]);\nassert.equal(\n readFile(vfs, '/tmp/file.txt'), // (A)\n 'Hello!'\n);\nassert.equal(\n readFile(vfs, '/tmp/echo.txt'), // (B)\n '/tmp/echo.txt'\n);\n\n```", "```ts\nimport * as fs from 'node:fs';\nfunction readFile(vfs: VirtualFileSystem, path: string): string {\n const fileEntry = vfs.get(path);\n if (fileEntry === undefined) {\n throw new Error('Unknown path: ' + JSON.stringify(path));\n }\n if ('data' in fileEntry) { // (A)\n return fileEntry.data;\n } else if ('generator' in fileEntry) { // (B)\n return fileEntry.generator(path);\n } else if ('path' in fileEntry) { // (C)\n return fs.readFileSync(fileEntry.path, 'utf-8');\n } else {\n throw new UnexpectedValueError(fileEntry); // (D)\n }\n}\n\n```", "```ts\nFileEntryData | FileEntryGenerator | FileEntryFile\n\n```", "```ts\nclass UnexpectedValueError extends Error {\n constructor(_value: never) {\n super();\n }\n}\n\n```", "```ts\ntype FileEntry =\n | {\n kind: 'FileEntryData',\n data: string,\n }\n | {\n kind: 'FileEntryGenerator',\n generator: (path: string) => string,\n }\n | {\n kind: 'FileEntryFile',\n path: string,\n }\n ;\ntype VirtualFileSystem = Map<string, FileEntry>;\n\n```", "```ts\ndata FileEntry = FileEntryData String\n | FileEntryGenerator (String -> String)\n | FileEntryFile String\n\n```", "```ts\nfunction readFile(vfs: VirtualFileSystem, path: string): string {\n const fileEntry = vfs.get(path);\n if (fileEntry === undefined) {\n throw new Error('Unknown path: ' + JSON.stringify(path));\n }\n switch (fileEntry.kind) {\n case 'FileEntryData':\n return fileEntry.data;\n case 'FileEntryGenerator':\n return fileEntry.generator(path);\n case 'FileEntryFile':\n return fs.readFileSync(fileEntry.path, 'utf-8');\n default:\n throw new UnexpectedValueError(fileEntry);\n }\n}\n\n```", "```ts\ntype Shape =\n| {\n tag: 'Triangle',\n corner1: Point,\n corner2: Point,\n corner3: Point,\n}\n| {\n tag: 'Rectangle',\n corner1: Point,\n corner2: Point,\n}\n| {\n tag: 'Circle',\n center: Point,\n radius: number,\n}\n;\n\n```", "```ts\ntype Temperature =\n | {\n type: 'TemperatureCelsius',\n value: number,\n }\n | {\n type: 'TemperatureFahrenheit',\n value: number,\n }\n;\n\n```", "```ts\ntype OutputPathDef =\n | null // same as input path\n | '' // stem of output path\n | string // output path with different extension\n\n```", "```ts\ntype OutputPathDef =\n | { key: 'sameAsInputPath' }\n | { key: 'inputPathStem' }\n | { key: 'inputPathStemPlusExt', ext: string }\n ;\n\n```", "```ts\nimport * as path from 'node:path';\nfunction deriveOutputPath(def: OutputPathDef, inputPath: string): string {\n if (def.key === 'sameAsInputPath') {\n return inputPath;\n }\n const parsed = path.parse(inputPath);\n const stem = path.join(parsed.dir, parsed.name);\n switch (def.key) {\n case 'inputPathStem':\n return stem;\n case 'inputPathStemPlusExt':\n return stem + def.ext;\n }\n}\nconst zip = { key: 'inputPathStemPlusExt', ext: '.zip' } as const;\nassert.equal(\n deriveOutputPath(zip, '/tmp/my-dir'),\n '/tmp/my-dir.zip'\n);\n\n```", "```ts\ntype Content =\n | {\n kind: 'text',\n charCount: number,\n }\n | {\n kind: 'image',\n width: number,\n height: number,\n }\n | {\n kind: 'video',\n width: number,\n height: number,\n runningTimeInSeconds: number,\n }\n;\n\n```", "```ts\ntype GetKind<T extends {kind: string}> =\n T['kind'];\n\ntype ContentKind = GetKind<Content>;\n\ntype _ = Assert<Equal<\n ContentKind,\n 'text' | 'image' | 'video'\n>>;\n\n```", "```ts\nconst DESCRIPTIONS_FULL: Record<ContentKind, string> = {\n text: 'plain text',\n image: 'an image',\n video: 'a video',\n} as const;\n\n```", "```ts\nconst DESCRIPTIONS_PARTIAL: Partial<Record<ContentKind, string>> = {\n text: 'plain text',\n} as const;\n\n```", "```ts\ntype ExtractSubtype<\n Union extends {kind: string},\n SubKinds extends GetKind<Union> // (A)\n> =\n Union extends {kind: SubKinds} ? Union : never // (B)\n;\n\n```", "```ts\ntype _ = Assert<Equal<\n ExtractSubtype<Content, 'text' | 'image'>,\n | {\n kind: 'text',\n charCount: number,\n }\n | {\n kind: 'image',\n width: number,\n height: number,\n }\n>>;\n\n```", "```ts\ntype _ = Assert<Equal<\n Extract<Content, {kind: 'text' | 'image'}>,\n | {\n kind: 'text',\n charCount: number,\n }\n | {\n kind: 'image',\n width: number,\n height: number,\n }\n>>;\n\n```", "```ts\n{kind: 'text' | 'image'}\n\n```", "```ts\n1 + 2 + 3\n\n```", "```ts\nabstract class SyntaxTree {\n abstract evaluate(): number;\n}\n\nclass NumberValue extends SyntaxTree {\n numberValue: number;\n constructor(numberValue: number) {\n super();\n this.numberValue = numberValue;\n }\n evaluate(): number {\n return this.numberValue;\n }\n}\nclass Addition extends SyntaxTree {\n operand1: SyntaxTree;\n operand2: SyntaxTree;\n constructor(operand1: SyntaxTree, operand2: SyntaxTree) {\n super();\n this.operand1 = operand1;\n this.operand2 = operand2;\n }\n evaluate(): number {\n return this.operand1.evaluate() + this.operand2.evaluate();\n }\n}\n\n```", "```ts\nconst syntaxTree = new Addition(\n new NumberValue(1),\n new Addition(\n new NumberValue(2),\n new NumberValue(3),\n ),\n);\nassert.equal(\n syntaxTree.evaluate(), 6\n);\n\n```", "```ts\ntype SyntaxTree =\n | {\n kind: 'NumberValue';\n numberValue: number;\n }\n | {\n kind: 'Addition';\n operand1: SyntaxTree;\n operand2: SyntaxTree; \n }\n;\n\nfunction evaluate(syntaxTree: SyntaxTree): number {\n switch(syntaxTree.kind) {\n case 'NumberValue':\n return syntaxTree.numberValue;\n case 'Addition':\n return (\n evaluate(syntaxTree.operand1) +\n evaluate(syntaxTree.operand2)\n );\n default:\n throw new UnexpectedValueError(syntaxTree);\n }\n}\n\n```", "```ts\nconst syntaxTree: SyntaxTree = {\n kind: 'Addition',\n operand1: {\n kind: 'NumberValue',\n numberValue: 1,\n },\n operand2: {\n kind: 'Addition',\n operand1: {\n kind: 'NumberValue',\n numberValue: 2,\n },\n operand2: {\n kind: 'NumberValue',\n numberValue: 3,\n },\n }\n};\nassert.equal(\n evaluate(syntaxTree), 6\n);\n\n```", "```ts\ntype Color = Black | White;\n\nabstract class AbstractColor {}\nclass Black extends AbstractColor {\n readonly kind = 'Black';\n}\nclass White extends AbstractColor {\n readonly kind = 'White';\n}\n\nfunction colorToRgb(color: Color): string {\n switch (color.kind) {\n case 'Black':\n return '#000000';\n case 'White':\n return '#FFFFFF';\n }\n}\n\n```"]