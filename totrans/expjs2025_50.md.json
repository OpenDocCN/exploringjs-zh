["```js\nwhile (true) {\n const task = taskQueue.dequeue();\n task(); // run task\n}\n\n```", "```js\n<a id=\"block\" href=\"\">Block</a>\n<div id=\"statusMessage\"></div>\n<button>Click me!</button>\n\n```", "```js\ndocument.getElementById('block')\n .addEventListener('click', doBlock); // (A)\n `function doBlock(event) {`\n `// ···`\n `displayStatus('Blocking...');`\n `// ···`\n `sleep(5000); // (B)`\n `displayStatus('Done');`\n`}`\n `` `function sleep(milliseconds) {`  `const start = Date.now();`  `while ((Date.now() - start) < milliseconds);` `}` `function displayStatus(status) {`  `document.getElementById('statusMessage')`  `.textContent = status;` `}` `` \n```", "```js```", "``` ```", "````` These are the key parts of the code:    *   Line A: We tell the browser to call `doBlock()` whenever the HTML element is clicked whose ID is `block`. *   `doBlock()` displays status information and then calls `sleep()` to block the JavaScript process for 5000 milliseconds (line B). *   `sleep()` blocks the JavaScript process by looping until enough time has passed. *   `displayStatus()` displays status messages inside the `<div>` whose ID is `statusMessage`.    #### [42.2.2 How can we avoid blocking the browser?](#avoiding-blocking-browser)    How can we prevent a long-running operation from blocking the browser?    *   The operation can deliver its result *asynchronously*: Some operations, such as downloading files, run outside the JavaScript process and concurrently with it. If we invoke such an operation, we provide it with a callback. Once the operation is done, it calls the callback with the result (by adding a task to the queue). This style of delivering a result is called *asynchronous* because the invoker isn’t blocked while it waits for the result: It can do other things and is notified when the result is ready. Normal function invocations deliver their results synchronously. Our own code can also deliver results asynchronously. We’ll learn more about asynchronous code soon.           *   The operation can be performed in a separate process: This can be done via so-called *Web Workers*. A Web Worker is a heavyweight process that runs concurrently to the main process. It has its own runtime environment (global variables, etc.). It is completely isolated; communication happens via message passing. See [MDN web docs](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API) for more information.           *   The operation can take breaks and give pending tasks in the queue a chance to run – which unblocks the browser. The next subsection explains how that is done.              #### [42.2.3 Scheduling new tasks via `setTimeout()`](#setTimeout)    The following global function executes its parameter `callback` after a delay of `ms` milliseconds (the type signature is simplified – `setTimeout()` has more features):    ```js function setTimeout(callback: () => void, ms: number): any  ```    The function returns a *handle* (an ID) that can be used to *clear* the timeout (cancel the execution of the callback before it happens) via the following global function:    ```js function clearTimeout(handle?: any): void  ```    `setTimeout()` is available on both browsers and Node.js. We can view `setTimeout()` as scheduling a task for later execution:    ```js console.log('First task starts'); setTimeout(  () => { // (A)  console.log('Second task starts');  },  0 // (B) ); console.log('First task ends');  ```    Within the first task, we are scheduling a new task (the callback starting in line A) to be run after a delay of zero milliseconds (line B).    Output:    ```js First task starts First task ends Second task starts  ```    There is another way of looking at what happened: **The first task took a break and later continued with the second task.**    *   The first task runs. While it does, events such as click events may fire and cause tasks to be added to the queue. Those tasks can only run after the current task is finished. *   The first task ends. Now other tasks can run. We used a delay of zero milliseconds, so all tasks that were added to the queue before the second task, will run next. *   The second task runs, continuing the work of the first task.    In other words: The task took a break and gave other tasks a chance to run.    #### [42.2.4 Run-to-completion semantics](#run-to-completion-semantics)    JavaScript makes a guarantee for tasks:    > Each task is always finished (“run to completion”) before the next task is executed.    As a consequence, tasks don’t have to worry about their data being changed while they are working on it (*concurrent modification*). That simplifies programming in JavaScript.    We can observe run to completion in the previous example:    ```js console.log('First task starts'); setTimeout(  () => {  console.log('Second task starts');  },  0 ); console.log('First task ends');  ```    The first task ends before the next task starts.    ### [42.3 Patterns for delivering results asynchronously](#patterns-for-async-results)    In order to avoid blocking the main process while waiting for a long-running operation to finish, results are often delivered asynchronously in JavaScript. These are three popular patterns for doing so:    *   Events *   Callbacks *   Promises    The first two patterns are explained in the next two subsections. Promises are explained in [the next chapter](ch_promises.html#ch_promises).    #### [42.3.1 Delivering asynchronous results via events](#event-pattern)    Events as a pattern work as follows:    *   They are used to deliver values asynchronously. *   They do so zero or more times. *   There are three roles in this pattern:     *   The *event* (an object) carries the data to be delivered.     *   The *event listener* is a function that receives events via a parameter.     *   The *event source* sends events and lets us register event listeners.    Multiple variations of this pattern exist in the world of JavaScript. We’ll look at three examples next.    ##### [42.3.1.1 Events: IndexedDB](#events-indexeddb)    IndexedDB is a database that is built into web browsers. This is an example of using it:    ```js const openRequest = indexedDB.open('MyDatabase', 1); // (A)  `openRequest.onsuccess = (event) => {`  `const db = event.target.result;`  `// ···` `};`  `` `openRequest.onerror = (error) => {`  `console.error(error);` `};` ``  ```   ```js```` ```js``` `indexedDB` has an unusual way of invoking operations:    *   Each operation has an associated method for creating *request objects*. For example, in line A, the operation is “open”, the method is `.open()`, and the request object is `openRequest`.           *   The parameters for the operation are provided via the request object, not via parameters of the method. For example, the event listeners (functions) are stored in the properties `.onsuccess` and `.onerror`.           *   The invocation of the operation is added to the task queue via the method (in line A). That is, we configure the operation *after* its invocation has already been added to the queue. Only run-to-completion semantics saves us from race conditions here and ensures that the operation runs after the current code fragment is finished.              ##### [42.3.1.2 Events: `XMLHttpRequest`](#XMLHttpRequest)    The `XMLHttpRequest` API lets us make downloads from within a web browser. This is how we download the file `http://example.com/textfile.txt`:    ``` const xhr = new XMLHttpRequest(); // (A) xhr.open('GET', 'http://example.com/textfile.txt'); // (B) xhr.onload = () => { // (C)  if (xhr.status == 200) {  processData(xhr.responseText);  } else {  assert.fail(new Error(xhr.statusText));  } }; xhr.onerror = () => { // (D)  assert.fail(new Error('Network error')); }; xhr.send(); // (E)  `function processData(str) {`  `assert.equal(str, 'Content of textfile.txt\\n');` `}`  ```js   `````", "```js const element = document.getElementById('my-link'); // (A) element.addEventListener('click', clickListener); // (B)  `function clickListener(event) {`  `event.preventDefault(); // (C)`  `console.log(event.shiftKey); // (D)` `}`  ```", "```js`We first ask the browser to retrieve the HTML element whose ID is `'my-link'` (line A). Then we add a listener for all `click` events (line B). In the listener, we first tell the browser not to perform its default action (line C) – going to the target of the link. Then we log to the console if the shift key is currently pressed (line D).    #### [42.3.2 Delivering asynchronous results via callbacks](#callback-pattern)    Callbacks are another pattern for handling asynchronous results. They are only used for one-off results and have the advantage of being less verbose than events.    As an example, consider a function `readFile()` that reads a text file and returns its contents asynchronously. This is how we call `readFile()` if it uses Node.js-style callbacks:    ```", "```js    There is a single callback that handles both success and failure. If the first parameter is not `null` then an error happened. Otherwise, the result can be found in the second parameter.    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercises: Callback-based code**    The following exercises use tests for asynchronous code, which are different from tests for synchronous code. See [“Asynchronous tests in Mocha” (§12.2.2)](ch_exercises.html#async-tests-mocha) for more information.    *   From synchronous to callback-based code: `exercises/async-js/read_file_cb_exrc.mjs` *   Implementing a callback-based version of `.map()`: `exercises/async-js/map_cb_test.mjs`    ### [42.4 Asynchronous code: the downsides](#async-code-downsides)    In many situations, on either browsers or Node.js, we have no choice: We must use asynchronous code. In this chapter, we have seen several patterns that such code can use. All of them have two disadvantages:    *   Asynchronous code is more verbose than synchronous code. *   If we call asynchronous code, our code must become asynchronous too. That’s because we can’t wait synchronously for an asynchronous result. Asynchronous code has an infectious quality.    The first disadvantage becomes less severe with Promises (covered in [the next chapter](ch_promises.html#ch_promises)) and mostly disappears with async functions (covered in [the chapter after next](ch_async-functions.html#ch_async-functions)).    Alas, the infectiousness of async code does not go away. But it is mitigated by the fact that switching between sync and async is easy with async functions.    ### [42.5 Resources](#resources)    *   [“Help, I'm stuck in an event-loop”](https://vimeo.com/96425312) by Philip Roberts (video). *   [“Event loops”](https://www.w3.org/TR/html5/webappapis.html#event-loops), section in HTML5 spec.```", "```js`` ```", "```js ```", "```js` ```", "```js`` ```"]