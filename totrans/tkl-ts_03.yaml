- en: 2 Why TypeScript?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/tackling-ts/ch_why-typescript.html](https://exploringjs.com/tackling-ts/ch_why-typescript.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 [The benefits of using TypeScript](ch_why-typescript.html#the-benefits-of-using-typescript)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.1.1 [More errors are detected *statically* (without running code)](ch_why-typescript.html#more-errors-are-detected-statically-without-running-code)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.1.2 [Documenting parameters is good practice anyway](ch_why-typescript.html#documenting-parameters-is-good-practice-anyway)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.1.3 [TypeScript provides an additional layer of documentation](ch_why-typescript.html#typescript-provides-an-additional-layer-of-documentation)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.1.4 [Type definitions for JavaScript improve auto-completion](ch_why-typescript.html#type-definitions-for-javascript-improve-auto-completion)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.1.5 [TypeScript makes refactorings safer](ch_why-typescript.html#typescript-makes-refactorings-safer)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.1.6 [TypeScript can compile new features to older code](ch_why-typescript.html#typescript-can-compile-new-features-to-older-code)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.2 [The downsides of using TypeScript](ch_why-typescript.html#the-downsides-of-using-typescript)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.3 [TypeScript myths](ch_why-typescript.html#typescript-myths)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.3.1 [TypeScript code is heavyweight](ch_why-typescript.html#typescript-code-is-heavyweight)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.3.2 [TypeScript is an attempt to replace JavaScript with C# or Java](ch_why-typescript.html#typescript-is-an-attempt-to-replace-javascript-with-c-or-java)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: You can skip this chapter if you are already sure that you will learn and use
    TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: If you are still unsure – this chapter is my sales pitch.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 The benefits of using TypeScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 2.1.1 More errors are detected *statically* (without running code)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While you are editing TypeScript code in an integrated development environment,
    you get warnings if you mistype names, call functions incorrectly, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following two lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For the second line, we get this warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the error message for the last line is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 2.1.2 Documenting parameters is good practice anyway
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Documenting parameters of functions and methods is something that many people
    do, anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Specifying the types via `{number}` and `{string}` is not required, but the
    descriptions in English mention them, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use TypeScript’s notation to document types, we get the added benefit
    of this information being checked for consistency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 2.1.3 TypeScript provides an additional layer of documentation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Whenever I migrate JavaScript code to TypeScript, I’m noticing an interesting
    phenomenon: In order to find the appropriate types for parameters for a function
    or method, I have to check where it is invoked. That means that static types give
    me information locally that I otherwise have to look up elsewhere.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And I do indeed find it easier to understand TypeScript code bases than JavaScript
    code bases: TypeScript provides an additional layer of documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: This additional documentation also helps when working in teams because it is
    clearer how code is to be used and TypeScript often warns us if we are doing something
    wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.4 Type definitions for JavaScript improve auto-completion
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If there are type definitions for JavaScript code, then editors can use them
    to improve auto-completion.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to using TypeScript’s syntax, is to provide all type information
    via JSDoc comments – like we did at the beginning of this chapter. In that case,
    TypeScript can also check code for consistency and generate type definitions.
    For more information, see [chapter “Type Checking JavaScript Files”](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html)
    in the TypeScript handbook.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.5 TypeScript makes refactorings safer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Refactorings are automated code transformations that many integrated development
    environments offer.
  prefs: []
  type: TYPE_NORMAL
- en: Renaming methods is an example of a refactoring. Doing so in plain JavaScript
    can be tricky because the same name might refer to different methods. TypeScript
    has more information on how methods and types are connected, which makes renaming
    methods safer there.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.6 TypeScript can compile new features to older code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TypeScript tends to quickly support ECMAScript stage 4 features (such features
    are scheduled to be included in the next ECMAScript version). When we compile
    to JavaScript, the compiler option `--target` lets us specify the ECMAScript version
    that the output is compatible with. Then any incompatible feature (that was introduced
    later) will be compiled to equivalent, compatible code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this kind of support for older ECMAScript versions does not require
    TypeScript or static typing: [The JavaScript compiler Babel](https://babeljs.io)
    does it too, but it compiles JavaScript to JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 The downsides of using TypeScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is an added layer on top of JavaScript: more complexity, more things to
    learn, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It introduces a compilation step when writing code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: npm packages can only be used if they have static type definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These days, many packages either come with type definitions or there are type
    definitions available for them on [DefinitelyTyped](http://definitelytyped.org).
    However, especially the latter can occasionally be slightly wrong, which leads
    to issues that you don’t have without static typing.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Getting static types right is occasionally difficult. My recommendation here
    is to keep things as simple as possible – for example: Don’t overdo generics and
    type variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.3 TypeScript myths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 2.3.1 TypeScript code is heavyweight
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'TypeScript code *can* be very heavyweight. But it doesn’t have to be. For example,
    due to type inference, we can often get away with few type annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The only locations where this TypeScript code is different from JavaScript code,
    are line A and line B.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a variety of styles in which TypeScript is written:'
  prefs: []
  type: TYPE_NORMAL
- en: In an object-oriented programming (OOP) style with classes and OOP patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a functional programming (FP) style with functional patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a mix of OOP and FP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.3.2 TypeScript is an attempt to replace JavaScript with C# or Java
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Initially, TypeScript did invent a few language constructs of its own (e.g. enums).
    But since ECMAScript 6, it mostly stuck with being a strict superset of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: My impression is that the TypeScript team likes JavaScript and doesn’t want
    to replace it with something “better” (which is the goal of, e.g., Dart). They
    do want to make it possible to statically type as much JavaScript code as possible.
    Many new TypeScript features are driven by that desire.
  prefs: []
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/tackling-ts/issues/2)'
  prefs: []
  type: TYPE_NORMAL
