<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>14 Values</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>14 Values</h1>
<blockquote>原文：<a href="https://exploringjs.com/js/book/ch_values.html">https://exploringjs.com/js/book/ch_values.html</a></blockquote>

        
    
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#whats-a-type">14.1 What’s a type?</a>
    </li>
    <li>
      <a href="#javascripts-type-hierarchy">14.2 JavaScript’s type hierarchy</a>
    </li>
    <li>
      <a href="#the-types-of-the-language-specification">14.3 The types of the language specification</a>
    </li>
    <li>
      <a href="#primitive-values-vs-objects">14.4 Primitive values vs. objects</a>
    </li>
    <li>
      <a href="#primitive-values-short-primitives">14.5 Primitive values (short: primitives)</a>
      <ol>
        <li>
          <a href="#primitives-are-immutable">14.5.1 Primitives are immutable</a>
        </li>
        <li>
          <a href="#primitives-are-passed-by-value">14.5.2 Primitives are <em>passed by value</em></a>
        </li>
        <li>
          <a href="#primitives-are-compared-by-value">14.5.3 Primitives are <em>compared by value</em></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#objects">14.6 Objects</a>
      <ol>
        <li>
          <a href="#objects-are-mutable-by-default">14.6.1 Objects are mutable by default</a>
        </li>
        <li>
          <a href="#objects-are-passed-by-identity">14.6.2 Objects are <em>passed by identity</em></a>
        </li>
        <li>
          <a href="#objects-are-compared-by-identity">14.6.3 Objects are <em>compared by identity</em></a>
        </li>
        <li>
          <a href="#passing-by-reference-vs-passing-by-identity-advanced">14.6.4 Passing by reference vs. passing by identity<span> (advanced)</span></a>
        </li>
        <li>
          <a href="#identity-in-the-ecmascript-specification-advanced">14.6.5 Identity in the ECMAScript specification<span> (advanced)</span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#the-operators-typeof-and-instanceof-whats-the-type-of-a-value">14.7 The operators <code>typeof</code> and <code>instanceof</code>: what’s the type of a value?</a>
      <ol>
        <li>
          <a href="#typeof-operator">14.7.1 <code>typeof</code></a>
        </li>
        <li>
          <a href="#instanceof-operator">14.7.2 <code>instanceof</code></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#classes-and-constructor-functions">14.8 Classes and constructor functions</a>
      <ol>
        <li>
          <a href="#constructor-functions-for-primitives">14.8.1 Constructor functions associated with primitive types</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#converting-between-types">14.9 Converting between types</a>
      <ol>
        <li>
          <a href="#explicit-conversion-between-types">14.9.1 Explicit conversion between types</a>
        </li>
        <li>
          <a href="#coercion">14.9.2 Coercion (automatic conversion between types)</a>
        </li>
      </ol>
    </li>
  </ol>
</nav>
<p>In this chapter, we’ll examine what kinds of values JavaScript has.</p>
<div class="boxout">
  <p><img src="../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png" class="boxout-icon" height="24" alt="Icon “reading”" data-original-src="https://exploringjs.com/js/book/icon/reading.svg"/> <strong>Supporting tool: <code>===</code></strong></p>
  <div class="boxout-vspace"/>
  <p>In this chapter, we’ll occasionally use the strict equality operator. <code>a === b</code> evaluates to <code>true</code> if <code>a</code> and <code>b</code> are equal. What exactly that means is explained in <a href="ch_operators.html#strict-equality">“Strict equality (<code>===</code> and <code>!==</code>)” (§15.5.1)</a>.</p>
</div>
<h3 id="whats-a-type"><a class="heading-id-link" href="#whats-a-type">14.1 What’s a type?</a></h3>
<p><span id="index-entry-type"/></p>
<p>For this chapter, I consider types to be sets of values – for example, the type <code>boolean</code> is the set { <code>false</code>, <code>true</code> }.</p>
<h3 id="javascripts-type-hierarchy"><a class="heading-id-link" href="#javascripts-type-hierarchy">14.2 JavaScript’s type hierarchy</a></h3>
<p><span id="index-entry-type-hierarchy"/></p>
<figure id="fig:type-hierarchy" class="float">
  <p><img src="../Images/86e9cf484c901c5e9bd1b2ee4a0d1ba7.png" alt="" style="width:514.33333px; height:327.76px" data-original-src="https://exploringjs.com/js/book/img/values/type-hierarchy.svg"/></p>
  <figcaption>
    <p><span class="float-label">Figure 14.1:</span> A partial hierarchy of JavaScript’s types. Missing are the classes for errors, the classes associated with primitive types, and more.</p>
  </figcaption>
</figure>
<p><a href="#fig:type-hierarchy">Figure 14.1</a> shows JavaScript’s type hierarchy:</p>
<ul>
  <li>
    <p>JavaScript distinguishes two kinds of values: primitive values and objects. We’ll soon see what the difference is.</p>
  </li>
  <li>
    <p>The diagram hints at an important fact: Some objects are not instances of the class <code>Object</code> (<a href="ch_classes.html#non-instances-of-object">more information</a>). However, such objects are rare. Virtually all objects we’ll encounter are indeed instances of <code>Object</code>. </p>
  </li>
</ul>
<h3 id="the-types-of-the-language-specification"><a class="heading-id-link" href="#the-types-of-the-language-specification">14.3 The types of the language specification</a></h3>
<p>The ECMAScript specification only knows a total of eight types. The names of those types are (I’m using TypeScript’s names, not the spec’s names):</p>
<ul>
  <li>
    <code>undefined</code> with the only element <code>undefined</code>
  </li>
  <li>
    <code>null</code> with the only element <code>null</code>
  </li>
  <li>
    <code>boolean</code> with the elements <code>false</code> and <code>true</code>
  </li>
  <li>
    <code>number</code>, the type of all numbers (e.g., <code>-123</code>, <code>3.141</code>)
  </li>
  <li>
    <code>bigint</code>, the type of all big integers (e.g., <code>-123n</code>)
  </li>
  <li>
    <code>string</code>, the type of all strings (e.g., <code>'abc'</code>)
  </li>
  <li>
    <code>symbol</code>, the type of all symbols (e.g., <code>Symbol('My Symbol')</code>)
  </li>
  <li>
    <code>object</code>, the type of all objects (different from <code>Object</code>, the type of all instances of class <code>Object</code> and its subclasses)
  </li>
</ul>
<h3 id="primitive-values-vs-objects"><a class="heading-id-link" href="#primitive-values-vs-objects">14.4 Primitive values vs. objects</a></h3>
<p><span id="index-entry-primitive-value-vs.-object"/><span id="index-entry-object-vs.-primitive-value"/></p>
<p>The specification makes an important distinction between values:</p>
<ul>
  <li>
    <em>Primitive values</em> are the elements of the types <code>undefined</code>, <code>null</code>, <code>boolean</code>, <code>number</code>, <code>bigint</code>, <code>string</code>, <code>symbol</code>.
  </li>
  <li>
    All other values are <em>objects</em>.
  </li>
</ul>
<p>In contrast to Java (that inspired JavaScript here), primitive values are not second-class citizens. The difference between them and objects is more subtle. In a nutshell:</p>
<ul>
  <li>
    Primitive values: are atomic building blocks of data in JavaScript.
    <ul>
      <li>
        They are <em>passed by value</em>: when primitive values are assigned to variables or passed to functions, their contents are copied.
      </li>
      <li>
        They are <em>compared by value</em>: when comparing two primitive values, their contents are compared.
      </li>
    </ul>
  </li>
  <li>
    Objects: are compound pieces of data.
    <ul>
      <li>
        They are <em>passed by identity</em> (new term): when objects are assigned to variables or passed to functions, their <em>identities</em> (think pointers) are copied.
      </li>
      <li>
        They are <em>compared by identity</em> (new term): when comparing two objects, their identities are compared.
      </li>
    </ul>
  </li>
</ul>
<p>Other than that, primitive values and objects are quite similar: they both have <em>properties</em> (key-value entries) and can be used in the same locations.</p>
<p>Next, we’ll look at primitive values and objects in more depth.</p>
<h3 id="primitive-values-short-primitives"><a class="heading-id-link" href="#primitive-values-short-primitives">14.5 Primitive values (short: primitives)</a></h3>
<p><span id="index-entry-primitive-value"/></p>
<h4 id="primitives-are-immutable"><a class="heading-id-link" href="#primitives-are-immutable">14.5.1 Primitives are immutable</a></h4>
<p>We can’t change, add, or remove properties of primitives:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> str = <span class="hljs-string">'abc'</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(str.<span class="hljs-property">length</span>, <span class="hljs-number">3</span>);</code>
<code>assert.<span class="hljs-title function_">throws</span>(</code>
<code>  <span class="hljs-function">() =&gt;</span> { str.<span class="hljs-property">length</span> = <span class="hljs-number">1</span> },</code>
<code>  <span class="hljs-regexp">/^TypeError: Cannot assign to read only property 'length'/</span></code>
<code>);</code>
</pre>
<h4 id="primitives-are-passed-by-value"><a class="heading-id-link" href="#primitives-are-passed-by-value">14.5.2 Primitives are <em>passed by value</em></a></h4>
<p><span id="index-entry-passing-by-value"/></p>
<p>Primitives are <em>passed by value</em>: variables (including parameters) store the contents of the primitives. When assigning a primitive value to a variable or passing it as an argument to a function, its content is copied.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> x = <span class="hljs-number">123</span>;</code>
<code><span class="hljs-keyword">const</span> y = x;</code>
<code><span class="hljs-comment">// `y` is the same as any other number 123</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(y, <span class="hljs-number">123</span>);</code>
</pre>
<div class="boxout">
  <p><img src="../Images/38ba63de820aae6f94a019538ae0f222.png" class="boxout-icon" height="24" alt="Icon “details”" data-original-src="https://exploringjs.com/js/book/icon/details.svg"/> <strong>Observing the difference between passing by value and passing by identity</strong></p>
  <div class="boxout-vspace"/>
  <p>Due to primitive values being immutable and compared by value (see next subsection), there is no way to observe the difference between passing by value and passing by identity (as used for objects in JavaScript).</p>
</div>
<h4 id="primitives-are-compared-by-value"><a class="heading-id-link" href="#primitives-are-compared-by-value">14.5.3 Primitives are <em>compared by value</em></a></h4>
<p><span id="index-entry-comparing-by-value"/></p>
<p>Primitives are <em>compared by value</em>: when comparing two primitive values, we compare their contents.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">123</span> === <span class="hljs-number">123</span>, <span class="hljs-literal">true</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-string">'abc'</span> === <span class="hljs-string">'abc'</span>, <span class="hljs-literal">true</span>);</code>
</pre>
<p>To see what’s so special about this way of comparing, read on and find out how objects are compared.</p>
<h3 id="objects"><a class="heading-id-link" href="#objects">14.6 Objects</a></h3>
<p>Objects are covered in detail in <a href="ch_objects.html#ch_objects">“Objects” (§30)</a> and the following chapter. Here, we mainly focus on how they differ from primitive values.</p>
<p>Let’s first explore two common ways of creating objects:</p>
<ul>
  <li>
    <p>Object literal:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {</code>
<code>  <span class="hljs-attr">first</span>: <span class="hljs-string">'Jane'</span>,</code>
<code>  <span class="hljs-attr">last</span>: <span class="hljs-string">'Doe'</span>,</code>
<code>};</code>
</pre>
    <p>The object literal starts and ends with curly braces <code>{}</code>. It creates an object with two properties. The first property has the key <code>'first'</code> (a string) and the value <code>'Jane'</code>. The second property has the key <code>'last'</code> and the value <code>'Doe'</code>. For more information on object literals, see <a href="ch_objects.html#object-literals">“Object literals: properties” (§30.3.1)</a>.</p>
  </li>
  <li>
    <p>Array literal:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> fruits = [<span class="hljs-string">'strawberry'</span>, <span class="hljs-string">'apple'</span>];</code>
</pre>
    <p>The Array literal starts and ends with square brackets <code>[]</code>. It creates an Array with two <em>elements</em>: <code>'strawberry'</code> and <code>'apple'</code>. For more information on Array literals, see <a href="ch_arrays.html#array-literals">“Creating, reading, writing Arrays” (§34.3.1)</a>.</p>
  </li>
</ul>
<h4 id="objects-are-mutable-by-default"><a class="heading-id-link" href="#objects-are-mutable-by-default">14.6.1 Objects are mutable by default</a></h4>
<p>By default, we can freely change, add, and remove the properties of objects:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {};</code>
<code/>
<code>obj.<span class="hljs-property">count</span> = <span class="hljs-number">2</span>; <span class="hljs-comment">// add a property</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(obj.<span class="hljs-property">count</span>, <span class="hljs-number">2</span>);</code>
<code/>
<code>obj.<span class="hljs-property">count</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// change a property</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(obj.<span class="hljs-property">count</span>, <span class="hljs-number">3</span>);</code>
</pre>
<h4 id="objects-are-passed-by-identity"><a class="heading-id-link" href="#objects-are-passed-by-identity">14.6.2 Objects are <em>passed by identity</em></a></h4>
<p><span id="index-entry-passing-by-identity"/>
<span id="index-entry-identity-of-an-object"/><span id="index-entry-object--identity-of-an"/></p>
<p>Objects are <em>passed by identity</em> (new term): Variables (including parameters) store the <em>identities</em> of objects. The identity of an object is a <em>transparent reference</em> (think pointer) to the object’s actual data on the <em>heap</em> (the shared main memory of a JavaScript process). When assigning an object to a variable or passing it as an argument to a function, its identity is copied.</p>
<p>Each object literal creates a fresh object on the heap and returns its identity:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> a = {}; <span class="hljs-comment">// fresh empty object</span></code>
<code><span class="hljs-comment">// Pass the identity in `a` to `b`:</span></code>
<code><span class="hljs-keyword">const</span> b = a;</code>
<code/>
<code><span class="hljs-comment">// Now `a` and `b` point to the same object</span></code>
<code><span class="hljs-comment">// (they “share” that object):</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(a === b, <span class="hljs-literal">true</span>);</code>
<code/>
<code><span class="hljs-comment">// Changing `a` also changes `b`:</span></code>
<code>a.<span class="hljs-property">name</span> = <span class="hljs-string">'Tessa'</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(b.<span class="hljs-property">name</span>, <span class="hljs-string">'Tessa'</span>);</code>
</pre>
<p><span id="index-entry-garbage-collection"/></p>
<p>JavaScript uses <em>garbage collection</em> to automatically manage memory:</p>
<pre class="language-js">
<code><span class="hljs-keyword">let</span> obj = { <span class="hljs-attr">prop</span>: <span class="hljs-string">'value'</span> };</code>
<code>obj = {};</code>
</pre>
<p>Now the old value <code>{ prop: 'value' }</code> of <code>obj</code> is <em>garbage</em> (not used anymore). JavaScript will automatically <em>garbage-collect</em> it (remove it from memory), at some point in time (possibly never if there is enough free memory).</p>
<h4 id="objects-are-compared-by-identity"><a class="heading-id-link" href="#objects-are-compared-by-identity">14.6.3 Objects are <em>compared by identity</em></a></h4>
<p><span id="index-entry-comparing-by-identity"/></p>
<p>Objects are <em>compared by identity</em> (new term): two variables are only equal if they contain the same object identity. They are not equal if they refer to different objects with the same content.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {}; <span class="hljs-comment">// fresh empty object</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(obj === obj, <span class="hljs-literal">true</span>); <span class="hljs-comment">// same identity</span></code>
<code>assert.<span class="hljs-title function_">equal</span>({} === {}, <span class="hljs-literal">false</span>); <span class="hljs-comment">// different identities, same content</span></code>
</pre>
<h4 id="passing-by-reference-vs-passing-by-identity-advanced"><a class="heading-id-link" href="#passing-by-reference-vs-passing-by-identity-advanced">14.6.4 Passing by reference vs. passing by identity<span> (advanced)</span></a></h4>
<p>If a parameter is <em>passed by reference</em>, it points to a variable and assigning to the parameter changes the variable – e.g., in the following C++ code, the parameters <code>x</code> and <code>y</code> are passed by reference. The invocation in line A affects the variables <code>a</code> and <code>b</code> of the invoker.</p>
<pre class="language-cpp">
<code><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap_ints</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span> </span>{</code>
<code>  <span class="hljs-type">int</span> temp = x;</code>
<code>  x = y;</code>
<code>  y = temp;</code>
<code>}</code>
<code><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{</code>
<code>  <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;</code>
<code>  <span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;</code>
<code/>
<code>  <span class="hljs-built_in">swap_ints</span>(a, b); <span class="hljs-comment">// (A)</span></code>
<code>  <span class="hljs-comment">// Now `a` is 2 and `b` is 1</span></code>
<code/>
<code>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code>
<code>}</code>
</pre>
<p>If a parameter is <em>passed by identity</em> (which is a new, new term), the identity of an object (a transparent reference) is passed by value. Assigning to the parameter only has a local effect. This approach is also called <a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing"><em>passing by sharing</em></a>.</p>
<p><strong>Acknowledgement:</strong> The term <em>passing by identity</em> was <a href="https://x.com/awbjs/status/1086919101635801088">suggested</a> by Allen Wirfs-Brock in 2019.</p>
<h4 id="identity-in-the-ecmascript-specification-advanced"><a class="heading-id-link" href="#identity-in-the-ecmascript-specification-advanced">14.6.5 Identity in the ECMAScript specification<span> (advanced)</span></a></h4>
<p>The ECMAScript specification uses the term <em>identity</em> as follows (<a href="https://tc39.es/ecma262/#sec-identity">source</a>):</p>
<ul>
  <li>
    <p><em>Values without identity</em> are equal to other values without identity if all of their innate characteristics are the same – characteristics such as the magnitude of an integer or the length of a sequence.</p>
    <ul>
      <li>
        Values without identity may be manifest without prior reference by fully describing their characteristics.
      </li>
    </ul>
  </li>
  <li>
    <p>In contrast, each <em>value with identity</em> is unique and therefore only equal to itself. Values with identity are like values without identity but with an additional unguessable, unchangeable, universally-unique characteristic called identity.</p>
    <ul>
      <li>
        References to existing values with identity cannot be manifest simply by describing them, as the identity itself is indescribable; instead, references to these values must be explicitly passed from one place to another.
      </li>
      <li>
        Some values with identity are mutable and therefore can have their characteristics (except their identity) changed in-place, causing all holders of the value to observe the new characteristics.
      </li>
    </ul>
  </li>
</ul>
<p>At the language level:</p>
<ul>
  <li>
    Values that have identity: objects and symbols created via <code>Symbol()</code>
  </li>
  <li>
    Values that don’t have identity: primitive values and symbols created via <code>Symbol.for()</code>
  </li>
</ul>
<h3 id="the-operators-typeof-and-instanceof-whats-the-type-of-a-value"><a class="heading-id-link" href="#the-operators-typeof-and-instanceof-whats-the-type-of-a-value">14.7 The operators <code>typeof</code> and <code>instanceof</code>: what’s the type of a value?</a></h3>
<p><span id="index-entry-typeof"/><span id="index-entry-instanceof"/></p>
<p>The two operators <code>typeof</code> and <code>instanceof</code> let us determine what type a given value <code>x</code> has:</p>
<pre class="language-js">
<code><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">'string'</span>) ···</code>
<code><span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) ···</code>
</pre>
<p>How do they differ?</p>
<ul>
  <li>
    <code>typeof</code> distinguishes the 7 types of the specification (minus one omission, plus one addition).
  </li>
  <li>
    <code>instanceof</code> tests which class created a given value.
  </li>
</ul>
<div class="boxout">
  <p><img src="../Images/8440b17bb8219cda9f9405ac83c36db0.png" class="boxout-icon" height="24" alt="Icon “tip”" data-original-src="https://exploringjs.com/js/book/icon/tip.svg"/> <strong>Rule of thumb: <code>typeof</code> is for primitive values; <code>instanceof</code> is for objects</strong></p>
  <div class="boxout-vspace"/>
</div>
<h4 id="typeof-operator"><a class="heading-id-link" href="#typeof-operator">14.7.1 <code>typeof</code></a></h4>
<figure id="tbl:typeof-results" class="float">
  <table class="framed">
    <style>
      th:nth-child(1), td:nth-child(1) {
        text-align: left;
      }
      th:nth-child(2), td:nth-child(2) {
        text-align: left;
      }
    </style>
    <thead>
      <tr>
        <th><code>x</code></th><th><code>typeof x</code></th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>undefined</code></td><td><code>'undefined'</code></td>
      </tr>
      <tr>
        <td><code>null</code></td><td><code>'object'</code></td>
      </tr>
      <tr>
        <td>Boolean</td><td><code>'boolean'</code></td>
      </tr>
      <tr>
        <td>Number</td><td><code>'number'</code></td>
      </tr>
      <tr>
        <td>Bigint</td><td><code>'bigint'</code></td>
      </tr>
      <tr>
        <td>String</td><td><code>'string'</code></td>
      </tr>
      <tr>
        <td>Symbol</td><td><code>'symbol'</code></td>
      </tr>
      <tr>
        <td>Function</td><td><code>'function'</code></td>
      </tr>
      <tr>
        <td>All other objects</td><td><code>'object'</code></td>
      </tr>
    </tbody>
  </table>
  <figcaption>
    <p><span class="float-label">Table 14.1:</span> The results of the <code>typeof</code> operator.</p>
  </figcaption>
</figure>
<p><a href="#tbl:typeof-results">Table 14.1</a> lists all results of <code>typeof</code>. They roughly correspond to the 7 types of the language specification. Alas, there are two differences, and they are language quirks:</p>
<ul>
  <li>
    <code>typeof null</code> returns <code>'object'</code> and not <code>'null'</code>. That’s a bug. Unfortunately, it can’t be fixed. TC39 tried to do that, but it broke too much code on the web.
  </li>
  <li>
    <code>typeof</code> of a function should be <code>'object'</code> (functions are objects). Introducing a separate category for functions is confusing.
  </li>
</ul>
<p>These are a few examples of using <code>typeof</code>:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span></span></code>
<code>'undefined'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-number">123n</span></span></code>
<code>'bigint'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-string">'abc'</span></span></code>
<code>'string'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">typeof</span> {}</span></code>
<code>'object'</code>
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercises: Two exercises on <code>typeof</code></strong></p>
  <div class="boxout-vspace"/>
  <ul>
    <li>
      <code>exercises/values/typeof_exrc.mjs</code>
    </li>
    <li>
      Bonus: <code>exercises/values/is_object_test.mjs</code>
    </li>
  </ul>
</div>
<h4 id="instanceof-operator"><a class="heading-id-link" href="#instanceof-operator">14.7.2 <code>instanceof</code></a></h4>
<p>This operator answers the question: has a value <code>x</code> been created by a class <code>C</code>?</p>
<pre class="language-js">
<code>x <span class="hljs-keyword">instanceof</span> C</code>
</pre>
<p>For example:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {}) <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span></span></code>
<code>true</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">({}) <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span></span></code>
<code>true</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span></span></code>
<code>true</code>
</pre>
<p>Primitive values are not instances of anything:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">123</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span></span></code>
<code>false</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">''</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span></span></code>
<code>false</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">''</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span></span></code>
<code>false</code>
</pre>
<p>For more information on this operator, see <a href="ch_classes.html#instanceof-operator-details">“The <code>instanceof</code> operator in detail<span> (advanced)</span>” (§31.7.3)</a>.</p>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: <code>instanceof</code></strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/values/instanceof_exrc.mjs</code></p>
</div>
<h3 id="classes-and-constructor-functions"><a class="heading-id-link" href="#classes-and-constructor-functions">14.8 Classes and constructor functions</a></h3>
<p>JavaScript’s original factories for objects are <em>constructor functions</em>: ordinary functions that return “instances” of themselves if we invoke them via the <code>new</code> operator.</p>
<p>ES6 introduced <em>classes</em>, which are mainly better syntax for constructor functions.</p>
<p>In this book, I’m using the terms <em>constructor function</em> and <em>class</em> interchangeably.</p>
<p>Classes can be seen as partitioning the single type <code>object</code> of the specification into subtypes – they give us more types than the limited 7 ones of the specification. Each class is the type of the objects that were created by it.</p>
<h4 id="constructor-functions-for-primitives"><a class="heading-id-link" href="#constructor-functions-for-primitives">14.8.1 Constructor functions associated with primitive types</a></h4>
<p>Each primitive type (except for the types <code>undefined</code> and <code>null</code>) has an associated <em>constructor function</em> (think class):</p>
<ul>
  <li>
    The constructor function <code>Boolean</code> is associated with booleans.
  </li>
  <li>
    The constructor function <code>Number</code> is associated with numbers.
  </li>
  <li>
    The constructor function <code>String</code> is associated with strings.
  </li>
  <li>
    The constructor function <code>Symbol</code> is associated with symbols.
  </li>
</ul>
<p>Each of these functions plays several roles – for example, <code>Number</code>:</p>
<ul>
  <li>
    <p>We can use it as a function and convert values to numbers:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-string">'123'</span>), <span class="hljs-number">123</span>);</code>
</pre>
  </li>
  <li>
    <p><code>Number.prototype</code> provides the properties for numbers – for example, method <code>.toString()</code>:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>((<span class="hljs-number">123</span>).<span class="hljs-property">toString</span>, <span class="hljs-title class_">Number</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>);</code>
</pre>
  </li>
  <li>
    <p><code>Number</code> is a namespace/container object for tool functions for numbers – for example:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(<span class="hljs-number">123</span>), <span class="hljs-literal">true</span>);</code>
</pre>
  </li>
  <li>
    <p>Lastly, we can also use <code>Number</code> as a class and create number objects. These objects are different from real numbers and should be avoided. They virtually never show up in normal code. See the next subsection for more information.</p>
  </li>
</ul>
<h5 id="wrapper-classes-for-primitive-values-advanced"><a class="heading-id-link" href="#wrapper-classes-for-primitive-values-advanced">14.8.1.1 Wrapper classes for primitive values<span> (advanced)</span></a></h5>
<p><span id="index-entry-wrapper-object--for-a-primitive-value-"/>
<span id="index-entry-wrapper-class--for-a-primitive-value-"/></p>
<p>If we new-invoke a constructor function associated with a primitive type, it returns a so-called <em>wrapper object</em>. This is the standard way of converting a primitive value to an object – by “wrapping” it.</p>
<p>The primitive value is not an instance of the wrapper class:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> prim = <span class="hljs-literal">true</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-keyword">typeof</span> prim, <span class="hljs-string">'boolean'</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(prim <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Boolean</span>, <span class="hljs-literal">false</span>);</code>
</pre>
<p>The wrapper object is not a primitive value:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> wrapper = <span class="hljs-title class_">Object</span>(prim);</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-keyword">typeof</span> wrapper, <span class="hljs-string">'object'</span>); <span class="hljs-comment">// not 'boolean'</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(wrapper <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Boolean</span>, <span class="hljs-literal">true</span>);</code>
</pre>
<p>We can unwrap the wrapper object to get back the primitive value:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(wrapper.<span class="hljs-title function_">valueOf</span>(), prim); <span class="hljs-comment">// unwrap</span></code>
</pre>
<h3 id="converting-between-types"><a class="heading-id-link" href="#converting-between-types">14.9 Converting between types</a></h3>
<p>There are two ways in which values are converted to other types in JavaScript:</p>
<ul>
  <li>
    Explicit conversion: via functions such as <code>String()</code>.
  </li>
  <li>
    <em>Coercion</em> (automatic conversion): happens when an operation receives operands/parameters that it can’t work with. <span id="index-entry-coercion"/>
  </li>
</ul>
<h4 id="explicit-conversion-between-types"><a class="heading-id-link" href="#explicit-conversion-between-types">14.9.1 Explicit conversion between types</a></h4>
<p>The function associated with a primitive type explicitly converts values to that type:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Boolean</span>(<span class="hljs-number">0</span>)</span></code>
<code>false</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>(<span class="hljs-string">'123'</span>)</span></code>
<code>123</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">String</span>(<span class="hljs-number">123</span>)</span></code>
<code>'123'</code>
</pre>
<p><span id="index-entry-Object--"/></p>
<p>We can also use <code>Object()</code> to convert values to objects:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Object</span>(<span class="hljs-number">123</span>)</span></code>
<code>'object'</code>
</pre>
<p>The following table describes in more detail how this conversion works:</p>
<table class="framed">
  <style>
    th:nth-child(1), td:nth-child(1) {
      text-align: left;
    }
    th:nth-child(2), td:nth-child(2) {
      text-align: left;
    }
  </style>
  <thead>
    <tr>
      <th><code>x</code></th><th><code>Object(x)</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>undefined</code></td><td><code>{}</code></td>
    </tr>
    <tr>
      <td><code>null</code></td><td><code>{}</code></td>
    </tr>
    <tr>
      <td>boolean</td><td><code>new Boolean(x)</code></td>
    </tr>
    <tr>
      <td>number</td><td><code>new Number(x)</code></td>
    </tr>
    <tr>
      <td>bigint</td><td>An instance of <code>BigInt</code> (<code>new</code> throws <code>TypeError</code>)</td>
    </tr>
    <tr>
      <td>string</td><td><code>new String(x)</code></td>
    </tr>
    <tr>
      <td>symbol</td><td>An instance of <code>Symbol</code> (<code>new</code> throws <code>TypeError</code>)</td>
    </tr>
    <tr>
      <td>object</td><td><code>x</code></td>
    </tr>
  </tbody>
</table>
<h4 id="coercion"><a class="heading-id-link" href="#coercion">14.9.2 Coercion (automatic conversion between types)</a></h4>
<p>For many operations, JavaScript automatically converts the operands/parameters if their types don’t fit. This kind of automatic conversion is called <em>coercion</em>.</p>
<p>For example, the multiplication operator coerces its operands to numbers:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'7'</span> * <span class="hljs-string">'3'</span></span></code>
<code>21</code>
</pre>
<p>Many built-in functions coerce, too. For example, <code>Number.parseInt()</code> coerces its parameter to a string before parsing it. That explains the following result:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">123.45</span>)</span></code>
<code>123</code>
</pre>
<p>The number <code>123.45</code> is converted to the string <code>'123.45'</code> before it is parsed. Parsing stops before the first non-digit character, which is why the result is <code>123</code>.</p>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Converting values to primitives</strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/values/conversion_exrc.mjs</code></p>
</div>

    
      
</body>
</html>