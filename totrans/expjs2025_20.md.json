["```js\nlet myVar;\nassert.equal(myVar, undefined);\n\n```", "```js\nfunction func(x) {\n return x;\n}\nassert.equal(func(), undefined);\n\n```", "```js\nconst obj = {};\nassert.equal(obj.unknownProp, undefined);\n\n```", "```js\nfunction func() {}\nassert.equal(func(), undefined);\n\n```", "```js\n> Object.getPrototypeOf(Object.prototype)\nnull\n\n```", "```js\n> /a/.exec('x')\nnull\n\n```", "```js\n> JSON.stringify({a: undefined, b: null})\n'{\"b\":null}'\n\n```", "```js\nif (x === null) ···\nif (x === undefined) ···\n\n```", "```js\nif (x !== undefined && x !== null) {\n // ···\n}\nif (x) { // truthy?\n // x is neither: undefined, null, false, 0, NaN, 0n, ''\n}\n\n```", "```js\nif (x === undefined || x === null) {\n // ···\n}\nif (!x) { // falsy?\n // x is: undefined, null, false, 0, NaN, 0n, ''\n}\n\n```", "```js\nvalue ?? defaultValue\n\n```", "```js\n> undefined ?? 'default'\n'default'\n> null ?? 'default'\n'default'\n> false ?? 'default'\nfalse\n> 0 ?? 'default'\n0\n> '' ?? 'default'\n''\n> {} ?? 'default'\n{}\n\n```", "```js\nlet evaluated = false;\n `// Right-hand side is not used`\n`123 ?? (evaluated = true);`\n`assert.equal(evaluated, false);`\n `` `// Right-hand side is used` `undefined ?? (evaluated = true);` `assert.equal(evaluated, true);` `` \n```", "```js```", "````js````", "```js```", "````js``` #### [16.4.1 Example: counting matches](#example-counting-matches)    The following code shows a real-world example:    ``` function countMatches(regex, str) {  const matchResult = str.match(regex); // null or Array  return (matchResult ?? []).length; }  `assert.equal(`  `countMatches(/a/g, 'ababa'), 3` `);` `assert.equal(`  `countMatches(/b/g, 'ababa'), 2` `);` `assert.equal(`  `countMatches(/x/g, 'ababa'), 0` `);`  ```js   ````", "`````` If there are one or more matches for `regex` inside `str`, then `.match()` returns an Array. If there are no matches, it unfortunately returns `null` (and not the empty Array). We fix that via the `??` operator.    We also could have used [optional chaining](ch_objects.html#optional-chaining):    ```js return matchResult?.length ?? 0;  ```    #### [16.4.2 Example: specifying a default value for a property](#example-specifying-a-default-value-for-a-property)    ```js function getTitle(fileDesc) {  return fileDesc.title ?? '(Untitled)'; }  `const files = [`  `{ path: 'index.html', title: 'Home' },`  `{ path: 'tmp.html' },` `];` `assert.deepEqual(`  `files.map(f => getTitle(f)),`  `['Home', '(Untitled)']` `);`  ```   ```js``````", "``` > undefined || 'default' 'default' > null || 'default' 'default'  ```", "``` > false || 'default' 'default' > 0 || 'default' 'default' > 0n || 'default' 'default' > '' || 'default' 'default'  ```", "``` > undefined ?? 'default' 'default' > null ?? 'default' 'default'  `> false ?? 'default'` `false` `> 0 ?? 'default'` `0` `> 0n ?? 'default'` `0n` `> '' ?? 'default'` `''`  ```", "``````js```` #### [16.4.4 The nullish coalescing assignment operator (`??=`) ^(ES2021)](#nullish-coalescing-assignment-operator)    The nullish coalescing assignment operator (`??=`) assigns a default if a value is `undefined` or `null`:    ```js value ??= defaultValue  ```    *   If `value` is either `undefined` or `null`, `defaultValue` is evaluated and assigned to `value`. *   Otherwise, nothing happens.    Examples:    ```js let value;  `value = undefined;` `value ??= 'DEFAULT';` `assert.equal(`  `value, 'DEFAULT'` `);`  `` `value = 0;` `value ??= 'DEFAULT';` `assert.equal(`  `value, 0` `);` ``  ```   ```js``````", "```js```", "```js a ??= b a ?? (a = b)  ```", "```js let value;  `value = undefined;` `value ??= console.log('evaluated');`  `` `value = 0;` `value ??= console.log('NOT EVALUATED');` ``  ```", "```js```", "```js```", "``` evaluated  ```", "``` const books = [  {  isbn: '123',  },  {  title: 'ECMAScript Language Specification',  isbn: '456',  }, ];  `// Add property .title where it’s missing` `for (const book of books) {`  `book.title ??= '(Untitled)';` `}`  `` `assert.deepEqual(`  `books,`  `[`  `{`  `isbn: '123',`  `title: '(Untitled)',`  `},`  `{`  `title: 'ECMAScript Language Specification',`  `isbn: '456',`  `},`  `]);` ``  ```", "````` ```js` ### [16.5 `undefined` and `null` don’t have properties](#undefined-null-no-properties)    `undefined` and `null` are the only two JavaScript values where we get an exception if we try to read a property. To explore this phenomenon, let’s use the following function, which reads (“gets”) property `.prop` and returns the result.    ``` function getProp(x) {  return x.prop; }  ```js    If we apply `getProp()` to various values, we can see that it only fails for `undefined` and `null`:    ``` > getProp(undefined) TypeError: Cannot read properties of undefined (reading 'prop') > getProp(null) TypeError: Cannot read properties of null (reading 'prop')  `> getProp(true)` `undefined` `> getProp({})` `undefined`  ```js   ``### [16.6 The history of `undefined` and `null`](#history-of-undefined-null)    In Java (which inspired many aspects of JavaScript), initialization values depend on the static type of a variable:    *   Variables with object types are initialized with `null`. *   Each primitive type has its own initialization value. For example, `int` variables are initialized with `0`.    JavaScript borrowed `null` and uses it where objects are expected. It means “not an object”.    However, storage locations in JavaScript (variables, properties, etc.) can hold either primitive values or objects. They need an initialization value that means “neither an object nor a primitive value”. That’s why `undefined` was introduced.`` ```` ```js`` `````", "``````js` ``````", "``````js``` ``````", "```` ```js````", "```js` ```", "```js```", "``` ```", "```````js``` ``````js```````"]