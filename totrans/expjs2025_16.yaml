- en: 13 Variables and assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_variables-assignment.html](https://exploringjs.com/js/book/ch_variables-assignment.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[13.1 `let`](#let)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.2 `const`](#const)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.2.1 `const` and immutability](#const-creates-immutable-bindings)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.2.2 `const` and loops](#const-and-loops)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.3 Deciding between `const` and `let`](#deciding-between-const-and-let)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.4 The scope of a variable](#variable-scope)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.4.1 Shadowing variables](#shadowing-variables)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.5 (Advanced)](#advanced-1)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.6 Terminology: static vs. dynamic](#programming-languages-static-vs-dynamic)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.6.1 Static phenomenon: scopes of variables](#static-phenomenon-scopes-of-variables)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.6.2 Dynamic phenomenon: function calls](#dynamic-phenomenon-function-calls)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.7 The scopes of JavaScript’s global variables](#global-variable-scopes)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.7.1 `globalThis` ^(ES2020)](#globalThis)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.8 Declarations: scope and activation](#declarations-scope-activation)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.8.1 `const` and `let`: temporal dead zone](#temporal-dead-zone)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.8.2 Function declarations and early activation](#early-activation)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.8.3 Class declarations are not activated early](#class-declarations-are-not-activated-early)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.8.4 `var`: hoisting (partial early activation)](#hoisting)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.9 Closures](#closures)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.9.1 Bound variables vs. free variables](#bound-variables-vs-free-variables)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.9.2 What is a closure?](#what-is-a-closure)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.9.3 Example: A factory for incrementors](#example-a-factory-for-incrementors)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.9.4 Use cases for closures](#use-cases-for-closures)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These are JavaScript’s main ways of declaring variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`let` declares mutable variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const` declares *constants* (immutable variables).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before ES6, there was also `var`. But it has several quirks, so it’s best to
    avoid it in modern JavaScript. You can read more about it in [*Speaking JavaScript*](http://exploringjs.com/es5/ch16.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[13.1 `let`](#let)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Variables declared via `let` are mutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also declare and assign at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[13.2 `const`](#const)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Variables declared via `const` are immutable. We must always initialize immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3][PRE4]`` #### [13.2.1 `const` and immutability](#const-creates-immutable-bindings)    In
    JavaScript, `const` only means that the *binding* (the association between variable
    name and variable value) is immutable. The value itself may be mutable, like `obj`
    in the following example.    [PRE5] `` // Not allowed: assigning to `obj` `` `assert.throws(`  `()
    => { obj = {} },`  `{`  `name: ''TypeError'',`  `message: ''Assignment to constant
    variable.'',`  `}` `);` [PRE6]   [PRE7][PRE8]` [PRE9][PRE10] #### [13.2.2 `const`
    and loops](#const-and-loops)    We can use `const` with `for-of` loops, where
    a fresh binding is created for each iteration:    [PRE11]    Output:    [PRE12]    In
    plain `for` loops, we must use `let`, however:    [PRE13]    ### [13.3 Deciding
    between `const` and `let`](#deciding-between-const-and-let)    I recommend the
    following rules to decide between `const` and `let`:    *   `const` indicates
    an immutable binding and that a variable never changes its value. Prefer it. *   `let`
    indicates that the value of a variable changes. Use it only when you can’t use
    `const`.    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    `const`**    `exercises/variables-assignment/const_exrc.mjs`    ### [13.4 The
    scope of a variable](#variable-scope)    The *scope* of a variable is the region
    of a program where it can be accessed. Consider the following code.    [PRE14]    *   Scope
    A is the *(direct) scope* of `x`. *   Scopes B and C are *inner scopes* of scope
    A. *   Scope A is an *outer scope* of scope B and scope C.    Each variable is
    accessible in its direct scope and all scopes nested within that scope.    The
    variables declared via `const` and `let` are called *block-scoped* because their
    scopes are always the innermost surrounding blocks.    #### [13.4.1 Shadowing
    variables](#shadowing-variables)    We can’t declare the same variable twice at
    the same level:    [PRE15]    ![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **Why
    `eval()`?**    [`eval()`](ch_dynamic-code-evaluation.html#eval) delays parsing
    (and therefore the `SyntaxError`), until the callback of `assert.throws()` is
    executed. If we didn’t use it, we’d already get an error when this code is parsed
    and `assert.throws()` wouldn’t even be executed.    We can, however, nest a block
    and use the same variable name `x` that we used outside the block:    [PRE16]    Inside
    the block, the inner `x` is the only accessible variable with that name. The inner
    `x` is said to *shadow* the outer `x`. Once we leave the block, we can access
    the old value again.    ### [13.5 (Advanced)](#advanced-1)    All remaining sections
    are advanced.    ### [13.6 Terminology: static vs. dynamic](#programming-languages-static-vs-dynamic)    These
    two adjectives describe phenomena in programming languages:    *   *Static* means
    that something is related to source code and can be determined without executing
    code. *   *Dynamic* means at runtime.    Let’s look at examples of these two terms.    ####
    [13.6.1 Static phenomenon: scopes of variables](#static-phenomenon-scopes-of-variables)    Variable
    scopes are a static phenomenon. Consider the following code:    [PRE17]    `x`
    is *statically* (or *lexically*) *scoped*. That is, its scope is fixed and doesn’t
    change at runtime.    Variable scopes form a static tree (via static nesting).    ####
    [13.6.2 Dynamic phenomenon: function calls](#dynamic-phenomenon-function-calls)    Function
    calls are a dynamic phenomenon. Consider the following code:    [PRE18]    Whether
    or not the function call in line A happens, can only be decided at runtime.    Function
    calls form a dynamic tree (via dynamic calls).    ### [13.7 The scopes of JavaScript’s
    global variables](#global-variable-scopes)    JavaScript’s variable scopes are
    nested. They form a tree:    *   The outermost scope is the root of the tree.
    *   The scopes directly contained in that scope are the children of the root.
    *   And so on.    The root is also called the *global scope*. In web browsers,
    the only location where one is directly in that scope is at the top level of a
    script. The variables of the global scope are called *global variables* and accessible
    everywhere. There are two kinds of global variables:    *   *Global declarative
    variables* are normal variables:               *   They can only be created while
    at the top level of a script, via `const`, `let`, and class declarations. *   *Global
    object variables* are stored in properties of the so-called *global object*:               *   They
    are created in the top level of a script, via `var` and function declarations.     *   The
    global object can be accessed via the global variable `globalThis`. It can be
    used to create, read, and delete global object variables.     *   Other than that,
    global object variables work like normal variables.    The following HTML fragment
    demonstrates `globalThis` and the two kinds of global variables.    [PRE19]    Each
    module has its own variable scope that is a direct child of the global scope.
    Therefore, variables that exist at the top level of a module are not global. [Figure
    13.1](#fig:global-scope) illustrates how the various scopes are related.    ![](../Images/52eed01843eedb709d2fd13429ec233c.png)      Figure
    13.1: The global scope is JavaScript’s outermost scope. It has two kinds of variables:
    *object variables* (managed via the *global object*) and normal *declarative variables*.
    Each ECMAScript module has its own scope which is contained in the global scope.      ####
    [13.7.1 `globalThis` ^(ES2020)](#globalThis)    The global variable `globalThis`
    is the standard way of accessing the global object. It got its name from the fact
    that it has the same value as `this` in global scope (script scope, not module
    scope).    ![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **`globalThis`
    does not always directly point to the global object**    For example, in browsers,
    [there is an indirection](https://exploringjs.com/deep-js/ch_global-scope.html#window-proxy).
    That indirection is normally not noticable, but it is there and can be observed.    #####
    [13.7.1.1 Alternatives to `globalThis`](#alternatives-to-globalthis)    The following
    global variables let us access the global object on *some* platforms:    *   `window`:
    The classic way of referring to the global object. But it doesn’t work in Node.js
    and in Web Workers. *   `self`: Available in Web Workers and browsers in general.
    But it isn’t supported by Node.js. *   `global`: Only available in Node.js.     |  |
    Main browser thread | Web Workers | Node.js | | --- | --- | --- | --- | | `globalThis`
    | ✔ | ✔ | ✔ | | `window` | ✔ |  |  | | `self` | ✔ | ✔ |  | | `global` |  |  |
    ✔ |    ##### [13.7.1.2 Use cases for `globalThis`](#use-cases-for-globalthis)    The
    global object is now considered a mistake that JavaScript can’t get rid of, due
    to backward compatibility. It affects performance negatively and is generally
    confusing.    ECMAScript 6 introduced several features that make it easier to
    avoid the global object – for example:    *   `const`, `let`, and class declarations
    don’t create global object properties when used in global scope. *   Each ECMAScript
    module has its own local scope.    It is usually better to access global object
    variables via variables and not via properties of `globalThis`. The former has
    always worked the same on all JavaScript platforms.    Tutorials on the web occasionally
    access global variables `globVar` via `window.globVar`. But the prefix “`window.`”
    is not necessary and I recommend to omit it:    [PRE20]    Therefore, there are
    relatively few use cases for `globalThis` – for example:    *   [*Polyfills*](ch_modules.html#polyfills)
    that add new features to old JavaScript engines. *   Feature detection, to find
    out what features a JavaScript engine supports.    ### [13.8 Declarations: scope
    and activation](#declarations-scope-activation)    These are two key aspects of
    declarations:    *   Scope: Where can a declared entity be seen? This is a static
    trait. *   Activation: When can I access an entity? This is a dynamic trait. Some
    entities can be accessed as soon as we enter their scopes. For others, we have
    to wait until execution reaches their declarations.    The following table summarizes
    how various declarations handle these aspects:     |  | Scope | Activation | Duplicates
    | Global prop. | | --- | --- | --- | --- | --- | | `const` | Block | decl. (TDZ)
    | ✘ | ✘ | | `let` | Block | decl. (TDZ) | ✘ | ✘ | | `function` | Block (*) | start
    | ✔ | ✔ | | `class` | Block | decl. (TDZ) | ✘ | ✘ | | `import` | Module | start
    | ✘ | ✘ | | `var` | Function | start (partially) | ✔ | ✔ |    (*) Function declarations
    are normally block-scoped, but function-scoped in [non-strict mode](ch_syntax.html#strict-mode).    Aspects
    of declarations:    *   For most constructs, their scope is the innermost surrounding
    block. There are two exceptions:     *   `import` can only be used at the top
    level of a module.     *   The scope of a variable declared via `var` is its innermost
    surrounding function (not block). *   The activation of the constructs (when we
    can access them) varies and is described in more detail later – e.g., *TDZ* means
    *temporal dead zone*. *   “Duplicates” describes if a declaration can be used
    twice with the same name (per scope). *   “Global prop.” describes if a declaration
    adds a property to the global object, when it is executed in the global scope
    of a script.    `import` is described in [“ECMAScript modules” (§29.5)](ch_modules.html#ecmascript-modules).
    The following subsections describe the other constructs and phenomena in more
    detail.    #### [13.8.1 `const` and `let`: temporal dead zone](#temporal-dead-zone)    #####
    [13.8.1.1 What to do when a variable is accessed before its declaration?](#what-to-do-when-a-variable-is-accessed-before-its-declaration)    For
    JavaScript, TC39 needed to decide what happens if we access a constant in its
    direct scope, before its declaration:    [PRE21]    Some possible approaches are:    1.  The
    name is resolved in the scope surrounding the current scope. 2.  We get `undefined`.
    3.  There is an error.    Approach 1 was rejected because there is no precedent
    in the language for this approach. It would therefore not be intuitive to JavaScript
    programmers.    Approach 2 was rejected because then `x` wouldn’t be a constant
    – it would have different values before and after its declaration.    `let` uses
    the same approach 3 as `const`, so that both work similarly and it’s easy to switch
    between them.    ##### [13.8.1.2 The temporal dead zone](#the-temporal-dead-zone)    The
    time between entering the scope of a variable and executing its declaration is
    called the *temporal dead zone* (TDZ) of that variable:    *   During this time,
    the variable is considered to be uninitialized (as if that were a special value
    it has). *   If we access an uninitialized variable, we get a `ReferenceError`.
    *   Once we reach a variable declaration, the variable is set to either the value
    of the initializer (specified via the assignment symbol) or `undefined` – if there
    is no initializer.    The following code illustrates the temporal dead zone:    [PRE22]   [PRE23][PRE24]``js[PRE25]`js`
    Even though `func()` is located before the declaration of `myVar` and uses that
    variable, we can call `func()`. But we have to wait until the temporal dead zone
    of `myVar` is over.    #### [13.8.2 Function declarations and early activation](#early-activation)    ![Icon
    “reading”](../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png) **More information
    on functions**    In this section, we are using functions – before we had a chance
    to learn them properly. Hopefully, everything still makes sense. Whenever it doesn’t,
    please see [“Callable values” (§27)](ch_callables.html#ch_callables).    A function
    declaration is always executed when entering its scope, regardless of where it
    is located within that scope. That enables us to call a function `funcDecl()`
    before it is declared.    [PRE26]js    The early activation of `funcDecl()` means
    that the previous code is equivalent to:    [PRE27]js    If we declare a function
    via `const` or `let`, then it is not activated early. In the following example,
    we can only use `arrowFunc()` after its declaration.    [PRE28]js   [PRE29] #####
    [13.8.2.1 Calling ahead without early activation](#calling-ahead-without-early-activation)    A
    function `f()` can call a function `g()` that is declared later and not activated
    early – as long as we invoke `f()` after the declaration of `g()`:    [PRE30]   [PRE31]``
    The functions of a module are usually invoked after its complete body is executed.
    Therefore, in modules, we rarely need to worry about the order of functions (even
    if they are not function declarations).    ##### [13.8.2.2 A pitfall of early
    activation](#a-pitfall-of-early-activation)    If we rely on early activation
    to call a function before its declaration, then we need to be careful that it
    doesn’t access data that isn’t activated early.    [PRE32]   [PRE33]` The problem
    goes away if we make the call to `funcDecl()` after the declaration of `MY_STR`.    #####
    [13.8.2.3 The pros and cons of early activation](#the-pros-and-cons-of-early-activation)    We
    have seen that early activation has a pitfall and that we can get most of its
    benefits without using it. Therefore, it is better to avoid early activation.
    But I don’t feel strongly about this and, as mentioned before, often use function
    declarations because I like their syntax.    #### [13.8.3 Class declarations are
    not activated early](#class-declarations-are-not-activated-early)    Even though
    they are similar to function declarations in some ways, [class declarations](ch_classes.html#classes)
    are not activated early:    [PRE34]   [PRE35] [PRE36]`js [PRE37]js`` [PRE38]js[PRE39][PRE40][PRE41][PRE42]js[PRE43]js`
    [PRE44]`js`` [PRE45]````'
  prefs: []
  type: TYPE_NORMAL
