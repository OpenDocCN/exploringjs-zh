- en: 13 Variables and assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_variables-assignment.html](https://exploringjs.com/js/book/ch_variables-assignment.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[13.1 `let`](#let)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.2 `const`](#const)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.2.1 `const` and immutability](#const-creates-immutable-bindings)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.2.2 `const` and loops](#const-and-loops)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.3 Deciding between `const` and `let`](#deciding-between-const-and-let)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.4 The scope of a variable](#variable-scope)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.4.1 Shadowing variables](#shadowing-variables)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.5 (Advanced)](#advanced-1)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.6 Terminology: static vs. dynamic](#programming-languages-static-vs-dynamic)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.6.1 Static phenomenon: scopes of variables](#static-phenomenon-scopes-of-variables)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.6.2 Dynamic phenomenon: function calls](#dynamic-phenomenon-function-calls)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.7 The scopes of JavaScript’s global variables](#global-variable-scopes)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.7.1 `globalThis` ^(ES2020)](#globalThis)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.8 Declarations: scope and activation](#declarations-scope-activation)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.8.1 `const` and `let`: temporal dead zone](#temporal-dead-zone)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.8.2 Function declarations and early activation](#early-activation)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.8.3 Class declarations are not activated early](#class-declarations-are-not-activated-early)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.8.4 `var`: hoisting (partial early activation)](#hoisting)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.9 Closures](#closures)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.9.1 Bound variables vs. free variables](#bound-variables-vs-free-variables)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.9.2 What is a closure?](#what-is-a-closure)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.9.3 Example: A factory for incrementors](#example-a-factory-for-incrementors)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13.9.4 Use cases for closures](#use-cases-for-closures)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These are JavaScript’s main ways of declaring variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`let` declares mutable variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const` declares *constants* (immutable variables).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before ES6, there was also `var`. But it has several quirks, so it’s best to
    avoid it in modern JavaScript. You can read more about it in [*Speaking JavaScript*](http://exploringjs.com/es5/ch16.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[13.1 `let`](#let)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Variables declared via `let` are mutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also declare and assign at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[13.2 `const`](#const)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Variables declared via `const` are immutable. We must always initialize immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[13.2.1 `const` and immutability](#const-creates-immutable-bindings)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In JavaScript, `const` only means that the *binding* (the association between
    variable name and variable value) is immutable. The value itself may be mutable,
    like `obj` in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[13.2.2 `const` and loops](#const-and-loops)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can use `const` with `for-of` loops, where a fresh binding is created for
    each iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In plain `for` loops, we must use `let`, however:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[13.3 Deciding between `const` and `let`](#deciding-between-const-and-let)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I recommend the following rules to decide between `const` and `let`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const` indicates an immutable binding and that a variable never changes its
    value. Prefer it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`let` indicates that the value of a variable changes. Use it only when you
    can’t use `const`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    `const`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/variables-assignment/const_exrc.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[13.4 The scope of a variable](#variable-scope)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *scope* of a variable is the region of a program where it can be accessed.
    Consider the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Scope A is the *(direct) scope* of `x`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scopes B and C are *inner scopes* of scope A.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scope A is an *outer scope* of scope B and scope C.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each variable is accessible in its direct scope and all scopes nested within
    that scope.
  prefs: []
  type: TYPE_NORMAL
- en: The variables declared via `const` and `let` are called *block-scoped* because
    their scopes are always the innermost surrounding blocks.
  prefs: []
  type: TYPE_NORMAL
- en: '[13.4.1 Shadowing variables](#shadowing-variables)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can’t declare the same variable twice at the same level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **Why `eval()`?**'
  prefs: []
  type: TYPE_NORMAL
- en: '[`eval()`](ch_dynamic-code-evaluation.html#eval) delays parsing (and therefore
    the `SyntaxError`), until the callback of `assert.throws()` is executed. If we
    didn’t use it, we’d already get an error when this code is parsed and `assert.throws()`
    wouldn’t even be executed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, however, nest a block and use the same variable name `x` that we used
    outside the block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Inside the block, the inner `x` is the only accessible variable with that name.
    The inner `x` is said to *shadow* the outer `x`. Once we leave the block, we can
    access the old value again.
  prefs: []
  type: TYPE_NORMAL
- en: '[13.5 (Advanced)](#advanced-1)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All remaining sections are advanced.
  prefs: []
  type: TYPE_NORMAL
- en: '[13.6 Terminology: static vs. dynamic](#programming-languages-static-vs-dynamic)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These two adjectives describe phenomena in programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Static* means that something is related to source code and can be determined
    without executing code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dynamic* means at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at examples of these two terms.
  prefs: []
  type: TYPE_NORMAL
- en: '[13.6.1 Static phenomenon: scopes of variables](#static-phenomenon-scopes-of-variables)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Variable scopes are a static phenomenon. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`x` is *statically* (or *lexically*) *scoped*. That is, its scope is fixed
    and doesn’t change at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: Variable scopes form a static tree (via static nesting).
  prefs: []
  type: TYPE_NORMAL
- en: '[13.6.2 Dynamic phenomenon: function calls](#dynamic-phenomenon-function-calls)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Function calls are a dynamic phenomenon. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Whether or not the function call in line A happens, can only be decided at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Function calls form a dynamic tree (via dynamic calls).
  prefs: []
  type: TYPE_NORMAL
- en: '[13.7 The scopes of JavaScript’s global variables](#global-variable-scopes)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript’s variable scopes are nested. They form a tree:'
  prefs: []
  type: TYPE_NORMAL
- en: The outermost scope is the root of the tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scopes directly contained in that scope are the children of the root.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The root is also called the *global scope*. In web browsers, the only location
    where one is directly in that scope is at the top level of a script. The variables
    of the global scope are called *global variables* and accessible everywhere. There
    are two kinds of global variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Global declarative variables* are normal variables:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can only be created while at the top level of a script, via `const`, `let`,
    and class declarations.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Global object variables* are stored in properties of the so-called *global
    object*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are created in the top level of a script, via `var` and function declarations.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The global object can be accessed via the global variable `globalThis`. It can
    be used to create, read, and delete global object variables.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Other than that, global object variables work like normal variables.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The following HTML fragment demonstrates `globalThis` and the two kinds of global
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Each module has its own variable scope that is a direct child of the global
    scope. Therefore, variables that exist at the top level of a module are not global.
    [Figure 13.1](#fig:global-scope) illustrates how the various scopes are related.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/52eed01843eedb709d2fd13429ec233c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: The global scope is JavaScript’s outermost scope. It has two kinds
    of variables: *object variables* (managed via the *global object*) and normal
    *declarative variables*. Each ECMAScript module has its own scope which is contained
    in the global scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '[13.7.1 `globalThis` ^(ES2020)](#globalThis)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The global variable `globalThis` is the standard way of accessing the global
    object. It got its name from the fact that it has the same value as `this` in
    global scope (script scope, not module scope).
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **`globalThis`
    does not always directly point to the global object**'
  prefs: []
  type: TYPE_NORMAL
- en: For example, in browsers, [there is an indirection](https://exploringjs.com/deep-js/ch_global-scope.html#window-proxy).
    That indirection is normally not noticable, but it is there and can be observed.
  prefs: []
  type: TYPE_NORMAL
- en: '[13.7.1.1 Alternatives to `globalThis`](#alternatives-to-globalthis)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following global variables let us access the global object on *some* platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`window`: The classic way of referring to the global object. But it doesn’t
    work in Node.js and in Web Workers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self`: Available in Web Workers and browsers in general. But it isn’t supported
    by Node.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`global`: Only available in Node.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  | Main browser thread | Web Workers | Node.js |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `globalThis` | ✔ | ✔ | ✔ |'
  prefs: []
  type: TYPE_TB
- en: '| `window` | ✔ |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `self` | ✔ | ✔ |  |'
  prefs: []
  type: TYPE_TB
- en: '| `global` |  |  | ✔ |'
  prefs: []
  type: TYPE_TB
- en: '[13.7.1.2 Use cases for `globalThis`](#use-cases-for-globalthis)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The global object is now considered a mistake that JavaScript can’t get rid
    of, due to backward compatibility. It affects performance negatively and is generally
    confusing.
  prefs: []
  type: TYPE_NORMAL
- en: 'ECMAScript 6 introduced several features that make it easier to avoid the global
    object – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const`, `let`, and class declarations don’t create global object properties
    when used in global scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each ECMAScript module has its own local scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is usually better to access global object variables via variables and not
    via properties of `globalThis`. The former has always worked the same on all JavaScript
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tutorials on the web occasionally access global variables `globVar` via `window.globVar`.
    But the prefix “`window.`” is not necessary and I recommend to omit it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, there are relatively few use cases for `globalThis` – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Polyfills*](ch_modules.html#polyfills) that add new features to old JavaScript
    engines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature detection, to find out what features a JavaScript engine supports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[13.8 Declarations: scope and activation](#declarations-scope-activation)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These are two key aspects of declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scope: Where can a declared entity be seen? This is a static trait.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Activation: When can I access an entity? This is a dynamic trait. Some entities
    can be accessed as soon as we enter their scopes. For others, we have to wait
    until execution reaches their declarations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table summarizes how various declarations handle these aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Scope | Activation | Duplicates | Global prop. |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `const` | Block | decl. (TDZ) | ✘ | ✘ |'
  prefs: []
  type: TYPE_TB
- en: '| `let` | Block | decl. (TDZ) | ✘ | ✘ |'
  prefs: []
  type: TYPE_TB
- en: '| `function` | Block (*) | start | ✔ | ✔ |'
  prefs: []
  type: TYPE_TB
- en: '| `class` | Block | decl. (TDZ) | ✘ | ✘ |'
  prefs: []
  type: TYPE_TB
- en: '| `import` | Module | start | ✘ | ✘ |'
  prefs: []
  type: TYPE_TB
- en: '| `var` | Function | start (partially) | ✔ | ✔ |'
  prefs: []
  type: TYPE_TB
- en: (*) Function declarations are normally block-scoped, but function-scoped in
    [non-strict mode](ch_syntax.html#strict-mode).
  prefs: []
  type: TYPE_NORMAL
- en: 'Aspects of declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For most constructs, their scope is the innermost surrounding block. There
    are two exceptions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import` can only be used at the top level of a module.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The scope of a variable declared via `var` is its innermost surrounding function
    (not block).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The activation of the constructs (when we can access them) varies and is described
    in more detail later – e.g., *TDZ* means *temporal dead zone*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Duplicates” describes if a declaration can be used twice with the same name
    (per scope).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Global prop.” describes if a declaration adds a property to the global object,
    when it is executed in the global scope of a script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import` is described in [“ECMAScript modules” (§29.5)](ch_modules.html#ecmascript-modules).
    The following subsections describe the other constructs and phenomena in more
    detail.'
  prefs: []
  type: TYPE_NORMAL
- en: '[13.8.1 `const` and `let`: temporal dead zone](#temporal-dead-zone)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[13.8.1.1 What to do when a variable is accessed before its declaration?](#what-to-do-when-a-variable-is-accessed-before-its-declaration)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For JavaScript, TC39 needed to decide what happens if we access a constant
    in its direct scope, before its declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Some possible approaches are:'
  prefs: []
  type: TYPE_NORMAL
- en: The name is resolved in the scope surrounding the current scope.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get `undefined`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Approach 1 was rejected because there is no precedent in the language for this
    approach. It would therefore not be intuitive to JavaScript programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Approach 2 was rejected because then `x` wouldn’t be a constant – it would have
    different values before and after its declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '`let` uses the same approach 3 as `const`, so that both work similarly and
    it’s easy to switch between them.'
  prefs: []
  type: TYPE_NORMAL
- en: '[13.8.1.2 The temporal dead zone](#the-temporal-dead-zone)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The time between entering the scope of a variable and executing its declaration
    is called the *temporal dead zone* (TDZ) of that variable:'
  prefs: []
  type: TYPE_NORMAL
- en: During this time, the variable is considered to be uninitialized (as if that
    were a special value it has).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we access an uninitialized variable, we get a `ReferenceError`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we reach a variable declaration, the variable is set to either the value
    of the initializer (specified via the assignment symbol) or `undefined` – if there
    is no initializer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code illustrates the temporal dead zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The next example shows that the temporal dead zone is truly *temporal* (related
    to time):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Even though `func()` is located before the declaration of `myVar` and uses that
    variable, we can call `func()`. But we have to wait until the temporal dead zone
    of `myVar` is over.
  prefs: []
  type: TYPE_NORMAL
- en: '[13.8.2 Function declarations and early activation](#early-activation)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '![Icon “reading”](../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png) **More information
    on functions**'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are using functions – before we had a chance to learn them
    properly. Hopefully, everything still makes sense. Whenever it doesn’t, please
    see [“Callable values” (§27)](ch_callables.html#ch_callables).
  prefs: []
  type: TYPE_NORMAL
- en: A function declaration is always executed when entering its scope, regardless
    of where it is located within that scope. That enables us to call a function `funcDecl()`
    before it is declared.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The early activation of `funcDecl()` means that the previous code is equivalent
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If we declare a function via `const` or `let`, then it is not activated early.
    In the following example, we can only use `arrowFunc()` after its declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[13.8.2.1 Calling ahead without early activation](#calling-ahead-without-early-activation)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A function `f()` can call a function `g()` that is declared later and not activated
    early – as long as we invoke `f()` after the declaration of `g()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The functions of a module are usually invoked after its complete body is executed.
    Therefore, in modules, we rarely need to worry about the order of functions (even
    if they are not function declarations).
  prefs: []
  type: TYPE_NORMAL
- en: '[13.8.2.2 A pitfall of early activation](#a-pitfall-of-early-activation)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If we rely on early activation to call a function before its declaration, then
    we need to be careful that it doesn’t access data that isn’t activated early.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The problem goes away if we make the call to `funcDecl()` after the declaration
    of `MY_STR`.
  prefs: []
  type: TYPE_NORMAL
- en: '[13.8.2.3 The pros and cons of early activation](#the-pros-and-cons-of-early-activation)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We have seen that early activation has a pitfall and that we can get most of
    its benefits without using it. Therefore, it is better to avoid early activation.
    But I don’t feel strongly about this and, as mentioned before, often use function
    declarations because I like their syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[13.8.3 Class declarations are not activated early](#class-declarations-are-not-activated-early)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Even though they are similar to function declarations in some ways, [class
    declarations](ch_classes.html#classes) are not activated early:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Why is that? Consider the following class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The operand of `extends` is an expression. Therefore, we can do things like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Evaluating such an expression must be done at the location where it is mentioned.
    Anything else would be confusing. That explains why class declarations are not
    activated early.
  prefs: []
  type: TYPE_NORMAL
- en: '[13.8.4 `var`: hoisting (partial early activation)](#hoisting)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`var` is an older way of declaring variables that predates `const` and `let`
    (which are preferred now). Consider the following `var` declaration.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This declaration has two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaration `var x`: The scope of a `var`-declared variable is the innermost
    surrounding function and not the innermost surrounding block, as for most other
    declarations. Such a variable is already active at the beginning of its scope
    and initialized with `undefined`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assignment `x = 123`: The assignment is always executed in place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code demonstrates the effects of `var`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[13.9 Closures](#closures)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we can explore closures, we need to learn about bound variables and free
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[13.9.1 Bound variables vs. free variables](#bound-variables-vs-free-variables)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Per scope, there is a set of variables that are mentioned. Among these variables
    we distinguish:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Bound variables* are declared within the scope. They are parameters and local
    variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Free variables* are declared externally. They are also called *non-local variables*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the body of `func()`, `x` and `y` are bound variables. `z` is a free variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[13.9.2 What is a closure?](#what-is-a-closure)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What is a closure then? A *closure* is a function plus a connection to the variables
    that exist at its “birth place”.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is the point of keeping this connection? It provides the values for the
    free variables of the function – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`funcFactory` returns a closure that is assigned to `func`. Because `func`
    has the connection to the variables at its birth place, it can still access the
    free variable `value` when it is called in line A (even though it “escaped” its
    scope).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **All functions
    in JavaScript are closures**'
  prefs: []
  type: TYPE_NORMAL
- en: Static scoping is supported via closures in JavaScript. Therefore, every function
    is a closure.
  prefs: []
  type: TYPE_NORMAL
- en: '[13.9.3 Example: A factory for incrementors](#example-a-factory-for-incrementors)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following function returns *incrementors* (a name that I just made up).
    An incrementor is a function that internally stores a number. When it is called,
    it updates that number by adding the argument to it and returns the new value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the function created in line A keeps its internal number in
    the free variable `startValue`. This time, we don’t just read from the birth scope,
    we use it to store data that we change and that persists across function calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create more storage slots in the birth scope, via local variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[13.9.4 Use cases for closures](#use-cases-for-closures)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What are closures good for?
  prefs: []
  type: TYPE_NORMAL
- en: For starters, they are simply an implementation of static scoping. As such,
    they provide context data for callbacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can also be used by functions to store state that persists across function
    calls. `createInc()` is an example of that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And they can provide private data for objects (produced via literals or classes).
    The details of how that works are explained in [*Exploring ES6*](https://exploringjs.com/es6/ch_classes.html#_private-data-via-constructor-environments).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
