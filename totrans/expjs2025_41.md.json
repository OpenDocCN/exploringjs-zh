["```js\n// Creating an Array\nconst arr = ['a', 'b', 'c']; // Array literal\nassert.deepEqual(\n  arr,\n  [ // Array literal\n    'a',\n    'b',\n    'c', // trailing commas are ignored\n  ]\n);\n\n// Reading elements\nassert.equal(\n  arr[0], 'a' // negative indices don’t work\n);\nassert.equal(\n  arr.at(-1), 'c' // negative indices work\n);\n\n// Writing an element\narr[0] = 'x';\nassert.deepEqual(\n  arr, ['x', 'b', 'c']\n);\n\n```", "```js\nconst arr = ['a', 'b', 'c'];\nassert.equal(\n  arr.length, 3 // number of elements\n);\narr.length = 1; // removing elements\nassert.deepEqual(\n  arr, ['a']\n);\narr[arr.length] = 'b'; // adding an element\nassert.deepEqual(\n  arr, ['a', 'b']\n);\n\n```", "```js\nconst arr = ['a', 'b'];\n\narr.push('c'); // adding an element\nassert.deepEqual(\n  arr, ['a', 'b', 'c']\n);\n\n// Pushing Arrays (used as arguments via spreading (...)):\narr.push(...['d', 'e']);\nassert.deepEqual(\n  arr, ['a', 'b', 'c', 'd', 'e']\n);\n\n```", "```js\nconst arr1 = ['a', 'b'];\nconst arr2 = ['c'];\nassert.deepEqual(\n  [...arr1, ...arr2, 'd', 'e'],\n  ['a', 'b', 'c', 'd', 'e']\n);\n\n```", "```js\nconst arr = ['a', 'b', 'c'];\nfor (const value of arr) {\n  console.log(value);\n}\n\n```", "```js\na\nb\nc\n\n```", "```js\nconst arr = ['a', 'b', 'c'];\nfor (const [index, value] of arr.entries()) {\n  console.log(index, value);\n}\n\n```", "```js\n0 a\n1 b\n2 c\n\n```", "```js\n// Adding and removing at the start\nconst arr1 = ['■', '●'];\narr1.unshift('▲');\nassert.deepEqual(\n  arr1, ['▲', '■', '●']\n);\narr1.shift();\nassert.deepEqual(\n  arr1, ['■', '●']\n);\n\n// Adding and removing at the end\nconst arr2 = ['■', '●'];\narr2.push('▲');\nassert.deepEqual(\n  arr2, ['■', '●', '▲']\n);\narr2.pop();\nassert.deepEqual(\n  arr2, ['■', '●']\n);\n\n```", "```js\n> ['■', '●', '■'].includes('■')\ntrue\n> ['■', '●', '■'].indexOf('■')\n0\n> ['■', '●', '■'].lastIndexOf('■')\n2\n> ['●', '', '▲'].find(x => x.length > 0)\n'●'\n> ['●', '', '▲'].findLast(x => x.length > 0)\n'▲'\n> ['●', '', '▲'].findIndex(x => x.length > 0)\n0\n> ['●', '', '▲'].findLastIndex(x => x.length > 0)\n2\n\n```", "```js\n> ['▲', '●'].map(x => x+x)\n['▲▲', '●●']\n> ['■', '●', '■'].filter(x => x === '■') \n['■', '■']\n> ['▲', '●'].flatMap(x => [x,x])\n['▲', '▲', '●', '●']\n\n```", "```js\n> ['■', '●', '▲'].slice(1, 3)\n['●', '▲']\n> ['■', '●', '▲'].slice() // complete copy\n['■', '●', '▲']\n\n```", "```js\n> ['■','●','▲'].join('-')\n'■-●-▲'\n> ['■','●','▲'].join('')\n'■●▲'\n\n```", "```js\n// By default, string representations of the Array elements\n// are sorted lexicographically:\nconst arr = [200, 3, 10];\narr.sort();\nassert.deepEqual(\n  arr, [10, 200, 3]\n);\n\n// Sorting can be customized via a callback:\nassert.deepEqual(\n  [200, 3, 10].sort((a, z) => a - z), // sort numerically\n  [3, 10, 200]\n);\n\n```", "```js\n> Object.entries({ a: 1, b: 2, c: 3 })\n[\n  [ 'a', 1 ],\n  [ 'b', 2 ],\n  [ 'c', 3 ],\n]\n\n```", "```js\nconst arr = ['a', 'b', 'c'];\n\n```", "```js\nconst arr = [\n  'a',\n  'b',\n  'c',\n];\n\n```", "```js\nconst arr = ['a', 'b', 'c'];\nassert.equal(arr[0], 'a');\n\n```", "```js\nconst arr = ['a', 'b', 'c'];\narr[0] = 'x';\nassert.deepEqual(arr, ['x', 'b', 'c']);\n\n```", "```js\nconst arr = ['a', 'b'];\nassert.equal(arr.length, 2);\n\n```", "```js\narr[arr.length] = 'c';\nassert.deepEqual(\n  arr, ['a', 'b', 'c']\n);\nassert.equal(arr.length, 3)\n\n```", "```js\narr.length = 1;\nassert.deepEqual(\n  arr, ['a']\n);\n\n```", "```js\nconst arr = ['a', 'b'];\narr.push('c');\nassert.deepEqual(\n  arr, ['a', 'b', 'c']\n);\n\n```", "```js\n> const arr = ['a', 'b', 'c'];\n> arr.slice(-1)\n[ 'c' ]\n> arr.slice(arr.length - 1)\n[ 'c' ]\n\n```", "```js\n> ['a', 'b', 'c'].at(0)\n'a'\n> ['a', 'b', 'c'].at(-1)\n'c'\n\n```", "```js\nconst arr = ['a', 'b', 'c'];\n\narr[-1] = 'non-element property';\n// The Array elements didn’t change:\nassert.deepEqual(\n  Array.from(arr), // copy just the Array elements\n  ['a', 'b', 'c']\n);\n\nassert.equal(\n  arr[-1], 'non-element property'\n);\n\n```", "```js\nconst arr = ['a', 'b', 'c'];\narr.length = 0;\nassert.deepEqual(arr, []);\n\n```", "```js\nlet arr = ['a', 'b', 'c'];\narr = [];\nassert.deepEqual(arr, []);\n\n```", "```js\n> const iterable = ['b', 'c'];\n> ['a', ...iterable, 'd']\n[ 'a', 'b', 'c', 'd' ]\n\n```", "```js\nconst iterable = new Set(['x', 'y']);\nassert.deepEqual(\n  [...iterable],\n  ['x', 'y']\n);\n\n```", "```js\nconst arr = ['a', 'b', 'c'];\nconst copy = [...arr];\n\n```", "```js\nconst arr1 = ['a', 'b'];\nconst arr2 = ['c', 'd'];\n\nconst concatenated = [...arr1, ...arr2, 'e'];\nassert.deepEqual(\n  concatenated,\n  ['a', 'b', 'c', 'd', 'e']\n);\n\n```", "```js\n> [...'abc'] // strings are iterable\n[ 'a', 'b', 'c' ]\n> [...123]\nTypeError: 123 is not iterable\n> [...undefined]\nTypeError: undefined is not iterable\n\n```", "```js\nconst arr = ['a', 'b'];\narr.prop = true; // needed later\n\nassert.deepEqual(\n  arr.keys().toArray(), // (A)\n  [0, 1]\n);\n\n```", "```js\nassert.deepEqual(\n  Object.keys(arr),\n  ['0', '1', 'prop']\n);\n\n```", "```js\nassert.deepEqual(\n  arr.entries().toArray(),\n  [\n    [0, 'a'],\n    [1, 'b'],\n  ]\n);\n\n```", "```js\nassert.deepEqual(\n  Object.entries(arr),\n  [\n    ['0', 'a'],\n    ['1', 'b'],\n    ['prop', true],\n  ]\n);\n\n```", "```js\n> Array.isArray([])\ntrue\n\n```", "```js\n> [] instanceof Array\ntrue\n\n```", "```js\n> typeof []\n'object'\n\n```", "```js\nfor (const element of ['a', 'b']) {\n  console.log(element);\n}\n\n```", "```js\na\nb\n\n```", "```js\nfor (const element of ['a', 'b'].keys()) {\n  console.log(element);\n}\n\n```", "```js\n0\n1\n\n```", "```js\nfor (const [index, element] of ['a', 'b'].entries()) {\n  console.log(index, element);\n}\n\n```", "```js\n0 a\n1 b\n\n```", "```js\n// .length is implicitly 0 in this case\nassert.deepEqual(\n  Array.from({}),\n  []\n);\n\nassert.deepEqual(\n  Array.from({length: 2, 0: 'a', 1: 'b'}),\n  [ 'a', 'b' ]\n);\n\n```", "```js\ninterface ArrayLike<T> {\n  length: number;\n  [n: number]: T;\n}\n\n```", "```js\nconst iterable = new Set(['a', 'b']);\nassert.deepEqual(\n  [...iterable],\n  ['a', 'b']\n);\n\n```", "```js\nconst iterable = new Set(['a', 'b']);\nassert.deepEqual(\n  Iterator.from(iterable).toArray(),\n  ['a', 'b']\n);\n\n```", "```js\nassert.deepEqual(\n  iterable.values().toArray(),\n  ['a', 'b']\n);\n\n```", "```js\n.from<T>(iterable: Iterable<T> | ArrayLike<T>): Array<T>\n\n```", "```js\n> Array.from(new Set(['a', 'b'])) // iterable\n[ 'a', 'b' ]\n> Array.from({length: 2, 0:'a', 1:'b'}) // Array-like\n[ 'a', 'b' ]\n\n```", "```js\n.from<T, U>(\n  iterable: Iterable<T> | ArrayLike<T>,\n  mapFunc: (v: T, i: number) => U,\n  thisArg?: any\n): Array<U>\n\n```", "```js\n> Array.from(new Set(['a', 'b']), x => x + x)\n[ 'aa', 'bb' ]\n\n```", "```js\nconst arr = ['a', 'b'];\n\nconst shallowCopy1 = arr.slice();\nconst shallowCopy2 = Array.from(arr);\nconst shallowCopy3 = [...arr];\nconst shallowCopy4 = arr.values().toArray();\n\nconst deepCopy = structuredClone(arr);\n\nconst copies = [\n  shallowCopy1, shallowCopy2, shallowCopy3, shallowCopy4, deepCopy\n];\nfor (const copy of copies) {\n  assert.deepEqual(copy, arr);\n}\n\n```", "```js\nconst arr = [];\nfor (let i=0; i<3; i++) {\n  arr.push('*'.repeat(i));\n}\nassert.deepEqual(\n  arr, ['', '*', '**']\n);\n\n```", "```js\n> new Array(3).fill(0)\n[ 0, 0, 0 ]\n\n```", "```js\n> new Array(3)\n[ , , ,]\n\n```", "```js\nconst arr = new Array(3).fill({});\narr[0].prop = true;\nassert.deepEqual(\n  arr, [\n    {prop: true},\n    {prop: true},\n    {prop: true},\n  ]);\n\n```", "```js\n> Array.from(new Array(3), () => ({}))\n[{}, {}, {}]\n\n```", "```js\n> new Array(3).map(() => ({}))\n[ , , ,]\n\n```", "```js\n> Array.from({length: 3}, () => ({}))\n[{}, {}, {}]\n\n```", "```js\nfunction createRange(start, end) {\n  return Array.from({length: end-start}, (_, i) => i+start);\n}\nassert.deepEqual(\n  createRange(2, 5),\n  [2, 3, 4]);\n\n```", "```js\n/** Returns an iterable */\nfunction createRange(end) {\n  return new Array(end).keys();\n}\nassert.deepEqual(\n  Array.from(createRange(4)),\n  [0, 1, 2, 3]\n);\n\n```", "```js\nfunction initMultiArray(...dimensions) {\n  function initMultiArrayRec(dimIndex) {\n    if (dimIndex >= dimensions.length) {\n      return 0;\n    } else {\n      const dim = dimensions[dimIndex];\n      const arr = [];\n      for (let i=0; i<dim; i++) {\n        arr.push(initMultiArrayRec(dimIndex+1));\n      }\n      return arr;\n    }\n  }\n  return initMultiArrayRec(0);\n}\n\nconst arr = initMultiArray(4, 3, 2);\narr[3][2][1] = 'X'; // last in each dimension\nassert.deepEqual(arr, [\n  [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ],\n  [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ],\n  [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ],\n  [ [ 0, 0 ], [ 0, 0 ], [ 0, 'X' ] ],\n]);\n\n```", "```js\nconst arr = ['a', 'b'];\narr.prop = 123;\nassert.deepEqual(\n  Object.keys(arr),\n  ['0', '1', 'prop'] // (A)\n);\n\nassert.equal(arr[0], 'a');  // (B)\nassert.equal(arr['0'], 'a'); // (C)\n\n```", "```js\nToString(ToUint32(str)) === str\n\n```", "```js\nconst arr = [];\narr.prop = true;\narr[1] = 'b';\narr[0] = 'a';\n\nassert.deepEqual(\n  Object.keys(arr),\n  ['0', '1', 'prop']\n);\nassert.deepEqual(\n  Object.entries(arr),\n  [['0', 'a'], ['1', 'b'], ['prop', true]]\n);\n\n```", "```js\nassert.deepEqual(\n  Array.from(arr.keys()),\n  [0, 1]\n);\nassert.deepEqual(\n  Array.from(arr.entries()),\n  [[0, 'a'], [1, 'b']]\n);\n\n```", "```js\nconst arr = [];\narr[0] = 'a';\narr[2] = 'c';\n\nassert.deepEqual(Object.keys(arr), ['0', '2']); // (A)\n\nassert.equal(0 in arr, true); // element\nassert.equal(1 in arr, false); // hole\n\n```", "```js\nconst arr = ['a', , 'c'];\n\nassert.deepEqual(Object.keys(arr), ['0', '2']);\n\n```", "```js\nconst arr = ['a'];\nassert.deepEqual(Object.keys(arr), ['0']);\nassert.equal(arr.length, 1);\narr.length = 3;\narr.push('x');\nassert.deepEqual(Object.keys(arr), ['0', '3']);\nassert.deepEqual(arr, ['a', /*hole*/, /*hole*/, 'x']);\n\n```", "```js\nconst arr = ['a', 'b', 'c'];\nassert.deepEqual(Object.keys(arr), ['0', '1', '2']);\ndelete arr[1];\nassert.deepEqual(Object.keys(arr), ['0', '2']);\nassert.deepEqual(arr, ['a', , 'c']);\n\n```", "```js\n> ['a',,'b'].filter(x => true)\n[ 'a', 'b' ]\n\n```", "```js\n> ['a', ,'a'].every(x => x === 'a')\ntrue\n\n```", "```js\n> ['a',,'b'].map(x => 'c')\n[ 'c', , 'c' ]\n\n```", "```js\n> Array.from(['a',,'b'])\n[ 'a', undefined, 'b' ]\n> Array.from(['a',,'b'], x => x + '!') // mapping\n[ 'a!', 'undefined!', 'b!' ]\n> ['a',,'b'].entries().toArray()\n[[0, 'a'], [1, undefined], [2, 'b']]\n\n```", "```js\n> ['a',,'b'].keys().toArray()\n[ 0, 1, 2 ]\n> Object.keys(['a',,'b'])\n[ '0', '2' ]\n\n```", "```js\nconst arr = ['a', 'b', 'c'];\n\narr[1] = 'x';\nassert.deepEqual(\n  // The original was modified\n  arr, ['a', 'x', 'c']\n);\n\n```", "```js\nconst arr = ['a', 'b', 'c'];\n\nassert.deepEqual(\n  // Produces a copy with changes\n  arr.with(1, 'x'),\n  ['a', 'x', 'c']\n);\nassert.deepEqual(\n  // The original is unchanged\n  arr, [ 'a', 'b', 'c' ]\n);\n\n```", "```js\nconst original = ['a', 'b', 'c'];\nconst reversed = original.reverse();\n\nassert.deepEqual(reversed, ['c', 'b', 'a']);\nassert.ok(reversed === original); // .reverse() returned `this`\nassert.deepEqual(original, ['c', 'b', 'a']);\n\n```", "```js\nconst original = ['a', 'b', 'c'];\n\nconst reversed1 = original.slice().reverse();\nconst reversed2 = Array.from(original).reverse();\nconst reversed3 = [...original].reverse();\nconst reversed4 = original.values().toArray().reverse();\n\nassert.deepEqual(original, ['a', 'b', 'c']);\n\n```", "```js\nconst original = ['a', 'b', 'c'];\nconst reversed = original.toReversed();\n\nassert.deepEqual(reversed, ['c', 'b', 'a']);\n// The original is unchanged\nassert.deepEqual(original, ['a', 'b', 'c']);\n\n```", "```js\nconst arr1 = ['a', 'b'];\narr1.push('x', 'y'); // append single elements\nassert.deepEqual(arr1, ['a', 'b', 'x', 'y']);\n\nconst arr2 = ['a', 'b'];\narr2.push(...['x', 'y']); // (A) append Array\nassert.deepEqual(arr2, ['a', 'b', 'x', 'y']);\n\n```", "```js\nconst arr2 = ['a', 'b', 'c'];\nassert.equal(arr2.pop(), 'c');\nassert.deepEqual(arr2, ['a', 'b']);\n\n```", "```js\nconst arr1 = ['a', 'b', 'c'];\nassert.equal(arr1.shift(), 'a');\nassert.deepEqual(arr1, ['b', 'c']);\n\n```", "```js\nconst arr1 = ['a', 'b'];\narr1.unshift('x', 'y'); // prepend single elements\nassert.deepEqual(arr1, ['x', 'y', 'a', 'b']);\n\nconst arr2 = ['a', 'b'];\narr2.unshift(...['x', 'y']); // prepend Array\nassert.deepEqual(arr2, ['x', 'y', 'a', 'b']);\n\n```", "```js\nconst arr1 = ['a', 'b'];\nassert.deepEqual(\n  ['x', 'y', ...arr1], // prepend single elements\n  ['x', 'y', 'a', 'b']);\nassert.deepEqual(arr1, ['a', 'b']); // unchanged!\n\nconst arr2 = ['a', 'b'];\nassert.deepEqual(\n  [...['x', 'y'], ...arr2], // prepend Array\n  ['x', 'y', 'a', 'b']);\nassert.deepEqual(arr2, ['a', 'b']); // unchanged!\n\n```", "```js\nconst arr1 = ['a', 'b'];\nassert.deepEqual(\n  [...arr1, 'x', 'y'], // append single elements\n  ['a', 'b', 'x', 'y']);\nassert.deepEqual(arr1, ['a', 'b']); // unchanged!\n\nconst arr2 = ['a', 'b'];\nassert.deepEqual(\n  [...arr2, ...['x', 'y']], // append Array\n  ['a', 'b', 'x', 'y']);\nassert.deepEqual(arr2, ['a', 'b']); // unchanged!\n\n```", "```js\ncallback: (value: T, index: number, array: Array<T>) => boolean\n\n```", "```js\n    > ['a', 'b', 'c'].map(x => x + x)\n    [ 'aa', 'bb', 'cc' ]\n\n    ```", "```js\n    > ['a', 'bb', 'ccc'].find(str => str.length >= 2)\n    'bb'\n\n    ```", "```js\n> [1, 2, 3].map(x => x * 3)\n[ 3, 6, 9 ]\n> ['how', 'are', 'you'].map(str => str.toUpperCase())\n[ 'HOW', 'ARE', 'YOU' ]\n> [true, true, true].map((_x, index) => index)\n[ 0, 1, 2 ]\n\n```", "```js\nfunction map(arr, mapFunc) {\n  const result = [];\n  for (const [i, x] of arr.entries()) {\n    result.push(mapFunc(x, i, arr));\n  }\n  return result;\n}\n\n```", "```js\n> [-1, 2, 5, -7, 6].filter(x => x >= 0)\n[ 2, 5, 6 ]\n> ['a', 'b', 'c', 'd'].filter((_x,i) => (i%2)===0)\n[ 'a', 'c' ]\n\n```", "```js\nfunction filter(arr, filterFunc) {\n  const result = [];\n  for (const [i, x] of arr.entries()) {\n    if (filterFunc(x, i, arr)) {\n      result.push(x);\n    }\n  }\n  return result;\n}\n\n```", "```js\n.flatMap<U>(\n  callback: (value: T, index: number, array: Array<T>) => U|Array<U>,\n  thisValue?: any\n): Array<U>\n\n```", "```js\n> ['a', 'b', 'c'].flatMap(x => [x,x])\n[ 'a', 'a', 'b', 'b', 'c', 'c' ]\n> ['a', 'b', 'c'].flatMap(x => [x])\n[ 'a', 'b', 'c' ]\n> ['a', 'b', 'c'].flatMap(x => [])\n[]\n\n```", "```js\nconst result = [\n  { status: 'fulfilled', value: 'sunshine.jpg' },\n  { status: 'rejected', reason: 'FILE NOT FOUND' },\n  { status: 'fulfilled', value: 'dog.jpg' },\n  { status: 'rejected', reason: 'NOT AUTHORIZED' },\n];\n\n```", "```js\nconst values = result.flatMap(\n  r => r.status === 'fulfilled' ? [r.value] : []\n);\nassert.deepEqual(\n  values, ['sunshine.jpg', 'dog.jpg']\n);\n\nconst reasons = result.flatMap(\n  r => r.status === 'rejected' ? [r.reason] : []\n);\nassert.deepEqual(\n  reasons, ['FILE NOT FOUND', 'NOT AUTHORIZED']\n);\n\n```", "```js\n> stringsToCodePoints(['many', 'a', 'moon'])\n['m', 'a', 'n', 'y', 'a', 'm', 'o', 'o', 'n']\n\n```", "```js\nfunction stringsToCodePoints(strs) {\n  return strs.flatMap(str => Array.from(str));\n}\n\n```", "```js\nfunction flatMap(arr, mapFunc) {\n  const result = [];\n  for (const [index, elem] of arr.entries()) {\n    const x = mapFunc(elem, index, arr);\n    // We allow mapFunc() to return non-Arrays\n    if (Array.isArray(x)) {\n      result.push(...x);\n    } else {\n      result.push(x);\n    }\n  }\n  return result;\n}\n\n```", "```js\n.reduce<U>(\n  callback: (accumulator: U, elem: T, idx: number, arr: Array<T>) => U,\n  init?: U\n): U\n\n```", "```js\nconst accumulator_0 = callback(init, arr[0]);\nconst accumulator_1 = callback(accumulator_0, arr[1]);\nconst accumulator_2 = callback(accumulator_1, arr[2]);\n// Etc.\n\n```", "```js\nfunction addAll(arr) {\n  return arr.reduce(\n    (sum, element) => sum + element,\n    0 // `init` value\n  );\n}\nassert.equal(addAll([1,  2, 3]), 6); // (A)\nassert.equal(addAll([7, -4, 2]), 5);\n\n```", "```js\ncallback(0, 1) --> 1\ncallback(1, 2) --> 3\ncallback(3, 3) --> 6\n\n```", "```js\nfunction addAll(arr) {\n  let sum = 0;\n  for (const element of arr) {\n    sum = sum + element;\n  }\n  return sum;\n}\n\n```", "```js\n> [1, 2].reduce((acc, elem) => acc + elem, 100)\n103\n> [1].reduce((acc, elem) => acc + elem, 100)\n101\n> [].reduce((acc, elem) => acc + elem, 100)\n100\n\n```", "```js\n> [1, 2].reduce((acc, elem) => acc + elem)\n3\n> [1].reduce((acc, elem) => acc + elem)\n1\n> [].reduce((acc, elem) => acc + elem)\nTypeError: Reduce of empty array with no initial value\n\n```", "```js\n> ['x', 'a', 'b'].reduce((acc, elem) => acc)\n'x'\n> ['a', 'b'].reduce((acc, elem) => acc, 'x')\n'x'\n\n```", "```js\nconst NOT_FOUND = -1;\nfunction indexOf(arr, searchValue) {\n  return arr.reduce(\n    (result, elem, index) => {\n      if (result !== NOT_FOUND) {\n        // We have already found something: don’t change anything\n        return result;\n      } else if (elem === searchValue) {\n        return index;\n      } else {\n        return NOT_FOUND;\n      }\n    },\n    NOT_FOUND);\n}\nassert.equal(indexOf(['a', 'b', 'c'], 'b'), 1);\nassert.equal(indexOf(['a', 'b', 'c'], 'x'), -1);\n\n```", "```js\nfunction double(inArr) {\n  return inArr.reduce(\n    (outArr, element) => {\n      outArr.push(element * 2);\n      return outArr;\n    },\n    []);\n}\nassert.deepEqual(\n  double([1, 2, 3]),\n  [2, 4, 6]);\n\n```", "```js\nfunction double(inArr) {\n  return inArr.reduce(\n    // Don’t change `outArr`, return a fresh Array\n    (outArr, element) => [...outArr, element * 2],\n    []);\n}\nassert.deepEqual(\n  double([1, 2, 3]),\n  [2, 4, 6]);\n\n```", "```js\n> ['a', 'b', 'c'].reduce((acc, x) => acc + x)\n'abc'\n\n```", "```js\n> ['a', 'b', 'c'].reduceRight((acc, x) => acc + x)\n'cba'\n\n```", "```js\nsort(compareFunc?: (a: T, b: T) => number): this\n\n```", "```js\n> const arr = ['a', 'c', 'b'];\n> arr.sort() === arr\ntrue\n> arr\n[ 'a', 'b', 'c' ]\n\n```", "```js\n> [200, 3, 10].sort()\n[ 10, 200, 3 ]\n\n```", "```js\nfunction compareNumbers(a, b) {\n  if (a < b) {\n    return -1; // any negative number will do\n  } else if (a === b) {\n    return 0;\n  } else {\n    return 1; // any positive number will do\n  }\n}\nassert.deepEqual(\n  [200, 3, 10].sort(compareNumbers),\n  [3, 10, 200]\n);\n\n```", "```js\n> [200, 3, 10].sort((a, z) => a - z)\n[ 3, 10, 200 ]\n\n```", "```js\n> ['pie', 'cookie', 'éclair', 'Pie', 'Cookie', 'Éclair'].sort()\n[ 'Cookie', 'Pie', 'cookie', 'pie', 'Éclair', 'éclair' ]\n\n```", "```js\nconst arr = ['pie', 'cookie', 'éclair', 'Pie', 'Cookie', 'Éclair'];\nassert.deepEqual(\n  arr.sort(new Intl.Collator('en').compare),\n  ['cookie', 'Cookie', 'éclair', 'Éclair', 'pie', 'Pie']\n);\n\n```", "```js\nconst arr = [ {age: 200}, {age: 3}, {age: 10} ];\nassert.deepEqual(\n  arr.sort((obj1, obj2) => obj1.age - obj2.age),\n  [{ age: 3 }, { age: 10 }, { age: 200 }]\n);\n\n```", "```js\nassert.deepEqual(\n  Object.groupBy(\n    [0, -5, 3, -4, 8, 9],\n    x => Math.sign(x)\n  ),\n  {\n    '0': [0],\n    '-1': [-5,-4],\n    '1': [3,8,9],\n    __proto__: null,\n  }\n);\n\n```", "```js\nconst arr = ['a', 'b', 'c'];\nassert.equal(\n  arr.at(-1), 'c'\n);\n\n```", "```js\n    // Trailing commas are always ignored.\n    // Therefore: number of commas = number of holes\n    assert.deepEqual(new Array(3), [,,,]);\n\n    ```", "```js\n    Array.from<T>(\n      iterableOrArrayLike: Iterable<T> | ArrayLike<T>\n    ): Array<T>\n    Array.from<T, U>(\n      iterableOrArrayLike: Iterable<T> | ArrayLike<T>,\n      mapFunc: (v: T, k: number) => U, thisArg?: any\n    ): Array<U>\n\n    ```", "```js\n    > Array.from(new Set(['a', 'b'])) // iterable\n    [ 'a', 'b' ]\n    > Array.from({length: 2, 0:'a', 1:'b'}) // Array-like object\n    [ 'a', 'b' ]\n\n    ```", "```js\n    Array.of<T>(\n      ...items: Array<T>\n    ): Array<T>\n\n    ```", "```js\n    class MyArray extends Array {}\n\n    assert.equal(\n      MyArray.of('a', 'b') instanceof MyArray, true\n    );\n\n    ```", "```js\n    arr[index] === arr.at(index)\n\n    ```", "```js\n    > ['a', 'b', 'c'].at(0)\n    'a'\n    > ['a', 'b', 'c'].at(-1)\n    'c'\n\n    ```", "```js\n    > ['a', 'b', 'c'].with(2, 'x')\n    [ 'a', 'b', 'x' ]\n    > ['a', 'b', 'c'].with(-1, 'x')\n    [ 'a', 'b', 'x' ]\n\n    ```", "```js\n    Array<T>.prototype.forEach(\n      callback: (value: T, index: number, array: Array<T>) => void,\n      thisArg?: any\n    ): void\n\n    ```", "```js\n    ['a', 'b'].forEach(\n      (elem) => console.log(elem)\n    );\n    ['a', 'b'].forEach(\n      (elem, index) => console.log(elem, index)\n    );\n\n    ```", "```js\n    a\n    b\n    a 0\n    b 1\n\n    ```", "```js\n    > Array.from(['a', 'b'].keys())\n    [ 0, 1 ]\n\n    ```", "```js\n    > Array.from(['a', 'b'].values())\n    [ 'a', 'b' ]\n\n    ```", "```js\n    > Array.from(['a', 'b'].entries())\n    [ [ 0, 'a' ], [ 1, 'b' ] ]\n\n    ```", "```js\n    > const arr = ['a', 'b', 'c'];\n    > arr.pop()\n    'c'\n    > arr\n    [ 'a', 'b' ]\n\n    ```", "```js\n    > const arr = ['a', 'b'];\n    > arr.push('c', 'd')\n    4\n    > arr\n    [ 'a', 'b', 'c', 'd' ]\n\n    ```", "```js\n    > const arr = ['x'];\n    > arr.push(...['y', 'z'])\n    3\n    > arr\n    [ 'x', 'y', 'z' ]  \n\n    ```", "```js\n    > const arr = ['a', 'b', 'c'];\n    > arr.shift()\n    'a'\n    > arr\n    [ 'b', 'c' ]\n\n    ```", "```js\n    > const arr = ['c', 'd'];\n    > arr.unshift('e', 'f')\n    4\n    > arr\n    [ 'e', 'f', 'c', 'd' ]\n\n    ```", "```js\n    > const arr = ['c'];\n    > arr.unshift(...['a', 'b'])\n    3\n    > arr\n    [ 'a', 'b', 'c' ]\n\n    ```", "```js\n    > ['a'].concat('b', ['c', 'd'])\n    [ 'a', 'b', 'c', 'd' ]\n\n    ```", "```js\n    > ['a', 'b', 'c', 'd'].slice(1, 3)\n    [ 'b', 'c' ]\n    > ['a', 'b'].slice() // shallow copy\n    [ 'a', 'b' ]\n\n    ```", "```js\n    > ['a', 'b', 'c'].slice(-2)\n    [ 'b', 'c' ]\n\n    ```", "```js\n    const copy = original.slice();\n\n    ```", "```js\n    > const arr = ['a', 'b', 'c', 'd'];\n    > arr.splice(1, 2, 'x', 'y')\n    [ 'b', 'c' ]\n    > arr\n    [ 'a', 'x', 'y', 'd' ]\n\n    ```", "```js\n    > const arr = ['a', 'b', 'c', 'd'];\n    > arr.splice(2)\n    [ 'c', 'd' ]\n    > arr\n    [ 'a', 'b' ]\n\n    ```", "```js\n    > ['a', 'b', 'c'].splice(-2)\n    [ 'b', 'c' ]\n\n    ```", "```js\n    > const arr = ['a', 'b', 'c', 'd'];\n    > arr.toSpliced(1, 2, 'x', 'y')\n    [ 'a', 'x', 'y', 'd' ]\n\n    ```", "```js\n    > ['a', 'b', 'c'].toSpliced(-2)\n    [ 'a' ]\n\n    ```", "```js\n    > [0, 1, 2].fill('a')\n    [ 'a', 'a', 'a' ]\n\n    ```", "```js\n    > ['a', 'b', 'c', 'd'].copyWithin(0, 2, 4)\n    [ 'c', 'd', 'c', 'd' ]\n\n    ```", "```js\n    > [0, 1, 2].includes(1)\n    true\n    > [0, 1, 2].includes(5)\n    false\n\n    ```", "```js\n    > ['a', 'b', 'a'].indexOf('a')\n    0\n    > ['a', 'b', 'a'].indexOf('a', 1)\n    2\n    > ['a', 'b', 'a'].indexOf('c')\n    -1\n\n    ```", "```js\n    > ['a', 'b', 'a'].lastIndexOf('a')\n    2\n    > ['a', 'b', 'a'].lastIndexOf('a', 1)\n    0\n    > ['a', 'b', 'a'].lastIndexOf('c')\n    -1\n\n    ```", "```js\n    Array<T>.prototype.find(\n      predicate: (value: T, index: number, obj: Array<T>) => boolean,\n      thisArg?: any\n    ): T | undefined\n\n    ```", "```js\n    > [-1, 2, -3].find(x => x < 0)\n    -1\n    > [1, 2, 3].find(x => x < 0)\n    undefined\n\n    ```", "```js\n    Array<T>.prototype.findLast(\n      predicate: (value: T, index: number, obj: Array<T>) => boolean,\n      thisArg?: any\n    ): T | undefined\n\n    ```", "```js\n    > [-1, 2, -3].findLast(x => x < 0)\n    -3\n    > [1, 2, 3].findLast(x => x < 0)\n    undefined\n\n    ```", "```js\n    Array<T>.prototype.findIndex(\n      predicate: (value: T, index: number, obj: Array<T>) => boolean,\n      thisArg?: any\n    ): number\n\n    ```", "```js\n    > [-1, 2, -3].findIndex(x => x < 0)\n    0\n    > [1, 2, 3].findIndex(x => x < 0)\n    -1\n\n    ```", "```js\n    Array<T>.prototype.findLastIndex(\n      predicate: (value: T, index: number, obj: Array<T>) => boolean,\n      thisArg?: any\n    ): number\n\n    ```", "```js\n    > [-1, 2, -3].findLastIndex(x => x < 0)\n    2\n    > [1, 2, 3].findLastIndex(x => x < 0)\n    -1\n\n    ```", "```js\n    Array<T>.prototype.filter(\n      predicate: (value: T, index: number, array: Array<T>) => boolean,\n      thisArg?: any\n    ): Array<T>\n\n    ```", "```js\n    > [1, -2, 3].filter(x => x > 0)\n    [ 1, 3 ]\n\n    ```", "```js\n    Array<T>.prototype.map<U>(\n      mapFunc: (value: T, index: number, array: Array<T>) => U,\n      thisArg?: any\n    ): Array<U>\n\n    ```", "```js\n    > [1, 2, 3].map(x => x * 2)\n    [ 2, 4, 6 ]\n    > ['a', 'b', 'c'].map((x, i) => i)\n    [ 0, 1, 2 ]\n\n    ```", "```js\n    Array<T>.prototype.flatMap<U>(\n      callback: (value: T, index: number, array: Array<T>) => U|Array<U>,\n      thisValue?: any\n    ): Array<U>\n\n    ```", "```js\n    > ['a', 'b', 'c'].flatMap(x => [x,x])\n    [ 'a', 'a', 'b', 'b', 'c', 'c' ]\n    > ['a', 'b', 'c'].flatMap(x => [x])\n    [ 'a', 'b', 'c' ]\n    > ['a', 'b', 'c'].flatMap(x => [])\n    []\n\n    ```", "```js\n    > [ 1,2, [3,4], [[5,6]] ].flat(0) // no change\n    [ 1, 2, [3,4], [[5,6]] ]\n\n    > [ 1,2, [3,4], [[5,6]] ].flat(1)\n    [1, 2, 3, 4, [5,6]]\n\n    > [ 1,2, [3,4], [[5,6]] ].flat(2)\n    [1, 2, 3, 4, 5, 6]\n\n    ```", "```js\n    Array<T>.prototype.every(\n      predicate: (value: T, index: number, array: Array<T>) => boolean,\n      thisArg?: any\n    ): boolean\n\n    ```", "```js\n    > [1, 2, 3].every(x => x > 0)\n    true\n    > [1, -2, 3].every(x => x > 0)\n    false\n\n    ```", "```js\n    Array<T>.prototype.some(\n      predicate: (value: T, index: number, array: Array<T>) => boolean,\n      thisArg?: any\n    ): boolean\n\n    ```", "```js\n    > [1, 2, 3].some(x => x < 0)\n    false\n    > [1, -2, 3].some(x => x < 0)\n    true\n\n    ```", "```js\n    Array<T>.prototype.reduce<U>(\n      callback: (accumulator: U, elem: T, idx: number, arr: Array<T>) => U,\n      initialValue?: U\n    ): U\n\n    ```", "```js\n    const accumulator_0 = callback(initialValue, arr[0]);\n    const accumulator_1 = callback(accumulator_0, arr[1]);\n    const accumulator_2 = callback(accumulator_1, arr[2]);\n    // Etc.\n\n    ```", "```js\n    > [1, 2, 3].reduce((accu, x) => accu + x, 0)\n    6\n    > [1, 2, 3].reduce((accu, x) => accu + String(x), '')\n    '123'\n\n    ```", "```js\n    Array<T>.prototype.reduceRight<U>(\n      callback: (accumulator: U, elem: T, idx: number, arr: Array<T>) => U,\n      initialValue?: U\n    ): U\n\n    ```", "```js\n    > [1, 2, 3].reduceRight((accu, x) => accu + String(x), '')\n    '321'\n\n    ```", "```js\n    > ['a', 'b', 'c'].join('##')\n    'a##b##c'\n    > ['a', 'b', 'c'].join()\n    'a,b,c'\n\n    ```", "```js\n    > [1, 2, 3].toString()\n    '1,2,3'\n    > ['1', '2', '3'].toString()\n    '1,2,3'\n    > [].toString()\n    ''\n\n    ```", "```js\n    Array<T>.prototype.sort(\n      compareFunc?: (a: T, b: T) => number\n    ): this\n\n    ```", "```js\n    // Default: lexicographical sorting\n    assert.deepEqual(\n      [200, 3, 10].sort(),\n      [10, 200, 3]\n    );\n\n    // Ascending numerical sorting (“from a to z”)\n    assert.deepEqual(\n      [200, 3, 10].sort((a, z) => a - z),\n      [3, 10, 200]\n    );\n\n    ```", "```js\n    > ['pie', 'cookie', 'éclair', 'Pie', 'Cookie', 'Éclair'].sort()\n    [ 'Cookie', 'Pie', 'cookie', 'pie', 'Éclair', 'éclair' ]\n\n    ```", "```js\n    const arr = ['pie', 'cookie', 'éclair', 'Pie', 'Cookie', 'Éclair'];\n    assert.deepEqual(\n      arr.sort(new Intl.Collator('en').compare),\n      ['cookie', 'Cookie', 'éclair', 'Éclair', 'pie', 'Pie']\n    );\n\n    ```", "```js\n    Array<T>.prototype.toSorted.toSorted(\n      compareFunc?: (a: T, b: T) => number\n    ): Array<T>\n\n    ```", "```js\n    const original = ['y', 'z', 'x'];\n    const sorted = original.toSorted();\n    assert.deepEqual(\n      // The original is unchanged\n      original, ['y', 'z', 'x']\n    );\n    assert.deepEqual(\n      // The copy is sorted\n      sorted, ['x', 'y', 'z']\n    );\n\n    ```", "```js\n    > const arr = ['a', 'b', 'c'];\n    > arr.reverse()\n    [ 'c', 'b', 'a' ]\n    > arr\n    [ 'c', 'b', 'a' ]\n\n    ```", "```js\n    const original = ['x', 'y', 'z'];\n    const reversed = original.toReversed();\n    assert.deepEqual(\n      // The original is unchanged\n      original, ['x', 'y', 'z']\n    );\n    assert.deepEqual(\n      // The copy is reversed\n      reversed, ['z', 'y', 'x']\n    );\n\n    ```"]