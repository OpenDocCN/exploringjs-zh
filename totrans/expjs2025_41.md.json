["```js\n// Creating an Array\nconst arr = ['a', 'b', 'c']; // Array literal\nassert.deepEqual(\n arr,\n [ // Array literal\n 'a',\n 'b',\n 'c', // trailing commas are ignored\n ]\n);\n `// Reading elements`\n`assert.equal(`\n `arr[0], 'a' // negative indices don’t work`\n`);`\n`assert.equal(`\n `arr.at(-1), 'c' // negative indices work`\n`);`\n `` `// Writing an element` `arr[0] = 'x';` `assert.deepEqual(`  `arr, ['x', 'b', 'c']` `);` `` \n```", "```js```", "````js````", "```js```", "````js````", "```js```", "```js```", "````js````", "```js```", "````js````", "```js```", "```js const arr = ['a', 'b', 'c']; assert.equal(  arr.length, 3 // number of elements ); arr.length = 1; // removing elements assert.deepEqual(  arr, ['a'] ); arr[arr.length] = 'b'; // adding an element assert.deepEqual(  arr, ['a', 'b'] );  ```", "```js const arr = ['a', 'b'];  `arr.push('c'); // adding an element` `assert.deepEqual(`  `arr, ['a', 'b', 'c']` `);`  `` `// Pushing Arrays (used as arguments via spreading (...)):` `arr.push(...['d', 'e']);` `assert.deepEqual(`  `arr, ['a', 'b', 'c', 'd', 'e']` `);` ``  ```", "```js```", "````js````", "```js```", "````js````", "```js```", "``````js``````", "```````js```````", "`````` Adding elements non-destructively via spreading (`...`):    ```js const arr1 = ['a', 'b']; const arr2 = ['c']; assert.deepEqual(  [...arr1, ...arr2, 'd', 'e'],  ['a', 'b', 'c', 'd', 'e'] );  ```    Looping over elements:    ```js const arr = ['a', 'b', 'c']; for (const value of arr) {  console.log(value); }  ```    Output:    ```js a b c  ```    Looping over index-value pairs:    ```js const arr = ['a', 'b', 'c']; for (const [index, value] of arr.entries()) {  console.log(index, value); }  ```    Output:    ```js 0 a 1 b 2 c  ```    #### [34.1.2 The most commonly used Array methods](#the-most-commonly-used-array-methods)    This section demonstrates a few common Array methods. There is [a more comprehensive quick reference](#quickref-Array) at the end of this chapter.    Destructively adding or removing an Array element at the start or the end:    ```js // Adding and removing at the start const arr1 = ['■', '●']; arr1.unshift('▲'); assert.deepEqual(  arr1, ['▲', '■', '●'] ); arr1.shift(); assert.deepEqual(  arr1, ['■', '●'] );  `// Adding and removing at the end` `const arr2 = ['■', '●'];` `arr2.push('▲');` `assert.deepEqual(`  `arr2, ['■', '●', '▲']` `);` `arr2.pop();` `assert.deepEqual(`  `arr2, ['■', '●']` `);`  ```   ```js``````", "```````js```````", "```````js` Finding Array elements:    ``` > ['■', '●', '■'].includes('■') true > ['■', '●', '■'].indexOf('■') 0 > ['■', '●', '■'].lastIndexOf('■') 2 > ['●', '', '▲'].find(x => x.length > 0) '●' > ['●', '', '▲'].findLast(x => x.length > 0) '▲' > ['●', '', '▲'].findIndex(x => x.length > 0) 0 > ['●', '', '▲'].findLastIndex(x => x.length > 0) 2  ```js    Transforming Arrays (creating new ones without changing the originals):    ``` > ['▲', '●'].map(x => x+x) ['▲▲', '●●'] > ['■', '●', '■'].filter(x => x === '■')  ['■', '■'] > ['▲', '●'].flatMap(x => [x,x]) ['▲', '▲', '●', '●']  ```js    Copying parts of an Array:    ``` > ['■', '●', '▲'].slice(1, 3) ['●', '▲'] > ['■', '●', '▲'].slice() // complete copy ['■', '●', '▲']  ```js    Concatenating the strings in an Array:    ``` > ['■','●','▲'].join('-') '■-●-▲' > ['■','●','▲'].join('') '■●▲'  ```js    `.sort()` sorts its receiver and returns it (if we don’t want to change the receiver, we can use [`.toSorted()`](#qref-Array.prototype.toSorted)):    ``` // By default, string representations of the Array elements // are sorted lexicographically: const arr = [200, 3, 10]; arr.sort(); assert.deepEqual(  arr, [10, 200, 3] );  `// Sorting can be customized via a callback:` `assert.deepEqual(`  `[200, 3, 10].sort((a, z) => a - z), // sort numerically`  `[3, 10, 200]` `);`  ```js   ``````js```````", "```````js```````", "```` ### [34.2 Ways of using Arrays: fixed layout vs. sequence](#arrays-fixed-layout-vs-sequence)    These are the two most common ways of using Arrays in JavaScript:    *   Fixed-layout Arrays: Used this way, Arrays have a fixed number of indexed elements. Each of those elements can have a different type. *   Sequence Arrays: Used this way, Arrays have a variable number of indexed elements. Each of those elements has the same type. Sequence Arrays are very flexible; we can use them as (traditional) arrays, stacks, and queues. We’ll see how later.    As an example of the difference between the two ways, consider the Array returned by `Object.entries()`:    ```js > Object.entries({ a: 1, b: 2, c: 3 }) [  [ 'a', 1 ],  [ 'b', 2 ],  [ 'c', 3 ], ]  ```    It is a sequence of *pairs* – fixed-layout Arrays with a length of two.    ### [34.3 Basic Array operations](#basic-array-operations)    #### [34.3.1 Creating, reading, writing Arrays](#array-literals)    The best way to create an Array is via an *Array literal*:    ```js const arr = ['a', 'b', 'c'];  ```    The Array literal starts and ends with square brackets `[]`. It creates an Array with three *elements*: `'a'`, `'b'`, and `'c'`.    A comma after the last element is allowed and ignored in an Array literal:    ```js const arr = [  'a',  'b',  'c', ];  ```    To read an Array element, we put an index in square brackets (indices start at zero):    ```js const arr = ['a', 'b', 'c']; assert.equal(arr[0], 'a');  ```    To change an Array element, we assign to an Array with an index:    ```js const arr = ['a', 'b', 'c']; arr[0] = 'x'; assert.deepEqual(arr, ['x', 'b', 'c']);  ```    The range of Array indices is 32 bits (excluding the maximum length): [0, 2^(32)−1)    #### [34.3.2 The `.length` of an Array](#array-length)    Every Array has a property `.length` that can be used to both read and change(!) the number of elements in an Array.    The length of an Array is always the highest index plus one:    ```js const arr = ['a', 'b']; assert.equal(arr.length, 2);  ```    If we write to the Array at the index of the length, we append an element:    ```js arr[arr.length] = 'c'; assert.deepEqual(  arr, ['a', 'b', 'c'] ); assert.equal(arr.length, 3)  ```    If we set `.length`, we prune the Array and remove elements:    ```js arr.length = 1; assert.deepEqual(  arr, ['a'] );  ```    To (destructively) append an element, we can also use the Array method `.push()`:    ```js const arr = ['a', 'b']; arr.push('c'); assert.deepEqual(  arr, ['a', 'b', 'c'] );  ```    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Removing empty lines via `.push()`**    `exercises/arrays/remove_empty_lines_push_test.mjs`    #### [34.3.3 Referring to elements via negative indices](#referring-to-elements-via-negative-indices)    Most Array methods support negative indices. If an index is negative, it is added to the length of an Array to produce a usable index. Therefore, the following two invocations of `.slice()` are equivalent: They both copy `arr` starting at the last element.    ```js > const arr = ['a', 'b', 'c']; > arr.slice(-1) [ 'c' ] > arr.slice(arr.length - 1) [ 'c' ]  ```    ##### [34.3.3.1 `.at()`: reading single elements (supports negative indices) ^(ES2022)](#Array.prototype.at)    The Array method `.at()` returns the element at a given index. It supports positive and negative indices (`-1` refers to the last element, `-2` refers to the second-last element, etc.):    ```js > ['a', 'b', 'c'].at(0) 'a' > ['a', 'b', 'c'].at(-1) 'c'  ```    In contrast, the bracket operator `[]` does not support negative indices (and can’t be changed because that would break existing code). It interprets them as keys of non-element properties:    ```js const arr = ['a', 'b', 'c'];  `arr[-1] = 'non-element property';` `// The Array elements didn’t change:` `assert.deepEqual(`  `Array.from(arr), // copy just the Array elements`  `['a', 'b', 'c']` `);`  `` `assert.equal(`  `arr[-1], 'non-element property'` `);` ``  ```   ```js````", "```js```", "````js````", "```js```", "``` ```", "```````js```````", "```````js````` #### [34.3.4 Clearing Arrays](#clearing-arrays)    We can clear an Array by setting its `.length` to zero:    ```js const arr = ['a', 'b', 'c']; arr.length = 0; assert.deepEqual(arr, []);  ```    We can also assign a new empty Array to the variable storing the Array:    ```js let arr = ['a', 'b', 'c']; arr = []; assert.deepEqual(arr, []);  ```    The latter approach has the advantage of not affecting other locations that point to the same Array. If, however, we do want to reset a shared Array for everyone, then we need the former approach.    #### [34.3.5 Spreading into Array literals](#spreading-into-array-literals)    Inside an Array literal, a *spread element* consists of three dots (`...`) followed by an expression. It results in the expression being evaluated and then iterated over. Each iterated value becomes an additional Array element – for example:    ```js > const iterable = ['b', 'c']; > ['a', ...iterable, 'd'] [ 'a', 'b', 'c', 'd' ]  ```    That means we can convert any iterable to an Array:    ```js const iterable = new Set(['x', 'y']); assert.deepEqual(  [...iterable],  ['x', 'y'] );  ```    Since Arrays are iterable, we can use spreading to copy them:    ```js const arr = ['a', 'b', 'c']; const copy = [...arr];  ```    Spreading is also convenient for concatenating Arrays (and other iterables) into Arrays:    ```js const arr1 = ['a', 'b']; const arr2 = ['c', 'd'];  `const concatenated = [...arr1, ...arr2, 'e'];` `assert.deepEqual(`  `concatenated,`  `['a', 'b', 'c', 'd', 'e']` `);`  ```   ```js```````", "```````js```````", "```` Due to spreading using iteration, it only works if the value is iterable:    ```js > [...'abc'] // strings are iterable [ 'a', 'b', 'c' ] > [...123] TypeError: 123 is not iterable > [...undefined] TypeError: undefined is not iterable  ```    #### [34.3.6 Arrays: listing indices and entries](#arrays-listing-indices-and-entries)    Method `.keys()` lists the indices of an Array:    ```js const arr = ['a', 'b']; arr.prop = true; // needed later  `assert.deepEqual(`  `arr.keys().toArray(), // (A)`  `[0, 1]` `);`  ```   ```js````", "```js```", "````js````", "```js```", "``` assert.deepEqual(  Object.keys(arr),  ['0', '1', 'prop'] );  ```", "``` assert.deepEqual(  arr.entries().toArray(),  [  [0, 'a'],  [1, 'b'],  ] );  ```", "``` assert.deepEqual(  Object.entries(arr),  [  ['0', 'a'],  ['1', 'b'],  ['prop', true],  ] );  ```", "``` > Array.isArray([]) true  ```", "``` > [] instanceof Array true  ```", "``` > typeof [] 'object'  ```", "``` for (const element of ['a', 'b']) {  console.log(element); }  ```", "``` a b  ```", "``` for (const element of ['a', 'b'].keys()) {  console.log(element); }  ```", "``` 0 1  ```", "``` for (const [index, element] of ['a', 'b'].entries()) {  console.log(index, element); }  ```", "``` 0 a 1 b  ```", "``` // .length is implicitly 0 in this case assert.deepEqual(  Array.from({}),  [] );  `assert.deepEqual(`  `Array.from({length: 2, 0: 'a', 1: 'b'}),`  `[ 'a', 'b' ]` `);`  ```", "``````js``````", "```````js`````` The TypeScript interface for Array-like objects is:    ```js interface ArrayLike<T> {  length: number;  [n: number]: T; }  ```    ![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **Array-like objects are relatively rare in modern JavaScript**    Array-like objects used to be more common before ES6; now we don’t see them very often.    ### [34.6 Converting iterables, iterators and Array-like values to Arrays](#converting-to-array)    In this section we explore how we can convert various values to Array:    *   Converting iterables to Arrays via spreading (`...`) *   Converting iterators to Arrays via `.toArray()` *   Converting iterables and Array-like objects to Arrays via `Array.from()`    #### [34.6.1 Converting iterables to Arrays via spreading (`...`)](#converting-iterables-to-arrays-via-spreading-)    Inside an Array literal, spreading via `...` converts any iterable object into a series of Array elements. For example:    ```js const iterable = new Set(['a', 'b']); assert.deepEqual(  [...iterable],  ['a', 'b'] );  ```    #### [34.6.2 Converting iterators to Arrays via `.toArray()` ^(ES2025)](#converting-iterators-to-arrays-via-toarray-es2025)    If we have an iterator, we can use method `.toArray()` to store its values in an Array:    ```js const iterable = new Set(['a', 'b']); assert.deepEqual(  Iterator.from(iterable).toArray(),  ['a', 'b'] );  ```    Instead of `Iterator.from()` we can also use a method that returns an iterator (such as `.keys()`, `.values()` and `.entries()`):    ```js assert.deepEqual(  iterable.values().toArray(),  ['a', 'b'] );  ```    #### [34.6.3 Converting iterables and Array-like objects to Arrays via `Array.from()`](#Array.from)    `Array.from()` can be used in two modes.    ##### [34.6.3.1 Mode 1 of `Array.from()`: converting](#mode-1-of-arrayfrom-converting)    The first mode has the following type signature:    ```js .from<T>(iterable: Iterable<T> | ArrayLike<T>): Array<T>  ```    Interface `Iterable` is shown [in the chapter on synchronous iteration](ch_sync-iteration.html#iterable-iterator-iteratorresult). Interface `ArrayLike` appeared [earlier in this chapter](#array-like-objects).    With a single parameter, `Array.from()` converts anything iterable or Array-like to an Array:    ```js > Array.from(new Set(['a', 'b'])) // iterable [ 'a', 'b' ] > Array.from({length: 2, 0:'a', 1:'b'}) // Array-like [ 'a', 'b' ]  ```    ##### [34.6.3.2 Mode 2 of `Array.from()`: converting and mapping](#mode-2-of-arrayfrom-converting-and-mapping)    The second mode of `Array.from()` involves two parameters:    ```js .from<T, U>(  iterable: Iterable<T> | ArrayLike<T>,  mapFunc: (v: T, i: number) => U,  thisArg?: any ): Array<U>  ```    In this mode, `Array.from()` does several things:    *   It iterates over `iterable`. *   It calls `mapFunc` with each iterated value. The optional parameter `thisArg` specifies a `this` for `mapFunc`. *   It applies `mapFunc` to each iterated value. *   It collects the results in a new Array and returns it.    In other words: we are going from an iterable with elements of type `T` to an Array with elements of type `U`.    This is an example:    ```js > Array.from(new Set(['a', 'b']), x => x + x) [ 'aa', 'bb' ]  ```    ### [34.7 Copying Arrays](#copying-arrays)    The following code shows five ways of copying the Array `arr`:    ```js const arr = ['a', 'b'];  `const shallowCopy1 = arr.slice();` `const shallowCopy2 = Array.from(arr);` `const shallowCopy3 = [...arr];` `const shallowCopy4 = arr.values().toArray();`  ``` `const deepCopy = structuredClone(arr);`  `` `const copies = [`  `shallowCopy1, shallowCopy2, shallowCopy3, shallowCopy4, deepCopy` `];` `for (const copy of copies) {`  `assert.deepEqual(copy, arr);` `}` `` ```js  ```   ```js```````", "```````js```````", "``````js``````", "```````js```` Only `structuredClone()` produces a *deep copy*. In each other case, the copy is *shallow*: It contains copies of the [index, element] entries but the elements themselves are shared with the original Array. For more information, including the limitations of `structuredClone()`, see [“Copying objects: spreading vs. `Object.assign()` vs. `structuredClone()`” (§30.5)](ch_objects.html#copying-objects).    ### [34.8 Creating and filling Arrays with arbitrary lengths](#filling-arrays)    The best way of creating an Array is via an Array literal. However, we can’t always use one: The Array may be too large, we may not know its length during development, or we may want to keep its length flexible. Then I recommend the following techniques for creating, and possibly filling, Arrays.    #### [34.8.1 Creating an Array and adding elements later](#creating-array-adding-elements-later)    The most common technique for creating an Array and adding elements later, is to start with an empty Array and push values into it:    ```js const arr = []; for (let i=0; i<3; i++) {  arr.push('*'.repeat(i)); } assert.deepEqual(  arr, ['', '*', '**'] );  ```    #### [34.8.2 Creating an Array filled with a primitive value](#creating-array-with-primitives)    The following code creates an Array that is filled with a primitive value:    ```js > new Array(3).fill(0) [ 0, 0, 0 ]  ```    `.fill()` replaces each Array element or hole with a given value. We use it to fill an Array that has 3 holes:    ```js > new Array(3) [ , , ,]  ```    Note that the result has [three *holes* (empty slots)](#array-holes) – the last comma in an Array literal is always ignored.    #### [34.8.3 Creating an Array filled with objects](#creating-array-with-objects)    If we use `.fill()` with an object, then each Array element will refer to this same single object:    ```js const arr = new Array(3).fill({}); arr[0].prop = true; assert.deepEqual(  arr, [  {prop: true},  {prop: true},  {prop: true},  ]);  ```    How can we fix this? We can use [`Array.from()`](#Array.from):    ```js > Array.from(new Array(3), () => ({})) [{}, {}, {}]  ```    Calling `Array.from()` with two arguments:    *   extracts the elements of the first argument (which must be iterable or Array-like), *   maps them via the callback in the second argument and *   returns the result in an Array.    In contrast to `.fill()`, which reuses the same object multiple times, the previous code creates a new object for each element.    Could we have used `.map()` in this case? Unfortunately not because `.map()` ignores but preserves holes (whereas `Array.from()` treats them as `undefined` elements):    ```js > new Array(3).map(() => ({})) [ , , ,]  ```    For large sizes, the temporary Array in the first argument can consume quite a bit of memory. The following approach doesn’t have this downside but is less self-descriptive:    ```js > Array.from({length: 3}, () => ({})) [{}, {}, {}]  ```    Instead of a temporary Array, we are using a temporary [Array-like object](#array-like-objects).    #### [34.8.4 Creating an Array with a range of integers](#creating-array-with-range-of-integers)    To create an Array with a range of integers, we use `Array.from()` similarly to how we did in the previous subsection:    ```js function createRange(start, end) {  return Array.from({length: end-start}, (_, i) => i+start); } assert.deepEqual(  createRange(2, 5),  [2, 3, 4]);  ```    Here is an alternative, slightly hacky technique for creating integer ranges that start at zero:    ```js /** Returns an iterable */ function createRange(end) {  return new Array(end).keys(); } assert.deepEqual(  Array.from(createRange(4)),  [0, 1, 2, 3] );  ```    This works because `.keys()` treats [*holes*](#array-holes) like `undefined` elements and lists their indices.    #### [34.8.5 Typed Arrays work well if the elements are all integers or all floats](#typed-arrays-work-well-if-the-elements-are-all-integers-or-all-floats)    When dealing with Arrays of integers or floats, we should consider [*Typed Arrays*](ch_typed-arrays.html#ch_typed-arrays), which were created for this purpose.    ### [34.9 Multidimensional Arrays](#multidimensional-arrays)    JavaScript does not have real multidimensional Arrays; we need to resort to Arrays whose elements are Arrays:    ```js function initMultiArray(...dimensions) {  function initMultiArrayRec(dimIndex) {  if (dimIndex >= dimensions.length) {  return 0;  } else {  const dim = dimensions[dimIndex];  const arr = [];  for (let i=0; i<dim; i++) {  arr.push(initMultiArrayRec(dimIndex+1));  }  return arr;  }  }  return initMultiArrayRec(0); }  `const arr = initMultiArray(4, 3, 2);` `arr[3][2][1] = 'X'; // last in each dimension` `assert.deepEqual(arr, [`  `[ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ],`  `[ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ],`  `[ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ],`  `[ [ 0, 0 ], [ 0, 0 ], [ 0, 'X' ] ],` `]);`  ```   ```js```````", "```````js`````` ### [34.10 Arrays are actually dictionaries (advanced)](#arrays-are-dictionaries)    In this section, we examine how exactly Arrays store their elements: in properties. We usually don’t need to know that but it helps with understanding a few rarer Array phenomena.    #### [34.10.1 Array indices are (slightly special) property keys](#array-indices)    You’d think that Array elements are special because we are accessing them via numbers. But the square brackets operator `[]` for doing so is the same operator that is used for accessing properties. It coerces any non-symbol value to a string. Therefore, Array elements are (almost) normal properties (line A) and it doesn’t matter if we use numbers or strings as indices (line B and line C):    ```js const arr = ['a', 'b']; arr.prop = 123; assert.deepEqual(  Object.keys(arr),  ['0', '1', 'prop'] // (A) );  `assert.equal(arr[0], 'a');  // (B)` `assert.equal(arr['0'], 'a'); // (C)`  ```   ```js```````", "```````js````` Property keys (strings!) that are used for Array elements are called [*indices*](https://tc39.es/ecma262/#integer-index). A string `str` is an index if converting it to a 32-bit unsigned integer and back results in the original value. Written as a formula:    ```js ToString(ToUint32(str)) === str  ```    ##### [34.10.1.1 Internally, JavaScript engines optimize how Arrays are managed](#internally-javascript-engines-optimize-how-arrays-are-managed)    When using JavaScript and in the ECMAScript specification, Array elements are properties and Array indices are string-valued property keys.    However, internally, virtually all JavaScript engines optimize how Arrays are managed: They store their elements sequentially and used indices as numeric offsets. Engines may switch to a more dictionary-like representation if the elements of an Array are not contiguous – if there are holes between them. More on holes in Arrays soon.    ##### [34.10.1.2 Listing indices](#listing-indices)    When listing property keys, [indices are treated specially](ch_objects.html#order-of-properties) – they always come first and are sorted like numbers (`'2'` comes before `'10'`):    ```js const arr = []; arr.prop = true; arr[1] = 'b'; arr[0] = 'a';  `assert.deepEqual(`  `Object.keys(arr),`  `['0', '1', 'prop']` `);` `assert.deepEqual(`  `Object.entries(arr),`  `[['0', 'a'], ['1', 'b'], ['prop', true]]` `);`  ```   ```js```````", "```````js```` Note that `.keys()` and `.entries()` treat Array indices as numbers and ignore non-index properties:    ```js assert.deepEqual(  Array.from(arr.keys()),  [0, 1] ); assert.deepEqual(  Array.from(arr.entries()),  [[0, 'a'], [1, 'b']] );  ```    We used [`Array.from()`](#Array.from) to convert the iterables returned by `.keys()` and `.entries()` to Arrays.    #### [34.10.2 Arrays can have holes](#array-holes)    We distinguish two kinds of Arrays in JavaScript:    *   An Array `arr` is *dense* if all indices `i`, with 0 ≤ `i` < `arr.length`, exist. That is, the indices form a contiguous range. *   An Array is *sparse* if the range of indices has *holes* in it. That is, some indices are missing.    Arrays can be sparse in JavaScript because Arrays are actually dictionaries from indices to values.    ![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Recommendation: avoid holes**    So far, we have only seen dense Arrays and it’s indeed recommended to avoid holes: They make our code more complicated and are not handled consistently by Array methods. Additionally, JavaScript engines optimize dense Arrays, making them faster.    ##### [34.10.2.1 Creating Array holes](#creating-array-holes)    We can create holes by skipping indices when assigning elements:    ```js const arr = []; arr[0] = 'a'; arr[2] = 'c';  `assert.deepEqual(Object.keys(arr), ['0', '2']); // (A)`  `` `assert.equal(0 in arr, true); // element` `assert.equal(1 in arr, false); // hole` ``  ```   ```js```````", "```````js``` ``````js```````", "`````` In line A, we are using `Object.keys()` because `arr.keys()` treats holes as if they were `undefined` elements and does not reveal them.    Another way of creating holes is to skip elements in Array literals:    ```js const arr = ['a', , 'c'];  `assert.deepEqual(Object.keys(arr), ['0', '2']);`  ```   ```js``````", "```````js` We can also add holes at the end by increasing `.length`:    ``` const arr = ['a']; assert.deepEqual(Object.keys(arr), ['0']); assert.equal(arr.length, 1); arr.length = 3; arr.push('x'); assert.deepEqual(Object.keys(arr), ['0', '3']); assert.deepEqual(arr, ['a', /*hole*/, /*hole*/, 'x']);  ```js    Deleting Array elements creates holes, too:    ``` const arr = ['a', 'b', 'c']; assert.deepEqual(Object.keys(arr), ['0', '1', '2']); delete arr[1]; assert.deepEqual(Object.keys(arr), ['0', '2']); assert.deepEqual(arr, ['a', , 'c']);  ```js    ##### [34.10.2.2 How do Array operations treat holes?](#how-do-array-operations-treat-holes)    Alas, there are many different ways in which Array operations treat holes.    Some Array operations remove holes:    ``` > ['a',,'b'].filter(x => true) [ 'a', 'b' ]  ```js    Some Array operations ignore holes:    ``` > ['a', ,'a'].every(x => x === 'a') true  ```js    Some Array operations ignore but preserve holes:    ``` > ['a',,'b'].map(x => 'c') [ 'c', , 'c' ]  ```js    Some Array operations treat holes as `undefined` elements:    ``` > Array.from(['a',,'b']) [ 'a', undefined, 'b' ] > Array.from(['a',,'b'], x => x + '!') // mapping [ 'a!', 'undefined!', 'b!' ] > ['a',,'b'].entries().toArray() [[0, 'a'], [1, undefined], [2, 'b']]  ```js    `Object.keys()` works differently than `.keys()` (strings vs. numbers, holes don’t have keys):    ``` > ['a',,'b'].keys().toArray() [ 0, 1, 2 ] > Object.keys(['a',,'b']) [ '0', '2' ]  ```js    There is no common rule to remember here. If it ever matters how an Array operation treats holes, the best approach is to do a quick test in a console.    ### [34.11 Destructive vs. non-destructive Array operations](#array-operations-destructive-vs-non-destructive)    Some Array operations are *destructive*: They change the Array they operate on – e.g., setting an element:    ``` const arr = ['a', 'b', 'c'];  `arr[1] = 'x';` `assert.deepEqual(`  `// The original was modified`  `arr, ['a', 'x', 'c']` `);`  ```js   ``````js```````", "```` Other Array operations are *non-destructive*: They produce new Arrays that contain the desired changes and don’t touch the originals – e.g., method `.with()` is the non-destructive version of setting elements:    ```js const arr = ['a', 'b', 'c'];  `assert.deepEqual(`  `// Produces a copy with changes`  `arr.with(1, 'x'),`  `['a', 'x', 'c']` `);` `assert.deepEqual(`  `// The original is unchanged`  `arr, [ 'a', 'b', 'c' ]` `);`  ```   ```js````", "```js```", "``` #### [34.11.1 How to make destructive Array methods non-destructive](#how-to-make-destructive-array-methods-nondestructive)    These are three common destructive Array methods:    *   `.reverse()` *   `.sort()` *   `.splice()`    We’ll get to [`.sort()`](#Array.prototype.sort) and [`.splice()`](#qref-Array.prototype.splice) later in this chapter. `.reverse()` rearranges an Array so that the order of its elements is reversed: The element that was previously last now comes first; the second-last element comes second; etc.:    ```", "```   ```", "```````js````` To prevent a destructive method from changing an Array, we can make a copy before using it – e.g.:    ```js const original = ['a', 'b', 'c'];  `const reversed1 = original.slice().reverse();` `const reversed2 = Array.from(original).reverse();` `const reversed3 = [...original].reverse();` `const reversed4 = original.values().toArray().reverse();`  `` `assert.deepEqual(original, ['a', 'b', 'c']);` ``  ```   ```js```````", "```` ```js````", "```js```", "``` const original = ['a', 'b', 'c']; const reversed = original.toReversed();  `assert.deepEqual(reversed, ['c', 'b', 'a']);` `// The original is unchanged` `assert.deepEqual(original, ['a', 'b', 'c']);`  ```", "``````js``````", "```js const arr1 = ['a', 'b']; arr1.push('x', 'y'); // append single elements assert.deepEqual(arr1, ['a', 'b', 'x', 'y']);  `const arr2 = ['a', 'b'];` `arr2.push(...['x', 'y']); // (A) append Array` `assert.deepEqual(arr2, ['a', 'b', 'x', 'y']);`  ```", "```js```", "````js` [Spread arguments (`...`)](ch_callables.html#spread-arguments) are a feature of function calls. In line A, we used it to push an Array.    `.pop()` is the inverse of `.push()` and removes elements at the end of an Array:    ``` const arr2 = ['a', 'b', 'c']; assert.equal(arr2.pop(), 'c'); assert.deepEqual(arr2, ['a', 'b']);  ```js    `.shift()` removes elements at the beginning of an Array:    ``` const arr1 = ['a', 'b', 'c']; assert.equal(arr1.shift(), 'a'); assert.deepEqual(arr1, ['b', 'c']);  ```js    `.unshift()` is the inverse of `.shift()` and adds element at the beginning of an Array:    ``` const arr1 = ['a', 'b']; arr1.unshift('x', 'y'); // prepend single elements assert.deepEqual(arr1, ['x', 'y', 'a', 'b']);  `const arr2 = ['a', 'b'];` `arr2.unshift(...['x', 'y']); // prepend Array` `assert.deepEqual(arr2, ['x', 'y', 'a', 'b']);`  ```js   ````", "```` ![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Tip: remembering the functionality of `push`, `pop`, `shift` and `unshift`**    My recommendation is to focus on remembering the following two methods:    *   `.push()` is the most frequently used of the four methods. One common use case is to assemble an output Array: We first push the element at index 0; then the element at index 1; etc. *   `.shift()` can be used to consume the elements of an Array: The first time we shift, we get the element at index 0; then the element at index 1; etc.    The remaining two methods, `pop` and `unshift`, are inverses of these two methods.    ![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise: Implementing a queue via an Array**    `exercises/arrays/queue_via_array_test.mjs`    #### [34.12.2 Non-destructively prepending and appending elements](#nondestructively-prepending-and-appending-elements)    [Spread elements (`...`)](#spreading-into-array-literals) are a feature of Array literals. In this section, we’ll use it to non-destructively prepend and append elements to Arrays.    Non-destructive prepending:    ```js const arr1 = ['a', 'b']; assert.deepEqual(  ['x', 'y', ...arr1], // prepend single elements  ['x', 'y', 'a', 'b']); assert.deepEqual(arr1, ['a', 'b']); // unchanged!  `const arr2 = ['a', 'b'];` `assert.deepEqual(`  `[...['x', 'y'], ...arr2], // prepend Array`  `['x', 'y', 'a', 'b']);` `assert.deepEqual(arr2, ['a', 'b']); // unchanged!`  ```   ```js````", "```js const arr1 = ['a', 'b']; assert.deepEqual(  [...arr1, 'x', 'y'], // append single elements  ['a', 'b', 'x', 'y']); assert.deepEqual(arr1, ['a', 'b']); // unchanged!  `const arr2 = ['a', 'b'];` `assert.deepEqual(`  `[...arr2, ...['x', 'y']], // append Array`  `['a', 'b', 'x', 'y']);` `assert.deepEqual(arr2, ['a', 'b']); // unchanged!`  ```", "```js```", "```js callback: (value: T, index: number, array: Array<T>) => boolean  ```", "```js     > ['a', 'b', 'c'].map(x => x + x)     [ 'aa', 'bb', 'cc' ]          ```", "```js     > ['a', 'bb', 'ccc'].find(str => str.length >= 2)     'bb'          ```", "```js > [1, 2, 3].map(x => x * 3) [ 3, 6, 9 ] > ['how', 'are', 'you'].map(str => str.toUpperCase()) [ 'HOW', 'ARE', 'YOU' ] > [true, true, true].map((_x, index) => index) [ 0, 1, 2 ]  ```", "```js function map(arr, mapFunc) {  const result = [];  for (const [i, x] of arr.entries()) {  result.push(mapFunc(x, i, arr));  }  return result; }  ```", "```js > [-1, 2, 5, -7, 6].filter(x => x >= 0) [ 2, 5, 6 ] > ['a', 'b', 'c', 'd'].filter((_x,i) => (i%2)===0) [ 'a', 'c' ]  ```", "```js function filter(arr, filterFunc) {  const result = [];  for (const [i, x] of arr.entries()) {  if (filterFunc(x, i, arr)) {  result.push(x);  }  }  return result; }  ```", "```js .flatMap<U>(  callback: (value: T, index: number, array: Array<T>) => U|Array<U>,  thisValue?: any ): Array<U>  ```", "```js > ['a', 'b', 'c'].flatMap(x => [x,x]) [ 'a', 'a', 'b', 'b', 'c', 'c' ] > ['a', 'b', 'c'].flatMap(x => [x]) [ 'a', 'b', 'c' ] > ['a', 'b', 'c'].flatMap(x => []) []  ```", "```js const result = [  { status: 'fulfilled', value: 'sunshine.jpg' },  { status: 'rejected', reason: 'FILE NOT FOUND' },  { status: 'fulfilled', value: 'dog.jpg' },  { status: 'rejected', reason: 'NOT AUTHORIZED' }, ];  ```", "```js const values = result.flatMap(  r => r.status === 'fulfilled' ? [r.value] : [] ); assert.deepEqual(  values, ['sunshine.jpg', 'dog.jpg'] );  const reasons = result.flatMap(  r => r.status === 'rejected' ? [r.reason] : [] ); assert.deepEqual(  reasons, ['FILE NOT FOUND', 'NOT AUTHORIZED'] );  ```", "```js > stringsToCodePoints(['many', 'a', 'moon']) ['m', 'a', 'n', 'y', 'a', 'm', 'o', 'o', 'n']  ```", "```js function stringsToCodePoints(strs) {  return strs.flatMap(str => Array.from(str)); }  ```", "```js function flatMap(arr, mapFunc) {  const result = [];  for (const [index, elem] of arr.entries()) {  const x = mapFunc(elem, index, arr);  // We allow mapFunc() to return non-Arrays  if (Array.isArray(x)) {  result.push(...x);  } else {  result.push(x);  }  }  return result; }  ```", "```js .reduce<U>(  callback: (accumulator: U, elem: T, idx: number, arr: Array<T>) => U,  init?: U ): U  ```", "```js const accumulator_0 = callback(init, arr[0]); const accumulator_1 = callback(accumulator_0, arr[1]); const accumulator_2 = callback(accumulator_1, arr[2]); // Etc.  ```", "```js function addAll(arr) {  return arr.reduce(  (sum, element) => sum + element,  0 // `init` value  ); } assert.equal(addAll([1,  2, 3]), 6); // (A) assert.equal(addAll([7, -4, 2]), 5);  ```", "```js callback(0, 1) --> 1 callback(1, 2) --> 3 callback(3, 3) --> 6  ```", "```js function addAll(arr) {  let sum = 0;  for (const element of arr) {  sum = sum + element;  }  return sum; }  ```", "```js > [1, 2].reduce((acc, elem) => acc + elem, 100) 103 > [1].reduce((acc, elem) => acc + elem, 100) 101 > [].reduce((acc, elem) => acc + elem, 100) 100  ```", "```js > [1, 2].reduce((acc, elem) => acc + elem) 3 > [1].reduce((acc, elem) => acc + elem) 1 > [].reduce((acc, elem) => acc + elem) TypeError: Reduce of empty array with no initial value  ```", "```js > ['x', 'a', 'b'].reduce((acc, elem) => acc) 'x' > ['a', 'b'].reduce((acc, elem) => acc, 'x') 'x'  ```", "```js const NOT_FOUND = -1; function indexOf(arr, searchValue) {  return arr.reduce(  (result, elem, index) => {  if (result !== NOT_FOUND) {  // We have already found something: don’t change anything  return result;  } else if (elem === searchValue) {  return index;  } else {  return NOT_FOUND;  }  },  NOT_FOUND); } assert.equal(indexOf(['a', 'b', 'c'], 'b'), 1); assert.equal(indexOf(['a', 'b', 'c'], 'x'), -1);  ```", "```js function double(inArr) {  return inArr.reduce(  (outArr, element) => {  outArr.push(element * 2);  return outArr;  },  []); } assert.deepEqual(  double([1, 2, 3]),  [2, 4, 6]);  ```", "```js function double(inArr) {  return inArr.reduce(  // Don’t change `outArr`, return a fresh Array  (outArr, element) => [...outArr, element * 2],  []); } assert.deepEqual(  double([1, 2, 3]),  [2, 4, 6]);  ```", "```js > ['a', 'b', 'c'].reduce((acc, x) => acc + x) 'abc'  ```", "```js > ['a', 'b', 'c'].reduceRight((acc, x) => acc + x) 'cba'  ```", "```js sort(compareFunc?: (a: T, b: T) => number): this  ```", "```js > const arr = ['a', 'c', 'b']; > arr.sort() === arr true > arr [ 'a', 'b', 'c' ]  ```", "```js > [200, 3, 10].sort() [ 10, 200, 3 ]  ```", "```js function compareNumbers(a, b) {  if (a < b) {  return -1; // any negative number will do  } else if (a === b) {  return 0;  } else {  return 1; // any positive number will do  } } assert.deepEqual(  [200, 3, 10].sort(compareNumbers),  [3, 10, 200] );  ```", "```js > [200, 3, 10].sort((a, z) => a - z) [ 3, 10, 200 ]  ```", "```js > ['pie', 'cookie', 'éclair', 'Pie', 'Cookie', 'Éclair'].sort() [ 'Cookie', 'Pie', 'cookie', 'pie', 'Éclair', 'éclair' ]  ```", "```js const arr = ['pie', 'cookie', 'éclair', 'Pie', 'Cookie', 'Éclair']; assert.deepEqual(  arr.sort(new Intl.Collator('en').compare),  ['cookie', 'Cookie', 'éclair', 'Éclair', 'pie', 'Pie'] );  ```", "```js const arr = [ {age: 200}, {age: 3}, {age: 10} ]; assert.deepEqual(  arr.sort((obj1, obj2) => obj1.age - obj2.age),  [{ age: 3 }, { age: 10 }, { age: 200 }] );  ```", "```js assert.deepEqual(  Object.groupBy(  [0, -5, 3, -4, 8, 9],  x => Math.sign(x)  ),  {  '0': [0],  '-1': [-5,-4],  '1': [3,8,9],  __proto__: null,  } );  ```", "```js const arr = ['a', 'b', 'c']; assert.equal(  arr.at(-1), 'c' );  ```", "```js     // Trailing commas are always ignored.     // Therefore: number of commas = number of holes     assert.deepEqual(new Array(3), [,,,]);          ```", "```js     Array.from<T>(      iterableOrArrayLike: Iterable<T> | ArrayLike<T>     ): Array<T>     Array.from<T, U>(      iterableOrArrayLike: Iterable<T> | ArrayLike<T>,      mapFunc: (v: T, k: number) => U, thisArg?: any     ): Array<U>          ```", "```js     > Array.from(new Set(['a', 'b'])) // iterable     [ 'a', 'b' ]     > Array.from({length: 2, 0:'a', 1:'b'}) // Array-like object     [ 'a', 'b' ]          ```", "```js     Array.of<T>(      ...items: Array<T>     ): Array<T>          ```", "```js     class MyArray extends Array {}      `assert.equal(`      `MyArray.of('a', 'b') instanceof MyArray, true`     `);`      ```", "```js```", "```js     arr[index] === arr.at(index)          ```", "```js     > ['a', 'b', 'c'].at(0)     'a'     > ['a', 'b', 'c'].at(-1)     'c'          ```", "```js     > ['a', 'b', 'c'].with(2, 'x')     [ 'a', 'b', 'x' ]     > ['a', 'b', 'c'].with(-1, 'x')     [ 'a', 'b', 'x' ]          ```", "```js     Array<T>.prototype.forEach(      callback: (value: T, index: number, array: Array<T>) => void,      thisArg?: any     ): void          ```", "```js     ['a', 'b'].forEach(      (elem) => console.log(elem)     );     ['a', 'b'].forEach(      (elem, index) => console.log(elem, index)     );          ```", "```js     a     b     a 0     b 1          ```", "```js     > Array.from(['a', 'b'].keys())     [ 0, 1 ]          ```", "```js     > Array.from(['a', 'b'].values())     [ 'a', 'b' ]          ```", "```js     > Array.from(['a', 'b'].entries())     [ [ 0, 'a' ], [ 1, 'b' ] ]          ```", "```js     > const arr = ['a', 'b', 'c'];     > arr.pop()     'c'     > arr     [ 'a', 'b' ]          ```", "```js     > const arr = ['a', 'b'];     > arr.push('c', 'd')     4     > arr     [ 'a', 'b', 'c', 'd' ]          ```", "```js     > const arr = ['x'];     > arr.push(...['y', 'z'])     3     > arr     [ 'x', 'y', 'z' ]           ```", "```js     > const arr = ['a', 'b', 'c'];     > arr.shift()     'a'     > arr     [ 'b', 'c' ]          ```", "```js     > const arr = ['c', 'd'];     > arr.unshift('e', 'f')     4     > arr     [ 'e', 'f', 'c', 'd' ]          ```", "```js     > const arr = ['c'];     > arr.unshift(...['a', 'b'])     3     > arr     [ 'a', 'b', 'c' ]          ```", "```js     > ['a'].concat('b', ['c', 'd'])     [ 'a', 'b', 'c', 'd' ]          ```", "```js     > ['a', 'b', 'c', 'd'].slice(1, 3)     [ 'b', 'c' ]     > ['a', 'b'].slice() // shallow copy     [ 'a', 'b' ]          ```", "```js     > ['a', 'b', 'c'].slice(-2)     [ 'b', 'c' ]          ```", "```js     const copy = original.slice();          ```", "```js     > const arr = ['a', 'b', 'c', 'd'];     > arr.splice(1, 2, 'x', 'y')     [ 'b', 'c' ]     > arr     [ 'a', 'x', 'y', 'd' ]          ```", "```js     > const arr = ['a', 'b', 'c', 'd'];     > arr.splice(2)     [ 'c', 'd' ]     > arr     [ 'a', 'b' ]          ```", "```js     > ['a', 'b', 'c'].splice(-2)     [ 'b', 'c' ]          ```", "```js     > const arr = ['a', 'b', 'c', 'd'];     > arr.toSpliced(1, 2, 'x', 'y')     [ 'a', 'x', 'y', 'd' ]          ```", "```js     > ['a', 'b', 'c'].toSpliced(-2)     [ 'a' ]          ```", "```js     > [0, 1, 2].fill('a')     [ 'a', 'a', 'a' ]          ```", "```js     > ['a', 'b', 'c', 'd'].copyWithin(0, 2, 4)     [ 'c', 'd', 'c', 'd' ]          ```", "```js     > [0, 1, 2].includes(1)     true     > [0, 1, 2].includes(5)     false          ```", "```js     > ['a', 'b', 'a'].indexOf('a')     0     > ['a', 'b', 'a'].indexOf('a', 1)     2     > ['a', 'b', 'a'].indexOf('c')     -1          ```", "```js     > ['a', 'b', 'a'].lastIndexOf('a')     2     > ['a', 'b', 'a'].lastIndexOf('a', 1)     0     > ['a', 'b', 'a'].lastIndexOf('c')     -1          ```", "```js     Array<T>.prototype.find(      predicate: (value: T, index: number, obj: Array<T>) => boolean,      thisArg?: any     ): T | undefined          ```", "```js     > [-1, 2, -3].find(x => x < 0)     -1     > [1, 2, 3].find(x => x < 0)     undefined          ```", "```js     Array<T>.prototype.findLast(      predicate: (value: T, index: number, obj: Array<T>) => boolean,      thisArg?: any     ): T | undefined          ```", "```js     > [-1, 2, -3].findLast(x => x < 0)     -3     > [1, 2, 3].findLast(x => x < 0)     undefined          ```", "```js     Array<T>.prototype.findIndex(      predicate: (value: T, index: number, obj: Array<T>) => boolean,      thisArg?: any     ): number          ```", "```js     > [-1, 2, -3].findIndex(x => x < 0)     0     > [1, 2, 3].findIndex(x => x < 0)     -1          ```", "```js     Array<T>.prototype.findLastIndex(      predicate: (value: T, index: number, obj: Array<T>) => boolean,      thisArg?: any     ): number          ```", "```js     > [-1, 2, -3].findLastIndex(x => x < 0)     2     > [1, 2, 3].findLastIndex(x => x < 0)     -1          ```", "```js     Array<T>.prototype.filter(      predicate: (value: T, index: number, array: Array<T>) => boolean,      thisArg?: any     ): Array<T>          ```", "```js     > [1, -2, 3].filter(x => x > 0)     [ 1, 3 ]          ```", "```js     Array<T>.prototype.map<U>(      mapFunc: (value: T, index: number, array: Array<T>) => U,      thisArg?: any     ): Array<U>          ```", "```js     > [1, 2, 3].map(x => x * 2)     [ 2, 4, 6 ]     > ['a', 'b', 'c'].map((x, i) => i)     [ 0, 1, 2 ]          ```", "```js     Array<T>.prototype.flatMap<U>(      callback: (value: T, index: number, array: Array<T>) => U|Array<U>,      thisValue?: any     ): Array<U>          ```", "```js     > ['a', 'b', 'c'].flatMap(x => [x,x])     [ 'a', 'a', 'b', 'b', 'c', 'c' ]     > ['a', 'b', 'c'].flatMap(x => [x])     [ 'a', 'b', 'c' ]     > ['a', 'b', 'c'].flatMap(x => [])     []          ```", "```js     > [ 1,2, [3,4], [[5,6]] ].flat(0) // no change     [ 1, 2, [3,4], [[5,6]] ]      `> [ 1,2, [3,4], [[5,6]] ].flat(1)`     `[1, 2, 3, 4, [5,6]]`      `` `> [ 1,2, [3,4], [[5,6]] ].flat(2)` `[1, 2, 3, 4, 5, 6]` ``      ```", "```js```", "````` #### [34.18.9 `Array.prototype.*`: computing summaries](#arrayprototype-computing-summaries)    *   `Array.prototype.every(predicate, thisArg?)`     ES5 | Non-mutating                    ```js     Array<T>.prototype.every(      predicate: (value: T, index: number, array: Array<T>) => boolean,      thisArg?: any     ): boolean          ```                    Returns `true` if `predicate` returns a truthy value for every element. Otherwise, it returns `false`:                    ```js     > [1, 2, 3].every(x => x > 0)     true     > [1, -2, 3].every(x => x > 0)     false          ```               *   Stops traversing an Array if the predicate returns a falsy value (because then the result is guaranteed to be `false`).     *   Corresponds to universal quantification (“for all”, ∀) in mathematics.     *   Related method: [`.some()`](#qref-Array.prototype.some) (“exists”). *   `Array.prototype.some(predicate, thisArg?)`     ES5 | Non-mutating                    ```js     Array<T>.prototype.some(      predicate: (value: T, index: number, array: Array<T>) => boolean,      thisArg?: any     ): boolean          ```                    Returns `true` if `predicate` returns a truthy value for at least one element. Otherwise, it returns `false`.                    ```js     > [1, 2, 3].some(x => x < 0)     false     > [1, -2, 3].some(x => x < 0)     true          ```               *   Stops traversing an Array if the predicate returns a truthy value (because then the result is guaranteed to be `true`).     *   Corresponds to existential quantification (“exists”, ∃) in mathematics.     *   Related method: [`.every()`](#qref-Array.prototype.every) (“for all”). *   `Array.prototype.reduce(callback, initialValue?)`     ES5 | Non-mutating                    ```js     Array<T>.prototype.reduce<U>(      callback: (accumulator: U, elem: T, idx: number, arr: Array<T>) => U,      initialValue?: U     ): U          ```                    This method produces a summary of the receiver: it feeds all Array elements to `callback`, which combines a current summary (in parameter `accumulator`) with the current Array element and returns the next `accumulator`:                    ```js     const accumulator_0 = callback(initialValue, arr[0]);     const accumulator_1 = callback(accumulator_0, arr[1]);     const accumulator_2 = callback(accumulator_1, arr[2]);     // Etc.          ```                    The result of `.reduce()` is the last result of `callback` after it has visited all Array elements.                    ```js     > [1, 2, 3].reduce((accu, x) => accu + x, 0)     6     > [1, 2, 3].reduce((accu, x) => accu + String(x), '')     '123'          ```                    If no `initialValue` is provided, the Array element at index 0 is used and the element at index 1 is visited first. Therefore, the Array must have at least length 1.           *   `Array.prototype.reduceRight(callback, initialValue?)`     ES5 | Non-mutating                    ```js     Array<T>.prototype.reduceRight<U>(      callback: (accumulator: U, elem: T, idx: number, arr: Array<T>) => U,      initialValue?: U     ): U          ```                    Works like `.reduce()`, but visits the Array elements backward, starting with the last element.                    ```js     > [1, 2, 3].reduceRight((accu, x) => accu + String(x), '')     '321'          ```              #### [34.18.10 `Array.prototype.*`: converting to string](#arrayprototype-converting-to-string)    *   `Array.prototype.join(separator = ',')`     ES1 | Non-mutating                    Creates a string by concatenating string representations of all elements, separating them with `separator`.                    ```js     > ['a', 'b', 'c'].join('##')     'a##b##c'     > ['a', 'b', 'c'].join()     'a,b,c'          ```           *   `Array.prototype.toString()`     ES1 | Non-mutating                    Converts all elements to strings via `String()`, concatenates them while separating them with commas, and returns the result.                    ```js     > [1, 2, 3].toString()     '1,2,3'     > ['1', '2', '3'].toString()     '1,2,3'     > [].toString()     ''          ```           *   `Array.prototype.toLocaleString()`     ES3 | Non-mutating                    Works like [`.toString()`](#qref-Array.prototype.toString) but converts its elements to strings via `.toLocaleString()` (not via `.toString()`) before separating them via commas and concatenating them to a single string – that it returns.              #### [34.18.11 `Array.prototype.*`: sorting and reversing](#arrayprototype-sorting-and-reversing)    *   `Array.prototype.sort(compareFunc?)`     ES1 | Mutating                    ```js     Array<T>.prototype.sort(      compareFunc?: (a: T, b: T) => number     ): this          ```               *   Sorts the receiver and returns it.     *   The non-destructive version of this method is [`.toSorted()`](#qref-Array.prototype.toSorted).     *   Sorts string representations of the elements lexicographically.          Sorting numbers:                    ```js     // Default: lexicographical sorting     assert.deepEqual(      [200, 3, 10].sort(),      [10, 200, 3]     );      `// Ascending numerical sorting (“from a to z”)`     `assert.deepEqual(`      `[200, 3, 10].sort((a, z) => a - z),`      `[3, 10, 200]`     `);`      ```           ```js` Sorting strings: By default, strings are sorted by code unit values (char codes), where, e.g., all unaccented uppercase letters come before all unaccented lowercase letters:    ``` > ['pie', 'cookie', 'éclair', 'Pie', 'Cookie', 'Éclair'].sort() [ 'Cookie', 'Pie', 'cookie', 'pie', 'Éclair', 'éclair' ]  ```js    For human languages, we can use [`Intl.Collator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Collator):    ``` const arr = ['pie', 'cookie', 'éclair', 'Pie', 'Cookie', 'Éclair']; assert.deepEqual(  arr.sort(new Intl.Collator('en').compare),  ['cookie', 'Cookie', 'éclair', 'Éclair', 'pie', 'Pie'] );  ```js ````  ```js` *   `Array.prototype.toSorted(compareFunc?)`     ES2023 | Non-mutating                    ```     Array<T>.prototype.toSorted.toSorted(      compareFunc?: (a: T, b: T) => number     ): Array<T>          ```js               *   Returns a sorted copy of the current Array.     *   The destructive version of this method is [`.sort()`](#qref-Array.prototype.sort).          ```     const original = ['y', 'z', 'x'];     const sorted = original.toSorted();     assert.deepEqual(      // The original is unchanged      original, ['y', 'z', 'x']     );     assert.deepEqual(      // The copy is sorted      sorted, ['x', 'y', 'z']     );          ```js                    See the description of [`.sort()`](#qref-Array.prototype.sort) for more information on how to use this method.          *   `Array.prototype.reverse()`     ES1 | Mutating                    Rearranges the elements of the receiver so that they are in reverse order and then returns the receiver.                    ```     > const arr = ['a', 'b', 'c'];     > arr.reverse()     [ 'c', 'b', 'a' ]     > arr     [ 'c', 'b', 'a' ]          ```js                    The non-destructive version of this method is [`.toReversed()`](#qref-Array.prototype.toReversed).          *   `Array.prototype.toReversed()`     ES2023 | Non-mutating               *   Returns a reversed copy of the current Array.     *   The destructive version of this method is [`.reverse()`](#qref-Array.prototype.reverse).          ```     const original = ['x', 'y', 'z'];     const reversed = original.toReversed();     assert.deepEqual(      // The original is unchanged      original, ['x', 'y', 'z']     );     assert.deepEqual(      // The copy is reversed      reversed, ['z', 'y', 'x']     );          ```js ````    `#### [34.18.12 Sources of the quick reference](#sources-of-the-quick-reference)    *   [ECMAScript language specification](https://tc39.es/ecma262/) *   [TypeScript’s built-in typings](https://github.com/microsoft/TypeScript/tree/main/src/lib/) *   [MDN web docs for JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)` ```js`` `````", "``````js` ``````", "``````js``` ``````", "```` ```js````", "```js` ```", "```js```", "``` ```", "```````js``` ``````js```````", "``````js``````", "``````js``````", "``` ```", "```js```", "````js````", "```js```", "````js````", "```js` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "``````js``````", "```````js` ``````js```````", "```````js`` ``````js```````", "```````js``` ``````js```````", "```````js```` ```js```````", "```````js```````", "``````js``````", "```````js`````` ```js```````", "```````js```````", "``` ```", "```js```", "````js````", "```js```", "````js` ````", "```````js```````", "```````js`` ``````js```````", "```````js```````", "``` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js` ```", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "````js````", "```js```", "``````js``````", "```````js```````", "```````js` ``````js```````", "```````js```````", "`````````"]