<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>21 Class definitions in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>21 Class definitions in TypeScript</h1>
<blockquote>原文：<a href="https://exploringjs.com/ts/book/ch_class-definitions.html">https://exploringjs.com/ts/book/ch_class-definitions.html</a></blockquote>

    
        <div id="adbox">
      <div id="adbox-explain">(Ad, please don’t block.)</div>
              
          </div>
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#cheat-sheet-classes-in-plain-javascript">21.1 Cheat sheet: classes in plain JavaScript</a>
      <ol>
        <li>
          <a href="#basic-members-of-classes">21.1.1 Basic members of classes</a>
        </li>
        <li>
          <a href="#modifier-static">21.1.2 Modifier: <code>static</code></a>
        </li>
        <li>
          <a href="#modifier-like-name-prefix-private">21.1.3 Modifier-like name prefix: <code>#</code> (private)</a>
        </li>
        <li>
          <a href="#modifiers-for-accessors-get-getter-and-set-setter">21.1.4 Modifiers for accessors: <code>get</code> (getter) and <code>set</code> (setter)</a>
        </li>
        <li>
          <a href="#modifier-for-methods-generator">21.1.5 Modifier for methods: <code>*</code> (generator)</a>
        </li>
        <li>
          <a href="#modifier-for-methods-async">21.1.6 Modifier for methods: <code>async</code></a>
        </li>
        <li>
          <a href="#computed-class-member-names">21.1.7 Computed class member names</a>
        </li>
        <li>
          <a href="#combinations-of-modifiers">21.1.8 Combinations of modifiers</a>
        </li>
        <li>
          <a href="#under-the-hood">21.1.9 Under the hood</a>
        </li>
        <li>
          <a href="#more-information-on-class-definitions-in-plain-javascript">21.1.10 More information on class definitions in plain JavaScript</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#non-public-data-slots-in-typescript">21.2 Non-public data slots in TypeScript</a>
      <ol>
        <li>
          <a href="#private-properties">21.2.1 Private properties</a>
        </li>
        <li>
          <a href="#private-fields">21.2.2 Private fields</a>
        </li>
        <li>
          <a href="#private-properties-vs-private-fields">21.2.3 Private properties vs. private fields</a>
        </li>
        <li>
          <a href="#protected-properties">21.2.4 Protected properties</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#private-constructors">21.3 Private constructors</a>
    </li>
    <li>
      <a href="#initializing-instance-properties">21.4 Initializing instance properties</a>
      <ol>
        <li>
          <a href="#strictPropertyInitialization">21.4.1 Strict property initialization</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#convenience-features-we-should-avoid">21.5 Convenience features we should avoid</a>
      <ol>
        <li>
          <a href="#inferred-member-types">21.5.1 Inferred member types</a>
        </li>
        <li>
          <a href="#making-constructor-parameters-public-private-or-protected">21.5.2 Making constructor parameters <code>public</code>, <code>private</code> or <code>protected</code></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#abstract-classes">21.6 Abstract classes</a>
    </li>
    <li>
      <a href="#override">21.7 Keyword <code>override</code> for methods</a>
    </li>
    <li>
      <a href="#classes-vs-object-types">21.8 Classes vs. object types</a>
      <ol>
        <li>
          <a href="#class-counter">21.8.1 Class <code>Counter</code></a>
        </li>
        <li>
          <a href="#object-type-counter">21.8.2 Object type <code>Counter</code></a>
        </li>
        <li>
          <a href="#which-one-to-choose-class-or-object-type">21.8.3 Which one to choose: class or object type?</a>
        </li>
      </ol>
    </li>
  </ol>
</nav>
<p>In this chapter, we examine how class definitions work in TypeScript:</p>
<ul>
  <li>
    First, we take a quick look at the features of class definitions in plain JavaScript.
  </li>
  <li>
    Then we explore what additions TypeScript brings to the table.
  </li>
</ul>
<h3 id="cheat-sheet-classes-in-plain-javascript"><a class="heading-id-link" href="#cheat-sheet-classes-in-plain-javascript">21.1 Cheat sheet: classes in plain JavaScript</a></h3>
<p>This section is a cheat sheet for class definitions in plain JavaScript.</p>
<h4 id="basic-members-of-classes"><a class="heading-id-link" href="#basic-members-of-classes">21.1.1 Basic members of classes</a></h4>
<pre class="language-js">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">OtherClass</span> {}</code>
<code/>
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">OtherClass</span> {</code>
<code>  publicInstanceField = <span class="hljs-number">1</span>;</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">    <span class="hljs-variable language_">super</span>();</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">  <span class="hljs-title function_">publicPrototypeMethod</span>(<span class="hljs-params"/>) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">}</span></code>
<code/>
<code><span class="hljs-params"><span class="hljs-keyword">const</span> inst1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass1</span>();</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(inst1.<span class="hljs-property">publicInstanceField</span>, <span class="hljs-number">1</span>);</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(inst1.<span class="hljs-title function_">publicPrototypeMethod</span>(), <span class="hljs-number">2</span>);</span></code>
</pre>
<div class="boxout">
  <p><img src="../Images/00b0d6029a045810b908b88d1a6733d2.png" height="24" class="boxout-icon" alt="Icon “reading”" data-original-src="https://exploringjs.com/ts/book/icon/reading.svg"/> <strong>The next sections are about modifiers</strong></p>
  <div class="boxout-vspace"/>
  <p>At the end, there is a table that shows how modifiers can be combined.</p>
</div>
<h4 id="modifier-static"><a class="heading-id-link" href="#modifier-static">21.1.2 Modifier: <code>static</code></a></h4>
<pre class="language-js">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass2</span> {</code>
<code>  <span class="hljs-keyword">static</span> staticPublicField = <span class="hljs-number">1</span>;</code>
<code>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">staticPublicMethod</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">}</span></code>
<code/>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">MyClass2</span>.<span class="hljs-property">staticPublicField</span>, <span class="hljs-number">1</span>);</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title class_">MyClass2</span>.<span class="hljs-title function_">staticPublicMethod</span>(), <span class="hljs-number">2</span>);</span></code>
</pre>
<h4 id="modifier-like-name-prefix-private"><a class="heading-id-link" href="#modifier-like-name-prefix-private">21.1.3 Modifier-like name prefix: <code>#</code> (private)</a></h4>
<pre class="language-js">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass3</span> {</code>
<code>  #privateField = <span class="hljs-number">1</span>;</code>
<code>  #<span class="hljs-title function_">privateMethod</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-title function_">accessPrivateMembers</span>(<span class="hljs-params"/>) {</span></code>
<code><span class="hljs-params">    <span class="hljs-comment">// Private members can only be accessed from inside class definitions</span></span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">const</span> inst3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass3</span>();</span></code>
<code><span class="hljs-params">    assert.<span class="hljs-title function_">equal</span>(inst3.#privateField, <span class="hljs-number">1</span>);</span></code>
<code><span class="hljs-params">    assert.<span class="hljs-title function_">equal</span>(inst3.#<span class="hljs-title function_">privateMethod</span>(), <span class="hljs-number">2</span>);</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<h4 id="modifiers-for-accessors-get-getter-and-set-setter"><a class="heading-id-link" href="#modifiers-for-accessors-get-getter-and-set-setter">21.1.4 Modifiers for accessors: <code>get</code> (getter) and <code>set</code> (setter)</a></h4>
<p>Roughly, accessors are prototype methods that are inherited by instances and invoked by accessing properties. There are two kinds of accessors: getters and setters.</p>
<pre class="language-js">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass4</span> {</code>
<code>  #name = <span class="hljs-string">'Rumpelstiltskin'</span>;</code>
<code>  </code>
<code>  <span class="hljs-comment">/** Prototype getter */</span></code>
<code>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() {</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#name;</code>
<code>  }</code>
<code/>
<code>  <span class="hljs-comment">/** Prototype setter */</span></code>
<code>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">value</span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.#name = value;</code>
<code>  }</code>
<code>}</code>
<code><span class="hljs-keyword">const</span> inst5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass4</span>();</code>
<code>assert.<span class="hljs-title function_">equal</span>(inst5.<span class="hljs-property">name</span>, <span class="hljs-string">'Rumpelstiltskin'</span>); <span class="hljs-comment">// getter</span></code>
<code>inst5.<span class="hljs-property">name</span> = <span class="hljs-string">'Queen'</span>; <span class="hljs-comment">// setter</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(inst5.<span class="hljs-property">name</span>, <span class="hljs-string">'Queen'</span>); <span class="hljs-comment">// getter</span></code>
</pre>
<h4 id="modifier-for-methods-generator"><a class="heading-id-link" href="#modifier-for-methods-generator">21.1.5 Modifier for methods: <code>*</code> (generator)</a></h4>
<pre class="language-js">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass5</span> {</code>
<code>  * <span class="hljs-title function_">publicPrototypeGeneratorMethod</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">yield</span> <span class="hljs-string">'hello'</span>;</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">yield</span> <span class="hljs-string">'world'</span>;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">}</span></code>
<code/>
<code><span class="hljs-params"><span class="hljs-keyword">const</span> inst6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass5</span>();</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(inst6.<span class="hljs-title function_">publicPrototypeGeneratorMethod</span>()),</span></code>
<code><span class="hljs-params">  [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>]</span></code>
<code><span class="hljs-params">);</span></code>
</pre>
<h4 id="modifier-for-methods-async"><a class="heading-id-link" href="#modifier-for-methods-async">21.1.6 Modifier for methods: <code>async</code></a></h4>
<pre class="language-js">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass6</span> {</code>
<code>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">publicPrototypeAsyncMethod</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'abc'</span>);</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> result + result;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">}</span></code>
<code/>
<code><span class="hljs-params"><span class="hljs-keyword">const</span> inst7 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass6</span>();</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">await</span> inst7.<span class="hljs-title function_">publicPrototypeAsyncMethod</span>(),</span></code>
<code><span class="hljs-params">  <span class="hljs-string">'abcabc'</span></span></code>
<code><span class="hljs-params">);</span></code>
</pre>
<h4 id="computed-class-member-names"><a class="heading-id-link" href="#computed-class-member-names">21.1.7 Computed class member names</a></h4>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> publicInstanceFieldKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'publicInstanceFieldKey'</span>);</code>
<code><span class="hljs-keyword">const</span> publicPrototypeMethodKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'publicPrototypeMethodKey'</span>);</code>
<code/>
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass7</span> {</code>
<code>  [publicInstanceFieldKey] = <span class="hljs-number">1</span>;</code>
<code>  [publicPrototypeMethodKey]() {</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;</code>
<code>  }</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">const</span> inst8 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass7</span>();</code>
<code>assert.<span class="hljs-title function_">equal</span>(inst8[publicInstanceFieldKey], <span class="hljs-number">1</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(inst8[publicPrototypeMethodKey](), <span class="hljs-number">2</span>);</code>
</pre>
<p>Comments:</p>
<ul>
  <li>
    The main use case for this feature is symbols such as <code>Symbol.iterator</code>. But any expression can be used inside the square brackets.
  </li>
  <li>
    We can compute the names of fields, methods, and accessors.
  </li>
  <li>
    We cannot compute the names of private members (which are always fixed).
  </li>
</ul>
<h4 id="combinations-of-modifiers"><a class="heading-id-link" href="#combinations-of-modifiers">21.1.8 Combinations of modifiers</a></h4>
<p>Fields:</p>
<table class="framed">
  <style>
    th:nth-child(1), td:nth-child(1) {
      text-align: left;
    }
    th:nth-child(2), td:nth-child(2) {
      text-align: left;
    }
    th:nth-child(3), td:nth-child(3) {
      text-align: left;
    }
  </style>
  <thead>
    <tr>
      <th>Level</th><th>Private</th><th>Code</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>(instance)</td><td/><td><code>field</code></td>
    </tr>
    <tr>
      <td>(instance)</td><td><code>#</code></td><td><code>#field</code></td>
    </tr>
    <tr>
      <td><code>static</code></td><td/><td><code>static field</code></td>
    </tr>
    <tr>
      <td><code>static</code></td><td><code>#</code></td><td><code>static #field</code></td>
    </tr>
  </tbody>
</table>
<p>Methods (columns: Level, Accessor, Async, Generator, Private, Code – without body):</p>
<table class="framed">
  <style>
    th:nth-child(1), td:nth-child(1) {
      text-align: left;
    }
    th:nth-child(2), td:nth-child(2) {
      text-align: left;
    }
    th:nth-child(3), td:nth-child(3) {
      text-align: left;
    }
    th:nth-child(4), td:nth-child(4) {
      text-align: left;
    }
    th:nth-child(5), td:nth-child(5) {
      text-align: left;
    }
    th:nth-child(6), td:nth-child(6) {
      text-align: left;
    }
  </style>
  <thead>
    <tr>
      <th>Level</th><th>Acc</th><th>Async</th><th>Gen</th><th>Priv</th><th>Code</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>(prototype)</td><td/><td/><td/><td/><td><code>m()</code></td>
    </tr>
    <tr>
      <td>(prototype)</td><td><code>get</code></td><td/><td/><td/><td><code>get p()</code></td>
    </tr>
    <tr>
      <td>(prototype)</td><td><code>set</code></td><td/><td/><td/><td><code>set p(x)</code></td>
    </tr>
    <tr>
      <td>(prototype)</td><td/><td><code>async</code></td><td/><td/><td><code>async m()</code></td>
    </tr>
    <tr>
      <td>(prototype)</td><td/><td/><td><code>*</code></td><td/><td><code>* m()</code></td>
    </tr>
    <tr>
      <td>(prototype)</td><td/><td><code>async</code></td><td><code>*</code></td><td/><td><code>async * m()</code></td>
    </tr>
    <tr>
      <td>(prototype-ish)</td><td/><td/><td/><td><code>#</code></td><td><code>#m()</code></td>
    </tr>
    <tr>
      <td>(prototype-ish)</td><td><code>get</code></td><td/><td/><td><code>#</code></td><td><code>get #p()</code></td>
    </tr>
    <tr>
      <td>(prototype-ish)</td><td><code>set</code></td><td/><td/><td><code>#</code></td><td><code>set #p(x)</code></td>
    </tr>
    <tr>
      <td>(prototype-ish)</td><td/><td><code>async</code></td><td/><td><code>#</code></td><td><code>async #m()</code></td>
    </tr>
    <tr>
      <td>(prototype-ish)</td><td/><td/><td><code>*</code></td><td><code>#</code></td><td><code>* #m()</code></td>
    </tr>
    <tr>
      <td>(prototype-ish)</td><td/><td><code>async</code></td><td><code>*</code></td><td><code>#</code></td><td><code>async * #m()</code></td>
    </tr>
    <tr>
      <td><code>static</code></td><td/><td/><td/><td/><td><code>static m()</code></td>
    </tr>
    <tr>
      <td><code>static</code></td><td><code>get</code></td><td/><td/><td/><td><code>static get p()</code></td>
    </tr>
    <tr>
      <td><code>static</code></td><td><code>set</code></td><td/><td/><td/><td><code>static set p(x)</code></td>
    </tr>
    <tr>
      <td><code>static</code></td><td/><td><code>async</code></td><td/><td/><td><code>static async m()</code></td>
    </tr>
    <tr>
      <td><code>static</code></td><td/><td/><td><code>*</code></td><td/><td><code>static * m()</code></td>
    </tr>
    <tr>
      <td><code>static</code></td><td/><td><code>async</code></td><td><code>*</code></td><td/><td><code>static async * m()</code></td>
    </tr>
    <tr>
      <td><code>static</code></td><td/><td/><td/><td><code>#</code></td><td><code>static #m()</code></td>
    </tr>
    <tr>
      <td><code>static</code></td><td><code>get</code></td><td/><td/><td><code>#</code></td><td><code>static get #p()</code></td>
    </tr>
    <tr>
      <td><code>static</code></td><td><code>set</code></td><td/><td/><td><code>#</code></td><td><code>static set #p(x)</code></td>
    </tr>
    <tr>
      <td><code>static</code></td><td/><td><code>async</code></td><td/><td><code>#</code></td><td><code>static async #m()</code></td>
    </tr>
    <tr>
      <td><code>static</code></td><td/><td/><td><code>*</code></td><td><code>#</code></td><td><code>static * #m()</code></td>
    </tr>
    <tr>
      <td><code>static</code></td><td/><td><code>async</code></td><td><code>*</code></td><td><code>#</code></td><td><code>static async * #m()</code></td>
    </tr>
  </tbody>
</table>
<h4 id="under-the-hood"><a class="heading-id-link" href="#under-the-hood">21.1.9 Under the hood</a></h4>
<p>It’s important to keep in mind that with classes, there are two chains of prototype objects:</p>
<ul>
  <li>
    The instance chain which starts with an instance.
  </li>
  <li>
    The static chain which starts with the class of that instance.
  </li>
</ul>
<p>Consider the following plain JavaScript example:</p>
<pre class="language-js">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA</span> {</code>
<code>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">staticMthdA</span>(<span class="hljs-params">) {}</span></code>
<code><span class="hljs-params">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">instPropA</span>) {</span></code>
<code><span class="hljs-params">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instPropA</span> = instPropA;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">  <span class="hljs-title function_">prototypeMthdA</span>(<span class="hljs-params"/>) {}</span></code>
<code><span class="hljs-params">}</span></code>
<code><span class="hljs-params"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ClassA</span> {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">static</span> <span class="hljs-title function_">staticMthdB</span>(<span class="hljs-params"/>) {}</span></code>
<code><span class="hljs-params">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">instPropA, instPropB</span>) {</span></code>
<code><span class="hljs-params">    <span class="hljs-variable language_">super</span>(instPropA);</span></code>
<code><span class="hljs-params">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instPropB</span> = instPropB;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">  <span class="hljs-title function_">prototypeMthdB</span>(<span class="hljs-params"/>) {}</span></code>
<code><span class="hljs-params">}</span></code>
<code><span class="hljs-params"><span class="hljs-keyword">const</span> instB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassB</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);</span></code>
</pre>
<p><a href="#fig:class-prototype-chains">Figure 21.1</a> shows what the prototype chains look like that are created by <code>ClassA</code> and <code>ClassB</code>.</p>
<figure id="fig:class-prototype-chains" class="float">
  <p><img src="../Images/820493c8f187cebea74380b7ced1d6f2.png" width="356" alt="" style="height:392.5px" data-original-src="https://exploringjs.com/ts/book/img/class-definitions/class-prototype-chains.svg"/></p>
  <figcaption>
    <p><span class="float-label">Figure 21.1:</span> The classes <code>ClassA</code> and <code>ClassB</code> create two prototype chains: One for classes (left-hand side) and one for instances (right-hand side).</p>
  </figcaption>
</figure>
<h4 id="more-information-on-class-definitions-in-plain-javascript"><a class="heading-id-link" href="#more-information-on-class-definitions-in-plain-javascript">21.1.10 More information on class definitions in plain JavaScript</a></h4>
<ul>
  <li>
    <a href="https://exploringjs.com/js/book/ch_classes.html">Chapter “Classes”</a> in “Exploring JavaScript”
  </li>
</ul>
<h3 id="non-public-data-slots-in-typescript"><a class="heading-id-link" href="#non-public-data-slots-in-typescript">21.2 Non-public data slots in TypeScript</a></h3>
<p>By default, all data slots in TypeScript are public properties. There are two ways of keeping data private:</p>
<ul>
  <li>
    Private properties
  </li>
  <li>
    Private fields
  </li>
</ul>
<p>We’ll look at both next.</p>
<p>Note that TypeScript does not currently support private methods.</p>
<h4 id="private-properties"><a class="heading-id-link" href="#private-properties">21.2.1 Private properties</a></h4>
<p>Private properties are a TypeScript-only (static) feature. Any property can be made private by prefixing it with the keyword <code>private</code> (line A):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonPrivateProperty</span> {</code>
<code>  <span class="hljs-keyword">private</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// (A)</span></code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;</code>
<code>  }</code>
<code>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>!`</span>;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p>We now get compile-time errors if we access that property in the wrong scope (line A):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersonPrivateProperty</span>(<span class="hljs-string">'John'</span>);</code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  john.<span class="hljs-title function_">sayHello</span>(), <span class="hljs-string">'Hello John!'</span></code>
<code>);</code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Property 'name' is private and only accessible</span></code>
<code><span class="hljs-comment">// within class 'PersonPrivateProperty'.</span></code>
<code>john.<span class="hljs-property">name</span>; <span class="hljs-comment">// (A)</span></code>
</pre>
<p>However, <code>private</code> doesn’t change anything at runtime. There, property <code>.name</code> is indistinguishable from a public property:</p>
<pre class="language-ts">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(john),</code>
<code>  [<span class="hljs-string">'name'</span>]</code>
<code>);</code>
</pre>
<p>We can also see that private properties aren’t protected at runtime when we look at the JavaScript code that the class is compiled to:</p>
<pre class="language-js">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonPrivateProperty</span> {</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;</code>
<code>  }</code>
<code>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>!`</span>;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<h4 id="private-fields"><a class="heading-id-link" href="#private-fields">21.2.2 Private fields</a></h4>
<p>Private fields are a new JavaScript feature that TypeScript has supported since version 3.8:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonPrivateField</span> {</code>
<code>  #<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.#name = name;</code>
<code>  }</code>
<code>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.#name}</span>!`</span>;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p>This version of <code>Person</code> is mostly used the same way as the private property version:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersonPrivateField</span>(<span class="hljs-string">'John'</span>);</code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  john.<span class="hljs-title function_">sayHello</span>(), <span class="hljs-string">'Hello John!'</span></code>
<code>);</code>
</pre>
<p>However, this time, the data is completely encapsulated. Using the private field syntax outside classes is even a JavaScript syntax error. That’s why we have to use <code>eval()</code> in line A so that we can execute this code:</p>
<pre class="language-ts">
<code>assert.<span class="hljs-title function_">throws</span>(</code>
<code>  <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">eval</span>(<span class="hljs-string">'john.#name'</span>), <span class="hljs-comment">// (A)</span></code>
<code>  {</code>
<code>    <span class="hljs-attr">name</span>: <span class="hljs-string">'SyntaxError'</span>,</code>
<code>    <span class="hljs-attr">message</span>: <span class="hljs-string">"Private field '#name' must be declared in "</span></code>
<code>      + <span class="hljs-string">"an enclosing class"</span>,</code>
<code>  }</code>
<code>);</code>
<code/>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(john),</code>
<code>  []</code>
<code>);</code>
</pre>
<p>Compiled to JavaScript, <code>PersonPrivateField</code> looks more or less the same:</p>
<pre class="language-js">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonPrivateField</span> {</code>
<code>  #name;</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.#name = name;</code>
<code>  }</code>
<code>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.#name}</span>!`</span>;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<h4 id="private-properties-vs-private-fields"><a class="heading-id-link" href="#private-properties-vs-private-fields">21.2.3 Private properties vs. private fields</a></h4>
<ul>
  <li>
    Downsides of private properties:
    <ul>
      <li>
        We can’t reuse the names of private properties in subclasses (because the properties aren’t private at runtime).
      </li>
      <li>
        No encapsulation at runtime.
      </li>
    </ul>
  </li>
  <li>
    Upsides of private properties:
    <ul>
      <li>
        Clients can circumvent the encapsulation and access private properties. This can be useful if someone needs to work around a bug. In other words: Data being completely encapsulated has pros and cons.
      </li>
      <li>
        Some JavaScript helper functions, e.g. for cloning or for serialization to JSON, don’t work with private fields.
      </li>
    </ul>
  </li>
</ul>
<h4 id="protected-properties"><a class="heading-id-link" href="#protected-properties">21.2.4 Protected properties</a></h4>
<p>Private fields and private properties can’t be accessed in subclasses (line B):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrivatePerson</span> {</code>
<code>  <span class="hljs-keyword">private</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;</code>
<code>  }</code>
<code>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>!`</span>;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">}</span></code>
<code><span class="hljs-params"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrivateEmployee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PrivatePerson</span> {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">private</span> <span class="hljs-attr">company</span>: <span class="hljs-built_in">string</span>;</span></code>
<code><span class="hljs-params">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, company: <span class="hljs-built_in">string</span></span>) {</span></code>
<code><span class="hljs-params">    <span class="hljs-variable language_">super</span>(name);</span></code>
<code><span class="hljs-params">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">company</span> = company;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">override</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"/>) { <span class="hljs-comment">// (A)</span></span></code>
<code><span class="hljs-params">    <span class="hljs-comment">// @ts-expect-error: Property 'name' is private and only</span></span></code>
<code><span class="hljs-params">    <span class="hljs-comment">// accessible within class 'PrivatePerson'.</span></span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span> from <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.company}</span>!`</span>; <span class="hljs-comment">// (B)</span></span></code>
<code><span class="hljs-params">  }  </span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p>The keyword <code>override</code> is explained <a href="#override">later</a> – it’s for methods that override super-methods.</p>
<p>We can fix the previous example by switching from <code>private</code> to <code>protected</code> in line A (we also switch in line B, for consistency’s sake):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProtectedPerson</span> {</code>
<code>  <span class="hljs-keyword">protected</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// (A)</span></code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;</code>
<code>  }</code>
<code>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>!`</span>;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">}</span></code>
<code><span class="hljs-params"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProtectedEmployee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ProtectedPerson</span> {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">protected</span> <span class="hljs-attr">company</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// (B)</span></span></code>
<code><span class="hljs-params">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, company: <span class="hljs-built_in">string</span></span>) {</span></code>
<code><span class="hljs-params">    <span class="hljs-variable language_">super</span>(name);</span></code>
<code><span class="hljs-params">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">company</span> = company;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">override</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"/>) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span> from <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.company}</span>!`</span>; <span class="hljs-comment">// OK</span></span></code>
<code><span class="hljs-params">  }  </span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<h3 id="private-constructors"><a class="heading-id-link" href="#private-constructors">21.3 Private constructors</a></h3>
<p>At the moment, JavaScript does not support hash-private constructors. However, TypeScript supports <code>private</code> for them. That is useful when we have static factory methods and want clients to always use those methods, never the constructor directly. Static methods can access private class members, which is why the factory methods can still use the constructor.</p>
<p>In the following code, there is one static factory method <code>DataContainer.create()</code>. It sets up instances via asynchronously loaded data. Keeping the asynchronous code in the factory method enables the actual class to be completely synchronous:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataContainer</span> {</code>
<code>  #<span class="hljs-attr">data</span>: <span class="hljs-built_in">string</span>;</code>
<code>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'downloaded'</span>); <span class="hljs-comment">// (A)</span></span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">this</span>(data);</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">private</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">data: <span class="hljs-built_in">string</span></span>) {</span></code>
<code><span class="hljs-params">    <span class="hljs-variable language_">this</span>.#data = data;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">  <span class="hljs-title function_">getData</span>(<span class="hljs-params"/>) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-string">'DATA: '</span>+<span class="hljs-variable language_">this</span>.#data;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">}</span></code>
<code><span class="hljs-params"><span class="hljs-keyword">const</span> dataContainer = <span class="hljs-keyword">await</span> <span class="hljs-title class_">DataContainer</span>.<span class="hljs-title function_">create</span>();</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span></code>
<code><span class="hljs-params">  dataContainer.<span class="hljs-title function_">getData</span>(),</span></code>
<code><span class="hljs-params">  <span class="hljs-string">'DATA: downloaded'</span></span></code>
<code><span class="hljs-params">);</span></code>
</pre>
<p>In real-world code, we would use <code>fetch()</code> or a similar Promise-based API to load data asynchronously in line A.</p>
<p>The private constructor prevents <code>DataContainer</code> from being subclassed. If we want to allow subclasses, we have to make it <code>protected</code>.</p>
<h3 id="initializing-instance-properties"><a class="heading-id-link" href="#initializing-instance-properties">21.4 Initializing instance properties</a></h3>
<h4 id="strictPropertyInitialization"><a class="heading-id-link" href="#strictPropertyInitialization">21.4.1 Strict property initialization</a></h4>
<p>If the compiler setting <code>--strictPropertyInitialization</code> is switched on (which is the case if we use <code>--strict</code>), then TypeScript checks if all declared instance properties are correctly initialized:</p>
<ul>
  <li>
    <p>Either via assignments in the constructor:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {</code>
<code>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;</code>
<code>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;</code>
<code>  }</code>
<code>}</code>
</pre>
  </li>
  <li>
    <p>Or via initializers for the property declarations:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {</code>
<code>  x = <span class="hljs-number">0</span>;</code>
<code>  y = <span class="hljs-number">0</span>;</code>
<code/>
<code>  <span class="hljs-comment">// No constructor needed</span></code>
<code>}</code>
</pre>
  </li>
</ul>
<p>However, sometimes we initialize properties in a manner that TypeScript doesn’t recognize. Then we can use exclamation marks (<em>definite assignment assertions</em>) to switch off TypeScript’s warnings (line A and line B):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {</code>
<code>  x!: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// (A)</span></code>
<code>  y!: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// (B)</span></code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initProperties</span>();</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">  <span class="hljs-title function_">initProperties</span>(<span class="hljs-params"/>) {</span></code>
<code><span class="hljs-params">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = <span class="hljs-number">0</span>;</span></code>
<code><span class="hljs-params">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = <span class="hljs-number">0</span>;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<h5 id="example-setting-up-instance-properties-via-objects"><a class="heading-id-link" href="#example-setting-up-instance-properties-via-objects">21.4.1.1 Example: setting up instance properties via objects</a></h5>
<p>In the following example, we also need definite assignment assertions. Here, we set up instance properties via the constructor parameter <code>props</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">CompilerError</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CompilerErrorProps</span> { <span class="hljs-comment">// (A)</span></code>
<code>  line!: <span class="hljs-built_in">number</span>;</code>
<code>  description!: <span class="hljs-built_in">string</span>;</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props: CompilerErrorProps</span>) {</code>
<code>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-variable language_">this</span>, props); <span class="hljs-comment">// (B)</span></code>
<code>  }</code>
<code>}</code>
<code/>
<code><span class="hljs-comment">// Helper interface for the parameter properties</span></code>
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CompilerErrorProps</span> {</code>
<code>  <span class="hljs-attr">line</span>: <span class="hljs-built_in">number</span>,</code>
<code>  <span class="hljs-attr">description</span>: <span class="hljs-built_in">string</span>,</code>
<code>}</code>
<code/>
<code><span class="hljs-comment">// Using the class:</span></code>
<code><span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompilerError</span>({</code>
<code>  <span class="hljs-attr">line</span>: <span class="hljs-number">123</span>,</code>
<code>  <span class="hljs-attr">description</span>: <span class="hljs-string">'Unexpected token'</span>,</code>
<code>});</code>
</pre>
<p>Notes:</p>
<ul>
  <li>
    In line B, we initialize all properties: We use <code>Object.assign()</code> to copy the properties of parameter <code>props</code> into <code>this</code>.
  </li>
  <li>
    In line A, the <code>implements</code> ensures that the class declares all properties that are part of interface <code>CompilerErrorProps</code>.
  </li>
</ul>
<h3 id="convenience-features-we-should-avoid"><a class="heading-id-link" href="#convenience-features-we-should-avoid">21.5 Convenience features we should avoid</a></h3>
<h4 id="inferred-member-types"><a class="heading-id-link" href="#inferred-member-types">21.5.1 Inferred member types</a></h4>
<p><code>tsc</code> can infer the type of the member <code>.str</code> because we assign to it in line A. However, that is not compatible with the compiler option <a href="ch_tsconfig-json.html#isolatedDeclarations"><code>isolatedDeclarations</code></a> (which enables external tools to generate declarations without doing inference):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {</code>
<code>  str;</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span></span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">str</span> = str; <span class="hljs-comment">// (A)</span></code>
<code>  }</code>
<code>}</code>
</pre>
<h4 id="making-constructor-parameters-public-private-or-protected"><a class="heading-id-link" href="#making-constructor-parameters-public-private-or-protected">21.5.2 Making constructor parameters <code>public</code>, <code>private</code> or <code>protected</code></a></h4>
<p>JavaScript currently has no equivalent to the TypeScript feature described in this subsection – which is why it is illegal if the compiler option <a href="ch_tsconfig-json.html#erasableSyntaxOnly"><code>erasableSyntaxOnly</code></a> is active.</p>
<p>If we use the modifier <code>public</code> for a constructor parameter <code>prop</code>, then TypeScript does two things for us:</p>
<ul>
  <li>
    It declares a public instance property <code>.prop</code>.
  </li>
  <li>
    It assigns the parameter <code>prop</code> to that instance property.
  </li>
</ul>
<p>This is an example:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> x: <span class="hljs-built_in">number</span>, <span class="hljs-keyword">public</span> y: <span class="hljs-built_in">number</span></span>) {</code>
<code>  }</code>
<code>}</code>
</pre>
<p>If we use <code>private</code> or <code>protected</code> instead of <code>public</code>, then the corresponding instance properties are private or protected.</p>
<p>The TypeScript class <code>Point</code> is compiled to the following JavaScript code:</p>
<pre class="language-js">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y</span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;</code>
<code>  }</code>
<code>}</code>
</pre>
<h3 id="abstract-classes"><a class="heading-id-link" href="#abstract-classes">21.6 Abstract classes</a></h3>
<p>Two constructs can be abstract in TypeScript:</p>
<ul>
  <li>
    An abstract class can’t be instantiated. Only its subclasses can – if they are not abstract, themselves.
  </li>
  <li>
    An abstract method has no implementation, only a type signature. Each concrete subclass must have a concrete method with the same name and a compatible type signature.
    <ul>
      <li>
        If a class has any abstract methods, it must be abstract, too.
      </li>
    </ul>
  </li>
</ul>
<p>The following code demonstrates abstract classes and methods.</p>
<p>On one hand, there is the abstract superclass <code>Printable</code> and its helper class <code>StringBuilder</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBuilder</span> {</code>
<code>  <span class="hljs-built_in">string</span> = <span class="hljs-string">''</span>;</code>
<code>  <span class="hljs-title function_">add</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span></span>) {</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">string</span> += str;</code>
<code>  }</code>
<code>}</code>
<code><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Printable</span> {</code>
<code>  <span class="hljs-title function_">toString</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">const</span> out = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();</span></code>
<code><span class="hljs-params">    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">print</span>(out);</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> out.<span class="hljs-property">string</span>;</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">print</span>(<span class="hljs-attr">out</span>: <span class="hljs-title class_">StringBuilder</span>): <span class="hljs-built_in">void</span>;</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
<p>On the other hand, there are the concrete subclasses <code>Entries</code> and <code>Entry</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entries</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Printable</span> {</code>
<code>  <span class="hljs-attr">entries</span>: <span class="hljs-title class_">Entry</span>[];</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">entries: Entry[]</span>) {</code>
<code>    <span class="hljs-variable language_">super</span>();</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">entries</span> = entries;</code>
<code>  }</code>
<code>  <span class="hljs-title function_">print</span>(<span class="hljs-attr">out</span>: <span class="hljs-title class_">StringBuilder</span>): <span class="hljs-built_in">void</span> {</code>
<code>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">entries</span>) {</code>
<code>      entry.<span class="hljs-title function_">print</span>(out);</code>
<code>    }</code>
<code>  }</code>
<code>}</code>
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Printable</span> {</code>
<code>  <span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>;</code>
<code>  <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>;</code>
<code>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">key: <span class="hljs-built_in">string</span>, value: <span class="hljs-built_in">string</span></span>) {</code>
<code>    <span class="hljs-variable language_">super</span>();</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key;</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;</code>
<code>  }</code>
<code>  <span class="hljs-title function_">print</span>(<span class="hljs-attr">out</span>: <span class="hljs-title class_">StringBuilder</span>): <span class="hljs-built_in">void</span> {</code>
<code>    out.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span>);</code>
<code>    out.<span class="hljs-title function_">add</span>(<span class="hljs-string">': '</span>);</code>
<code>    out.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);</code>
<code>    out.<span class="hljs-title function_">add</span>(<span class="hljs-string">'\n'</span>);</code>
<code>  }</code>
<code>}</code>
</pre>
<p>And finally, this is us using <code>Entries</code> and <code>Entry</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> entries = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entries</span>([</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(<span class="hljs-string">'accept-ranges'</span>, <span class="hljs-string">'bytes'</span>),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(<span class="hljs-string">'content-length'</span>, <span class="hljs-string">'6518'</span>),</code>
<code>]);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  entries.<span class="hljs-title function_">toString</span>(),</code>
<code>  <span class="hljs-string">'accept-ranges: bytes\ncontent-length: 6518\n'</span></code>
<code>);</code>
</pre>
<p>Notes about abstract classes:</p>
<ul>
  <li>
    An abstract class can be seen as an interface where some members already have implementations.
  </li>
  <li>
    While a class can implement multiple interfaces, it can only extend at most one abstract class.
  </li>
  <li>
    “Abstractness” only exists at compile time. At runtime, abstract classes are normal classes and abstract methods don’t exist (due to them only providing compile-time information).
  </li>
  <li>
    Abstract classes can be seen as templates where each abstract method is a blank that has to be filled in (implemented) by subclasses.
  </li>
</ul>
<h3 id="override"><a class="heading-id-link" href="#override">21.7 Keyword <code>override</code> for methods</a></h3>
<p>The keyword <code>override</code> is for methods that override methods in superclasses – e.g.:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {</code>
<code>  <span class="hljs-title function_">m</span>(): <span class="hljs-built_in">void</span> {}</code>
<code>}</code>
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> {</code>
<code>  <span class="hljs-comment">// `override` is required</span></code>
<code>  <span class="hljs-keyword">override</span> <span class="hljs-title function_">m</span>(): <span class="hljs-built_in">void</span> {} <span class="hljs-comment">// (A)</span></code>
<code>}</code>
</pre>
<p>If the compiler option <a href="ch_tsconfig-json.html#noImplicitOverride"><code>noImplicitOverride</code></a> is active then TypeScript complains if there is no <code>override</code> in line A.</p>
<p>We can also use <code>override</code> when we implement an abstract method. That’s not required but I find it useful information:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {</code>
<code>  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">m</span>(): <span class="hljs-built_in">void</span>;</code>
<code>}</code>
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> {</code>
<code>  <span class="hljs-comment">// `override` is optional</span></code>
<code>  <span class="hljs-keyword">override</span> <span class="hljs-title function_">m</span>(): <span class="hljs-built_in">void</span> {}</code>
<code>}</code>
</pre>
<h3 id="classes-vs-object-types"><a class="heading-id-link" href="#classes-vs-object-types">21.8 Classes vs. object types</a></h3>
<p>In JavaScript, we don’t have to use classes, we can also use objects directly. TypeScript supports both approaches.</p>
<h4 id="class-counter"><a class="heading-id-link" href="#class-counter">21.8.1 Class <code>Counter</code></a></h4>
<p>This is a class that implements a counter:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> {</code>
<code>  count = <span class="hljs-number">0</span>;</code>
<code>  <span class="hljs-title function_">inc</span>(): <span class="hljs-built_in">void</span> {</code>
<code>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;</code>
<code>  }</code>
<code>}</code>
<code/>
<code><span class="hljs-comment">// Trying out the functionality</span></code>
<code><span class="hljs-keyword">const</span> counter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>();</code>
<code>counter.<span class="hljs-title function_">inc</span>();</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  counter.<span class="hljs-property">count</span>, <span class="hljs-number">1</span></code>
<code>);</code>
</pre>
<h4 id="object-type-counter"><a class="heading-id-link" href="#object-type-counter">21.8.2 Object type <code>Counter</code></a></h4>
<p>In TypeScript, a class defines both a type and a factory for instances. In the following code, both are separate: We have the object type <code>Counter</code> and the factory <code>createCounter()</code>.</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Counter</span> = {</code>
<code>  <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span>,</code>
<code>};</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params">): <span class="hljs-title class_">Counter</span> {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">return</span> {</span></code>
<code><span class="hljs-params">    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,</span></code>
<code><span class="hljs-params">  };</span></code>
<code><span class="hljs-params">}</span></code>
<code><span class="hljs-params"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inc</span>(<span class="hljs-params">counter: Counter</span>): <span class="hljs-built_in">void</span> {</span></code>
<code><span class="hljs-params">  counter.<span class="hljs-property">count</span>++;</span></code>
<code><span class="hljs-params">}</span></code>
<code/>
<code><span class="hljs-params"><span class="hljs-comment">// Trying out the functionality</span></span></code>
<code><span class="hljs-params"><span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">createCounter</span>();</span></code>
<code><span class="hljs-params"><span class="hljs-title function_">inc</span>(counter);</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span></code>
<code><span class="hljs-params">  counter.<span class="hljs-property">count</span>, <span class="hljs-number">1</span></span></code>
<code><span class="hljs-params">);</span></code>
</pre>
<h4 id="which-one-to-choose-class-or-object-type"><a class="heading-id-link" href="#which-one-to-choose-class-or-object-type">21.8.3 Which one to choose: class or object type?</a></h4>
<p>Benefits of classes:</p>
<ul>
  <li>
    Everything is specified compactly in one place:
    <ul>
      <li>
        Type
      </li>
      <li>
        Instance factory
      </li>
      <li>
        Operations such as <code>inc</code>
      </li>
      <li>
        The default value of a property being specified close to the definition of that property is something I find useful – e.g., <code>.count</code> has the default value 0.
      </li>
    </ul>
  </li>
  <li>
    We can check the type of a value via <code>instanceof</code> – e.g. to narrow a type.
  </li>
  <li>
    We can use private fields.
  </li>
</ul>
<p>Benefits of object types:</p>
<ul>
  <li>
    They work better if objects are cloned: Library functions for cloning can’t handle private fields and <a href="https://2ality.com/2022/01/structured-clone.html"><code>structuredClone()</code></a> does not preserve the class of an instance.
  </li>
  <li>
    They work better if objects are moved between realms: Each realm has its own version of a given class and that makes moving class instances problematic.
  </li>
</ul>
<p>Serializing and deserializing (to/from JSON etc.) is an interesting use case:</p>
<ul>
  <li>
    With object types, deserialization is easier because we can immediate work with the result of <code>JSON.parse()</code> (potentially after <a href="ch_validating-external-data.html#ch_validating-external-data">validating the type via Zod</a>).
  </li>
  <li>
    Things get more complicated if not all data can be easily serialized and deserialized – e.g. if a property contains a <code>Map</code>. Then classes have one benefit: We can customize serialization by implementing the method <code>.toJSON()</code>.
  </li>
</ul>
<p>Apart from these criteria, which one to choose depends on whether you prefer code that is more object-oriented or code that is more functional.</p>
<p>We have not covered inheritance – where you also have a choice between an object-oriented coding style (classes) and a functional coding style (discriminated unions). For more information, see <a href="ch_unions-object-types.html#class-hierarchies-vs-discriminated-unions">“Class hierarchies vs. discriminated unions” (§19.3)</a>.</p>

    
      
</body>
</html>