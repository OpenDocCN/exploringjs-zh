- en: 28 Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 28 对象
- en: 原文：[https://exploringjs.com/impatient-js/ch_objects.html](https://exploringjs.com/impatient-js/ch_objects.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/impatient-js/ch_objects.html](https://exploringjs.com/impatient-js/ch_objects.html)
- en: '* * *'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '28.1 [Cheat sheet: objects](ch_objects.html#cheat-sheet-objects)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.1 [速查表：对象](ch_objects.html#cheat-sheet-objects)
- en: 28.1.1 [Single objects](ch_objects.html#single-objects)
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.1.1 [单个对象](ch_objects.html#single-objects)
- en: 28.1.2 [Prototype chains](ch_objects.html#prototype-chains)
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.1.2 [原型链](ch_objects.html#prototype-chains)
- en: 28.2 [What is an object?](ch_objects.html#what-is-an-object)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.2 [什么是对象？](ch_objects.html#what-is-an-object)
- en: 28.2.1 [The two ways of using objects](ch_objects.html#ways-of-using-objects)
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.2.1 [使用对象的两种方式](ch_objects.html#ways-of-using-objects)
- en: 28.3 [Fixed-layout objects](ch_objects.html#fixed-layout-objects)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.3 [固定布局对象](ch_objects.html#fixed-layout-objects)
- en: '28.3.1 [Object literals: properties](ch_objects.html#object-literals)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.3.1 [对象文字：属性](ch_objects.html#object-literals)
- en: '28.3.2 [Object literals: property value shorthands](ch_objects.html#object-literals-property-value-shorthands)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.3.2 [对象文字：属性值简写](ch_objects.html#object-literals-property-value-shorthands)
- en: 28.3.3 [Getting properties](ch_objects.html#getting-properties)
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.3.3 [获取属性](ch_objects.html#getting-properties)
- en: 28.3.4 [Setting properties](ch_objects.html#setting-properties)
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.3.4 [设置属性](ch_objects.html#setting-properties)
- en: '28.3.5 [Object literals: methods](ch_objects.html#object-literals-methods)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.3.5 [对象文字：方法](ch_objects.html#object-literals-methods)
- en: '28.3.6 [Object literals: accessors](ch_objects.html#object-literal-accessors)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.3.6 [对象文字：访问器](ch_objects.html#object-literal-accessors)
- en: 28.4 [Spreading into object literals (`...`) [ES2018]](ch_objects.html#spreading-into-object-literals)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.4 [扩展到对象文字(`...`)[ES2018]](ch_objects.html#spreading-into-object-literals)
- en: '28.4.1 [Use case for spreading: copying objects](ch_objects.html#use-case-for-spreading-copying-objects)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.4.1 [扩展的用例：复制对象](ch_objects.html#use-case-for-spreading-copying-objects)
- en: '28.4.2 [Use case for spreading: default values for missing properties](ch_objects.html#use-case-for-spreading-default-values-for-missing-properties)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.4.2 [扩展的用例：缺失属性的默认值](ch_objects.html#use-case-for-spreading-default-values-for-missing-properties)
- en: '28.4.3 [Use case for spreading: non-destructively changing properties](ch_objects.html#use-case-for-spreading-non-destructively-changing-properties)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.4.3 [扩展的用例：非破坏性地更改属性](ch_objects.html#use-case-for-spreading-non-destructively-changing-properties)
- en: '28.4.4 [“Destructive spreading”: `Object.assign()` [ES6]](ch_objects.html#destructive-spreading-object.assign-es6)'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.4.4 [“破坏性扩展”：`Object.assign()`[ES6]](ch_objects.html#destructive-spreading-object.assign-es6)
- en: 28.5 [Methods and the special variable `this`](ch_objects.html#methods-and-this)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.5 [方法和特殊变量`this`](ch_objects.html#methods-and-this)
- en: 28.5.1 [Methods are properties whose values are functions](ch_objects.html#methods-are-properties-whose-values-are-functions)
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.5.1 [方法是其值为函数的属性](ch_objects.html#methods-are-properties-whose-values-are-functions)
- en: 28.5.2 [The special variable `this`](ch_objects.html#the-special-variable-this)
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.5.2 [特殊变量`this`](ch_objects.html#the-special-variable-this)
- en: 28.5.3 [Methods and `.call()`](ch_objects.html#methods-call)
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.5.3 [方法和`.call()`](ch_objects.html#methods-call)
- en: 28.5.4 [Methods and `.bind()`](ch_objects.html#methods-bind)
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.5.4 [方法和`.bind()`](ch_objects.html#methods-bind)
- en: '28.5.5 [`this` pitfall: extracting methods](ch_objects.html#extracting-methods)'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.5.5 [`this`陷阱：提取方法](ch_objects.html#extracting-methods)
- en: '28.5.6 [`this` pitfall: accidentally shadowing `this`](ch_objects.html#shadowing-this)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.5.6 [`this`陷阱：意外遮蔽`this`](ch_objects.html#shadowing-this)
- en: 28.5.7 [The value of `this` in various contexts (advanced)](ch_objects.html#the-value-of-this-in-various-contexts-advanced)
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.5.7 [`this`在各种上下文中的值（高级）](ch_objects.html#the-value-of-this-in-various-contexts-advanced)
- en: 28.6 [Optional chaining for property getting and method calls [ES2020] (advanced)](ch_objects.html#optional-chaining)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.6 [可选链接用于属性获取和方法调用[ES2020]（高级）](ch_objects.html#optional-chaining)
- en: '28.6.1 [Example: optional fixed property getting](ch_objects.html#example-optional-fixed-property-getting)'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.6.1 [示例：可选的固定属性获取](ch_objects.html#example-optional-fixed-property-getting)
- en: 28.6.2 [The operators in more detail (advanced)](ch_objects.html#the-operators-in-more-detail-advanced)
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.6.2 [更详细的操作符（高级）](ch_objects.html#the-operators-in-more-detail-advanced)
- en: 28.6.3 [Short-circuiting with optional property getting](ch_objects.html#short-circuiting-with-optional-property-getting)
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.6.3 [可选属性获取的短路](ch_objects.html#short-circuiting-with-optional-property-getting)
- en: '28.6.4 [Optional chaining: downsides and alternatives](ch_objects.html#optional-chaining-downsides-and-alternatives)'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.6.4 [可选链接：缺点和替代方案](ch_objects.html#optional-chaining-downsides-and-alternatives)
- en: 28.6.5 [Frequently asked questions](ch_objects.html#frequently-asked-questions)
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.6.5 [常见问题](ch_objects.html#frequently-asked-questions)
- en: 28.7 [Dictionary objects (advanced)](ch_objects.html#dictionary-objects-advanced)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.7 [字典对象（高级）](ch_objects.html#dictionary-objects-advanced)
- en: 28.7.1 [Quoted keys in object literals](ch_objects.html#object-literals-quoted-keys)
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.7.1 [对象文字中的引用键](ch_objects.html#object-literals-quoted-keys)
- en: 28.7.2 [Computed keys in object literals](ch_objects.html#object-literals-computed-keys)
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.7.2 [对象文字中的计算键](ch_objects.html#object-literals-computed-keys)
- en: '28.7.3 [The `in` operator: is there a property with a given key?](ch_objects.html#in-operator)'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.7.3 [`in`运算符：是否存在具有给定键的属性？](ch_objects.html#in-operator)
- en: 28.7.4 [Deleting properties](ch_objects.html#deleting-properties)
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.7.4 [删除属性](ch_objects.html#deleting-properties)
- en: 28.7.5 [Enumerability](ch_objects.html#enumerability)
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.7.5 [可枚举性](ch_objects.html#enumerability)
- en: 28.7.6 [Listing property keys via `Object.keys()` etc.](ch_objects.html#listing-property-keys-via-object.keys-etc.)
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.7.6 [通过`Object.keys()`等列出属性键](ch_objects.html#listing-property-keys-via-object.keys-etc.)
- en: 28.7.7 [Listing property values via `Object.values()`](ch_objects.html#Object.values)
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.7.7 [通过`Object.values()`列出属性值](ch_objects.html#Object.values)
- en: 28.7.8 [Listing property entries via `Object.entries()` [ES2017]](ch_objects.html#Object.entries)
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.7.8 [通过`Object.entries()`列出属性条目[ES2017]](ch_objects.html#Object.entries)
- en: 28.7.9 [Properties are listed deterministically](ch_objects.html#order-of-properties)
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.7.9 [属性被确定性地列出](ch_objects.html#order-of-properties)
- en: 28.7.10 [Assembling objects via `Object.fromEntries()` [ES2019]](ch_objects.html#Object.fromEntries)
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.7.10 [通过`Object.fromEntries()`组装对象[ES2019]](ch_objects.html#Object.fromEntries)
- en: 28.7.11 [The pitfalls of using an object as a dictionary](ch_objects.html#the-pitfalls-of-using-an-object-as-a-dictionary)
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.7.11 使用对象作为字典的陷阱
- en: 28.8 [Property attributes and freezing objects (advanced)](ch_objects.html#property-attributes-and-freezing-objects-advanced)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.8 [属性特性和冻结对象（高级）](ch_objects.html#property-attributes-and-freezing-objects-advanced)
- en: 28.8.1 [Property attributes and property descriptors [ES5]](ch_objects.html#property-attributes-property-descriptors)
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.8.1 [属性特性和属性描述符[ES5]](ch_objects.html#property-attributes-property-descriptors)
- en: 28.8.2 [Freezing objects [ES5]](ch_objects.html#freezing-objects-es5)
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.8.2 [冻结对象[ES5]](ch_objects.html#freezing-objects-es5)
- en: 28.9 [Prototype chains](ch_objects.html#prototype-chains)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.9 [原型链](ch_objects.html#prototype-chains)
- en: '28.9.1 [JavaScript’s operations: all properties vs. own properties](ch_objects.html#javascripts-operations-all-properties-vs.-own-properties)'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.9.1 [JavaScript的操作：所有属性 vs. 自有属性](ch_objects.html#javascripts-operations-all-properties-vs.-own-properties)
- en: '28.9.2 [Pitfall: only the first member of a prototype chain is mutated](ch_objects.html#pitfall-only-the-first-member-of-a-prototype-chain-is-mutated)'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.9.2 陷阱：原型链中只有第一个成员被改变
- en: 28.9.3 [Tips for working with prototypes (advanced)](ch_objects.html#tips-for-working-with-prototypes-advanced)
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.9.3 [使用原型的技巧（高级）](ch_objects.html#tips-for-working-with-prototypes-advanced)
- en: '28.9.4 [`Object.hasOwn()`: Is a given property own (non-inherited)? [ES2022]](ch_objects.html#Object.hasOwn)'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '28.9.4 [`Object.hasOwn()`: 给定属性是否为自有（非继承）？[ES2022]](ch_objects.html#Object.hasOwn)'
- en: 28.9.5 [Sharing data via prototypes](ch_objects.html#sharing-data-via-prototypes)
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.9.5 [通过原型共享数据](ch_objects.html#sharing-data-via-prototypes)
- en: '28.10 [FAQ: objects](ch_objects.html#faq-objects)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.10 [FAQ：对象](ch_objects.html#faq-objects)
- en: 28.10.1 [Why do objects preserve the insertion order of properties?](ch_objects.html#why-do-objects-preserve-the-insertion-order-of-properties)
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28.10.1 [为什么对象保留属性的插入顺序？](ch_objects.html#why-do-objects-preserve-the-insertion-order-of-properties)
- en: '* * *'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'In this book, JavaScript’s style of object-oriented programming (OOP) is introduced
    in four steps. This chapter covers step 1 and 2; [the next chapter](ch_classes.html)
    covers step 3 and 4\. The steps are (fig. [8](#fig:oop_steps_1_2)):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，JavaScript的面向对象编程（OOP）风格分四步介绍。本章涵盖了第1步和第2步；[下一章](ch_classes.html)涵盖了第3步和第4步。这些步骤是（图[8](#fig:oop_steps_1_2)）：
- en: '**Single objects (this chapter):** How do *objects*, JavaScript’s basic OOP
    building blocks, work in isolation?'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单个对象（本章）：** *对象*，JavaScript的基本OOP构建块，在孤立状态下如何工作？'
- en: '**Prototype chains (this chapter):** Each object has a chain of zero or more
    *prototype objects*. Prototypes are JavaScript’s core inheritance mechanism.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**原型链（本章）：** 每个对象都有零个或多个*原型对象*链。原型是JavaScript的核心继承机制。'
- en: '**Classes (next chapter):** JavaScript’s *classes* are factories for objects.
    The relationship between a class and its instances is based on prototypal inheritance
    (step 2).'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**类（下一章）：** JavaScript的*类*是对象的工厂。类与其实例之间的关系基于原型继承（第2步）。'
- en: '**Subclassing (next chapter):** The relationship between a *subclass* and its
    *superclass* is also based on prototypal inheritance.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**子类（下一章）：** *子类* 与 *超类* 之间的关系也是基于原型继承的。'
- en: '![Figure 8: This book introduces object-oriented programming in JavaScript
    in four steps.](../Images/77a1456d5bcb274b676345e01127a1b5.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图8：本书分四步介绍JavaScript中的面向对象编程。](../Images/77a1456d5bcb274b676345e01127a1b5.png)'
- en: 'Figure 8: This book introduces object-oriented programming in JavaScript in
    four steps.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：本书分四步介绍JavaScript中的面向对象编程。
- en: '28.1 Cheat sheet: objects'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.1 对象速查表
- en: 28.1.1 Single objects
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.1.1 单个对象
- en: 'Creating an object via an *object literal* (starts and ends with a curly brace):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过*对象字面量*创建对象（以大括号开始和结束）：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Being able to create objects directly (without classes) is one of the highlights
    of JavaScript.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 能够直接创建对象（无需类）是JavaScript的一个亮点。
- en: 'Spreading into objects:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展为对象：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can also use spreading to make an unmodified (shallow) copy of an object:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用扩展来制作对象的未修改（浅层）副本：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 28.1.2 Prototype chains
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.1.2 原型链
- en: Prototypes are JavaScript’s fundamental inheritance mechanism. Even classes
    are based on it. Each object has `null` or an object as its prototype. The latter
    object can also have a prototype, etc. In general, we get *chains* of prototypes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 原型是JavaScript的基本继承机制。甚至类也是基于它构建的。每个对象的原型都是`null`或一个对象。后者的对象也可以有原型，依此类推。通常，我们得到原型的*链*。
- en: 'Prototypes are managed like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 原型的管理方式如下：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notes:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注：
- en: 'Setting an object’s prototype while creating the object: line A, line C'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建对象时设置对象的原型：A行，C行
- en: 'Retrieving the prototype of an object: line B'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索对象的原型：B行
- en: 'Each object inherits all the properties of its prototype:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都继承其原型的所有属性：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The non-inherited properties of an object are called its *own* properties.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的非继承属性称为其*自有*属性。
- en: The most important use case for prototypes is that several objects can share
    methods by inheriting them from a common prototype.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 原型最重要的用例是多个对象可以通过从共同原型继承方法来共享它们。
- en: 28.2 What is an object?
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.2 什么是对象？
- en: 'Objects in JavaScript:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的对象：
- en: An object is a set of slots (key-value entries).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象是一组槽（键值条目）。
- en: 'Public slots are called *properties*:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共槽称为*属性*：
- en: A property key can only be a string or a symbol.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性键只能是字符串或符号。
- en: Private slots can only be created via classes and are explained in [§29.2.4
    “Public slots (properties) vs. private slots”](ch_classes.html#private-slots).
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有槽只能通过类创建，并在[§29.2.4“公共槽（属性）vs. 私有槽”](ch_classes.html#private-slots)中进行了解。
- en: 28.2.1 The two ways of using objects
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.2.1 使用对象的两种方式
- en: 'There are two ways of using objects in JavaScript:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中有两种使用对象的方式：
- en: 'Fixed-layout objects: Used this way, objects work like records in databases.
    They have a fixed number of properties, whose keys are known at development time.
    Their values generally have different types.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定布局对象：以这种方式使用，对象就像数据库中的记录一样工作。它们具有固定数量的属性，其键在开发时已知。它们的值通常具有不同的类型。
- en: '[PRE5]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Dictionary objects: Used this way, objects work like lookup tables or maps.
    They have a variable number of properties, whose keys are not known at development
    time. All of their values have the same type.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典对象：以这种方式使用，对象就像查找表或映射一样。它们具有可变数量的属性，其键在开发时未知。它们的所有值都具有相同的类型。
- en: '[PRE6]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that the two ways can also be mixed: Some objects are both fixed-layout
    objects and dictionary objects.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两种方式也可以混合使用：有些对象既是固定布局对象，又是字典对象。
- en: 'The ways of using objects influence how they are explained in this chapter:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象的方式会影响它们在本章中的解释：
- en: First, we’ll explore fixed-layout objects. Even though property keys are strings
    or symbols under the hood, they will appear as fixed identifiers to us.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将探索固定布局对象。即使属性键在底层是字符串或符号，它们对我们来说将显示为固定标识符。
- en: Later, we’ll explore dictionary objects. Note that [Maps](ch_maps.html) are
    usually better dictionaries than objects. However, some of the operations that
    we’ll encounter are also useful for fixed-layout objects.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稍后，我们将探索字典对象。请注意，[Maps](ch_maps.html)通常比对象更好地充当字典。但是，我们将遇到的一些操作对于固定布局对象也很有用。
- en: 28.3 Fixed-layout objects
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.3 固定布局对象
- en: Let’s first explore *fixed-layout objects*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先探索*固定布局对象*。
- en: '28.3.1 Object literals: properties'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.3.1 对象文字：属性
- en: '*Object literals* are one way of creating fixed-layout objects. They are a
    stand-out feature of JavaScript: we can directly create objects – no need for
    classes! This is an example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象文字*是创建固定布局对象的一种方式。它们是JavaScript的一个突出特点：我们可以直接创建对象-无需类！这是一个例子：'
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the example, we created an object via an object literal, which starts and
    ends with curly braces `{}`. Inside it, we defined two *properties* (key-value
    entries):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们通过对象文字创建了一个对象，它以大括号`{}`开头和结尾。在其中，我们定义了两个*属性*（键值条目）：
- en: The first property has the key `first` and the value `'Jane'`.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个属性的键是`first`，值为`'Jane'`。
- en: The second property has the key `last` and the value `'Doe'`.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个属性的键是`last`，值为`'Doe'`。
- en: Since ES5, trailing commas are allowed in object literals.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 自ES5以来，对象文字中允许使用尾随逗号。
- en: 'We will later see other ways of specifying property keys, but with this way
    of specifying them, they must follow the rules of JavaScript variable names. For
    example, we can use `first_name` as a property key, but not `first-name`). However,
    reserved words are allowed:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以后看到指定属性键的其他方法，但是使用这种指定方式，它们必须遵循JavaScript变量名称的规则。例如，我们可以使用`first_name`作为属性键，但不能使用`first-name`）。但是，保留字是允许的。
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In order to check the effects of various operations on objects, we’ll occasionally
    use `Object.keys()` in this part of the chapter. It lists property keys:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查各种操作对对象的影响，我们将在本章的这一部分偶尔使用`Object.keys()`。它列出属性键：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '28.3.2 Object literals: property value shorthands'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.3.2 对象文字：属性值简写
- en: Whenever the value of a property is defined via a variable that has the same
    name as the key, we can omit the key.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每当属性的值是通过与键同名的变量定义的时候，我们可以省略键。
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 28.3.3 Getting properties
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.3.3 获取属性
- en: 'This is how we *get* (read) a property (line A):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们*获取*（读取）属性的方式（A行）：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Getting an unknown property produces `undefined`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 获取未知属性会产生`undefined`：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 28.3.4 Setting properties
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.3.4 设置属性
- en: 'This is how we *set* (write to) a property (line A):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们*设置*（写入）属性的方式（A行）：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We just changed an existing property via setting. If we set an unknown property,
    we create a new entry:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚通过设置更改了现有属性。如果我们设置一个未知的属性，我们将创建一个新条目：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '28.3.5 Object literals: methods'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.3.5 对象文字：方法
- en: 'The following code shows how to create the method `.says()` via an object literal:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何通过对象文字创建方法`.says()`：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: During the method call `jane.says('hello')`, `jane` is called the *receiver*
    of the method call and assigned to the special variable `this` (more on `this`
    in [§28.5 “Methods and the special variable `this`”](ch_objects.html#methods-and-this)).
    That enables method `.says()` to access the sibling property `.first` in line
    A.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法调用`jane.says('hello')`期间，`jane`被称为方法调用的*接收者*，并分配给特殊变量`this`（有关`this`的更多信息，请参见[§28.5“方法和特殊变量`this`”](ch_objects.html#methods-and-this)）。这使得方法`.says()`能够访问A行中的兄弟属性`.first`。
- en: '28.3.6 Object literals: accessors'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.3.6 对象文字：访问器
- en: 'An *accessor* is defined via syntax inside an object literal that looks like
    methods: a *getter* and/or a *setter* (i.e., each accessor has one or both of
    them).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对象文字内部的语法定义*访问器*，看起来像方法：*getter*和/或*setter*（即，每个访问器都有一个或两个）。
- en: 'Invoking an accessor looks like accessing a value property:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 调用访问器看起来像访问值属性：
- en: Reading the property invokes the getter.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取属性会调用getter。
- en: Writing to the property invokes the setter.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入属性会调用setter。
- en: 28.3.6.1 Getters
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 28.3.6.1 获取器
- en: 'A getter is created by prefixing a method definition with the modifier `get`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在方法定义前加上修饰符`get`来创建getter：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 28.3.6.2 Setters
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 28.3.6.2 设置器
- en: 'A setter is created by prefixing a method definition with the modifier `set`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在方法定义前加上修饰符`set`来创建setter：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Creating an
    object via an object literal**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png) **练习：通过对象文字创建对象**'
- en: '`exercises/objects/color_point_object_test.mjs`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/objects/color_point_object_test.mjs`'
- en: 28.4 Spreading into object literals (`...`) [ES2018]
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.4 扩展到对象文字（`...`）[ES2018]
- en: 'Inside an object literal, a *spread property* adds the properties of another
    object to the current one:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象文字中，*扩展属性*将另一个对象的属性添加到当前对象中：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If property keys clash, the property that is mentioned last “wins”:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性键冲突，最后提到的属性将“获胜”：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'All values are spreadable, even `undefined` and `null`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所有值都是可扩展的，甚至`undefined`和`null`：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Property `.length` of strings and Arrays is hidden from this kind of operation
    (it is not *enumerable*; see [§28.8.1 “Property attributes and property descriptors
    [ES5]”](ch_objects.html#property-attributes-property-descriptors) for more information).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串和数组的属性`.length`被隐藏在这种操作中（它不是*可枚举*的；有关更多信息，请参见[§28.8.1“属性属性和属性描述符[ES5]”](ch_objects.html#property-attributes-property-descriptors)）。
- en: 'Spreading includes properties whose keys are symbols (which are ignored by
    `Object.keys()`, `Object.values()` and `Object.entries()`):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展包括其键为符号的属性（这些符号被`Object.keys()`，`Object.values()`和`Object.entries()`忽略）：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '28.4.1 Use case for spreading: copying objects'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.4.1 扩展的用例：复制对象
- en: 'We can use spreading to create a copy of an object `original`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用扩展来创建对象`original`的副本：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Caveat – copying is *shallow*: `copy` is a fresh object with duplicates of
    all properties (key-value entries) of `original`. But if property values are objects,
    then those are not copied themselves; they are shared between `original` and `copy`.
    Let’s look at an example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 - 复制是*浅层*的：`copy`是一个全新的对象，其中包含`original`的所有属性（键值条目）的副本。但是，如果属性值是对象，则这些对象本身不会被复制；它们在`original`和`copy`之间共享。让我们看一个例子：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first level of `copy` is really a copy: If we change any properties at
    that level, it does not affect the original:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy`的第一级确实是一个副本：如果我们更改该级别的任何属性，它不会影响原始对象：'
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: However, deeper levels are not copied. For example, the value of `.b` is shared
    between original and copy. Changing `.b` in the copy also changes it in the original.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，深层次的内容不会被复制。例如，`.b`的值在原始对象和副本之间共享。在副本中更改`.b`也会在原始对象中更改它。
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![](../Images/0ac255e56dc93a43365d8502301c8688.png)  **JavaScript doesn’t have
    built-in support for deep copying**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/0ac255e56dc93a43365d8502301c8688.png) **JavaScript没有内置支持深复制**'
- en: '*Deep copies* of objects (where all levels are copied) are notoriously difficult
    to do generically. Therefore, JavaScript does not have a built-in operation for
    them (for now). If we need such an operation, we have to implement it ourselves.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的*深复制*（其中所有级别都被复制）通常很难以通用方式实现。因此，JavaScript目前没有内置操作。如果我们需要这样的操作，我们必须自己实现它。
- en: '28.4.2 Use case for spreading: default values for missing properties'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.4.2 扩展的用例：缺少属性的默认值
- en: 'If one of the inputs of our code is an object with data, we can make properties
    optional by specifying default values that are used if those properties are missing.
    One technique for doing so is via an object whose properties contain the default
    values. In the following example, that object is `DEFAULTS`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的代码的输入之一是具有数据的对象，则可以通过指定默认值使属性变为可选，如果缺少这些属性，则使用这些默认值。其中一种方法是通过包含默认值的对象。在下面的示例中，该对象是`DEFAULTS`：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The result, the object `allData`, is created by copying `DEFAULTS` and overriding
    its properties with those of `providedData`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 结果对象`allData`是通过复制`DEFAULTS`并用`providedData`的属性覆盖其属性而创建的。
- en: 'But we don’t need an object to specify the default values; we can also specify
    them inside the object literal, individually:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们不需要对象来指定默认值；我们也可以在对象文字中单独指定它们：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '28.4.3 Use case for spreading: non-destructively changing properties'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.4.3 扩展的用例：非破坏性地更改属性
- en: 'So far, we have encountered one way of changing a property `.alpha` of an object:
    We *set* it (line A) and mutate the object. That is, this way of changing a property
    is destructive.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经遇到了一种更改对象的属性`.alpha`的方法：我们*设置*它（A行）并改变对象。也就是说，这种更改属性的方式是破坏性的。
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With spreading, we can change `.alpha` non-destructively – we make a copy of
    `obj` where `.alpha` has a different value:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展，我们可以非破坏性地更改`.alpha` - 我们复制了`obj`的副本，其中`.alpha`具有不同的值：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Non-destructively
    updating a property via spreading (fixed key)**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png) **练习：通过扩展（固定键）非破坏性地更新属性**'
- en: '`exercises/objects/update_name_test.mjs`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/objects/update_name_test.mjs`'
- en: '28.4.4 “Destructive spreading”: `Object.assign()` [ES6]'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.4.4 “破坏性扩展”：`Object.assign()` [ES6]
- en: '`Object.assign()` is a tool method:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign()`是一个工具方法：'
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This expression assigns all properties of `source_1` to `target`, then all
    properties of `source_2`, etc. At the end, it returns `target` – for example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此表达式将`source_1`的所有属性分配给`target`，然后将`source_2`的所有属性等。最后，它返回`target` - 例如：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The use cases for `Object.assign()` are similar to those for spread properties.
    In a way, it spreads destructively.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign()`的用例与扩展属性的用例类似。在某种程度上，它是破坏性地扩展。'
- en: 28.5 Methods and the special variable `this`
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.5 方法和特殊变量`this`
- en: 28.5.1 Methods are properties whose values are functions
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.5.1 方法是其值为函数的属性
- en: 'Let’s revisit the example that was used to introduce methods:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新访问用于介绍方法的示例：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Somewhat surprisingly, methods are functions:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有些令人惊讶的是，方法就是函数：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Why is that? We learned [in the chapter on callable values](ch_callables.html#roles-of-ordinary-functions)
    that ordinary functions play several roles. *Method* is one of those roles. Therefore,
    internally, `jane` roughly looks as follows.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？我们在[可调用值章节](ch_callables.html#roles-of-ordinary-functions)中学到，普通函数扮演了几种角色。*方法*是其中之一。因此，在内部，`jane`大致如下。
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 28.5.2 The special variable `this`
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.5.2 特殊变量`this`
- en: 'Consider the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In line B, `obj` is the *receiver* of a method call. It is passed to the function
    stored in `obj.someMethod` via an implicit (hidden) parameter whose name is `this`
    (line A).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在B行，`obj`是方法调用的*接收者*。它通过一个隐式（隐藏）参数传递给存储在`obj.someMethod`中的函数，其名称为`this`（A行）。
- en: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png)  **How to understand `this`**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png) **如何理解`this`**'
- en: The best way to understand `this` is as an implicit parameter of ordinary functions
    (and therefore methods, too).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 理解`this`的最佳方法是将其视为普通函数（因此也是方法）的隐式参数。
- en: 28.5.3 Methods and `.call()`
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.5.3 方法和`.call()`
- en: Methods are functions and functions have methods themselves. One of those methods
    is [`.call()`](ch_callables.html#Function.prototype.call). Let’s look at an example
    to understand how this method works.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是函数，函数本身也有方法。其中之一是[`.call()`](ch_callables.html#Function.prototype.call)。让我们看一个例子来了解这个方法是如何工作的。
- en: 'In the previous section, there was this method invocation:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，有这种方法调用：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This invocation is equivalent to:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这种调用等同于：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Which is also equivalent to:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这也等同于：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`.call()` makes the normally implicit parameter `this` explicit: When invoking
    a function via `.call()`, the first parameter is `this`, followed by the regular
    (explicit) function parameters.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`.call()`使通常隐含的参数`this`变得显式：当通过`.call()`调用函数时，第一个参数是`this`，然后是常规（显式）函数参数。'
- en: 'As an aside, this means that there are actually two different dot operators:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，这意味着实际上有两个不同的点运算符：
- en: 'One for accessing properties: `obj.prop`'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个用于访问属性：`obj.prop`
- en: 'Another one for calling methods: `obj.prop()`'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个用于调用方法：`obj.prop()`
- en: They are different in that (2) is not just (1) followed by the function call
    operator `()`. Instead, (2) additionally provides a value for `this`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的不同之处在于（2）不仅仅是（1）后面跟着函数调用运算符`()`。相反，（2）还提供了`this`的值。
- en: 28.5.4 Methods and `.bind()`
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.5.4 方法和`.bind()`
- en: '[`.bind()`](ch_callables.html#Function.prototype.bind) is another method of
    function objects. In the following code, we use `.bind()` to turn method `.says()`
    into the stand-alone function `func()`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[`.bind()`](ch_callables.html#Function.prototype.bind)是函数对象的另一个方法。在下面的代码中，我们使用`.bind()`将方法`.says()`转换为独立的函数`func()`：'
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Setting `this` to `jane` via `.bind()` is crucial here. Otherwise, `func()`
    wouldn’t work properly because `this` is used in line A. In the next section,
    we’ll explore why that is.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`.bind()`将`this`设置为`jane`在这里至关重要。否则，`func()`将无法正常工作，因为`this`在A行中使用。在下一节中，我们将探讨为什么会这样。
- en: '28.5.5 `this` pitfall: extracting methods'
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.5.5 `this`陷阱：提取方法
- en: 'We now know quite a bit about functions and methods and are ready to take a
    look at the biggest pitfall involving methods and `this`: function-calling a method
    extracted from an object can fail if we are not careful.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对函数和方法有了相当多的了解，并且准备好看看涉及方法和`this`的最大陷阱：如果我们不小心，从对象中提取的方法进行函数调用可能会失败。
- en: In the following example, we fail when we extract method `jane.says()`, store
    it in the variable `func`, and function-call `func`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，当我们提取方法`jane.says()`，将其存储在变量`func`中，并调用`func`时，我们失败了。
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In line A, we are making a normal function call. And in normal function calls,
    `this` is `undefined` (if [strict mode](ch_syntax.html#strict-mode) is active,
    which it almost always is). Line A is therefore equivalent to:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在A行，我们正在进行普通函数调用。在普通函数调用中，`this`是`undefined`（如果[严格模式](ch_syntax.html#strict-mode)激活，几乎总是激活的）。因此，A行等价于：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'How do we fix this? We need to use `.bind()` to extract method `.says()`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题？我们需要使用`.bind()`来提取方法`.says()`：
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `.bind()` ensures that `this` is always `jane` when we call `func()`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`.bind()`确保我们调用`func()`时`this`始终是`jane`。'
- en: 'We can also use arrow functions to extract methods:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用箭头函数来提取方法：
- en: '[PRE44]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '28.5.5.1 Example: extracting a method'
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 28.5.5.1 示例：提取一个方法
- en: 'The following is a simplified version of code that we may see in actual web
    development:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在实际网页开发中可能看到的代码的简化版本：
- en: '[PRE45]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In line A, we don’t extract the method `.handleClick()` properly. Instead,
    we should do:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在A行，我们没有正确提取方法`.handleClick()`。相反，我们应该这样做：
- en: '[PRE46]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Each invocation of `.bind()` creates a new function. That’s why we need to store
    the result somewhere if we want to remove it later on.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`.bind()`都会创建一个新函数。这就是为什么如果我们想要稍后删除它，就需要将结果存储在某个地方。
- en: 28.5.5.2 How to avoid the pitfall of extracting methods
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 28.5.5.2 如何避免提取方法的陷阱
- en: 'Alas, there is no simple way around the pitfall of extracting methods: Whenever
    we extract a method, we have to be careful and do it properly – for example, by
    binding `this` or by using an arrow function.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，没有简单的方法可以避免提取方法的陷阱：每当我们提取一个方法时，都必须小心并正确地处理它 - 例如，通过绑定`this`或使用箭头函数。
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Extracting
    a method**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png) **练习：提取一个方法**'
- en: '`exercises/objects/method_extraction_exrc.mjs`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/objects/method_extraction_exrc.mjs`'
- en: '28.5.6 `this` pitfall: accidentally shadowing `this`'
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.5.6 `this`陷阱：意外遮蔽`this`
- en: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png)  **Accidentally shadowing
    `this` is only an issue with ordinary functions**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png) **意外遮蔽`this`只是普通函数的问题**'
- en: Arrow functions don’t shadow `this`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数不会遮蔽`this`。
- en: 'Consider the following problem: when we are inside an ordinary function, we
    can’t access the `this` of the surrounding scope because the ordinary function
    has its own `this`. In other words, a variable in an inner scope hides a variable
    in an outer scope. That is called [*shadowing*](ch_variables-assignment.html#shadowing-variables).
    The following code is an example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下问题：当我们在普通函数内部时，我们无法访问周围范围的`this`，因为普通函数有它自己的`this`。换句话说，内部作用域中的变量隐藏了外部作用域中的变量。这就是所谓的[*遮蔽*](ch_variables-assignment.html#shadowing-variables)。以下代码是一个例子：
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In line A, we want to access the `this` of `.prefixStringArray()`. But we can’t
    since the surrounding ordinary function has its own `this` that *shadows* (and
    blocks access to) the `this` of the method. The value of the former `this` is
    `undefined` due to the callback being function-called. That explains the error
    message.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在A行，我们想要访问`.prefixStringArray()`的`this`。但我们不能，因为周围的普通函数有它自己的`this`，*遮蔽*了（并阻止访问）方法的`this`。前者的`this`的值是`undefined`，因为回调函数被函数调用。这解释了错误消息。
- en: 'The simplest way to fix this problem is via an arrow function, which doesn’t
    have its own `this` and therefore doesn’t shadow anything:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 修复这个问题的最简单方法是使用箭头函数，它没有自己的`this`，因此不会遮蔽任何东西：
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can also store `this` in a different variable (line A), so that it doesn’t
    get shadowed:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将`this`存储在不同的变量中（A行），这样它就不会被遮蔽：
- en: '[PRE49]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Another option is to specify a fixed `this` for the callback via `.bind()`
    (line A):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是通过`.bind()`（第A行）为回调函数指定一个固定的`this`：
- en: '[PRE50]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Lastly, `.map()` lets us specify a value for `this` (line A) that it uses when
    invoking the callback:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`.map()`让我们指定一个值作为`this`（A行），在调用回调函数时使用：
- en: '[PRE51]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 28.5.6.1 Avoiding the pitfall of accidentally shadowing `this`
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 28.5.6.1 避免意外遮蔽`this`的陷阱
- en: 'If we follow the advice in [§25.3.4 “Recommendation: prefer specialized functions
    over ordinary functions”](ch_callables.html#prefer-specialized-functions), we
    can avoid the pitfall of accidentally shadowing `this`. This is a summary:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遵循[§25.3.4“建议：优先使用专门的函数而不是普通函数”](ch_callables.html#prefer-specialized-functions)中的建议，我们可以避免意外遮蔽`this`的陷阱。这是一个总结：
- en: Use arrow functions as anonymous inline functions. They don’t have `this` as
    an implicit parameter and don’t shadow it.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用箭头函数作为匿名内联函数。它们没有`this`作为隐式参数，也不会遮蔽它。
- en: For named stand-alone function declarations we can either use arrow functions
    or function declarations. If we do the latter, we have to make sure `this` isn’t
    mentioned in their bodies.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于命名的独立函数声明，我们可以使用箭头函数或函数声明。如果我们选择后者，就必须确保它们的主体中没有提到`this`。
- en: 28.5.7 The value of `this` in various contexts (advanced)
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.5.7 各种上下文中`this`的值（高级）
- en: What is the value of `this` in various contexts?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在各种上下文中`this`的值是多少？
- en: 'Inside a callable entity, the value of `this` depends on how the callable entity
    is invoked and what kind of callable entity it is:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在可调用实体内，`this`的值取决于可调用实体的调用方式和可调用实体的类型：
- en: 'Function call:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数调用：
- en: 'Ordinary functions: `this === undefined` (in [strict mode](ch_syntax.html#strict-mode))'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通函数：`this === undefined`（在[严格模式](ch_syntax.html#strict-mode)下）
- en: 'Arrow functions: `this` is same as in surrounding scope (lexical `this`)'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数：`this`与周围作用域相同（词法`this`）
- en: 'Method call: `this` is receiver of call'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法调用：`this`是调用的接收者
- en: '`new`: `this` refers to the newly created instance'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new`：`this`指的是新创建的实例'
- en: 'We can also access `this` in all common top-level scopes:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在所有常见的顶层作用域中访问`this`：
- en: '`<script>` element: `this === globalThis`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<script>`元素：`this === globalThis`'
- en: 'ECMAScript modules: `this === undefined`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript模块：`this === undefined`
- en: 'CommonJS modules: `this === module.exports`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CommonJS模块：`this === module.exports`
- en: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png)  **Tip: pretend that `this`
    doesn’t exist in top-level scopes**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png) **提示：假装顶层作用域中不存在`this`**'
- en: I like to do that because top-level `this` is confusing and there are better
    alternatives for its (few) use cases.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢这样做是因为顶层的`this`很令人困惑，而且对于它的（少数）用例有更好的替代方案。
- en: 28.6 Optional chaining for property getting and method calls [ES2020] (advanced)
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.6 可选链用于属性获取和方法调用[ES2020]（高级）
- en: 'The following kinds of optional chaining operations exist:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 存在以下种类的可选链操作：
- en: '[PRE52]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The rough idea is:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 大致的想法是：
- en: If the value before the question mark is neither `undefined` nor `null`, then
    perform the operation after the question mark.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果问号前的值既不是`undefined`也不是`null`，那么执行问号后的操作。
- en: Otherwise, return `undefined`.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，返回`undefined`。
- en: 'Each of the three syntaxes is covered in more detail later. These are a few
    first examples:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种语法的每一种都会在后面更详细地介绍。以下是一些最初的例子：
- en: '[PRE53]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '28.6.1 Example: optional fixed property getting'
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.6.1 示例：可选的固定属性获取
- en: 'Consider the following data:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下数据：
- en: '[PRE54]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can use optional chaining to safely extract street names:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用可选链来安全地提取街道名称：
- en: '[PRE55]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 28.6.1.1 Handling defaults via nullish coalescing
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 28.6.1.1 通过nullish coalescing处理默认值
- en: 'The [nullish coalescing operator](ch_undefined-null.html#nullish-coalescing-operator)
    allows us to use the default value `''(no name)''` instead of `undefined`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[nullish coalescing operator](ch_undefined-null.html#nullish-coalescing-operator)允许我们使用默认值`''(no
    name)''`而不是`undefined`：'
- en: '[PRE56]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 28.6.2 The operators in more detail (advanced)
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.6.2 更详细的操作符（高级）
- en: 28.6.2.1 Optional fixed property getting
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 28.6.2.1 可选的固定属性获取
- en: 'The following two expressions are equivalent:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个表达式是等价的：
- en: '[PRE57]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Examples:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 例子：
- en: '[PRE58]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 28.6.2.2 Optional dynamic property getting
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 28.6.2.2 可选的动态属性获取
- en: 'The following two expressions are equivalent:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个表达式是等价的：
- en: '[PRE59]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Examples:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 例子：
- en: '[PRE60]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 28.6.2.3 Optional function or method call
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 28.6.2.3 可选的函数或方法调用
- en: 'The following two expressions are equivalent:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个表达式是等价的：
- en: '[PRE61]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Examples:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 例子：
- en: '[PRE62]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Note that this operator produces an error if its left-hand side is not callable:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果可选链的左侧不可调用，则此运算符会产生错误：
- en: '[PRE63]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Why? The idea is that the operator only tolerates deliberate omissions. An uncallable
    value (other than `undefined` and `null`) is probably an error and should be reported,
    rather than worked around.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？这个想法是，该运算符只容忍有意的遗漏。一个不可调用的值（除了`undefined`和`null`之外）可能是一个错误，应该报告而不是绕过。
- en: 28.6.3 Short-circuiting with optional property getting
  id: totrans-304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.6.3 可选属性获取的短路
- en: 'In a chain of property gettings and method invocations, evaluation stops once
    the first optional operator encounters `undefined` or `null` at its left-hand
    side:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在一系列属性获取和方法调用中，一旦第一个可选运算符在其左侧遇到`undefined`或`null`，评估就会停止：
- en: '[PRE64]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Consider `invokeM(undefined)` in line B: `undefined?.a` is `undefined`. Therefore
    we’d expect `.b` to fail in line A. But it doesn’t: The `?.` operator encounters
    the value `undefined` and the evaluation of the whole expression immediately returns
    `undefined`.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在B行中考虑`invokeM(undefined)`：`undefined?.a`是`undefined`。因此我们期望A行中的`.b`失败。但实际上并不是：`?.`运算符遇到值`undefined`，整个表达式的评估立即返回`undefined`。
- en: 'This behavior differs from a normal operator where JavaScript always evaluates
    all operands before evaluating the operator. It is called *short-circuiting*.
    Other short-circuiting operators are:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为不同于普通运算符，JavaScript总是在评估运算符之前评估所有操作数。这被称为*短路*。其他短路运算符包括：
- en: '`(a && b)`: `b` is only evaluated if `a` is truthy.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(a && b)`: 只有在`a`为真时才评估`b`。'
- en: '`(a || b)`: `b` is only evaluated if `a` is falsy.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(a || b)`: 只有在`a`为假时才评估`b`。'
- en: '`(c ? t : e)`: If `c` is truthy, `t` is evaluated. Otherwise, `e` is evaluated.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(c ? t : e)`: 如果`c`为真，则评估`t`。否则，评估`e`。'
- en: '28.6.4 Optional chaining: downsides and alternatives'
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.6.4 可选链：缺点和替代方案
- en: 'Optional chaining also has downsides:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 可选链也有缺点：
- en: 'Deeply nested structures are more difficult to manage. For example, refactoring
    is harder if there are many sequences of property names: Each one enforces the
    structure of multiple objects.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度嵌套的结构更难管理。例如，如果有许多属性名称序列，重构会更加困难：每个序列都会强制多个对象的结构。
- en: Being so forgiving when accessing data hides problems that will surface much
    later and are then harder to debug. For example, a typo early in a sequence of
    optional property names has more negative effects than a normal typo.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在访问数据时如此宽容会隐藏问题，这些问题将在后来显现，并且更难以调试。例如，早期出现的可选属性名称序列中的拼写错误会产生比正常拼写错误更多的负面影响。
- en: 'An alternative to optional chaining is to extract the information once, in
    a single location:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 可选链的另一种方法是在一个位置提取信息一次：
- en: We can either write a helper function that extracts the data.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以编写一个辅助函数来提取数据。
- en: Or we can write a function whose input is deeply nested data and whose output
    is simpler, normalized data.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者我们可以编写一个函数，其输入是深度嵌套的数据，输出是更简单、规范化的数据。
- en: With either approach, it is possible to perform checks and to fail early if
    there are problems.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 通过任一方法，都可以进行检查并在出现问题时提前失败。
- en: 'Further reading:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步阅读：
- en: “[Overly defensive programming](https://medium.com/@vcarl/overly-defensive-programming-e7a1b3d234c2)”
    by [Carl Vitullo](https://twitter.com/vcarl_)
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “[过度防御性编程](https://medium.com/@vcarl/overly-defensive-programming-e7a1b3d234c2)”
    由 [Carl Vitullo](https://twitter.com/vcarl_)
- en: '[Thread on Twitter](https://twitter.com/housecor/status/1088419498846244864)
    by [Cory House](https://twitter.com/housecor)'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Twitter 上的讨论](https://twitter.com/housecor/status/1088419498846244864) 由 [Cory
    House](https://twitter.com/housecor)'
- en: 28.6.5 Frequently asked questions
  id: totrans-323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.6.5 经常问的问题
- en: 28.6.5.1 What is a good mnemonic for the optional chaining operator (`?.`)?
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 28.6.5.1 可选链操作符（`?.`）的好记忆法是什么？
- en: 'Are you occasionally unsure if the optional chaining operator starts with a
    dot (`.?`) or a question mark (`?.`)? Then this mnemonic may help you:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否偶尔不确定可选链操作符是以点号（`.?`）还是问号（`?.`）开始的？那么这个记忆法可能会帮助您：
- en: IF (`?`) the left-hand side is not nullish
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IF（`?`）左侧不是 nullish
- en: THEN (`.`) access a property.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: THEN（`.`）访问属性。
- en: 28.6.5.2 Why are there dots in `o?.[x]` and `f?.()`?
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 28.6.5.2 为什么 `o?.[x]` 和 `f?.()` 中有点号？
- en: 'The syntaxes of the following two optional operator are not ideal:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个可选操作符的语法并不理想：
- en: '[PRE65]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Alas, the less elegant syntax is necessary because distinguishing the ideal
    syntax (first expression) from the conditional operator (second expression) is
    too complicated:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，不够优雅的语法是必要的，因为区分理想的语法（第一个表达式）和条件运算符（第二个表达式）太复杂了：
- en: '[PRE66]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 28.6.5.3 Why does `null?.prop` evaluate to `undefined` and not `null`?
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 28.6.5.3 为什么 `null?.prop` 的计算结果是 `undefined` 而不是 `null`？
- en: 'The operator `?.` is mainly about its right-hand side: Does property `.prop`
    exist? If not, stop early. Therefore, keeping information about its left-hand
    side is rarely useful. However, only having a single “early termination” value
    does simplify things.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符 `?.` 主要关注其右侧：属性 `.prop` 存在吗？如果不存在，就提前停止。因此，保留左侧的信息很少有用。然而，只有一个“提前终止”值确实简化了事情。
- en: 28.7 Dictionary objects (advanced)
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.7 字典对象（高级）
- en: 'Objects work best as fixed-layout objects. But before ES6, JavaScript did not
    have a data structure for dictionaries (ES6 brought [Maps](ch_maps.html)). Therefore,
    objects had to be used as dictionaries, which imposed a signficant constraint:
    Dictionary keys had to be strings (symbols were also introduced with ES6).'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 对象最适合作为固定布局的对象。但在 ES6 之前，JavaScript 没有字典的数据结构（ES6 带来了 [Maps](ch_maps.html)）。因此，对象必须被用作字典，这带来了一个重要的限制：字典键必须是字符串（ES6
    也引入了符号）。
- en: 'We first look at features of objects that are related to dictionaries but also
    useful for fixed-layout objects. This section concludes with tips for actually
    using objects as dictionaries. (Spoiler: If possible, it’s better to use Maps.)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们看一下与字典相关的对象的特性，但也适用于固定布局的对象。本节以实际使用对象作为字典的提示结束。（提示：如果可能的话，最好使用 Maps。）
- en: 28.7.1 Quoted keys in object literals
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.7.1 对象字面量中的引用键
- en: 'So far, we have always used fixed-layout objects. Property keys were fixed
    tokens that had to be valid identifiers and internally became strings:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用固定布局的对象。属性键是固定的标记，必须是有效的标识符，并在内部变为字符串：
- en: '[PRE67]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'As a next step, we’ll go beyond this limitation for property keys: In this
    subsection, we’ll use arbitrary fixed strings as keys. In the next subsection,
    we’ll dynamically compute keys.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，我们将超越属性键的这种限制：在本小节中，我们将使用任意固定字符串作为键。在下一小节中，我们将动态计算键。
- en: Two syntaxes enable us to use arbitrary strings as property keys.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 两种语法使我们能够使用任意字符串作为属性键。
- en: 'First, when creating property keys via object literals, we can quote property
    keys (with single or double quotes):'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在通过对象字面量创建属性键时，我们可以引用属性键（使用单引号或双引号）：
- en: '[PRE68]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Second, when getting or setting properties, we can use square brackets with
    strings inside them:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在获取或设置属性时，我们可以使用带有字符串的方括号：
- en: '[PRE69]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can also use these syntaxes for methods:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用这些语法来定义方法：
- en: '[PRE70]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 28.7.2 Computed keys in object literals
  id: totrans-349
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.7.2 对象字面量中的计算键
- en: In the previous subsection, property keys were specified via fixed strings inside
    object literals. In this section we learn how to dynamically compute property
    keys. That enables us to use either arbitrary strings or symbols.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一小节中，属性键是通过对象字面量中的固定字符串指定的。在本节中，我们将学习如何动态计算属性键。这使我们能够使用任意字符串或符号。
- en: 'The syntax of dynamically computed property keys in object literals is inspired
    by dynamically accessing properties. That is, we can use square brackets to wrap
    expressions:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量中动态计算的属性键的语法受到动态访问属性的启发。也就是说，我们可以使用方括号来包装表达式：
- en: '[PRE71]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The main use case for computed keys is having symbols as property keys (line
    A).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 计算键的主要用例是将符号作为属性键（A 行）。
- en: 'Note that the square brackets operator for getting and setting properties works
    with arbitrary expressions:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，用于获取和设置属性的方括号操作符可以使用任意表达式：
- en: '[PRE72]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Methods can have computed property keys, too:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 方法也可以有计算属性键：
- en: '[PRE73]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: For the remainder of this chapter, we’ll mostly use fixed property keys again
    (because they are syntactically more convenient). But all features are also available
    for arbitrary strings and symbols.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将主要再次使用固定属性键（因为它们在语法上更方便）。但所有特性也适用于任意字符串和符号。
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Non-destructively
    updating a property via spreading (computed key)**'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **练习：通过展开（计算键）非破坏性地更新属性**'
- en: '`exercises/objects/update_property_test.mjs`'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/objects/update_property_test.mjs`'
- en: '28.7.3 The `in` operator: is there a property with a given key?'
  id: totrans-361
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.7.3 `in`运算符：是否存在具有给定键的属性？
- en: 'The `in` operator checks if an object has a property with a given key:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`运算符检查对象是否具有具有给定键的属性：'
- en: '[PRE74]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 28.7.3.1 Checking if a property exists via truthiness
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 28.7.3.1 通过真值检查属性是否存在
- en: 'We can also use a truthiness check to determine if a property exists:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用真值检查来确定属性是否存在：
- en: '[PRE75]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The previous checks work because `obj.alpha` is truthy and because reading a
    missing property returns `undefined` (which is falsy).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的检查有效是因为`obj.alpha`是真值，并且读取一个不存在的属性会返回`undefined`（假值）。
- en: 'There is, however, one important caveat: truthiness checks fail if the property
    exists, but has a falsy value (`undefined`, `null`, `false`, `0`, `""`, etc.):'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个重要的警告：如果属性存在但具有假值（`undefined`、`null`、`false`、`0`、`""`等），真值检查会失败：
- en: '[PRE76]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 28.7.4 Deleting properties
  id: totrans-370
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.7.4 删除属性
- en: 'We can delete properties via the `delete` operator:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`delete`运算符删除属性：
- en: '[PRE77]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 28.7.5 Enumerability
  id: totrans-373
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.7.5 可枚举性
- en: '*Enumerability* is an [*attribute*](ch_objects.html#property-attributes-property-descriptors)
    of a property. Non-enumerable properties are ignored by some operations – for
    example, by `Object.keys()` and when spreading properties. By default, most properties
    are enumerable. The next example shows how to change that and how it affects spreading.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '*可枚举性*是属性的[*属性*](ch_objects.html#property-attributes-property-descriptors)。一些操作会忽略不可枚举的属性，例如`Object.keys()`和属性展开时。默认情况下，大多数属性是可枚举的。下一个例子展示了如何改变它以及它如何影响属性展开。'
- en: '[PRE78]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '`Object.defineProperties()` is explained [later in this chapter](ch_objects.html#property-attributes-property-descriptors).
    The next subsection shows how these operations are affected by enumerability:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.defineProperties()`在[本章后面](ch_objects.html#property-attributes-property-descriptors)有解释。下一小节展示了这些操作如何受到可枚举性的影响：'
- en: 28.7.6 Listing property keys via `Object.keys()` etc.
  id: totrans-377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.7.6 通过`Object.keys()`等列出属性键
- en: 'Table 19: Standard library methods for listing *own* (non-inherited) property
    keys. All of them return Arrays with strings and/or symbols.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 表19：列出*自有*（非继承的）属性键的标准库方法。它们都返回包含字符串和/或符号的数组。
- en: '|  | enumerable | non-e. | string | symbol |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '|  | 可枚举 | 非可枚举 | 字符串 | 符号 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `Object.keys()` | `✔` |  | `✔` |  |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| `Object.keys()` | `✔` |  | `✔` |  |'
- en: '| `Object.getOwnPropertyNames()` | `✔` | `✔` | `✔` |  |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| `Object.getOwnPropertyNames()` | `✔` | `✔` | `✔` |  |'
- en: '| `Object.getOwnPropertySymbols()` | `✔` | `✔` |  | `✔` |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| `Object.getOwnPropertySymbols()` | `✔` | `✔` |  | `✔` |'
- en: '| `Reflect.ownKeys()` | `✔` | `✔` | `✔` | `✔` |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| `Reflect.ownKeys()` | `✔` | `✔` | `✔` | `✔` |'
- en: 'Each of the methods in tbl. [19](#tbl:listing-property-keys) returns an Array
    with the own property keys of the parameter. In the names of the methods, we can
    see that the following distinction is made:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: tbl. [19](#tbl:listing-property-keys)中的每个方法都返回一个参数的自有属性键的数组。在方法的名称中，我们可以看到以下区别：
- en: A *property key* can be either a string or a symbol.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*属性键*可以是字符串或符号。'
- en: A *property name* is a property key whose value is a string.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*属性名*是其值为字符串的属性键。'
- en: A *property symbol* is a property key whose value is a symbol.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*属性符号*是其值为符号的属性键。'
- en: 'To demonstrate the four operations, we revisit the example from the previous
    subsection:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这四个操作，我们重新访问上一小节的例子：
- en: '[PRE79]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 28.7.7 Listing property values via `Object.values()`
  id: totrans-391
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.7.7 通过`Object.values()`列出属性值
- en: '`Object.values()` lists the values of all enumerable string-keyed properties
    of an object:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.values()`列出对象的所有可枚举的字符串键属性的值：'
- en: '[PRE80]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 28.7.8 Listing property entries via `Object.entries()` [ES2017]
  id: totrans-394
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.7.8 通过`Object.entries()`列出属性条目[ES2017]
- en: '`Object.entries()` lists all enumerable string-keyed properties as key-value
    pairs. Each pair is encoded as a two-element Array:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.entries()`列出所有可枚举的字符串键属性作为键值对。每对被编码为一个两元素数组：'
- en: '[PRE81]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 28.7.8.1 A simple implementation of `Object.entries()`
  id: totrans-397
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 28.7.8.1 `Object.entries()`的简单实现
- en: 'The following function is a simplified version of `Object.entries()`:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的函数是`Object.entries()`的简化版本：
- en: '[PRE82]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: `Object.entries()`**'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **练习：`Object.entries()`**'
- en: '`exercises/objects/find_key_test.mjs`'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/objects/find_key_test.mjs`'
- en: 28.7.9 Properties are listed deterministically
  id: totrans-402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.7.9 属性被有确定性地列出
- en: 'Own (non-inherited) properties of objects are always listed in the following
    order:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的自有（非继承的）属性总是按照以下顺序列出：
- en: 'Properties with string keys that contain integer indices (that includes [Array
    indices](ch_arrays.html#array-indices)):'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有包含整数索引的字符串键的属性（包括[数组索引](ch_arrays.html#array-indices)）：
- en: In ascending numeric order
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按升序排列的数字顺序
- en: 'Remaining properties with string keys:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩余的具有字符串键的属性：
- en: In the order in which they were added
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按照它们被添加的顺序
- en: 'Properties with symbol keys:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有符号键的属性：
- en: In the order in which they were added
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按照它们被添加的顺序
- en: 'The following example demonstrates how property keys are sorted according to
    these rules:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子演示了如何根据这些规则对属性键进行排序：
- en: '[PRE83]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **The order of properties**'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **属性的顺序**'
- en: '[The ECMAScript specification](https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys)
    describes in more detail how properties are ordered.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '[ECMAScript规范](https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys)更详细地描述了属性的排序方式。'
- en: 28.7.10 Assembling objects via `Object.fromEntries()` [ES2019]
  id: totrans-414
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.7.10 通过`Object.fromEntries()`组装对象[ES2019]
- en: 'Given an iterable over [key, value] pairs, `Object.fromEntries()` creates an
    object:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个[key, value]对的可迭代对象，`Object.fromEntries()`创建一个对象：
- en: '[PRE84]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '`Object.fromEntries()` does the opposite of [`Object.entries()`](ch_objects.html#Object.entries).
    However, while `Object.entries()` ignores symbol-keyed properties, `Object.fromEntries()`
    doesn’t (see previous example).'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate both, we’ll use them to implement two tool functions from the
    library [Underscore](https://underscorejs.org) in the next subsubsections.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '28.7.10.1 Example: `pick()`'
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[The Underscore function `pick()`](https://underscorejs.org/#pick) has the
    following signature:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'It returns a copy of `object` that has only those properties whose keys are
    mentioned in the trailing arguments:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We can implement `pick()` as follows:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '28.7.10.2 Example: `invert()`'
  id: totrans-426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[The Underscore function `invert()`](https://underscorejs.org/#invert) has
    the following signature:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'It returns a copy of `object` where the keys and values of all properties are
    swapped:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We can implement `invert()` like this:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 28.7.10.3 A simple implementation of `Object.fromEntries()`
  id: totrans-433
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following function is a simplified version of `Object.fromEntries()`:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Using `Object.entries()`
    and `Object.fromEntries()`**'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/objects/omit_properties_test.mjs`'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 28.7.11 The pitfalls of using an object as a dictionary
  id: totrans-438
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we use plain objects (created via object literals) as dictionaries, we have
    to look out for two pitfalls.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: 'The first pitfall is that the `in` operator also finds inherited properties:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We want `dict` to be treated as empty, but the `in` operator detects the properties
    it inherits from its prototype, `Object.prototype`.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: 'The second pitfall is that we can’t use the property key `__proto__` because
    it has special powers (it sets the prototype of the object):'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 28.7.11.1 Safely using objects as dictionaries
  id: totrans-445
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: So how do we avoid the two pitfalls?
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: If we can, we use Maps. They are the best solution for dictionaries.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we can’t, we use a library for objects-as-dictionaries that protects us from
    making mistakes.
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If that’s not possible or desired, we use an object without a prototype.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code demonstrates using prototype-less objects as dictionaries:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We avoided both pitfalls:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: First, a property without a prototype does not inherit any properties (line
    A).
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, in modern JavaScript, `__proto__` is implemented via `Object.prototype`.
    That means that it is switched off if `Object.prototype` is not in the prototype
    chain.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Using an object
    as a dictionary**'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/objects/simple_dict_test.mjs`'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 28.8 Property attributes and freezing objects (advanced)
  id: totrans-457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 28.8.1 Property attributes and property descriptors [ES5]
  id: totrans-458
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Just as objects are composed of properties, properties are composed of *attributes*.
    The value of a property is only one of several attributes. Others include:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '`writable`: Is it possible to change the value of the property?'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enumerable`: Is the property considered by `Object.keys()`, spreading, etc.?'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we are using one of the operations for handling property attributes, attributes
    are specified via *property descriptors*: objects where each property represents
    one attribute. For example, this is how we read the attributes of a property `obj.myProp`:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'And this is how we change the attributes of `obj.myProp`:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '**Further reading:**'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Enumerability is covered in greater detail [earlier in this chapter](ch_objects.html#enumerability).
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on property attributes and property descriptors, see [*Deep
    JavaScript*](https://exploringjs.com/deep-js/ch_property-attributes-intro.html).
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.8.2 Freezing objects [ES5]
  id: totrans-469
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Object.freeze(obj)` makes `obj` completely immutable: We can’t change properties,
    add properties, or change its prototype – for example:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Under the hood, `Object.freeze()` changes the attributes of properties (e.g.,
    it makes them non-writable) and objects (e.g., it makes them *non-extensible*,
    meaning that no properties can be added anymore).
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one caveat: `Object.freeze(obj)` freezes shallowly. That is, only
    the properties of `obj` are frozen but not objects stored in properties.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个警告：`Object.freeze(obj)`只能浅冻结。也就是说，只有`obj`的属性被冻结，而不是存储在属性中的对象。
- en: '![](../Images/aec4653f22c8cf0e517ff5024759dfe1.png)  **More information**'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/aec4653f22c8cf0e517ff5024759dfe1.png) **更多信息**'
- en: For more information on freezing and other ways of locking down objects, see
    [*Deep JavaScript*](https://exploringjs.com/deep-js/ch_protecting-objects.html).
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 有关冻结和其他锁定对象的方法的更多信息，请参阅[*深入JavaScript*](https://exploringjs.com/deep-js/ch_protecting-objects.html)。
- en: 28.9 Prototype chains
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.9 原型链
- en: 'Prototypes are JavaScript’s only inheritance mechanism: Each object has a prototype
    that is either `null` or an object. In the latter case, the object inherits all
    of the prototype’s properties.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 原型是JavaScript的唯一继承机制：每个对象都有一个原型，要么是`null`，要么是一个对象。在后一种情况下，对象继承原型的所有属性。
- en: 'In an object literal, we can set the prototype via the special property `__proto__`:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象文字中，我们可以通过特殊属性`__proto__`设置原型：
- en: '[PRE98]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Given that a prototype object can have a prototype itself, we get a chain of
    objects – the so-called *prototype chain*. Inheritance gives us the impression
    that we are dealing with single objects, but we are actually dealing with chains
    of objects.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于原型对象本身可以有一个原型，我们得到了一系列对象-所谓的*原型链*。继承给我们一种印象，即我们正在处理单个对象，但实际上我们正在处理对象链。
- en: Fig. [9](#fig:oo_proto_chain) shows what the prototype chain of `obj` looks
    like.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 图[9](#fig:oo_proto_chain)显示了`obj`的原型链是什么样子。
- en: '![Figure 9: obj starts a chain of objects that continues with proto and other
    objects.](../Images/3dab4bfabd32003cdb2479f38899b9ab.png)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![图9：obj开始了一个包含proto和其他对象的对象链。](../Images/3dab4bfabd32003cdb2479f38899b9ab.png)'
- en: 'Figure 9: `obj` starts a chain of objects that continues with `proto` and other
    objects.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 图9：`obj`开始了一个包含`proto`和其他对象的对象链。
- en: Non-inherited properties are called *own properties*. `obj` has one own property,
    `.objProp`.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 非继承属性称为*自有属性*。`obj`有一个自有属性`.objProp`。
- en: '28.9.1 JavaScript’s operations: all properties vs. own properties'
  id: totrans-485
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.9.1 JavaScript的操作：所有属性与自有属性
- en: 'Some operations consider all properties (own and inherited) – for example,
    getting properties:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 一些操作考虑所有属性（自有和继承的）-例如，获取属性：
- en: '[PRE99]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Other operations only consider own properties – for example, `Object.keys()`:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 其他操作只考虑自有属性-例如，`Object.keys()`：
- en: '[PRE100]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Read on for another operation that also only considers own properties: setting
    properties.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 继续阅读另一个操作，该操作也只考虑自有属性：设置属性。
- en: '28.9.2 Pitfall: only the first member of a prototype chain is mutated'
  id: totrans-491
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.9.2 陷阱：只有原型链的第一个成员被改变
- en: 'Given an object `obj` with a chain of prototype objects, it makes sense that
    setting an own property of `obj` only changes `obj`. However, setting an inherited
    property via `obj` also only changes `obj`. It creates a new own property in `obj`
    that overrides the inherited property. Let’s explore how that works with the following
    object:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个具有原型对象链的对象`obj`，设置`obj`的自有属性只改变`obj`是有意义的。但是，通过`obj`设置继承属性也只会改变`obj`。它在`obj`中创建一个新的自有属性，覆盖了继承属性。让我们看看如何在以下对象中工作：
- en: '[PRE101]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'In the next code snippet, we set the inherited property `obj.protoProp` (line
    A). That “changes” it by creating an own property: When reading `obj.protoProp`,
    the own property is found first and its value *overrides* the value of the inherited
    property.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码片段中，我们设置了继承属性`obj.protoProp`（A行）。这通过创建自有属性“改变”了它：当读取`obj.protoProp`时，首先找到自有属性，其值*覆盖*了继承属性的值。
- en: '[PRE102]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The prototype chain of `obj` is depicted in fig. [10](#fig:oo_overriding).
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj`的原型链如图所示。[10](#fig:oo_overriding)。'
- en: '![Figure 10: The own property .protoProp of obj overrides the property inherited
    from proto.](../Images/488c29553b4afa118ff5630e10e3fee4.png)'
  id: totrans-497
  prefs: []
  type: TYPE_IMG
  zh: '![图10：obj的自有属性.protoProp覆盖了从proto继承的属性。](../Images/488c29553b4afa118ff5630e10e3fee4.png)'
- en: 'Figure 10: The own property `.protoProp` of `obj` overrides the property inherited
    from `proto`.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 图10：`obj`的自有属性`.protoProp`覆盖了从`proto`继承的属性。
- en: 28.9.3 Tips for working with prototypes (advanced)
  id: totrans-499
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.9.3 处理原型的提示（高级）
- en: 28.9.3.1 Getting and setting prototypes
  id: totrans-500
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 28.9.3.1 获取和设置原型
- en: 'Recommendations for `__proto__`:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '`__proto__`的建议：'
- en: 'Don’t use `__proto__` as a pseudo-property (a setter of all instances of `Object`):'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将`__proto__`用作伪属性（`Object`的所有实例的setter）：
- en: It can’t be used with all objects (e.g. objects that are not instances of `Object`).
  id: totrans-503
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能与所有对象一起使用（例如不是`Object`的实例的对象）。
- en: The language specification has deprecated it.
  id: totrans-504
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言规范已经将其弃用。
- en: For more information on this feature see [§29.8.7 “`Object.prototype.__proto__`
    (accessor)”](ch_classes.html#Object.prototype.__proto__).
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关此功能的更多信息，请参阅[§29.8.7“`Object.prototype.__proto__`（访问器）”](ch_classes.html#Object.prototype.__proto__)。
- en: 'Using `__proto__` in object literals to set prototypes is different: It’s a
    feature of object literals that has no pitfalls.'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象文字中使用`__proto__`设置原型是不同的：这是对象文字的一个特性，没有陷阱。
- en: 'The recommended ways of getting and setting prototypes are:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 获取和设置原型的推荐方法是：
- en: 'Getting the prototype of an object:'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取对象的原型：
- en: '[PRE103]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The best time to set the prototype of an object is when we are creating it.
    We can do so via `__proto__` in an object literal or via:'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建对象时，设置对象的原型的最佳时间是。我们可以通过对象文字中的`__proto__`或通过以下方式来实现：
- en: '[PRE104]'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: If we have to, we can use `Object.setPrototypeOf()` to change the prototype
    of an existing object. But that may affect performance negatively.
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果必须，我们可以使用`Object.setPrototypeOf()`来更改现有对象的原型。但这可能会对性能产生负面影响。
- en: 'This is how these features are used:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这些特性的使用方式：
- en: '[PRE105]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 28.9.3.2 Checking if an object is in the prototype chain of another object
  id: totrans-515
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 28.9.3.2 检查一个对象是否在另一个对象的原型链中
- en: 'So far, “`proto` is a prototype of `obj`” always meant “`proto` is a *direct*
    prototype of `obj`”. But it can also be used more loosely and mean that `proto`
    is in the prototype chain of `obj`. That looser relationship can be checked via
    `.isPrototypeOf()`:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，“`proto`是`obj`的原型”总是意味着“`proto`是`obj`的*直接*原型”。但它也可以更松散地使用，并意味着`proto`在`obj`的原型链中。可以通过`.isPrototypeOf()`检查这种更松散的关系：
- en: 'For example:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE106]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: For more information on this method see [§29.8.5 “`Object.prototype.isPrototypeOf()`”](ch_classes.html#Object.prototype.isPrototypeOf).
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此方法的更多信息，请参见[§29.8.5 “`Object.prototype.isPrototypeOf()`”](ch_classes.html#Object.prototype.isPrototypeOf)。
- en: '28.9.4 `Object.hasOwn()`: Is a given property own (non-inherited)? [ES2022]'
  id: totrans-520
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '28.9.4 `Object.hasOwn()`: 给定属性是否是自有的（非继承的）？[ES2022]'
- en: The `in` operator (line A) checks if an object has a given property. In contrast,
    `Object.hasOwn()` (lines B and C) checks if a property is own.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`运算符（A行）检查对象是否具有给定属性。相反，`Object.hasOwn()`（B行和C行）检查属性是否是自有的。'
- en: '[PRE107]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png)  **Alternative before ES2022:
    `.hasOwnProperty()`**'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png) **ES2022之前的替代方法：`.hasOwnProperty()`**'
- en: 'Before ES2022, we can use another feature: [§29.8.8 “`Object.prototype.hasOwnProperty()`”](ch_classes.html#Object.prototype.hasOwnProperty).
    This feature has pitfalls, but the referenced section explains how to work around
    them.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES2022之前，我们可以使用另一个特性：[§29.8.8 “`Object.prototype.hasOwnProperty()`”](ch_classes.html#Object.prototype.hasOwnProperty)。这个特性有陷阱，但引用的部分解释了如何解决它们。
- en: 28.9.5 Sharing data via prototypes
  id: totrans-525
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.9.5 通过原型共享数据
- en: 'Consider the following code:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE108]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: We have two objects that are very similar. Both have two properties whose names
    are `.firstName` and `.describe`. Additionally, method `.describe()` is the same.
    How can we avoid duplicating that method?
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个非常相似的对象。两者都有两个名为`.firstName`和`.describe`的属性。另外，方法`.describe()`是相同的。我们如何避免重复这个方法？
- en: 'We can move it to an object `PersonProto` and make that object a prototype
    of both `jane` and `tarzan`:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将它移到一个对象`PersonProto`中，并使该对象成为`jane`和`tarzan`的原型：
- en: '[PRE109]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The name of the prototype reflects that both `jane` and `tarzan` are persons.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 原型的名称反映了`jane`和`tarzan`都是人。
- en: '![Figure 11: Objects jane and tarzan share method .describe(), via their common
    prototype PersonProto.](../Images/0cd9c5f607e5b90dabb4d4f8d5d26d93.png)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
  zh: '![图11：对象jane和tarzan共享方法.describe()，通过它们的共同原型PersonProto。](../Images/0cd9c5f607e5b90dabb4d4f8d5d26d93.png)'
- en: 'Figure 11: Objects `jane` and `tarzan` share method `.describe()`, via their
    common prototype `PersonProto`.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 图11：对象`jane`和`tarzan`共享方法`.describe()`，通过它们的共同原型`PersonProto`。
- en: 'Fig. [11](#fig:oo_person_shared) illustrates how the three objects are connected:
    The objects at the bottom now contain the properties that are specific to `jane`
    and `tarzan`. The object at the top contains the properties that are shared between
    them.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 图[11](#fig:oo_person_shared)说明了这三个对象是如何连接的：底部的对象现在包含了特定于`jane`和`tarzan`的属性。顶部的对象包含了它们之间共享的属性。
- en: When we make the method call `jane.describe()`, `this` points to the receiver
    of that method call, `jane` (in the bottom-left corner of the diagram). That’s
    why the method still works. `tarzan.describe()` works similarly.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用方法`jane.describe()`时，`this`指向该方法调用的接收者`jane`（在图表的左下角）。这就是为什么该方法仍然有效。`tarzan.describe()`也是类似的。
- en: '[PRE110]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Looking ahead to the next chapter on classes – this is how classes are organized
    internally:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 展望下一章关于类的章节 - 这是类在内部组织的方式：
- en: All instances share a common prototype with methods.
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有实例都共享一个带有方法的共同原型。
- en: Instance-specific data is stored in own properties in each instance.
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定于实例的数据存储在每个实例的自有属性中。
- en: '[§29.3 “The internals of classes”](ch_classes.html#internals-of-classes) explains
    this in more detail.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '[§29.3 “类的内部”](ch_classes.html#internals-of-classes)更详细地解释了这一点。'
- en: '28.10 FAQ: objects'
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.10 常见问题：对象
- en: 28.10.1 Why do objects preserve the insertion order of properties?
  id: totrans-542
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.10.1 为什么对象保留属性的插入顺序？
- en: In principle, objects are unordered. The main reason for ordering properties
    is so that operations that list entries, keys, or values are deterministic. That
    helps, e.g., with testing.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，对象是无序的。排序属性的主要原因是列出条目、键或值的操作是确定性的。这有助于例如测试。
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz**'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png) **测验**'
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[测验应用](ch_quizzes-exercises.html#quizzes)。
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/18)'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '[评论](https://github.com/rauschma/impatient-js/issues/18)'
