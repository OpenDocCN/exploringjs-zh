- en: 28 Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/impatient-js/ch_objects.html](https://exploringjs.com/impatient-js/ch_objects.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '28.1 [Cheat sheet: objects](ch_objects.html#cheat-sheet-objects)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.1.1 [Single objects](ch_objects.html#single-objects)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.1.2 [Prototype chains](ch_objects.html#prototype-chains)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.2 [What is an object?](ch_objects.html#what-is-an-object)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.2.1 [The two ways of using objects](ch_objects.html#ways-of-using-objects)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.3 [Fixed-layout objects](ch_objects.html#fixed-layout-objects)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '28.3.1 [Object literals: properties](ch_objects.html#object-literals)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '28.3.2 [Object literals: property value shorthands](ch_objects.html#object-literals-property-value-shorthands)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.3.3 [Getting properties](ch_objects.html#getting-properties)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.3.4 [Setting properties](ch_objects.html#setting-properties)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '28.3.5 [Object literals: methods](ch_objects.html#object-literals-methods)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '28.3.6 [Object literals: accessors](ch_objects.html#object-literal-accessors)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.4 [Spreading into object literals (`...`) [ES2018]](ch_objects.html#spreading-into-object-literals)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '28.4.1 [Use case for spreading: copying objects](ch_objects.html#use-case-for-spreading-copying-objects)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '28.4.2 [Use case for spreading: default values for missing properties](ch_objects.html#use-case-for-spreading-default-values-for-missing-properties)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '28.4.3 [Use case for spreading: non-destructively changing properties](ch_objects.html#use-case-for-spreading-non-destructively-changing-properties)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '28.4.4 [“Destructive spreading”: `Object.assign()` [ES6]](ch_objects.html#destructive-spreading-object.assign-es6)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.5 [Methods and the special variable `this`](ch_objects.html#methods-and-this)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.5.1 [Methods are properties whose values are functions](ch_objects.html#methods-are-properties-whose-values-are-functions)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.5.2 [The special variable `this`](ch_objects.html#the-special-variable-this)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.5.3 [Methods and `.call()`](ch_objects.html#methods-call)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.5.4 [Methods and `.bind()`](ch_objects.html#methods-bind)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '28.5.5 [`this` pitfall: extracting methods](ch_objects.html#extracting-methods)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '28.5.6 [`this` pitfall: accidentally shadowing `this`](ch_objects.html#shadowing-this)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.5.7 [The value of `this` in various contexts (advanced)](ch_objects.html#the-value-of-this-in-various-contexts-advanced)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.6 [Optional chaining for property getting and method calls [ES2020] (advanced)](ch_objects.html#optional-chaining)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '28.6.1 [Example: optional fixed property getting](ch_objects.html#example-optional-fixed-property-getting)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.6.2 [The operators in more detail (advanced)](ch_objects.html#the-operators-in-more-detail-advanced)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.6.3 [Short-circuiting with optional property getting](ch_objects.html#short-circuiting-with-optional-property-getting)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '28.6.4 [Optional chaining: downsides and alternatives](ch_objects.html#optional-chaining-downsides-and-alternatives)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.6.5 [Frequently asked questions](ch_objects.html#frequently-asked-questions)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.7 [Dictionary objects (advanced)](ch_objects.html#dictionary-objects-advanced)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.7.1 [Quoted keys in object literals](ch_objects.html#object-literals-quoted-keys)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.7.2 [Computed keys in object literals](ch_objects.html#object-literals-computed-keys)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '28.7.3 [The `in` operator: is there a property with a given key?](ch_objects.html#in-operator)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.7.4 [Deleting properties](ch_objects.html#deleting-properties)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.7.5 [Enumerability](ch_objects.html#enumerability)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.7.6 [Listing property keys via `Object.keys()` etc.](ch_objects.html#listing-property-keys-via-object.keys-etc.)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.7.7 [Listing property values via `Object.values()`](ch_objects.html#Object.values)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.7.8 [Listing property entries via `Object.entries()` [ES2017]](ch_objects.html#Object.entries)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.7.9 [Properties are listed deterministically](ch_objects.html#order-of-properties)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.7.10 [Assembling objects via `Object.fromEntries()` [ES2019]](ch_objects.html#Object.fromEntries)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.7.11 [The pitfalls of using an object as a dictionary](ch_objects.html#the-pitfalls-of-using-an-object-as-a-dictionary)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.8 [Property attributes and freezing objects (advanced)](ch_objects.html#property-attributes-and-freezing-objects-advanced)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.8.1 [Property attributes and property descriptors [ES5]](ch_objects.html#property-attributes-property-descriptors)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.8.2 [Freezing objects [ES5]](ch_objects.html#freezing-objects-es5)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.9 [Prototype chains](ch_objects.html#prototype-chains)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '28.9.1 [JavaScript’s operations: all properties vs. own properties](ch_objects.html#javascripts-operations-all-properties-vs.-own-properties)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '28.9.2 [Pitfall: only the first member of a prototype chain is mutated](ch_objects.html#pitfall-only-the-first-member-of-a-prototype-chain-is-mutated)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.9.3 [Tips for working with prototypes (advanced)](ch_objects.html#tips-for-working-with-prototypes-advanced)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '28.9.4 [`Object.hasOwn()`: Is a given property own (non-inherited)? [ES2022]](ch_objects.html#Object.hasOwn)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.9.5 [Sharing data via prototypes](ch_objects.html#sharing-data-via-prototypes)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '28.10 [FAQ: objects](ch_objects.html#faq-objects)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.10.1 [Why do objects preserve the insertion order of properties?](ch_objects.html#why-do-objects-preserve-the-insertion-order-of-properties)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, JavaScript’s style of object-oriented programming (OOP) is introduced
    in four steps. This chapter covers step 1 and 2; [the next chapter](ch_classes.html)
    covers step 3 and 4\. The steps are (fig. [8](#fig:oop_steps_1_2)):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single objects (this chapter):** How do *objects*, JavaScript’s basic OOP
    building blocks, work in isolation?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Prototype chains (this chapter):** Each object has a chain of zero or more
    *prototype objects*. Prototypes are JavaScript’s core inheritance mechanism.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Classes (next chapter):** JavaScript’s *classes* are factories for objects.
    The relationship between a class and its instances is based on prototypal inheritance
    (step 2).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Subclassing (next chapter):** The relationship between a *subclass* and its
    *superclass* is also based on prototypal inheritance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8: This book introduces object-oriented programming in JavaScript
    in four steps.](../Images/77a1456d5bcb274b676345e01127a1b5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8: This book introduces object-oriented programming in JavaScript in
    four steps.'
  prefs: []
  type: TYPE_NORMAL
- en: '28.1 Cheat sheet: objects'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 28.1.1 Single objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Creating an object via an *object literal* (starts and ends with a curly brace):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Being able to create objects directly (without classes) is one of the highlights
    of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spreading into objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use spreading to make an unmodified (shallow) copy of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 28.1.2 Prototype chains
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Prototypes are JavaScript’s fundamental inheritance mechanism. Even classes
    are based on it. Each object has `null` or an object as its prototype. The latter
    object can also have a prototype, etc. In general, we get *chains* of prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prototypes are managed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Notes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting an object’s prototype while creating the object: line A, line C'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Retrieving the prototype of an object: line B'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each object inherits all the properties of its prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The non-inherited properties of an object are called its *own* properties.
  prefs: []
  type: TYPE_NORMAL
- en: The most important use case for prototypes is that several objects can share
    methods by inheriting them from a common prototype.
  prefs: []
  type: TYPE_NORMAL
- en: 28.2 What is an object?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Objects in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: An object is a set of slots (key-value entries).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Public slots are called *properties*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A property key can only be a string or a symbol.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Private slots can only be created via classes and are explained in [§29.2.4
    “Public slots (properties) vs. private slots”](ch_classes.html#private-slots).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.2.1 The two ways of using objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two ways of using objects in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixed-layout objects: Used this way, objects work like records in databases.
    They have a fixed number of properties, whose keys are known at development time.
    Their values generally have different types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Dictionary objects: Used this way, objects work like lookup tables or maps.
    They have a variable number of properties, whose keys are not known at development
    time. All of their values have the same type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that the two ways can also be mixed: Some objects are both fixed-layout
    objects and dictionary objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ways of using objects influence how they are explained in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll explore fixed-layout objects. Even though property keys are strings
    or symbols under the hood, they will appear as fixed identifiers to us.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Later, we’ll explore dictionary objects. Note that [Maps](ch_maps.html) are
    usually better dictionaries than objects. However, some of the operations that
    we’ll encounter are also useful for fixed-layout objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.3 Fixed-layout objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s first explore *fixed-layout objects*.
  prefs: []
  type: TYPE_NORMAL
- en: '28.3.1 Object literals: properties'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Object literals* are one way of creating fixed-layout objects. They are a
    stand-out feature of JavaScript: we can directly create objects – no need for
    classes! This is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example, we created an object via an object literal, which starts and
    ends with curly braces `{}`. Inside it, we defined two *properties* (key-value
    entries):'
  prefs: []
  type: TYPE_NORMAL
- en: The first property has the key `first` and the value `'Jane'`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second property has the key `last` and the value `'Doe'`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since ES5, trailing commas are allowed in object literals.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will later see other ways of specifying property keys, but with this way
    of specifying them, they must follow the rules of JavaScript variable names. For
    example, we can use `first_name` as a property key, but not `first-name`). However,
    reserved words are allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to check the effects of various operations on objects, we’ll occasionally
    use `Object.keys()` in this part of the chapter. It lists property keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '28.3.2 Object literals: property value shorthands'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whenever the value of a property is defined via a variable that has the same
    name as the key, we can omit the key.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 28.3.3 Getting properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is how we *get* (read) a property (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting an unknown property produces `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 28.3.4 Setting properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is how we *set* (write to) a property (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We just changed an existing property via setting. If we set an unknown property,
    we create a new entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '28.3.5 Object literals: methods'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following code shows how to create the method `.says()` via an object literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: During the method call `jane.says('hello')`, `jane` is called the *receiver*
    of the method call and assigned to the special variable `this` (more on `this`
    in [§28.5 “Methods and the special variable `this`”](ch_objects.html#methods-and-this)).
    That enables method `.says()` to access the sibling property `.first` in line
    A.
  prefs: []
  type: TYPE_NORMAL
- en: '28.3.6 Object literals: accessors'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An *accessor* is defined via syntax inside an object literal that looks like
    methods: a *getter* and/or a *setter* (i.e., each accessor has one or both of
    them).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoking an accessor looks like accessing a value property:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading the property invokes the getter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing to the property invokes the setter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.3.6.1 Getters
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A getter is created by prefixing a method definition with the modifier `get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 28.3.6.2 Setters
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A setter is created by prefixing a method definition with the modifier `set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Creating an
    object via an object literal**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/objects/color_point_object_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: 28.4 Spreading into object literals (`...`) [ES2018]
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inside an object literal, a *spread property* adds the properties of another
    object to the current one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If property keys clash, the property that is mentioned last “wins”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'All values are spreadable, even `undefined` and `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Property `.length` of strings and Arrays is hidden from this kind of operation
    (it is not *enumerable*; see [§28.8.1 “Property attributes and property descriptors
    [ES5]”](ch_objects.html#property-attributes-property-descriptors) for more information).
  prefs: []
  type: TYPE_NORMAL
- en: 'Spreading includes properties whose keys are symbols (which are ignored by
    `Object.keys()`, `Object.values()` and `Object.entries()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '28.4.1 Use case for spreading: copying objects'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can use spreading to create a copy of an object `original`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Caveat – copying is *shallow*: `copy` is a fresh object with duplicates of
    all properties (key-value entries) of `original`. But if property values are objects,
    then those are not copied themselves; they are shared between `original` and `copy`.
    Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first level of `copy` is really a copy: If we change any properties at
    that level, it does not affect the original:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: However, deeper levels are not copied. For example, the value of `.b` is shared
    between original and copy. Changing `.b` in the copy also changes it in the original.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/0ac255e56dc93a43365d8502301c8688.png)  **JavaScript doesn’t have
    built-in support for deep copying**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Deep copies* of objects (where all levels are copied) are notoriously difficult
    to do generically. Therefore, JavaScript does not have a built-in operation for
    them (for now). If we need such an operation, we have to implement it ourselves.'
  prefs: []
  type: TYPE_NORMAL
- en: '28.4.2 Use case for spreading: default values for missing properties'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If one of the inputs of our code is an object with data, we can make properties
    optional by specifying default values that are used if those properties are missing.
    One technique for doing so is via an object whose properties contain the default
    values. In the following example, that object is `DEFAULTS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The result, the object `allData`, is created by copying `DEFAULTS` and overriding
    its properties with those of `providedData`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we don’t need an object to specify the default values; we can also specify
    them inside the object literal, individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '28.4.3 Use case for spreading: non-destructively changing properties'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far, we have encountered one way of changing a property `.alpha` of an object:
    We *set* it (line A) and mutate the object. That is, this way of changing a property
    is destructive.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With spreading, we can change `.alpha` non-destructively – we make a copy of
    `obj` where `.alpha` has a different value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Non-destructively
    updating a property via spreading (fixed key)**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/objects/update_name_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '28.4.4 “Destructive spreading”: `Object.assign()` [ES6]'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Object.assign()` is a tool method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This expression assigns all properties of `source_1` to `target`, then all
    properties of `source_2`, etc. At the end, it returns `target` – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The use cases for `Object.assign()` are similar to those for spread properties.
    In a way, it spreads destructively.
  prefs: []
  type: TYPE_NORMAL
- en: 28.5 Methods and the special variable `this`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 28.5.1 Methods are properties whose values are functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s revisit the example that was used to introduce methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Somewhat surprisingly, methods are functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Why is that? We learned [in the chapter on callable values](ch_callables.html#roles-of-ordinary-functions)
    that ordinary functions play several roles. *Method* is one of those roles. Therefore,
    internally, `jane` roughly looks as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 28.5.2 The special variable `this`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In line B, `obj` is the *receiver* of a method call. It is passed to the function
    stored in `obj.someMethod` via an implicit (hidden) parameter whose name is `this`
    (line A).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png)  **How to understand `this`**'
  prefs: []
  type: TYPE_NORMAL
- en: The best way to understand `this` is as an implicit parameter of ordinary functions
    (and therefore methods, too).
  prefs: []
  type: TYPE_NORMAL
- en: 28.5.3 Methods and `.call()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Methods are functions and functions have methods themselves. One of those methods
    is [`.call()`](ch_callables.html#Function.prototype.call). Let’s look at an example
    to understand how this method works.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, there was this method invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This invocation is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Which is also equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`.call()` makes the normally implicit parameter `this` explicit: When invoking
    a function via `.call()`, the first parameter is `this`, followed by the regular
    (explicit) function parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an aside, this means that there are actually two different dot operators:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One for accessing properties: `obj.prop`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another one for calling methods: `obj.prop()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They are different in that (2) is not just (1) followed by the function call
    operator `()`. Instead, (2) additionally provides a value for `this`.
  prefs: []
  type: TYPE_NORMAL
- en: 28.5.4 Methods and `.bind()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[`.bind()`](ch_callables.html#Function.prototype.bind) is another method of
    function objects. In the following code, we use `.bind()` to turn method `.says()`
    into the stand-alone function `func()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Setting `this` to `jane` via `.bind()` is crucial here. Otherwise, `func()`
    wouldn’t work properly because `this` is used in line A. In the next section,
    we’ll explore why that is.
  prefs: []
  type: TYPE_NORMAL
- en: '28.5.5 `this` pitfall: extracting methods'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We now know quite a bit about functions and methods and are ready to take a
    look at the biggest pitfall involving methods and `this`: function-calling a method
    extracted from an object can fail if we are not careful.'
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we fail when we extract method `jane.says()`, store
    it in the variable `func`, and function-call `func`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In line A, we are making a normal function call. And in normal function calls,
    `this` is `undefined` (if [strict mode](ch_syntax.html#strict-mode) is active,
    which it almost always is). Line A is therefore equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'How do we fix this? We need to use `.bind()` to extract method `.says()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `.bind()` ensures that `this` is always `jane` when we call `func()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use arrow functions to extract methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '28.5.5.1 Example: extracting a method'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following is a simplified version of code that we may see in actual web
    development:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In line A, we don’t extract the method `.handleClick()` properly. Instead,
    we should do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Each invocation of `.bind()` creates a new function. That’s why we need to store
    the result somewhere if we want to remove it later on.
  prefs: []
  type: TYPE_NORMAL
- en: 28.5.5.2 How to avoid the pitfall of extracting methods
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Alas, there is no simple way around the pitfall of extracting methods: Whenever
    we extract a method, we have to be careful and do it properly – for example, by
    binding `this` or by using an arrow function.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Extracting
    a method**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/objects/method_extraction_exrc.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '28.5.6 `this` pitfall: accidentally shadowing `this`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png)  **Accidentally shadowing
    `this` is only an issue with ordinary functions**'
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions don’t shadow `this`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following problem: when we are inside an ordinary function, we
    can’t access the `this` of the surrounding scope because the ordinary function
    has its own `this`. In other words, a variable in an inner scope hides a variable
    in an outer scope. That is called [*shadowing*](ch_variables-assignment.html#shadowing-variables).
    The following code is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In line A, we want to access the `this` of `.prefixStringArray()`. But we can’t
    since the surrounding ordinary function has its own `this` that *shadows* (and
    blocks access to) the `this` of the method. The value of the former `this` is
    `undefined` due to the callback being function-called. That explains the error
    message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to fix this problem is via an arrow function, which doesn’t
    have its own `this` and therefore doesn’t shadow anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also store `this` in a different variable (line A), so that it doesn’t
    get shadowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option is to specify a fixed `this` for the callback via `.bind()`
    (line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, `.map()` lets us specify a value for `this` (line A) that it uses when
    invoking the callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 28.5.6.1 Avoiding the pitfall of accidentally shadowing `this`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If we follow the advice in [§25.3.4 “Recommendation: prefer specialized functions
    over ordinary functions”](ch_callables.html#prefer-specialized-functions), we
    can avoid the pitfall of accidentally shadowing `this`. This is a summary:'
  prefs: []
  type: TYPE_NORMAL
- en: Use arrow functions as anonymous inline functions. They don’t have `this` as
    an implicit parameter and don’t shadow it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For named stand-alone function declarations we can either use arrow functions
    or function declarations. If we do the latter, we have to make sure `this` isn’t
    mentioned in their bodies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.5.7 The value of `this` in various contexts (advanced)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What is the value of `this` in various contexts?
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside a callable entity, the value of `this` depends on how the callable entity
    is invoked and what kind of callable entity it is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Function call:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ordinary functions: `this === undefined` (in [strict mode](ch_syntax.html#strict-mode))'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Arrow functions: `this` is same as in surrounding scope (lexical `this`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Method call: `this` is receiver of call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new`: `this` refers to the newly created instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also access `this` in all common top-level scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<script>` element: `this === globalThis`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ECMAScript modules: `this === undefined`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CommonJS modules: `this === module.exports`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png)  **Tip: pretend that `this`
    doesn’t exist in top-level scopes**'
  prefs: []
  type: TYPE_NORMAL
- en: I like to do that because top-level `this` is confusing and there are better
    alternatives for its (few) use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 28.6 Optional chaining for property getting and method calls [ES2020] (advanced)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following kinds of optional chaining operations exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The rough idea is:'
  prefs: []
  type: TYPE_NORMAL
- en: If the value before the question mark is neither `undefined` nor `null`, then
    perform the operation after the question mark.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, return `undefined`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of the three syntaxes is covered in more detail later. These are a few
    first examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '28.6.1 Example: optional fixed property getting'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use optional chaining to safely extract street names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 28.6.1.1 Handling defaults via nullish coalescing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The [nullish coalescing operator](ch_undefined-null.html#nullish-coalescing-operator)
    allows us to use the default value `''(no name)''` instead of `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 28.6.2 The operators in more detail (advanced)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 28.6.2.1 Optional fixed property getting
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following two expressions are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 28.6.2.2 Optional dynamic property getting
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following two expressions are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 28.6.2.3 Optional function or method call
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following two expressions are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this operator produces an error if its left-hand side is not callable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Why? The idea is that the operator only tolerates deliberate omissions. An uncallable
    value (other than `undefined` and `null`) is probably an error and should be reported,
    rather than worked around.
  prefs: []
  type: TYPE_NORMAL
- en: 28.6.3 Short-circuiting with optional property getting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In a chain of property gettings and method invocations, evaluation stops once
    the first optional operator encounters `undefined` or `null` at its left-hand
    side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider `invokeM(undefined)` in line B: `undefined?.a` is `undefined`. Therefore
    we’d expect `.b` to fail in line A. But it doesn’t: The `?.` operator encounters
    the value `undefined` and the evaluation of the whole expression immediately returns
    `undefined`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This behavior differs from a normal operator where JavaScript always evaluates
    all operands before evaluating the operator. It is called *short-circuiting*.
    Other short-circuiting operators are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(a && b)`: `b` is only evaluated if `a` is truthy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(a || b)`: `b` is only evaluated if `a` is falsy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(c ? t : e)`: If `c` is truthy, `t` is evaluated. Otherwise, `e` is evaluated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '28.6.4 Optional chaining: downsides and alternatives'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Optional chaining also has downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deeply nested structures are more difficult to manage. For example, refactoring
    is harder if there are many sequences of property names: Each one enforces the
    structure of multiple objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being so forgiving when accessing data hides problems that will surface much
    later and are then harder to debug. For example, a typo early in a sequence of
    optional property names has more negative effects than a normal typo.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An alternative to optional chaining is to extract the information once, in
    a single location:'
  prefs: []
  type: TYPE_NORMAL
- en: We can either write a helper function that extracts the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or we can write a function whose input is deeply nested data and whose output
    is simpler, normalized data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With either approach, it is possible to perform checks and to fail early if
    there are problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further reading:'
  prefs: []
  type: TYPE_NORMAL
- en: “[Overly defensive programming](https://medium.com/@vcarl/overly-defensive-programming-e7a1b3d234c2)”
    by [Carl Vitullo](https://twitter.com/vcarl_)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Thread on Twitter](https://twitter.com/housecor/status/1088419498846244864)
    by [Cory House](https://twitter.com/housecor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.6.5 Frequently asked questions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 28.6.5.1 What is a good mnemonic for the optional chaining operator (`?.`)?
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Are you occasionally unsure if the optional chaining operator starts with a
    dot (`.?`) or a question mark (`?.`)? Then this mnemonic may help you:'
  prefs: []
  type: TYPE_NORMAL
- en: IF (`?`) the left-hand side is not nullish
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: THEN (`.`) access a property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.6.5.2 Why are there dots in `o?.[x]` and `f?.()`?
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The syntaxes of the following two optional operator are not ideal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Alas, the less elegant syntax is necessary because distinguishing the ideal
    syntax (first expression) from the conditional operator (second expression) is
    too complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 28.6.5.3 Why does `null?.prop` evaluate to `undefined` and not `null`?
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The operator `?.` is mainly about its right-hand side: Does property `.prop`
    exist? If not, stop early. Therefore, keeping information about its left-hand
    side is rarely useful. However, only having a single “early termination” value
    does simplify things.'
  prefs: []
  type: TYPE_NORMAL
- en: 28.7 Dictionary objects (advanced)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Objects work best as fixed-layout objects. But before ES6, JavaScript did not
    have a data structure for dictionaries (ES6 brought [Maps](ch_maps.html)). Therefore,
    objects had to be used as dictionaries, which imposed a signficant constraint:
    Dictionary keys had to be strings (symbols were also introduced with ES6).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first look at features of objects that are related to dictionaries but also
    useful for fixed-layout objects. This section concludes with tips for actually
    using objects as dictionaries. (Spoiler: If possible, it’s better to use Maps.)'
  prefs: []
  type: TYPE_NORMAL
- en: 28.7.1 Quoted keys in object literals
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far, we have always used fixed-layout objects. Property keys were fixed
    tokens that had to be valid identifiers and internally became strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'As a next step, we’ll go beyond this limitation for property keys: In this
    subsection, we’ll use arbitrary fixed strings as keys. In the next subsection,
    we’ll dynamically compute keys.'
  prefs: []
  type: TYPE_NORMAL
- en: Two syntaxes enable us to use arbitrary strings as property keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, when creating property keys via object literals, we can quote property
    keys (with single or double quotes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, when getting or setting properties, we can use square brackets with
    strings inside them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use these syntaxes for methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 28.7.2 Computed keys in object literals
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the previous subsection, property keys were specified via fixed strings inside
    object literals. In this section we learn how to dynamically compute property
    keys. That enables us to use either arbitrary strings or symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of dynamically computed property keys in object literals is inspired
    by dynamically accessing properties. That is, we can use square brackets to wrap
    expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The main use case for computed keys is having symbols as property keys (line
    A).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the square brackets operator for getting and setting properties works
    with arbitrary expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Methods can have computed property keys, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: For the remainder of this chapter, we’ll mostly use fixed property keys again
    (because they are syntactically more convenient). But all features are also available
    for arbitrary strings and symbols.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Non-destructively
    updating a property via spreading (computed key)**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/objects/update_property_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: '28.7.3 The `in` operator: is there a property with a given key?'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `in` operator checks if an object has a property with a given key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 28.7.3.1 Checking if a property exists via truthiness
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can also use a truthiness check to determine if a property exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The previous checks work because `obj.alpha` is truthy and because reading a
    missing property returns `undefined` (which is falsy).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, one important caveat: truthiness checks fail if the property
    exists, but has a falsy value (`undefined`, `null`, `false`, `0`, `""`, etc.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 28.7.4 Deleting properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can delete properties via the `delete` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 28.7.5 Enumerability
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Enumerability* is an [*attribute*](ch_objects.html#property-attributes-property-descriptors)
    of a property. Non-enumerable properties are ignored by some operations – for
    example, by `Object.keys()` and when spreading properties. By default, most properties
    are enumerable. The next example shows how to change that and how it affects spreading.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '`Object.defineProperties()` is explained [later in this chapter](ch_objects.html#property-attributes-property-descriptors).
    The next subsection shows how these operations are affected by enumerability:'
  prefs: []
  type: TYPE_NORMAL
- en: 28.7.6 Listing property keys via `Object.keys()` etc.
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Table 19: Standard library methods for listing *own* (non-inherited) property
    keys. All of them return Arrays with strings and/or symbols.'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | enumerable | non-e. | string | symbol |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.keys()` | `✔` |  | `✔` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.getOwnPropertyNames()` | `✔` | `✔` | `✔` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.getOwnPropertySymbols()` | `✔` | `✔` |  | `✔` |'
  prefs: []
  type: TYPE_TB
- en: '| `Reflect.ownKeys()` | `✔` | `✔` | `✔` | `✔` |'
  prefs: []
  type: TYPE_TB
- en: 'Each of the methods in tbl. [19](#tbl:listing-property-keys) returns an Array
    with the own property keys of the parameter. In the names of the methods, we can
    see that the following distinction is made:'
  prefs: []
  type: TYPE_NORMAL
- en: A *property key* can be either a string or a symbol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *property name* is a property key whose value is a string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *property symbol* is a property key whose value is a symbol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To demonstrate the four operations, we revisit the example from the previous
    subsection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 28.7.7 Listing property values via `Object.values()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Object.values()` lists the values of all enumerable string-keyed properties
    of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 28.7.8 Listing property entries via `Object.entries()` [ES2017]
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Object.entries()` lists all enumerable string-keyed properties as key-value
    pairs. Each pair is encoded as a two-element Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 28.7.8.1 A simple implementation of `Object.entries()`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following function is a simplified version of `Object.entries()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: `Object.entries()`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/objects/find_key_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: 28.7.9 Properties are listed deterministically
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Own (non-inherited) properties of objects are always listed in the following
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties with string keys that contain integer indices (that includes [Array
    indices](ch_arrays.html#array-indices)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In ascending numeric order
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Remaining properties with string keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the order in which they were added
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Properties with symbol keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the order in which they were added
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following example demonstrates how property keys are sorted according to
    these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **The order of properties**'
  prefs: []
  type: TYPE_NORMAL
- en: '[The ECMAScript specification](https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys)
    describes in more detail how properties are ordered.'
  prefs: []
  type: TYPE_NORMAL
- en: 28.7.10 Assembling objects via `Object.fromEntries()` [ES2019]
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Given an iterable over [key, value] pairs, `Object.fromEntries()` creates an
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '`Object.fromEntries()` does the opposite of [`Object.entries()`](ch_objects.html#Object.entries).
    However, while `Object.entries()` ignores symbol-keyed properties, `Object.fromEntries()`
    doesn’t (see previous example).'
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate both, we’ll use them to implement two tool functions from the
    library [Underscore](https://underscorejs.org) in the next subsubsections.
  prefs: []
  type: TYPE_NORMAL
- en: '28.7.10.1 Example: `pick()`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[The Underscore function `pick()`](https://underscorejs.org/#pick) has the
    following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns a copy of `object` that has only those properties whose keys are
    mentioned in the trailing arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We can implement `pick()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '28.7.10.2 Example: `invert()`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[The Underscore function `invert()`](https://underscorejs.org/#invert) has
    the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns a copy of `object` where the keys and values of all properties are
    swapped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'We can implement `invert()` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 28.7.10.3 A simple implementation of `Object.fromEntries()`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following function is a simplified version of `Object.fromEntries()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Using `Object.entries()`
    and `Object.fromEntries()`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/objects/omit_properties_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: 28.7.11 The pitfalls of using an object as a dictionary
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we use plain objects (created via object literals) as dictionaries, we have
    to look out for two pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first pitfall is that the `in` operator also finds inherited properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: We want `dict` to be treated as empty, but the `in` operator detects the properties
    it inherits from its prototype, `Object.prototype`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second pitfall is that we can’t use the property key `__proto__` because
    it has special powers (it sets the prototype of the object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 28.7.11.1 Safely using objects as dictionaries
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: So how do we avoid the two pitfalls?
  prefs: []
  type: TYPE_NORMAL
- en: If we can, we use Maps. They are the best solution for dictionaries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we can’t, we use a library for objects-as-dictionaries that protects us from
    making mistakes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If that’s not possible or desired, we use an object without a prototype.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code demonstrates using prototype-less objects as dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We avoided both pitfalls:'
  prefs: []
  type: TYPE_NORMAL
- en: First, a property without a prototype does not inherit any properties (line
    A).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, in modern JavaScript, `__proto__` is implemented via `Object.prototype`.
    That means that it is switched off if `Object.prototype` is not in the prototype
    chain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Using an object
    as a dictionary**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/objects/simple_dict_test.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: 28.8 Property attributes and freezing objects (advanced)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 28.8.1 Property attributes and property descriptors [ES5]
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Just as objects are composed of properties, properties are composed of *attributes*.
    The value of a property is only one of several attributes. Others include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`writable`: Is it possible to change the value of the property?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enumerable`: Is the property considered by `Object.keys()`, spreading, etc.?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we are using one of the operations for handling property attributes, attributes
    are specified via *property descriptors*: objects where each property represents
    one attribute. For example, this is how we read the attributes of a property `obj.myProp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is how we change the attributes of `obj.myProp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '**Further reading:**'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerability is covered in greater detail [earlier in this chapter](ch_objects.html#enumerability).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on property attributes and property descriptors, see [*Deep
    JavaScript*](https://exploringjs.com/deep-js/ch_property-attributes-intro.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 28.8.2 Freezing objects [ES5]
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Object.freeze(obj)` makes `obj` completely immutable: We can’t change properties,
    add properties, or change its prototype – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Under the hood, `Object.freeze()` changes the attributes of properties (e.g.,
    it makes them non-writable) and objects (e.g., it makes them *non-extensible*,
    meaning that no properties can be added anymore).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one caveat: `Object.freeze(obj)` freezes shallowly. That is, only
    the properties of `obj` are frozen but not objects stored in properties.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/aec4653f22c8cf0e517ff5024759dfe1.png)  **More information**'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on freezing and other ways of locking down objects, see
    [*Deep JavaScript*](https://exploringjs.com/deep-js/ch_protecting-objects.html).
  prefs: []
  type: TYPE_NORMAL
- en: 28.9 Prototype chains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Prototypes are JavaScript’s only inheritance mechanism: Each object has a prototype
    that is either `null` or an object. In the latter case, the object inherits all
    of the prototype’s properties.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In an object literal, we can set the prototype via the special property `__proto__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Given that a prototype object can have a prototype itself, we get a chain of
    objects – the so-called *prototype chain*. Inheritance gives us the impression
    that we are dealing with single objects, but we are actually dealing with chains
    of objects.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. [9](#fig:oo_proto_chain) shows what the prototype chain of `obj` looks
    like.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9: obj starts a chain of objects that continues with proto and other
    objects.](../Images/3dab4bfabd32003cdb2479f38899b9ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9: `obj` starts a chain of objects that continues with `proto` and other
    objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Non-inherited properties are called *own properties*. `obj` has one own property,
    `.objProp`.
  prefs: []
  type: TYPE_NORMAL
- en: '28.9.1 JavaScript’s operations: all properties vs. own properties'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Some operations consider all properties (own and inherited) – for example,
    getting properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Other operations only consider own properties – for example, `Object.keys()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Read on for another operation that also only considers own properties: setting
    properties.'
  prefs: []
  type: TYPE_NORMAL
- en: '28.9.2 Pitfall: only the first member of a prototype chain is mutated'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Given an object `obj` with a chain of prototype objects, it makes sense that
    setting an own property of `obj` only changes `obj`. However, setting an inherited
    property via `obj` also only changes `obj`. It creates a new own property in `obj`
    that overrides the inherited property. Let’s explore how that works with the following
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next code snippet, we set the inherited property `obj.protoProp` (line
    A). That “changes” it by creating an own property: When reading `obj.protoProp`,
    the own property is found first and its value *overrides* the value of the inherited
    property.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The prototype chain of `obj` is depicted in fig. [10](#fig:oo_overriding).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10: The own property .protoProp of obj overrides the property inherited
    from proto.](../Images/488c29553b4afa118ff5630e10e3fee4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10: The own property `.protoProp` of `obj` overrides the property inherited
    from `proto`.'
  prefs: []
  type: TYPE_NORMAL
- en: 28.9.3 Tips for working with prototypes (advanced)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 28.9.3.1 Getting and setting prototypes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Recommendations for `__proto__`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t use `__proto__` as a pseudo-property (a setter of all instances of `Object`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can’t be used with all objects (e.g. objects that are not instances of `Object`).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The language specification has deprecated it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on this feature see [§29.8.7 “`Object.prototype.__proto__`
    (accessor)”](ch_classes.html#Object.prototype.__proto__).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using `__proto__` in object literals to set prototypes is different: It’s a
    feature of object literals that has no pitfalls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The recommended ways of getting and setting prototypes are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting the prototype of an object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The best time to set the prototype of an object is when we are creating it.
    We can do so via `__proto__` in an object literal or via:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we have to, we can use `Object.setPrototypeOf()` to change the prototype
    of an existing object. But that may affect performance negatively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is how these features are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 28.9.3.2 Checking if an object is in the prototype chain of another object
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'So far, “`proto` is a prototype of `obj`” always meant “`proto` is a *direct*
    prototype of `obj`”. But it can also be used more loosely and mean that `proto`
    is in the prototype chain of `obj`. That looser relationship can be checked via
    `.isPrototypeOf()`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: For more information on this method see [§29.8.5 “`Object.prototype.isPrototypeOf()`”](ch_classes.html#Object.prototype.isPrototypeOf).
  prefs: []
  type: TYPE_NORMAL
- en: '28.9.4 `Object.hasOwn()`: Is a given property own (non-inherited)? [ES2022]'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `in` operator (line A) checks if an object has a given property. In contrast,
    `Object.hasOwn()` (lines B and C) checks if a property is own.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/5fad46ca9f1c9224fc57d54750b4f1f4.png)  **Alternative before ES2022:
    `.hasOwnProperty()`**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before ES2022, we can use another feature: [§29.8.8 “`Object.prototype.hasOwnProperty()`”](ch_classes.html#Object.prototype.hasOwnProperty).
    This feature has pitfalls, but the referenced section explains how to work around
    them.'
  prefs: []
  type: TYPE_NORMAL
- en: 28.9.5 Sharing data via prototypes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: We have two objects that are very similar. Both have two properties whose names
    are `.firstName` and `.describe`. Additionally, method `.describe()` is the same.
    How can we avoid duplicating that method?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can move it to an object `PersonProto` and make that object a prototype
    of both `jane` and `tarzan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: The name of the prototype reflects that both `jane` and `tarzan` are persons.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11: Objects jane and tarzan share method .describe(), via their common
    prototype PersonProto.](../Images/0cd9c5f607e5b90dabb4d4f8d5d26d93.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11: Objects `jane` and `tarzan` share method `.describe()`, via their
    common prototype `PersonProto`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fig. [11](#fig:oo_person_shared) illustrates how the three objects are connected:
    The objects at the bottom now contain the properties that are specific to `jane`
    and `tarzan`. The object at the top contains the properties that are shared between
    them.'
  prefs: []
  type: TYPE_NORMAL
- en: When we make the method call `jane.describe()`, `this` points to the receiver
    of that method call, `jane` (in the bottom-left corner of the diagram). That’s
    why the method still works. `tarzan.describe()` works similarly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking ahead to the next chapter on classes – this is how classes are organized
    internally:'
  prefs: []
  type: TYPE_NORMAL
- en: All instances share a common prototype with methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance-specific data is stored in own properties in each instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[§29.3 “The internals of classes”](ch_classes.html#internals-of-classes) explains
    this in more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: '28.10 FAQ: objects'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 28.10.1 Why do objects preserve the insertion order of properties?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In principle, objects are unordered. The main reason for ordering properties
    is so that operations that list entries, keys, or values are deterministic. That
    helps, e.g., with testing.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz**'
  prefs: []
  type: TYPE_NORMAL
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  prefs: []
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/18)'
  prefs: []
  type: TYPE_NORMAL
