["```js\n    import * as assert from 'node:assert/strict';\n    ```", "```js\nspawn(\n command: string,\n args?: Array<string>,\n options?: Object\n): ChildProcess\n```", "```js\n        {env: {...process.env, MY_VAR: 'Hi!'}}\n        ```", "```js\nimport {spawn} from 'node:child_process';\n\nspawn(\n 'echo', ['Command starts'],\n {\n stdio: 'inherit',\n shell: true,\n }\n);\nconsole.log('After spawn()');\n```", "```js\nAfter spawn()\nCommand starts\n```", "```js\nimport {Readable} from 'node:stream';\nimport {spawn} from 'node:child_process';\n\nconst childProcess = spawn(\n 'echo \"Hello, how are you?\"',\n {\n shell: true, // (A)\n stdio: ['ignore', 'pipe', 'inherit'], // (B)\n }\n);\nconst stdout = Readable.toWeb(\n childProcess.stdout.setEncoding('utf-8'));\n\n// Result on Unix\nassert.equal(\n await readableStreamToString(stdout),\n 'Hello, how are you?\\n' // (C)\n);\n\n// Result on Windows: '\"Hello, how are you?\"\\r\\n'\n```", "```js\nimport {Readable} from 'node:stream';\nimport {spawn} from 'node:child_process';\n\nconst childProcess = spawn(\n 'echo', ['Hello, how are you?'],\n {\n shell: true,\n stdio: ['ignore', 'pipe', 'inherit'],\n }\n);\nconst stdout = Readable.toWeb(\n childProcess.stdout.setEncoding('utf-8'));\n\n// Result on Unix\nassert.equal(\n await readableStreamToString(stdout),\n 'Hello, how are you?\\n'\n);\n// Result on Windows: 'Hello, how are you?\\r\\n'\n```", "```js\nimport {Readable} from 'node:stream';\nimport {spawn} from 'node:child_process';\n\nasync function echoUser({shell, args}) {\n const childProcess = spawn(\n `echo`, args,\n {\n stdio: ['ignore', 'pipe', 'inherit'],\n shell,\n }\n );\n const stdout = Readable.toWeb(\n childProcess.stdout.setEncoding('utf-8'));\n return readableStreamToString(stdout);\n}\n\n// Results on Unix\nassert.equal(\n await echoUser({shell: false, args: ['$USER']}), // (A)\n '$USER\\n'\n);\nassert.equal(\n await echoUser({shell: true, args: ['$USER']}), // (B)\n 'rauschma\\n'\n);\nassert.equal(\n await echoUser({shell: true, args: [String.raw`\\$USER`]}), // (C)\n '$USER\\n'\n);\n```", "```js\nimport {Readable} from 'node:stream';\nimport {spawn} from 'node:child_process';\nimport {EOL} from 'node:os';\n\nconst childProcess = spawn(\n `(echo cherry && echo apple && echo banana) | sort`,\n {\n stdio: ['ignore', 'pipe', 'inherit'],\n shell: true,\n }\n);\nconst stdout = Readable.toWeb(\n childProcess.stdout.setEncoding('utf-8'));\nassert.equal(\n await readableStreamToString(stdout),\n 'apple\\nbanana\\ncherry\\n'\n);\n```", "```js\nimport {Readable, Writable} from 'node:stream';\nimport {spawn} from 'node:child_process';\n\nconst childProcess = spawn(\n `sort`, // (A)\n {\n stdio: ['pipe', 'pipe', 'inherit'],\n }\n);\nconst stdin = Writable.toWeb(childProcess.stdin); // (B)\nconst writer = stdin.getWriter(); // (C)\ntry {\n await writer.write('Cherry\\n');\n await writer.write('Apple\\n');\n await writer.write('Banana\\n');\n} finally {\n writer.close();\n}\n\nconst stdout = Readable.toWeb(\n childProcess.stdout.setEncoding('utf-8'));\nassert.equal(\n await readableStreamToString(stdout),\n 'Apple\\nBanana\\nCherry\\n'\n);\n```", "```js\n(echo cherry && echo apple && echo banana) | sort\n```", "```js\nimport {Readable, Writable} from 'node:stream';\nimport {spawn} from 'node:child_process';\n\nconst echo = spawn( // (A)\n `echo cherry && echo apple && echo banana`,\n {\n stdio: ['ignore', 'pipe', 'inherit'],\n shell: true,\n }\n);\nconst sort = spawn( // (B)\n `sort`,\n {\n stdio: ['pipe', 'pipe', 'inherit'],\n shell: true,\n }\n);\n\n//==== Transferring chunks from echo.stdout to sort.stdin ====\n\nconst echoOut = Readable.toWeb(\n echo.stdout.setEncoding('utf-8'));\nconst sortIn = Writable.toWeb(sort.stdin);\n\nconst sortInWriter = sortIn.getWriter();\ntry {\n for await (const chunk of echoOut) { // (C)\n await sortInWriter.write(chunk);\n }\n} finally {\n sortInWriter.close();\n}\n\n//==== Reading sort.stdout ====\n\nconst sortOut = Readable.toWeb(\n sort.stdout.setEncoding('utf-8'));\nassert.equal(\n await readableStreamToString(sortOut),\n 'apple\\nbanana\\ncherry\\n'\n);\n```", "```js\nimport {spawn} from 'node:child_process';\n\nconst childProcess = spawn(\n 'echo hello',\n {\n stdio: ['inherit', 'inherit', 'pipe'],\n shell: '/bin/does-not-exist', // (A)\n }\n);\nchildProcess.on('error', (err) => { // (B)\n assert.equal(\n err.toString(),\n 'Error: spawn /bin/does-not-exist ENOENT'\n );\n});\n```", "```js\nimport {Readable} from 'node:stream';\nimport {spawn} from 'node:child_process';\n\nconst childProcess = spawn(\n 'does-not-exist',\n {\n stdio: ['inherit', 'inherit', 'pipe'],\n shell: true,\n }\n);\nchildProcess.on('exit',\n async (exitCode, signalCode) => { // (A)\n assert.equal(exitCode, 127);\n assert.equal(signalCode, null);\n const stderr = Readable.toWeb(\n childProcess.stderr.setEncoding('utf-8'));\n assert.equal(\n await readableStreamToString(stderr),\n '/bin/sh: does-not-exist: command not found\\n'\n );\n }\n);\nchildProcess.on('error', (err) => { // (B)\n console.error('We never get here!');\n});\n```", "```js\nimport {Readable} from 'node:stream';\nimport {spawn} from 'node:child_process';\n\nconst childProcess = spawn(\n 'kill $$', // (A)\n {\n stdio: ['inherit', 'inherit', 'pipe'],\n shell: true,\n }\n);\nconsole.log(childProcess.pid); // (B)\nchildProcess.on('exit', async (exitCode, signalCode) => {\n assert.equal(exitCode, null); // (C)\n assert.equal(signalCode, 'SIGTERM'); // (D)\n const stderr = Readable.toWeb(\n childProcess.stderr.setEncoding('utf-8'));\n assert.equal(\n await readableStreamToString(stderr),\n '' // (E)\n );\n});\n```", "```js\nimport * as fs from 'node:fs';\nimport {spawn} from 'node:child_process';\n\nconst childProcess = spawn(\n `(echo first && echo second) > tmp-file.txt`,\n {\n shell: true,\n stdio: 'inherit',\n }\n);\nchildProcess.on('exit', (exitCode, signalCode) => { // (A)\n assert.equal(exitCode, 0);\n assert.equal(signalCode, null);\n assert.equal(\n fs.readFileSync('tmp-file.txt', {encoding: 'utf-8'}),\n 'first\\nsecond\\n'\n );\n});\n```", "```js\nimport * as fs from 'node:fs';\nimport {spawn} from 'node:child_process';\n\nconst childProcess = spawn(\n `(echo first && echo second) > tmp-file.txt`,\n {\n shell: true,\n stdio: 'inherit',\n }\n);\n\nconst {exitCode, signalCode} = await onExit(childProcess); // (A)\n\nassert.equal(exitCode, 0);\nassert.equal(signalCode, null);\nassert.equal(\n fs.readFileSync('tmp-file.txt', {encoding: 'utf-8'}),\n 'first\\nsecond\\n'\n);\n```", "```js\nexport function onExit(eventEmitter) {\n return new Promise((resolve, reject) => {\n eventEmitter.once('exit', (exitCode, signalCode) => {\n if (exitCode === 0) { // (B)\n resolve({exitCode, signalCode});\n } else {\n reject(new Error(\n `Non-zero exit: code ${exitCode}, signal ${signalCode}`));\n }\n });\n eventEmitter.once('error', (err) => { // (C)\n reject(err);\n });\n });\n}\n```", "```js\nimport {spawn} from 'node:child_process';\n\nconst abortController = new AbortController(); // (A)\n\nconst childProcess = spawn(\n `echo Hello`,\n {\n stdio: 'inherit',\n shell: true,\n signal: abortController.signal, // (B)\n }\n);\nchildProcess.on('error', (err) => {\n assert.equal(\n err.toString(),\n 'AbortError: The operation was aborted'\n );\n});\nabortController.abort(); // (C)\n```", "```js\nimport {spawn} from 'node:child_process';\n\nconst childProcess = spawn(\n `echo Hello`,\n {\n stdio: 'inherit',\n shell: true,\n }\n);\nchildProcess.on('exit', (exitCode, signalCode) => {\n assert.equal(exitCode, null);\n assert.equal(signalCode, 'SIGTERM');\n});\nchildProcess.kill(); // default argument value: 'SIGTERM'\n```", "```js\nspawnSync(\n command: string,\n args?: Array<string>,\n options?: Object\n): Object\n```", "```js\nimport {spawnSync} from 'node:child_process';\n\nspawnSync(\n 'echo', ['Command starts'],\n {\n stdio: 'inherit',\n shell: true,\n }\n);\nconsole.log('After spawnSync()');\n```", "```js\nCommand starts\nAfter spawnSync()\n```", "```js\nimport {spawnSync} from 'node:child_process';\n\nconst result = spawnSync(\n `echo rock && echo paper && echo scissors`,\n {\n stdio: ['ignore', 'pipe', 'inherit'], // (A)\n encoding: 'utf-8', // (B)\n shell: true,\n }\n);\nconsole.log(result);\nassert.equal(\n result.stdout, // (C)\n 'rock\\npaper\\nscissors\\n'\n);\nassert.equal(result.stderr, null); // (D)\n```", "```js\nimport {spawnSync} from 'node:child_process';\n\nconst result = spawnSync(\n `sort`,\n {\n stdio: ['pipe', 'pipe', 'inherit'],\n encoding: 'utf-8',\n input: 'Cherry\\nApple\\nBanana\\n', // (A)\n }\n);\nassert.equal(\n result.stdout,\n 'Apple\\nBanana\\nCherry\\n'\n);\n```", "```js\nimport {spawnSync} from 'node:child_process';\n\nconst result = spawnSync(\n 'echo hello',\n {\n stdio: ['ignore', 'inherit', 'pipe'],\n encoding: 'utf-8',\n shell: '/bin/does-not-exist',\n }\n);\nassert.equal(\n result.error.toString(),\n 'Error: spawnSync /bin/does-not-exist ENOENT'\n);\n```", "```js\nimport {spawnSync} from 'node:child_process';\n\nconst result = spawnSync(\n 'does-not-exist',\n {\n stdio: ['ignore', 'inherit', 'pipe'],\n encoding: 'utf-8',\n shell: true,\n }\n);\nassert.equal(result.status, 127);\nassert.equal(result.signal, null);\nassert.equal(\n result.stderr, '/bin/sh: does-not-exist: command not found\\n'\n);\n```", "```js\nimport {spawnSync} from 'node:child_process';\n\nconst result = spawnSync(\n 'kill $$',\n {\n stdio: ['ignore', 'inherit', 'pipe'],\n encoding: 'utf-8',\n shell: true,\n }\n);\n\nassert.equal(result.status, null);\nassert.equal(result.signal, 'SIGTERM');\nassert.equal(result.stderr, ''); // (A)\n```", "```js\nexec(\n command: string,\n options?: Object,\n callback?: (error, stdout, stderr) => void\n): ChildProcess\n```", "```js\nimport {exec} from 'node:child_process';\n\nconst childProcess = exec(\n 'echo Hello',\n (error, stdout, stderr) => {\n if (error) {\n console.error('error: ' + error.toString());\n return;\n }\n console.log('stdout: ' + stdout); // 'stdout: Hello\\n'\n console.error('stderr: ' + stderr); // 'stderr: '\n }\n);\n```", "```js\nimport * as util from 'node:util';\nimport * as child_process from 'node:child_process';\n\nconst execAsync = util.promisify(child_process.exec);\n\ntry {\n const resultPromise = execAsync('echo Hello');\n const {childProcess} = resultPromise;\n const obj = await resultPromise;\n console.log(obj); // { stdout: 'Hello\\n', stderr: '' }\n} catch (err) {\n console.error(err);\n}\n```", "```js\nexecSync(\n command: string,\n options?: Object\n): Buffer | string\n```", "```js\nimport {execSync} from 'node:child_process';\n\ntry {\n const stdout = execSync('echo Hello');\n console.log('stdout: ' + stdout); // 'stdout: Hello\\n'\n} catch (err) {\n console.error('Error: ' + err.toString());\n}\n```", "```js\nimport sh from 'tinysh';\n\nconsole.log(sh.ls('-l'));\nconsole.log(sh.cat('README.md'));\n```", "```js\nsh.tee.call({input: 'Hello, world!'}, 'file.txt');\n```", "```js\nimport {execFileSync} from 'node:child_process';\nconst sh = new Proxy({}, {\n get: (_, bin) => function (...args) { // (A)\n return execFileSync(bin, args,\n {\n encoding: 'utf-8',\n shell: true,\n ...this // (B)\n }\n );\n },\n});\n```", "```js\nimport { PowerShell } from 'node-powershell';\nPowerShell.$`echo \"hello from PowerShell\"`;\n```"]