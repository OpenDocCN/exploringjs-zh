["```ts\ninterface Array<T> {\n concat(...items: Array<T[] | T>): T[];\n reduce<U>(\n callback: (state: U, element: T, index: number) => U,\n firstState?: U\n ): U;\n // ···\n}\n\n```", "```ts\n> typeof true\n'boolean'\n\n```", "```ts\nconst value = null;\nassert.throws(\n () => value.length,\n /^TypeError: Cannot read properties of null/\n);\n\n```", "```ts\nconst value = null;\n// @ts-expect-error: 'value' is possibly 'null'.\nvalue.length;\n\n```", "```ts\n> typeof undefined\n'undefined'\n> typeof 123\n'number'\n> typeof 'abc'\n'string'\n\n```", "```ts\nlet count: number;\n\n```", "```ts\nlet count: number;\n// @ts-expect-error: Type 'string' is not assignable to type 'number'.\ncount = 'yes';\n\n```", "```ts\nfunction toString(num: number): string {\n return String(num);\n}\n\n```", "```ts\nconst noValue: undefined = undefined;\n\n```", "```ts\nlet thousand: 1000 = 1000;\n\n```", "```ts\nthousand = 1000; // OK\n// @ts-expect-error: Type '999' is not assignable to type '1000'.\nthousand = 999;\n\n```", "```ts\nconst num: number = thousand;\n\n```", "```ts\n// boolean literal type\nconst TRUTHY: true = true;\n\n// bigint literal type\nconst HUNDRED: 100n = 100n;\n\n// string literal type\nconst YES: 'yes' = 'yes';\n\n// These could also be considered literal types\nconst UNDEF: undefined = undefined;\nconst NULL: null = null;\n\n```", "```ts\n// @ts-expect-error: Parameter 'arg' implicitly has an 'any' type.\nfunction func1(arg): void {} // error\n\nfunction func2(arg: boolean): void {} // OK\n\nfunction func3(arg = false): void {} // OK\n\n```", "```ts\nconst count = 14;\nassertType<14>(count);\n\n```", "```ts\nlet count = 14;\nassertType<number>(count);\n\n```", "```ts\nfunction toString(num: number) {\n return String(num);\n}\nassertType<string>(toString(32));\n\n```", "```ts\nconst strValue = String(32);\nassertType<string>(strValue);\n\n```", "```ts\n(value: any) => string\n\n```", "```ts\ntype Age = number;\nconst age: Age = 82;\n\n```", "```ts\n// Array types\ntype StringArray = Array<string>;\n\n// Function types\ntype NumToStr = (num: number) => string;\n\n// Object literal types\ntype BlogPost = {\n title: string,\n tags: Array<string>,\n};\n\n// Union types\ntype YesOrNo = 'yes' | 'no';\n\n```", "```ts\nlet arr1: number[] = [];\nlet arr2: Array<number> = [];\n\n```", "```ts\nconst keys = Object.keys({prop: 123});\nassertType<string[]>(keys);\n\n```", "```ts\nconst entry: [string, number] = ['count', 33];\n\n```", "```ts\nassert.deepEqual(\n Object.fromEntries([entry]),\n {\n count: 33,\n }\n);\n\n```", "```ts\ntype NumToStr = (num: number) => string;\n\n```", "```ts\nconst toString: NumToStr = (num) => String(num);\n\n```", "```ts\nconst toString = (num: number): string => String(num);\n\n```", "```ts\nassertType<\n (num: number) => string\n>(toString);\n\n```", "```ts\nfunction stringify123(callback: (num: number) => string): string {\n return callback(123);\n}\n\n```", "```ts\n// @ts-expect-error: Argument of type 'NumberConstructor' is not\n// assignable to parameter of type '(num: number) => string'.\nstringify123(Number);\n\n```", "```ts\nassert.equal(\n stringify123(String), '123'\n);\n\n```", "```ts\nconst stringify123 =\n (callback: (num: number) => string): string => callback(123);\n\n```", "```ts\nfunction f1(): void {\n return undefined;\n}\n\n```", "```ts\nfunction f2(): void {}\n\n```", "```ts\nfunction f3(): void {\n // @ts-expect-error: Type 'string' is not assignable to type 'void'.\n return 'abc';\n}\n\n```", "```ts\nfunction stringify123(callback?: (num: number) => string) {\n if (callback === undefined) {\n callback = String;\n }\n return callback(123); // (A)\n}\n\n```", "```ts\nfunction createPoint(x=0, y=0): [number, number] {\n return [x, y];\n}\n\nassert.deepEqual(\n createPoint(),\n [0, 0]);\nassert.deepEqual(\n createPoint(1, 2),\n [1, 2]);\n\n```", "```ts\nfunction createPoint(x:number = 0, y:number = 0): [number, number] {\n return [x, y];\n}\n\n```", "```ts\nfunction joinNumbers(...nums: number[]): string {\n return nums.join('-');\n}\nassert.equal(\n joinNumbers(1, 2, 3),\n '1-2-3'\n);\n\n```", "```ts\ntype Point = {\n x: number,\n y: number,\n};\n\n```", "```ts\ninterface Point {\n x: number;\n y: number;\n} // no semicolon!\n\n```", "```ts\ntype Point = {\n x: number,\n y: number,\n};\nfunction pointToString(pt: Point) {\n return `(${pt.x}, ${pt.y})`;\n}\n\nassert.equal(\n pointToString({x: 5, y: 7}), // compatible structure\n '(5, 7)');\n\n```", "```ts\ntype Person = {\n name: string,\n company?: string,\n};\n\n```", "```ts\nconst john: Person = {\n name: 'John',\n};\nconst jane: Person = {\n name: 'Jane',\n company: 'Massive Dynamic',\n};\n\n```", "```ts\ntype Point = {\n x: number,\n y: number,\n distance(other: Point): number,\n};\n\n```", "```ts\ntype HasMethodDef = {\n simpleMethod(flag: boolean): void,\n};\ntype HasFuncProp = {\n simpleMethod: (flag: boolean) => void,\n};\ntype _ = Assert<Equal<\n HasMethodDef,\n HasFuncProp\n>>;\n\nconst objWithMethod = {\n simpleMethod(flag: boolean): void {},\n};\nassertType<HasMethodDef>(objWithMethod);\nassertType<HasFuncProp>(objWithMethod);\n\nconst objWithOrdinaryFunction: HasMethodDef = {\n simpleMethod: function (flag: boolean): void {},\n};\nassertType<HasMethodDef>(objWithOrdinaryFunction);\nassertType<HasFuncProp>(objWithOrdinaryFunction);\n\nconst objWithArrowFunction: HasMethodDef = {\n simpleMethod: (flag: boolean): void => {},\n};\nassertType<HasMethodDef>(objWithArrowFunction);\nassertType<HasFuncProp>(objWithArrowFunction);\n\n```", "```ts\nfunction getScore(stringOrNumber: string|number): number {\n if (typeof stringOrNumber === 'string'\n && /^\\*{1,5}$/.test(stringOrNumber)) {\n return stringOrNumber.length;\n } else if (typeof stringOrNumber === 'number'\n && stringOrNumber >= 1 && stringOrNumber <= 5) {\n return stringOrNumber\n } else {\n throw new Error('Illegal value: ' + JSON.stringify(stringOrNumber));\n }\n}\n\nassert.equal(getScore('*****'), 5);\nassert.equal(getScore(3), 3);\n\n```", "```ts\nlet numberOrNull: undefined|number = undefined;\nnumberOrNull = 123;\n\n```", "```ts\n// @ts-expect-error: Type 'undefined' is not assignable to type 'number'.\nlet mustBeNumber: number = undefined;\nmustBeNumber = 123;\n\n```", "```ts\nlet myNumber: number; // OK\nmyNumber = 123;\n\n```", "```ts\ntype BufferEncoding =\n | 'ascii'\n | 'utf8'\n | 'utf-8'\n | 'utf16le'\n | 'utf-16le'\n | 'ucs2'\n | 'ucs-2'\n | 'base64'\n | 'base64url'\n | 'latin1'\n | 'binary'\n | 'hex'\n;\n\n```", "```ts\ntype Type1 = 'a' | 'b' | 'c';\ntype Type2 = 'b' | 'c' | 'd' | 'e';\ntype _ = Assert<Equal<\n Type1 & Type2,\n 'b' | 'c'\n>>;\n\n```", "```ts\nfunction getLength(value: string | number): number {\n assertType<string | number>(value); // (A)\n // @ts-expect-error: Property 'length' does not exist on\n // type 'string | number'.\n value.length; // (B)\n if (typeof value === 'string') {\n assertType<string>(value); // (C)\n return value.length; // (D)\n }\n assertType<number>(value); // (E)\n return String(value).length;\n}\n\n```", "```ts\n    const valueFactory = (x: number) => x; // definition\n    const myValue = valueFactory(123); // use\n\n    ```", "```ts\n    type TypeFactory<X> = X; // definition\n    type MyType = TypeFactory<string>; // use\n\n    ```", "```ts\n// Factory for types\ntype ValueContainer<Value> = {\n value: Value;\n};\n\n// Creating one type\ntype StringContainer = ValueContainer<string>;\n\n```", "```ts\nclass SimpleStack<Elem> {\n #data: Array<Elem> = [];\n push(x: Elem): void {\n this.#data.push(x);\n }\n pop(): Elem {\n const result = this.#data.pop();\n if (result === undefined) {\n throw new Error();\n }\n return result;\n }\n get length() {\n return this.#data.length;\n }\n}\n\n```", "```ts\nconst stringStack = new SimpleStack<string>();\nstringStack.push('first');\nstringStack.push('second');\nassert.equal(stringStack.length, 2);\nassert.equal(stringStack.pop(), 'second');\n\n```", "```ts\nconst myMap: Map<boolean,string> = new Map([\n [false, 'no'],\n [true, 'yes'],\n]);\n\n```", "```ts\nconst myMap = new Map([\n [false, 'no'],\n [true, 'yes'],\n]);\nassertType<Map<boolean, string>>(myMap);\n\n```", "```ts\nfunction identity<Arg>(arg: Arg): Arg {\n return arg;\n}\n\n```", "```ts\nconst num1 = identity<number>(123);\nassertType<number>(num1);\n\n```", "```ts\nconst num2 = identity(123);\nassertType<123>(num2);\n\n```", "```ts\nconst identity = <Arg>(arg: Arg): Arg => arg;\n\n```", "```ts\nconst obj = {\n identity<Arg>(arg: Arg): Arg {\n return arg;\n },\n};\n\n```", "```ts\nfunction fillArray<T>(len: number, elem: T): T[] {\n return new Array<T>(len).fill(elem);\n}\n\n```", "```ts\nconst arr1 = fillArray<string>(3, '*');\nassertType<string[]>(arr1);\nassert.deepEqual(\n arr1, ['*', '*', '*']);\n\nconst arr2 = fillArray(3, '*'); // (A)\nassertType<string[]>(arr2);\n\n```", "```ts\ninterface Array<T> {\n concat(...items: Array<T[] | T>): T[];\n reduce<U>(\n callback: (state: U, element: T, index: number) => U,\n firstState?: U\n ): U;\n // ···\n}\n\n```"]