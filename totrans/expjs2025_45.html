<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>38 Sets (Set) ES6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>38 Sets (Set) ES6</h1>
<blockquote>原文：<a href="https://exploringjs.com/js/book/ch_sets.html">https://exploringjs.com/js/book/ch_sets.html</a></blockquote>

        
    
    
    
<p><span id="index-entry-Set"/><span id="index-entry-Set2"/></p>
<nav class="local-toc">
  <ol>
    <li>
      <a href="#basic-set-operations">38.1 Basic Set operations</a>
      <ol>
        <li>
          <a href="#creating-sets">38.1.1 Creating Sets</a>
        </li>
        <li>
          <a href="#adding-removing-checking-membership">38.1.2 Adding, removing, checking membership</a>
        </li>
        <li>
          <a href="#determining-the-size-of-a-set-and-clearing-it">38.1.3 Determining the size of a Set and clearing it</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#combining-sets">38.2 Combining Sets: union, intersection, difference, symmetric difference<span> <sup>ES2025</sup></span></a>
      <ol>
        <li>
          <a href="#Set.prototype.union">38.2.1 Union: <code>set.union(other)</code><span> <sup>ES2025</sup></span></a>
        </li>
        <li>
          <a href="#Set.prototype.intersection">38.2.2 Intersection: <code>set.intersection(other)</code><span> <sup>ES2025</sup></span></a>
        </li>
        <li>
          <a href="#Set.prototype.difference">38.2.3 Difference: <code>set.difference(other)</code><span> <sup>ES2025</sup></span></a>
        </li>
        <li>
          <a href="#Set.prototype.symmetricDifference">38.2.4 Symmetric difference: <code>set.symmetricDifference(other)</code><span> <sup>ES2025</sup></span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#checking-set-relationships">38.3 Checking Set relationships: subset of, superset of, disjoint from<span> <sup>ES2025</sup></span></a>
      <ol>
        <li>
          <a href="#Set.prototype.isSubsetOf">38.3.1 Subset: <code>set.isSubsetOf(other)</code><span> <sup>ES2025</sup></span></a>
        </li>
        <li>
          <a href="#Set.prototype.isSupersetOf">38.3.2 Superset: <code>set.isSupersetOf(other)</code><span> <sup>ES2025</sup></span></a>
        </li>
        <li>
          <a href="#Set.prototype.isDisjointFrom">38.3.3 Disjoint: <code>set.isDisjointFrom(other)</code><span> <sup>ES2025</sup></span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#set-like-objects">38.4 Set-like objects<span> (advanced)</span></a>
      <ol>
        <li>
          <a href="#examples-finite-setlike-objects">38.4.1 Examples: finite Set-like objects</a>
        </li>
        <li>
          <a href="#infinite-sets">38.4.2 Examples: infinite Set-like data</a>
        </li>
        <li>
          <a href="#faq-setlike-objects">38.4.3 FAQ: Set-like objects</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#iterating-over-sets-1">38.5 Iterating over Sets</a>
      <ol>
        <li>
          <a href="#converting-set-to-array">38.5.1 Converting a Set to an Array</a>
        </li>
        <li>
          <a href="#applying-iterator-methods-to-sets">38.5.2 Mapping and filtering Sets via iterator methods</a>
        </li>
        <li>
          <a href="#combining-sets-via-iteration">38.5.3 Example: combining Sets via iteration<span> <sup>ES2025</sup></span></a>
        </li>
        <li>
          <a href="#grouping-set-elements-es2024">38.5.4 Grouping Set elements<span> <sup>ES2024</sup></span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#examples-of-using-sets">38.6 Examples of using Sets</a>
      <ol>
        <li>
          <a href="#removing-duplicates-from-an-array">38.6.1 Removing duplicates from an Array</a>
        </li>
        <li>
          <a href="#creating-a-set-of-unicode-characters-code-points">38.6.2 Creating a set of Unicode characters (code points)</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#details-of-the-set-api-advanced">38.7 Details of the Set API<span> (advanced)</span></a>
      <ol>
        <li>
          <a href="#what-set-elements-are-considered-equal">38.7.1 What Set elements are considered equal?</a>
        </li>
        <li>
          <a href="#faq-set-api">38.7.2 FAQ: Set API</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#quickref-sets">38.8 Quick reference: <code>Set</code></a>
      <ol>
        <li>
          <a href="#new-set">38.8.1 <code>new Set()</code></a>
        </li>
        <li>
          <a href="#setprototype-working-with-single-set-elements">38.8.2 <code>Set.prototype.*</code>: working with single Set elements</a>
        </li>
        <li>
          <a href="#setprototype-working-with-all-set-elements">38.8.3 <code>Set.prototype.*</code>: working with all Set elements</a>
        </li>
        <li>
          <a href="#setprototype-iterating-and-looping">38.8.4 <code>Set.prototype.*</code>: iterating and looping</a>
        </li>
        <li>
          <a href="#setprototype-combining-two-sets-es2025">38.8.5 <code>Set.prototype.*</code>: combining two Sets<span> <sup>ES2025</sup></span></a>
        </li>
        <li>
          <a href="#setprototype-checking-set-relationships-es2025">38.8.6 <code>Set.prototype.*</code>: checking Set relationships<span> <sup>ES2025</sup></span></a>
        </li>
      </ol>
    </li>
  </ol>
</nav>
<p>The data structure <code>Set</code> manages a duplicate-free collection of values and provides fast membership checks and more.</p>
<h3 id="basic-set-operations"><a class="heading-id-link" href="#basic-set-operations">38.1 Basic Set operations</a></h3>
<h4 id="creating-sets"><a class="heading-id-link" href="#creating-sets">38.1.1 Creating Sets</a></h4>
<p>There are three common ways of creating Sets.</p>
<p>First, we can use the constructor without any parameters to create an empty Set:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> emptySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();</code>
<code>assert.<span class="hljs-title function_">equal</span>(emptySet.<span class="hljs-property">size</span>, <span class="hljs-number">0</span>);</code>
</pre>
<p>Second, we can pass an iterable (e.g., an Array) to the constructor. The iterated values become elements of the new Set:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'blue'</span>]);</code>
</pre>
<p>Third, the <code>.add()</code> method adds elements to a Set and is chainable:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()</code>
<code>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'red'</span>)</code>
<code>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'green'</span>)</code>
<code>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'blue'</span>);</code>
</pre>
<h4 id="adding-removing-checking-membership"><a class="heading-id-link" href="#adding-removing-checking-membership">38.1.2 Adding, removing, checking membership</a></h4>
<p><code>.add()</code> adds an element to a Set.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();</code>
<code>set.<span class="hljs-title function_">add</span>(<span class="hljs-string">'red'</span>);</code>
</pre>
<p><code>.has()</code> checks if an element is a member of a Set.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-string">'red'</span>), <span class="hljs-literal">true</span>);</code>
</pre>
<p><code>.delete()</code> removes an element from a Set.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">equal</span>(set.<span class="hljs-title function_">delete</span>(<span class="hljs-string">'red'</span>), <span class="hljs-literal">true</span>); <span class="hljs-comment">// there was a deletion</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-string">'red'</span>), <span class="hljs-literal">false</span>);</code>
</pre>
<h4 id="determining-the-size-of-a-set-and-clearing-it"><a class="heading-id-link" href="#determining-the-size-of-a-set-and-clearing-it">38.1.3 Determining the size of a Set and clearing it</a></h4>
<p><code>.size</code> contains the number of elements in a Set.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()</code>
<code>  .<span class="hljs-title function_">add</span>(<span class="hljs-string">'foo'</span>)</code>
<code>  .<span class="hljs-title function_">add</span>(<span class="hljs-string">'bar'</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(set.<span class="hljs-property">size</span>, <span class="hljs-number">2</span>)</code>
</pre>
<p><code>.clear()</code> removes all elements of a Set.</p>
<pre class="language-js">
<code>set.<span class="hljs-title function_">clear</span>();</code>
<code>assert.<span class="hljs-title function_">equal</span>(set.<span class="hljs-property">size</span>, <span class="hljs-number">0</span>)</code>
</pre>
<h3 id="combining-sets"><a class="heading-id-link" href="#combining-sets">38.2 Combining Sets: union, intersection, difference, symmetric difference<span> <sup>ES2025</sup></span></a></h3>
<p>There are four methods for combining two Sets.</p>
<h4 id="Set.prototype.union"><a class="heading-id-link" href="#Set.prototype.union">38.2.1 Union: <code>set.union(other)</code><span> <sup>ES2025</sup></span></a></h4>
<p><img src="../Images/466ab17df8ce9bada54b76b314e6dec4.png" alt="" style="width:248.672px; height:113.5px" data-original-src="https://exploringjs.com/js/book/img/sets/union.svg"/></p>
<p>The result of <code>set.union(other)</code> is a Set that has the values of both <code>set</code> and <code>other</code>:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]).<span class="hljs-title function_">union</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])</code>
<code>);</code>
</pre>
<h4 id="Set.prototype.intersection"><a class="heading-id-link" href="#Set.prototype.intersection">38.2.2 Intersection: <code>set.intersection(other)</code><span> <sup>ES2025</sup></span></a></h4>
<p><img src="../Images/177acd08f608df8b69590d67b803378a.png" alt="" style="width:248.672px; height:113.5px" data-original-src="https://exploringjs.com/js/book/img/sets/intersection.svg"/></p>
<p>The result of <code>set.intersection(other)</code> is a Set that has the values that <code>set</code> and <code>other</code> have in common:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]).<span class="hljs-title function_">intersection</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'b'</span>])</code>
<code>);</code>
</pre>
<h4 id="Set.prototype.difference"><a class="heading-id-link" href="#Set.prototype.difference">38.2.3 Difference: <code>set.difference(other)</code><span> <sup>ES2025</sup></span></a></h4>
<p><img src="../Images/f64428582010ac4f391a4145f2014ec6.png" alt="" style="width:248.672px; height:113.50006px" data-original-src="https://exploringjs.com/js/book/img/sets/difference.svg"/></p>
<p>The result of <code>set.difference(other)</code> is a Set that has the values that are only in <code>set</code>:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]).<span class="hljs-title function_">difference</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>])</code>
<code>);</code>
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Implementing <code>set.union()</code>, <code>set.intersection()</code> and <code>set.difference()</code></strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/sets/set-union-intersection-difference_test.mjs</code></p>
</div>
<h4 id="Set.prototype.symmetricDifference"><a class="heading-id-link" href="#Set.prototype.symmetricDifference">38.2.4 Symmetric difference: <code>set.symmetricDifference(other)</code><span> <sup>ES2025</sup></span></a></h4>
<p><img src="../Images/752ee7e59a3e2b58f55fc196e668112f.png" alt="" style="width:248.672px; height:113.50006px" data-original-src="https://exploringjs.com/js/book/img/sets/symmetric-difference.svg"/></p>
<p>The result of <code>set.symmetricDifference(other)</code> is a Set that has the values that are only in <code>set</code> or only in <code>other</code>:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]).<span class="hljs-title function_">symmetricDifference</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>])</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]).<span class="hljs-title function_">symmetricDifference</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>])),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>])</code>
<code>);</code>
</pre>
<p>What does <em>symmetric difference</em> mean? These are equivalent definitions of the symmetric difference:</p>
<ul>
  <li>
    (<code>set</code> − <code>other</code>) ∪ (<code>other</code> − <code>set</code>)
    <ul>
      <li>
        Elements that are only in <code>set</code> or only in <code>other</code>. The formula makes it clear why the symmetric difference is both symmetric and a difference.
      </li>
    </ul>
  </li>
  <li>
    (<code>set</code> ∪ <code>other</code>) − (<code>set</code> ∩ <code>other</code>)
    <ul>
      <li>
        The elements of <code>set</code> and <code>other</code> – except for the elements that are in both Sets.
      </li>
    </ul>
  </li>
  <li>
    <code>set</code> xor <code>other</code>
    <ul>
      <li>
        Exclusive Or – visually: Everything that is inside the area of <code>set</code> is inverted. Everything that is outside <code>set</code> is not changed.
      </li>
    </ul>
  </li>
</ul>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercise: Implementing <code>set.symmetricDifference()</code></strong></p>
  <div class="boxout-vspace"/>
  <p><code>exercises/sets/set-symmetric-difference_test.mjs</code></p>
</div>
<h3 id="checking-set-relationships"><a class="heading-id-link" href="#checking-set-relationships">38.3 Checking Set relationships: subset of, superset of, disjoint from<span> <sup>ES2025</sup></span></a></h3>
<p>There are three methods for checking the relationships between two sets.</p>
<h4 id="Set.prototype.isSubsetOf"><a class="heading-id-link" href="#Set.prototype.isSubsetOf">38.3.1 Subset: <code>set.isSubsetOf(other)</code><span> <sup>ES2025</sup></span></a></h4>
<p><code>set.isSubsetOf(other)</code> returns <code>true</code> if all elements of <code>set</code> are in <code>other</code>:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]).<span class="hljs-title function_">isSubsetOf</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])),</code>
<code>  <span class="hljs-literal">true</span></code>
<code>);</code>
</pre>
<h4 id="Set.prototype.isSupersetOf"><a class="heading-id-link" href="#Set.prototype.isSupersetOf">38.3.2 Superset: <code>set.isSupersetOf(other)</code><span> <sup>ES2025</sup></span></a></h4>
<p><code>set.isSupersetOf(other)</code> returns <code>true</code> if <code>set</code> contains all elements of <code>other</code>:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]).<span class="hljs-title function_">isSupersetOf</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>])),</code>
<code>  <span class="hljs-literal">true</span></code>
<code>);</code>
</pre>
<h4 id="Set.prototype.isDisjointFrom"><a class="heading-id-link" href="#Set.prototype.isDisjointFrom">38.3.3 Disjoint: <code>set.isDisjointFrom(other)</code><span> <sup>ES2025</sup></span></a></h4>
<p><code>set.isDisjointFrom(other)</code> returns <code>true</code> if <code>set</code> and <code>other</code> have no elements in common:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]).<span class="hljs-title function_">isDisjointFrom</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'x'</span>])),</code>
<code>  <span class="hljs-literal">true</span></code>
<code>);</code>
</pre>
<div class="boxout">
  <p><img src="../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png" class="boxout-icon" height="24" alt="Icon “exercise”" data-original-src="https://exploringjs.com/js/book/icon/exercise.svg"/> <strong>Exercises for Set relationship methods</strong></p>
  <div class="boxout-vspace"/>
  <ul>
    <li>
      Implementing Set equality: <code>exercises/sets/set-is-equal-to_test.mjs</code>
    </li>
    <li>
      Implementing <code>set.isSubsetOf()</code>:  <code>exercises/sets/is-subset-of_test.mjs</code>
    </li>
    <li>
      Implementing <code>set.isDisjointFrom()</code>:  <code>exercises/sets/is-disjoint-from_test.mjs</code>
    </li>
  </ul>
</div>
<h3 id="set-like-objects"><a class="heading-id-link" href="#set-like-objects">38.4 Set-like objects<span> (advanced)</span></a></h3>
<p>A Set method whose parameter is another Set <code>other</code> does not require <code>other</code> to be an actual Set; it only has to be Set-like and have the following methods:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SetLike</span>&lt;T&gt; {</code>
<code>  <span class="hljs-comment">/** Can be `Infinity` (see next section). */</span></code>
<code>  <span class="hljs-attr">size</span>: <span class="hljs-built_in">number</span>;</code>
<code>  </code>
<code>  <span class="hljs-title function_">has</span>(<span class="hljs-attr">key</span>: T): <span class="hljs-built_in">boolean</span>;</code>
<code/>
<code>  <span class="hljs-comment">/** Returns an iterator for the elements in `this`. */</span></code>
<code>  <span class="hljs-title function_">keys</span>(): <span class="hljs-title class_">Iterator</span>&lt;T&gt;; <span class="hljs-comment">// only method `.next()` is required</span></code>
<code>}</code>
</pre>
<h4 id="examples-finite-setlike-objects"><a class="heading-id-link" href="#examples-finite-setlike-objects">38.4.1 Examples: finite Set-like objects</a></h4>
<p>Let’s implement a simple Set-like object and use it with methods whose parameters are “other Sets”:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> setLike = {</code>
<code>  <span class="hljs-attr">size</span>: <span class="hljs-number">1</span>,</code>
<code>  <span class="hljs-title function_">has</span>(<span class="hljs-params">x</span>) { <span class="hljs-keyword">return</span> x === <span class="hljs-string">'b'</span> },</code>
<code>  * <span class="hljs-title function_">keys</span>(<span class="hljs-params">) { <span class="hljs-keyword">yield</span> <span class="hljs-string">'b'</span> },</span></code>
<code><span class="hljs-params">};</span></code>
<code/>
<code><span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]).<span class="hljs-title function_">difference</span>(setLike),</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>]),</span></code>
<code><span class="hljs-params">);</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]).<span class="hljs-title function_">difference</span>(setLike),</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>]),</span></code>
<code><span class="hljs-params">);</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]).<span class="hljs-title function_">isSupersetOf</span>(setLike),</span></code>
<code><span class="hljs-params">  <span class="hljs-literal">true</span>,</span></code>
<code><span class="hljs-params">);</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'b'</span>]).<span class="hljs-title function_">isSubsetOf</span>(setLike),</span></code>
<code><span class="hljs-params">  <span class="hljs-literal">true</span>,</span></code>
<code><span class="hljs-params">);</span></code>
</pre>
<p>Maps are also Set-like:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> setLike = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">'b'</span>, <span class="hljs-literal">true</span>]]);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]).<span class="hljs-title function_">difference</span>(setLike),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>]),</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]).<span class="hljs-title function_">isSupersetOf</span>(setLike),</code>
<code>  <span class="hljs-literal">true</span>,</code>
<code>);</code>
</pre>
<h4 id="infinite-sets"><a class="heading-id-link" href="#infinite-sets">38.4.2 Examples: infinite Set-like data</a></h4>
<p>The <code>.size</code> of <code>other</code> can be <code>Infinity</code>. That means we can work with infinite Sets:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> evenNumbers = {</code>
<code>  <span class="hljs-title function_">has</span>(<span class="hljs-params">elem</span>) {</code>
<code>    <span class="hljs-keyword">return</span> (elem % <span class="hljs-number">2</span>) === <span class="hljs-number">0</span>;</code>
<code>  },</code>
<code>  <span class="hljs-attr">size</span>: <span class="hljs-title class_">Infinity</span>,</code>
<code>  <span class="hljs-title function_">keys</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>();</span></code>
<code><span class="hljs-params">  }</span></code>
<code><span class="hljs-params">};</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).<span class="hljs-title function_">difference</span>(evenNumbers),</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>])</span></code>
<code><span class="hljs-params">);</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">deepEqual</span>(</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).<span class="hljs-title function_">intersection</span>(evenNumbers),</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>])</span></code>
<code><span class="hljs-params">);</span></code>
</pre>
<p>This works because these methods only invoke <code>other.keys()</code> if <code>other.size</code> is smaller than <code>this.size</code>.</p>
<p>Only two methods don’t support <code>other</code> being an infinite Set:</p>
<ul>
  <li>
    <code>union</code>
  </li>
  <li>
    <code>symmetricDifference</code>
  </li>
</ul>
<h4 id="faq-setlike-objects"><a class="heading-id-link" href="#faq-setlike-objects">38.4.3 FAQ: Set-like objects</a></h4>
<ul>
  <li>
    <p>Why use the interface <code>SetLike</code> for <code>other</code>?</p>
    <ul>
      <li>
        Due to the interface, <code>other</code> can be a data structure that is not a Set. It was chosen as a compromise between accepting only Sets and all iterable objects.
      </li>
    </ul>
  </li>
  <li>
    <p>Why does JavaScript always enforce the full interface <code>SetLike</code> for <code>other</code> and throws an exception if a property is missing or has the wrong dynamic type?</p>
    <ul>
      <li>
        That makes the API simpler and hides implementation details.
      </li>
    </ul>
  </li>
  <li>
    <p>Why was method <code>.keys()</code> chosen for iterating over elements?</p>
    <ul>
      <li>
        That’s due to compatibility with the only Set-like data structure currently in the standard library – <code>Map</code>. Two other Set methods would have been nicer but can’t be used with Maps:
        <ul>
          <li>
            The Map method <code>.[Symbol.iterator]()</code> returns key-value pairs.
          </li>
          <li>
            The Map method <code>.values()</code> is incompatible with the Map method <code>.has()</code> (which accepts keys, not values).
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p>Source: <a href="https://github.com/tc39/proposal-set-methods/blob/main/details.md">TC39 proposal</a></p>
<h3 id="iterating-over-sets-1"><a class="heading-id-link" href="#iterating-over-sets-1">38.5 Iterating over Sets</a></h3>
<p>Sets are iterable and the <code>for-of</code> loop works as we’d expect:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'blue'</span>]);</code>
<code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> set) {</code>
<code>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);</code>
<code>}</code>
</pre>
<p>Output:</p>
<pre>
<code>red</code>
<code>green</code>
<code>blue</code>
</pre>
<p>As we can see, Sets preserve <em>insertion order</em>. That is, elements are always iterated over in the order in which they were added.</p>
<h4 id="converting-set-to-array"><a class="heading-id-link" href="#converting-set-to-array">38.5.1 Converting a Set to an Array</a></h4>
<p>Sets are iterable, which is why we can use <code>Array.from()</code> to convert a Set to an Array:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'blue'</span>]);</code>
<code/>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(set),</code>
<code>  [<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'blue'</span>]</code>
<code>);</code>
</pre>
<p>We can also perform the conversion via an iterator:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  set.<span class="hljs-title function_">values</span>().<span class="hljs-title function_">toArray</span>(),</code>
<code>  [<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'blue'</span>]</code>
<code>);</code>
</pre>
<ul>
  <li>
    <code>set.values()</code> returns in iterator for the values of <code>set</code>.
  </li>
  <li>
    The iterator method <code>.toArray()</code> creates an Array with the iterated values.
  </li>
</ul>
<h4 id="applying-iterator-methods-to-sets"><a class="heading-id-link" href="#applying-iterator-methods-to-sets">38.5.2 Mapping and filtering Sets via iterator methods</a></h4>
<p>Sets don’t have a method <code>.map()</code>. But we can borrow the one that iterators have:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);</code>
<code><span class="hljs-keyword">const</span> mappedSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>( <span class="hljs-comment">// (A)</span></code>
<code>  set.<span class="hljs-title function_">values</span>().<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">2</span>) <span class="hljs-comment">// (B)</span></code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  mappedSet,</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>])</code>
<code>);</code>
</pre>
<p>The previous code shows a common pattern for using iterator methods with Sets:</p>
<ul>
  <li>
    <code>set.values()</code> returns an iterator for <code>set</code> (line B).
  </li>
  <li>
    <code>.map()</code> is an iterator method that returns an iterator (line B).
  </li>
  <li>
    The result of the previous step is an iterable iterator. It is passed to the constructor <code>Set</code> which accepts any iterable as a parameter and uses it to fill the new Set with values.
  </li>
</ul>
<p>Filtering Sets works the same way:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);</code>
<code><span class="hljs-keyword">const</span> filteredSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(</code>
<code>  set.<span class="hljs-title function_">values</span>().<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> (x % <span class="hljs-number">2</span>) === <span class="hljs-number">0</span>)</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  filteredSet,</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">2</span>, <span class="hljs-number">4</span>])</code>
<code>);</code>
</pre>
<p>What if we can’t use iterator methods? Then we can switch to Array methods:</p>
<ul>
  <li>
    We use <code>Array.from(set)</code>
  </li>
  <li>
    instead of <code>set.values()</code>.
  </li>
</ul>
<h4 id="combining-sets-via-iteration"><a class="heading-id-link" href="#combining-sets-via-iteration">38.5.3 Example: combining Sets via iteration<span> <sup>ES2025</sup></span></a></h4>
<p>Instead of the Set methods, we can also use iteration to combine Sets:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);</code>
<code><span class="hljs-keyword">const</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);</code>
<code/>
<code><span class="hljs-comment">// Union</span></code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...a, ...b]),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])</code>
<code>);</code>
<code/>
<code><span class="hljs-comment">// Intersection</span></code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(a.<span class="hljs-title function_">values</span>().<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> b.<span class="hljs-title function_">has</span>(x))),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>])</code>
<code>);</code>
<code/>
<code><span class="hljs-comment">// Difference</span></code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(a.<span class="hljs-title function_">values</span>().<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> !b.<span class="hljs-title function_">has</span>(x))),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>])</code>
<code>);</code>
</pre>
<h4 id="grouping-set-elements-es2024"><a class="heading-id-link" href="#grouping-set-elements-es2024">38.5.4 Grouping Set elements<span> <sup>ES2024</sup></span></a></h4>
<p>Grouping via <code>Object.groupBy()</code> and <code>Map.groupBy()</code> works for any iterable object and therefore for Sets:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">groupBy</span>(</code>
<code>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">0</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]),</code>
<code>    <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sign</span>(x)</code>
<code>  ),</code>
<code>  {</code>
<code>    <span class="hljs-string">'0'</span>: [<span class="hljs-number">0</span>],</code>
<code>    <span class="hljs-string">'-1'</span>: [-<span class="hljs-number">5</span>,-<span class="hljs-number">4</span>],</code>
<code>    <span class="hljs-string">'1'</span>: [<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>],</code>
<code>    <span class="hljs-attr">__proto__</span>: <span class="hljs-literal">null</span>,</code>
<code>  }</code>
<code>);</code>
</pre>
<p>More information: <a href="ch_sync-iteration.html#grouping-sync-iterables">“Grouping iterables<span> <sup>ES2024</sup></span>” (§32.8)</a></p>
<h3 id="examples-of-using-sets"><a class="heading-id-link" href="#examples-of-using-sets">38.6 Examples of using Sets</a></h3>
<h4 id="removing-duplicates-from-an-array"><a class="heading-id-link" href="#removing-duplicates-from-an-array">38.6.1 Removing duplicates from an Array</a></h4>
<p>Converting an Array to a Set and back, removes duplicates from the Array:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>];</code>
<code><span class="hljs-keyword">const</span> noDuplicates = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr));</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  noDuplicates, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</code>
<code>);</code>
</pre>
<h4 id="creating-a-set-of-unicode-characters-code-points"><a class="heading-id-link" href="#creating-a-set-of-unicode-characters-code-points">38.6.2 Creating a set of Unicode characters (code points)</a></h4>
<p>Strings are iterable and can therefore be used as parameters for <code>new Set()</code>:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(<span class="hljs-string">'abc'</span>),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])</code>
<code>);</code>
</pre>
<h3 id="details-of-the-set-api-advanced"><a class="heading-id-link" href="#details-of-the-set-api-advanced">38.7 Details of the Set API<span> (advanced)</span></a></h3>
<h4 id="what-set-elements-are-considered-equal"><a class="heading-id-link" href="#what-set-elements-are-considered-equal">38.7.1 What Set elements are considered equal?</a></h4>
<p>As with Map keys, Set elements are compared similarly to <code>===</code>, with the exception of <code>NaN</code> being equal to itself.</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">NaN</span>]);</span></code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">set.<span class="hljs-property">size</span></span></code>
<code>1</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">set.<span class="hljs-title function_">has</span>(<span class="hljs-title class_">NaN</span>)</span></code>
<code>true</code>
</pre>
<p>As with <code>===</code>, two different objects are never considered equal (and there is no way to change that at the moment):</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();</span></code>
<code/>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">set.<span class="hljs-title function_">add</span>({});</span></code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">set.<span class="hljs-property">size</span></span></code>
<code>1</code>
<code/>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">set.<span class="hljs-title function_">add</span>({});</span></code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">set.<span class="hljs-property">size</span></span></code>
<code>2</code>
</pre>
<h4 id="faq-set-api"><a class="heading-id-link" href="#faq-set-api">38.7.2 FAQ: Set API</a></h4>
<ul>
  <li>
    <p>Why do Sets have a <code>.size</code>, while Arrays have a <code>.length</code>?</p>
    <ul>
      <li>
        The answer to this question is given in <a href="ch_maps.html#collection-size-vs-length">“Why do Maps have a <code>.size</code>, while Arrays have a <code>.length</code>?” (§36.7.4)</a>.
      </li>
    </ul>
  </li>
  <li>
    <p>Why are some method names verbs and others nouns? This is a rough general rule:</p>
    <ul>
      <li>
        Verb methods mutate <code>this</code> – e.g.: <code>set.add()</code> and <code>set.clear()</code>
      </li>
      <li>
        Noun methods return new data – e.g.: <code>set.values()</code> and <code>set.union()</code>
      </li>
    </ul>
  </li>
</ul>
<h3 id="quickref-sets"><a class="heading-id-link" href="#quickref-sets">38.8 Quick reference: <code>Set</code></a></h3>
<h4 id="new-set"><a class="heading-id-link" href="#new-set">38.8.1 <code>new Set()</code></a></h4>
<ul>
  <li>
    <p><code id="qref-new-Set">new Set(iterable)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <ul>
      <li>
        If we don’t provide the parameter <code>values</code>, then an empty Set is created.
      </li>
      <li>
        If we do, then the iterated values are added as elements to the Set.
      </li>
    </ul>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'blue'</span>]);</code>
</pre>
  </li>
</ul>
<h4 id="setprototype-working-with-single-set-elements"><a class="heading-id-link" href="#setprototype-working-with-single-set-elements">38.8.2 <code>Set.prototype.*</code>: working with single Set elements</a></h4>
<ul>
  <li>
    <p><code id="qref-Set.prototype.add">Set.prototype.add(value)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <ul>
      <li>
        Adds <code>value</code> to this Set.
      </li>
      <li>
        This method returns <code>this</code>, which means that it can be chained.
      </li>
    </ul>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'red'</span>]);</code>
<code>set.<span class="hljs-title function_">add</span>(<span class="hljs-string">'green'</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">'blue'</span>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(set), [<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'blue'</span>]</code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Set.prototype.delete">Set.prototype.delete(value)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <ul>
      <li>
        Removes <code>value</code> from this Set.
      </li>
      <li>
        Returns <code>true</code> if something was deleted and <code>false</code>, otherwise.
      </li>
    </ul>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'blue'</span>]);</code>
<code>assert.<span class="hljs-title function_">equal</span>(set.<span class="hljs-title function_">delete</span>(<span class="hljs-string">'red'</span>), <span class="hljs-literal">true</span>); <span class="hljs-comment">// there was a deletion</span></code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(set), [<span class="hljs-string">'green'</span>, <span class="hljs-string">'blue'</span>]</code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Set.prototype.has">Set.prototype.has(value)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>Returns <code>true</code> if <code>value</code> is in this Set and <code>false</code> otherwise.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>]);</code>
<code>assert.<span class="hljs-title function_">equal</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-string">'red'</span>), <span class="hljs-literal">true</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-string">'blue'</span>), <span class="hljs-literal">false</span>);</code>
</pre>
  </li>
</ul>
<h4 id="setprototype-working-with-all-set-elements"><a class="heading-id-link" href="#setprototype-working-with-all-set-elements">38.8.3 <code>Set.prototype.*</code>: working with all Set elements</a></h4>
<ul>
  <li>
    <p><code id="qref-get-Set.prototype.size">get Set.prototype.size</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>Returns how many elements there are in this Set.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'blue'</span>]);</code>
<code>assert.<span class="hljs-title function_">equal</span>(set.<span class="hljs-property">size</span>, <span class="hljs-number">3</span>);</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Set.prototype.clear">Set.prototype.clear()</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>Removes all elements from this Set.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'blue'</span>]);</code>
<code>assert.<span class="hljs-title function_">equal</span>(set.<span class="hljs-property">size</span>, <span class="hljs-number">3</span>);</code>
<code>set.<span class="hljs-title function_">clear</span>();</code>
<code>assert.<span class="hljs-title function_">equal</span>(set.<span class="hljs-property">size</span>, <span class="hljs-number">0</span>);</code>
</pre>
  </li>
</ul>
<h4 id="setprototype-iterating-and-looping"><a class="heading-id-link" href="#setprototype-iterating-and-looping">38.8.4 <code>Set.prototype.*</code>: iterating and looping</a></h4>
<ul>
  <li>
    <p><code id="qref-Set.prototype.values">Set.prototype.values()</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>Returns an iterable over all elements of this Set.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>]);</code>
<code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">values</span>()) {</code>
<code>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);</code>
<code>}</code>
</pre>
    <p>Output:</p>
<pre>
<code>red</code>
<code>green</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Set.prototype-Symbol.iterator-">Set.prototype[Symbol.iterator]()</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>Default way of iterating over Sets. Same as <code>.values()</code>.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>]);</code>
<code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> set) {</code>
<code>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);</code>
<code>}</code>
</pre>
    <p>Output:</p>
<pre>
<code>red</code>
<code>green</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Set.prototype.forEach">Set.prototype.forEach(callback, thisArg?)</code> <span class="ibox ibox-small" size="small">ES6</span></p>
<pre class="language-ts">
<code><span class="hljs-title function_">forEach</span>(</code>
<code>  <span class="hljs-attr">callback</span>: <span class="hljs-function">(<span class="hljs-params">value: T, key: T, theSet: <span class="hljs-built_in">Set</span>&lt;T&gt;</span>) =&gt;</span> <span class="hljs-built_in">void</span>,</code>
<code>  thisArg?: <span class="hljs-built_in">any</span></code>
<code>): <span class="hljs-built_in">void</span></code>
</pre>
    <p>Feeds each element of this Set to <code>callback()</code>. <code>value</code> and <code>key</code> both contain the current element. This redundancy was introduced so that this <code>callback</code> has the same type signature as the <code>callback</code> of <code>Map.prototype.forEach()</code>.</p>
    <p>We can specify the <code>this</code> of <code>callback</code> via <code>thisArg</code>. If we omit it, <code>this</code> is <code>undefined</code>.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>]);</code>
<code>set.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x));</code>
</pre>
    <p>Output:</p>
<pre>
<code>red</code>
<code>green</code>
</pre>
  </li>
</ul>
<h5 id="symmetry-with-map"><a class="heading-id-link" href="#symmetry-with-map">38.8.4.1 Symmetry with <code>Map</code></a></h5>
<p>The following methods make the interface of <code>Set</code> symmetric with the interface of <code>Map</code>.</p>
<ul>
  <li>
    <p><code id="qref-Set.prototype.entries">Set.prototype.entries(): Iterable&lt;[T,T]&gt;</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>Mainly exists so that Sets and Maps have similar interfaces: Each Set element is viewed as a key-value entry whose key and value are both that element:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]).<span class="hljs-title function_">entries</span>().<span class="hljs-title function_">toArray</span>()</span></code>
<code>[ [ 'a', 'a' ], [ 'b', 'b' ], [ 'c', 'c' ] ]</code>
</pre>
    <p><code>.entries()</code> enables us to convert a Set to a Map:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]);</code>
<code><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(set.<span class="hljs-title function_">entries</span>());</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(map.<span class="hljs-title function_">entries</span>()),</code>
<code>  [[<span class="hljs-string">'a'</span>,<span class="hljs-string">'a'</span>], [<span class="hljs-string">'b'</span>,<span class="hljs-string">'b'</span>], [<span class="hljs-string">'c'</span>,<span class="hljs-string">'c'</span>]]</code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Set.prototype.keys">Set.prototype.keys(): Iterable&lt;T&gt;</code> <span class="ibox ibox-small" size="small">ES6</span></p>
    <p>Mainly exists so that Sets and Maps have similar interfaces: Each Set element is viewed as a key-value entry whose key and value are both that element. Therefore the result of <code>.keys()</code> is the same as the result of <code>.values()</code>:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]).<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">toArray</span>()</span></code>
<code>[ 'a', 'b', 'c' ]</code>
</pre>
  </li>
</ul>
<h4 id="setprototype-combining-two-sets-es2025"><a class="heading-id-link" href="#setprototype-combining-two-sets-es2025">38.8.5 <code>Set.prototype.*</code>: combining two Sets<span> <sup>ES2025</sup></span></a></h4>
<ul>
  <li>
    <p><code id="qref-Set.prototype.union">Set.prototype.union(other)</code> <span class="ibox ibox-small" size="small">ES2025</span></p>
<pre class="language-ts">
<code><span class="hljs-title class_">Set</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">union</span>(<span class="hljs-attr">other</span>: <span class="hljs-title class_">SetLike</span>&lt;T&gt;): <span class="hljs-title class_">Set</span>&lt;T&gt;</code>
</pre>
    <p>This method returns a Set that is the union of <code>this</code> and <code>other</code>. It contains a value if it is in <code>this</code> or <code>other</code>.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]).<span class="hljs-title function_">union</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])</code>
<code>);</code>
</pre>
    <p><code>other</code> doesn’t have to be a Set, it only has to be <a href="#set-like-objects"><em>Set-like</em></a> and have the property <code>.size</code> and the methods <code>.has(key)</code> and <code>.keys()</code>. Sets and Maps both fulfill those requirements.</p>
  </li>
  <li>
    <p><code id="qref-Set.prototype.intersection">Set.prototype.intersection(other)</code> <span class="ibox ibox-small" size="small">ES2025</span></p>
<pre class="language-ts">
<code><span class="hljs-title class_">Set</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">intersection</span>(<span class="hljs-attr">other</span>: <span class="hljs-title class_">SetLike</span>&lt;T&gt;): <span class="hljs-title class_">Set</span>&lt;T&gt;</code>
</pre>
    <p>This method returns a Set that is the intersection of <code>this</code> and <code>other</code>. It contains a value if it is in <code>this</code> or <code>other</code>.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]).<span class="hljs-title function_">intersection</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'b'</span>])</code>
<code>);</code>
</pre>
    <p><code>other</code> doesn’t have to be a Set, it only has to be <a href="#set-like-objects"><em>Set-like</em></a> and have the property <code>.size</code> and the methods <code>.has(key)</code> and <code>.keys()</code>. Sets and Maps both fulfill those requirements.</p>
  </li>
  <li>
    <p><code id="qref-Set.prototype.difference">Set.prototype.difference(other)</code> <span class="ibox ibox-small" size="small">ES2025</span></p>
<pre class="language-ts">
<code><span class="hljs-title class_">Set</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">difference</span>(<span class="hljs-attr">other</span>: <span class="hljs-title class_">SetLike</span>&lt;T&gt;): <span class="hljs-title class_">Set</span>&lt;T&gt;</code>
</pre>
    <p>This method returns a Set that is the difference between <code>this</code> and <code>other</code>. It contains a value if it is in <code>this</code> but not in <code>other</code>.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]).<span class="hljs-title function_">difference</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>])</code>
<code>);</code>
</pre>
    <p><code>other</code> doesn’t have to be a Set, it only has to be <a href="#set-like-objects"><em>Set-like</em></a> and have the property <code>.size</code> and the methods <code>.has(key)</code> and <code>.keys()</code>. Sets and Maps both fulfill those requirements.</p>
  </li>
  <li>
    <p><code id="qref-Set.prototype.symmetricDifference">Set.prototype.symmetricDifference(other)</code> <span class="ibox ibox-small" size="small">ES2025</span></p>
<pre class="language-ts">
<code><span class="hljs-title class_">Set</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">symmetricDifference</span>(<span class="hljs-attr">other</span>: <span class="hljs-title class_">SetLike</span>&lt;T&gt;): <span class="hljs-title class_">Set</span>&lt;T&gt;</code>
</pre>
    <p>This method returns a Set that is the symmetric difference between <code>this</code> and <code>other</code>. It contains a value if it is only in <code>this</code> or only in <code>other</code>.</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]).<span class="hljs-title function_">symmetricDifference</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>])</code>
<code>);</code>
</pre>
    <p><code>other</code> doesn’t have to be a Set, it only has to be <a href="#set-like-objects"><em>Set-like</em></a> and have the property <code>.size</code> and the methods <code>.has(key)</code> and <code>.keys()</code>. Sets and Maps both fulfill those requirements.</p>
    <p>For more information on this method, see <a href="#Set.prototype.symmetricDifference">its section in this chapter</a>.</p>
  </li>
</ul>
<h4 id="setprototype-checking-set-relationships-es2025"><a class="heading-id-link" href="#setprototype-checking-set-relationships-es2025">38.8.6 <code>Set.prototype.*</code>: checking Set relationships<span> <sup>ES2025</sup></span></a></h4>
<ul>
  <li>
    <p><code id="qref-Set.prototype.isSubsetOf">Set.prototype.isSubsetOf(other)</code> <span class="ibox ibox-small" size="small">ES2025</span></p>
<pre class="language-ts">
<code><span class="hljs-title class_">Set</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isSubsetOf</span>(<span class="hljs-attr">other</span>: <span class="hljs-title class_">SetLike</span>&lt;T&gt;): <span class="hljs-built_in">boolean</span></code>
</pre>
    <p>Returns <code>true</code> if all elements of <code>this</code> are in <code>other</code>:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]).<span class="hljs-title function_">isSubsetOf</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])),</code>
<code>  <span class="hljs-literal">true</span></code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Set.prototype.isSupersetOf">Set.prototype.isSupersetOf(other)</code> <span class="ibox ibox-small" size="small">ES2025</span></p>
<pre class="language-ts">
<code><span class="hljs-title class_">Set</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isSupersetOf</span>(<span class="hljs-attr">other</span>: <span class="hljs-title class_">SetLike</span>&lt;T&gt;): <span class="hljs-built_in">boolean</span></code>
</pre>
    <p>Returns <code>true</code> if <code>this</code> contains all elements of <code>other</code>:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]).<span class="hljs-title function_">isSupersetOf</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>])),</code>
<code>  <span class="hljs-literal">true</span></code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><code id="qref-Set.prototype.isDisjointFrom">Set.prototype.isDisjointFrom(other)</code> <span class="ibox ibox-small" size="small">ES2025</span></p>
<pre class="language-ts">
<code><span class="hljs-title class_">Set</span>&lt;T&gt;.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isDisjointFrom</span>(<span class="hljs-attr">other</span>: <span class="hljs-title class_">SetLike</span>&lt;T&gt;): <span class="hljs-built_in">boolean</span></code>
</pre>
    <p>Returns <code>true</code> if <code>this</code> and <code>other</code> have no elements in common:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]).<span class="hljs-title function_">isDisjointFrom</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'x'</span>])),</code>
<code>  <span class="hljs-literal">true</span></code>
<code>);</code>
</pre>
  </li>
</ul>

    
      
</body>
</html>