<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>6‚ÄÉNew JavaScript features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>6‚ÄÉNew JavaScript features</h1>
<blockquote>ÂéüÊñáÔºö<a href="https://exploringjs.com/js/book/ch_new-javascript-features.html">https://exploringjs.com/js/book/ch_new-javascript-features.html</a></blockquote>

        
    
    
    
<p><span id="index-entry-Promise"/></p>
<nav class="local-toc">
  <ol>
    <li>
      <a href="#new-in-es2025">6.1‚ÄÉNew in ECMAScript 2025</a>
    </li>
    <li>
      <a href="#new-in-es2024">6.2‚ÄÉNew in ECMAScript 2024</a>
    </li>
    <li>
      <a href="#new-in-es2023">6.3‚ÄÉNew in ECMAScript 2023</a>
    </li>
    <li>
      <a href="#new-in-es2022">6.4‚ÄÉNew in ECMAScript 2022</a>
    </li>
    <li>
      <a href="#new-in-es2021">6.5‚ÄÉNew in ECMAScript 2021</a>
    </li>
    <li>
      <a href="#new-in-es2020">6.6‚ÄÉNew in ECMAScript 2020</a>
    </li>
    <li>
      <a href="#new-in-es2019">6.7‚ÄÉNew in ECMAScript 2019</a>
    </li>
    <li>
      <a href="#new-in-es2018">6.8‚ÄÉNew in ECMAScript 2018</a>
    </li>
    <li>
      <a href="#new-in-es2017">6.9‚ÄÉNew in ECMAScript 2017</a>
    </li>
    <li>
      <a href="#new-in-es2016">6.10‚ÄÉNew in ECMAScript 2016</a>
    </li>
    <li>
      <a href="#source-of-this-chapter">6.11‚ÄÉSource of this chapter</a>
    </li>
  </ol>
</nav>
<p>This chapter lists what‚Äôs new in recent ECMAScript versions ‚Äì in reverse chronological order. It ends before ES6 (ES2015): ES2016 was the first truly incremental release of ECMAScript ‚Äì which is why ES6 has too many features to list here. If you want to get a feeling for earlier releases:</p>
<ul>
  <li>
    My book <a href="https://exploringjs.com/es6.html">‚ÄúExploring ES6‚Äù</a> describes what was added in ES6 (ES2015).
  </li>
  <li>
    My book <a href="https://exploringjs.com/es5/">‚ÄúSpeaking JavaScript‚Äù</a> describes all of the features of ES5 ‚Äì and is therefore a useful time capsule.
  </li>
</ul>
<h3 id="new-in-es2025"><a class="heading-id-link" href="#new-in-es2025">6.1‚ÄÉNew in ECMAScript 2025</a></h3>
<ul>
  <li>
    <p><a href="ch_modules.html#import-attributes">Import attributes</a> provide the syntactic foundation for importing non-JavaScript artifacts. The first such artifacts to be supported are <a href="ch_modules.html#json-modules">JSON modules</a>:</p>
<pre class="language-js">
<code><span class="hljs-comment">// Static import</span></code>
<code><span class="hljs-keyword">import</span> configData1 <span class="hljs-keyword">from</span> <span class="hljs-string">'./config-data.json'</span> <span class="hljs-keyword">with</span> { <span class="hljs-attr">type</span>: <span class="hljs-string">'json'</span> };</code>
<code/>
<code><span class="hljs-comment">// Dynamic import</span></code>
<code><span class="hljs-keyword">const</span> configData2 = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(</code>
<code>  <span class="hljs-string">'./config-data.json'</span>, { <span class="hljs-attr">with</span>: { <span class="hljs-attr">type</span>: <span class="hljs-string">'json'</span> } }</code>
<code>);</code>
</pre>
    <p>The object literal syntax after <code>with</code> is used for specifying import attributes. <code>type</code> is an import attribute.</p>
  </li>
  <li>
    <p><a href="ch_sync-iteration.html#class-iterator">Iterator helper methods</a> let us do more with iterators:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'e'</span>];</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  arr.<span class="hljs-title function_">values</span>() <span class="hljs-comment">// creates an iterator</span></code>
<code>    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>)</code>
<code>    .<span class="hljs-title function_">drop</span>(<span class="hljs-number">1</span>)</code>
<code>    .<span class="hljs-title function_">take</span>(<span class="hljs-number">3</span>)</code>
<code>    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-string">`=<span class="hljs-subst">${x}</span>=`</span>)</code>
<code>    .<span class="hljs-title function_">toArray</span>()</code>
<code>  ,</code>
<code>  [<span class="hljs-string">'=b='</span>, <span class="hljs-string">'=c='</span>, <span class="hljs-string">'=d='</span>]</code>
<code>);</code>
</pre>
    <p>How are iterator methods an improvement over Arrays methods?</p>
    <ul>
      <li>
        Iterator methods can be used with any iterable data structure ‚Äì e.g., they let us filter and map the data structures <code>Set</code> and <code>Map</code>.
      </li>
      <li>
        Iterator methods don‚Äôt create intermediate Arrays and compute data incrementally. That is useful for large amounts of data:
        <ul>
          <li>
            With iterator methods, all methods are applied to the first value, then to the second value, etc.
          </li>
          <li>
            With Array methods, the first method is applied to all values, then the second method is applied to all results, etc.
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Methods for <a href="ch_sets.html#combining-sets">combining Sets</a> and <a href="ch_sets.html#checking-set-relationships">checking Set relationships</a>:</p>
    <ul>
      <li>
        Combining Sets:
        <ul>
          <li>
            <code>Set.prototype.intersection(other)</code>
          </li>
          <li>
            <code>Set.prototype.union(other)</code>
          </li>
          <li>
            <code>Set.prototype.difference(other)</code>
          </li>
          <li>
            <code>Set.prototype.symmetricDifference(other)</code>
          </li>
        </ul>
      </li>
      <li>
        Checking Set relationships:
        <ul>
          <li>
            <code>Set.prototype.isSubsetOf(other)</code>
          </li>
          <li>
            <code>Set.prototype.isSupersetOf(other)</code>
          </li>
          <li>
            <code>Set.prototype.isDisjointFrom(other)</code>
          </li>
        </ul>
      </li>
    </ul>
    <p>Examples:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]).<span class="hljs-title function_">union</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>])),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>])</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]).<span class="hljs-title function_">intersection</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>])),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]).<span class="hljs-title function_">isSubsetOf</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])),</code>
<code>  <span class="hljs-literal">true</span></code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]).<span class="hljs-title function_">isSupersetOf</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>])),</code>
<code>  <span class="hljs-literal">true</span></code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><a href="ch_regexps.html#RegExp.escape"><code>RegExp.escape()</code></a> escapes text so that it can be used inside a regular expression ‚Äì e.g., the following code removes all occurrences of <code>text</code> inside <code>str</code> that are not quoted:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeUnquotedText</span>(<span class="hljs-params">str, text</span>) {</code>
<code>  <span class="hljs-keyword">const</span> regExp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(</code>
<code>    <span class="hljs-string">`(?&lt;!‚Äú)<span class="hljs-subst">${<span class="hljs-built_in">RegExp</span>.<span class="hljs-built_in">escape</span>(text)}</span>(?!‚Äù)`</span>,</code>
<code>    <span class="hljs-string">'gu'</span></code>
<code>  );</code>
<code>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">replaceAll</span>(regExp, <span class="hljs-string">'‚Ä¢'</span>);</code>
<code>}</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">removeUnquotedText</span>(<span class="hljs-string">'‚Äúyes‚Äù and yes and ‚Äúyes‚Äù'</span>, <span class="hljs-string">'yes'</span>),</code>
<code>  <span class="hljs-string">'‚Äúyes‚Äù and ‚Ä¢ and ‚Äúyes‚Äù'</span></code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><a href="ch_regexps.html#regexp-pattern-modifiers">Regular expression pattern modifiers (inline flags)</a> let us apply flags to parts of a regular expression (vs. all of the regular expression) ‚Äì for example, in the following regular expression, the flag <code>i</code> is only applied to ‚ÄúHELLO‚Äù:</p>
  </li>
</ul>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^<span class="hljs-title function_">x</span>(?<span class="hljs-attr">i</span>:<span class="hljs-variable constant_">HELLO</span>)x$/.<span class="hljs-title function_">test</span>(<span class="hljs-string">'xHELLOx'</span>)</span></code>
<code>true</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^<span class="hljs-title function_">x</span>(?<span class="hljs-attr">i</span>:<span class="hljs-variable constant_">HELLO</span>)x$/.<span class="hljs-title function_">test</span>(<span class="hljs-string">'xhellox'</span>)</span></code>
<code>true</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^<span class="hljs-title function_">x</span>(?<span class="hljs-attr">i</span>:<span class="hljs-variable constant_">HELLO</span>)x$/.<span class="hljs-title function_">test</span>(<span class="hljs-string">'XhelloX'</span>)</span></code>
<code>false</code>
</pre>
<ul>
  <li>
    <p><a href="ch_regexps.html#duplicate-named-capture-groups">Duplicate named capture groups</a>: We can now use the same group name twice ‚Äì as long as it appears in different alternatives:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RE</span> = <span class="hljs-regexp">/(?&lt;chars&gt;a+)|(?&lt;chars&gt;b+)/</span>v;</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-variable constant_">RE</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'aaa'</span>).<span class="hljs-property">groups</span>,</code>
<code>  {</code>
<code>    <span class="hljs-attr">chars</span>: <span class="hljs-string">'aaa'</span>,</code>
<code>    <span class="hljs-attr">__proto__</span>: <span class="hljs-literal">null</span>,</code>
<code>  }</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-variable constant_">RE</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'bb'</span>).<span class="hljs-property">groups</span>,</code>
<code>  {</code>
<code>    <span class="hljs-attr">chars</span>: <span class="hljs-string">'bb'</span>,</code>
<code>    <span class="hljs-attr">__proto__</span>: <span class="hljs-literal">null</span>,</code>
<code>  }</code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><a href="ch_promises.html#Promise.try"><code>Promise.try()</code></a> lets us start a Promise chain with code that is not purely asynchronous ‚Äì e.g.:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">computeAsync</span>(<span class="hljs-params">) {</span></code>
<code><span class="hljs-params">  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">try</span>(<span class="hljs-function">() =&gt;</span> {</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">syncFuncMightThrow</span>();</span></code>
<code><span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-title function_">asyncFunc</span>(value);</span></code>
<code><span class="hljs-params">  });</span></code>
<code><span class="hljs-params">}</span></code>
</pre>
  </li>
  <li>
    <p>Support for 16-bit floating point numbers (float16):</p>
    <ul>
      <li>
        <a href="ch_math.html#rounding-floats"><code>Math.f16round()</code></a>
      </li>
      <li>
        <a href="ch_typed-arrays.html#typed-array-element-types">New element type for the Typed Arrays API</a>:
        <ul>
          <li>
            <code>Float16Array</code>
          </li>
          <li>
            <code>DataView.prototype.getFloat16()</code>
          </li>
          <li>
            <code>DataView.prototype.setFloat16()</code>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<h3 id="new-in-es2024"><a class="heading-id-link" href="#new-in-es2024">6.2‚ÄÉNew in ECMAScript 2024</a></h3>
<ul>
  <li>
    <p><a href="ch_sync-iteration.html#grouping-sync-iterables">Grouping synchronous iterables</a>:</p>
    <p><code>Map.groupBy()</code> groups the items of an iterable into Map entries whose keys are provided by a callback:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Map</span>.<span class="hljs-title function_">groupBy</span>([<span class="hljs-number">0</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sign</span>(x)),</code>
<code>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()</code>
<code>    .<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, [<span class="hljs-number">0</span>])</code>
<code>    .<span class="hljs-title function_">set</span>(-<span class="hljs-number">1</span>, [-<span class="hljs-number">5</span>,-<span class="hljs-number">4</span>])</code>
<code>    .<span class="hljs-title function_">set</span>(<span class="hljs-number">1</span>, [<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>])</code>
<code>);</code>
</pre>
    <p>There is also <code>Object.groupBy()</code> which produces an object instead of a Map:</p>
<pre class="language-js">
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">groupBy</span>([<span class="hljs-number">0</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sign</span>(x)),</code>
<code>  {</code>
<code>    <span class="hljs-string">'0'</span>: [<span class="hljs-number">0</span>],</code>
<code>    <span class="hljs-string">'-1'</span>: [-<span class="hljs-number">5</span>,-<span class="hljs-number">4</span>],</code>
<code>    <span class="hljs-string">'1'</span>: [<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>],</code>
<code>    <span class="hljs-attr">__proto__</span>: <span class="hljs-literal">null</span>,</code>
<code>  }</code>
<code>);</code>
</pre>
  </li>
  <li>
    <p><a href="ch_promises.html#Promise.withResolvers"><code>Promise.withResolvers()</code></a> provides a new way of creating Promises that we want to resolve:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> { promise, resolve, reject } = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">withResolvers</span>();</code>
</pre>
  </li>
  <li>
    <p><a href="ch_regexps.html#regexp-flag-unicode-sets">The new regular expression flag <code>/v</code> (<code>.unicodeSets</code>)</a> enables these features:</p>
    <ul>
      <li>
        <p>Escapes for Unicode string properties (üòµ‚Äçüí´ consists of three code points):</p>
<pre class="language-js">
<code><span class="hljs-comment">// Previously: Unicode code point property `Emoji` via /u</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-regexp">/^\p{Emoji}$/u</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">'üòµ‚Äçüí´'</span>), <span class="hljs-literal">false</span></code>
<code>);</code>
<code><span class="hljs-comment">// New: Unicode string property `RGI_Emoji` via /v</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-regexp">/^\p{RGI_Emoji}$/</span>v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'üòµ‚Äçüí´'</span>), <span class="hljs-literal">true</span></code>
<code>);</code>
</pre>
      </li>
      <li>
        <p>String literals via <code>\q{}</code> in character classes:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\q{üòµ‚Äçüí´}]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'üòµ‚Äçüí´'</span>)</span></code>
<code>true</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\q{abc|def}]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'abc'</span>)</span></code>
<code>true</code>
</pre>
      </li>
      <li>
        <p>Set operations for character classes:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\w--[a-g]]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'a'</span>)</span></code>
<code>false</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\p{<span class="hljs-title class_">Number</span>}--[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'Ÿ£'</span>)</span></code>
<code>true</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^[\p{RGI_Emoji}--\q{üòµ‚Äçüí´}]$/v.<span class="hljs-title function_">test</span>(<span class="hljs-string">'üòµ‚Äçüí´'</span>)</span></code>
<code>false</code>
</pre>
      </li>
      <li>
        <p>Improved matching with <code>/i</code> if a Unicode property escape is negated via <code>[^¬∑¬∑¬∑]</code></p>
      </li>
    </ul>
  </li>
  <li>
    <p>ArrayBuffers get two new features:</p>
    <ul>
      <li>
        <p>They can be <a href="ch_typed-arrays.html#resizing-array-buffers">resized</a> in place:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">2</span>, {<span class="hljs-attr">maxByteLength</span>: <span class="hljs-number">4</span>});</code>
<code><span class="hljs-comment">// `typedArray` starts at offset 2</span></code>
<code><span class="hljs-keyword">const</span> typedArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(buf, <span class="hljs-number">2</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  typedArray.<span class="hljs-property">length</span>, <span class="hljs-number">0</span></code>
<code>);</code>
<code>buf.<span class="hljs-title function_">resize</span>(<span class="hljs-number">4</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  typedArray.<span class="hljs-property">length</span>, <span class="hljs-number">2</span></code>
<code>);</code>
</pre>
      </li>
      <li>
        <p>They get a method <code>.transfer()</code> for <a href="ch_typed-arrays.html#transferring-detaching-array-buffers">transferring</a> them.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>SharedArrayBuffers can be resized, but they can only grow and never shrink. They are not transferrable and therefore don‚Äôt get the method <code>.transfer()</code> that <code>ArrayBuffers</code> got.</p>
  </li>
  <li>
    <p>Two new methods help us ensure that strings are well-formed (w.r.t. <a href="ch_unicode.html#utf-16">UTF-16</a> code units):</p>
    <ul>
      <li>
        <a href="ch_strings.html#qref-String.prototype.isWellFormed">String method <code>.isWellFormed()</code></a> checks if a JavaScript string is <em>well-formed</em> and does not contain any <a href="ch_unicode.html#unicode-lone-surrogate"><em>lone surrogates</em></a>.
      </li>
      <li>
        <a href="ch_strings.html#qref-String.prototype.isWellFormed">String method <code>.toWellFormed()</code></a> returns a copy of the receiver where each lone surrogate is replaced with the code unit 0xFFFD (which represents the code point with the same number, whose name is ‚Äúreplacement character‚Äù). The result is therefore well-formed.
      </li>
    </ul>
  </li>
  <li>
    <p><code>Atomics.waitAsync()</code> lets us wait asynchronously for a change to shared memory. Its functionality is beyond the scope of this book. See <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/waitAsync">the MDN Web Docs</a> for more information.</p>
  </li>
</ul>
<h3 id="new-in-es2023"><a class="heading-id-link" href="#new-in-es2023">6.3‚ÄÉNew in ECMAScript 2023</a></h3>
<ul>
  <li>
    <p><a href="ch_arrays.html#array-operations-destructive-vs-non-destructive">‚ÄúChange Array by copy‚Äù</a>: Arrays and Typed Arrays get new non-destructive methods that copy receivers before changing them:</p>
    <ul>
      <li>
        <p><code>.toReversed()</code> is the non-destructive version of <code>.reverse()</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> original = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];</code>
<code><span class="hljs-keyword">const</span> reversed = original.<span class="hljs-title function_">toReversed</span>();</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(reversed, [<span class="hljs-string">'c'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>]);</code>
<code><span class="hljs-comment">// The original is unchanged</span></code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(original, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]);</code>
</pre>
      </li>
      <li>
        <p><code>.toSorted()</code> is the non-destructive version of <code>.sort()</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> original = [<span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];</code>
<code><span class="hljs-keyword">const</span> sorted = original.<span class="hljs-title function_">toSorted</span>();</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(sorted, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]);</code>
<code><span class="hljs-comment">// The original is unchanged</span></code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(original, [<span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]);</code>
</pre>
      </li>
      <li>
        <p><code>.toSpliced()</code> is the non-destructive version of <code>.splice()</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> original = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>];</code>
<code><span class="hljs-keyword">const</span> spliced = original.<span class="hljs-title function_">toSpliced</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'x'</span>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(spliced, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'x'</span>, <span class="hljs-string">'d'</span>]);</code>
<code><span class="hljs-comment">// The original is unchanged</span></code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(original, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>]);</code>
</pre>
      </li>
      <li>
        <p><code>.with()</code> is the non-destructive version of setting a value with square brackets:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> original = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];</code>
<code><span class="hljs-keyword">const</span> updated = original.<span class="hljs-title function_">with</span>(<span class="hljs-number">1</span>, <span class="hljs-string">'x'</span>);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(updated, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'x'</span>, <span class="hljs-string">'c'</span>]);</code>
<code><span class="hljs-comment">// The original is unchanged</span></code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(original, [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]);</code>
</pre>
      </li>
    </ul>
  </li>
  <li>
    <p>‚ÄúArray find from last‚Äù: <a href="ch_arrays.html#ch_arrays">Arrays</a> and <a href="ch_typed-arrays.html#ch_typed-arrays">Typed Arrays</a> get two new methods:</p>
    <ul>
      <li>
        <p><code>.findLast()</code> is similar to <code>.find()</code> but starts searching at the end of an Array:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">''</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">''</span>].<span class="hljs-title function_">findLast</span>(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>)</span></code>
<code>'b'</code>
</pre>
      </li>
      <li>
        <p><code>.findLastIndex()</code> is similar to <code>.findIndex()</code> but starts searching at the end of an Array:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">''</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">''</span>].<span class="hljs-title function_">findLastIndex</span>(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>)</span></code>
<code>2</code>
</pre>
      </li>
    </ul>
  </li>
  <li>
    <p><a href="ch_weakmaps.html#weakmap-keys-criteria">Symbols as WeakMap keys</a>: Before this feature, only objects could be used as keys in WeakMaps. This feature also lets us use symbols ‚Äì except for <em>registered symbols</em> (created via <code>Symbol.for()</code>).</p>
  </li>
  <li>
    <p><a href="ch_syntax.html#hashbang-lines">‚ÄúHashbang grammar‚Äù</a>: JavaScript now ignores the first line of a file if it starts with a hash (<code>#</code>) and a bang (<code>!</code>). Some JavaScript runtimes, such as Node.js, have done this for a long time. Now it is also part of the language proper. This is an example of a ‚Äúhashbang‚Äù line:</p>
<pre>
<code>#!/usr/bin/env node</code>
</pre>
  </li>
</ul>
<h3 id="new-in-es2022"><a class="heading-id-link" href="#new-in-es2022">6.4‚ÄÉNew in ECMAScript 2022</a></h3>
<ul>
  <li>
    <p>New members of classes:</p>
    <ul>
      <li>
        Properties (public slots) can now be created via:
        <ul>
          <li>
            <a href="ch_classes.html#instance-public-fields">Instance public fields</a>
          </li>
          <li>
            <a href="ch_classes.html#static-public-fields">Static public fields</a>
          </li>
        </ul>
      </li>
      <li>
        <a href="ch_classes.html#private-slots">Private slots</a> are new and can be created via:
        <ul>
          <li>
            Private fields (<a href="ch_classes.html#instance-private-fields">instance private fields</a> and <a href="ch_classes.html#static-private-methods-accessors-fields">static private fields</a>)
          </li>
          <li>
            Private methods and accessors (<a href="ch_classes.html#private-methods-accessors">non-static</a> and <a href="ch_classes.html#static-private-methods-accessors-fields">static</a>)
          </li>
        </ul>
      </li>
      <li>
        <a href="ch_classes.html#class-static-initialization-blocks">Static initialization blocks</a>
      </li>
    </ul>
  </li>
  <li>
    <p><a href="ch_classes.html#private-slot-checks">Private slot checks</a> (‚Äúergonomic brand checks for private fields‚Äù): The following expression checks if <code>obj</code> has a private slot <code>#privateSlot</code>:</p>
<pre class="language-js">
<code>#privateSlot <span class="hljs-keyword">in</span> obj</code>
</pre>
  </li>
  <li>
    <p><a href="ch_modules.html#top-level-await">Top-level <code>await</code> in modules</a>: We can now use <code>await</code> at the top levels of modules and don‚Äôt have to enter async functions or methods anymore.</p>
  </li>
  <li>
    <p><a href="ch_exception-handling.html#error-cause"><code>error.cause</code></a>: <code>Error</code> and its subclasses now let us specify which error caused the current one:</p>
<pre class="language-js">
<code><span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Something went wrong'</span>, {<span class="hljs-attr">cause</span>: otherError})</code>
</pre>
  </li>
  <li>
    <p><a href="ch_arrays.html#Array.prototype.at">Method <code>.at()</code> of indexable values</a> lets us read an element at a given index (like the bracket operator <code>[]</code>) and supports negative indices (unlike the bracket operator).</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">at</span>(<span class="hljs-number">0</span>)</span></code>
<code>'a'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>].<span class="hljs-title function_">at</span>(-<span class="hljs-number">1</span>)</span></code>
<code>'c'</code>
</pre>
    <p>The following ‚Äúindexable‚Äù types have method <code>.at()</code>:</p>
    <ul>
      <li>
        <code>string</code>
      </li>
      <li>
        <code>Array</code>
      </li>
      <li>
        All Typed Array classes: <code>Uint8Array</code> etc.
      </li>
    </ul>
  </li>
  <li>
    <p><a href="ch_regexps.html#regexp-match-indices">RegExp match indices</a>: If we add a flag to a regular expression, using it produces match objects that record the start and end index of each group capture.</p>
  </li>
  <li>
    <p><a href="ch_objects.html#Object.hasOwn"><code>Object.hasOwn(obj, propKey)</code></a> provides a safe way to check if an object <code>obj</code> has an own property with the key <code>propKey</code>.</p>
  </li>
</ul>
<h3 id="new-in-es2021"><a class="heading-id-link" href="#new-in-es2021">6.5‚ÄÉNew in ECMAScript 2021</a></h3>
<ul>
  <li>
    <p><a href="ch_regexps.html#replace-replaceAll"><code>String.prototype.replaceAll()</code></a> lets us replace all matches of a regular expression or a string (<code>.replace()</code> only replaces the first occurrence of a string):</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'abbbaab'</span>.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-string">'b'</span>, <span class="hljs-string">'x'</span>)</span></code>
<code>'axxxaax'</code>
</pre>
  </li>
  <li>
    <p><a href="ch_promises.html#Promise.any"><code>Promise.any()</code></a> and <a href="ch_promises.html#AggregateError"><code>AggregateError</code></a>: <code>Promise.any()</code> returns a Promise that is fulfilled as soon as the first Promise in an iterable of Promises is fulfilled. If there are only rejections, they are put into an <code>AggregateError</code> which becomes the rejection value.</p>
    <p>We use <code>Promise.any()</code> when we are only interested in the first fulfilled Promise among several.</p>
  </li>
  <li>
    <p><a href="ch_operators.html#logical-assignment-operators">Logical assignment operators</a>:</p>
<pre class="language-js">
<code>a ||= b</code>
<code>a &amp;&amp;= b</code>
<code>a ??= b</code>
</pre>
  </li>
  <li>
    <p>Underscores (<code>_</code>) as separators in:</p>
    <ul>
      <li>
        <a href="ch_numbers.html#numeric-separator-number-literals">Number literals</a>: <code>123_456.789_012</code>
      </li>
      <li>
        <a href="ch_bigints.html#numeric-separator-bigint-literals">Bigint literals</a>: <code>6_000_000_000_000_000_000_000_000n</code>
      </li>
    </ul>
  </li>
  <li>
    <p>WeakRefs: This feature is beyond the scope of this book. <a href="https://github.com/tc39/proposal-weakrefs">Quoting its proposal</a> states:</p>
    <ul>
      <li>
        [This proposal] encompasses two major new pieces of functionality:
        <ul>
          <li>
            Creating weak references to objects with the <code>WeakRef</code> class
          </li>
          <li>
            Running user-defined finalizers after objects are garbage-collected, with the <code>FinalizationRegistry</code> class
          </li>
        </ul>
      </li>
      <li>
        Their correct use takes careful thought, and they are best avoided if possible.
      </li>
    </ul>
  </li>
  <li>
    <p><code>Array.prototype.sort</code> has been stable since ES2019. In ES2021, ‚Äú[it] was made more precise, reducing the amount of cases that result in an implementation-defined sort order‚Äù [<a href="https://tc39.es/ecma262/#sec-intro">source</a>]. For more information, see <a href="https://github.com/tc39/ecma262/pull/1585">the pull request for this improvement</a>.</p>
  </li>
</ul>
<h3 id="new-in-es2020"><a class="heading-id-link" href="#new-in-es2020">6.6‚ÄÉNew in ECMAScript 2020</a></h3>
<ul>
  <li>
    <p>New module features:</p>
    <ul>
      <li>
        <p><a href="ch_modules.html#dynamic-imports">Dynamic imports via <code>import()</code></a>: The normal <code>import</code> statement is static: We can only use it at the top levels of modules and its module specifier is a fixed string. <code>import()</code> changes that. It can be used anywhere (including conditional statements) and we can compute its argument.</p>
      </li>
      <li>
        <p><a href="ch_modules.html#import.meta"><code>import.meta</code></a> contains metadata for the current module. Its first widely supported property is <code>import.meta.url</code> which contains a string with the URL of the current module‚Äôs file.</p>
      </li>
      <li>
        <p><a href="ch_modules.html#cheat-sheet-modules">Namespace re-exporting</a>: The following expression imports all exports of module <code>'mod'</code> in a namespace object <code>ns</code> and exports that object.</p>
<pre class="language-js">
<code><span class="hljs-keyword">export</span> * <span class="hljs-keyword">as</span> ns <span class="hljs-keyword">from</span> <span class="hljs-string">'mod'</span>;</code>
</pre>
      </li>
    </ul>
  </li>
  <li>
    <p><a href="ch_objects.html#optional-chaining">Optional chaining for property accesses and method calls</a>. One example of optional chaining is:</p>
<pre class="language-js">
<code>value?.<span class="hljs-property">prop</span></code>
</pre>
    <p>This expression evaluates to <code>undefined</code> if <code>value</code> is either <code>undefined</code> or <code>null</code>. Otherwise, it evaluates to <code>value.prop</code>. This feature is especially useful in chains of property reads when some of the properties may be missing.</p>
  </li>
  <li>
    <p><a href="ch_undefined-null.html#nullish-coalescing-operator">Nullish coalescing operator (<code>??</code>)</a>:</p>
<pre class="language-js">
<code>value ?? defaultValue</code>
</pre>
    <p>This expression is <code>defaultValue</code> if <code>value</code> is either <code>undefined</code> or <code>null</code> and <code>value</code> otherwise. This operator lets us use a default value whenever something is missing.</p>
    <p>Previously the Logical Or operator (<code>||</code>) was used in this case but it has downsides here because it returns the default value whenever the left-hand side is falsy (which isn‚Äôt always correct).</p>
  </li>
  <li>
    <p><a href="ch_bigints.html#ch_bigints">Bigints ‚Äì arbitrary-precision integers</a>: Bigint is a new primitive type. It supports integer numbers that can be arbitrarily large (storage for them grows as necessary).</p>
  </li>
  <li>
    <p><a href="ch_regexps.html#String.prototype.matchAll"><code>String.prototype.matchAll()</code></a>: This method throws if flag <code>/g</code> isn‚Äôt set and returns an iterable with all match objects for a given string.</p>
  </li>
  <li>
    <p><a href="ch_promises.html#Promise.allSettled"><code>Promise.allSettled()</code></a> receives an iterable of Promises. It returns a Promise that is fulfilled once all the input Promises are settled. The fulfillment value is an Array with one object per input Promise ‚Äì either one of:</p>
    <ul>
      <li>
        <code>{ status: 'fulfilled', value: ¬´fulfillment value¬ª }</code>
      </li>
      <li>
        <code>{ status: 'rejected',  reason: ¬´rejection value¬ª }</code>
      </li>
    </ul>
  </li>
  <li>
    <p><a href="ch_variables-assignment.html#globalThis"><code>globalThis</code></a> provides a way to access the global object that works both on browsers and server-side platforms such as Node.js and Deno.</p>
  </li>
  <li>
    <p><code>for-in</code> mechanics: This feature is beyond the scope of this book. For more information on it, see <a href="https://github.com/tc39/proposal-for-in-order">its proposal</a>.</p>
  </li>
  <li>
    <p><a href="ch_modules.html#re-exporting">Namespace re-exporting</a>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">export</span> * <span class="hljs-keyword">as</span> ns <span class="hljs-keyword">from</span> <span class="hljs-string">'./internal.mjs'</span>;</code>
</pre>
  </li>
</ul>
<h3 id="new-in-es2019"><a class="heading-id-link" href="#new-in-es2019">6.7‚ÄÉNew in ECMAScript 2019</a></h3>
<ul>
  <li>
    <p>Array method <a href="ch_arrays.html#Array.prototype.flatMap"><code>.flatMap()</code></a> works like <code>.map()</code> but lets the callback return Arrays of zero or more values instead of single values. The returned Arrays are then concatenated and become the result of <code>.flatMap()</code>. Use cases include:</p>
    <ul>
      <li>
        Filtering and mapping at the same time
      </li>
      <li>
        Mapping single input values to multiple output values
      </li>
    </ul>
  </li>
  <li>
    <p>Array method <a href="ch_arrays.html#qref-Array.prototype.flat"><code>.flat()</code></a> converts nested Arrays into flat Arrays. Optionally, we can tell it at which depth of nesting it should stop flattening.</p>
  </li>
  <li>
    <p><a href="ch_objects.html#Object.fromEntries"><code>Object.fromEntries()</code></a> creates an object from an iterable over <em>entries</em>. Each entry is a two-element Array with a property key and a property value.</p>
  </li>
  <li>
    <p>String methods: <a href="ch_strings.html#qref-String.prototype.trimStart"><code>.trimStart()</code></a> and <a href="ch_strings.html#qref-String.prototype.trimEnd"><code>.trimEnd()</code></a> work like <code>.trim()</code> but remove whitespace only at the start or only at the end of a string.</p>
  </li>
  <li>
    <p><a href="ch_exception-handling.html#omitting-catch-binding">Optional <code>catch</code> binding</a>: We can now omit the parameter of a <code>catch</code> clause if we don‚Äôt use it.</p>
  </li>
  <li>
    <p><a href="ch_symbols.html#symbol-descriptions"><code>Symbol.prototype.description</code></a> is a getter for reading the description of a symbol. Previously, the description was included in the result of <code>.toString()</code> but couldn‚Äôt be accessed individually.</p>
  </li>
  <li>
    <p><code>.sort()</code> for Arrays and Typed Arrays is now guaranteed to be <em>stable</em>: If elements are considered equal by sorting, then sorting does not change the order of those elements (relative to each other).</p>
  </li>
</ul>
<p>These ES2019 features are beyond the scope of this book:</p>
<ul>
  <li>
    JSON superset: See <a href="https://2ality.com/2019/01/json-superset.html">2ality blog post</a>.
  </li>
  <li>
    Well-formed <code>JSON.stringify()</code>: See <a href="https://2ality.com/2019/01/well-formed-stringify.html">2ality blog post</a>.
  </li>
  <li>
    <code>Function.prototype.toString()</code> revision: See <a href="https://2ality.com/2016/08/function-prototype-tostring.html">2ality blog post</a>.
  </li>
</ul>
<h3 id="new-in-es2018"><a class="heading-id-link" href="#new-in-es2018">6.8‚ÄÉNew in ECMAScript 2018</a></h3>
<ul>
  <li>
    <p><a href="ch_async-iteration.html#ch_async-iteration">Asynchronous iteration</a> is the asynchronous version of synchronous iteration. It is based on Promises:</p>
    <ul>
      <li>
        With synchronous iterables, we can immediately access each item. With asynchronous iterables, we have to <code>await</code> before we can access an item.
      </li>
      <li>
        With synchronous iterables, we use <code>for-of</code> loops. With asynchronous iterables, we use <code>for-await-of</code> loops.
      </li>
    </ul>
  </li>
  <li>
    <p><a href="ch_objects.html#spreading-into-object-literals">Spreading into object literals</a>: By using spreading (<code>...</code>) inside an object literal, we can copy the properties of another object into the current one. One use case is to create a shallow copy of an object <code>obj</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> shallowCopy = {...obj};</code>
</pre>
  </li>
  <li>
    <p><a href="ch_destructuring.html#rest-properties">Rest properties (destructuring)</a>: When object-destructuring a value, we can now use rest syntax (<code>...</code>) to get all previously unmentioned properties in an object.</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> {a, ...remaining} = {<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>};</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(remaining, {<span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>});</code>
</pre>
  </li>
  <li>
    <p><a href="ch_promises.html#Promise.prototype.finally"><code>Promise.prototype.finally()</code></a> is related to the <code>finally</code> clause of a try-catch-finally statement ‚Äì similarly to how the Promise method <code>.then()</code> is related to the <code>try</code> clause and <code>.catch()</code> is related to the <code>catch</code> clause.</p>
    <p>On other words: The callback of <code>.finally()</code> is executed regardless of whether a Promise is fulfilled or rejected.</p>
  </li>
  <li>
    <p>New Regular expression features:</p>
    <ul>
      <li>
        <p><a href="ch_regexps.html#named-capture-groups"><code>RegExp</code> named capture groups</a>: In addition to accessing groups by number, we can now name them and access them by name:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> matchObj = <span class="hljs-string">'---756---'</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/(?&lt;digits&gt;[0-9]+)/</span>)</code>
<code>assert.<span class="hljs-title function_">equal</span>(matchObj.<span class="hljs-property">groups</span>.<span class="hljs-property">digits</span>, <span class="hljs-string">'756'</span>);</code>
</pre>
      </li>
      <li>
        <p><a href="ch_regexps.html#regexp-lookbehind-assertions"><code>RegExp</code> lookbehind assertions</a> complement lookahead assertions:</p>
        <ul>
          <li>
            Positive lookbehind: <code>(?&lt;=X)</code> matches if the current location is preceded by <code>'X'</code>.
          </li>
          <li>
            Negative lookbehind: <code>(?&lt;!X)</code> matches if the current location is not preceded by <code>'(?&lt;!X)'</code>.
          </li>
        </ul>
      </li>
      <li>
        <p><a href="ch_regexps.html#regexp-dot-all-flag"><code>s</code> (<code>dotAll</code>) flag for regular expressions</a>. If this flag is active, the dot matches line terminators (by default, it doesn‚Äôt).</p>
      </li>
      <li>
        <p><a href="ch_regexps.html#unicode-character-property-escapes"><code>RegExp</code> Unicode property escapes</a> give us more power when matching sets of Unicode code points ‚Äì for example:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\p{<span class="hljs-title class_">Lowercase</span>_Letter}+$/u.<span class="hljs-title function_">test</span>(<span class="hljs-string">'a√ºœÄ'</span>)</span></code>
<code>true</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\p{<span class="hljs-title class_">White</span>_Space}+$/u.<span class="hljs-title function_">test</span>(<span class="hljs-string">'\n \t'</span>)</span></code>
<code>true</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/^\p{<span class="hljs-title class_">Script</span>=<span class="hljs-title class_">Greek</span>}+$/u.<span class="hljs-title function_">test</span>(<span class="hljs-string">'Œ©ŒîŒ®'</span>)</span></code>
<code>true</code>
</pre>
      </li>
    </ul>
  </li>
  <li>
    <p><a href="ch_template-literals.html#template-strings-cooked-vs-raw">Template literal revision</a> allows text with backslashes in tagged templates that is illegal in string literals ‚Äì for example:</p>
<pre>
<code>windowsPath`C:\uuu\xxx\111`</code>
<code>latex`\unicode`</code>
</pre>
  </li>
</ul>
<h3 id="new-in-es2017"><a class="heading-id-link" href="#new-in-es2017">6.9‚ÄÉNew in ECMAScript 2017</a></h3>
<ul>
  <li>
    <p><a href="ch_async-functions.html#ch_async-functions">Async functions (<code>async/await</code>)</a> let us use synchronous-looking syntax to write asynchronous code.</p>
  </li>
  <li>
    <p><a href="ch_objects.html#Object.values"><code>Object.values()</code></a> returns an Array with the values of all enumerable string-keyed properties of a given object.</p>
  </li>
  <li>
    <p><a href="ch_objects.html#Object.entries"><code>Object.entries()</code></a> returns an Array with the key-value pairs of all enumerable string-keyed properties of a given object. Each pair is encoded as a two-element Array.</p>
  </li>
  <li>
    <p>String padding: The string methods <a href="ch_strings.html#qref-String.prototype.padStart"><code>.padStart()</code></a> and <a href="ch_strings.html#qref-String.prototype.padEnd"><code>.padEnd()</code></a> insert padding text until the receivers are long enough:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'7'</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">3</span>, <span class="hljs-string">'0'</span>)</span></code>
<code>'007'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">'yes'</span>.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">6</span>, <span class="hljs-string">'!'</span>)</span></code>
<code>'yes!!!'</code>
</pre>
  </li>
  <li>
    <p><a href="ch_callables.html#trailing-commas-parameters">Trailing commas in function parameter lists and calls</a>: Trailing commas have been allowed in Arrays literals since ES3 and in Object literals since ES5. They are now also allowed in function calls and method calls.</p>
  </li>
  <li>
    <p><a href="ch_objects.html#qref-Object.getOwnPropertyDescriptors"><code>Object.getOwnPropertyDescriptors()</code></a> lets us define properties via an object with property descriptors:</p>
  </li>
  <li>
    <p>The feature ‚ÄúShared memory and atomics‚Äù is beyond the scope of this book. For more information on it, see:</p>
    <ul>
      <li>
        The documentation on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer"><code>SharedArrayBuffer</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics"><code>Atomics</code></a> on MDN Web Docs
      </li>
      <li>
        <a href="https://github.com/tc39/proposal-ecmascript-sharedmem">The ECMAScript proposal ‚ÄúShared memory and atomics‚Äù</a>
      </li>
    </ul>
  </li>
</ul>
<h3 id="new-in-es2016"><a class="heading-id-link" href="#new-in-es2016">6.10‚ÄÉNew in ECMAScript 2016</a></h3>
<ul>
  <li>
    <p><a href="ch_arrays.html#qref-Array.prototype.includes"><code>Array.prototype.includes()</code></a> checks if an Array contains a given value.</p>
  </li>
  <li>
    <p><a href="ch_numbers.html#binary-arithmetic-operators">Exponentiation operator (<code>**</code>)</a>:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">4</span> ** <span class="hljs-number">2</span></span></code>
<code>16</code>
</pre>
  </li>
</ul>
<h3 id="source-of-this-chapter"><a class="heading-id-link" href="#source-of-this-chapter">6.11‚ÄÉSource of this chapter</a></h3>
<p>ECMAScript feature lists were taken from <a href="https://github.com/tc39/proposals/blob/main/finished-proposals.md">the TC39 page on finished proposals</a>.</p>

    
      
</body>
</html>