- en: 14 Creating cross-platform shell scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/nodejs-shell-scripting/ch_creating-shell-scripts.html](https://exploringjs.com/nodejs-shell-scripting/ch_creating-shell-scripts.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 14.1 [Required knowledge](ch_creating-shell-scripts.html#required-knowledge)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.1.1 [What’s next in this chapter](ch_creating-shell-scripts.html#whats-next-in-this-chapter)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.2 [Node.js ESM modules as standalone shell scripts on Unix](ch_creating-shell-scripts.html#node.js-esm-modules-as-standalone-shell-scripts-on-unix)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.2.1 [Node.js shell scripts on Unix](ch_creating-shell-scripts.html#node.js-shell-scripts-on-unix)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.2.2 [Hashbangs on Unix](ch_creating-shell-scripts.html#hashbangs-on-unix)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.2.3 [Making files executable on Unix](ch_creating-shell-scripts.html#making-files-executable-on-unix)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.2.4 [Running `hello.mjs` directly](ch_creating-shell-scripts.html#running-hello.mjs-directly)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.3 [Creating an npm package with shell scripts](ch_creating-shell-scripts.html#creating-an-npm-package-with-shell-scripts)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.3.1 [Setting up the package’s directory](ch_creating-shell-scripts.html#npm-init)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.3.2 [Adding dependencies](ch_creating-shell-scripts.html#adding-dependencies)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.3.3 [Adding content to the package](ch_creating-shell-scripts.html#adding-content-to-the-package)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.3.4 [Running the shell scripts without installing them](ch_creating-shell-scripts.html#running-the-shell-scripts-without-installing-them)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.4 [How npm installs shell scripts](ch_creating-shell-scripts.html#how-npm-installs-shell-scripts)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.4.1 [Installation on Unix](ch_creating-shell-scripts.html#installation-on-unix)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.4.2 [Installation on Windows](ch_creating-shell-scripts.html#installation-on-windows)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.5 [Publishing the example package to the npm registry](ch_creating-shell-scripts.html#publishing-the-example-package-to-the-npm-registry)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.5.1 [Which files are published? Which files are ignored?](ch_creating-shell-scripts.html#which-files-are-published-which-files-are-ignored)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.5.2 [Checking if a package is properly configured](ch_creating-shell-scripts.html#checking-if-a-package-is-properly-configured)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '14.5.3 [`npm publish`: uploading packages to the npm registry](ch_creating-shell-scripts.html#npm-publish)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.5.4 [Automatically performing tasks every time before publishing](ch_creating-shell-scripts.html#automatically-performing-tasks-every-time-before-publishing)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.6 [Standalone Node.js shell scripts with arbitrary extensions on Unix](ch_creating-shell-scripts.html#standalone-node.js-shell-scripts-with-arbitrary-extensions-on-unix)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '14.6.1 [Unix: arbitrary filename extension via a custom executable](ch_creating-shell-scripts.html#unix-arbitrary-filename-extension-via-a-custom-executable)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '14.6.2 [Unix: arbitrary filename extension via a shell prolog](ch_creating-shell-scripts.html#unix-arbitrary-filename-extension-via-a-shell-prolog)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.7 [Standalone Node.js shell scripts on Windows](ch_creating-shell-scripts.html#standalone-node.js-shell-scripts-on-windows)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '14.7.1 [Windows: configuring the filename extension `.mjs`](ch_creating-shell-scripts.html#windows-configuring-the-filename-extension-.mjs)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '14.7.2 [Windows Command shell: Node.js scripts via a shell prolog](ch_creating-shell-scripts.html#windows-command-shell-node.js-scripts-via-a-shell-prolog)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '14.7.3 [Windows PowerShell: Node.js scripts via a shell prolog](ch_creating-shell-scripts.html#windows-powershell-node.js-scripts-via-a-shell-prolog)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.8 [Creating native binaries for Linux, macOS, and Windows](ch_creating-shell-scripts.html#creating-native-binaries-for-linux-macos-and-windows)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '14.9 [Shell paths: making sure shells find scripts](ch_creating-shell-scripts.html#shell-paths-making-sure-shells-find-scripts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '14.9.1 [Unix: `$PATH`](ch_creating-shell-scripts.html#unix-path)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.9.2 [Changing the PATH variable on Windows (Command shell, PowerShell)](ch_creating-shell-scripts.html#changing-the-path-variable-on-windows-command-shell-powershell)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we learn how to implement shell scripts via Node.js ESM modules.
    There are two common ways of doing so:'
  prefs: []
  type: TYPE_NORMAL
- en: We can write a stand-alone script and install it ourselves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can put our script in an npm package and use a package manager to install
    it. That also gives us the option to publish the package to the npm registry so
    that others can install it, too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.1 Required knowledge
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You should be loosely familiar with the following two topics:'
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript Modules, as explained in [chapter “modules”](https://exploringjs.com/impatient-js/ch_modules.html)
    in “JavaScript for impatient programmers”.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'npm packages, as explained in [§5 “Packages: JavaScript’s units for software
    distribution”](ch_packages.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.1.1 What’s next in this chapter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Windows doesn’t really support standalone shell scripts written in JavaScript.
    Therefore, we’ll first look into how to write standalone scripts *with* filename
    extensions for Unix. That knowledge will help us with creating packages that contain
    shell scripts. Later, we’ll learn:'
  prefs: []
  type: TYPE_NORMAL
- en: A trick for writing standalone shell scripts on Windows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A trick for writing standalone shell scripts *without* filename extensions on
    Unix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing shell scripts via packages is the topic of [§13 “Installing npm packages
    and running bin scripts”](ch_installing-packages.html).
  prefs: []
  type: TYPE_NORMAL
- en: 14.2 Node.js ESM modules as standalone shell scripts on Unix
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s turn an ESM module into a Unix shell script that we can run without it
    being inside a package. In principle, we can choose between two filename extensions
    for ESM modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.mjs` files are always interpreted as ESM modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.js` files are only interpreted as ESM modules if the closest `package.json`
    has the following entry:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, since we want to create a standalone script, we can’t rely on `package.json`
    being there. Therefore, we have to use the filename extension `.mjs` (we’ll get
    to workarounds later).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following file has the name `hello.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can already run this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 14.2.1 Node.js shell scripts on Unix
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to do two things so that we can run `hello.mjs` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'These things are:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a *hashbang* line at the beginning of `hello.mjs`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making `hello.mjs` executable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.2.2 Hashbangs on Unix
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In a Unix shell script, the first line is a *hashbang* – metadata that tells
    the shell how to execute the file. For example, this is the most common hashbang
    for Node.js scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This line has the name “hashbang” because it starts with a hash symbol and an
    exclamation mark. It is also often called “shebang”.
  prefs: []
  type: TYPE_NORMAL
- en: If a line starts with a hash, it is a comment in most Unix shells (sh, bash,
    zsh, etc.). Therefore, the hashbang is ignored by those shells. Node.js also ignores
    it, but only if it is the first line.
  prefs: []
  type: TYPE_NORMAL
- en: Why don’t we use this hashbang?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Not all Unixes install the Node.js binary at that path. How about this path
    then?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Alas, not all Unixes allow relative paths. That’s why we refer to `env` via
    an absolute path and use it to run `node` for us.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on Unix hashbangs, see [“Node.js shebang”](https://alexewerlof.medium.com/node-shebang-e1d4b02f731d)
    by Alex Ewerlöf.
  prefs: []
  type: TYPE_NORMAL
- en: 14.2.2.1 Passing arguments to the Node.js binary
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: What if we want to pass arguments such as command line options to the Node.js
    binary?
  prefs: []
  type: TYPE_NORMAL
- en: 'One solution that works on many Unixes is to use option `-S` for `env` which
    prevents it from interpreting all of its arguments as a single name of a binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: On macOS, the previous command works even without `-S`; on Linux it usually
    doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: '14.2.2.2 Hashbang pitfall: creating hashbangs on Windows'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If we use a text editor on Windows to create an ESM module that should run
    as a script on either Unix or Windows, we have to add a hashbang. If we do that,
    the first line will end with the Windows line terminator `\r\n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Running a file with such a hashbang on Unix produces the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That is, `env` thinks the name of the executable is `node\r`. There are two
    ways to fix this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, some editors automatically check which line terminators are already
    used in a file and keep using them. For example, Visual Studio Code, shows the
    current line terminator (it calls it “end of line sequence”) in the status bar
    at the bottom right:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LF` (line feed) for the Unix line terminator `\n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CRLF` (carriage return, line feed) for the Windows line terminator `\r\n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can switch pick a line terminator by clicking on that status information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, we can create a minimal file `my-script.mjs` with only Unix line terminators
    that we never edit on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 14.2.3 Making files executable on Unix
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In order to become a shell script, `hello.mjs` must also be executable (a permission
    of files), in addition to having a hashbang:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that we made the file executable (`x`) for the user who created it (`u`),
    not for everyone.
  prefs: []
  type: TYPE_NORMAL
- en: 14.2.4 Running `hello.mjs` directly
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`hello.mjs` is now executable and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can therefore run it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Alas, there is no way to tell `node` to interpret a file with an arbitrary extension
    as an ESM module. That’s why we have to use the extension `.mjs`. Workarounds
    are possible but complicated, as we’ll see later.
  prefs: []
  type: TYPE_NORMAL
- en: 14.3 Creating an npm package with shell scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section we create an npm package with shell scripts. We then examine
    how we can install such a package so that its scripts become available at the
    command line of your system (Unix or Windows).
  prefs: []
  type: TYPE_NORMAL
- en: 'The finished package is available here:'
  prefs: []
  type: TYPE_NORMAL
- en: On GitHub as [`rauschma/demo-shell-scripts`](https://github.com/rauschma/demo-shell-scripts)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On npm as [`@rauschma/demo-shell-scripts`](https://www.npmjs.com/package/@rauschma/demo-shell-scripts)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.3.1 Setting up the package’s directory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These commands work on both Unix and Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now there are the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 14.3.1.1 `package.json` for unpublished packages
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One option is to create a package and not publish it to the npm registry. We
    can still install such a package on our system (as explained later). In that case,
    our `package.json` looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Explanations:'
  prefs: []
  type: TYPE_NORMAL
- en: Making the package private means that no name or version is needed and that
    it can’t be accidentally published.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"UNLICENSED"` denies others the right to use the package under any terms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.3.1.2 `package.json` for published packages
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If we want to publish our package to the npm registry, our `package.json` looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For your own packages, you need to replace the value of `"name"` with a package
    name that works for you:'
  prefs: []
  type: TYPE_NORMAL
- en: Either a globally unique name. Such a name should only be used for important
    packages because we don’t want to prevent others from using the name otherwise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Or a *scoped name*: To publish a package, you need an npm account (how to get
    one is explained later). The name of your account can be used as a *scope* for
    package names. For example, if your account name is `jane`, you can use the following
    package name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 14.3.2 Adding dependencies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we install a dependency that we want to use in one of our scripts – package
    `lodash-es` (the ESM version of [Lodash](https://lodash.com)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This command:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates the directory `node_modules`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installs package `lodash-es` into it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Adds the following property to `package.json`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creates the file `package-lock.json`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we only use a package during development, we can add it to `"devDependencies"`
    instead of to `"dependencies"` and npm will only install it if we run `npm install`
    inside our package’s directory, but not if we install it as a dependency. A unit
    testing library is a typical dev dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are two ways in which we can install a dev dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: Via `npm install some-package`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use `npm install some-package --save-dev` and then manually move the
    entry for `some-package` from `"dependencies"` to `"devDependencies"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second way means that we can easily postpone the decision whether a package
    is a dependency or a dev dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 14.3.3 Adding content to the package
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s add a readme file and two modules `homedir.mjs` and `versions.mjs` that
    are shell scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to tell npm about the two shell scripts so that it can install them
    for us. That’s what property `"bin"` in `package.json` is for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If we install this package, two shell scripts with the names `homedir` and `versions`
    will become available.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may prefer the filename extension `.js` for the shell scripts. Then, instead
    of the previous property, you have to add the following two properties to `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first property tells Node.js that it should interpret `.js` files as ESM
    modules (and not as CommonJS modules – which is the default).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what `homedir.mjs` looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This module starts with the aforementioned hashbang which is required if we
    want to use it on Unix. It imports function `homedir()` from the built-in module
    `node:os`, calls it and logs the result to the console (i.e., standard output).
  prefs: []
  type: TYPE_NORMAL
- en: Note that `homedir.mjs` does not have to be executable; npm ensure executability
    of `"bin"` scripts when it installs them (we’ll see how soon).
  prefs: []
  type: TYPE_NORMAL
- en: '`versions.mjs` has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We import function `pick()` from Lodash and use it to display three properties
    of the object `process.versions`.
  prefs: []
  type: TYPE_NORMAL
- en: 14.3.4 Running the shell scripts without installing them
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can run, e.g., `homedir.mjs` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 14.4 How npm installs shell scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 14.4.1 Installation on Unix
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A script such as `homedir.mjs` does not need to be executable on Unix because
    npm installs it via an executable symbolic link:'
  prefs: []
  type: TYPE_NORMAL
- en: If we install the package globally, the link is added to a directory that’s
    listed in `$PATH`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we install the package locally (as a dependency), the link is added to `node_modules/.bin/`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.4.2 Installation on Windows
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To install `homedir.mjs` on Windows, npm creates three files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`homedir.bat` is a Command shell script that uses `node` to execute `homedir.mjs`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`homedir.ps1` does the same for PowerShell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`homedir` does the same for Cygwin, MinGW, and MSYS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'npm adds these files to a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: If we install the package globally, the files are added to a directory that’s
    listed in `%Path%`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we install the package locally (as a dependency), the files are added to
    `node_modules/.bin/`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.5 Publishing the example package to the npm registry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s publish package `@rauschma/demo-shell-scripts` (which we have created
    previously) to npm. Before we use `npm publish` to upload the package, we should
    check that everything is configured properly.
  prefs: []
  type: TYPE_NORMAL
- en: 14.5.1 Which files are published? Which files are ignored?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following mechanisms are used to exclude and include files when publishing:'
  prefs: []
  type: TYPE_NORMAL
- en: The files listed in the top-level file `.gitignore` are excluded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can override `.gitignore` with the file `.npmignore`, which has the same
    format.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `package.json` property `"files"` contains an Array with the names of files
    that are included. That means we have a choice of listing either the files we
    want to exclude (in `.npmignore`) or the files we want to include.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some files and directories are excluded by default – e.g.:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`node_modules`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.*.swp`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`._*`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.DS_Store`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.git`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.gitignore`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.npmignore`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.npmrc`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm-debug.log`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Except for these defaults, dot files (files whose names start with dots) are
    included.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following files are never excluded:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package.json`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`README.md` and its variants'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CHANGELOG` and its variants'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LICENSE`, `LICENCE`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The npm documentation has [more details](https://docs.npmjs.com/cli/v8/using-npm/developers#keeping-files-out-of-your-package)
    on what’s included and whats excluded when publishing.
  prefs: []
  type: TYPE_NORMAL
- en: 14.5.2 Checking if a package is properly configured
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are several things we can check before we upload a package.
  prefs: []
  type: TYPE_NORMAL
- en: 14.5.2.1 Checking which files will be uploaded
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *dry run* of `npm install` runs the command without uploading anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This displays which files would be uploaded and several statistics about the
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create an archive of the package as it would exist on the npm registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This command creates the file `rauschma-demo-shell-scripts-1.0.0.tgz` in the
    current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 14.5.2.2 Installing the package globally – without uploading it
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can use either of the following two commands to install our package globally
    without publishing it to the npm registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To see if that worked, we can open a new shell and check if the two commands
    are available. We can also list all globally installed packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 14.5.2.3 Installing the package locally (as a depencency) – without uploading
    it
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To install our package as a dependency, we have to execute the following commands
    (while we are in directory `demo-shell-scripts`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run, e.g., `homedir` with either one of the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '14.5.3 `npm publish`: uploading packages to the npm registry'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we can upload our package, we need to create an npm user account. The
    npm documentation [describes how to do that](https://docs.npmjs.com/creating-a-new-npm-user-account).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can finally publish our package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to specify public access because the defaults are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public` for unscoped packages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restricted` for scoped packages. This setting makes a package [*private*](https://docs.npmjs.com/about-private-packages)
    – which is a paid npm feature used mostly by companies and different from `"private":true`
    in `package.json`. Quoting npm: “With npm private packages, you can use the npm
    registry to host code that is only visible to you and chosen collaborators, allowing
    you to manage and use private code alongside public code in your projects.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Option `--access` only has an effect the first time we publish. Afterward, we
    can omit it and need to use [`npm access`](https://docs.npmjs.com/cli/v8/commands/npm-access)
    to change the access level.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can change the default for the initial `npm publish` via [`publishConfig.access`](https://docs.npmjs.com/cli/v8/using-npm/config#access)
    in `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 14.5.3.1 A new version is required for every upload
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Once we have uploaded a package with a specific version, we can’t use that
    version again, we have to increase either of the three components of the version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We increase `major` if we made breaking changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We increase `minor` if we made backward-compatible changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We increase `patch` if we made small fixes that don’t really change the API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.5.4 Automatically performing tasks every time before publishing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There may be steps that we want to perform every time before we upload a package
    – e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: Running unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling TypeScript code to JavaScript code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That can be done automatically via the `package.json` property `“scripts”.
    That property can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`mocha` is a unit testing library. `tsc` is the TypeScript compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following package scripts are run before `npm publish`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"prepare"` is run:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before `npm pack`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Before `npm publish`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After a local `npm install` without arguments
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"prepublishOnly"` is run only before `npm publish`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on this topic, see [§15 “Running cross-platform tasks via
    npm package scripts”](ch_package-scripts.html).
  prefs: []
  type: TYPE_NORMAL
- en: 14.6 Standalone Node.js shell scripts with arbitrary extensions on Unix
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '14.6.1 Unix: arbitrary filename extension via a custom executable'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Node.js binary `node` uses the filename extension to detect which kind of
    module a file is. There currently is no command line option to override that.
    And the default is CommonJS, which is not what we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can create our own executable for running Node.js and, e.g., call
    it `node-esm`. Then we can rename our previous standalone script `hello.mjs` to
    `hello` (without any extension) if we change the first line to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Previously, the argument of `env` was `node`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is [an implementation of `node-esm`](https://gist.github.com/WebReflection/8840ec29d296f2fa98d8be0102f08590)
    proposed by Andrea Giammarchi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This executable sends the content of a script to `node` via standard input.
    The command line option `--input-type=module` tells Node.js that the text it receives
    is an ESM module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also use the following Unix shell features:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$1` contains the the first argument passed to `node-esm` – the path of the
    script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We delete argument `$0` (the path of `node-esm`) via `shift` and pass on the
    remaining arguments to `node` via `$@`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exec` replaces the current process with the one in which `node` runs. That
    ensures that the script exits with the same code as `node`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hyphen (`-`) separates Node’s arguments from the script’s arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we can use `node-esm`, we have to make sure that it is executable and
    can be found via the `$PATH`. How to do that is explained later.
  prefs: []
  type: TYPE_NORMAL
- en: '14.6.2 Unix: arbitrary filename extension via a shell prolog'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have seen that we can’t specify the module type for a file, only for standard
    input. Therefore, we can write a Unix shell script `hello` that uses Node.js to
    run itself as an ESM module (based on [work by sambal.org](https://sambal.org/2014/02/passing-options-node-shebang-line/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Most of the shell features that we are using here are described at the beginning
    of this chapter. `$?` contains the exit code of the last shell command that was
    executed. That enables `hello` to exit with the same code as `node`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key trick used by this script is that the second line is both Unix shell
    script code and JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: As shell script code, it runs [the quoted command `':'`](https://www.gnu.org/software/bash/manual/html_node/Bourne-Shell-Builtins.html#Bourne-Shell-Builtins)
    which does nothing beyond expanding its arguments and performing redirections.
    Its only argument is the path `//`. Then it pipes the contents of the current
    file to the `node` binary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As JavaScript code, it is the string `':'` (which is interpreted as an expression
    statement and does nothing), followed by a comment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An additional benefit of hiding the shell code from JavaScript is that JavaScript
    editors won’t be confused when it comes to processing and displaying the syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 14.7 Standalone Node.js shell scripts on Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '14.7.1 Windows: configuring the filename extension `.mjs`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One option for creating standalone Node.js shell scripts on Windows is to the
    filename extension `.mjs` and configure it so that files that have it are run
    via `node`. Alas that only works for the Command shell, not for PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another downside is that we can’t pass arguments to a script that way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How do we configure Windows so that the Command shell directly runs files such
    as `args.mjs`?
  prefs: []
  type: TYPE_NORMAL
- en: '*File associations* specify which app a file is opened with when we enter its
    name in a shell. If we associate the filename extension `.mjs` with the Node.js
    binary, we can run ESM modules in shells. One way to do that is via the Settings
    app, as explained in [“How to Change File Associations in Windows”](https://www.lifewire.com/how-to-change-file-associations-in-windows-2624477)
    by Tim Fisher.'
  prefs: []
  type: TYPE_NORMAL
- en: If we additionally add `.MJS` to the variable `%PATHEXT%`, we can even omit
    the filename extension when referring to an ESM module. This environment variable
    can be changed permanently via the Settings app – search for “variables”.
  prefs: []
  type: TYPE_NORMAL
- en: '14.7.2 Windows Command shell: Node.js scripts via a shell prolog'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On Windows, we are facing the challenge that there is no mechanism like hashbangs.
    Therefore, we have to use a workaround that is similar to the one we used for
    extensionless files on Unix: We create a script that runs the JavaScript code
    inside itself via Node.js.'
  prefs: []
  type: TYPE_NORMAL
- en: Command shell scripts have the filename extension `.bat`. We can run a script
    named `script.bat` via either `script.bat` or `script`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what `hello.mjs` looks like if we turn it into a Command shell script
    `hello.bat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code as a file via `node` would require two features that don’t
    exist:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a command line option to override extension-less files being interpreted
    as ESM modules by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skipping lines at the beginning of a file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore, we have no choice but to pipe the file’s content into `node`. We
    also use the following command shell features:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%~f0` contains the full path of the current script, including its filename
    extension. In contrast, `%0` contains the command that was used to invoke the
    script. Therefore, the former shell variable enables us to invoke the script via
    either `hello` or `hello.bat`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%*` contains the command’s arguments – which we pass on to `node`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%errorlevel%` contains the exit code of the last command that was executed.
    We use that value to exit with the same code that was specified by `node`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '14.7.3 Windows PowerShell: Node.js scripts via a shell prolog'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can use a trick similar to the one used in the previous section and turn
    `hello.mjs` into a PowerShell script `hello.ps1` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run this script via either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'However, before we can do that, we need to set an execution policy that allows
    us to run PowerShell scripts ([more information on execution policies](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies)):'
  prefs: []
  type: TYPE_NORMAL
- en: The default policies on Windows clients is `Restricted` and doesn’t let us run
    any scripts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The policy `RemoteSigned` lets us run unsigned local scripts. Downloaded scripts
    must be signed. This is the default on Windows servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following command lets us run local scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 14.8 Creating native binaries for Linux, macOS, and Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[The npm package `pkg`](https://github.com/vercel/pkg) turns a Node.js package
    into a native binary that even runs on systems where Node.js isn’t installed.
    It supports the following platforms: Linux, macOS, and Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: '14.9 Shell paths: making sure shells find scripts'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In most shells, we can type in a filename without directly referring to a file
    and they search several directories for a file with that name and run it. Those
    directories are usually listed in a special shell variable:'
  prefs: []
  type: TYPE_NORMAL
- en: In most Unix shells, we access it via `$PATH`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Windows Command shell, we access it via `%Path%`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In PowerShell, we access it via `$Env:PATH`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need the PATH variable for two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: If we want to install our custom Node.js executable `node-esm`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we want to run a standalone shell script without directly referring to its
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '14.9.1 Unix: `$PATH`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Most Unix shells have the variable `$PATH` that lists all paths where a shell
    looks for executables when we type in a command. Its value may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command works on most shells ([source](https://unix.stackexchange.com/questions/26047/how-to-correctly-add-a-path-to-path/26059#26059))
    and changes the `$PATH` until we leave the current shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The quotes are needed in case one of the two shell variables contains spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 14.9.1.1 Permanently changing the `$PATH`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'On Unix, how the `$PATH` is configured depends on the shell. You can find out
    which shell you are running via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'MacOS uses Zsh where the best place to permanently configure `$PATH` is the
    startup script `$HOME/.zprofile` – [like this](https://stackoverflow.com/questions/11530090/adding-a-new-entry-to-the-path-variable-in-zsh):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 14.9.2 Changing the PATH variable on Windows (Command shell, PowerShell)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On Windows, the default environment variables of the Command shell and PowerShell
    can be configured (permanently) via the Settings app – search for “variables”.
  prefs: []
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/nodejs-shell-scripting/issues/14)'
  prefs: []
  type: TYPE_NORMAL
