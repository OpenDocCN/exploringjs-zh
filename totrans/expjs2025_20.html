<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>16 The non-values undefined and null</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>16 The non-values undefined and null</h1>
<blockquote>原文：<a href="https://exploringjs.com/js/book/ch_undefined-null.html">https://exploringjs.com/js/book/ch_undefined-null.html</a></blockquote>

        
    
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#undefined-vs-null">16.1 <code>undefined</code> vs. <code>null</code></a>
    </li>
    <li>
      <a href="#occurrences-of-undefined-and-null">16.2 Occurrences of <code>undefined</code> and <code>null</code></a>
      <ol>
        <li>
          <a href="#occurrences-of-undefined">16.2.1 Occurrences of <code>undefined</code></a>
        </li>
        <li>
          <a href="#occurrences-of-null">16.2.2 Occurrences of <code>null</code></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#checking-for-undefined-or-null">16.3 Checking for <code>undefined</code> or <code>null</code></a>
    </li>
    <li>
      <a href="#nullish-coalescing-operator">16.4 The nullish coalescing operator (<code>??</code>) for default values<span> <sup>ES2020</sup></span></a>
      <ol>
        <li>
          <a href="#is-shortcircuiting">16.4.0.1 <code>??</code> is short-circuiting</a>
        </li>
        <li>
          <a href="#example-counting-matches">16.4.1 Example: counting matches</a>
        </li>
        <li>
          <a href="#example-specifying-a-default-value-for-a-property">16.4.2 Example: specifying a default value for a property</a>
        </li>
        <li>
          <a href="#legacy-approach-using-logical-or--for-default-values">16.4.3 Legacy approach: using logical Or (<code>||</code>) for default values</a>
        </li>
        <li>
          <a href="#nullish-coalescing-assignment-operator">16.4.4 The nullish coalescing assignment operator (<code>??=</code>)<span> <sup>ES2021</sup></span></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#undefined-null-no-properties">16.5 <code>undefined</code> and <code>null</code> don’t have properties</a>
    </li>
    <li>
      <a href="#history-of-undefined-null">16.6 The history of <code>undefined</code> and <code>null</code></a>
    </li>
  </ol>
</nav>
<p><span id="index-entry-undefined"/><span id="index-entry-null"/></p>
<p>Many programming languages have one “non-value” called <code>null</code>. It indicates that a variable does not currently point to an object – for example, when it hasn’t been initialized yet.</p>
<p>In contrast, JavaScript has two of them: <code>undefined</code> and <code>null</code>.</p>
<h3 id="undefined-vs-null"><a class="heading-id-link" href="#undefined-vs-null">16.1 <code>undefined</code> vs. <code>null</code></a></h3>
<p>Both values are very similar and often used interchangeably. How they differ is therefore subtle. The language itself makes the following distinction:</p>
<ul>
  <li>
    <code>undefined</code> means “not initialized” (e.g., a variable) or “not existing” (e.g., a property of an object).
  </li>
  <li>
    <code>null</code> means “the intentional absence of any object value” (a quote from <a href="https://tc39.es/ecma262/#sec-null-value">the language specification</a>).
  </li>
</ul>
<p>Programmers sometimes make the following distinction:</p>
<ul>
  <li>
    <code>undefined</code> is the non-value used by the language (when something is uninitialized, etc.).
  </li>
  <li>
    <code>null</code> means “explicitly switched off”. That is, it helps implement a type that comprises both meaningful values and a meta-value that stands for “no meaningful value”. Such a type is called <a href="https://en.wikipedia.org/wiki/Option_type"><em>option type</em> or <em>maybe type</em></a> in functional programming.
  </li>
</ul>
<h3 id="occurrences-of-undefined-and-null"><a class="heading-id-link" href="#occurrences-of-undefined-and-null">16.2 Occurrences of <code>undefined</code> and <code>null</code></a></h3>
<p>The following subsections describe where <code>undefined</code> and <code>null</code> appear in the language. We’ll encounter several mechanisms that are explained in more detail later in this book.</p>
<h4 id="occurrences-of-undefined"><a class="heading-id-link" href="#occurrences-of-undefined">16.2.1 Occurrences of <code>undefined</code></a></h4>
<p>Uninitialized variable <code>myVar</code>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">let</span> myVar;</code>
<code>assert.<span class="hljs-title function_">equal</span>(myVar, <span class="hljs-literal">undefined</span>);</code>
</pre>
<p>Parameter <code>x</code> is not provided:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x</span>) {</code>
<code>  <span class="hljs-keyword">return</span> x;</code>
<code>}</code>
<code>assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">func</span>(), <span class="hljs-literal">undefined</span>);</code>
</pre>
<p>Property <code>.unknownProp</code> is missing:</p>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> obj = {};</code>
<code>assert.<span class="hljs-title function_">equal</span>(obj.<span class="hljs-property">unknownProp</span>, <span class="hljs-literal">undefined</span>);</code>
</pre>
<p>If we don’t explicitly specify the result of a function via a <code>return</code> statement, JavaScript returns <code>undefined</code> for us:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">) {}</span></code>
<code><span class="hljs-params">assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">func</span>(), <span class="hljs-literal">undefined</span>);</span></code>
</pre>
<h4 id="occurrences-of-null"><a class="heading-id-link" href="#occurrences-of-null">16.2.2 Occurrences of <code>null</code></a></h4>
<p>The prototype of an object is either an object or, at the end of a chain of prototypes, <code>null</code>. <code>Object.prototype</code> does not have a prototype:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)</span></code>
<code>null</code>
</pre>
<p>If we match a regular expression (such as <code>/a/</code>) against a string (such as <code>'x'</code>), we either get an object with matching data (if matching was successful) or <code>null</code> (if matching failed):</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">/a/.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'x'</span>)</span></code>
<code>null</code>
</pre>
<p>The <a href="ch_json.html#ch_json">JSON data format</a> does not support <code>undefined</code>, only <code>null</code>:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({<span class="hljs-attr">a</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">b</span>: <span class="hljs-literal">null</span>})</span></code>
<code>'{"b":null}'</code>
</pre>
<h3 id="checking-for-undefined-or-null"><a class="heading-id-link" href="#checking-for-undefined-or-null">16.3 Checking for <code>undefined</code> or <code>null</code></a></h3>
<p>Checking for either:</p>
<pre class="language-js">
<code><span class="hljs-keyword">if</span> (x === <span class="hljs-literal">null</span>) ···</code>
<code><span class="hljs-keyword">if</span> (x === <span class="hljs-literal">undefined</span>) ···</code>
</pre>
<p>Does <code>x</code> have a value?</p>
<pre class="language-js">
<code><span class="hljs-keyword">if</span> (x !== <span class="hljs-literal">undefined</span> &amp;&amp; x !== <span class="hljs-literal">null</span>) {</code>
<code>  <span class="hljs-comment">// ···</span></code>
<code>}</code>
<code><span class="hljs-keyword">if</span> (x) { <span class="hljs-comment">// truthy?</span></code>
<code>  <span class="hljs-comment">// x is neither: undefined, null, false, 0, NaN, 0n, ''</span></code>
<code>}</code>
</pre>
<p>Is <code>x</code> either <code>undefined</code> or <code>null</code>?</p>
<pre class="language-js">
<code><span class="hljs-keyword">if</span> (x === <span class="hljs-literal">undefined</span> || x === <span class="hljs-literal">null</span>) {</code>
<code>  <span class="hljs-comment">// ···</span></code>
<code>}</code>
<code><span class="hljs-keyword">if</span> (!x) { <span class="hljs-comment">// falsy?</span></code>
<code>  <span class="hljs-comment">// x is: undefined, null, false, 0, NaN, 0n, ''</span></code>
<code>}</code>
</pre>
<p><em>Truthy</em> means “is <code>true</code> if coerced to boolean”. <em>Falsy</em> means “is <code>false</code> if coerced to boolean”. Both concepts are explained properly in <a href="ch_booleans.html#falsiness-truthiness">“Falsy and truthy values” (§17.2)</a>.</p>
<h3 id="nullish-coalescing-operator"><a class="heading-id-link" href="#nullish-coalescing-operator">16.4 The nullish coalescing operator (<code>??</code>) for default values<span> <sup>ES2020</sup></span></a></h3>
<p><span id="index-entry-nullish-coalescing-operator"/>
<span id="index-entry-operator--nullish-coalescing"/>
<span id="index-entry-default-value-operator"/>
<span id="index-entry-operator--default-value"/>
<span id="index-entry-.x--d"/></p>
<p>The <em>nullish coalescing operator</em> (<code>??</code>) lets us use a default if a value is <code>undefined</code> or <code>null</code>:</p>
<pre class="language-js">
<code>value ?? defaultValue</code>
</pre>
<ul>
  <li>
    If <code>value</code> is <code>undefined</code> nor <code>null</code>, <code>defaultValue</code> is evaluated and the result is returned.
  </li>
  <li>
    Otherwise, <code>value</code> is returned.
  </li>
</ul>
<p>Examples:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">undefined</span> ?? <span class="hljs-string">'default'</span></span></code>
<code>'default'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">null</span> ?? <span class="hljs-string">'default'</span></span></code>
<code>'default'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">false</span> ?? <span class="hljs-string">'default'</span></span></code>
<code>false</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">0</span> ?? <span class="hljs-string">'default'</span></span></code>
<code>0</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">''</span> ?? <span class="hljs-string">'default'</span></span></code>
<code>''</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">{} ?? <span class="hljs-string">'default'</span></span></code>
<code>{}</code>
</pre>
<h5 id="is-shortcircuiting"><a class="heading-id-link" href="#-is-shortcircuiting">16.4.0.1 <code>??</code> is short-circuiting</a></h5>
<p><code>??</code> is <a href="ch_booleans.html#short-circuiting">short-circuiting</a> – the right-hand side is only evaluated if it is actually used:</p>
<pre class="language-js">
<code><span class="hljs-keyword">let</span> evaluated = <span class="hljs-literal">false</span>;</code>
<code/>
<code><span class="hljs-comment">// Right-hand side is not used</span></code>
<code><span class="hljs-number">123</span> ?? (evaluated = <span class="hljs-literal">true</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(evaluated, <span class="hljs-literal">false</span>);</code>
<code/>
<code><span class="hljs-comment">// Right-hand side is used</span></code>
<code><span class="hljs-literal">undefined</span> ?? (evaluated = <span class="hljs-literal">true</span>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(evaluated, <span class="hljs-literal">true</span>);</code>
</pre>
<h4 id="example-counting-matches"><a class="heading-id-link" href="#example-counting-matches">16.4.1 Example: counting matches</a></h4>
<p>The following code shows a real-world example:</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">countMatches</span>(<span class="hljs-params">regex, str</span>) {</code>
<code>  <span class="hljs-keyword">const</span> matchResult = str.<span class="hljs-title function_">match</span>(regex); <span class="hljs-comment">// null or Array</span></code>
<code>  <span class="hljs-keyword">return</span> (matchResult ?? []).<span class="hljs-property">length</span>;</code>
<code>}</code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">countMatches</span>(<span class="hljs-regexp">/a/g</span>, <span class="hljs-string">'ababa'</span>), <span class="hljs-number">3</span></code>
<code>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">countMatches</span>(<span class="hljs-regexp">/b/g</span>, <span class="hljs-string">'ababa'</span>), <span class="hljs-number">2</span></code>
<code>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">countMatches</span>(<span class="hljs-regexp">/x/g</span>, <span class="hljs-string">'ababa'</span>), <span class="hljs-number">0</span></code>
<code>);</code>
</pre>
<p>If there are one or more matches for <code>regex</code> inside <code>str</code>, then <code>.match()</code> returns an Array. If there are no matches, it unfortunately returns <code>null</code> (and not the empty Array). We fix that via the <code>??</code> operator.</p>
<p>We also could have used <a href="ch_objects.html#optional-chaining">optional chaining</a>:</p>
<pre class="language-js">
<code><span class="hljs-keyword">return</span> matchResult?.<span class="hljs-property">length</span> ?? <span class="hljs-number">0</span>;</code>
</pre>
<h4 id="example-specifying-a-default-value-for-a-property"><a class="heading-id-link" href="#example-specifying-a-default-value-for-a-property">16.4.2 Example: specifying a default value for a property</a></h4>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">getTitle</span>(<span class="hljs-params">fileDesc</span>) {</code>
<code>  <span class="hljs-keyword">return</span> fileDesc.<span class="hljs-property">title</span> ?? <span class="hljs-string">'(Untitled)'</span>;</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">const</span> files = [</code>
<code>  { <span class="hljs-attr">path</span>: <span class="hljs-string">'index.html'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'Home'</span> },</code>
<code>  { <span class="hljs-attr">path</span>: <span class="hljs-string">'tmp.html'</span> },</code>
<code>];</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  files.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> <span class="hljs-title function_">getTitle</span>(f)),</code>
<code>  [<span class="hljs-string">'Home'</span>, <span class="hljs-string">'(Untitled)'</span>]</code>
<code>);</code>
</pre>
<h4 id="legacy-approach-using-logical-or--for-default-values"><a class="heading-id-link" href="#legacy-approach-using-logical-or--for-default-values">16.4.3 Legacy approach: using logical Or (<code>||</code>) for default values</a></h4>
<p>Before ECMAScript 2020 and the nullish coalescing operator, logical Or was used for default values. That has a downside.</p>
<p><code>||</code> works as expected for <code>undefined</code> and <code>null</code>:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">undefined</span> || <span class="hljs-string">'default'</span></span></code>
<code>'default'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">null</span> || <span class="hljs-string">'default'</span></span></code>
<code>'default'</code>
</pre>
<p>But it also returns the default for all other falsy values – for example:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">false</span> || <span class="hljs-string">'default'</span></span></code>
<code>'default'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">0</span> || <span class="hljs-string">'default'</span></span></code>
<code>'default'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">0n</span> || <span class="hljs-string">'default'</span></span></code>
<code>'default'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">''</span> || <span class="hljs-string">'default'</span></span></code>
<code>'default'</code>
</pre>
<p>Compare that to how <code>??</code> works:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">undefined</span> ?? <span class="hljs-string">'default'</span></span></code>
<code>'default'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">null</span> ?? <span class="hljs-string">'default'</span></span></code>
<code>'default'</code>
<code/>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-literal">false</span> ?? <span class="hljs-string">'default'</span></span></code>
<code>false</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">0</span> ?? <span class="hljs-string">'default'</span></span></code>
<code>0</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">0n</span> ?? <span class="hljs-string">'default'</span></span></code>
<code>0n</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">''</span> ?? <span class="hljs-string">'default'</span></span></code>
<code>''</code>
</pre>
<h4 id="nullish-coalescing-assignment-operator"><a class="heading-id-link" href="#nullish-coalescing-assignment-operator">16.4.4 The nullish coalescing assignment operator (<code>??=</code>)<span> <sup>ES2021</sup></span></a></h4>
<p><span id="index-entry-nullish-coalescing-assignment-operator------"/>
<span id="index-entry-operator--nullish-coalescing-assignment------"/>
<span id="index-entry-.x---y2"/></p>
<p>The nullish coalescing assignment operator (<code>??=</code>) assigns a default if a value is <code>undefined</code> or <code>null</code>:</p>
<pre class="language-js">
<code>value ??= defaultValue</code>
</pre>
<ul>
  <li>
    If <code>value</code> is either <code>undefined</code> or <code>null</code>, <code>defaultValue</code> is evaluated and assigned to <code>value</code>.
  </li>
  <li>
    Otherwise, nothing happens.
  </li>
</ul>
<p>Examples:</p>
<pre class="language-js">
<code><span class="hljs-keyword">let</span> value;</code>
<code/>
<code>value = <span class="hljs-literal">undefined</span>;</code>
<code>value ??= <span class="hljs-string">'DEFAULT'</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  value, <span class="hljs-string">'DEFAULT'</span></code>
<code>);</code>
<code/>
<code>value = <span class="hljs-number">0</span>;</code>
<code>value ??= <span class="hljs-string">'DEFAULT'</span>;</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  value, <span class="hljs-number">0</span></code>
<code>);</code>
</pre>
<h5 id="is-shortcircuiting-1"><a class="heading-id-link" href="#-is-shortcircuiting-1">16.4.4.1 <code>??=</code> is short-circuiting</a></h5>
<p>The following two expressions are roughly equivalent:</p>
<pre class="language-js">
<code>a ??= b</code>
<code>a ?? (a = b)</code>
</pre>
<p>That means that <code>??=</code> is <a href="ch_booleans.html#short-circuiting">short-circuiting</a> – the following two things only happen if <code>a</code> is <code>undefined</code> or <code>null</code>:</p>
<ul>
  <li>
    <code>b</code> is evaluated.
  </li>
  <li>
    The result is assigned to <code>a</code>.
  </li>
</ul>
<pre class="language-js">
<code><span class="hljs-keyword">let</span> value;</code>
<code/>
<code>value = <span class="hljs-literal">undefined</span>;</code>
<code>value ??= <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'evaluated'</span>);</code>
<code/>
<code>value = <span class="hljs-number">0</span>;</code>
<code>value ??= <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'NOT EVALUATED'</span>);</code>
</pre>
<pre>
<code>evaluated</code>
</pre>
<h5 id="example-using--to-add-missing-properties"><a class="heading-id-link" href="#example-using--to-add-missing-properties">16.4.4.2 Example: using <code>??=</code> to add missing properties</a></h5>
<pre class="language-js">
<code><span class="hljs-keyword">const</span> books = [</code>
<code>  {</code>
<code>    <span class="hljs-attr">isbn</span>: <span class="hljs-string">'123'</span>,</code>
<code>  },</code>
<code>  {</code>
<code>    <span class="hljs-attr">title</span>: <span class="hljs-string">'ECMAScript Language Specification'</span>,</code>
<code>    <span class="hljs-attr">isbn</span>: <span class="hljs-string">'456'</span>,</code>
<code>  },</code>
<code>];</code>
<code/>
<code><span class="hljs-comment">// Add property .title where it’s missing</span></code>
<code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> book <span class="hljs-keyword">of</span> books) {</code>
<code>  book.<span class="hljs-property">title</span> ??= <span class="hljs-string">'(Untitled)'</span>;</code>
<code>}</code>
<code/>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  books,</code>
<code>  [</code>
<code>    {</code>
<code>      <span class="hljs-attr">isbn</span>: <span class="hljs-string">'123'</span>,</code>
<code>      <span class="hljs-attr">title</span>: <span class="hljs-string">'(Untitled)'</span>,</code>
<code>    },</code>
<code>    {</code>
<code>      <span class="hljs-attr">title</span>: <span class="hljs-string">'ECMAScript Language Specification'</span>,</code>
<code>      <span class="hljs-attr">isbn</span>: <span class="hljs-string">'456'</span>,</code>
<code>    },</code>
<code>  ]);</code>
</pre>
<h3 id="undefined-null-no-properties"><a class="heading-id-link" href="#undefined-null-no-properties">16.5 <code>undefined</code> and <code>null</code> don’t have properties</a></h3>
<p><code>undefined</code> and <code>null</code> are the only two JavaScript values where we get an exception if we try to read a property. To explore this phenomenon, let’s use the following function, which reads (“gets”) property <code>.prop</code> and returns the result.</p>
<pre class="language-js">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">getProp</span>(<span class="hljs-params">x</span>) {</code>
<code>  <span class="hljs-keyword">return</span> x.<span class="hljs-property">prop</span>;</code>
<code>}</code>
</pre>
<p>If we apply <code>getProp()</code> to various values, we can see that it only fails for <code>undefined</code> and <code>null</code>:</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">getProp</span>(<span class="hljs-literal">undefined</span>)</span></code>
<code>TypeError: Cannot read properties of undefined (reading 'prop')</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">getProp</span>(<span class="hljs-literal">null</span>)</span></code>
<code>TypeError: Cannot read properties of null (reading 'prop')</code>
<code/>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">getProp</span>(<span class="hljs-literal">true</span>)</span></code>
<code>undefined</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title function_">getProp</span>({})</span></code>
<code>undefined</code>
</pre>
<h3 id="history-of-undefined-null"><a class="heading-id-link" href="#history-of-undefined-null">16.6 The history of <code>undefined</code> and <code>null</code></a></h3>
<p>In Java (which inspired many aspects of JavaScript), initialization values depend on the static type of a variable:</p>
<ul>
  <li>
    Variables with object types are initialized with <code>null</code>.
  </li>
  <li>
    Each primitive type has its own initialization value. For example, <code>int</code> variables are initialized with <code>0</code>.
  </li>
</ul>
<p>JavaScript borrowed <code>null</code> and uses it where objects are expected. It means “not an object”.</p>
<p>However, storage locations in JavaScript (variables, properties, etc.) can hold either primitive values or objects. They need an initialization value that means “neither an object nor a primitive value”. That’s why <code>undefined</code> was introduced.</p>

    
      
</body>
</html>