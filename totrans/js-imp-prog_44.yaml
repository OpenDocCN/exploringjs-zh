- en: 37 Destructuring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/impatient-js/ch_destructuring.html](https://exploringjs.com/impatient-js/ch_destructuring.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 37.1 [A first taste of destructuring](ch_destructuring.html#a-first-taste-of-destructuring)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 37.2 [Constructing vs. extracting](ch_destructuring.html#constructing-vs.-extracting)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 37.3 [Where can we destructure?](ch_destructuring.html#where-can-we-destructure)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 37.4 [Object-destructuring](ch_destructuring.html#object-destructuring)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 37.4.1 [Property value shorthands](ch_destructuring.html#property-value-shorthands)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 37.4.2 [Rest properties](ch_destructuring.html#rest-properties)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '37.4.3 [Syntax pitfall: assigning via object destructuring](ch_destructuring.html#assigning-via-object-destructuring)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 37.5 [Array-destructuring](ch_destructuring.html#array-destructuring)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 37.5.1 [Array-destructuring works with any iterable](ch_destructuring.html#array-destructuring-works-with-any-iterable)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 37.5.2 [Rest elements](ch_destructuring.html#rest-elements)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 37.6 [Examples of destructuring](ch_destructuring.html#examples-of-destructuring)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '37.6.1 [Array-destructuring: swapping variable values](ch_destructuring.html#array-destructuring-swapping-variable-values)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '37.6.2 [Array-destructuring: operations that return Arrays](ch_destructuring.html#array-destructuring-operations-that-return-arrays)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '37.6.3 [Object-destructuring: multiple return values](ch_destructuring.html#object-destructuring-multiple-return-values)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 37.7 [What happens if a pattern part does not match anything?](ch_destructuring.html#what-happens-if-a-pattern-part-does-not-match-anything)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 37.7.1 [Object-destructuring and missing properties](ch_destructuring.html#object-destructuring-and-missing-properties)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 37.7.2 [Array-destructuring and missing elements](ch_destructuring.html#array-destructuring-and-missing-elements)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 37.8 [What values can’t be destructured?](ch_destructuring.html#what-values-cant-be-destructured)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 37.8.1 [You can’t object-destructure `undefined` and `null`](ch_destructuring.html#you-cant-object-destructure-undefined-and-null)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 37.8.2 [You can’t Array-destructure non-iterable values](ch_destructuring.html#you-cant-array-destructure-non-iterable-values)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 37.9 [(Advanced)](ch_destructuring.html#advanced-4)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 37.10 [Default values](ch_destructuring.html#default-values)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 37.10.1 [Default values in Array-destructuring](ch_destructuring.html#default-values-in-array-destructuring)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 37.10.2 [Default values in object-destructuring](ch_destructuring.html#default-values-in-object-destructuring)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 37.11 [Parameter definitions are similar to destructuring](ch_destructuring.html#parameter-definitions-are-similar-to-destructuring)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 37.12 [Nested destructuring](ch_destructuring.html#nested-destructuring)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 37.1 A first taste of destructuring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With normal assignment, you extract one piece of data at a time – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With destructuring, you can extract multiple pieces of data at the same time
    via patterns in locations that receive data. The left-hand side of `=` in the
    previous code is one such location. In the following code, the square brackets
    in line A are a destructuring pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code does the same as the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the pattern is “smaller” than the data: we are only extracting what
    we need.'
  prefs: []
  type: TYPE_NORMAL
- en: 37.2 Constructing vs. extracting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to understand what destructuring is, consider that JavaScript has
    two kinds of operations that are opposites:'
  prefs: []
  type: TYPE_NORMAL
- en: You can *construct* compound data, for example, by setting properties and via
    object literals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can *extract* data out of compound data, for example, by getting properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Constructing data looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Extracting data looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The operation in line A is new: we declare two variables `f2` and `l2` and
    initialize them via *destructuring* (multivalue extraction).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following part of line A is a *destructuring pattern*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Destructuring patterns are syntactically similar to the literals that are used
    for multivalue construction. But they appear where data is received (e.g., at
    the left-hand sides of assignments), not where data is created (e.g., at the right-hand
    sides of assignments).
  prefs: []
  type: TYPE_NORMAL
- en: 37.3 Where can we destructure?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Destructuring patterns can be used at “data sink locations” such as:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Variable declarations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assignments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Parameter definitions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that variable declarations include `const` and `let` declarations in `for-of`
    loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next two sections, we’ll look deeper into the two kinds of destructuring:
    object-destructuring and Array-destructuring.'
  prefs: []
  type: TYPE_NORMAL
- en: 37.4 Object-destructuring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Object-destructuring* lets you batch-extract values of properties via patterns
    that look like object literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can think of the pattern as a transparent sheet that you place over the
    data: the pattern key `''street''` has a match in the data. Therefore, the data
    value `''Evergreen Terrace''` is assigned to the pattern variable `s`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also object-destructure primitive values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can object-destructure Arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Why does that work? [Array indices are also properties](ch_arrays.html#array-indices).
  prefs: []
  type: TYPE_NORMAL
- en: 37.4.1 Property value shorthands
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Object literals support property value shorthands and so do object patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/90f73f1851c5b1baf43cb746913c09e6.png)  **Exercise: Object-destructuring**'
  prefs: []
  type: TYPE_NORMAL
- en: '`exercises/destructuring/object_destructuring_exrc.mjs`'
  prefs: []
  type: TYPE_NORMAL
- en: 37.4.2 Rest properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In object literals, you can have spread properties. In object patterns, you
    can have rest properties (which must come last):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A rest property variable, such as `remaining` (line A), is assigned an object
    with all data properties whose keys are not mentioned in the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '`remaining` can also be viewed as the result of non-destructively removing
    property `a` from `obj`.'
  prefs: []
  type: TYPE_NORMAL
- en: '37.4.3 Syntax pitfall: assigning via object destructuring'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we object-destructure in an assignment, we are facing a pitfall caused by
    [syntactic ambiguity](ch_syntax.html#ambiguous-syntax) – you can’t start a statement
    with a curly brace because then JavaScript thinks you are starting a block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **Why `eval()`?**'
  prefs: []
  type: TYPE_NORMAL
- en: '[`eval()`](ch_dynamic-code-evaluation.html#eval) delays parsing (and therefore
    the `SyntaxError`) until the callback of `assert.throws()` is executed. If we
    didn’t use it, we’d already get an error when this code is parsed and `assert.throws()`
    wouldn’t even be executed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The workaround is to put the whole assignment in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 37.5 Array-destructuring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Array-destructuring* lets you batch-extract values of Array elements via patterns
    that look like Array literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can skip elements by mentioning holes inside Array patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first element of the Array pattern in line A is a hole, which is why the
    Array element at index 0 is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 37.5.1 Array-destructuring works with any iterable
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Array-destructuring can be applied to any value that is iterable, not just
    to Arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 37.5.2 Rest elements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In Array literals, you can have spread elements. In Array patterns, you can
    have rest elements (which must come last):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A rest element variable, such as `remaining` (line A), is assigned an Array
    with all elements of the destructured value that were not mentioned yet.
  prefs: []
  type: TYPE_NORMAL
- en: 37.6 Examples of destructuring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '37.6.1 Array-destructuring: swapping variable values'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use Array-destructuring to swap the values of two variables without
    needing a temporary variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '37.6.2 Array-destructuring: operations that return Arrays'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Array-destructuring is useful when operations return Arrays, as does, for example,
    the regular expression method `.exec()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '37.6.3 Object-destructuring: multiple return values'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Destructuring is very useful if a function returns multiple values – either
    packaged as an Array or packaged as an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a function `findElement()` that finds elements in an Array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Its second parameter is a function that receives the value and index of an element
    and returns a boolean indicating if this is the element the caller is looking
    for.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now faced with a dilemma: Should `findElement()` return the value of
    the element it found or the index? One solution would be to create two separate
    functions, but that would result in duplicated code because both functions would
    be very similar.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following implementation avoids duplication by returning an object that
    contains both index and value of the element that is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Destructuring helps us with processing the result of `findElement()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are working with property keys, the order in which we mention `value`
    and `index` doesn’t matter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The kicker is that destructuring also serves us well if we are only interested
    in one of the two results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: All of these conveniences combined make this way of handling multiple return
    values quite versatile.
  prefs: []
  type: TYPE_NORMAL
- en: 37.7 What happens if a pattern part does not match anything?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What happens if there is no match for part of a pattern? The same thing that
    happens if you use non-batch operators: you get `undefined`.'
  prefs: []
  type: TYPE_NORMAL
- en: 37.7.1 Object-destructuring and missing properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a property in an object pattern has no match on the right-hand side, you
    get `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 37.7.2 Array-destructuring and missing elements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If an element in an Array pattern has no match on the right-hand side, you
    get `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 37.8 What values can’t be destructured?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 37.8.1 You can’t object-destructure `undefined` and `null`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Object-destructuring only fails if the value to be destructured is either `undefined`
    or `null`. That is, it fails whenever accessing a property via the dot operator
    would fail too.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 37.8.2 You can’t Array-destructure non-iterable values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Array-destructuring demands that the destructured value be iterable. Therefore,
    you can’t Array-destructure `undefined` and `null`. But you can’t Array-destructure
    non-iterable objects either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz: basic**'
  prefs: []
  type: TYPE_NORMAL
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  prefs: []
  type: TYPE_NORMAL
- en: 37.9 (Advanced)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of the remaining sections are advanced.
  prefs: []
  type: TYPE_NORMAL
- en: 37.10 Default values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Normally, if a pattern has no match, the corresponding variable is set to `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want a different value to be used, you need to specify a *default value*
    (via `=`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In line A, we specify the default value for `p` to be `123`. That default is
    used because the data that we are destructuring has no property named `prop`.
  prefs: []
  type: TYPE_NORMAL
- en: 37.10.1 Default values in Array-destructuring
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here, we have two default values that are assigned to the variables `x` and
    `y` because the corresponding elements don’t exist in the Array that is destructured.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The default value for the first element of the Array pattern is `1`; the default
    value for the second element is `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 37.10.2 Default values in object-destructuring
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can also specify default values for object-destructuring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Neither property key `first` nor property key `last` exist in the object that
    is destructured. Therefore, the default values are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'With property value shorthands, this code becomes simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 37.11 Parameter definitions are similar to destructuring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Considering what we have learned in this chapter, parameter definitions have
    much in common with an Array pattern (rest elements, default values, etc.). In
    fact, the following two function declarations are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 37.12 Nested destructuring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Until now, we have only used variables as *assignment targets* (data sinks)
    inside destructuring patterns. But you can also use patterns as assignment targets,
    which enables you to nest patterns to arbitrary depths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Inside the Array pattern in line A, there is a nested object pattern at index
    1.
  prefs: []
  type: TYPE_NORMAL
- en: Nested patterns can become difficult to understand, so they are best used in
    moderation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz: advanced**'
  prefs: []
  type: TYPE_NORMAL
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  prefs: []
  type: TYPE_NORMAL
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/25)'
  prefs: []
  type: TYPE_NORMAL
