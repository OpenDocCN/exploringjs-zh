["```ts\nconst data: object = ['a', 'b', 'c']; // (A)\n\n// @ts-expect-error: Property 'length' does not exist on type 'object'.\ndata.length; // (B)\n\nassert.equal(\n (data as Array<string>).length, 3 // (C)\n);\n\n```", "```ts\n<Array<string>>data\n\n```", "```ts\ntype Dict = {[k:string]: unknown};\n\nfunction getPropertyValue(dict: unknown, key: string): unknown {\n if (typeof dict === 'object' && dict !== null && key in dict) {\n assertType<object>(dict);\n\n // @ts-expect-error: Element implicitly has an 'any' type because\n // expression of type 'string' can't be used to index type '{}'. No\n // index signature with a parameter of type 'string' was found on\n // type '{}'.\n dict[key];\n\n return (dict as Dict)[key]; // (A)\n } else {\n throw new Error();\n }\n}\n\n```", "```ts\ntype PrependDollarSign<Obj> = {\n [Key in (keyof Obj & string) as `$${Key}`]: Obj[Key]\n};\nfunction prependDollarSign<\n Obj extends object\n>(obj: Obj): PrependDollarSign<Obj> { // (A)\n // @ts-expect-error: Type '{ [k: string]: any; }' is not assignable to\n // type 'PrependDollarSign<Obj>'.\n return Object.fromEntries( // (B)\n Object.entries(obj)\n .map(\n ([key, value]) => ['$'+key, value]\n )\n );\n}\n\n```", "```ts\nfunction prependDollarSign<\n Obj extends object\n>(obj: Obj): PrependDollarSign<Obj> {\n return Object.fromEntries(\n Object.entries(obj)\n .map(\n ([key, value]) => ['$'+key, value]\n )\n ) as any; // (A)\n}\n\nconst dollarObject = prependDollarSign({\n prop: 123,\n});\nassert.deepEqual(\n dollarObject,\n {\n $prop: 123,\n }\n);\nassertType<\n {\n $prop: number,\n }\n>(dollarObject);\n\n```", "```ts\nconst theName = 'Jane' as (null | string);\n\n// @ts-expect-error: 'theName' is possibly 'null'.\ntheName.length;\n\nassert.equal(\n theName!.length, 4); // OK\n\n```", "```ts\nfunction getLength(strMap: Map<string, string>, key: string): number {\n if (strMap.has(key)) {\n // We are sure x is not undefined:\n const value = strMap.get(key)!; // (A)\n return value.length;\n }\n return -1;\n}\n\n```", "```ts\nfunction getLength(strMap: Map<string, string>, key: string): number {\n const value = strMap.get(key);\n assertType<string | undefined>(value);\n\n if (value === undefined) { // (A)\n return -1;\n }\n assertType<string>(value);\n\n return value.length;\n}\n\n```", "```ts\nclass Point1 {\n // @ts-expect-error: Property 'x' has no initializer and is not definitely\n // assigned in the constructor.\n x: number;\n\n // @ts-expect-error: Property 'y' has no initializer and is not definitely\n // assigned in the constructor.\n y: number;\n\n constructor() {\n this.initProperties();\n }\n initProperties() {\n this.x = 0;\n this.y = 0;\n }\n}\n\n```", "```ts\nclass Point2 {\n x!: number; // (A)\n y!: number; // (B)\n constructor() {\n this.initProperties();\n }\n initProperties() {\n this.x = 0;\n this.y = 0;\n }\n}\n\n```", "```ts\nconst obj = { prop: 123 };\ntype _1 = Assert<Equal<\n typeof obj, { prop: number }\n>>;\nconst constObj = { prop: 123 } as const;\ntype _2 = Assert<Equal<\n typeof constObj, { readonly prop: 123 }\n>>;\n\nconst arr = ['a', 'b'];\ntype _3 = Assert<Equal<\n typeof arr, string[]\n>>;\nconst constTuple = ['a', 'b'] as const;\ntype _4 = Assert<Equal<\n typeof constTuple, readonly [\"a\", \"b\"]\n>>;\n\n```", "```ts\nconst TextStyle  = {\n Bold: {\n html: 'b',\n latex: 'textbf',\n },\n // @ts-expect-error: Property 'latex' is missing in type\n // '{ html: string; }' but required in type 'TTextStyle'.\n Italics: { // (A)\n html: 'i',\n },\n} satisfies Record<string, TTextStyle>; // (B)\ntype TTextStyle = {\n html: string,\n latex: string,\n};\n\ntype TextStyleKeys = keyof typeof TextStyle; // (C)\ntype _ = Assert<Equal<\n TextStyleKeys, \"Bold\" | \"Italics\"\n>>;\n\n```"]