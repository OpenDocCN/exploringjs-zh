- en: 23 Using template literals and tagged templates ES6
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 23 使用模板字面量和标记模板 ES6
- en: 原文：[https://exploringjs.com/js/book/ch_template-literals.html](https://exploringjs.com/js/book/ch_template-literals.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/js/book/ch_template-literals.html](https://exploringjs.com/js/book/ch_template-literals.html)
- en: '[23.1 Disambiguation: “template”](#disambiguation-template)'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.1 消除歧义：“模板”](#disambiguation-template)'
- en: '[23.2 Template literals](#template-literals)'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.2 模板字面量](#template-literals)'
- en: '[23.3 Tagged templates](#tagged-templates)'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.3 标记模板](#tagged-templates)'
- en: '[23.3.1 Cooked vs. raw template strings (advanced)](#template-strings-cooked-vs-raw)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.3.1 烹饪与原始模板字符串（高级）](#template-strings-cooked-vs-raw)'
- en: '[23.4 Examples of tagged templates (as provided via libraries)](#examples-of-tagged-templates-as-provided-via-libraries)'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.4 标记模板的示例（通过库提供）](#examples-of-tagged-templates-as-provided-via-libraries)'
- en: '[23.4.1 Tag function library: lit-html](#tag-function-library-lithtml)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.4.1 标记函数库：lit-html](#tag-function-library-lithtml)'
- en: '[23.4.2 Tag function library: regex](#regex-library)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.4.2 标记函数库：regex](#regex-library)'
- en: '[23.4.3 Tag function library: graphql-tag](#tag-function-library-graphqltag)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.4.3 标记函数库：graphql-tag](#tag-function-library-graphqltag)'
- en: '[23.5 Raw string literals via the template tag `String.raw`](#raw-string-literals)'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.5 通过模板标签`String.raw`的原始字符串字面量](#raw-string-literals)'
- en: '[23.6 Multiline template literals and indentation](#multiline-template-literals)'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.6 多行模板字面量和缩进](#multiline-template-literals)'
- en: '[23.6.1 Fix: indenting the text and removing the indentation via a template
    tag](#fix-indenting-the-text-and-removing-the-indentation-via-a-template-tag)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.6.1 修复：缩进文本并通过模板标签移除缩进](#fix-indenting-the-text-and-removing-the-indentation-via-a-template-tag)'
- en: '[23.6.2 Fix: not indenting the text and removing leading and trailing whitespace
    via `.trim()`](#fix-not-indenting-the-text-and-removing-leading-and-trailing-whitespace-via-trim)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.6.2 修复：不缩进文本并通过`.trim()`移除前导和尾随空白](#fix-not-indenting-the-text-and-removing-leading-and-trailing-whitespace-via-trim)'
- en: '[23.7 Simple templating via template literals (advanced)](#simple-templating-via-template-literals-advanced)'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.7 通过模板字面量进行简单模板化（高级）](#simple-templating-via-template-literals-advanced)'
- en: '[23.7.1 A more complex example](#a-more-complex-example)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.7.1 一个更复杂的例子](#a-more-complex-example)'
- en: '[23.7.2 Simple HTML-escaping](#simple-html-escaping)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.7.2 简单的HTML转义](#simple-html-escaping)'
- en: Before we dig into the two features *template literal* and *tagged template*,
    let’s first examine the multiple meanings of the term *template*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨“模板字面量”和“标记模板”这两个特性之前，让我们首先考察一下“模板”一词的多种含义。
- en: '[23.1 Disambiguation: “template”](#disambiguation-template)'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[23.1 消除歧义：“模板”](#disambiguation-template)'
- en: 'The following three things are significantly different despite all having *template*
    in their names and despite all of them looking similar:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这三个名称中都有“模板”，并且它们看起来很相似，但以下三者在本质上却有着显著的不同：
- en: 'A *text template* is a function from data to text. It is frequently used in
    web development and often defined via text files. For example, the following text
    defines a template for the library [Handlebars](https://handlebarsjs.com):'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本模板**是从数据到文本的函数。它在Web开发中经常被使用，通常通过文本文件定义。例如，以下文本定义了一个用于库[Handlebars](https://handlebarsjs.com)的模板：'
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This template has two blanks to be filled in: `title` and `body`. It is used
    like this:'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此模板有两个空白需要填写：`title`和`body`。它被这样使用：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A *template literal* is similar to a string literal, but has additional features
    – for example, interpolation. It is delimited by backticks:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板字面量**类似于字符串字面量，但具有额外的功能——例如，插值。它由反引号分隔：'
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Syntactically, a *tagged template* is a template literal that follows a function
    (or rather, an expression that evaluates to a function). That leads to the function
    being called. Its arguments are derived from the contents of the template literal.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从语法上讲，一个**标记模板**是一个跟随函数（或者更确切地说，是一个评估为函数的表达式）的模板字面量。这会导致函数被调用。它的参数来自模板字面量的内容。
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that `getArgs()` receives both the text of the literal and the data interpolated
    via `${}`.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`getArgs()`接收来自字面量的文本以及通过`${}`插值的数据。
- en: '[23.2 Template literals](#template-literals)'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[23.2 模板字面量](#template-literals)'
- en: A template literal has two new features compared to a normal string literal.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通字符串字面量相比，模板字面量有两个新特性。
- en: 'First, it supports *string interpolation*: if we put a dynamically computed
    value inside a `${}`, it is converted to a string and inserted into the string
    returned by the literal.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它支持**字符串插值**：如果我们把一个动态计算出的值放在`${}`中，它会被转换为字符串并插入到字面量返回的字符串中。
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Second, template literals can span multiple lines:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，模板字面量可以跨越多行：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Template literals always produce strings.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字面量总是产生字符串。
- en: '[23.3 Tagged templates](#tagged-templates)'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[23.3 标记模板](#tagged-templates)'
- en: The expression in line A is a *tagged template*. It is equivalent to invoking
    `tagFunc()` with the arguments shown below line A.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 行 A 中的表达式是一个*标记模板*。它相当于调用 `tagFunc()` 并使用行 A 以下显示的参数。
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The function `tagFunc` before the first backtick is called a *tag function*.
    Its arguments are:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个反引号之前调用的函数 `tagFunc` 被称为*标记函数*。它的参数是：
- en: '*Template strings* (first argument): an Array with the text fragments surrounding
    the interpolations `${}`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模板字符串*（第一个参数）：一个包含围绕插值 `${}` 的文本片段的数组。'
- en: 'In the example: `[''Setting '', '' is '', ''!'']`'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在示例中：`['Setting ', ' is ', '!']`
- en: '*Substitutions* (remaining arguments): the interpolated values.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*替换*（剩余参数）：插值值。'
- en: 'In the example: `''dark mode''` and `true`'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在示例中：`'dark mode'` 和 `true`
- en: The static (fixed) parts of the literal (the template strings) are kept separate
    from the dynamic parts (the substitutions).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 文字（字面量）的静态（固定）部分（模板字符串）与动态部分（替换）是分开的。
- en: A tag function can return arbitrary values.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 标记函数可以返回任意值。
- en: '[23.3.1 Cooked vs. raw template strings (advanced)](#template-strings-cooked-vs-raw)'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[23.3.1 烹饪与原始模板字符串（高级）](#template-strings-cooked-vs-raw)'
- en: 'So far, we have only seen the *cooked interpretation* of template strings.
    But tag functions actually get two interpretations:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了模板字符串的*烹饪解释*。但实际上，标记函数实际上得到两种解释：
- en: A *cooked interpretation* where backslashes have special meaning. For example,
    `\t` produces a tab character. This interpretation of the template strings is
    stored as an Array in the first argument.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*烹饪解释*，其中反斜杠具有特殊意义。例如，`\t` 产生一个制表符字符。这种解释的模板字符串存储在第一个参数（一个数组）中。
- en: A *raw interpretation* where backslashes do not have special meaning. For example,
    `\t` produces two characters – a backslash and a `t`. This interpretation of the
    template strings is stored in property `.raw` of the first argument (an Array).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*原始解释*，其中反斜杠没有特殊意义。例如，`\t` 产生两个字符——一个反斜杠和一个 `t`。这种解释的模板字符串存储在第一个参数（一个数组）的
    `.raw` 属性中。
- en: The raw interpretation enables raw string literals via `String.raw` [(described
    later)](#raw-string-literals) and similar applications.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 原始解释通过 `String.raw` [(稍后描述)](#raw-string-literals) 和类似的应用程序启用原始字符串字面量。
- en: 'The following tag function `cookedRaw` uses both interpretations:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标记函数 `cookedRaw` 使用了两种解释：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can also use Unicode code point escapes (`\u{1F642}`), Unicode code unit
    escapes (`\u03A9`), and ASCII escapes (`\x52`) in tagged templates:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在标记模板中使用 Unicode 代码点转义（`\u{1F642}`）、Unicode 代码单元转义（`\u03A9`）和 ASCII 转义（`\x52`）：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If the syntax of one of these escapes isn’t correct, the corresponding cooked
    template string is `undefined`, while the raw version is still verbatim:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中一个转义的语法不正确，相应的烹饪模板字符串是 `undefined`，而原始版本仍然是字面量：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Incorrect escapes produce syntax errors in template literals and string literals.
    Before ES2018, they even produced errors in tagged templates. Why was that changed?
    We can now use tagged templates for text that was previously illegal – for example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 不正确的转义会在模板字面量和字符串字面量中产生语法错误。在 ES2018 之前，它们甚至在标记模板中产生错误。为什么会有这样的改变？现在我们可以使用标记模板来处理之前非法的文本——例如：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[23.4 Examples of tagged templates (as provided via libraries)](#examples-of-tagged-templates-as-provided-via-libraries)'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[23.4 标记模板的示例（通过库提供）](#examples-of-tagged-templates-as-provided-via-libraries)'
- en: Tagged templates are great for supporting small embedded languages (so-called
    *domain-specific languages*). We’ll continue with a few examples.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 标记模板非常适合支持小型嵌入式语言（所谓的*领域特定语言*）。我们将继续使用一些示例。
- en: '[23.4.1 Tag function library: lit-html](#tag-function-library-lithtml)'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[23.4.1 标记函数库：lit-html](#tag-function-library-lithtml)'
- en: '[Lit](https://lit.dev) is a library for building web components that uses tagged
    templates for HTML templating:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[Lit](https://lit.dev) 是一个用于构建网页组件的库，它使用标记模板进行 HTML 模板化：'
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`repeat()` is a custom function for looping. Its second parameter produces
    unique keys for the values returned by the third parameter. Note the nested tagged
    template used by that parameter.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat()` 是一个用于循环的自定义函数。它的第二个参数为第三个参数返回的值生成唯一的键。注意该参数使用的嵌套标记模板。'
- en: '[23.4.2 Tag function library: regex](#regex-library)'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[23.4.2 标记函数库：正则表达式](#regex-library)'
- en: '[The library “regex”](https://github.com/slevithan/regex) by Steven Levithan
    provides template tags that help with creating regular expressions and enable
    advanced features. The following example demonstrates how it works:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Steven Levithan 编写的“regex”库（https://github.com/slevithan/regex）提供了模板标签，有助于创建正则表达式并启用高级功能。以下示例演示了它是如何工作的：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following flags are switched on by default:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 默认启用的以下标志：
- en: Flag `/v`
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记 `/v`
- en: Flag `/x` (emulated) enables insignificant whitespace and line comments via
    `#`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记 `/x`（模拟）通过 `#` 启用不重要的空白和行注释。
- en: Flag `/n` (emulated) enables *named capture only mode*, which prevents the grouping
    metacharacters `(···)` from capturing.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记 `/n`（模拟）启用*仅命名捕获模式*，这阻止了分组元字符 `(···)` 的捕获。
- en: '[23.4.3 Tag function library: graphql-tag](#tag-function-library-graphqltag)'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[23.4.3 标签函数库：graphql-tag](#tag-function-library-graphqltag)'
- en: '[The library graphql-tag](https://github.com/apollographql/graphql-tag) lets
    us create GraphQL queries via tagged templates:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[graphql-tag 库](https://github.com/apollographql/graphql-tag)让我们可以通过标签模板创建
    GraphQL 查询：'
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Additionally, there are plugins for pre-compiling such queries in Babel, TypeScript,
    etc.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有插件可以在 Babel、TypeScript 等中预编译此类查询。
- en: '[23.5 Raw string literals via the template tag `String.raw`](#raw-string-literals)'
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[23.5 通过模板标签 `String.raw` 的原始字符串字面量](#raw-string-literals)'
- en: 'Raw string literals are implemented via the tag function `String.raw`. They
    are string literals where backslashes don’t do anything special (such as escaping
    characters, etc.):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串字面量通过标签函数 `String.raw` 实现。它们是字符串字面量，其中反斜杠不执行任何特殊操作（例如转义字符等）：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This helps whenever data contains backslashes – for example, strings with regular
    expressions:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于数据包含反斜杠时——例如，包含正则表达式的字符串：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All three regular expressions are equivalent. With a normal string literal,
    we have to write the backslash twice, to escape it for that literal. With a raw
    string literal, we don’t have to do that.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个正则表达式都是等效的。使用普通字符串字面量时，我们必须写两次反斜杠，以转义该字面量。使用原始字符串字面量时，我们不必这样做。
- en: 'Raw string literals are also useful for specifying Windows filename paths:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串字面量也用于指定 Windows 文件名路径：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[23.6 Multiline template literals and indentation](#multiline-template-literals)'
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[23.6 多行模板字面量和缩进](#multiline-template-literals)'
- en: 'If we put multiline text in template literals, two goals are in conflict: On
    one hand, the template literal should be indented to fit inside the source code.
    On the other hand, the lines of its content should start in the leftmost column.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在模板字面量中放置多行文本，两个目标就产生了冲突：一方面，模板字面量应该缩进以适应源代码。另一方面，其内容行应该从最左侧列开始。
- en: 'For example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Due to the indentation, the template literal fits well into the source code.
    Alas, the output is also indented. And we don’t want the return at the beginning
    and the return plus two spaces at the end.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缩进，模板字面量很好地融入了源代码。然而，输出也是缩进的。我们不想在开头有返回，在结尾有返回加两个空格。
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There are two ways to fix this: via a tagged template or by trimming the result
    of the template literal.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以修复这个问题：通过标签模板或通过修剪模板字面量的结果。
- en: '[23.6.1 Fix: indenting the text and removing the indentation via a template
    tag](#fix-indenting-the-text-and-removing-the-indentation-via-a-template-tag)'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[23.6.1 修复：通过模板标签缩进文本并移除缩进](#fix-indenting-the-text-and-removing-the-indentation-via-a-template-tag)'
- en: 'The first fix is to use a custom template tag that removes the unwanted whitespace.
    It uses the first line after the initial line break to determine in which column
    the text starts and shortens the indentation everywhere. It also removes the line
    break at the very beginning and the indentation at the very end. One such template
    tag is [`dedent` by Desmond Brand](https://github.com/dmnd/dedent):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个修复是使用自定义模板标签来删除不需要的空白。它使用初始换行符之后的第一行来确定文本开始的列，并在所有地方缩短缩进。它还删除了非常开始的换行符和非常结束的缩进。这样的模板标签之一是
    [Desmond Brand 的 `dedent`](https://github.com/dmnd/dedent)：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is not indented:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 输出没有缩进：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[23.6.2 Fix: not indenting the text and removing leading and trailing whitespace
    via `.trim()`](#fix-not-indenting-the-text-and-removing-leading-and-trailing-whitespace-via-trim)'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[23.6.2 修复：不缩进文本并通过 `.trim()` 移除前导和尾随空白](#fix-not-indenting-the-text-and-removing-leading-and-trailing-whitespace-via-trim)'
- en: 'The second fix is quicker, but also dirtier:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个修复更快，但也更脏：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The string method `.trim()` removes the superfluous whitespace at the beginning
    and at the end, but the content itself can’t be indented – it must start in the
    leftmost column. The advantage of this solution is that we don’t need a custom
    tag function. The downside is that the unindented text doesn’t fit well into its
    surroundings.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串方法`.trim()`移除了开头和结尾的冗余空白字符，但内容本身不能缩进 - 它必须从最左侧列开始。这种解决方案的优势是我们不需要自定义标签函数。缺点是未缩进的文本与周围环境不太搭配。
- en: 'The output is the same as with `dedent`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与`dedent`相同：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[23.7 Simple templating via template literals (advanced)](#simple-templating-via-template-literals-advanced)'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[23.7 通过模板字面量进行简单模板化（高级）](#simple-templating-via-template-literals-advanced)'
- en: 'While template literals look like text templates, it is not immediately obvious
    how to use them for (text) templating: A text template gets its data from an object,
    while a template literal gets its data from variables. The solution is to use
    a template literal in the body of a function whose parameter receives the templating
    data – for example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然模板字面量看起来像文本模板，但它们用于（文本）模板化的方法并不立即明显：文本模板从对象中获取数据，而模板字面量从变量中获取数据。解决方案是在一个函数体中使用模板字面量，该函数的参数接收模板数据
    - 例如：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[23.7.1 A more complex example](#a-more-complex-example)'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[23.7.1 更复杂的示例](#a-more-complex-example)'
- en: 'As a more complex example, we’d like to take an Array of addresses and produce
    an HTML table. This is the Array:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 作为更复杂的示例，我们希望从一个地址数组中生成一个HTML表格。这是数组：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The function `tmpl()` that produces the HTML table looks as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 生成HTML表格的函数`tmpl()`看起来如下：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This code contains two templating functions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码包含两个模板函数：
- en: The first one (line 1) takes `addrs`, an Array with addresses, and returns a
    string with a table.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个（第1行）接受`addrs`，一个包含地址的数组，并返回一个包含表格的字符串。
- en: The second one (line 4) takes `addr`, an object containing an address, and returns
    a string with a table row. Note the `.trim()` at the end, which removes unnecessary
    whitespace.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个（第4行）接受`addr`，一个包含地址的对象，并返回一个包含表格行的字符串。注意最后的`.trim()`，它移除了不必要的空白字符。
- en: The first templating function produces its result by wrapping a table element
    around an Array that it joins into a string (line 10). That Array is produced
    by mapping the second templating function to each element of `addrs` (line 3).
    It therefore contains strings with table rows.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模板函数通过将表格元素包裹在一个它连接成字符串的数组周围来生成结果（第10行）。这个数组是通过将第二个模板函数映射到`addrs`（第3行）的每个元素上产生的。因此，它包含带有表格行的字符串。
- en: The helper function `escapeHtml()` is used to escape special HTML characters
    (line 6 and line 7). Its implementation is shown in the next subsection.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数`escapeHtml()`用于转义特殊的HTML字符（第6行和第7行）。其实现将在下一小节中展示。
- en: 'Let us call `tmpl()` with the addresses and log the result:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用地址调用`tmpl()`并记录结果：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[23.7.2 Simple HTML-escaping](#simple-html-escaping)'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[23.7.2 简单的HTML转义](#simple-html-escaping)'
- en: 'The following function escapes plain text so that it is displayed verbatim
    in HTML:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数用于转义纯文本，以便在HTML中以纯文本形式显示：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    HTML templating**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![“练习”图标](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：HTML模板化**'
- en: 'Exercise with bonus challenge: `exercises/template-literals/templating_test.mjs`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 练习（带额外挑战）：`exercises/template-literals/templating_test.mjs`
