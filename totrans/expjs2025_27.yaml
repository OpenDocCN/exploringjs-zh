- en: 23 Using template literals and tagged templates ES6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/js/book/ch_template-literals.html](https://exploringjs.com/js/book/ch_template-literals.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[23.1 Disambiguation: “template”](#disambiguation-template)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[23.2 Template literals](#template-literals)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[23.3 Tagged templates](#tagged-templates)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[23.3.1 Cooked vs. raw template strings (advanced)](#template-strings-cooked-vs-raw)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[23.4 Examples of tagged templates (as provided via libraries)](#examples-of-tagged-templates-as-provided-via-libraries)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[23.4.1 Tag function library: lit-html](#tag-function-library-lithtml)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[23.4.2 Tag function library: regex](#regex-library)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[23.4.3 Tag function library: graphql-tag](#tag-function-library-graphqltag)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[23.5 Raw string literals via the template tag `String.raw`](#raw-string-literals)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[23.6 Multiline template literals and indentation](#multiline-template-literals)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[23.6.1 Fix: indenting the text and removing the indentation via a template
    tag](#fix-indenting-the-text-and-removing-the-indentation-via-a-template-tag)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[23.6.2 Fix: not indenting the text and removing leading and trailing whitespace
    via `.trim()`](#fix-not-indenting-the-text-and-removing-leading-and-trailing-whitespace-via-trim)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[23.7 Simple templating via template literals (advanced)](#simple-templating-via-template-literals-advanced)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[23.7.1 A more complex example](#a-more-complex-example)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[23.7.2 Simple HTML-escaping](#simple-html-escaping)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we dig into the two features *template literal* and *tagged template*,
    let’s first examine the multiple meanings of the term *template*.
  prefs: []
  type: TYPE_NORMAL
- en: '[23.1 Disambiguation: “template”](#disambiguation-template)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following three things are significantly different despite all having *template*
    in their names and despite all of them looking similar:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *text template* is a function from data to text. It is frequently used in
    web development and often defined via text files. For example, the following text
    defines a template for the library [Handlebars](https://handlebarsjs.com):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This template has two blanks to be filled in: `title` and `body`. It is used
    like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A *template literal* is similar to a string literal, but has additional features
    – for example, interpolation. It is delimited by backticks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Syntactically, a *tagged template* is a template literal that follows a function
    (or rather, an expression that evaluates to a function). That leads to the function
    being called. Its arguments are derived from the contents of the template literal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that `getArgs()` receives both the text of the literal and the data interpolated
    via `${}`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[23.2 Template literals](#template-literals)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A template literal has two new features compared to a normal string literal.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it supports *string interpolation*: if we put a dynamically computed
    value inside a `${}`, it is converted to a string and inserted into the string
    returned by the literal.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, template literals can span multiple lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Template literals always produce strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[23.3 Tagged templates](#tagged-templates)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The expression in line A is a *tagged template*. It is equivalent to invoking
    `tagFunc()` with the arguments shown below line A.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6] `assert.deepEqual(`  ``tagFunc`Setting ${setting} is ${value}!`, //
    (A)``  `{`  `templateStrings: [''Setting '', '' is '', ''!''],`  `substitutions:
    [''dark mode'', true],`  `}`  `// tagFunc([''Setting '', '' is '', ''!''], ''dark
    mode'', true)` `);` [PRE7]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8][PRE9]``js[PRE10] function cookedRaw(templateStrings, ...substitutions)
    {  return {  cooked: Array.from(templateStrings), // copy only Array elements  raw:
    templateStrings.raw,  substitutions,  }; } assert.deepEqual(  cookedRaw`\tab${''subst''}\newline\\`,  {  cooked:
    [''\tab'', ''\newline\\''],  raw:    [''\\tab'', ''\\newline\\\\''],  substitutions:
    [''subst''],  });  [PRE11] assert.deepEqual(  cookedRaw`\u{54}\u0065\x78t`,  {  cooked:
    [''Text''],  raw:    [''\\u{54}\\u0065\\x78t''],  substitutions: [],  });  [PRE12]
    assert.deepEqual(  cookedRaw`\uu\xx ${1} after`,  {  cooked: [undefined, '' after''],  raw:    [''\\uu\\xx
    '', '' after''],  substitutions: [1],  });  [PRE13] windowsPath`C:\uuu\xxx\111`
    latex`\unicode`  [PRE14] @customElement(''my-element'') class MyElement extends
    LitElement {  `// ···`  [PRE15]  [PRE16][PRE17][PRE18] import {regex, pattern}
    from ''regex'';  ``const RE_YEAR = pattern`(?<year>[0-9]{4})`;`` ``const RE_MONTH
    = pattern`(?<month>[0-9]{2})`;`` ``const RE_DAY = pattern`(?<day>[0-9]{2})`;``
    `` const RE_DATE = regex(''g'')` ``  `${RE_YEAR} # 4 digits`  `-`  `${RE_MONTH}
    # 2 digits`  `-`  `${RE_DAY} # 2 digits` `` `; ``  `` `const match = RE_DATE.exec(''2017-01-27'');`
    `assert.equal(match.groups.year, ''2017'');` ``  [PRE19][PRE20]`` The following
    flags are switched on by default:    *   Flag `/v` *   Flag `/x` (emulated) enables
    insignificant whitespace and line comments via `#`. *   Flag `/n` (emulated) enables
    *named capture only mode*, which prevents the grouping metacharacters `(···)`
    from capturing.    #### [23.4.3 Tag function library: graphql-tag](#tag-function-library-graphqltag)    [The
    library graphql-tag](https://github.com/apollographql/graphql-tag) lets us create
    GraphQL queries via tagged templates:    [PRE21]   [PRE22] assert.equal(  String.raw`\back`,  ''\\back''
    );  [PRE23] const regex1 = /^\./; const regex2 = new RegExp(''^\\.''); const regex3
    = new RegExp(String.raw`^\.`);  [PRE24] const WIN_PATH = String.raw`C:\Users\Robin\Documents`;
    assert.equal(  WIN_PATH, ''C:\\Users\\Robin\\Documents'' );  [PRE25] function
    div(text) {  return `  <div>  ${text}  </div>  `; } console.log(''Output:'');
    console.log(  div(''Hello!'')  // Replace spaces with mid-dots:  .replace(/ /g,
    ''·'')  // Replace \n with #\n:  .replace(/\n/g, ''#\n'') );  [PRE26] Output:
    # ····<div># ······Hello!# ····</div># ··  [PRE27] import dedent from ''dedent'';
    function divDedented(text) {  return dedent`  <div>  ${text}  </div>  `; } console.log(''Output:'');
    console.log(divDedented(''Hello!''));  [PRE28] Output: <div>  Hello! </div>  [PRE29]
    function divDedented(text) {  return ` <div>  ${text} </div>  `.trim(); } console.log(''Output:'');
    console.log(divDedented(''Hello!''));  [PRE30] Output: <div>  Hello! </div>  [PRE31]
    const tmpl = (data) => `Hello ${data.name}!`; assert.equal(tmpl({name: ''Jane''}),
    ''Hello Jane!'');  [PRE32] const addresses = [  { first: ''<Jane>'', last: ''Bond''
    },  { first: ''Lars'', last: ''<Croft>'' }, ];  [PRE33] const tmpl = (addrs) =>
    ` <table>  ${addrs.map(  (addr) => `  <tr>  <td>${escapeHtml(addr.first)}</td>  <td>${escapeHtml(addr.last)}</td>  </tr>  `.trim()  ).join('''')}
    </table> `.trim();  [PRE34] console.log(tmpl(addresses));  [PRE35] <table>  <tr>  <td>&lt;Jane&gt;</td>  <td>Bond</td>  </tr><tr>  <td>Lars</td>  <td>&lt;Croft&gt;</td>  </tr>
    </table>  [PRE36] function escapeHtml(str) {  return str  .replace(/&/g, ''&amp;'')
    // first!  .replace(/>/g, ''&gt;'')  .replace(/</g, ''&lt;'')  .replace(/"/g,
    ''&quot;'')  .replace(/''/g, ''&#39;'')  .replace(/`/g, ''&#96;'')  ; } assert.equal(  escapeHtml(''Rock
    & Roll''), ''Rock &amp; Roll''); assert.equal(  escapeHtml(''<blank>''), ''&lt;blank&gt;'');  [PRE37]`
    [PRE38][PRE39][PRE40][PRE41][PRE42] [PRE43]'
  prefs: []
  type: TYPE_NORMAL
