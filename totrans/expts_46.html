<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>38 Template literal types (`${U}`): creating and transforming string literal types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>38 Template literal types (`${U}`): creating and transforming string literal types</h1>
<blockquote>原文：<a href="https://exploringjs.com/ts/book/ch_template-literal-types.html">https://exploringjs.com/ts/book/ch_template-literal-types.html</a></blockquote>

    
        <div id="adbox">
      <div id="adbox-explain">(Ad, please don’t block.)</div>
              
          </div>
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#the-structure-of-this-chapter">38.1 The structure of this chapter</a>
    </li>
    <li>
      <a href="#syntax-and-basic-ways-of-using-template-literal-types">38.2 Syntax and basic ways of using template literal types</a>
      <ol>
        <li>
          <a href="#the-syntax">38.2.1 The syntax</a>
        </li>
        <li>
          <a href="#concatenation-is-distributive">38.2.2 Concatenation is distributive</a>
        </li>
        <li>
          <a href="#extracting-substrings-via-infer">38.2.3 Extracting substrings via <code>infer</code></a>
        </li>
        <li>
          <a href="#parsing-substrings-via-infer-plus-extends">38.2.4 Parsing substrings via <code>infer</code> plus <code>extends</code></a>
        </li>
        <li>
          <a href="#interpolating-primitive-types-into-template-literals">38.2.5 Interpolating primitive types into template literals</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#utility-types-for-strings">38.3 Utility types for string manipulation</a>
      <ol>
        <li>
          <a href="#example-isuppercase">38.3.1 Example: <code>isUppercase</code></a>
        </li>
        <li>
          <a href="#example-tostring">38.3.2 Example: <code>ToString</code></a>
        </li>
        <li>
          <a href="#example-trimming-string-literal-types">38.3.3 Example: trimming string literal types</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#working-with-tuples">38.4 Working with tuples</a>
      <ol>
        <li>
          <a href="#joining-a-tuple-of-strings">38.4.1 Joining a tuple of strings</a>
        </li>
        <li>
          <a href="#Split">38.4.2 Splitting a string</a>
        </li>
        <li>
          <a href="#example-defining-a-string-literal-union-type-via-a-string-literal-type">38.4.3 Example: defining a string literal union type via a string literal type</a>
        </li>
        <li>
          <a href="#splitting-a-string-into-code-units">38.4.4 Splitting a string into code units</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#working-with-objects">38.5 Working with objects</a>
      <ol>
        <li>
          <a href="#example-adding-prefixes-to-property-names">38.5.1 Example: adding prefixes to property names</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#practical-examples">38.6 Practical examples</a>
      <ol>
        <li>
          <a href="#example-styling-output-to-a-terminal">38.6.1 Example: styling output to a terminal</a>
        </li>
        <li>
          <a href="#example-property-paths">38.6.2 Example: property paths</a>
        </li>
        <li>
          <a href="#example-changing-property-name-prefixes">38.6.3 Example: changing property name prefixes</a>
        </li>
        <li>
          <a href="#example-converting-camel-case-to-hyphen-case">38.6.4 Example: converting camel case to hyphen case</a>
        </li>
        <li>
          <a href="#example-from-hyphen-case-to-camel-case">38.6.5 Example: converting hyphen case to camel case</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#neat-things-people-are-doing-with-template-literal-types">38.7 Neat things people are doing with template literal types</a>
      <ol>
        <li>
          <a href="#node-js-type-for-uuids">38.7.1 Node.js: type for UUIDs</a>
        </li>
        <li>
          <a href="#parsing-cli-arguments-stefan-baumgartner">38.7.2 Parsing CLI arguments (Stefan Baumgartner)</a>
        </li>
        <li>
          <a href="#smart-result-type-of-document-queryselector-mike-ryan">38.7.3 Smart result type of <code>document.querySelector()</code> (Mike Ryan)</a>
        </li>
        <li>
          <a href="#typing-routes-in-angular-mike-ryan">38.7.4 Typing routes in Angular (Mike Ryan)</a>
        </li>
        <li>
          <a href="#express-route-extractor-dan-vanderkam">38.7.5 Express route extractor (Dan Vanderkam)</a>
        </li>
        <li>
          <a href="#tailwind-color-variations-tomek-su-C5-82kowski">38.7.6 Tailwind color variations (Tomek Sułkowski)</a>
        </li>
        <li>
          <a href="#arktype-defining-types">38.7.7 Arktype: defining types</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#conclusion-and-caveats">38.8 Conclusion and caveats</a>
    </li>
    <li>
      <a href="#further-reading-10">38.9 Further reading</a>
    </li>
    <li>
      <a href="#sources-of-this-chapter-7">38.10 Sources of this chapter</a>
    </li>
  </ol>
</nav>
<p>In this chapter, we take a closer look at template literal types in TypeScript: While their syntax is similar to JavaScript’s template literals, they operate at the type level. Their use cases include:</p>
<ul>
  <li>
    Static syntax checking for string literals
  </li>
  <li>
    Transforming the casing of property names (e.g. from hyphen case to camel case)
  </li>
  <li>
    Concisely specifying large string literal union types
  </li>
</ul>
<h3 id="the-structure-of-this-chapter"><a class="heading-id-link" href="#the-structure-of-this-chapter">38.1 The structure of this chapter</a></h3>
<p>First, we’ll learn how template literal types work via small toy examples. We’ll write type-level code that looks similar to JavaScript code. These are the topics we’ll cover: </p>
<ul>
  <li>
    Syntax and basic ways of using template literal types
  </li>
  <li>
    Utility types for string manipulation
  </li>
  <li>
    Working with tuples
  </li>
  <li>
    Working with objects
  </li>
</ul>
<p>After that, we’ll look at practical examples and neat things that people have done with template literal types.</p>
<h3 id="syntax-and-basic-ways-of-using-template-literal-types"><a class="heading-id-link" href="#syntax-and-basic-ways-of-using-template-literal-types">38.2 Syntax and basic ways of using template literal types</a></h3>
<h4 id="the-syntax"><a class="heading-id-link" href="#the-syntax">38.2.1 The syntax</a></h4>
<p>The syntax of template literal types is inspired by JavaScript’s template literals. They also let us concatenate values, optionally interspersed with static string fragments:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Song</span>&lt;<span class="hljs-title class_">Num</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>, <span class="hljs-title class_">Bev</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = <span class="hljs-comment">// (A)</span></code>
<code>  <span class="hljs-string">`<span class="hljs-subst">${Num}</span> bottles of <span class="hljs-subst">${Bev}</span>`</span></code>
<code>;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Song</span>&lt;<span class="hljs-number">99</span>, <span class="hljs-string">'juice'</span>&gt;, <span class="hljs-comment">// (B)</span></code>
<code>  <span class="hljs-string">'99 bottles of juice'</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>Explanations:</p>
<ul>
  <li>
    <p>In line (A), we define the generic type <code>Song</code>. It is similar to a function in JavaScript but operates at the type level. The <code>extends</code> keyword is used to specify the types that <code>Num</code> and <code>Bev</code> must be assignable to.</p>
  </li>
  <li>
    <p>In line (B), we apply <code>Song</code> to two arguments: a number literal type and a string literal type.</p>
  </li>
</ul>
<h4 id="concatenation-is-distributive"><a class="heading-id-link" href="#concatenation-is-distributive">38.2.2 Concatenation is distributive</a></h4>
<p>If we insert a string literal union type into a template literal type, the latter is applied to each member of the former:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Modules</span> = <span class="hljs-string">'fs'</span> | <span class="hljs-string">'os'</span> | <span class="hljs-string">'path'</span>;</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Prefixed</span> = <span class="hljs-string">`node:<span class="hljs-subst">${Modules}</span>`</span>;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Prefixed</span>, <span class="hljs-string">'node:fs'</span> | <span class="hljs-string">'node:os'</span> | <span class="hljs-string">'node:path'</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>If we insert more than one string literal union type, then we get the cartesian product (all possible combinations are used):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Words</span> = <span class="hljs-string">`<span class="hljs-subst">${ <span class="hljs-string">'d'</span> | <span class="hljs-string">'l'</span> }</span><span class="hljs-subst">${ <span class="hljs-string">'i'</span> | <span class="hljs-string">'o'</span> }</span>ve`</span>;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Words</span>, <span class="hljs-string">'dive'</span> | <span class="hljs-string">'dove'</span> | <span class="hljs-string">'live'</span> | <span class="hljs-string">'love'</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>That enables us to concisely specify large unions. We’ll see a practical example later on.</p>
<p><a href="https://github.com/microsoft/TypeScript/pull/40336">Anders Hejlsberg warns</a>: “Beware that the cross product distribution of union types can quickly escalate into very large and costly types. Also note that union types are limited to less than 100,000 constituents, and the following will cause an error:”</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Digit</span> = <span class="hljs-number">0</span> | <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span> | <span class="hljs-number">4</span> | <span class="hljs-number">5</span> | <span class="hljs-number">6</span> | <span class="hljs-number">7</span> | <span class="hljs-number">8</span> | <span class="hljs-number">9</span>;</code>
<code><span class="hljs-comment">// @ts-expect-error: Expression produces a union type</span></code>
<code><span class="hljs-comment">// that is too complex to represent.</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Zip</span> = <span class="hljs-string">`<span class="hljs-subst">${Digit}</span><span class="hljs-subst">${Digit}</span><span class="hljs-subst">${Digit}</span><span class="hljs-subst">${Digit}</span><span class="hljs-subst">${Digit}</span>`</span>;</code>
</pre>
<p>The above union type has exactly 100,000 elements. This is another example that exceeds the limit:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Hex</span> =</code>
<code>  | <span class="hljs-string">'0'</span> | <span class="hljs-string">'1'</span> | <span class="hljs-string">'2'</span> | <span class="hljs-string">'3'</span> | <span class="hljs-string">'4'</span> | <span class="hljs-string">'5'</span> | <span class="hljs-string">'6'</span> | <span class="hljs-string">'7'</span> | <span class="hljs-string">'8'</span> | <span class="hljs-string">'9'</span></code>
<code>  | <span class="hljs-string">'A'</span> | <span class="hljs-string">'B'</span> | <span class="hljs-string">'C'</span> | <span class="hljs-string">'D'</span> | <span class="hljs-string">'E'</span> | <span class="hljs-string">'F'</span></code>
<code>  ;</code>
<code><span class="hljs-comment">// @ts-expect-error: Expression produces a union type</span></code>
<code><span class="hljs-comment">// that is too complex to represent.</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">CssColor</span> = <span class="hljs-string">`#<span class="hljs-subst">${Hex}</span><span class="hljs-subst">${Hex}</span><span class="hljs-subst">${Hex}</span><span class="hljs-subst">${Hex}</span><span class="hljs-subst">${Hex}</span><span class="hljs-subst">${Hex}</span>`</span>;</code>
</pre>
<h4 id="extracting-substrings-via-infer"><a class="heading-id-link" href="#extracting-substrings-via-infer">38.2.3 Extracting substrings via <code>infer</code></a></h4>
<p>If we use the <code>infer</code> operator inside a template literal, we can extract parts of strings:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ParseSemver</span>&lt;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; =</code>
<code>    <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer Major}</span>.<span class="hljs-subst">${infer Minor}</span>.<span class="hljs-subst">${infer Patch}</span>`</span></code>
<code>      ? [ <span class="hljs-title class_">Major</span>, <span class="hljs-title class_">Minor</span>, <span class="hljs-title class_">Patch</span> ]</code>
<code>      : <span class="hljs-built_in">never</span></code>
<code>;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">ParseSemver</span>&lt;<span class="hljs-string">'1.2.3'</span>&gt;, [<span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>]</code>
<code>&gt;&gt;;</code>
</pre>
<h4 id="parsing-substrings-via-infer-plus-extends"><a class="heading-id-link" href="#parsing-substrings-via-infer-plus-extends">38.2.4 Parsing substrings via <code>infer</code> plus <code>extends</code></a></h4>
<p>By default an <code>infer</code> inside a template literal extracts a string:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-string">'¡Hola!'</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`¡<span class="hljs-subst">${infer S}</span>!`</span> ? S : <span class="hljs-built_in">never</span>,</code>
<code>  <span class="hljs-string">'Hola'</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>If we constrain <code>infer</code> via <code>extends</code> to a type then TypeScript parses values of that type – e.g.:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-string">'true'</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer B <span class="hljs-keyword">extends</span> <span class="hljs-built_in">boolean</span>}</span>`</span> ? B : <span class="hljs-built_in">never</span>,</code>
<code>    <span class="hljs-literal">true</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-string">'256'</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer N <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>}</span>`</span> ? N : <span class="hljs-built_in">never</span>,</code>
<code>    <span class="hljs-number">256</span></code>
<code>  &gt;&gt;,</code>
<code>];</code>
</pre>
<p>Parsing numbers only works for integers:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">StrToNum</span>&lt;T&gt; =</code>
<code>  T <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer N <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>}</span>`</span> ? N : <span class="hljs-built_in">never</span></code>
<code>;</code>
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">StrToNum</span>&lt;<span class="hljs-string">'123'</span>&gt;, <span class="hljs-number">123</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">StrToNum</span>&lt;<span class="hljs-string">'-123'</span>&gt;, -<span class="hljs-number">123</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">StrToNum</span>&lt;<span class="hljs-string">'1.0'</span>&gt;, <span class="hljs-built_in">number</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">StrToNum</span>&lt;<span class="hljs-string">'1e2'</span>&gt;, <span class="hljs-built_in">number</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">StrToNum</span>&lt;<span class="hljs-string">'abc'</span>&gt;, <span class="hljs-built_in">never</span></code>
<code>  &gt;&gt;,</code>
<code>];</code>
</pre>
<p>For an example that uses <code>StrToNum</code>, see <a href="ch_computing-with-tuple-types.html#TupleIndices">“Extracting the indices (numbers) of a tuple” (§37.3.2)</a>.</p>
<h4 id="interpolating-primitive-types-into-template-literals"><a class="heading-id-link" href="#interpolating-primitive-types-into-template-literals">38.2.5 Interpolating primitive types into template literals</a></h4>
<p>So far, we have inserted literal types and union types into template literals, but we can also insert some primitive types. That lets us construct subsets of <code>string</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Version</span> = <span class="hljs-string">`v<span class="hljs-subst">${<span class="hljs-built_in">number</span>}</span>.<span class="hljs-subst">${<span class="hljs-built_in">number</span>}</span>`</span>;</code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Type '""' is not assignable to</span></code>
<code><span class="hljs-comment">// type '`v${number}.${number}`'.</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">version0</span>: <span class="hljs-title class_">Version</span> = <span class="hljs-string">''</span>;</code>
<code/>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">version1</span>: <span class="hljs-title class_">Version</span> = <span class="hljs-string">'v1.0'</span>; <span class="hljs-comment">// OK</span></code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Type '"v2.zero"' is not assignable to</span></code>
<code><span class="hljs-comment">// type '`v${number}.${number}`'.</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">version2</span>: <span class="hljs-title class_">Version</span> = <span class="hljs-string">'v2.zero'</span>;</code>
</pre>
<p>These are the supported types:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">undefinedValue</span>: <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-literal">undefined</span>}</span>`</span> = <span class="hljs-string">'undefined'</span>;</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">nullValue</span>: <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-literal">null</span>}</span>`</span> = <span class="hljs-string">'null'</span>;</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">booleanValue</span>: <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">boolean</span>}</span>`</span> = <span class="hljs-string">'true'</span>;</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">numberValue</span>: <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">number</span>}</span>`</span> = <span class="hljs-string">'123'</span>;</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">bigintValue</span>: <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">bigint</span>}</span>`</span> = <span class="hljs-string">'123'</span>;</code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">stringValue</span>: <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">string</span>}</span>`</span> = <span class="hljs-string">'abc'</span>;</code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Type 'symbol' is not assignable to type</span></code>
<code><span class="hljs-comment">// 'string | number | bigint | boolean | null | undefined'.</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">symbolValue</span>: <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">symbol</span>}</span>`</span> = <span class="hljs-string">'symbol'</span>;</code>
</pre>
<p>Note that <code>undefined</code> is the type with the single value <code>undefined</code>. <code>null</code> is similar.</p>
<h5 id="example-keeping-only-strings-with-numbers"><a class="heading-id-link" href="#example-keeping-only-strings-with-numbers">38.2.5.1 Example: keeping only strings with numbers</a></h5>
<p>An interpolated type <code>number</code> can be used to “filter” a union of string literal types:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Properties</span> = <span class="hljs-string">'0'</span> | <span class="hljs-string">'2'</span> | <span class="hljs-string">'length'</span> | <span class="hljs-string">'toString'</span>;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Properties</span> &amp; <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">number</span>}</span>`</span>, <span class="hljs-comment">// (A)</span></code>
<code>  <span class="hljs-string">'0'</span> | <span class="hljs-string">'2'</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>We use the intersection type in line A to extract those elements of <code>Properties</code> that are stringified numbers. Examples that use this trick:</p>
<ul>
  <li>
    <a href="ch_mapped-types.html#PickFreely">“Example: removing the constraint of parameter <code>K</code> of <code>Pick&lt;T, K&gt;</code>” (§36.3.3.2)</a>
  </li>
  <li>
    <a href="ch_computing-with-tuple-types.html#TupleIndexKeys">“Extracting the index keys (strings) of a tuple” (§37.3.1)</a>
  </li>
</ul>
<h5 id="example-excluding-strings-that-start-with-a"><a class="heading-id-link" href="#example-excluding-strings-that-start-with-a">38.2.5.2 Example: excluding strings that start with “a”</a></h5>
<p>The template literal type <code>`a${string}`</code> matches all string literal types that start with the character “a”. Therefore, we can use it to exclude those types:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-string">'apple'</span> | <span class="hljs-string">'apricot'</span> | <span class="hljs-string">'banana'</span>, <span class="hljs-string">`a<span class="hljs-subst">${<span class="hljs-built_in">string</span>}</span>`</span>&gt;,</code>
<code>  <span class="hljs-string">'banana'</span></code>
<code>&gt;&gt;;</code>
</pre>
<h3 id="utility-types-for-strings"><a class="heading-id-link" href="#utility-types-for-strings">38.3 Utility types for string manipulation</a></h3>
<p>TypeScript has four built-in string manipulation types (<a href="https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#intrinsic-string-manipulation-types">documentation</a>):</p>
<ul>
  <li>
    <p><code>Uppercase&lt;StringLiteralType&gt;</code></p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Uppercase</span>&lt;<span class="hljs-string">'hello'</span>&gt;, <span class="hljs-string">'HELLO'</span></code>
<code>&gt;&gt;;</code>
</pre>
  </li>
  <li>
    <p><code>Lowercase&lt;StringLiteralType&gt;</code></p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Lowercase</span>&lt;<span class="hljs-string">'HELLO'</span>&gt;, <span class="hljs-string">'hello'</span></code>
<code>&gt;&gt;;</code>
</pre>
  </li>
  <li>
    <p><code>Capitalize&lt;StringLiteralType&gt;</code></p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Capitalize</span>&lt;<span class="hljs-string">'hello'</span>&gt;, <span class="hljs-string">'Hello'</span></code>
<code>&gt;&gt;;</code>
</pre>
  </li>
  <li>
    <p><code>Uncapitalize&lt;StringLiteralType&gt;</code></p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Uncapitalize</span>&lt;<span class="hljs-string">'HELLO'</span>&gt;, <span class="hljs-string">'hELLO'</span></code>
<code>&gt;&gt;;</code>
</pre>
  </li>
</ul>
<p>TypeScript (as of version 5.7) uses the following JavaScript methods to make the changes – which are not locale aware (<a href="https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#intrinsic-string-manipulation-types">source</a> – see “technical details” at the end):</p>
<pre class="language-js">
<code>str.<span class="hljs-title function_">toUpperCase</span>() <span class="hljs-comment">// Uppercase</span></code>
<code>str.<span class="hljs-title function_">toLowerCase</span>() <span class="hljs-comment">// Lowercase</span></code>
<code>str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUpperCase</span>() + str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// Capitalize</span></code>
<code>str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toLowerCase</span>() + str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// Uncapitalize</span></code>
</pre>
<h4 id="example-isuppercase"><a class="heading-id-link" href="#example-isuppercase">38.3.1 Example: <code>isUppercase</code></a></h4>
<p>We can use <code>Uppercase</code> to define a generic type <code>IsUppercase</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">IsUppercase</span>&lt;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Uppercase</span>&lt;<span class="hljs-title class_">Str</span>&gt;</code>
<code>  ? <span class="hljs-literal">true</span></code>
<code>  : <span class="hljs-literal">false</span>;</code>
<code/>
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">IsUppercase</span>&lt;<span class="hljs-string">'SUNSHINE'</span>&gt;, <span class="hljs-literal">true</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">IsUppercase</span>&lt;<span class="hljs-string">'SUNSHINe'</span>&gt;, <span class="hljs-literal">false</span></code>
<code>  &gt;&gt;,</code>
<code>];</code>
</pre>
<h4 id="example-tostring"><a class="heading-id-link" href="#example-tostring">38.3.2 Example: <code>ToString</code></a></h4>
<p><code>ToString</code> uses normal template literal type interpolation to convert primitive literal types to string literal types:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ToString</span>&lt;</code>
<code>  T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">bigint</span> | <span class="hljs-built_in">boolean</span> | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span></code>
<code>&gt; = <span class="hljs-string">`<span class="hljs-subst">${T}</span>`</span></code>
<code>;</code>
<code/>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">ToString</span>&lt;<span class="hljs-string">'abc'</span> | <span class="hljs-number">123</span> | -<span class="hljs-number">456n</span> | <span class="hljs-literal">false</span> | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span>&gt;,</code>
<code>  <span class="hljs-string">'abc'</span> | <span class="hljs-string">'123'</span> | <span class="hljs-string">'-456'</span> | <span class="hljs-string">'false'</span> | <span class="hljs-string">'null'</span> | <span class="hljs-string">'undefined'</span></code>
<code>&gt;&gt;;</code>
</pre>
<h4 id="example-trimming-string-literal-types"><a class="heading-id-link" href="#example-trimming-string-literal-types">38.3.3 Example: trimming string literal types</a></h4>
<p>To trim a string literal type, we recursively remove all spaces from its start and its end:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">TrimStart</span>&lt;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; =</code>
<code>  <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">` <span class="hljs-subst">${infer Rest}</span>`</span></code>
<code>    ? <span class="hljs-title class_">TrimStart</span>&lt;<span class="hljs-title class_">Rest</span>&gt; <span class="hljs-comment">// (A)</span></code>
<code>    : <span class="hljs-title class_">Str</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">TrimEnd</span>&lt;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; =</code>
<code>  <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer Rest}</span> `</span></code>
<code>    ? <span class="hljs-title class_">TrimEnd</span>&lt;<span class="hljs-title class_">Rest</span>&gt; <span class="hljs-comment">// (B)</span></code>
<code>    : <span class="hljs-title class_">Str</span></code>
<code>;</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Trim</span>&lt;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = <span class="hljs-title class_">TrimStart</span>&lt;<span class="hljs-title class_">TrimEnd</span>&lt;<span class="hljs-title class_">Str</span>&gt;&gt;;</code>
</pre>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">TrimStart</span>&lt;<span class="hljs-string">'  text  '</span>&gt;,</code>
<code>    <span class="hljs-string">'text  '</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">TrimEnd</span>&lt;<span class="hljs-string">'  text  '</span>&gt;,</code>
<code>    <span class="hljs-string">'  text'</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">Trim</span>&lt;<span class="hljs-string">'  text  '</span>&gt;,</code>
<code>    <span class="hljs-string">'text'</span></code>
<code>  &gt;&gt;,</code>
<code>];</code>
</pre>
<p>Note the self-recursive invocations in line A and line B.</p>
<p>Acknowledgement: This example was inspired by <a href="https://x.com/MikeRyanDev/status/1308472279010025477">code by Mike Ryan</a>.</p>
<h3 id="working-with-tuples"><a class="heading-id-link" href="#working-with-tuples">38.4 Working with tuples</a></h3>
<h4 id="joining-a-tuple-of-strings"><a class="heading-id-link" href="#joining-a-tuple-of-strings">38.4.1 Joining a tuple of strings</a></h4>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Join</span>&lt;<span class="hljs-title class_">Strs</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>[], <span class="hljs-title class_">Sep</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> = <span class="hljs-string">','</span>&gt; =</code>
<code>  <span class="hljs-title class_">Strs</span> <span class="hljs-keyword">extends</span> [</code>
<code>    infer <span class="hljs-title class_">First</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>,</code>
<code>    ...infer <span class="hljs-title class_">Rest</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>[]</code>
<code>  ]</code>
<code>    ? <span class="hljs-title class_">Rest</span>[<span class="hljs-string">'length'</span>] <span class="hljs-keyword">extends</span> <span class="hljs-number">0</span></code>
<code>      ? <span class="hljs-title class_">First</span></code>
<code>      : <span class="hljs-string">`<span class="hljs-subst">${First}</span><span class="hljs-subst">${Sep}</span><span class="hljs-subst">${Join&lt;Rest, Sep&gt;}</span>`</span></code>
<code>    : <span class="hljs-string">''</span></code>
<code>;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Join</span>&lt;[<span class="hljs-string">'Hello'</span>, <span class="hljs-string">'How'</span>, <span class="hljs-string">'Are'</span>, <span class="hljs-string">'You'</span>], <span class="hljs-string">' '</span>&gt;,</code>
<code>  <span class="hljs-string">'Hello How Are You'</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>Once again, we are programming at a type level in a functional style.</p>
<p>In the second line, we take the tuple <code>Strs</code> apart (think destructuring):</p>
<ul>
  <li>
    <code>First</code> is the first element (a string).
  </li>
  <li>
    <code>Rest</code> is the remaining elements (a tuple).
  </li>
</ul>
<p>Next:</p>
<ul>
  <li>
    If the tuple <code>Rest</code> is empty, the result is simply <code>First</code>.
  </li>
  <li>
    Otherwise, we concatenate <code>First</code> with the separator <code>Sep</code> and the joined <code>Rest</code>.
  </li>
</ul>
<h4 id="Split"><a class="heading-id-link" href="#Split">38.4.2 Splitting a string</a></h4>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Split</span>&lt;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, <span class="hljs-title class_">Sep</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; =</code>
<code>  <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer First}</span><span class="hljs-subst">${Sep}</span><span class="hljs-subst">${infer Rest}</span>`</span></code>
<code>    ? [<span class="hljs-title class_">First</span>, ...<span class="hljs-title class_">Split</span>&lt;<span class="hljs-title class_">Rest</span>, <span class="hljs-title class_">Sep</span>&gt;] <span class="hljs-comment">// (A)</span></code>
<code>    : [<span class="hljs-title class_">Str</span>] <span class="hljs-comment">// (B)</span></code>
<code>;</code>
</pre>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Split</span>&lt;<span class="hljs-string">'How | are|you'</span>, <span class="hljs-string">'|'</span>&gt;,</code>
<code>  [<span class="hljs-string">'How '</span>, <span class="hljs-string">' are'</span>, <span class="hljs-string">'you'</span>]</code>
<code>&gt;&gt;;</code>
</pre>
<p>We use <code>infer</code> inside a template literal to determine the prefix <code>First</code> before a separator <code>Sep</code> and then recursively invoke <code>Split</code> (line A).</p>
<p>If no separator is found, the result is a tuple with the whole <code>Str</code> (line B).</p>
<h4 id="example-defining-a-string-literal-union-type-via-a-string-literal-type"><a class="heading-id-link" href="#example-defining-a-string-literal-union-type-via-a-string-literal-type">38.4.3 Example: defining a string literal union type via a string literal type</a></h4>
<p>We can use the previously defined <code>Split</code> and <code>Trim</code> to convert a string literal type to a string literal union type:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">StringToUnion</span>&lt;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; =</code>
<code>  <span class="hljs-title class_">Trim</span>&lt;<span class="hljs-title class_">TupleToUnion</span>&lt;<span class="hljs-title class_">Split</span>&lt;<span class="hljs-title class_">Str</span>, <span class="hljs-string">'|'</span>&gt;&gt;&gt;;</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">TupleToUnion</span>&lt;<span class="hljs-title class_">Tup</span> <span class="hljs-keyword">extends</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">unknown</span>[]&gt; = <span class="hljs-title class_">Tup</span>[<span class="hljs-built_in">number</span>]; </code>
<code/>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">StringToUnion</span>&lt;<span class="hljs-string">'A | B | C'</span>&gt;,</code>
<code>  <span class="hljs-string">'A'</span> | <span class="hljs-string">'C'</span> | <span class="hljs-string">'B'</span></code>
<code>&gt;&gt;;</code>
</pre>
<p><code>TupleToUnion</code> treats the tuple <code>Tup</code> as a map from numbers (indices) to values: <code>Tup[number]</code> means “give me all the values” (the range of <code>Tup</code>).</p>
<p>Note how the application of <code>Trim</code> is distributed and applied to each member of the union.</p>
<h4 id="splitting-a-string-into-code-units"><a class="heading-id-link" href="#splitting-a-string-into-code-units">38.4.4 Splitting a string into code units</a></h4>
<p>If we infer without a fixed separator, then the <code>First</code> inferred string is always a single code unit (a “JavaScript character”, not a Unicode code point which comprises one or two code units):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">SplitCodeUnits</span>&lt;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; =</code>
<code>  <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer First}</span><span class="hljs-subst">${infer Rest}</span>`</span></code>
<code>    <span class="hljs-comment">// `First` is not empty</span></code>
<code>    ? [<span class="hljs-title class_">First</span>, ...<span class="hljs-title class_">SplitCodeUnits</span>&lt;<span class="hljs-title class_">Rest</span>&gt;]</code>
<code>    <span class="hljs-comment">// `First` (and therefore `Str`) is empty</span></code>
<code>    : []</code>
<code>;</code>
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">SplitCodeUnits</span>&lt;<span class="hljs-string">'rainbow'</span>&gt;,</code>
<code>    [<span class="hljs-string">'r'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'i'</span>, <span class="hljs-string">'n'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'o'</span>, <span class="hljs-string">'w'</span>]</code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">SplitCodeUnits</span>&lt;<span class="hljs-string">''</span>&gt;,</code>
<code>    []</code>
<code>  &gt;&gt;,</code>
<code>];</code>
</pre>
<h3 id="working-with-objects"><a class="heading-id-link" href="#working-with-objects">38.5 Working with objects</a></h3>
<h4 id="example-adding-prefixes-to-property-names"><a class="heading-id-link" href="#example-adding-prefixes-to-property-names">38.5.1 Example: adding prefixes to property names</a></h4>
<p>Below, we are using a mapped type to convert an object type <code>Obj</code> to a new object type, where each property key starts with a dollar sign (<code>$</code>):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">PrependDollarSign</span>&lt;<span class="hljs-title class_">Obj</span>&gt; = {</code>
<code>  [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> (keyof <span class="hljs-title class_">Obj</span> &amp; <span class="hljs-built_in">string</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">`$<span class="hljs-subst">${Key}</span>`</span>]: <span class="hljs-title class_">Obj</span>[<span class="hljs-title class_">Key</span>]</code>
<code>};</code>
<code/>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Items</span> = {</code>
<code>  <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span>,</code>
<code>  <span class="hljs-attr">item</span>: <span class="hljs-built_in">string</span>,</code>
<code>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]: <span class="hljs-built_in">string</span>,</code>
<code>};</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">PrependDollarSign</span>&lt;<span class="hljs-title class_">Items</span>&gt;,</code>
<code>  {</code>
<code>    <span class="hljs-attr">$count</span>: <span class="hljs-built_in">number</span>,</code>
<code>    <span class="hljs-attr">$item</span>: <span class="hljs-built_in">string</span>,</code>
<code>    <span class="hljs-comment">// Omitted: [Symbol.toStringTag]</span></code>
<code>  }</code>
<code>&gt;&gt;;</code>
</pre>
<p>How does this code work? We assemble an output object like this:</p>
<ul>
  <li>
    <p>The result of <code>PrependDollarSign</code> is computed by a loop. In each iteration, the loop variable <code>Key</code> is assigned to one element of a union of string literal types. These are three ways of describing that union:</p>
    <ul>
      <li>
        <code>keyof Obj &amp; string</code>
      </li>
      <li>
        the intersection of the keys of <code>Obj</code> and all strings
      </li>
      <li>
        the string keys of <code>Obj</code>
      </li>
    </ul>
  </li>
  <li>
    <p>Each loop iteration contributes one property to the output object:</p>
    <ul>
      <li>
        The key of that property is specified via <code>as</code>: <code>`$${Key}`</code>
      </li>
      <li>
        The value of that property comes ofter the colon: <code>Obj[Key]</code>
      </li>
    </ul>
  </li>
</ul>
<h3 id="practical-examples"><a class="heading-id-link" href="#practical-examples">38.6 Practical examples</a></h3>
<h4 id="example-styling-output-to-a-terminal"><a class="heading-id-link" href="#example-styling-output-to-a-terminal">38.6.1 Example: styling output to a terminal</a></h4>
<p>In Node.js, we can use <a href="https://nodejs.org/api/util.html#utilstyletextformat-text-options"><code>util.styleText()</code></a> to log styled text to the console:</p>
<pre class="language-js">
<code><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(</code>
<code>  util.<span class="hljs-title function_">styleText</span>([<span class="hljs-string">'bold'</span>, <span class="hljs-string">'underline'</span>, <span class="hljs-string">'red'</span>], <span class="hljs-string">'Hello!'</span>)</code>
<code>);</code>
</pre>
<p>To get a list of all possible style values, evaluate this expression in the Node.js REPL:</p>
<pre class="language-js">
<code><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(util.<span class="hljs-property">inspect</span>.<span class="hljs-property">colors</span>)</code>
</pre>
<p>Below, we define a function <code>styleText()</code> that uses a single string to specify multiple styles and statically checks that that string has the proper format:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> styles = [</code>
<code>  <span class="hljs-string">'bold'</span>,</code>
<code>  <span class="hljs-string">'italic'</span>,</code>
<code>  <span class="hljs-string">'underline'</span>,</code>
<code>  <span class="hljs-string">'red'</span>,</code>
<code>  <span class="hljs-string">'green'</span>,</code>
<code>  <span class="hljs-string">'blue'</span>,</code>
<code>  <span class="hljs-comment">// ...</span></code>
<code>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// `as const` enables us to derive a type</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">StyleUnion</span> = <span class="hljs-title class_">TupleToUnion</span>&lt;<span class="hljs-keyword">typeof</span> styles&gt;;</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">TupleToUnion</span>&lt;<span class="hljs-title class_">Tup</span> <span class="hljs-keyword">extends</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">unknown</span>[]&gt; = <span class="hljs-title class_">Tup</span>[<span class="hljs-built_in">number</span>]; </code>
<code/>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">StyleTextFormat</span> =</code>
<code>| <span class="hljs-string">`<span class="hljs-subst">${StyleUnion}</span>`</span></code>
<code>| <span class="hljs-string">`<span class="hljs-subst">${StyleUnion}</span>+<span class="hljs-subst">${StyleUnion}</span>`</span></code>
<code>| <span class="hljs-string">`<span class="hljs-subst">${StyleUnion}</span>+<span class="hljs-subst">${StyleUnion}</span>+<span class="hljs-subst">${StyleUnion}</span>`</span></code>
<code>;</code>
<code/>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">styleText</span>(<span class="hljs-params">format: StyleTextFormat, text: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span> {</code>
<code>  <span class="hljs-keyword">return</span> util.<span class="hljs-title function_">styleText</span>(format.<span class="hljs-title function_">split</span>(<span class="hljs-string">'+'</span>), text);</code>
<code>}</code>
<code/>
<code><span class="hljs-title function_">styleText</span>(<span class="hljs-string">'bold+underline+red'</span>, <span class="hljs-string">'Hello!'</span>); <span class="hljs-comment">// OK</span></code>
<code><span class="hljs-comment">// @ts-expect-error: Argument of type '"bol+underline+red"' is not</span></code>
<code><span class="hljs-comment">// assignable to parameter of type 'StyleTextFormat'.</span></code>
<code><span class="hljs-title function_">styleText</span>(<span class="hljs-string">'bol+underline+red'</span>, <span class="hljs-string">'Hello!'</span>); <span class="hljs-comment">// typo: 'bol'</span></code>
</pre>
<h4 id="example-property-paths"><a class="heading-id-link" href="#example-property-paths">38.6.2 Example: property paths</a></h4>
<p>The following example is based on code by <a href="https://github.com/microsoft/TypeScript/pull/40336">Anders Hejlsberg</a>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">PropType</span>&lt;T, <span class="hljs-title class_">Path</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; =</code>
<code>  <span class="hljs-title class_">Path</span> <span class="hljs-keyword">extends</span> keyof T</code>
<code>    <span class="hljs-comment">// `Path` is already a key of `T`</span></code>
<code>    ? T[<span class="hljs-title class_">Path</span>]</code>
<code>    <span class="hljs-comment">// Otherwise: extract first dot-separated key</span></code>
<code>    : <span class="hljs-title class_">Path</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer First}</span>.<span class="hljs-subst">${infer Rest}</span>`</span></code>
<code>      ? <span class="hljs-title class_">First</span> <span class="hljs-keyword">extends</span> keyof T</code>
<code>        <span class="hljs-comment">// Use key `First` and compute PropType for result</span></code>
<code>        ? <span class="hljs-title class_">PropType</span>&lt;T[<span class="hljs-title class_">First</span>], <span class="hljs-title class_">Rest</span>&gt;</code>
<code>        : <span class="hljs-built_in">unknown</span></code>
<code>      : <span class="hljs-built_in">unknown</span>;</code>
<code/>
<code><span class="hljs-keyword">function</span> getPropValue</code>
<code>  &lt;T, P <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt;</code>
<code>  (<span class="hljs-attr">value</span>: T, <span class="hljs-attr">path</span>: P): <span class="hljs-title class_">PropType</span>&lt;T, P&gt;</code>
<code>{</code>
<code>  <span class="hljs-comment">// Not implemented yet...</span></code>
<code>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">PropType</span>&lt;T, P&gt;;</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: [<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>]}} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code>
<code/>
<code>assertType&lt;</code>
<code>  { <span class="hljs-keyword">readonly</span> <span class="hljs-attr">b</span>: <span class="hljs-keyword">readonly</span> [<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>] }</code>
<code>&gt;(<span class="hljs-title function_">getPropValue</span>(obj, <span class="hljs-string">'a'</span>));</code>
<code/>
<code>assertType&lt;</code>
<code>  <span class="hljs-keyword">readonly</span> [<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>]</code>
<code>&gt;(<span class="hljs-title function_">getPropValue</span>(obj, <span class="hljs-string">'a.b'</span>));</code>
<code/>
<code>assertType&lt;</code>
<code>  <span class="hljs-string">'y'</span></code>
<code>&gt;(<span class="hljs-title function_">getPropValue</span>(obj, <span class="hljs-string">'a.b.1'</span>));</code>
<code/>
<code>assertType&lt;</code>
<code>  <span class="hljs-built_in">unknown</span></code>
<code>&gt;(<span class="hljs-title function_">getPropValue</span>(obj, <span class="hljs-string">'a.b.p'</span>));</code>
<code/>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span></span>) {</code>
<code>  <span class="hljs-comment">// If the second argument is not a literal,</span></code>
<code>  <span class="hljs-comment">// we can’t infer a return type.</span></code>
<code>  assertType&lt;</code>
<code>    <span class="hljs-built_in">unknown</span></code>
<code>  &gt;(<span class="hljs-title function_">getPropValue</span>(obj, str));</code>
<code>}</code>
</pre>
<h4 id="example-changing-property-name-prefixes"><a class="heading-id-link" href="#example-changing-property-name-prefixes">38.6.3 Example: changing property name prefixes</a></h4>
<p>This is a more complicated version of an earlier example:</p>
<ul>
  <li>
    The type <code>JsonLd</code> describes <a href="https://developers.google.com/search/docs/appearance/structured-data/article">structured data</a> in JSON-LD format.
  </li>
  <li>
    We use <code>PropKeysAtToUnderscore</code> to convert the type <code>JsonLd</code> into a type with keys that we don’t need to quote.
  </li>
</ul>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">PropKeysAtToUnderscore</span>&lt;<span class="hljs-title class_">Obj</span>&gt; = {</code>
<code>  [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Obj</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">AtToUnderscore</span>&lt;<span class="hljs-title class_">Key</span>&gt;]: <span class="hljs-title class_">Obj</span>[<span class="hljs-title class_">Key</span>];</code>
<code>};</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">AtToUnderscore</span>&lt;<span class="hljs-title class_">Key</span>&gt; =</code>
<code>  <span class="hljs-comment">// Remove prefix '@', add prefix '_'</span></code>
<code>  <span class="hljs-title class_">Key</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`@<span class="hljs-subst">${infer Rest}</span>`</span> ? <span class="hljs-string">`_<span class="hljs-subst">${Rest}</span>`</span> : <span class="hljs-title class_">Key</span> <span class="hljs-comment">// (A)</span></code>
<code>;</code>
<code/>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">JsonLd</span> = {</code>
<code>  <span class="hljs-string">'@context'</span>: <span class="hljs-built_in">string</span>,</code>
<code>  <span class="hljs-string">'@type'</span>: <span class="hljs-built_in">string</span>,</code>
<code>  <span class="hljs-attr">datePublished</span>: <span class="hljs-built_in">string</span>,</code>
<code>};</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">PropKeysAtToUnderscore</span>&lt;<span class="hljs-title class_">JsonLd</span>&gt;,</code>
<code>  {</code>
<code>    <span class="hljs-attr">_context</span>: <span class="hljs-built_in">string</span>,</code>
<code>    <span class="hljs-attr">_type</span>: <span class="hljs-built_in">string</span>,</code>
<code>    <span class="hljs-attr">datePublished</span>: <span class="hljs-built_in">string</span>,</code>
<code>  }</code>
<code>&gt;&gt;;</code>
</pre>
<p>Note that in line A, we only the change key if it is a string that starts with an at symbol. Other keys (including symbols) are not changed.</p>
<p>We could constrain the type of <code>Key</code> like this:</p>
<pre class="language-ts">
<code><span class="hljs-title class_">AtToUnderscore</span>&lt;<span class="hljs-title class_">Key</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt;</code>
</pre>
<p>But then we couldn’t use <code>AtToUnderscore</code> for symbols and would have to filter values in some manner before passing them to this utility type.</p>
<h4 id="example-converting-camel-case-to-hyphen-case"><a class="heading-id-link" href="#example-converting-camel-case-to-hyphen-case">38.6.4 Example: converting camel case to hyphen case</a></h4>
<p>We can use template literal types to convert a string in camel case (JavaScript) to one in hyphen case (CSS).</p>
<p>Let’s first convert a string to a tuple of strings:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">SplitCamelCase</span>&lt;</code>
<code>  <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>,</code>
<code>  <span class="hljs-title class_">Word</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> = <span class="hljs-string">''</span>,</code>
<code>  <span class="hljs-title class_">Words</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>[] = []</code>
<code>&gt; = <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer Char}</span><span class="hljs-subst">${infer Rest}</span>`</span></code>
<code>  ? <span class="hljs-title class_">IsUppercase</span>&lt;<span class="hljs-title class_">Char</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-literal">true</span></code>
<code>    <span class="hljs-comment">// `Word` is empty if initial `Str` starts with capital letter</span></code>
<code>    ? <span class="hljs-title class_">SplitCamelCase</span>&lt;<span class="hljs-title class_">Rest</span>, <span class="hljs-title class_">Char</span>, <span class="hljs-title class_">Append</span>&lt;<span class="hljs-title class_">Words</span>, <span class="hljs-title class_">Word</span>&gt;&gt;</code>
<code>    : <span class="hljs-title class_">SplitCamelCase</span>&lt;<span class="hljs-title class_">Rest</span>, <span class="hljs-string">`<span class="hljs-subst">${Word}</span><span class="hljs-subst">${Char}</span>`</span>, <span class="hljs-title class_">Words</span>&gt;</code>
<code>  <span class="hljs-comment">// We have reached the end of `Str`:</span></code>
<code>  <span class="hljs-comment">// `Word` is only empty if initial `Str` was empty.</span></code>
<code>  : [...<span class="hljs-title class_">Words</span>, <span class="hljs-title class_">Word</span>]</code>
<code>;</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">IsUppercase</span>&lt;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Uppercase</span>&lt;<span class="hljs-title class_">Str</span>&gt;</code>
<code>  ? <span class="hljs-literal">true</span></code>
<code>  : <span class="hljs-literal">false</span></code>
<code>;</code>
<code><span class="hljs-comment">// Only append `Str` to `Arr` if `Str` isn’t empty</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Append</span>&lt;<span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>[], <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; =</code>
<code>  <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">''</span></code>
<code>    ? <span class="hljs-title class_">Arr</span></code>
<code>    : [...<span class="hljs-title class_">Arr</span>, <span class="hljs-title class_">Str</span>]</code>
<code>;</code>
<code/>
<code><span class="hljs-keyword">type</span> _1 = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">SplitCamelCase</span>&lt;<span class="hljs-string">'howAreYou'</span>&gt;,</code>
<code>    [<span class="hljs-string">'how'</span>, <span class="hljs-string">'Are'</span>, <span class="hljs-string">'You'</span>]</code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">SplitCamelCase</span>&lt;<span class="hljs-string">'PascalCase'</span>&gt;,</code>
<code>    [<span class="hljs-string">'Pascal'</span>, <span class="hljs-string">'Case'</span>]</code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">SplitCamelCase</span>&lt;<span class="hljs-string">'CAPS'</span>&gt;,</code>
<code>    [<span class="hljs-string">'C'</span>, <span class="hljs-string">'A'</span>, <span class="hljs-string">'P'</span>, <span class="hljs-string">'S'</span>]</code>
<code>  &gt;&gt;,</code>
<code>];</code>
</pre>
<p>To understand how this works, consider the roles of the parameters:</p>
<ul>
  <li>
    <code>Str</code> is the actual parameter and the only parameter that doesn’t have a default value. <code>SplitCamelCase</code> uses recursion to iterate over the characters of <code>Str</code>.
  </li>
  <li>
    <code>Word</code>: While inside a word, we add characters to this parameter.
  </li>
  <li>
    <code>Words</code>: Once a word is finished, it is added to this (initially empty) tuple. Once recursion is finished then <code>Words</code> contains the result of <code>SplitCamelCase</code> and is returned.
  </li>
</ul>
<p>The rest of the work involves lower-casing and joining the tuple elements, with hyphens as separators:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ToHyphenCase</span>&lt;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; =</code>
<code>  <span class="hljs-title class_">HyphenateWords</span>&lt;<span class="hljs-title class_">SplitCamelCase</span>&lt;<span class="hljs-title class_">Str</span>&gt;&gt;</code>
<code>;</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">HyphenateWords</span>&lt;<span class="hljs-title class_">Words</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>[]&gt; =</code>
<code>  <span class="hljs-title class_">Words</span> <span class="hljs-keyword">extends</span> [</code>
<code>    infer <span class="hljs-title class_">First</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>,</code>
<code>    ...infer <span class="hljs-title class_">Rest</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>[]</code>
<code>  ]</code>
<code>    ? <span class="hljs-title class_">Rest</span>[<span class="hljs-string">'length'</span>] <span class="hljs-keyword">extends</span> <span class="hljs-number">0</span></code>
<code>      ? <span class="hljs-title class_">Lowercase</span>&lt;<span class="hljs-title class_">First</span>&gt;</code>
<code>      : <span class="hljs-string">`<span class="hljs-subst">${Lowercase&lt;First&gt;}</span>-<span class="hljs-subst">${HyphenateWords&lt;Rest&gt;}</span>`</span></code>
<code>    : <span class="hljs-string">''</span></code>
<code>;</code>
<code/>
<code><span class="hljs-keyword">type</span> _2 = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">ToHyphenCase</span>&lt;<span class="hljs-string">'howAreYou'</span>&gt;,</code>
<code>    <span class="hljs-string">'how-are-you'</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">ToHyphenCase</span>&lt;<span class="hljs-string">'PascalCase'</span>&gt;,</code>
<code>    <span class="hljs-string">'pascal-case'</span></code>
<code>  &gt;&gt;,</code>
<code>];</code>
</pre>
<h4 id="example-from-hyphen-case-to-camel-case"><a class="heading-id-link" href="#example-from-hyphen-case-to-camel-case">38.6.5 Example: converting hyphen case to camel case</a></h4>
<p>Going the opposite way, from hyphen case to camel case, is easier because we have hyphens as separators. As a utility type, we use <a href="#Split"><code>Split</code></a> from earlier in this chapter.</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ToLowerCamelCase</span>&lt;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; =</code>
<code>  <span class="hljs-title class_">Uncapitalize</span>&lt;<span class="hljs-title class_">ToUpperCamelCase</span>&lt;<span class="hljs-title class_">Str</span>&gt;&gt;</code>
<code>;</code>
<code><span class="hljs-comment">// Upper camel case (Pascal case) is easier to compute</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ToUpperCamelCase</span>&lt;<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; =</code>
<code>  camelizeWords&lt;<span class="hljs-title class_">Split</span>&lt;<span class="hljs-title class_">Str</span>, <span class="hljs-string">'-'</span>&gt;&gt;</code>
<code>;</code>
<code/>
<code><span class="hljs-keyword">type</span> camelizeWords&lt;<span class="hljs-title class_">Words</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>[]&gt; =</code>
<code>  <span class="hljs-title class_">Words</span> <span class="hljs-keyword">extends</span> [</code>
<code>    infer <span class="hljs-title class_">First</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>,</code>
<code>    ...infer <span class="hljs-title class_">Rest</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>[]</code>
<code>  ]</code>
<code>    ? <span class="hljs-title class_">Rest</span>[<span class="hljs-string">'length'</span>] <span class="hljs-keyword">extends</span> <span class="hljs-number">0</span></code>
<code>      ? <span class="hljs-title class_">Capitalize</span>&lt;<span class="hljs-title class_">First</span>&gt;</code>
<code>      : <span class="hljs-string">`<span class="hljs-subst">${Capitalize&lt;First&gt;}</span><span class="hljs-subst">${camelizeWords&lt;Rest&gt;}</span>`</span></code>
<code>    : <span class="hljs-string">''</span></code>
<code>;</code>
<code/>
<code><span class="hljs-keyword">type</span> _ = [</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">ToLowerCamelCase</span>&lt;<span class="hljs-string">'how-are-you'</span>&gt;,</code>
<code>    <span class="hljs-string">'howAreYou'</span></code>
<code>  &gt;&gt;,</code>
<code>  <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>    <span class="hljs-title class_">ToUpperCamelCase</span>&lt;<span class="hljs-string">'how-are-you'</span>&gt;,</code>
<code>    <span class="hljs-string">'HowAreYou'</span></code>
<code>  &gt;&gt;,</code>
<code>];</code>
</pre>
<h3 id="neat-things-people-are-doing-with-template-literal-types"><a class="heading-id-link" href="#neat-things-people-are-doing-with-template-literal-types">38.7 Neat things people are doing with template literal types</a></h3>
<p>In this section, I have collected interesting things I have seen people do with template literal types.</p>
<h4 id="node-js-type-for-uuids"><a class="heading-id-link" href="#node-js-type-for-uuids">38.7.1 Node.js: type for UUIDs</a></h4>
<p><a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/node/crypto.d.ts"><code>@types/node</code></a> uses the following type for UUIDs:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">UUID</span> = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">string</span>}</span>-<span class="hljs-subst">${<span class="hljs-built_in">string</span>}</span>-<span class="hljs-subst">${<span class="hljs-built_in">string</span>}</span>-<span class="hljs-subst">${<span class="hljs-built_in">string</span>}</span>-<span class="hljs-subst">${<span class="hljs-built_in">string</span>}</span>`</span>;</code>
</pre>
<h4 id="parsing-cli-arguments-stefan-baumgartner"><a class="heading-id-link" href="#parsing-cli-arguments-stefan-baumgartner">38.7.2 Parsing CLI arguments (Stefan Baumgartner)</a></h4>
<p>Given the following definitions for the parameters of a shell script (<code>num</code> is an arbitrary name for a string parameter – not a type):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> opts = program</code>
<code>  .<span class="hljs-title function_">option</span>(<span class="hljs-string">"-e, --episode &lt;num&gt;"</span>, <span class="hljs-string">"Download episode No. &lt;num&gt;"</span>)</code>
<code>  .<span class="hljs-title function_">option</span>(<span class="hljs-string">"--keep"</span>, <span class="hljs-string">"Keeps temporary files"</span>)</code>
<code>  .<span class="hljs-title function_">option</span>(<span class="hljs-string">"--ratio [ratio]"</span>, <span class="hljs-string">"Either 16:9, or a custom ratio"</span>)</code>
<code>  .<span class="hljs-title function_">opts</span>();</code>
</pre>
<p>This type can be statically derived for <code>opts</code>:</p>
<pre class="language-ts">
<code>{</code>
<code>  <span class="hljs-attr">episode</span>: <span class="hljs-built_in">string</span>;</code>
<code>} &amp; {</code>
<code>  <span class="hljs-attr">keep</span>: <span class="hljs-built_in">boolean</span>;</code>
<code>} &amp; {</code>
<code>  <span class="hljs-attr">ratio</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">boolean</span>;</code>
<code>}</code>
</pre>
<p>More information: <a href="https://fettblog.eu/slides/the-typescript-converging-point/">“The TypeScript converging point”</a> by Stefan Baumgartner</p>
<h4 id="smart-result-type-of-document-queryselector-mike-ryan"><a class="heading-id-link" href="#smart-result-type-of-document-queryselector-mike-ryan">38.7.3 Smart result type of <code>document.querySelector()</code> (Mike Ryan)</a></h4>
<p>By parsing the argument of <code>querySelector()</code> at compile time, we can derive nice types:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> a = <span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'div.banner &gt; a.call-to-action'</span>);</code>
<code>  <span class="hljs-comment">// HTMLAnchorElement</span></code>
<code><span class="hljs-keyword">const</span> b = <span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'input, div'</span>);</code>
<code>  <span class="hljs-comment">// HTMLInputElement | HTMLDivElement</span></code>
<code><span class="hljs-keyword">const</span> c = <span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'circle[cx="150"]'</span>);</code>
<code>  <span class="hljs-comment">// SVGCircleElement</span></code>
<code><span class="hljs-keyword">const</span> d = <span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'button#buy-now'</span>);</code>
<code>  <span class="hljs-comment">// HTMLButtonElement</span></code>
<code><span class="hljs-keyword">const</span> e = <span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'section p:first-of-type'</span>);</code>
<code>  <span class="hljs-comment">// HTMLParagraphElement</span></code>
</pre>
<p>More information: <a href="https://x.com/MikeRyanDev/status/1308472279010025477">tweet</a> by Mike Ryan.</p>
<h4 id="typing-routes-in-angular-mike-ryan"><a class="heading-id-link" href="#typing-routes-in-angular-mike-ryan">38.7.4 Typing routes in Angular (Mike Ryan)</a></h4>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-title class_">AppRoutes</span> = <span class="hljs-title function_">routes</span>(</code>
<code>  {</code>
<code>    <span class="hljs-attr">path</span>: <span class="hljs-string">''</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>,</code>
<code>  },</code>
<code>  {</code>
<code>    <span class="hljs-attr">path</span>: <span class="hljs-string">'book/:id'</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>,</code>
<code>    <span class="hljs-attr">children</span>: <span class="hljs-title function_">routes</span>(</code>
<code>      {</code>
<code>        <span class="hljs-attr">path</span>: <span class="hljs-string">'author/:id'</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>,</code>
<code>      },</code>
<code>    ),</code>
<code>  },</code>
<code>);</code>
<code/>
<code><span class="hljs-comment">// `AppRoutes` determines (statically!) what arguments can be</span></code>
<code><span class="hljs-comment">// passed to `buildPath()`:</span></code>
<code/>
<code><span class="hljs-keyword">const</span> buildPath = <span class="hljs-title function_">createPathBuilder</span>(<span class="hljs-title class_">AppRoutes</span>);</code>
<code><span class="hljs-title function_">buildPath</span>(); <span class="hljs-comment">// OK</span></code>
<code><span class="hljs-title function_">buildPath</span>(<span class="hljs-string">'book'</span>, <span class="hljs-number">12</span>); <span class="hljs-comment">// OK</span></code>
<code><span class="hljs-title function_">buildPath</span>(<span class="hljs-string">'book'</span>, <span class="hljs-string">'123'</span>, <span class="hljs-string">'author'</span>, <span class="hljs-number">976</span>); <span class="hljs-comment">// OK</span></code>
<code/>
<code><span class="hljs-title function_">buildPath</span>(<span class="hljs-string">'book'</span>, <span class="hljs-literal">null</span>);</code>
<code>   <span class="hljs-comment">// Error: argument not assignable to parameter</span></code>
<code><span class="hljs-title function_">buildPath</span>(<span class="hljs-string">'fake'</span>, <span class="hljs-string">'route'</span>);</code>
<code>   <span class="hljs-comment">// Error: argument not assignable to parameter</span></code>
</pre>
<p>More information: <a href="https://x.com/MikeRyanDev/status/1308036861747752962">tweet</a> by Mike Ryan.</p>
<h4 id="express-route-extractor-dan-vanderkam"><a class="heading-id-link" href="#express-route-extractor-dan-vanderkam">38.7.5 Express route extractor (Dan Vanderkam)</a></h4>
<p>The first argument of <code>handleGet()</code> determines the parameters of the callback:</p>
<pre class="language-ts">
<code><span class="hljs-title function_">handleGet</span>(</code>
<code>  <span class="hljs-string">'/posts/:postId/:commentId'</span>,</code>
<code>  <span class="hljs-function">(<span class="hljs-params">{postId, commentId}</span>) =&gt;</span> {</code>
<code>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(postId, commentId);</code>
<code>  }</code>
<code>);</code>
</pre>
<p>More information: <a href="https://x.com/danvdk/status/1301707026507198464">tweet</a> by Dan Vanderkam</p>
<h4 id="tailwind-color-variations-tomek-su-C5-82kowski"><a class="heading-id-link" href="#tailwind-color-variations-tomek-su%C5%82kowski">38.7.6 Tailwind color variations (Tomek Sułkowski)</a></h4>
<p>Thanks to template literals being distributive, we can define <code>TailwindColor</code> very concisely:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">BaseColor</span> =</code>
<code>  <span class="hljs-string">'gray'</span> | <span class="hljs-string">'red'</span> | <span class="hljs-string">'yellow'</span> | <span class="hljs-string">'green'</span> |</code>
<code>  <span class="hljs-string">'blue'</span> | <span class="hljs-string">'indigo'</span> | <span class="hljs-string">'purple'</span> | <span class="hljs-string">'pink'</span>;</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Variant</span> =</code>
<code>  <span class="hljs-number">50</span> | <span class="hljs-number">100</span> | <span class="hljs-number">200</span> | <span class="hljs-number">300</span> | <span class="hljs-number">400</span></code>
<code>  <span class="hljs-number">500</span> | <span class="hljs-number">600</span> | <span class="hljs-number">700</span> | <span class="hljs-number">800</span> | <span class="hljs-number">900</span>;</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">TailwindColor</span> = <span class="hljs-string">`<span class="hljs-subst">${BaseColor}</span>-<span class="hljs-subst">${Variant}</span>`</span>;</code>
</pre>
<p>More information: <a href="https://x.com/sulco/status/1332337570563448834">tweet</a> by Tomek Sułkowski</p>
<h4 id="arktype-defining-types"><a class="heading-id-link" href="#arktype-defining-types">38.7.7 Arktype: defining types</a></h4>
<p>Where <a href="https://zod.dev">the TypeScript library Zod</a> uses chained method calls to define types, the <a href="https://github.com/arktypeio/arktype">ArkType library</a> uses (mostly) string literals that are parsed via template literal types. I prefer Zod’s approach, but it’s amazing how much ArkType does with string literals:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> currentTsSyntax = <span class="hljs-title function_">type</span>({</code>
<code>  <span class="hljs-attr">keyword</span>: <span class="hljs-string">"null"</span>,</code>
<code>  <span class="hljs-attr">stringLiteral</span>: <span class="hljs-string">"'TS'"</span>,</code>
<code>  <span class="hljs-attr">numberLiteral</span>: <span class="hljs-string">"5"</span>,</code>
<code>  <span class="hljs-attr">bigintLiteral</span>: <span class="hljs-string">"5n"</span>,</code>
<code>  <span class="hljs-attr">union</span>: <span class="hljs-string">"string|number"</span>,</code>
<code>  <span class="hljs-attr">intersection</span>: <span class="hljs-string">"boolean&amp;true"</span>,</code>
<code>  <span class="hljs-attr">array</span>: <span class="hljs-string">"Date[]"</span>,</code>
<code>  <span class="hljs-attr">grouping</span>: <span class="hljs-string">"(0|1)[]"</span>,</code>
<code>  <span class="hljs-attr">objectLiteral</span>: {</code>
<code>    <span class="hljs-attr">nested</span>: <span class="hljs-string">"string"</span>,</code>
<code>    <span class="hljs-string">"optional?"</span>: <span class="hljs-string">"number"</span></code>
<code>  },</code>
<code>  <span class="hljs-attr">tuple</span>: [<span class="hljs-string">"number"</span>, <span class="hljs-string">"number"</span>]</code>
<code>});</code>
</pre>
<h3 id="conclusion-and-caveats"><a class="heading-id-link" href="#conclusion-and-caveats">38.8 Conclusion and caveats</a></h3>
<p>It’s amazing what people are doing with template literal types: We now can statically check complex data in string literals or use them to derive types. However, doing so also comes with caveats:</p>
<ul>
  <li>
    The error messages are usually not very good.
  </li>
  <li>
    Type-level code that uses template literals can be difficult to understand.
  </li>
  <li>
    Such code can slow down type checking – especially if it involves recursion.
  </li>
</ul>
<h3 id="further-reading-10"><a class="heading-id-link" href="#further-reading-10">38.9 Further reading</a></h3>
<ul>
  <li>
    List of template literal types examples: <a href="https://github.com/ghoullier/awesome-template-literal-types">“Awesome Template Literal Types”</a>
  </li>
</ul>
<h3 id="sources-of-this-chapter-7"><a class="heading-id-link" href="#sources-of-this-chapter-7">38.10 Sources of this chapter</a></h3>
<ul>
  <li>
    Chapter <a href="https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html">“Template Literal Types”</a> in the TypeScript Handbook
  </li>
  <li>
    Pull request <a href="https://github.com/microsoft/TypeScript/pull/40336">“Template literal types and mapped type <code>as</code> clauses”</a> by Anders Hejlsberg
  </li>
  <li>
    Blog post <a href="https://blog.beraliv.dev/2022-07-14-camel-case">“Transform string literal type into camelCase in TypeScript”</a> by Alexey Berezin
  </li>
  <li>
    Blog post <a href="https://macarthur.me/posts/template-literal-types/">“I didn’t know you could compose template literal types in TypeScript”</a> by Alex MacArthur
  </li>
</ul>

    
      
</body>
</html>