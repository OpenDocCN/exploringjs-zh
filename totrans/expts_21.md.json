["```ts\ninterface LineStream {\n getNextLine(): string;\n}\n\n```", "```ts\ntype StreamValue = null | string;\n\ninterface LineStream {\n getNextLine(): StreamValue;\n}\n\n```", "```ts\nfunction countComments(ls: LineStream) {\n let commentCount = 0;\n while (true) {\n const line = ls.getNextLine();\n // @ts-expect-error: 'line' is possibly 'null'.\n if (line.startsWith('#')) { // (A)\n commentCount++;\n }\n if (line === null) break;\n }\n return commentCount;\n}\n\n```", "```ts\nfunction countComments(ls: LineStream) {\n let commentCount = 0;\n while (true) {\n const line = ls.getNextLine();\n if (line === null) break;\n if (line.startsWith('#')) { // (A)\n commentCount++;\n }\n }\n return commentCount;\n}\n\n```", "```ts\nconst EOF = Symbol('EOF');\ntype StreamValue = typeof EOF | string;\n\n```", "```ts\nconst couldNotParseNumber = Symbol('couldNotParseNumber');\n\nfunction parseNumber(str: string)\n : number | typeof couldNotParseNumber\n{\n const result = Number(str);\n if (!Number.isNaN(result)) {\n return result;\n } else {\n return couldNotParseNumber;\n }\n}\n\nassert.equal(\n parseNumber('123'), 123\n);\nassert.equal(\n parseNumber('hello'), couldNotParseNumber\n);\n\n```", "```ts\ninterface ValueStream<T> {\n getNextValue(): T;\n}\n\n```", "```ts\ninterface NormalValue<T> {\n type: 'normal'; // string literal type\n data: T;\n}\ninterface Eof {\n type: 'eof'; // string literal type\n}\ntype ValueStreamValue<T> = Eof | NormalValue<T>;\n\ninterface ValueStream<T> {\n getNextValue(): ValueStreamValue<T>;\n}\n\n```", "```ts\nfunction countValues<T>(vs: ValueStream<T>, data: T) {\n let valueCount = 0;\n while (true) {\n const value = vs.getNextValue(); // (A)\n assertType<Eof | NormalValue<T>>(value);\n\n if (value.type === 'eof') break;\n assertType<NormalValue<T>>(value); // (B)\n\n if (value.data === data) { // (C)\n valueCount++;\n }\n }\n return valueCount;\n}\n\n```", "```ts\ninterface IteratorYieldResult<TYield> {\n done?: false; // boolean literal type\n value: TYield;\n}\n\ninterface IteratorReturnResult<TReturn> {\n done: true; // boolean literal type\n value: TReturn;\n}\n\ntype IteratorResult<T, TReturn = any> =\n | IteratorYieldResult<T>\n | IteratorReturnResult<TReturn>;\n\n```", "```ts\ninterface A {\n one: number;\n two: number;\n}\ninterface B {\n three: number;\n four: number;\n}\ntype Union = A | B;\n\nfunction func(x: Union) {\n // @ts-expect-error: Property 'two' does not exist on type 'Union'.\n // Property 'two' does not exist on type 'B'.(2339)\n console.log(x.two); // error\n\n if ('one' in x) { // discriminating check\n console.log(x.two); // OK\n }\n}\n\n```", "```ts\ntype Union = [string] | number;\n\nfunction logHexValue(x: Union) {\n if (Array.isArray(x)) { // discriminating check\n console.log(x[0]); // OK\n } else {\n console.log(x.toString(16)); // OK\n }\n}\n\n```"]