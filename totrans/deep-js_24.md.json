["```js\n// .resolve() before .then()\nconst tp1 = new ToyPromise1();\ntp1.resolve('abc');\ntp1.then((value) => {\n assert.equal(value, 'abc');\n});\n```", "```js\n// .then() before .resolve()\nconst tp2 = new ToyPromise1();\ntp2.then((value) => {\n assert.equal(value, 'def');\n});\ntp2.resolve('def');\n```", "```js\nthen(onFulfilled, onRejected) {\n const fulfillmentTask = () => {\n if (typeof onFulfilled === 'function') {\n onFulfilled(this._promiseResult);\n }\n };\n const rejectionTask = () => {\n if (typeof onRejected === 'function') {\n onRejected(this._promiseResult);\n }\n };\n switch (this._promiseState) {\n case 'pending':\n this._fulfillmentTasks.push(fulfillmentTask);\n this._rejectionTasks.push(rejectionTask);\n break;\n case 'fulfilled':\n addToTaskQueue(fulfillmentTask);\n break;\n case 'rejected':\n addToTaskQueue(rejectionTask);\n break;\n default:\n throw new Error();\n }\n}\n```", "```js\nfunction addToTaskQueue(task) {\n setTimeout(task, 0);\n}\n```", "```js\nresolve(value) {\n if (this._promiseState !== 'pending') return this;\n this._promiseState = 'fulfilled';\n this._promiseResult = value;\n this._clearAndEnqueueTasks(this._fulfillmentTasks);\n return this; // enable chaining\n}\n```", "```js\n_clearAndEnqueueTasks(tasks) {\n this._fulfillmentTasks = undefined;\n this._rejectionTasks = undefined;\n tasks.map(addToTaskQueue);\n}\n```", "```js\nnew ToyPromise2()\n .resolve('result1')\n .then(x => {\n assert.equal(x, 'result1');\n return 'result2';\n })\n .then(x => {\n assert.equal(x, 'result2');\n });\n```", "```js\nnew ToyPromise2()\n .reject('error1')\n .then(null,\n x => {\n assert.equal(x, 'error1');\n return 'result2';\n })\n .then(x => {\n assert.equal(x, 'result2');\n });\n```", "```js\nnew ToyPromise2()\n .reject('error1')\n .catch(x => { // (A)\n assert.equal(x, 'error1');\n return 'result2';\n })\n .then(x => {\n assert.equal(x, 'result2');\n });\n```", "```js\n.catch(rejectionReaction)\n.then(null, rejectionReaction)\n```", "```js\ncatch(onRejected) { // [new]\n return this.then(null, onRejected);\n}\n```", "```js\nsomeAsyncFunction()\n .then(fulfillmentReaction1)\n .then(fulfillmentReaction2)\n .catch(rejectionReaction);\n```", "```js\nsomeAsyncFunction()\n .catch(rejectionReaction)\n .then(fulfillmentReaction);\n```", "```js\nthen(onFulfilled, onRejected) {\n const resultPromise = new ToyPromise2(); // [new]\n\n const fulfillmentTask = () => {\n if (typeof onFulfilled === 'function') {\n const returned = onFulfilled(this._promiseResult);\n resultPromise.resolve(returned); // [new]\n } else { // [new]\n // `onFulfilled` is missing\n // => we must pass on the fulfillment value\n resultPromise.resolve(this._promiseResult);\n } \n };\n\n const rejectionTask = () => {\n if (typeof onRejected === 'function') {\n const returned = onRejected(this._promiseResult);\n resultPromise.resolve(returned); // [new]\n } else { // [new]\n // `onRejected` is missing\n // => we must pass on the rejection value\n resultPromise.reject(this._promiseResult);\n }\n };\n\n \u00b7\u00b7\u00b7\n\n return resultPromise; // [new]\n}\n```", "```js\nasyncFunc1()\n.then((result1) => {\n assert.equal(result1, 'Result of asyncFunc1()');\n return asyncFunc2(); // (A)\n})\n.then((result2Promise) => {\n result2Promise\n .then((result2) => { // (B)\n assert.equal(\n result2, 'Result of asyncFunc2()');\n });\n});\n```", "```js\nasyncFunc1()\n.then((result1) => {\n assert.equal(result1, 'Result of asyncFunc1()');\n return asyncFunc2(); // (A)\n})\n.then((result2) => {\n // result2 is the fulfillment value, not the Promise\n assert.equal(\n result2, 'Result of asyncFunc2()');\n});\n```", "```js\nfunction isThenable(value) { // [new]\n return typeof value === 'object' && value !== null\n && typeof value.then === 'function';\n}\n```", "```js\nresolve(value) { // [new]\n if (this._alreadyResolved) return this;\n this._alreadyResolved = true;\n\n if (isThenable(value)) {\n // Forward fulfillments and rejections from `value` to `this`.\n // The callbacks are always executed asynchronously\n value.then(\n (result) => this._doFulfill(result),\n (error) => this._doReject(error));\n } else {\n this._doFulfill(value);\n }\n\n return this; // enable chaining\n}\n```", "```js\n_doFulfill(value) { // [new]\n assert.ok(!isThenable(value));\n this._promiseState = 'fulfilled';\n this._promiseResult = value;\n this._clearAndEnqueueTasks(this._fulfillmentTasks);\n}\n```", "```js\nnew ToyPromise4()\n .resolve('a')\n .then((value) => {\n assert.equal(value, 'a');\n throw 'b'; // triggers a rejection\n })\n .catch((error) => {\n assert.equal(error, 'b');\n })\n```", "```js\n const fulfillmentTask = () => {\n if (typeof onFulfilled === 'function') {\n this._runReactionSafely(resultPromise, onFulfilled); // [new]\n } else {\n // `onFulfilled` is missing\n // => we must pass on the fulfillment value\n resultPromise.resolve(this._promiseResult);\n } \n };\n```", "```js\n_runReactionSafely(resultPromise, reaction) { // [new]\n try {\n const returned = reaction(this._promiseResult);\n resultPromise.resolve(returned);\n } catch (e) {\n resultPromise.reject(e);\n }\n}\n```", "```js\nconst promise = new Promise(\n (resolve, reject) => { // executor\n // \u00b7\u00b7\u00b7\n });\n```"]