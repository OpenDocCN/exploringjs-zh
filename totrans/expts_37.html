<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>30 Type guards and narrowing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>30 Type guards and narrowing</h1>
<blockquote>原文：<a href="https://exploringjs.com/ts/book/ch_type-guards.html">https://exploringjs.com/ts/book/ch_type-guards.html</a></blockquote>

    
        <div id="adbox">
      <div id="adbox-explain">(Ad, please don’t block.)</div>
              
          </div>
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#type-guards-and-narrowing-1">30.1 Type guards and narrowing</a>
      <ol>
        <li>
          <a href="#example-a-type-guard-with">30.1.1 Example: a type guard with <code>===</code></a>
        </li>
        <li>
          <a href="#example-a-type-guard-with-typeof">30.1.2 Example: a type guard with <code>typeof</code></a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#when-do-we-need-to-narrow-types">30.2 When do we need to narrow types?</a>
      <ol>
        <li>
          <a href="#the-type-unknown-is-usually-too-general">30.2.1 The type <code>unknown</code> is usually too general</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#where-can-we-use-type-guards">30.3 Where can we use type guards?</a>
      <ol>
        <li>
          <a href="#type-guards-can-also-affect-parts-of-expressions">30.3.1 Type guards can also affect parts of expressions</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#what-kinds-of-type-guards-are-built-in">30.4 What kinds of type guards are built-in?</a>
      <ol>
        <li>
          <a href="#typeof-instanceof-array-isarray">30.4.1 <code>typeof</code>, <code>instanceof</code>, <code>Array.isArray</code></a>
        </li>
        <li>
          <a href="#strict-equality-and-strict-inequality">30.4.2 Strict equality (<code>===</code>) and strict inequality(<code>!==</code>)</a>
        </li>
        <li>
          <a href="#truthiness-checks">30.4.3 Truthiness checks</a>
        </li>
        <li>
          <a href="#checking-for-distinct-properties-via-the-operator-in">30.4.4 Checking for distinct properties via the operator <code>in</code></a>
        </li>
        <li>
          <a href="#checking-the-value-of-a-shared-property-discriminated-unions">30.4.5 Checking the value of a shared property (discriminated unions)</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#narrowing-via-assignment">30.5 Narrowing via assignment</a>
      <ol>
        <li>
          <a href="#narrowing-storage-locations-with-explicit-types">30.5.1 Narrowing storage locations with explicit types</a>
        </li>
        <li>
          <a href="#narrowing-variables-without-explicit-types">30.5.2 Narrowing variables without explicit types</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#for-which-storage-locations-can-we-use-type-narrowing">30.6 For which storage locations can we use type-narrowing?</a>
      <ol>
        <li>
          <a href="#narrowing-the-types-of-dotted-names">30.6.1 Narrowing the types of dotted names</a>
        </li>
        <li>
          <a href="#narrowing-array-element-types">30.6.2 Narrowing Array element types</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#user-defined-type-guard-functions">30.7 User-defined type guard functions</a>
      <ol>
        <li>
          <a href="#example-isnonnullable">30.7.1 Example: <code>isNonNullable()</code></a>
        </li>
        <li>
          <a href="#example-helping-every-with-a-user-defined-type-guard">30.7.2 Example: helping <code>.every()</code> with a user-defined type guard</a>
        </li>
        <li>
          <a href="#this-based-type-guards">30.7.3 <code>this</code>-based type guards</a>
        </li>
        <li>
          <a href="#inferred-type-predicates">30.7.4 Inferred type predicates</a>
        </li>
        <li>
          <a href="#advanced-example-user-defined-type-guard-istypeof">30.7.5 Advanced example: user-defined type guard <code>isTypeOf()</code></a>
        </li>
      </ol>
    </li>
  </ol>
</nav>
<p>Sometimes a value <code>nameOpt</code> has a type that is not specific enough – e.g., the type <code>null | string</code>. Before we can do anything with <code>nameOpt</code>, we have to check whether it is <code>null</code> or a string:</p>
<ul>
  <li>
    The condition of such a check is called a <em>type guard</em>.
  </li>
  <li>
    As a result of the check, the type becomes more specific (smaller) and is either <code>null</code> or <code>string</code>. That process is called <em>narrowing</em>.
  </li>
</ul>
<p>In this chapter, we explore type guards and narrowing.</p>
<h3 id="type-guards-and-narrowing-1"><a class="heading-id-link" href="#type-guards-and-narrowing-1">30.1 Type guards and narrowing</a></h3>
<h4 id="example-a-type-guard-with"><a class="heading-id-link" href="#example-a-type-guard-with">30.1.1 Example: a type guard with <code>===</code></a></h4>
<p>This is a first example:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">nameOpt: <span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span> {</code>
<code>  <span class="hljs-keyword">if</span> (nameOpt === <span class="hljs-literal">null</span>) { <span class="hljs-comment">// (A)</span></code>
<code>    assertType&lt;<span class="hljs-literal">null</span>&gt;(nameOpt); <span class="hljs-comment">// (B)</span></code>
<code>    nameOpt = <span class="hljs-string">'anonymous'</span>; <span class="hljs-comment">// (C)</span></code>
<code>    assertType&lt;<span class="hljs-built_in">string</span>&gt;(nameOpt);</code>
<code>  } <span class="hljs-keyword">else</span> {</code>
<code>    assertType&lt;<span class="hljs-built_in">string</span>&gt;(nameOpt);</code>
<code>  }</code>
<code>  assertType&lt;<span class="hljs-built_in">string</span>&gt;(nameOpt); <span class="hljs-comment">// (D)</span></code>
<code>  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">${nameOpt}</span>!`</span>;</code>
<code>}</code>
</pre>
<p>The initial type of <code>nameOpt</code>, <code>null | string</code> is too general:</p>
<ul>
  <li>
    Before we can work with it, we need to <em>narrow</em> it – make it more specific.
  </li>
  <li>
    We achieve that via the <code>if</code> statement in line A. Its condition is called a <em>type guard</em>: an expression with a boolean result that examines the type of <code>nameOpt</code>.
  </li>
</ul>
<p>In line B, we can see that the <code>if</code> statement with the type guard did indeed narrow the type of <code>nameOpt</code> inside the if-branch: At its start, it is <code>null</code>. We can also see that in the else-branch, the type of <code>nameOpt</code> is <code>string</code>.</p>
<p>The assignment in line C also changes the type of <code>nameOpt</code>. It doesn’t narrow its previous type, it narrows its original type.</p>
<p><strong>Control flow analysis.</strong> After both branches of <code>if</code> (in line D), the type of <code>nameOpt</code> is <code>string</code> because that’s what its type is at the end of both branches. So TypeScript traces what happens in both branches and adjusts the type accordingly. This kind of tracing is called <em>control flow analysis</em>.</p>
<p><strong>The effect of a type guard is static and dynamic.</strong> It’s interesting that a type guard is always tied to a value that exists at runtime. Its has an effect at the type level and at the JavaScript level.</p>
<p><strong>Narrowing produces subsets of types.</strong> In this chapter, we interpret types as sets of values, as explained in <a href="ch_what-is-a-type.html#ch_what-is-a-type">“What is a type in TypeScript? Two perspectives” (§13)</a>. Narrowing makes a type smaller: We go from a set of values to a proper subset.</p>
<h4 id="example-a-type-guard-with-typeof"><a class="heading-id-link" href="#example-a-type-guard-with-typeof">30.1.2 Example: a type guard with <code>typeof</code></a></h4>
<p>In the following example, we use <code>typeof</code> in a type guard:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">getScore</span>(<span class="hljs-params">value: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> {</code>
<code>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'number'</span>) { <span class="hljs-comment">// (A)</span></code>
<code>    assertType&lt;<span class="hljs-built_in">number</span>&gt;(value);</code>
<code>    <span class="hljs-keyword">return</span> value;</code>
<code>  }</code>
<code>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'string'</span>) { <span class="hljs-comment">// (B)</span></code>
<code>    assertType&lt;<span class="hljs-built_in">string</span>&gt;(value);</code>
<code>    <span class="hljs-keyword">return</span> value.<span class="hljs-property">length</span>;</code>
<code>  }</code>
<code>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Unexpected value: '</span> + value);</code>
<code>}</code>
<code/>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">getScore</span>(<span class="hljs-string">'*****'</span>), <span class="hljs-number">5</span></code>
<code>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">getScore</span>(<span class="hljs-number">3</span>), <span class="hljs-number">3</span></code>
<code>);</code>
</pre>
<p>In this example, there are two type guards: one in line A and one in line B.</p>
<h3 id="when-do-we-need-to-narrow-types"><a class="heading-id-link" href="#when-do-we-need-to-narrow-types">30.2 When do we need to narrow types?</a></h3>
<p>These are examples of types being too general:</p>
<ul>
  <li>
    <p>Nullable types:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params">arg: <span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span></span>) {}</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">func2</span>(<span class="hljs-params">arg: <span class="hljs-literal">undefined</span> | <span class="hljs-built_in">string</span></span>) {}</code>
</pre>
  </li>
  <li>
    <p><a href="ch_unions-object-types.html#discriminated-unions">Discriminated unions</a>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Teacher</span> = { <span class="hljs-attr">kind</span>: <span class="hljs-string">'Teacher'</span>, <span class="hljs-attr">teacherId</span>: <span class="hljs-built_in">string</span> };</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Student</span> = { <span class="hljs-attr">kind</span>: <span class="hljs-string">'Student'</span>, <span class="hljs-attr">studentId</span>: <span class="hljs-built_in">string</span> };</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Attendee</span> = <span class="hljs-title class_">Teacher</span> | <span class="hljs-title class_">Student</span>;</code>
<code/>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">func3</span>(<span class="hljs-params">attendee: Attendee</span>) {}</code>
</pre>
  </li>
  <li>
    <p>Types of optional parameters:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">func4</span>(<span class="hljs-params">arg?: <span class="hljs-built_in">string</span></span>) {</code>
<code>  assertType&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>&gt;(arg);</code>
<code>}</code>
</pre>
  </li>
</ul>
<p>Note that these types are all union types!</p>
<h4 id="the-type-unknown-is-usually-too-general"><a class="heading-id-link" href="#the-type-unknown-is-usually-too-general">30.2.1 The type <code>unknown</code> is usually too general</a></h4>
<p>If a value has <a href="ch_any-unknown.html#ch_any-unknown">the type <code>unknown</code></a>, we can do almost nothing with it and have to narrow its type first (line A):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">parseStringLiteral</span>(<span class="hljs-params">stringLiteral: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span> {</code>
<code>  <span class="hljs-comment">// We use `unknown` instead of the less-safe `any`</span></code>
<code>  <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">unknown</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(stringLiteral);</code>
<code>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'string'</span>) { <span class="hljs-comment">// (A)</span></code>
<code>    <span class="hljs-keyword">return</span> result;</code>
<code>  }</code>
<code>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Not a string literal: '</span> + stringLiteral);</code>
<code>}</code>
</pre>
<p>In other words: The type <code>unknown</code> is too general and we must narrow it. In a way, <code>unknown</code> is also a union type – the union of all types.</p>
<h3 id="where-can-we-use-type-guards"><a class="heading-id-link" href="#where-can-we-use-type-guards">30.3 Where can we use type guards?</a></h3>
<p>In <code>if</code> statements:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">value: <span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {</code>
<code>    assertType&lt;<span class="hljs-literal">null</span>&gt;(value);</code>
<code>  } <span class="hljs-keyword">else</span> {</code>
<code>    assertType&lt;<span class="hljs-built_in">string</span>&gt;(value);</code>
<code>  }</code>
<code>}</code>
</pre>
<p>In conditional expressions:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">value: <span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">const</span> result = value === <span class="hljs-literal">null</span></code>
<code>    ? assertType&lt;<span class="hljs-literal">null</span>&gt;(value)</code>
<code>    : assertType&lt;<span class="hljs-built_in">string</span>&gt;(value)</code>
<code>  ;</code>
<code>}</code>
</pre>
<p>In <code>switch</code> statements:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">value: <span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">typeof</span> value) {</code>
<code>    <span class="hljs-keyword">case</span> <span class="hljs-string">'object'</span>:</code>
<code>      assertType&lt;<span class="hljs-literal">null</span>&gt;(value);</code>
<code>      <span class="hljs-keyword">break</span>;</code>
<code>    <span class="hljs-keyword">case</span> <span class="hljs-string">'string'</span>:</code>
<code>      assertType&lt;<span class="hljs-built_in">string</span>&gt;(value);</code>
<code>      <span class="hljs-keyword">break</span>;</code>
<code>  }</code>
<code>}</code>
</pre>
<h4 id="type-guards-can-also-affect-parts-of-expressions"><a class="heading-id-link" href="#type-guards-can-also-affect-parts-of-expressions">30.3.1 Type guards can also affect parts of expressions</a></h4>
<p>If the left-hand side of the logical And operator (<code>&amp;&amp;</code>) is a type guard then it affects its right-hand side (which may contain more uses of <code>&amp;&amp;</code>):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">value: <span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">if</span> (value !== <span class="hljs-literal">null</span> &amp;&amp; value.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {</code>
<code>    <span class="hljs-comment">// ...</span></code>
<code>  }</code>
<code>}</code>
</pre>
<p>The <code>&amp;&amp;</code> operator stops evaluating if its left-hand side is falsy. Therefore, if we reach the right-hand side, we can be sure that <code>value !== null</code> is true – which is why we can access <code>value.length</code>.</p>
<p>With the logical Or operator (<code>||</code>), we get a related effect:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">value: <span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span> || value.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {</code>
<code>    <span class="hljs-comment">// ...</span></code>
<code>  }</code>
<code>}</code>
</pre>
<p>The <code>||</code> operator stops evaluating if its left-hand side is truthy. Therefore, if we reach the right-hand side, we can be sure that <code>value === null</code> is false – which is why we can access <code>value.length</code>.</p>
<h3 id="what-kinds-of-type-guards-are-built-in"><a class="heading-id-link" href="#what-kinds-of-type-guards-are-built-in">30.4 What kinds of type guards are built-in?</a></h3>
<p>In this section we explore TypeScript’s built-in type guards (expressions that evaluate to <code>true</code> or <code>false</code>).</p>
<h4 id="typeof-instanceof-array-isarray"><a class="heading-id-link" href="#typeof-instanceof-array-isarray">30.4.1 <code>typeof</code>, <code>instanceof</code>, <code>Array.isArray</code></a></h4>
<p>These are three common built-in type guards:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">value: <span class="hljs-built_in">Function</span> | <span class="hljs-built_in">Date</span> | <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt;</span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'function'</span>) {</code>
<code>    assertType&lt;<span class="hljs-title class_">Function</span>&gt;(value);</code>
<code>  }</code>
<code/>
<code>  <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>) {</code>
<code>    assertType&lt;<span class="hljs-title class_">Date</span>&gt;(value);</code>
<code>  }</code>
<code/>
<code>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)) {</code>
<code>    assertType&lt;<span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt;&gt;(value);</code>
<code>  }</code>
<code>}</code>
</pre>
<h4 id="strict-equality-and-strict-inequality"><a class="heading-id-link" href="#strict-equality-and-strict-inequality">30.4.2 Strict equality (<code>===</code>) and strict inequality(<code>!==</code>)</a></h4>
<p>Strict equality can be used in a type guard:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span></span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">if</span> (value === <span class="hljs-string">'abc'</span>) {</code>
<code>    assertType&lt;<span class="hljs-string">"abc"</span>&gt;(value);</code>
<code>  }</code>
<code>}</code>
</pre>
<p>If an element of a union type is a singleton type (with a single value) then we can use <code>===</code> and <code>!==</code> to narrow:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Book</span> {</code>
<code>  <span class="hljs-attr">title</span>: <span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span>;</code>
<code>  <span class="hljs-attr">isbn</span>: <span class="hljs-built_in">string</span>;</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">getTitle</span>(<span class="hljs-params">book: Book</span>): <span class="hljs-built_in">string</span> {</code>
<code>  <span class="hljs-keyword">if</span> (book.<span class="hljs-property">title</span> !== <span class="hljs-literal">null</span>) {</code>
<code>    assertType&lt;<span class="hljs-built_in">string</span>&gt;(book.<span class="hljs-property">title</span>);</code>
<code>    <span class="hljs-keyword">return</span> book.<span class="hljs-property">title</span>;</code>
<code>  }</code>
<code>  <span class="hljs-keyword">if</span> (book.<span class="hljs-property">title</span> === <span class="hljs-literal">null</span>) {</code>
<code>    assertType&lt;<span class="hljs-literal">null</span>&gt;(book.<span class="hljs-property">title</span>);</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-string">'(Untitled)'</span>;</code>
<code>  }</code>
<code>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();</code>
<code>}</code>
</pre>
<p><code>null</code> is a singleton type whose only member is the value <code>null</code>.</p>
<h4 id="truthiness-checks"><a class="heading-id-link" href="#truthiness-checks">30.4.3 Truthiness checks</a></h4>
<h5 id="truthiness-checks-via-if"><a class="heading-id-link" href="#truthiness-checks-via-if">30.4.3.1 Truthiness checks via <code>if</code></a></h5>
<p>Truthiness checks are related to equality checks. They also act as type guards:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">value: <span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">if</span> (value) {</code>
<code>    assertType&lt;<span class="hljs-built_in">string</span>&gt;(value);</code>
<code>  } <span class="hljs-keyword">else</span> {</code>
<code>    assertType&lt;<span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span>&gt;(value); <span class="hljs-comment">// (A)</span></code>
<code>  }</code>
<code>}</code>
</pre>
<p>At first glance, we may think that all strings go to the if-branch while all nulls go to the else-branch. Alas, that’s not the case:</p>
<ul>
  <li>
    Then-branch: <code>value</code> is neither <code>null</code> nor the empty string.
  </li>
  <li>
    Else-branch: <code>value</code> is either <code>null</code> or the empty string. That explains the type in line A.
  </li>
</ul>
<h5 id="recommendation-avoid-truthiness-checks"><a class="heading-id-link" href="#recommendation-avoid-truthiness-checks">30.4.3.2 Recommendation: avoid truthiness checks</a></h5>
<p>Truthiness is problematic, because it rejects non-nullish values such as empty strings, zero, etc. And TypeScript has no types to express “non-empty string”, “non-zero number”, etc.</p>
<p>That’s why I recommend to avoid it – code that uses it is more difficult to understand. Instead, we can use <code>===</code> and <code>!==</code> for more explicit checks. With an explicit check, the previous example becomes less confusing:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">value: <span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">if</span> (value !== <span class="hljs-literal">null</span>) {</code>
<code>    assertType&lt;<span class="hljs-built_in">string</span>&gt;(value);</code>
<code>  } <span class="hljs-keyword">else</span> {</code>
<code>    assertType&lt;<span class="hljs-literal">null</span>&gt;(value);</code>
<code>  }</code>
<code>}</code>
</pre>
<h5 id="truthiness-checks-via-logical-and-and-logical-or"><a class="heading-id-link" href="#truthiness-checks-via-logical-and-and-logical-or">30.4.3.3 Truthiness checks via logical And (<code>&amp;&amp;</code>) and logical Or (<code>||</code>)</a></h5>
<p>The operators logical And (<code>&amp;&amp;</code>) and logical Or (<code>||</code>) can also perform truthiness checks:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params">value: <span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">if</span> (value &amp;&amp; value.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {</code>
<code>    <span class="hljs-comment">// ...</span></code>
<code>  }</code>
<code>}</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params">value: <span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">if</span> (!value || value.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {</code>
<code>    <span class="hljs-comment">// ...</span></code>
<code>  }</code>
<code>}</code>
</pre>
<h5 id="boolean-cannot-be-used-as-a-type-guard"><a class="heading-id-link" href="#boolean-cannot-be-used-as-a-type-guard">30.4.3.4 <code>Boolean()</code> cannot be used as a type guard</a></h5>
<p>The function <code>Boolean()</code> cannot be used as a type guard:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">value: <span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Boolean</span>(value)) {</code>
<code>    assertType&lt;<span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span>&gt;(value); <span class="hljs-comment">// (A)</span></code>
<code>  }</code>
<code>}</code>
</pre>
<p>Alas, there is no narrowing: In line A, the type of <code>value</code> is not <code>string</code>.</p>
<p>In principle, <code>Boolean()</code> could be turned into a type guard function, but that would would have <a href="https://github.com/microsoft/TypeScript/issues/50387#issuecomment-2037968462">several downsides</a>.</p>
<p>As an alternative to <code>Boolean()</code>, we can use the prefix operator logical Negation (<code>!</code>) twice. That does narrow:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">value: <span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">if</span> (!!value) {</code>
<code>    assertType&lt;<span class="hljs-built_in">string</span>&gt;(value);</code>
<code>  }</code>
<code>}</code>
</pre>
<p>However, both <code>Boolean()</code> and <code>!!</code> are truthiness checks and therefore best avoided.</p>
<h4 id="checking-for-distinct-properties-via-the-operator-in"><a class="heading-id-link" href="#checking-for-distinct-properties-via-the-operator-in">30.4.4 Checking for distinct properties via the operator <code>in</code></a></h4>
<p>The <code>in</code> operator can be used in type guards – to check for distinct properties:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">FirstOrSecond</span> =</code>
<code>  | {<span class="hljs-attr">first</span>: <span class="hljs-built_in">string</span>}</code>
<code>  | {<span class="hljs-attr">second</span>: <span class="hljs-built_in">string</span>}</code>
<code>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">firstOrSecond: FirstOrSecond</span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">if</span> (<span class="hljs-string">'first'</span> <span class="hljs-keyword">in</span> firstOrSecond) {</code>
<code>    assertType&lt;{ <span class="hljs-attr">first</span>: <span class="hljs-built_in">string</span> }&gt;(firstOrSecond);</code>
<code>  }</code>
<code>}</code>
</pre>
<p>Note that the following check would not have worked:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">func2</span>(<span class="hljs-params">firstOrSecond: FirstOrSecond</span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-comment">// @ts-expect-error: Property 'first' does not exist on</span></code>
<code>  <span class="hljs-comment">// type 'FirstOrSecond'. [...]</span></code>
<code>  <span class="hljs-keyword">if</span> (firstOrSecond.<span class="hljs-property">first</span> !== <span class="hljs-literal">undefined</span>) {</code>
<code>    <span class="hljs-comment">// ···</span></code>
<code>  }</code>
<code>}</code>
</pre>
<p>The problem in this case is that, without narrowing, we can’t access property <code>.first</code> of a value whose type is <code>FirstOrSecond</code>.</p>
<h5 id="the-operator-in-also-narrows-to-single-properties"><a class="heading-id-link" href="#the-operator-in-also-narrows-to-single-properties">30.4.4.1 The operator <code>in</code> also narrows to single properties</a></h5>
<p>We can also use <code>in</code> to narrow to a single property:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">obj: <span class="hljs-built_in">object</span></span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">if</span> (<span class="hljs-string">'name'</span> <span class="hljs-keyword">in</span> obj) {</code>
<code>    assertType&lt;<span class="hljs-built_in">object</span> &amp; <span class="hljs-title class_">Record</span>&lt;<span class="hljs-string">'name'</span>, <span class="hljs-built_in">unknown</span>&gt;&gt;(obj);</code>
<code>    <span class="hljs-keyword">const</span> value = obj.<span class="hljs-property">name</span>;</code>
<code>    assertType&lt;<span class="hljs-built_in">unknown</span>&gt;(value);</code>
<code>  }</code>
<code>}</code>
</pre>
<p>This kind of narrowing only works if the left-hand side of the <code>in</code> operator is a string literal (and not, e.g., a variable).</p>
<h4 id="checking-the-value-of-a-shared-property-discriminated-unions"><a class="heading-id-link" href="#checking-the-value-of-a-shared-property-discriminated-unions">30.4.5 Checking the value of a shared property (discriminated unions)</a></h4>
<p>In a <a href="ch_unions-object-types.html#discriminated-unions">discriminated union</a>, the components of a union type have (at least) one property in common whose value is different for each component. Such a property is called a <em>discriminant</em>.</p>
<p>Checking the value of a discriminant is a type guard:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Teacher</span> = { <span class="hljs-attr">kind</span>: <span class="hljs-string">'Teacher'</span>, <span class="hljs-attr">teacherId</span>: <span class="hljs-built_in">string</span> };</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Student</span> = { <span class="hljs-attr">kind</span>: <span class="hljs-string">'Student'</span>, <span class="hljs-attr">studentId</span>: <span class="hljs-built_in">string</span> };</code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Attendee</span> = <span class="hljs-title class_">Teacher</span> | <span class="hljs-title class_">Student</span>;</code>
<code/>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">getId</span>(<span class="hljs-params">attendee: Attendee</span>) {</code>
<code>  <span class="hljs-keyword">switch</span> (attendee.<span class="hljs-property">kind</span>) {</code>
<code>    <span class="hljs-keyword">case</span> <span class="hljs-string">'Teacher'</span>:</code>
<code>      assertType&lt;{ <span class="hljs-attr">kind</span>: <span class="hljs-string">'Teacher'</span>, <span class="hljs-attr">teacherId</span>: <span class="hljs-built_in">string</span> }&gt;(attendee);</code>
<code>      <span class="hljs-keyword">return</span> attendee.<span class="hljs-property">teacherId</span>;</code>
<code>    <span class="hljs-keyword">case</span> <span class="hljs-string">'Student'</span>:</code>
<code>      assertType&lt;{ <span class="hljs-attr">kind</span>: <span class="hljs-string">'Student'</span>, <span class="hljs-attr">studentId</span>: <span class="hljs-built_in">string</span> }&gt;(attendee);</code>
<code>      <span class="hljs-keyword">return</span> attendee.<span class="hljs-property">studentId</span>;</code>
<code>    <span class="hljs-attr">default</span>:</code>
<code>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();</code>
<code>  }</code>
<code>}</code>
</pre>
<p>In the previous example, <code>.kind</code> is a discriminant: Each component of the union type <code>Attendee</code> has this property, with a unique value.</p>
<p>An <code>if</code> statement and equality checks work similarly to a <code>switch</code> statement:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">getId</span>(<span class="hljs-params">attendee: Attendee</span>) {</code>
<code>  <span class="hljs-keyword">if</span> (attendee.<span class="hljs-property">kind</span> === <span class="hljs-string">'Teacher'</span>) {</code>
<code>    assertType&lt;{ <span class="hljs-attr">kind</span>: <span class="hljs-string">'Teacher'</span>, <span class="hljs-attr">teacherId</span>: <span class="hljs-built_in">string</span> }&gt;(attendee);</code>
<code>    <span class="hljs-keyword">return</span> attendee.<span class="hljs-property">teacherId</span>;</code>
<code>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (attendee.<span class="hljs-property">kind</span> === <span class="hljs-string">'Student'</span>) {</code>
<code>    assertType&lt;{ <span class="hljs-attr">kind</span>: <span class="hljs-string">'Student'</span>, <span class="hljs-attr">studentId</span>: <span class="hljs-built_in">string</span> }&gt;(attendee);</code>
<code>    <span class="hljs-keyword">return</span> attendee.<span class="hljs-property">studentId</span>;</code>
<code>  } <span class="hljs-keyword">else</span> {</code>
<code>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();</code>
<code>  }</code>
<code>}</code>
</pre>
<h3 id="narrowing-via-assignment"><a class="heading-id-link" href="#narrowing-via-assignment">30.5 Narrowing via assignment</a></h3>
<h4 id="narrowing-storage-locations-with-explicit-types"><a class="heading-id-link" href="#narrowing-storage-locations-with-explicit-types">30.5.1 Narrowing storage locations with explicit types</a></h4>
<p>Assignment narrows the type of a storage location (such as a variable). If a variable <code>x</code> has an explicit type, we can assign any value of that type to it – which narrows its type:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: <span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span>;</code>
<code><span class="hljs-keyword">type</span> _1 = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-keyword">typeof</span> x,</code>
<code>  <span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span></code>
<code>&gt;&gt;;</code>
<code/>
<code>x = <span class="hljs-string">'a'</span>;</code>
<code><span class="hljs-keyword">type</span> _2 = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-keyword">typeof</span> x,</code>
<code>  <span class="hljs-built_in">string</span></code>
<code>&gt;&gt;;</code>
<code/>
<code>x = <span class="hljs-literal">null</span>;</code>
<code><span class="hljs-keyword">type</span> _3 = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-keyword">typeof</span> x,</code>
<code>  <span class="hljs-literal">null</span></code>
<code>&gt;&gt;;</code>
<code/>
<code><span class="hljs-comment">// @ts-expect-error: Type 'number' is not assignable to type 'string'.</span></code>
<code>x = <span class="hljs-number">1</span>;</code>
</pre>
<p>After we assign a string, the type of <code>x</code> is narrowed to <code>string</code>. After we assign <code>null</code>, the type of <code>x</code> is narrowed to <code>null</code>. At the end, we can see that we must stay within the confines of the type <code>null | string</code> – otherwise, we get an error.</p>
<p>Note that, with type guards, we always narrow the current type, whereas with assignments, we narrow the original type.</p>
<h4 id="narrowing-variables-without-explicit-types"><a class="heading-id-link" href="#narrowing-variables-without-explicit-types">30.5.2 Narrowing variables without explicit types</a></h4>
<p>If <a href="ch_any-unknown.html#noImplicitAny">the compiler option <code>noImplicitAny</code></a> is active (which it is if <code>strict</code> is active) then each storage location must have a type – either an inferred type or an explicitly defined type. The only exception are variables defined via <code>let</code> (<code>var</code> works similarly):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">let</span> x; <span class="hljs-comment">// implicitly has type `any`</span></code>
<code><span class="hljs-keyword">type</span> _1 = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-keyword">typeof</span> x, <span class="hljs-comment">// (A)</span></code>
<code>  <span class="hljs-literal">undefined</span></code>
<code>&gt;&gt;;</code>
<code>x = <span class="hljs-number">1</span>;</code>
<code><span class="hljs-keyword">type</span> _2 = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-keyword">typeof</span> x,</code>
<code>  <span class="hljs-built_in">number</span></code>
<code>&gt;&gt;;</code>
<code>x = <span class="hljs-string">'a'</span>;</code>
<code><span class="hljs-keyword">type</span> _3 = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-keyword">typeof</span> x,</code>
<code>  <span class="hljs-built_in">string</span></code>
<code>&gt;&gt;;</code>
<code>x = <span class="hljs-literal">true</span>;</code>
<code><span class="hljs-keyword">type</span> _4 = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-keyword">typeof</span> x,</code>
<code>  <span class="hljs-built_in">boolean</span></code>
<code>&gt;&gt;;</code>
</pre>
<p><code>x</code> initially has the implicit type <code>any</code>. In line A, we observe its type, which is why its type is narrowed to <code>undefined</code>. There are no restrictions with regard to what we can assign. Each time, the type is narrowed accordingly. There are no restrictions because we always narrow the original type of <code>x</code>: <a href="ch_any-unknown.html#ch_any-unknown">the top type <code>any</code></a>.</p>
<p>If we initialize a <code>let</code> variable with a value then it does not have the implicit type <code>any</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-keyword">typeof</span> x,</code>
<code>  <span class="hljs-built_in">number</span></code>
<code>&gt;&gt;;</code>
<code><span class="hljs-comment">// @ts-expect-error: Type 'string' is not assignable to type 'number'.</span></code>
<code>x = <span class="hljs-string">'a'</span>;</code>
</pre>
<h3 id="for-which-storage-locations-can-we-use-type-narrowing"><a class="heading-id-link" href="#for-which-storage-locations-can-we-use-type-narrowing">30.6 For which storage locations can we use type-narrowing?</a></h3>
<h4 id="narrowing-the-types-of-dotted-names"><a class="heading-id-link" href="#narrowing-the-types-of-dotted-names">30.6.1 Narrowing the types of dotted names</a></h4>
<p>We can narrow the types of properties (even of nested ones that we access via chains of property names):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyType</span> = {</code>
<code>  prop?: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>,</code>
<code>};</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">arg: MyType</span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> arg.<span class="hljs-property">prop</span> === <span class="hljs-string">'string'</span>) {</code>
<code>    assertType&lt;<span class="hljs-built_in">string</span>&gt;(arg.<span class="hljs-property">prop</span>); <span class="hljs-comment">// (A)</span></code>
<code/>
<code>    [].<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> {</code>
<code>      assertType&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>&gt;(arg.<span class="hljs-property">prop</span>); <span class="hljs-comment">// (B)</span></code>
<code>    });</code>
<code/>
<code>    assertType&lt;<span class="hljs-built_in">string</span>&gt;(arg.<span class="hljs-property">prop</span>);</code>
<code/>
<code>    arg = {};</code>
<code>    assertType&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>&gt;(arg.<span class="hljs-property">prop</span>); <span class="hljs-comment">// (C)</span></code>
<code>  }</code>
<code>}</code>
</pre>
<p>Let’s take a look at several locations in the previous code:</p>
<ul>
  <li>
    Line A: We narrowed the type of <code>arg.prop</code> via a type guard.
  </li>
  <li>
    Line B: Callbacks may be executed much later (think of asynchronous code), which is why TypeScript undoes narrowing inside callbacks.
  </li>
  <li>
    Line C: The preceding assignment also undid narrowing.
  </li>
</ul>
<h4 id="narrowing-array-element-types"><a class="heading-id-link" href="#narrowing-array-element-types">30.6.2 Narrowing Array element types</a></h4>
<h5 id="the-array-method-every-narrows"><a class="heading-id-link" href="#the-array-method-every-narrows">30.6.2.1 The Array method <code>.every()</code> narrows</a></h5>
<p>We can use method <code>.every()</code> to narrow the type of Array elements:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">mixedValues: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-literal">undefined</span> | <span class="hljs-literal">null</span> | <span class="hljs-built_in">number</span>&gt;</span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">if</span> (mixedValues.<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x !== <span class="hljs-literal">undefined</span> &amp;&amp; x !== <span class="hljs-literal">null</span>)) {</code>
<code>    assertType&lt;<span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt;&gt;(mixedValues);</code>
<code/>
<code>    <span class="hljs-comment">// @ts-expect-error: Argument of type 'null' is not assignable to</span></code>
<code>    <span class="hljs-comment">// parameter of type 'number'.</span></code>
<code>    mixedValues.<span class="hljs-title function_">push</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// (A)</span></code>
<code>  }</code>
<code>}</code>
</pre>
<p>Interestingly, TypeScript does not allow us to push the value <code>null</code> to <code>mixedValues</code> (line A) after we have narrowed its type to <code>Array&lt;number&gt;</code>.</p>
<h5 id="the-array-method-filter-produces-arrays-with-narrower-types"><a class="heading-id-link" href="#the-array-method-filter-produces-arrays-with-narrower-types">30.6.2.2 The Array method <code>.filter()</code> produces Arrays with narrower types</a></h5>
<p><code>.filter()</code> produces Arrays that have narrower types (i.e., it doesn’t actually narrow existing types):</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> mixedValues = [<span class="hljs-number">1</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">null</span>];</code>
<code>assertType&lt;(<span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span>)[]&gt;(mixedValues);</code>
<code/>
<code><span class="hljs-keyword">const</span> numbers = mixedValues.<span class="hljs-title function_">filter</span>(</code>
<code>  <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x !== <span class="hljs-literal">undefined</span> &amp;&amp; x !== <span class="hljs-literal">null</span></code>
<code>);</code>
<code>assertType&lt;<span class="hljs-built_in">number</span>[]&gt;(numbers);</code>
<code>assert.<span class="hljs-title function_">deepEqual</span>(</code>
<code>  numbers,</code>
<code>  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]</code>
<code>);</code>
</pre>
<h3 id="user-defined-type-guard-functions"><a class="heading-id-link" href="#user-defined-type-guard-functions">30.7 User-defined type guard functions</a></h3>
<p>TypeScript lets us define our own type guard functions – for example:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">isFunction</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span></span>): value is <span class="hljs-title class_">Function</span> {</code>
<code>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'function'</span>;</code>
<code>}</code>
</pre>
<p>The return type <code>value is Function</code> is a <em>type predicate</em>. It is part of the type signature of <code>isFunction()</code>:</p>
<pre class="language-ts">
<code>assertType&lt;<span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span></span>) =&gt;</span> value is <span class="hljs-title class_">Function</span>&gt;(isFunction);</code>
</pre>
<p>A user-defined type guard function must always return booleans. If <code>isFunction(x)</code> returns <code>true</code>, TypeScript narrows the type of the actual argument <code>x</code> to <code>Function</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">arg: <span class="hljs-built_in">unknown</span></span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isFunction</span>(arg)) {</code>
<code>    assertType&lt;<span class="hljs-title class_">Function</span>&gt;(arg); <span class="hljs-comment">// type is narrowed</span></code>
<code>  }</code>
<code>}</code>
</pre>
<p>Note that TypeScript doesn’t care how we compute the result of a user-defined type guard function. That gives us a lot of freedom w.r.t. the checks we use. For example, we could have implemented <code>isFunction()</code> as follows:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">isFunction</span>(<span class="hljs-params">value: <span class="hljs-built_in">any</span></span>): value is <span class="hljs-title class_">Function</span> {</code>
<code>  <span class="hljs-keyword">try</span> {</code>
<code>    <span class="hljs-title function_">value</span>(); <span class="hljs-comment">// (A)</span></code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</code>
<code>  } <span class="hljs-keyword">catch</span> {</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</code>
<code>  }</code>
<code>}</code>
</pre>
<p>Note that we have to use the type <code>any</code> for the parameter <code>value</code> because the type <code>unknown</code> does not let us make the function call in line A.</p>
<div class="boxout">
  <p><img src="../Images/837806d7ec89826c3784b2e685feb762.png" height="24" class="boxout-icon" alt="Icon “details”" data-original-src="https://exploringjs.com/ts/book/icon/details.svg"/> <strong>Terminology: “type guard function” vs. “type guard”</strong></p>
  <div class="boxout-vspace"/>
  <p>Custom type guard functions are often called custom type guards – even though they are only invoked in type guard expressions (and not type guards themselves).</p>
</div>
<h4 id="example-isnonnullable"><a class="heading-id-link" href="#example-isnonnullable">30.7.1 Example: <code>isNonNullable()</code></a></h4>
<p><a href="ch_intersections-object-types.html#NonNullable">The utility type <code>NonNullable&lt;T&gt;</code></a> removes <code>undefined</code> and <code>null</code> from union types <code>T</code>. In the next example, we use it to define a custom type guard:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> isNonNullable&lt;T&gt;(<span class="hljs-attr">value</span>: T): value is <span class="hljs-title class_">NonNullable</span>&lt;T&gt; {</code>
<code>  <span class="hljs-keyword">return</span> value !== <span class="hljs-literal">undefined</span> &amp;&amp; value !== <span class="hljs-literal">null</span>;</code>
<code>}</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params">arg: <span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span></span>) {</code>
<code>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isNonNullable</span>(arg)) {</code>
<code>    assertType&lt;<span class="hljs-built_in">string</span>&gt;(arg);</code>
<code>  }</code>
<code>}</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params">arg: <span class="hljs-literal">undefined</span> | <span class="hljs-built_in">string</span></span>) {</code>
<code>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isNonNullable</span>(arg)) {</code>
<code>    assertType&lt;<span class="hljs-built_in">string</span>&gt;(arg);</code>
<code>  }</code>
<code>}</code>
</pre>
<h4 id="example-helping-every-with-a-user-defined-type-guard"><a class="heading-id-link" href="#example-helping-every-with-a-user-defined-type-guard">30.7.2 Example: helping <code>.every()</code> with a user-defined type guard</a></h4>
<p>Let’s look at an example where a type guard with <code>.every()</code> doesn’t work properly. We’ll use the following utility type, which is explained in <a href="ch_classes-as-values.html#generic-type-class">“A generic type for constructors: <code>Class&lt;T&gt;</code>” (§23.3)</a>.</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Class</span>&lt;T&gt; = <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">any</span>&gt;) =&gt; T;</code>
</pre>
<p>After the type guard in line A, we’d expect the type of <code>arr</code> to be <code>Array&lt;T&gt;</code>. Alas, that’s not the case:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> f1&lt;T&gt;(<span class="hljs-attr">arr</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">unknown</span>&gt;, <span class="hljs-attr">theClass</span>: <span class="hljs-title class_">Class</span>&lt;T&gt;): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">if</span> (arr.<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x <span class="hljs-keyword">instanceof</span> theClass)) { <span class="hljs-comment">// (A)</span></code>
<code>    assertType&lt;<span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">unknown</span>&gt;&gt;(arr)</code>
<code>  }</code>
<code>}</code>
</pre>
<p>We can fix this issue by turning the check in line A into the user-defined type guard <code>isInstanceOf()</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> f2&lt;T&gt;(<span class="hljs-attr">arr</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">unknown</span>&gt;, <span class="hljs-attr">theClass</span>: <span class="hljs-title class_">Class</span>&lt;T&gt;): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">if</span> (arr.<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-title function_">isInstanceOf</span>(x, theClass))) {</code>
<code>    assertType&lt;<span class="hljs-title class_">Array</span>&lt;T&gt;&gt;(arr)</code>
<code>  }</code>
<code>}</code>
<code><span class="hljs-keyword">function</span> isInstanceOf&lt;T&gt;(<span class="hljs-attr">value</span>: <span class="hljs-built_in">unknown</span>, <span class="hljs-attr">theClass</span>: <span class="hljs-title class_">Class</span>&lt;T&gt;): value is T  {</code>
<code>  <span class="hljs-keyword">return</span> value <span class="hljs-keyword">instanceof</span> theClass;</code>
<code>}</code>
</pre>
<h4 id="this-based-type-guards"><a class="heading-id-link" href="#this-based-type-guards">30.7.3 <code>this</code>-based type guards</a></h4>
<p>In locations where we can use the type <code>this</code>, we can implement type guards that use that type (line A and line B)</p>
<pre class="language-ts">
<code><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> {</code>
<code>  <span class="hljs-title function_">isCircle</span>(): <span class="hljs-variable language_">this</span> is <span class="hljs-title class_">Circle</span> { <span class="hljs-comment">// (A)</span></code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Circle</span>;</code>
<code>  }</code>
<code>  <span class="hljs-title function_">isRectangle</span>(): <span class="hljs-variable language_">this</span> is <span class="hljs-title class_">Rectangle</span> { <span class="hljs-comment">// (B)</span></code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Rectangle</span>;</code>
<code>  }</code>
<code>}</code>
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Shape</span> {</code>
<code>  center = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>();</code>
<code>  radius = <span class="hljs-number">0</span>;</code>
<code>}</code>
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Shape</span> {</code>
<code>  corner1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>();</code>
<code>  corner2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>();</code>
<code>}</code>
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {</code>
<code>  x = <span class="hljs-number">0</span>;</code>
<code>  y = <span class="hljs-number">0</span>;</code>
<code>}</code>
</pre>
<p>The type guards <code>.isCircle()</code> and <code>.isRectangle()</code> enable us to go from the type of the abstract superclass <code>Shape</code> to one of its subclasses – e.g.:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">shape: Shape</span>): <span class="hljs-built_in">void</span> {</code>
<code>  <span class="hljs-keyword">if</span> (shape.<span class="hljs-title function_">isCircle</span>()) {</code>
<code>    assertType&lt;<span class="hljs-title class_">Circle</span>&gt;(shape);</code>
<code>  }</code>
<code>}</code>
</pre>
<h5 id="example-narrowing-the-type-of-a-property"><a class="heading-id-link" href="#example-narrowing-the-type-of-a-property">30.7.3.1 Example: narrowing the type of a property</a></h5>
<p>In the following code, we use a <code>this</code>-based type guard to narrow the type of a property:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">class</span> <span class="hljs-title class_">ValueContainer</span>&lt;T&gt; {</code>
<code>  <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span> | T = <span class="hljs-literal">null</span>;</code>
<code>  <span class="hljs-title function_">hasValue</span>(): <span class="hljs-variable language_">this</span> is { <span class="hljs-attr">value</span>: T } &amp; <span class="hljs-variable language_">this</span> {</code>
<code>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> !== <span class="hljs-literal">null</span>;</code>
<code>  }</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">stringContainer: ValueContainer&lt;<span class="hljs-built_in">string</span>&gt;</span>): <span class="hljs-built_in">void</span> {</code>
<code>  assertType&lt;<span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span>&gt;(stringContainer.<span class="hljs-property">value</span>);</code>
<code>  <span class="hljs-keyword">if</span> (stringContainer.<span class="hljs-title function_">hasValue</span>()) {</code>
<code>    assertType&lt;<span class="hljs-built_in">string</span>&gt;(stringContainer.<span class="hljs-property">value</span>);</code>
<code>  }</code>
<code>}</code>
</pre>
<p>If the type guard <code>.hasValue()</code> returns <code>true</code>, we can be sure that <code>.value</code> is not <code>null</code>. Therefore, we narrow its type accordingly. The <code>&amp; this</code> is not really needed in this case but it ensures that the method still works if we add more properties: It means that we keep all of <code>this</code> but intersect it with a type where <code>.value</code> has a narrower type.</p>
<h4 id="inferred-type-predicates"><a class="heading-id-link" href="#inferred-type-predicates">30.7.4 Inferred type predicates</a></h4>
<p>In some cases, TypeScript can infer a type predicate – e.g.:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-title function_">isNumber</span> = (<span class="hljs-params">x: <span class="hljs-built_in">unknown</span></span>) =&gt; <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">'number'</span>;</code>
<code>assertType&lt;</code>
<code>  <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">unknown</span></span>) =&gt;</span> x is <span class="hljs-built_in">number</span></code>
<code>&gt;(isNumber);</code>
<code/>
<code><span class="hljs-keyword">const</span> isNonNullable = &lt;T&gt;<span class="hljs-function">(<span class="hljs-params">x: T</span>) =&gt;</span> x != <span class="hljs-literal">null</span>;</code>
<code>assertType&lt;</code>
<code>  &lt;T&gt;<span class="hljs-function">(<span class="hljs-params">x: T</span>) =&gt;</span> x is <span class="hljs-title class_">NonNullable</span>&lt;T&gt;</code>
<code>&gt;(isNonNullable);</code>
</pre>
<p>This is why the Array methods <code>.every()</code> and <code>.filter()</code> can narrow Arrays with a callback that is not a type guard.</p>
<p>A type predicate can only be inferred if:</p>
<ul>
  <li>
    No return type is explicitly specified.
  </li>
  <li>
    The function has a single return statement and no implicit returns.
  </li>
  <li>
    The function does not mutate its parameter.
  </li>
  <li>
    The function returns a type guard expression.
  </li>
</ul>
<p>No type predicate is inferred for truthiness checks:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-title function_">isTruthy</span> = (<span class="hljs-params">x: <span class="hljs-built_in">unknown</span></span>) =&gt; !!x;</code>
<code>assertType&lt;</code>
<code>  <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">unknown</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span></code>
<code>&gt;(isTruthy);</code>
</pre>
<h4 id="advanced-example-user-defined-type-guard-istypeof"><a class="heading-id-link" href="#advanced-example-user-defined-type-guard-istypeof">30.7.5 Advanced example: user-defined type guard <code>isTypeOf()</code></a></h4>
<p>Let’s turn the JavaScript operator <code>typeof</code> into the user-defined type guard <code>isTypeOf()</code> – while fixing the following <code>typeof</code> bug (<code>null</code> should produce the result <code>'null'</code>):</p>
<pre class="language-node-repl">
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span></span></code>
<code>'object'</code>
<code><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-keyword">typeof</span> {}</span></code>
<code>'object'</code>
</pre>
<p>This is what using <code>isTypeOf()</code> looks like:</p>
<pre class="language-ts">
<code><span class="hljs-comment">//===== Using isTypeOf() at the JavaScript level =====</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">isTypeOf</span>(<span class="hljs-string">'abc'</span>, <span class="hljs-string">'string'</span>), <span class="hljs-literal">true</span></code>
<code>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">isTypeOf</span>(<span class="hljs-number">123</span>, <span class="hljs-string">'string'</span>), <span class="hljs-literal">false</span></code>
<code>);</code>
<code><span class="hljs-comment">// Fix `typeof` bug:</span></code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">isTypeOf</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">'null'</span>), <span class="hljs-literal">true</span></code>
<code>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">isTypeOf</span>({}, <span class="hljs-string">'null'</span>), <span class="hljs-literal">false</span></code>
<code>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">isTypeOf</span>({}, <span class="hljs-string">'object'</span>), <span class="hljs-literal">true</span></code>
<code>);</code>
<code>assert.<span class="hljs-title function_">equal</span>(</code>
<code>  <span class="hljs-title function_">isTypeOf</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">'object'</span>), <span class="hljs-literal">false</span></code>
<code>);</code>
<code/>
<code><span class="hljs-comment">//===== Using isTypeOf() at the type level =====</span></code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span></span>) {</code>
<code>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTypeOf</span>(value, <span class="hljs-string">'string'</span>)) {</code>
<code>    assertType&lt;<span class="hljs-built_in">string</span>&gt;(value);</code>
<code>  }</code>
<code/>
<code>  <span class="hljs-comment">// Fix `typeof` bug:</span></code>
<code>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTypeOf</span>(value, <span class="hljs-string">'object'</span>)) {</code>
<code>    assertType&lt;<span class="hljs-built_in">object</span>&gt;(value);</code>
<code>  }</code>
<code>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTypeOf</span>(value, <span class="hljs-string">'null'</span>)) {</code>
<code>    assertType&lt;<span class="hljs-literal">null</span>&gt;(value);</code>
<code>  }</code>
<code>}</code>
</pre>
<h5 id="implementing-istypeof-via-conditional-types"><a class="heading-id-link" href="#implementing-istypeof-via-conditional-types">30.7.5.1 Implementing <code>isTypeOf()</code> via conditional types</a></h5>
<p>This is a first attempt to implement <code>typeof</code> in TypeScript:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> isTypeOf&lt;</code>
<code>  T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span></code>
<code>&gt;(</code>
<code>  <span class="hljs-attr">value</span>: <span class="hljs-built_in">unknown</span>, <span class="hljs-attr">typeString</span>: T</code>
<code>): value is <span class="hljs-title class_">TypeStringToType</span>&lt;T&gt; {</code>
<code>  <span class="hljs-keyword">switch</span> (typeString) {</code>
<code>    <span class="hljs-keyword">case</span> <span class="hljs-string">'null'</span>:</code>
<code>      <span class="hljs-keyword">return</span> value === <span class="hljs-literal">null</span>;</code>
<code>    <span class="hljs-keyword">case</span> <span class="hljs-string">'object'</span>:</code>
<code>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'object'</span> &amp;&amp; value !== <span class="hljs-literal">null</span>;</code>
<code>    <span class="hljs-attr">default</span>:</code>
<code>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === typeString;</code>
<code>  }</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">TypeStringToType</span>&lt;S <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; =</code>
<code>  S <span class="hljs-keyword">extends</span> <span class="hljs-string">'undefined'</span> ? <span class="hljs-literal">undefined</span> :</code>
<code>  S <span class="hljs-keyword">extends</span> <span class="hljs-string">'null'</span> ? <span class="hljs-literal">null</span> :</code>
<code>  S <span class="hljs-keyword">extends</span> <span class="hljs-string">'boolean'</span> ? <span class="hljs-built_in">boolean</span> :</code>
<code>  S <span class="hljs-keyword">extends</span> <span class="hljs-string">'number'</span> ? <span class="hljs-built_in">number</span> :</code>
<code>  S <span class="hljs-keyword">extends</span> <span class="hljs-string">'bigint'</span> ? <span class="hljs-built_in">bigint</span> :</code>
<code>  S <span class="hljs-keyword">extends</span> <span class="hljs-string">'string'</span> ? <span class="hljs-built_in">string</span> :</code>
<code>  S <span class="hljs-keyword">extends</span> <span class="hljs-string">'symbol'</span> ? <span class="hljs-built_in">symbol</span> :</code>
<code>  S <span class="hljs-keyword">extends</span> <span class="hljs-string">'object'</span> ? <span class="hljs-built_in">object</span> :</code>
<code>  S <span class="hljs-keyword">extends</span> <span class="hljs-string">'function'</span> ? <span class="hljs-title class_">Function</span> :</code>
<code>  <span class="hljs-built_in">never</span></code>
<code>  ;</code>
</pre>
<p>The <a href="ch_computing-with-types-overview.html#generic-types">generic type</a> <code>TypeStringToType</code> uses <a href="ch_conditional-types.html#ch_conditional-types">conditional types</a> to translate from string literal types such as <code>'number'</code> to types such as <code>number</code>.</p>
<h5 id="implementing-istypeof-via-a-type-lookup-table"><a class="heading-id-link" href="#implementing-istypeof-via-a-type-lookup-table">30.7.5.2 Implementing <code>isTypeOf()</code> via a type lookup table</a></h5>
<p>The following solution is similar to the previous one, but this time, we don’t use conditional types to translate from string literal types to types; we use an object literal type as a lookup table:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> isTypeOf&lt;</code>
<code>  T <span class="hljs-keyword">extends</span> keyof <span class="hljs-title class_">TypeofLookupTable</span> <span class="hljs-comment">// (A)</span></code>
<code>&gt;(</code>
<code>  <span class="hljs-attr">value</span>: <span class="hljs-built_in">unknown</span>, <span class="hljs-attr">typeString</span>: T</code>
<code>): value is <span class="hljs-title class_">TypeofLookupTable</span>[T] {</code>
<code>  <span class="hljs-keyword">switch</span> (typeString) {</code>
<code>    <span class="hljs-keyword">case</span> <span class="hljs-string">'null'</span>:</code>
<code>      <span class="hljs-keyword">return</span> value === <span class="hljs-literal">null</span>;</code>
<code>    <span class="hljs-keyword">case</span> <span class="hljs-string">'object'</span>:</code>
<code>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'object'</span> &amp;&amp; value !== <span class="hljs-literal">null</span>;</code>
<code>    <span class="hljs-attr">default</span>:</code>
<code>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === typeString;</code>
<code>  }</code>
<code>}</code>
<code/>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">TypeofLookupTable</span> = {</code>
<code>  <span class="hljs-string">'undefined'</span>: <span class="hljs-literal">undefined</span>,</code>
<code>  <span class="hljs-string">'null'</span>: <span class="hljs-literal">null</span>,</code>
<code>  <span class="hljs-string">'boolean'</span>: <span class="hljs-built_in">boolean</span>,</code>
<code>  <span class="hljs-string">'number'</span>: <span class="hljs-built_in">number</span>,</code>
<code>  <span class="hljs-string">'bigint'</span>: <span class="hljs-built_in">bigint</span>,</code>
<code>  <span class="hljs-string">'string'</span>: <span class="hljs-built_in">string</span>,</code>
<code>  <span class="hljs-string">'symbol'</span>: <span class="hljs-built_in">symbol</span>,</code>
<code>  <span class="hljs-string">'object'</span>: <span class="hljs-built_in">object</span>,</code>
<code>  <span class="hljs-string">'function'</span>: <span class="hljs-title class_">Function</span>,</code>
<code>};</code>
</pre>
<p>The lookup table provides us with a nice benefit: We can restrict the type of <code>typeString</code> to the keys of <code>TypeofLookupTable</code> – which means that we get a compiler error if we make a typo:</p>
<pre class="language-ts">
<code><span class="hljs-comment">// @ts-expect-error: Argument of type '"nmbr"' is not assignable to</span></code>
<code><span class="hljs-comment">// parameter of type 'keyof TypeofLookupTable'.</span></code>
<code><span class="hljs-title function_">isTypeOf</span>(<span class="hljs-number">123</span>, <span class="hljs-string">'nmbr'</span>)</code>
</pre>
<p>(This approach is inspired by code by <a href="https://dev.to/krumpet/generic-type-guard-in-typescript-258l">Ran Lottem</a>.)</p>
<h5 id="implementing-istypeof-via-function-overloading"><a class="heading-id-link" href="#implementing-istypeof-via-function-overloading">30.7.5.3 Implementing <code>isTypeOf()</code> via function overloading</a></h5>
<p>Another option is to use <a href="ch_typing-functions.html#overloading-function-declarations">function overloading</a>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">isTypeOf</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span>, typeString: <span class="hljs-string">'undefined'</span></span>): value is <span class="hljs-literal">undefined</span>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">isTypeOf</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span>, typeString: <span class="hljs-string">'null'</span></span>): value is <span class="hljs-literal">null</span>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">isTypeOf</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span>, typeString: <span class="hljs-string">'boolean'</span></span>): value is <span class="hljs-built_in">boolean</span>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">isTypeOf</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span>, typeString: <span class="hljs-string">'number'</span></span>): value is <span class="hljs-built_in">number</span>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">isTypeOf</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span>, typeString: <span class="hljs-string">'bigint'</span></span>): value is <span class="hljs-built_in">bigint</span>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">isTypeOf</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span>, typeString: <span class="hljs-string">'string'</span></span>): value is <span class="hljs-built_in">string</span>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">isTypeOf</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span>, typeString: <span class="hljs-string">'symbol'</span></span>): value is <span class="hljs-built_in">symbol</span>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">isTypeOf</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span>, typeString: <span class="hljs-string">'object'</span></span>): value is <span class="hljs-built_in">object</span>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">isTypeOf</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span>, typeString: <span class="hljs-string">'function'</span></span>): value is <span class="hljs-title class_">Function</span>;</code>
<code><span class="hljs-keyword">function</span> <span class="hljs-title function_">isTypeOf</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span>, typeString: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> {</code>
<code>  <span class="hljs-keyword">switch</span> (typeString) {</code>
<code>    <span class="hljs-keyword">case</span> <span class="hljs-string">'null'</span>:</code>
<code>      <span class="hljs-keyword">return</span> value === <span class="hljs-literal">null</span>;</code>
<code>    <span class="hljs-keyword">case</span> <span class="hljs-string">'object'</span>:</code>
<code>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'object'</span> &amp;&amp; value !== <span class="hljs-literal">null</span>;</code>
<code>    <span class="hljs-attr">default</span>:</code>
<code>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === typeString;</code>
<code>  }</code>
<code>}</code>
</pre>
<p>(This approach is an idea by <a href="https://twitter.com/spadgos/status/1266839605883666432">Nick Fisher</a>.)</p>

    
      
</body>
</html>