- en: '36 Mapped types {[K in U]: X}'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://exploringjs.com/ts/book/ch_mapped-types.html](https://exploringjs.com/ts/book/ch_mapped-types.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Ad, please don’t block.)
  prefs: []
  type: TYPE_NORMAL
- en: '[36.1 Basic mapped types](#basic-mapped-types)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36.1.1 Example: finite set of keys](#example-finite-set-of-keys)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36.1.2 Index signature vs. mapped type](#index-signature-vs-mapped-type)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36.1.3 Transforming an object type via a mapped type](#transforming-an-object-type-via-a-mapped-type)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36.1.4 Mapping preserves the kind of type (tuple, array, object, etc.)](#mapping-preserves-the-kind-of-type-tuple-array-object-etc)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36.1.5 Example: making an interface asynchronous](#example-making-an-interface-asynchronous)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36.1.6 Example: adding keys to an enum object](#example-adding-keys-to-an-enum-object)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36.2 Changing property keys via key remapping (`as`)](#key-remapping)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36.2.1 If we use key remapping, the result is always an object literal type](#if-we-use-key-remapping-the-result-is-always-an-object-literal-type)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36.3 Filtering properties](#filtering-properties)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36.3.1 Filtering properties via key remapping (`as`)](#filtering-properties-via-key-remapping-as)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36.3.2 Filtering properties by filtering key unions](#filtering-properties-by-filtering-key-unions)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36.3.3 Built-in utility type for keeping properties: `Pick<T, KeysToKeep>`](#built-in-utility-type-for-keeping-properties-pick-t-keystokeep)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36.3.4 Built-in utility type for filtering out properties: `Omit<T, KeysToFilterOut>`](#built-in-utility-type-for-filtering-out-properties-omit-t-keys-to-fil-ter-out)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36.4 Adding and removing modifiers via mapped types](#changing-modifiers-via-mapped-types)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36.4.1 Example: adding the optional modifier (`?`)](#example-adding-the-optional-modifier)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36.4.2 Example: removing the optional modifier (`?`)](#example-removing-the-optional-modifier)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36.4.3 Example: adding the `readonly` modifier](#example-adding-the-readonly-modifier)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36.4.4 Example: removing the `readonly` modifier](#example-removing-the-readonly-modifier)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36.5 Detecting the property modifiers `readonly` and `?` (optional)](#detecting-the-property-modifiers-readonly-and-optional)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36.5.1 Detecting if a property is read-only](#detecting-if-a-property-is-read-only)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36.5.2 Detecting if a property is optional](#detecting-if-a-property-is-optional)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36.6 `Record` is a mapped type](#utility-type-record)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[36.7 Source of this chapter](#source-of-this-chapter)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The most common way of using a mapped type is to produce a new version of an
    input type (usually an object type or a tuple type) by looping over its keys.
  prefs: []
  type: TYPE_NORMAL
- en: '[36.1 Basic mapped types](#basic-mapped-types)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A basic mapped type looks like this (the name `Key` is just an example; we
    can use any identifier):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A mapped type creates an object type. It loops over the elements of `«KeySet»`
    and creates one property per iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Key` is the current element of `«KeySet»`. It determines the property key.
    (There are ways to use a different key or to skip a property. We’ll explore those
    later.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expression after the colon determines the property value and can use `Key`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[36.1.1 Example: finite set of keys](#example-finite-set-of-keys)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following mapped type loops over a finite set of keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[36.1.2 Index signature vs. mapped type](#index-signature-vs-mapped-type)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To understand how an index signature is different from a mapped type, let’s
    first review what an index signature is.
  prefs: []
  type: TYPE_NORMAL
- en: '[36.1.2.1 An index signature represents a potentially infinite set of properties](#an-index-signature-represents-a-potentially-infinite-set-of-properties)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This is an example of an index signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'An index signature represents a potentially infinite set of properties. In
    this case:'
  prefs: []
  type: TYPE_NORMAL
- en: The *binding identifier* `key` is ignored and can be any identifier. It distinguishes
    an index signature from [a property with a computed key](ch_typing-objects.html#computed-property-keys).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each property has a `string` key. The property type must be infinite – e.g.:
    `string`, `number`, `symbol`, a template string literal with an infinite primitive
    type (such as `` `${bigint}` ``)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each property has a value of type `number`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In other words: `StrToNum` is the type of objects, used as dictionaries from
    strings to numbers – e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'More information: [“Index signatures: objects as dictionaries” (§18.7)](ch_typing-objects.html#index-signatures).'
  prefs: []
  type: TYPE_NORMAL
- en: '[36.1.2.2 A mapped type is a type-level function](#a-mapped-type-is-a-type-level-function)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In contrast, a mapped type is a type-level function. It maps property keys
    to an object literal type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note an important difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[K in string]`: `K` is a type variable that can be used after the colon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[x: string]`: `x` doesn’t provide any functionality (it only serves as a syntactic
    marker), but it is similar to a normal variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[36.1.3 Transforming an object type via a mapped type](#transforming-an-object-type-via-a-mapped-type)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The most common use case for a mapped type is transforming an object type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In line A, we used `keyof Obj` to compute the keys of `Obj` and iterate over
    them. We used the [indexed access type](ch_computing-with-types-overview.html#indexed-access-types)
    `Obj[K]` and the generic type `Array` to define the property values.
  prefs: []
  type: TYPE_NORMAL
- en: '[36.1.4 Mapping preserves the kind of type (tuple, array, object, etc.)](#mapping-preserves-the-kind-of-type-tuple-array-object-etc)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The input of a mapped type (tuple, array, object, etc.) determines what the
    output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[36.1.5 Example: making an interface asynchronous](#example-making-an-interface-asynchronous)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The generic type `Asyncify<Intf>` converts the synchronous interface `Intf`
    into an asynchronous interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the definition of `Asyncify`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We use a mapped type to iterate over the properties of `Intf` (line A).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Per property with key `K` we check if the property value `Intf[K]` is a function
    or method (line B).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If yes then we use [the `infer` keyword](ch_infer-keyword.html#ch_infer-keyword)
    to extract the arguments into the type variable `A` and the return type into the
    type variable `R`. We use those variables to create a new property value where
    the return type `R` is wrapped in a Promise (line C).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If no, then the property value is not changed (line D).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[36.1.6 Example: adding keys to an enum object](#example-adding-keys-to-an-enum-object)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following enum object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We’d like to avoid having to redundantly mention `.key`. This is what adding
    them via a function `addKey()` would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s very useful that `addKeys()` does not lose type information: The computed
    type of `tokenDefs` correctly records where property `.description` exists and
    where it doesn’t: TypeScript lets us use `tokenDefs.number.description` (which
    exists) but not `tokenDefs.identifier.description` (which does not exist).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an implementation of `addKeys()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In line A, we use `&` to create an intersection type that has both the properties
    of `T[K]` and `{key: string}`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[36.2 Changing property keys via key remapping (`as`)](#key-remapping)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the key part of a mapped type we can use `as` to change the property key
    of the current property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we use `as` to add an underscore before each property
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In line A, the template literal type `` `_${K}` `` does not work if `K` is a
    symbol. That’s why we intersect `keyof Obj` with `string` and only loop over the
    keys of `Obj` that are strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[36.2.1 If we use key remapping, the result is always an object literal type](#if-we-use-key-remapping-the-result-is-always-an-object-literal-type)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have previously seen that applying a simple mapped type to a tuple produces
    a tuple. That changes if we do key remapping. Then the result is always an object
    literal type – e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This result reflects the actual keys of tuples. Simple map types implicitly
    filter those keys. For more information, see [“Mapping tuples via mapped types”
    (§37.4)](ch_computing-with-tuple-types.html#mapped-types-over-tuples).
  prefs: []
  type: TYPE_NORMAL
- en: '[36.3 Filtering properties](#filtering-properties)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we have only changed property keys or values of object types. In this
    section, we look at filtering properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[36.3.1 Filtering properties via key remapping (`as`)](#filtering-properties-via-key-remapping-as)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The easiest way to filter is via `as`: If we use `never` as a property key
    then the property is omitted from the result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we remove all properties whose values are not strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[36.3.2 Filtering properties by filtering key unions](#filtering-properties-by-filtering-key-unions)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before TypeScript had key remapping via via `as`, we had to filter the union
    with property keys before iterating over it with a mapped type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s redo the previous example without `as`: We want to only keep properties
    of the following type `Obj` whose values are strings.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following generic helper type collects the keys of all properties whose
    values are strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We compute the result in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Line A: First, we create an object where each property key `K` is mapped to:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`K` – if the property value `T[K]` is a string'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`never` – otherwise'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line B: Then we extract all property values of the object we just created.
    The type `never` disappears when we do that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With `KeysOfStrProps`, it’s now easy to implement `KeepStrProps` without `as`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[36.3.3 Built-in utility type for keeping properties: `Pick<T, KeysToKeep>`](#built-in-utility-type-for-keeping-properties-pick-t-keystokeep)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following [built-in utility type](https://github.com/Microsoft/TypeScript/blob/main/src/lib/es5.d.ts)
    lets us create a new object by specifying which properties of an existing object
    type we want to keep:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We keep a subset of the properties of `T` by iterating over a subset `K` of
    its property keys (`keyof T`).
  prefs: []
  type: TYPE_NORMAL
- en: '`Pick` is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[36.3.3.1 Typing a function via `Pick<>`](#typing-a-function-via-pick)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can implement property picking at the JavaScript level (as provided by [the
    Underscore library](https://underscorejs.org/#pick)). Then the utility type `Pick<>`
    helps us with the return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[36.3.3.2 Example: removing the constraint of parameter `K` of `Pick<T, K>`](#PickFreely)'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As we have seen, the parameter `K` of `Pick<T, K>` is constrained to keys of
    `T`. That prevents some useful applications – e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`` `${number}` `` is the type of all stringified numbers (see [“Interpolating
    primitive types into template literals” (§38.2.5)](ch_template-literal-types.html#interpolating-primitive-types-into-template-literals)).
    We’d like to extract all properties whose keys are elements of that type. Alas
    we can’t use `Pick` to do so. This is a version of `Pick` whose parameter `K`
    is not constrained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that the operation `T[P]` only works if `P` is a key of `T`. Therefore,
    the set after `in` must be a subset of `keyof T`. That’s why we used `K & keyof
    T` and not `K`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `PickFreely`, we can extract the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[36.3.4 Built-in utility type for filtering out properties: `Omit<T, KeysToFilterOut>`](#built-in-utility-type-for-filtering-out-properties-omit-t-keys-to-fil-ter-out)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following [built-in utility type](https://github.com/Microsoft/TypeScript/blob/main/src/lib/es5.d.ts)
    lets us create a new object type by specifying which properties of an existing
    object type we want to omit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Explanations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`K extends keyof any` means `K` must be a subset of all possible property keys:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Exclude<keyof T, K>>` means: take the keys of `T` and remove all “values”
    mentioned in `K`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Omit<>` is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[36.4 Adding and removing modifiers via mapped types](#changing-modifiers-via-mapped-types)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In TypeScript, properties can have to kinds of *modifiers*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A property can be optional: modifier `?`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A property can be read-only: modifier `readonly`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can add or remove these modifiers via mapped types.
  prefs: []
  type: TYPE_NORMAL
- en: '[36.4.1 Example: adding the optional modifier (`?`)](#example-adding-the-optional-modifier)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The notation `+?` means: make the current property optional. We can omit the
    `+` but I find it easier to understand what’s going on if it’s there.'
  prefs: []
  type: TYPE_NORMAL
- en: The built-in utility type [`Partial<T>`](https://github.com/Microsoft/TypeScript/blob/main/src/lib/es5.d.ts)
    is equivalent to our generic type `AddOptional` above.
  prefs: []
  type: TYPE_NORMAL
- en: '[36.4.2 Example: removing the optional modifier (`?`)](#example-removing-the-optional-modifier)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The notation `-?` means: make the current property required (non-optional).'
  prefs: []
  type: TYPE_NORMAL
- en: The built-in utility type [`Required<T>`](https://github.com/Microsoft/TypeScript/blob/main/src/lib/es5.d.ts)
    is equivalent to our generic type `RemoveOptional` above.
  prefs: []
  type: TYPE_NORMAL
- en: '[36.4.3 Example: adding the `readonly` modifier](#example-adding-the-readonly-modifier)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The notation `+readonly` means: make the current property read-only. We can
    omit the `+` but I find it easier to understand what’s going on if it’s there.'
  prefs: []
  type: TYPE_NORMAL
- en: The built-in utility type [`Readonly<T>`](https://github.com/Microsoft/TypeScript/blob/main/src/lib/es5.d.ts)
    is equivalent to our generic type `AddReadonly` above.
  prefs: []
  type: TYPE_NORMAL
- en: '[36.4.4 Example: removing the `readonly` modifier](#example-removing-the-readonly-modifier)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The notation `-readonly` means: make the current property mutable (non-read-only).'
  prefs: []
  type: TYPE_NORMAL
- en: There is no built-in utility type that removes `readonly` modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: '[36.5 Detecting the property modifiers `readonly` and `?` (optional)](#detecting-the-property-modifiers-readonly-and-optional)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[36.5.1 Detecting if a property is read-only](#detecting-if-a-property-is-read-only)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is what using a utility type `IsReadonly` would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Alas, implementing `IsReadonly` is complicated: `readonly` currently does not
    affect assignability and cannot be detected via `extends`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The brackets around `T1` and `T2` are needed to [prevent distributivity](ch_conditional-types.html#preventing-distributivity).
  prefs: []
  type: TYPE_NORMAL
- en: 'That means that we need a stricter equality check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The helper type `StrictEqual` is a hack but currently the best technique for
    strictly comparing types. How it works is explained in [“How to check if two types
    are equal?” (§39.3)](ch_testing-types.html#checking-type-equality).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can implement `IsReadonly` (based on [code](https://github.com/microsoft/TypeScript/issues/31581)
    by GitHub user `inad9300`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We compare two objects:'
  prefs: []
  type: TYPE_NORMAL
- en: An object that only contains property `K` of `T` (line A)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same object, with all properties made `readonly` (line B)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the two objects are equal, then making property `K` `readonly` didn’t change
    anything – which means that it is already `readonly`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Related GitHub issue: [“Allow identifying readonly properties in mapped types”](https://github.com/microsoft/TypeScript/issues/31581)'
  prefs: []
  type: TYPE_NORMAL
- en: '[36.5.2 Detecting if a property is optional](#detecting-if-a-property-is-optional)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is what it looks like to use a helper type `IsOptional` that detects if
    a property is optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`IsOptional` is easier to implement than `IsReadonly` because optional properties
    are easier to detect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'How does that work? Let’s look at the results produced by `Pick`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Only the latter object is assignable to the empty object `{}`.
  prefs: []
  type: TYPE_NORMAL
- en: '[36.6 `Record` is a mapped type](#utility-type-record)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The built-in utility type `Record` is simply an alias for a mapped type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, `keyof any` means “valid property key”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'These are results produced by `Record`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[36.7 Source of this chapter](#source-of-this-chapter)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Chapter [“Mapped Types”](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
    in the official TypeScript handbook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
