["```ts\ntype UndefinedLiteralType = undefined;\ntype NullLiteralType = null;\n\ntype BooleanLiteralType = true;\ntype NumericLiteralType = 123;\ntype BigIntLiteralType = 123n; // --target must be ES2020+\ntype StringLiteralType = 'abc';\n```", "```ts\nconst abc: 'abc' = 'abc';\n```", "```ts\n    elem.addEventListener('click', myEventHandler);\n    ```", "```ts\n    type IceCreamFlavor = 'vanilla' | 'chocolate' | 'strawberry';\n    ```", "```ts\nenum NoYesEnum {\n No = 'No',\n Yes = 'Yes',\n}\nfunction toGerman1(value: NoYesEnum): string {\n switch (value) {\n case NoYesEnum.No:\n return 'Nein';\n case NoYesEnum.Yes:\n return 'Ja';\n }\n}\nassert.equal(toGerman1(NoYesEnum.No), 'Nein');\nassert.equal(toGerman1(NoYesEnum.Yes), 'Ja');\n```", "```ts\ntype NoYesStrings = 'No' | 'Yes';\n\nfunction toGerman2(value: NoYesStrings): string {\n switch (value) {\n case 'No':\n return 'Nein';\n case 'Yes':\n return 'Ja';\n }\n}\nassert.equal(toGerman2('No'), 'Nein');\nassert.equal(toGerman2('Yes'), 'Ja');\n```", "```ts\n// @ts-expect-error: Function lacks ending return statement and\n// return type does not include 'undefined'. (2366)\nfunction toGerman3(value: NoYesStrings): string {\n switch (value) {\n case 'Yes':\n return 'Ja';\n }\n}\n```", "```ts\nclass UnsupportedValueError extends Error {\n constructor(value: never) {\n super('Unsupported value: ' + value);\n }\n}\n\nfunction toGerman4(value: NoYesStrings): string {\n switch (value) {\n case 'Yes':\n return 'Ja';\n default:\n // @ts-expect-error: Argument of type '\"No\"' is not\n // assignable to parameter of type 'never'. (2345)\n throw new UnsupportedValueError(value);\n }\n}\n```", "```ts\ntype Spanish = 'no' | 's\u00ed';\ntype English = 'no' | 'yes';\n\nconst spanishWord: Spanish = 'no';\nconst englishWord: English = spanishWord;\n```", "```ts\nenum LogLevel {\n off = 'off',\n info = 'info',\n warn = 'warn',\n error = 'error',\n}\n```", "```ts\nconst off = Symbol('off');\nconst info = Symbol('info');\nconst warn = Symbol('warn');\nconst error = Symbol('error');\n\n// %inferred-type: unique symbol | unique symbol |\n// unique symbol | unique symbol\ntype LogLevel =\n | typeof off\n | typeof info\n | typeof warn\n | typeof error\n;\n```", "```ts\ntype LogLevel = typeof Symbol('off') | \u00b7\u00b7\u00b7\n```", "```ts\n// %inferred-type: unique symbol\nconst constSymbol = Symbol('constSymbol');\n\n// %inferred-type: symbol\nlet letSymbol1 = Symbol('letSymbol1');\n```", "```ts\n// @ts-expect-error: A 'const' assertions can only be applied to references to enum\n// members, or string, number, boolean, array, or object literals. (1355)\nlet letSymbol2 = Symbol('letSymbol2') as const;\n```", "```ts\nfunction getName(logLevel: LogLevel): string {\n switch (logLevel) {\n case off:\n return 'off';\n case info:\n return 'info';\n case warn:\n return 'warn';\n case error:\n return 'error';\n }\n}\n\nassert.equal(\n getName(warn), 'warn');\n```", "```ts\ntype Spanish = 'no' | 's\u00ed';\ntype English = 'no' | 'yes';\n\nconst spanishWord: Spanish = 'no';\nconst englishWord: English = spanishWord;\n```", "```ts\nconst spanishNo = Symbol('no');\nconst spanishS\u00ed = Symbol('s\u00ed');\ntype Spanish = typeof spanishNo | typeof spanishS\u00ed;\n\nconst englishNo = Symbol('no');\nconst englishYes = Symbol('yes');\ntype English = typeof englishNo | typeof englishYes;\n\nconst spanishWord: Spanish = spanishNo;\n// @ts-expect-error: Type 'unique symbol' is not assignable to type 'English'. (2322)\nconst englishWord: English = spanishNo;\n```", "```ts\n1 + 2 + 3\n```", "```ts\n// Abstract = can\u2019t be instantiated via `new`\nabstract class SyntaxTree1 {}\nclass NumberValue1 extends SyntaxTree1 {\n constructor(public numberValue: number) {\n super();\n }\n}\nclass Addition1 extends SyntaxTree1 {\n constructor(public operand1: SyntaxTree1, public operand2: SyntaxTree1) {\n super();\n }\n}\n```", "```ts\nconst tree = new Addition1(\n new NumberValue1(1),\n new Addition1(\n new NumberValue1(2),\n new NumberValue1(3), // trailing comma\n ), // trailing comma\n);\n```", "```ts\nclass NumberValue2 {\n constructor(public numberValue: number) {}\n}\nclass Addition2 {\n constructor(public operand1: SyntaxTree2, public operand2: SyntaxTree2) {}\n}\ntype SyntaxTree2 = NumberValue2 | Addition2; // (A)\n```", "```ts\nconst tree = new Addition2(\n new NumberValue2(1),\n new Addition2(\n new NumberValue2(2),\n new NumberValue2(3),\n ),\n);\n```", "```ts\ninterface NumberValue3 {\n kind: 'number-value';\n numberValue: number;\n}\ninterface Addition3 {\n kind: 'addition';\n operand1: SyntaxTree3;\n operand2: SyntaxTree3;\n}\ntype SyntaxTree3 = NumberValue3 | Addition3;\n```", "```ts\nconst tree: SyntaxTree3 = { // (A)\n kind: 'addition',\n operand1: {\n kind: 'number-value',\n numberValue: 1,\n },\n operand2: {\n kind: 'addition',\n operand1: {\n kind: 'number-value',\n numberValue: 2,\n },\n operand2: {\n kind: 'number-value',\n numberValue: 3,\n },\n }\n};\n```", "```ts\nfunction getNumberValue(tree: SyntaxTree3) {\n // %inferred-type: SyntaxTree3\n tree; // (A)\n\n // @ts-expect-error: Property 'numberValue' does not exist on type 'SyntaxTree3'.\n // Property 'numberValue' does not exist on type 'Addition3'.(2339)\n tree.numberValue; // (B)\n\n if (tree.kind === 'number-value') { // (C)\n // %inferred-type: NumberValue3\n tree; // (D)\n return tree.numberValue; // OK!\n }\n return null;\n}\n```", "```ts\nfunction syntaxTreeToString(tree: SyntaxTree3): string {\n switch (tree.kind) { // (A)\n case 'addition':\n return syntaxTreeToString(tree.operand1)\n + ' + ' + syntaxTreeToString(tree.operand2);\n case 'number-value':\n return String(tree.numberValue);\n }\n}\n\nassert.equal(syntaxTreeToString(tree), '1 + 2 + 3');\n```", "```ts\nabstract class SyntaxTree1 {\n // Abstract = enforce that all subclasses implement this method:\n abstract toString(): string;\n}\nclass NumberValue1 extends SyntaxTree1 {\n constructor(public numberValue: number) {\n super();\n }\n toString(): string {\n return String(this.numberValue);\n }\n}\nclass Addition1 extends SyntaxTree1 {\n constructor(public operand1: SyntaxTree1, public operand2: SyntaxTree1) {\n super();\n }\n toString(): string {\n return this.operand1.toString() + ' + ' + this.operand2.toString();\n }\n}\n\nconst tree = new Addition1(\n new NumberValue1(1),\n new Addition1(\n new NumberValue1(2),\n new NumberValue1(3),\n ),\n);\n\nassert.equal(tree.toString(), '1 + 2 + 3');\n```", "```ts\ntype FileGenerator = (webPath: string) => string;\ntype FileSource1 = string|FileGenerator;\n```", "```ts\ninterface FileSourceFile {\n type: 'FileSourceFile',\n nativePath: string,\n}\ninterface FileSourceGenerator {\n type: 'FileSourceGenerator',\n fileGenerator: FileGenerator,\n}\ntype FileSource2 = FileSourceFile | FileSourceGenerator;\n```", "```ts\ninterface TemperatureCelsius {\n type: 'TemperatureCelsius',\n value: number,\n}\ninterface TemperatureFahrenheit {\n type: 'TemperatureFahrenheit',\n value: number,\n}\ntype Temperature = TemperatureCelsius | TemperatureFahrenheit;\n```", "```ts\nconst Color = {\n red: Symbol('red'),\n green: Symbol('green'),\n blue: Symbol('blue'),\n};\n```", "```ts\n// %inferred-type: symbol\nColor.red; // (A)\n\n// %inferred-type: symbol\ntype TColor2 = // (B)\n | typeof Color.red\n | typeof Color.green\n | typeof Color.blue\n;\n\nfunction toGerman(color: TColor): string {\n switch (color) {\n case Color.red:\n return 'rot';\n case Color.green:\n return 'gr\u00fcn';\n case Color.blue:\n return 'blau';\n default:\n // No exhaustiveness check (inferred type is not `never`):\n // %inferred-type: symbol\n color;\n\n // Prevent static error for return type:\n throw new Error();\n }\n}\n```", "```ts\nassert.equal(\n toGerman(Color.green), 'gr\u00fcn');\nassert.throws(\n () => toGerman(Symbol())); // no static error!\n```", "```ts\nconst ConstColor = {\n red: Symbol('red'),\n green: Symbol('green'),\n blue: Symbol('blue'),\n} as const;\n\n// %inferred-type: symbol\nConstColor.red;\n```", "```ts\nconst red = Symbol('red');\nconst green = Symbol('green');\nconst blue = Symbol('blue');\n\n// %inferred-type: unique symbol\nred;\n\n// %inferred-type: unique symbol | unique symbol | unique symbol\ntype TColor2 = typeof red | typeof green | typeof blue;\n```", "```ts\nconst Color = {\n red: 'red',\n green: 'green',\n blue: 'blue',\n} as const; // (A)\n\n// %inferred-type: \"red\"\nColor.red;\n\n// %inferred-type: \"red\" | \"green\" | \"blue\"\ntype TColor =\n | typeof Color.red\n | typeof Color.green\n | typeof Color.blue\n;\n```", "```ts\nclass Color {\n static red = new Color();\n static green = new Color();\n static blue = new Color();\n}\n\n// @ts-expect-error: Function lacks ending return statement and return type\n// does not include 'undefined'. (2366)\nfunction toGerman(color: Color): string { // (A)\n switch (color) {\n case Color.red:\n return 'rot';\n case Color.green:\n return 'gr\u00fcn';\n case Color.blue:\n return 'blau';\n }\n}\n\nassert.equal(toGerman(Color.blue), 'blau');\n```"]