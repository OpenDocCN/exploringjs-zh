<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>32 Validating external data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>32 Validating external data</h1>
<blockquote>原文：<a href="https://exploringjs.com/ts/book/ch_validating-external-data.html">https://exploringjs.com/ts/book/ch_validating-external-data.html</a></blockquote>

    
        <div id="adbox">
      <div id="adbox-explain">(Ad, please don’t block.)</div>
              
          </div>
    
    
<nav class="local-toc">
  <ol>
    <li>
      <a href="#json-schema">32.1 JSON schema</a>
      <ol>
        <li>
          <a href="#an-example-json-schema">32.1.1 An example JSON schema</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#approaches-for-data-validation-in-typescript">32.2 Approaches for data validation in TypeScript</a>
      <ol>
        <li>
          <a href="#approaches-not-using-json-schema">32.2.1 Approaches not using JSON schema</a>
        </li>
        <li>
          <a href="#approaches-using-json-schema">32.2.2 Approaches using JSON schema</a>
        </li>
        <li>
          <a href="#picking-a-library">32.2.3 Picking a library</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#example-validating-data-via-the-library-zod">32.3 Example: validating data via the library <em>Zod</em></a>
      <ol>
        <li>
          <a href="#defining-a-schema-via-zod-s-builder-api">32.3.1 Defining a “schema” via Zod’s builder API</a>
        </li>
        <li>
          <a href="#validating-data">32.3.2 Validating data</a>
        </li>
        <li>
          <a href="#zod-optional-properties">32.3.3 Tip: Use <code>z.interface()</code> and property keys with question marks for optional properties (Zod 4)</a>
        </li>
        <li>
          <a href="#external-vs-internal-representation-of-data">32.3.4 External vs. internal representation of data</a>
        </li>
      </ol>
    </li>
    <li>
      <a href="#conclusion-various-thoughts-about-data-validation-libraries">32.4 Conclusion: various thoughts about data validation libraries</a>
    </li>
  </ol>
</nav>
<p><em>Data validation</em> means ensuring that data has the desired structure and content.</p>
<p>With TypeScript, validation becomes relevant when we receive external data such as:</p>
<ul>
  <li>
    Data parsed from JSON files
  </li>
  <li>
    Data received from web services
  </li>
</ul>
<p>In these cases, we expect the data to fit static types we have, but we can’t be sure. Contrast that with data we create ourselves, where TypeScript continuously checks that everything is correct.</p>
<p>This chapter explains how to validate external data in TypeScript.</p>
<h3 id="json-schema"><a class="heading-id-link" href="#json-schema">32.1 JSON schema</a></h3>
<p>Before we can explore approaches for data validation in TypeScript, we need to take a look at <em>JSON schema</em> because several of the approaches are based on it.</p>
<p>The idea behind <a href="https://json-schema.org">JSON schema</a> is to express the <em>schema</em> (structure and content, think static type) of JSON data in JSON. That is, metadata is expressed in the same format as data.</p>
<p>The use cases for JSON schema are:</p>
<ul>
  <li>
    <p>Validating JSON data: If we have a schema definition for data, we can use tools to check that the data is correct. One issue with data can also be fixed automatically: We can specify default values that can be used to add properties that are missing.</p>
  </li>
  <li>
    <p>Documenting JSON data formats: On one hand, the core schema definitions can be considered documentation. But JSON schema additionally supports descriptions, deprecation notes, comments, examples, and more. These mechanisms are called <em>annotations</em>. They are not used for validation, but for documentation.</p>
  </li>
</ul>
<ul>
  <li>
    IDE support for editing data: For example, Visual Studio Code supports JSON schema. If there is a schema for a JSON file, we gain several editing features: auto-completion, highlighting of errors, etc. Notably, VS Code’s support for <code>package.json</code> files is completely based on a JSON schema.
  </li>
</ul>
<h4 id="an-example-json-schema"><a class="heading-id-link" href="#an-example-json-schema">32.1.1 An example JSON schema</a></h4>
<p>This example is taken from <a href="https://json-schema.org/learn/miscellaneous-examples.html#describing-geographical-coordinates">the <code>json-schema.org</code> website</a>:</p>
<pre class="language-json">
<code><span class="hljs-punctuation">{</span></code>
<code>  <span class="hljs-attr">"$id"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"https://example.com/geographical-location.schema.json"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"$schema"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"http://json-schema.org/draft-07/schema#"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"title"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Longitude and Latitude Values"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"description"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"A geographical coordinate."</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"required"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">"latitude"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"longitude"</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"object"</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"properties"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>    <span class="hljs-attr">"latitude"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"number"</span><span class="hljs-punctuation">,</span></code>
<code>      <span class="hljs-attr">"minimum"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">-90</span><span class="hljs-punctuation">,</span></code>
<code>      <span class="hljs-attr">"maximum"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">90</span></code>
<code>    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span></code>
<code>    <span class="hljs-attr">"longitude"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span></code>
<code>      <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"number"</span><span class="hljs-punctuation">,</span></code>
<code>      <span class="hljs-attr">"minimum"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">-180</span><span class="hljs-punctuation">,</span></code>
<code>      <span class="hljs-attr">"maximum"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">180</span></code>
<code>    <span class="hljs-punctuation">}</span></code>
<code>  <span class="hljs-punctuation">}</span></code>
<code><span class="hljs-punctuation">}</span></code>
</pre>
<p>The following JSON data is valid w.r.t. this schema:</p>
<pre class="language-json">
<code><span class="hljs-punctuation">{</span></code>
<code>  <span class="hljs-attr">"latitude"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">48.858093</span><span class="hljs-punctuation">,</span></code>
<code>  <span class="hljs-attr">"longitude"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2.294694</span></code>
<code><span class="hljs-punctuation">}</span></code>
</pre>
<h3 id="approaches-for-data-validation-in-typescript"><a class="heading-id-link" href="#approaches-for-data-validation-in-typescript">32.2 Approaches for data validation in TypeScript</a></h3>
<p>This section provides a brief overview of various approaches for validating data in TypeScript. For each approach, I list one or more libraries that support the approach. W.r.t. libraries, I don’t intend to be comprehensive because things change quickly in this space.</p>
<h4 id="approaches-not-using-json-schema"><a class="heading-id-link" href="#approaches-not-using-json-schema">32.2.1 Approaches not using JSON schema</a></h4>
<p>One approach for validation is to create a schema object by invoking builder methods and functions. Such an object enables us to:</p>
<ul>
  <li>
    Check data at runtime.
  </li>
  <li>
    Give data that passes the check the appropriate type at compile time.
  </li>
</ul>
<p>There are many libraries that work like this. Next, we’ll look at a few examples.</p>
<h5 id="zod"><a class="heading-id-link" href="#zod">32.2.1.1 Zod</a></h5>
<p><a href="https://github.com/vriad/zod">Zod</a> (demonstrated in more depth later in this chapter) uses builder methods and is very popular.</p>
<pre class="language-ts">
<code><span class="hljs-keyword">import</span> { z } <span class="hljs-keyword">from</span> <span class="hljs-string">'zod'</span>;</code>
<code/>
<code><span class="hljs-comment">// Define schema</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-title class_">ProductSchema</span> = z.<span class="hljs-title function_">object</span>({</code>
<code>  <span class="hljs-attr">name</span>: z.<span class="hljs-title function_">string</span>().<span class="hljs-title function_">min</span>(<span class="hljs-number">1</span>), <span class="hljs-comment">// non-empty</span></code>
<code>  <span class="hljs-attr">scores</span>: z.<span class="hljs-title function_">array</span>(</code>
<code>    z.<span class="hljs-title function_">union</span>([ z.<span class="hljs-title function_">number</span>(), z.<span class="hljs-title function_">string</span>() ])</code>
<code>  ),</code>
<code>});</code>
<code/>
<code><span class="hljs-comment">// Derive TypeScript type from schema</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Product</span> = z.<span class="hljs-property">infer</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">ProductSchema</span>&gt;;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Product</span>,</code>
<code>  {</code>
<code>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,</code>
<code>    <span class="hljs-attr">scores</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>&gt;,</code>
<code>  }</code>
<code>&gt;&gt;;</code>
<code/>
<code><span class="hljs-comment">// Validate data</span></code>
<code><span class="hljs-keyword">const</span> product = <span class="hljs-title class_">ProductSchema</span>.<span class="hljs-title function_">parse</span>({</code>
<code>  <span class="hljs-attr">name</span>: <span class="hljs-string">'Toothpaste'</span>,</code>
<code>  <span class="hljs-attr">scores</span>: [ <span class="hljs-number">5</span>, <span class="hljs-string">'*****'</span> ],</code>
<code>});</code>
<code>assertType&lt;<span class="hljs-title class_">Product</span>&gt;(product);</code>
</pre>
<h5 id="valibot"><a class="heading-id-link" href="#valibot">32.2.1.2 Valibot</a></h5>
<p><a href="https://github.com/fabian-hiller/valibot">Valibot</a> is similar to Zod but uses functions, which helps with excluding unused code from bundles.</p>
<pre class="language-ts">
<code><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> v <span class="hljs-keyword">from</span> <span class="hljs-string">'valibot'</span>;</code>
<code/>
<code><span class="hljs-comment">// Define schema</span></code>
<code><span class="hljs-keyword">const</span> <span class="hljs-title class_">ProductSchema</span> = v.<span class="hljs-title function_">object</span>({</code>
<code>  <span class="hljs-attr">name</span>: v.<span class="hljs-title function_">pipe</span>(v.<span class="hljs-title function_">string</span>(), v.<span class="hljs-title function_">minLength</span>(<span class="hljs-number">1</span>)), <span class="hljs-comment">// non-empty</span></code>
<code>  <span class="hljs-attr">scores</span>: v.<span class="hljs-title function_">array</span>(</code>
<code>    v.<span class="hljs-title function_">union</span>([ v.<span class="hljs-title function_">number</span>(), v.<span class="hljs-title function_">string</span>() ])</code>
<code>  ),</code>
<code>});</code>
<code/>
<code><span class="hljs-comment">// Derive TypeScript type from schema</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Product</span> = v.<span class="hljs-property">InferOutput</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">ProductSchema</span>&gt;;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Product</span>,</code>
<code>  {</code>
<code>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,</code>
<code>    <span class="hljs-attr">scores</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>&gt;,</code>
<code>  }</code>
<code>&gt;&gt;;</code>
<code/>
<code><span class="hljs-comment">// Validate data</span></code>
<code><span class="hljs-keyword">const</span> product = v.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">ProductSchema</span>, {</code>
<code>  <span class="hljs-attr">name</span>: <span class="hljs-string">'Toothpaste'</span>,</code>
<code>  <span class="hljs-attr">scores</span>: [ <span class="hljs-number">5</span>, <span class="hljs-string">'*****'</span> ],</code>
<code>});</code>
<code>assertType&lt;<span class="hljs-title class_">Product</span>&gt;(product);</code>
</pre>
<h5 id="arktype"><a class="heading-id-link" href="#arktype">32.2.1.3 ArkType</a></h5>
<p><a href="https://github.com/arktypeio/arktype">ArkType</a> has a distinct way of specifying types: Instead of function or method invocations, it often uses string literal types (parsed via template literal types at compile time).</p>
<pre class="language-ts">
<code><span class="hljs-keyword">import</span> { <span class="hljs-keyword">type</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'arktype'</span>;</code>
<code/>
<code><span class="hljs-comment">// Define schema</span></code>
<code><span class="hljs-keyword">const</span> productSchema = <span class="hljs-title function_">type</span>({</code>
<code>  <span class="hljs-attr">name</span>: <span class="hljs-string">'string &gt; 0'</span>, <span class="hljs-comment">// non-empty</span></code>
<code>  <span class="hljs-attr">scores</span>: <span class="hljs-string">'(number | string)[]'</span>,</code>
<code>});</code>
<code/>
<code><span class="hljs-comment">// Derive TypeScript type from schema</span></code>
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Product</span> = <span class="hljs-keyword">typeof</span> productSchema.<span class="hljs-property">infer</span>;</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  <span class="hljs-title class_">Product</span>,</code>
<code>  {</code>
<code>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,</code>
<code>    <span class="hljs-attr">scores</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>&gt;,</code>
<code>  }</code>
<code>&gt;&gt;;</code>
<code/>
<code><span class="hljs-comment">// Validate data</span></code>
<code><span class="hljs-keyword">const</span> product = <span class="hljs-title function_">productSchema</span>({</code>
<code>  <span class="hljs-attr">name</span>: <span class="hljs-string">'Toothpaste'</span>,</code>
<code>  <span class="hljs-attr">scores</span>: [ <span class="hljs-number">5</span>, <span class="hljs-string">'*****'</span> ],</code>
<code>});</code>
<code><span class="hljs-keyword">if</span> (product <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">type</span>.<span class="hljs-property">errors</span>) {</code>
<code>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(product.<span class="hljs-property">summary</span>);</code>
<code>} <span class="hljs-keyword">else</span> {</code>
<code>  assertType&lt;<span class="hljs-title class_">Product</span>&gt;(product);</code>
<code>}</code>
</pre>
<h5 id="standard-schema-standard-for-validation-apis"><a class="heading-id-link" href="#standard-schema-standard-for-validation-apis">32.2.1.4 Standard Schema: standard for validation APIs</a></h5>
<p>“<a href="https://standardschema.dev">Standard Schema</a> is a common interface designed to be implemented by JavaScript and TypeScript schema libraries.” Inspired by Zod, supported by many libraries.</p>
<h4 id="approaches-using-json-schema"><a class="heading-id-link" href="#approaches-using-json-schema">32.2.2 Approaches using JSON schema</a></h4>
<ul>
  <li>
    <p>Approach: Converting TypeScript types to JSON schema. Libraries:</p>
    <ul>
      <li>
        <a href="https://github.com/vega/ts-json-schema-generator">ts-json-schema-generator</a>
      </li>
      <li>
        <a href="https://github.com/YousefED/typescript-json-schema">typescript-json-schema</a>
      </li>
    </ul>
  </li>
  <li>
    <p>Approach: Converting a JSON schema to TypeScript types. Libraries:</p>
    <ul>
      <li>
        <a href="https://github.com/quicktype/quicktype">quicktype</a>
      </li>
      <li>
        <a href="https://github.com/bcherny/json-schema-to-typescript">json-schema-to-typescript</a>
      </li>
    </ul>
  </li>
  <li>
    <p>Approach: A builder API creates both TypeScript types and JSON schemas. Library:</p>
    <ul>
      <li>
        <a href="https://github.com/sinclairzx81/typebox">TypeBox</a> (it also validates untyped data in TypeScript code)
      </li>
    </ul>
  </li>
  <li>
    <p>Approach: Validating JSON data via JSON schemas. This functionality is also useful for the other approaches. npm package:</p>
    <ul>
      <li>
        <a href="https://github.com/ajv-validator/ajv">Ajv JSON schema validator</a>
      </li>
    </ul>
  </li>
</ul>
<h4 id="picking-a-library"><a class="heading-id-link" href="#picking-a-library">32.2.3 Picking a library</a></h4>
<p>Which approach and therefore library to use, depends on what we need:</p>
<ul>
  <li>
    <p>If we are starting with TypeScript types and want to ensure that data (coming from configuration files, etc.) fits those types, then builder APIs that support static types are a good choice.</p>
  </li>
  <li>
    <p>If our starting point is a JSON schema, then we should consider one of the libraries that support JSON schemas.</p>
  </li>
</ul>
<h3 id="example-validating-data-via-the-library-zod"><a class="heading-id-link" href="#example-validating-data-via-the-library-zod">32.3 Example: validating data via the library <em>Zod</em></a></h3>
<h4 id="defining-a-schema-via-zod-s-builder-api"><a class="heading-id-link" href="#defining-a-schema-via-zod-s-builder-api">32.3.1 Defining a “schema” via Zod’s builder API</a></h4>
<p>Zod has a builder API that produces both types and validation functions. That API is used as follows:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> z <span class="hljs-keyword">from</span> <span class="hljs-string">'zod'</span>;</code>
<code/>
<code><span class="hljs-keyword">const</span> <span class="hljs-title class_">FileEntryInputSchema</span> = z.<span class="hljs-title function_">union</span>([</code>
<code>  z.<span class="hljs-title function_">string</span>(),</code>
<code>  z.<span class="hljs-title function_">tuple</span>([z.<span class="hljs-title function_">string</span>(), z.<span class="hljs-title function_">string</span>(), z.<span class="hljs-title function_">array</span>(z.<span class="hljs-title function_">string</span>())]),</code>
<code>  z.<span class="hljs-title function_">interface</span>({</code>
<code>    <span class="hljs-attr">file</span>: z.<span class="hljs-title function_">string</span>(),</code>
<code>    <span class="hljs-string">'author?'</span>: z.<span class="hljs-title function_">string</span>(),</code>
<code>    <span class="hljs-string">'tags?'</span>: z.<span class="hljs-title function_">array</span>(z.<span class="hljs-title function_">string</span>()),</code>
<code>  }),</code>
<code>]);</code>
</pre>
<p>Note: <code>z.interface()</code> and the property keys with question marks are Zod 4 features. A subsection below explains why they are used here.</p>
<p>For larger schemas, it can make sense to break things up into multiple <code>const</code> declarations.</p>
<p>Zod can produce a static type from <code>FileEntryInputSchema</code>, but I decided to (redundantly!) manually maintain the static type <code>FileEntryInput</code>:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">FileEntryInput</span> =</code>
<code>  | <span class="hljs-built_in">string</span></code>
<code>  | [ <span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; ]</code>
<code>  | { <span class="hljs-attr">file</span>: <span class="hljs-built_in">string</span>, author?: <span class="hljs-built_in">string</span>, tags?: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; }</code>
<code>  ;</code>
</pre>
<p>Why the redundancy?</p>
<ul>
  <li>
    It’s easier to read.
  </li>
  <li>
    It helps with migrating to a different validation library or approach, should I ever have to.
  </li>
</ul>
<p>We can use a static check to ensure that <code>FileEntryInputSchema</code> and <code>FileEntryInput</code> are in sync:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  z.<span class="hljs-property">infer</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">FileEntryInputSchema</span>&gt;,</code>
<code>  <span class="hljs-title class_">FileEntryInput</span></code>
<code>&gt;&gt;;</code>
</pre>
<p>The generic type <code>z.infer</code> derives a type from a Zod schema.</p>
<h4 id="validating-data"><a class="heading-id-link" href="#validating-data">32.3.2 Validating data</a></h4>
<p>The schema method <code>.parse()</code> checks if a value has the correct structure:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-attr">fileEntryInput</span>: <span class="hljs-title class_">FileEntryInput</span> = <span class="hljs-title class_">FileEntryInputSchema</span>.<span class="hljs-title function_">parse</span>( <span class="hljs-comment">// OK</span></code>
<code>  [<span class="hljs-string">'iceland.txt'</span>, <span class="hljs-string">'me'</span>, [<span class="hljs-string">'vacation'</span>, <span class="hljs-string">'family'</span>]]</code>
<code>);</code>
<code>assert.<span class="hljs-title function_">throws</span>(</code>
<code>  <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">FileEntryInputSchema</span>.<span class="hljs-title function_">parse</span>([<span class="hljs-string">'iceland.txt'</span>, <span class="hljs-string">'me'</span>])</code>
<code>);</code>
</pre>
<h4 id="zod-optional-properties"><a class="heading-id-link" href="#zod-optional-properties">32.3.3 Tip: Use <code>z.interface()</code> and property keys with question marks for optional properties (Zod 4)</a></h4>
<p>They are a Zod 4 features. Without them, optional properties have the wrong types:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">const</span> <span class="hljs-title class_">Schema</span> = z.<span class="hljs-title function_">object</span>({</code>
<code>  <span class="hljs-attr">file</span>: z.<span class="hljs-title function_">string</span>(),</code>
<code>  <span class="hljs-attr">author</span>: z.<span class="hljs-title function_">string</span>().<span class="hljs-title function_">optional</span>(),</code>
<code>  <span class="hljs-attr">tags</span>: z.<span class="hljs-title function_">array</span>(z.<span class="hljs-title function_">string</span>()).<span class="hljs-title function_">optional</span>(),</code>
<code>});</code>
<code><span class="hljs-keyword">type</span> _ = <span class="hljs-title class_">Assert</span>&lt;<span class="hljs-title class_">Equal</span>&lt;</code>
<code>  z.<span class="hljs-property">infer</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Schema</span>&gt;,</code>
<code>  {</code>
<code>    <span class="hljs-attr">file</span>: <span class="hljs-built_in">string</span>,</code>
<code>    author?: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// (A)</span></code>
<code>    tags?: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; | <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// (B)</span></code>
<code>  }</code>
<code>&gt;&gt;;</code>
</pre>
<p><code>.optional()</code> does not do exactly what we want: In addition to making the property optional, it also adds <code>undefined</code> to its type (line A and line B).</p>
<h4 id="external-vs-internal-representation-of-data"><a class="heading-id-link" href="#external-vs-internal-representation-of-data">32.3.4 External vs. internal representation of data</a></h4>
<p>When working with external data, it’s often useful to distinguish two types.</p>
<p>On one hand, there is the type that describes the input data. Its structure is optimized for being easy to author:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">FileEntryInput</span> =</code>
<code>  | <span class="hljs-built_in">string</span></code>
<code>  | [ <span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; ]</code>
<code>  | { <span class="hljs-attr">file</span>: <span class="hljs-built_in">string</span>, author?: <span class="hljs-built_in">string</span>, tags?: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; }</code>
<code>  ;</code>
</pre>
<p>On the other hand, there is the type that is used in the program. Its structure is optimized for being easy to use in code:</p>
<pre class="language-ts">
<code><span class="hljs-keyword">type</span> <span class="hljs-title class_">FileEntry</span> = {</code>
<code>  <span class="hljs-attr">file</span>: <span class="hljs-built_in">string</span>,</code>
<code>  <span class="hljs-attr">author</span>: <span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span>,</code>
<code>  <span class="hljs-attr">tags</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;,</code>
<code>};</code>
</pre>
<p>After we have used Zod to ensure that the input data conforms to <code>FileEntryInput</code>, we can use a conversion function that converts the data to a value of type <code>FileEntry</code>.</p>
<h3 id="conclusion-various-thoughts-about-data-validation-libraries"><a class="heading-id-link" href="#conclusion-various-thoughts-about-data-validation-libraries">32.4 Conclusion: various thoughts about data validation libraries</a></h3>
<p>I see two options for improving data validation libraries in the long run:</p>
<ul>
  <li>
    <p>Built-in support for runtime type representations in TypeScript: That would help validation libraries – at least with simpler use cases. For advanced use cases, it may be possible to leverage decorators.</p>
  </li>
  <li>
    <p>Built-in support for compiling types to validation code. This could look similar to macros as supported, e.g., by Rust.</p>
  </li>
</ul>
<p>For libraries that have builder APIs, I’d find tools useful that compile TypeScript types to builder API invocations (online and via a shell command). This would help in two ways:</p>
<ul>
  <li>
    The tools could be used to explore how the APIs work.
  </li>
  <li>
    We’d have the option of producing API code via the tools.
  </li>
</ul>

    
      
</body>
</html>