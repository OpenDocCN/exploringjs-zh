- en: 14 The top types any and unknown
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14 顶级类型 any 和 unknown
- en: 原文：[https://exploringjs.com/ts/book/ch_any-unknown.html](https://exploringjs.com/ts/book/ch_any-unknown.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/ts/book/ch_any-unknown.html](https://exploringjs.com/ts/book/ch_any-unknown.html)
- en: (Ad, please don’t block.)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: (广告，请勿屏蔽。)
- en: '[14.1 TypeScript’s two top types](#typescript-s-two-top-types)'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[14.1 TypeScript 的两个顶级类型](#typescript-s-two-top-types)'
- en: '[14.2 The top type `any`](#the-top-type-any)'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[14.2 顶级类型 `any`](#the-top-type-any)'
- en: '[14.2.1 Example: `JSON.parse()`](#example-json-parse)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[14.2.1 示例：`JSON.parse()`](#example-json-parse)'
- en: '[14.2.2 Example: `String()`](#example-string)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[14.2.2 示例：`String()`](#example-string)'
- en: '[14.2.3 The compiler option `noImplicitAny`](#noImplicitAny)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[14.2.3 编译器选项 `noImplicitAny`](#noImplicitAny)'
- en: '[14.3 The top type `unknown`](#the-top-type-unknown)'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[14.3 顶级类型 `unknown`](#the-top-type-unknown)'
- en: In TypeScript, `any` and `unknown` are types that contain all values. In this
    chapter, we examine what they are and what they can be used for.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，`any` 和 `unknown` 是包含所有值的类型。在本章中，我们将探讨它们是什么以及它们可以用于什么。
- en: '[14.1 TypeScript’s two top types](#typescript-s-two-top-types)'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[14.1 TypeScript 的两个顶级类型](#typescript-s-two-top-types)'
- en: '`any` and `unknown` are so-called *top types* in TypeScript. Quoting [Wikipedia](https://en.wikipedia.org/wiki/Top_type):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`any` 和 `unknown` 是 TypeScript 中的所谓 *顶级类型*。引用 [Wikipedia](https://en.wikipedia.org/wiki/Top_type)：'
- en: The *top type* […] is the *universal* type, sometimes called the *universal
    supertype* as all other types in any given type system are subtypes […]. In most
    cases it is the type which contains every possible [value] in the type system
    of interest.
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*顶级类型* [...] 是 *通用* 类型，有时也称为 *通用超类型*，因为任何给定类型系统中的所有其他类型都是其子类型 [...]. 在大多数情况下，它是包含感兴趣的类型系统中所有可能
    [值] 的类型。'
- en: That is, when viewing types as sets of values (for more information on what
    types are, see [“What is a type in TypeScript? Two perspectives” (§13)](ch_what-is-a-type.html#ch_what-is-a-type)),
    `any` and `unknown` are sets that contain all values.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 即，当我们将类型视为值的集合（有关类型的更多信息，请参阅[“TypeScript 中的类型是什么？两种视角” (§13)](ch_what-is-a-type.html#ch_what-is-a-type))时，`any`
    和 `unknown` 是包含所有值的集合。
- en: TypeScript also has the *bottom type* `never`, which is the empty set and explained
    in [“The bottom type `never`” (§15)](ch_never.html#ch_never).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 还有一个 *最低类型* `never`，它是空集，在[“最低类型 `never`” (§15)](ch_never.html#ch_never)中解释。
- en: '[14.2 The top type `any`](#the-top-type-any)'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[14.2 顶级类型 `any`](#the-top-type-any)'
- en: 'If a value has type `any`, we can do everything with it:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个值具有 `any` 类型，我们可以对它做任何操作：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Every type is assignable to type `any`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类型都可以赋值给类型 `any`：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Type `any` is assignable to every type:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `any` 可赋值给任何类型：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With `any` we lose any protection that is normally given to us by TypeScript’s
    static type system. Therefore, it should only be used as a last resort, if we
    can’t use more specific types or `unknown`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `any` 我们会失去 TypeScript 静态类型系统通常给予我们的任何保护。因此，它只能作为最后的手段使用，如果我们不能使用更具体的类型或
    `unknown`。
- en: '[14.2.1 Example: `JSON.parse()`](#example-json-parse)'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[14.2.1 示例：`JSON.parse()`](#example-json-parse)'
- en: 'The result of `JSON.parse()` depends on dynamic input, which is why the return
    type is `any` (I have omitted the parameter `reviver` from the signature):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON.parse()` 的结果取决于动态输入，这就是为什么返回类型是 `any`（我已经从签名中省略了参数 `reviver`）：'
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`JSON.parse()` was added to TypeScript before the type `unknown` existed. Otherwise,
    its return type would probably be `unknown`.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `unknown` 类型存在之前，`JSON.parse()` 就被添加到 TypeScript 中。否则，它的返回类型可能就是 `unknown`。
- en: '[14.2.2 Example: `String()`](#example-string)'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[14.2.2 示例：`String()`](#example-string)'
- en: 'The function `String()`, which converts arbitrary values to strings, has the
    following type signature:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将任意值转换为字符串的函数 `String()` 有以下类型签名：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[14.2.3 The compiler option `noImplicitAny`](#noImplicitAny)'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[14.2.3 编译器选项 `noImplicitAny`](#noImplicitAny)'
- en: If the compiler option `noImplicitAny` is `true`, TypeScript requires explicit
    type annotations in locations where it can’t infer types. The most important example
    is parameters definitions. If this option is `false`, it (implicitly) uses the
    type `any` in those locations.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器选项 `noImplicitAny` 设置为 `true`，TypeScript 要求在它无法推断类型的位置显式添加类型注解。最重要的例子是参数定义。如果此选项设置为
    `false`，它（隐式地）使用类型 `any` 在这些位置。
- en: 'This is an example of a compiler error that is caused by `noImplicitAny` being
    `true`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个由 `noImplicitAny` 设置为 `true` 导致的编译器错误的示例：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'TypeScript does not complain about us using the type `any` explicitly:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 不会对我们显式使用类型 `any` 提出异议：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[14.3 The top type `unknown`](#the-top-type-unknown)'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[14.3 顶级类型 `unknown`](#the-top-type-unknown)'
- en: 'The type `unknown` is a type-safe version of the type `any`. Whenever you are
    thinking of using `any`, try using `unknown` first. `unknown` is similar to `any`
    in that we can assign any value to it:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 类型`unknown`是类型安全的`any`类型的版本。每当您考虑使用`any`时，请首先尝试使用`unknown`。`unknown`与`any`类似，我们可以将其分配给任何值：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'However, an `unknown` value is not assignable to anything:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`unknown`类型的值不能分配给任何类型：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Therefore, if we have a value of type `unknown`, we must narrow that type before
    we can do anything with the value – e.g., via:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们有一个`unknown`类型的值，我们必须在可以对该值进行任何操作之前缩小该类型——例如，通过：
- en: '[Type assertions](ch_type-assertions.html#ch_type-assertions):'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类型断言](ch_type-assertions.html#ch_type-assertions):'
- en: '[PRE9]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Equality:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相等性：
- en: '[PRE10]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Type guards](ch_type-guards.html#ch_type-guards):'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类型守卫](ch_type-guards.html#ch_type-guards):'
- en: '[PRE11]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Assertion functions](ch_assertion-functions.html#ch_assertion-functions):'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[断言函数](ch_assertion-functions.html#ch_assertion-functions):'
- en: '[PRE12]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
