- en: 4 The basics of TypeScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4   TypeScript 的基础知识
- en: 原文：[https://exploringjs.com/ts/book/ch_typescript-essentials.html](https://exploringjs.com/ts/book/ch_typescript-essentials.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/ts/book/ch_typescript-essentials.html](https://exploringjs.com/ts/book/ch_typescript-essentials.html)
- en: (Ad, please don’t block.)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: (广告，请勿拦截。)
- en: '[4.1 What you’ll learn](#what-you-ll-learn)'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.1 你将学到什么](#what-you-ll-learn)'
- en: '[4.2 How to play with code while reading this chapter](#how-to-play-with-code-while-reading-this-chapter)'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.2 如何在阅读本章时玩转代码](#how-to-play-with-code-while-reading-this-chapter)'
- en: '[4.3 What is a type?](#what-is-a-type)'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.3 什么是类型？](#what-is-a-type)'
- en: '[4.4 TypeScript’s two language levels](#language-levels)'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.4 TypeScript 的两种语言级别](#language-levels)'
- en: '[4.4.1 Dynamic types vs. static types](#dynamic-types-vs-static-types)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.4.1 动态类型与静态类型](#dynamic-types-vs-static-types)'
- en: '[4.4.2 JavaScript’s dynamic types](#javascript-s-dynamic-types)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.4.2 JavaScript 的动态类型](#javascript-s-dynamic-types)'
- en: '[4.4.3 TypeScript’s static types](#types-in-typescript)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.4.3 TypeScript 的静态类型](#types-in-typescript)'
- en: '[4.4.4 Revisiting the two language levels](#revisiting-the-two-language-levels)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.4.4 重访两种语言级别](#revisiting-the-two-language-levels)'
- en: '[4.5 Primitive literal types](#primitive-literal-types)'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.5 原始字面量类型](#primitive-literal-types)'
- en: '[4.6 The types `any`, `unknown` and `never`](#the-types-any-unknown-and-never)'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.6 类型 `any`、`unknown` 和 `never`](#the-types-any-unknown-and-never)'
- en: '[4.6.1 The wildcard type `any`](#the-wildcard-type-any)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.6.1 通配符类型 `any`](#the-wildcard-type-any)'
- en: '[4.7 Type inference](#type-inference)'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.7 类型推断](#type-inference)'
- en: '[4.7.1 The rules of type inference](#the-rules-of-type-inference)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.7.1 类型推断的规则](#the-rules-of-type-inference)'
- en: '[4.8 Type aliases](#type-aliases)'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.8 类型别名](#type-aliases)'
- en: '[4.9 Compound types](#compound-types)'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.9 复合类型](#compound-types)'
- en: '[4.10 Typing Arrays](#typing-arrays)'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.10 数组的类型化](#typing-arrays)'
- en: '[4.10.1 Array types: `T[]` and `Array<T>`](#array-types-t-and-array-t)'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.10.1 数组类型：`T[]` 和 `Array<T>`](#array-types-t-and-array-t)'
- en: '[4.10.2 Tuple types: `[T0, T1, ···]`](#tuple-types-t0-t1)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.10.2 元组类型：`[T0, T1, ···]`](#tuple-types-t0-t1)'
- en: '[4.11 Function types](#function-types)'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.11 函数类型](#function-types)'
- en: '[4.11.1 Inferring function types](#inferring-function-types)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.11.1 推断函数类型](#inferring-function-types)'
- en: '[4.11.2 Example: a function whose parameter is a function](#example-a-function-whose-parameter-is-a-function)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.11.2 示例：参数是函数的函数](#example-a-function-whose-parameter-is-a-function)'
- en: '[4.11.3 Inferring the return types of functions](#inferring-the-return-types-of-functions)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.11.3 推断函数的返回类型](#inferring-the-return-types-of-functions)'
- en: '[4.11.4 The special return type `void`](#the-special-return-type-void)'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.11.4 特殊返回类型 `void`](#the-special-return-type-void)'
- en: '[4.11.5 Optional parameters](#optional-parameters)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.11.5 可选参数](#optional-parameters)'
- en: '[4.11.6 Parameter default values](#parameter-default-values)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.11.6 参数默认值](#parameter-default-values)'
- en: '[4.11.7 Rest parameters](#rest-parameters)'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.11.7 可变参数](#rest-parameters)'
- en: '[4.12 Typing objects](#typing-objects)'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.12 对象的类型化](#typing-objects)'
- en: '[4.12.1 Typing fixed-layout objects via object literal types](#typing-fixed-layout-objects-via-object-literal-types)'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.12.1 通过对象字面量类型对固定布局对象进行类型化](#typing-fixed-layout-objects-via-object-literal-types)'
- en: '[4.12.2 Interfaces as an alternative to object literal types](#interfaces-as-an-alternative-to-object-literal-types)'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.12.2 接口作为对象字面量类型的替代方案](#interfaces-as-an-alternative-to-object-literal-types)'
- en: '[4.12.3 TypeScript’s structural typing vs. nominal typing](#typescript-s-structural-typing-vs-nominal-typing)'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.12.3 TypeScript 的结构化类型与名义类型](#typescript-s-structural-typing-vs-nominal-typing)'
- en: '[4.12.4 Optional properties](#optional-properties)'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.12.4 可选属性](#optional-properties)'
- en: '[4.12.5 Methods](#methods)'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.12.5 方法](#methods)'
- en: '[4.13 Union types](#union-types)'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.13 联合类型](#union-types)'
- en: '[4.13.1 Adding `undefined` and `null` to types](#adding-undefined-and-null-to-types)'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.13.1 将 `undefined` 和 `null` 添加到类型中](#adding-undefined-and-null-to-types)'
- en: '[4.13.2 Unions of string literal types](#unions-of-string-literal-types)'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.13.2 字符串字面量类型的联合](#unions-of-string-literal-types)'
- en: '[4.14 Intersection types](#intersection-types)'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.14 交集类型](#intersection-types)'
- en: '[4.15 Type guards and narrowing](#type-guards-and-narrowing)'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.15 类型守卫和缩窄](#type-guards-and-narrowing)'
- en: '[4.16 Type variables and generic types](#type-variables-and-generic-types)'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.16 类型变量和泛型类型](#type-variables-and-generic-types)'
- en: '[4.16.1 Example: a container for values](#example-a-container-for-values)'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.16.1 示例：值的容器](#example-a-container-for-values)'
- en: '[4.16.2 Example: a generic class](#example-a-generic-class)'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.16.2 示例：泛型类](#example-a-generic-class)'
- en: '[4.16.3 Example: Maps](#example-maps)'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.16.3 示例：映射](#example-maps)'
- en: '[4.16.4 Functions and methods with type parameters](#functions-and-methods-with-type-parameters)'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.16.4 带有类型参数的函数和方法](#functions-and-methods-with-type-parameters)'
- en: '[4.17 Conclusion: understanding the initial example](#conclusion-understanding-the-initial-example)'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.17 结论：理解初始示例](#conclusion-understanding-the-initial-example)'
- en: '[4.18 Next steps](#next-steps)'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.18 下一步](#next-steps)'
- en: '[4.18.1 Tip: Use `strict` type checking whenever you can](#tip-use-strict-type-checking-whenever-you-can)'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[4.18.1 小贴士：尽可能使用`strict`类型检查](#tip-use-strict-type-checking-whenever-you-can)'
- en: This chapter explains the basics of TypeScript. After reading it, you should
    be able to write your first TypeScript code. My hope is that that shouldn’t take
    you longer than a day. [I’d love to hear](https://dr-axel.de/#contact) how long
    it actually took you – my guess may be off.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了TypeScript的基础知识。阅读后，您应该能够编写您的第一个TypeScript代码。我的希望是，这不应该花您超过一天的时间。[我很乐意听听](https://dr-axel.de/#contact)您实际上花了多长时间——我的猜测可能不准确。
- en: '![Icon “reading”](../Images/00b0d6029a045810b908b88d1a6733d2.png) **Start reading
    here**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![阅读图标](../Images/00b0d6029a045810b908b88d1a6733d2.png) **从这里开始阅读**'
- en: 'You can start reading this book with this chapter: No prior knowledge is required
    other than JavaScript. Alternatively, if you first want to get a better understanding
    of how TypeScript fits into development workflows as a tool, you can check out
    [“How TypeScript is used: workflows, tools, etc.” (§6)](ch_typescript-workflows.html#ch_typescript-workflows).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从本章开始阅读这本书：除了JavaScript之外，不需要任何先前的知识。或者，如果您首先想更好地理解TypeScript作为工具如何融入开发工作流程，您可以查看[“TypeScript的使用：工作流程、工具等”（§6）](ch_typescript-workflows.html#ch_typescript-workflows)。
- en: '[4.1 What you’ll learn](#what-you-ll-learn)'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.1 您将学习的内容](#what-you-ll-learn)'
- en: 'After reading this chapter, you should be able to understand the following
    TypeScript code (which we’ll get back to at the end):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，您应该能够理解以下TypeScript代码（我们将在最后回到它）：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You may think that this is cryptic. And I agree with you! But (as I hope to
    prove) this syntax is relatively easy to learn. And once you understand it, it
    gives you immediate, precise and comprehensive summaries of how code behaves –
    without having to read long descriptions in English.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会认为这是晦涩的。我同意您的看法！但是（我希望证明），这种语法相对容易学习。一旦您理解了它，它就能立即、精确和全面地总结代码的行为——而不必阅读冗长的英文描述。
- en: '[4.2 How to play with code while reading this chapter](#how-to-play-with-code-while-reading-this-chapter)'
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.2 阅读本章时如何玩代码](#how-to-play-with-code-while-reading-this-chapter)'
- en: 'This chapter is meant to be consumed passively: Everything you need to see
    is shown here, including explorations of what a piece of code does.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在被动阅读：您需要看到的一切都在这里，包括对代码功能的探索。
- en: 'However, you may still want to play with TypeScript code. The following chapter
    explains how to do that: [“Trying out TypeScript without installing it” (§7)](ch_trying-out-typescript.html#ch_trying-out-typescript).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可能仍然想尝试TypeScript代码。下一章将解释如何做到这一点：[“尝试TypeScript而不安装它”（§7）](ch_trying-out-typescript.html#ch_trying-out-typescript)。
- en: '[4.3 What is a type?](#what-is-a-type)'
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.3 什么是类型？](#what-is-a-type)'
- en: 'In this chapter:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: A type is a set of values. For example, the type `boolean` is a set whose elements
    are `false` and `true`.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型是一组值。例如，类型`boolean`是一个包含`false`和`true`元素的集合。
- en: '`S` being a subtype of `T` means that `S` is a subset of `T`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S`是`T`的子类型意味着`S`是`T`的子集。'
- en: '[4.4 TypeScript’s two language levels](#language-levels)'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.4 TypeScript的两个语言级别](#language-levels)'
- en: 'TypeScript is JavaScript plus syntax for adding static type information. Therefore,
    TypeScript has two *language levels* – two ways of using source code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript是JavaScript加上添加静态类型信息的语法。因此，TypeScript有两个*语言级别*——两种使用源代码的方式：
- en: 'The *program level* (JavaScript): At this level, using TypeScript source code
    means running it: We have to remove the type information and feed it to a JavaScript
    engine.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*程序级别*（JavaScript）：在这个级别上，使用TypeScript源代码意味着运行它：我们必须移除类型信息并将其提供给JavaScript引擎。'
- en: 'The *type level* (TypeScript): At this level, using TypeScript source code
    means type-checking it: We analyze the source code to make sure types are used
    consistently.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类型级别*（TypeScript）：在这个级别上，使用TypeScript源代码意味着检查其类型：我们分析源代码以确保类型使用的一致性。'
- en: '|  | Program level | Type level |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|  | 程序级别 | 类型级别 |'
- en: '| --- | --- | --- |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Programming language is | JavaScript | TypeScript |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 编程语言 | JavaScript | TypeScript |'
- en: '| Source code is | executed | type-checked |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 源代码是 | 执行 | 类型检查 |'
- en: '| Types are | dynamic | static |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 类型是 | 动态的 | 静态的 |'
- en: '| Types exist at | runtime | compile time |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 类型存在于 | 运行时 | 编译时 |'
- en: '[4.4.1 Dynamic types vs. static types](#dynamic-types-vs-static-types)'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.4.1 动态类型与静态类型](#dynamic-types-vs-static-types)'
- en: 'So far, we have only talked about TypeScript’s (static) types. But JavaScript
    also has types:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了TypeScript的（静态）类型。但JavaScript也有类型：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Its types are called *dynamic*. Why is that? We have to run code to see if
    they are used correctly – e.g.:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的类型被称为 *动态*。为什么是这样？我们必须运行代码来查看它们是否被正确使用——例如：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In contrast, TypeScript’s types are *static*: We check them by analyzing the
    syntax – without running the code. That happens during editing (for individual
    files) or when running the TypeScript compiler `tsc` (for the whole code base).
    In the following code, TypeScript detects the error via type checking (note that
    it doesn’t even need explicit type information in this case):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，TypeScript 的类型是 *静态* 的：我们通过分析语法来检查它们——而不需要运行代码。这发生在编辑（对于单个文件）或运行 TypeScript
    编译器 `tsc`（对于整个代码库）时。在下面的代码中，TypeScript 通过类型检查检测到错误（注意，在这种情况下甚至不需要显式的类型信息）：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Icon “details”](../Images/837806d7ec89826c3784b2e685feb762.png) **`@ts-expect-error`
    shows type checking errors**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“详情”](../Images/837806d7ec89826c3784b2e685feb762.png) **`@ts-expect-error`
    显示类型检查错误**'
- en: In this book, type checking errors are shown via `@ts-expect-error` directives
    ([more information](ch_book-notation.html#notation-ts-expect-error)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，类型检查错误是通过 `@ts-expect-error` 指令显示的（[更多信息](ch_book-notation.html#notation-ts-expect-error)）。
- en: '[4.4.2 JavaScript’s dynamic types](#javascript-s-dynamic-types)'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.4.2 JavaScript 的动态类型](#javascript-s-dynamic-types)'
- en: 'The JavaScript language (not TypeScript!) has only eight types. In the ECMAScript
    specification, they have names that start with capital letters. Here, I’m going
    with the values returned by `typeof` – e.g.:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 语言（不是 TypeScript！）只有八个类型。在 ECMAScript 规范中，它们的名称以大写字母开头。在这里，我使用 `typeof`
    返回的值——例如：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'JavaScript’s eight types are:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的八个类型是：
- en: '`undefined`: the set with the only element `undefined`'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`undefined`: 只有一个元素 `undefined` 的集合'
- en: '`null`: the set with the only element `null`. Due to a historical bad decision,
    `typeof` returns `''object''` for the value `null` and not `''null''`.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`null`: 只有一个元素 `null` 的集合。由于一个历史性的错误决定，`typeof` 对于 `null` 值返回 `''object''`
    而不是 `''null''`。'
- en: '`boolean`: the set with the two elements `false` and `true`'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`boolean`: 包含两个元素 `false` 和 `true` 的集合'
- en: '`number`: the set of all numbers'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`number`: 所有数字的集合'
- en: '`bigint`: the set of all arbitrary-precision integers'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bigint`: 所有任意精度整数的集合'
- en: '`string`: the set of all strings'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`string`: 所有字符串的集合'
- en: '`symbol`: the set of all symbols'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`symbol`: 所有符号的集合'
- en: '`object`: the set of all objects (which includes functions and Arrays)'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`object`: 所有对象的集合（包括函数和数组）'
- en: '`typeof` additionally has a separate “type” for functions but that is not how
    ECMAScript sees things internally.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof` 还有一个针对函数的单独的“类型”，但 ECMAScript 并不是这样看待内部事物的。'
- en: All of these types are dynamic. They can also be used at the type level in TypeScript
    (see next section).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些类型都是动态的。它们也可以在 TypeScript 的类型级别上使用（见下一节）。
- en: '[4.4.3 TypeScript’s static types](#types-in-typescript)'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.4.3 TypeScript 的静态类型](#types-in-typescript)'
- en: 'TypeScript brings an additional layer to JavaScript: *static types*. In source
    code, there are:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 为 JavaScript 增加了一个额外的层：*静态类型*。在源代码中，有：
- en: Sources of data – e.g. values created via literals such as `128`, `true` or
    `['a', 'b']`
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的源——例如，通过字面量如 `128`、`true` 或 `['a', 'b']` 创建的值
- en: Sinks of data – e.g. storage locations such as variables, properties and parameters.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的汇——例如，变量、属性和参数等存储位置。
- en: Storage locations can also become data sources when we read from them.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储位置在读取时也可以成为数据源。
- en: 'Both have static types in TypeScript:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，它们都有静态类型：
- en: The type of a data source describes what dynamic values it can be.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据源的类型描述了它可以接受哪些动态值。
- en: The type of a data sink describes what dynamic values can be written to it.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据汇的类型描述了可以写入它的动态值。
- en: 'One way in which a storage location such as a variable can receive a static
    type is via a *type annotation* – e.g.:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 变量等存储位置可以通过 *类型注解* 接收静态类型，例如：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The colon (`:`) plus the type `number` is the type annotation. It states that
    the static type of the variable `count` is `number`. The type annotation helps
    with type checking:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号 (`:`) 加上类型 `number` 是类型注解。它声明变量 `count` 的静态类型是 `number`。类型注解有助于类型检查：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What does the error message mean? The (implicit) static type `string` of the
    data source `'yes'` is incompatible with the (explicitly specified) static type
    `number` of the data sink `count`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息是什么意思？数据源 `'yes'` 的（隐式）静态类型 `string` 与数据汇 `count` 的（明确指定的）静态类型 `number`
    不兼容。
- en: '[4.4.3.1 A function with type annotations](#a-function-with-type-annotations)'
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[4.4.3.1 带有类型注解的函数](#a-function-with-type-annotations)'
- en: 'The next example shows a function with type annotations:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了一个带有类型注解的函数：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are two type annotations:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型注解：
- en: The parameter `num` has the type `number`.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数 `num` 的类型是 `number`。
- en: The return type of the function is `string`.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的返回类型是 `string`。
- en: '[4.4.4 Revisiting the two language levels](#revisiting-the-two-language-levels)'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.4.4 回顾两种语言级别](#revisiting-the-two-language-levels)'
- en: 'Let’s briefly revisit the two language levels. It’s interesting to see how
    they show up in TypeScript’s syntax:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下两种语言级别。看看它们如何在 TypeScript 的语法中体现出来是很有趣的：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At the dynamic level, we use JavaScript to declare a variable `noValue` and
    initialize it with the value `undefined`.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在动态级别上，我们使用 JavaScript 声明一个变量 `noValue` 并用值 `undefined` 初始化它。
- en: At the static level, we use TypeScript to specify that variable `noValue` has
    the static type `undefined`.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在静态级别上，我们使用 TypeScript 指定变量 `noValue` 的静态类型为 `undefined`。
- en: The same syntax, `undefined`, is used at the JavaScript level and at the type
    level and means different things – depending on where it is used.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的语法 `undefined` 在 JavaScript 级别和类型级别上使用，但含义不同——取决于它被使用的地方。
- en: '[4.5 Primitive literal types](#primitive-literal-types)'
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.5 原始字面类型](#primitive-literal-types)'
- en: 'Several primitive types have so-called *literal types*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 几个原始类型都有所谓的 *字面类型*：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `1000` after the colon is a type, a *number literal type*: It is a set
    whose only element is the value `1000` and it is a subtype of `number`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号后面的 `1000` 是一个类型，一个 *数字字面类型*：它是一个只包含值 `1000` 的集合，并且它是 `number` 的子类型。
- en: 'On one hand, any value we assign to `thousand` must be `1000`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，我们分配给 `thousand` 的任何值都必须是 `1000`：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'On the other hand, we can assign `thousand` to any variable whose type is `number`
    because its type is a subtype of `number`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可以将 `thousand` 赋值给任何类型为 `number` 的变量，因为它的类型是 `number` 的子类型：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Except for `symbol`, all primitive types have literal types:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `symbol` 之外，所有原始类型都有字面类型：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Especially string literal types will become useful later (when we get to union
    types).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是字符串字面类型将在之后变得很有用（当我们到达联合类型时）。
- en: '[4.6 The types `any`, `unknown` and `never`](#the-types-any-unknown-and-never)'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.6 `any`、`unknown` 和 `never` 类型](#the-types-any-unknown-and-never)'
- en: 'TypeScript has several types that are specific to the type level:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 有几种特定于类型级别的类型：
- en: '`any` is a wildcard type and accepts any value (see below).'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any` 是一个通配符类型，接受任何值（见下文）。'
- en: '`unknown` is similar to `any` but less flexible: If a variable or parameter
    has that type, we can also write any value to it. However, we can’t do anything
    with its content unless we perform further type checks. Being less flexible is
    a good thing: I recommend avoiding `any` and instead using `unknown` whenever
    possible. For more information see [“The top types `any` and `unknown`” (§14)](ch_any-unknown.html#ch_any-unknown).'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unknown` 与 `any` 类似但更不灵活：如果一个变量或参数具有该类型，我们也可以向它写入任何值。然而，除非我们执行进一步的类型检查，否则我们无法对其内容进行任何操作。不够灵活是好事：我建议尽可能避免使用
    `any`，而是使用 `unknown`。更多信息请参阅[“顶级类型 `any` 和 `unknown`”（§14）](ch_any-unknown.html#ch_any-unknown)。'
- en: '`never` the empty set as a type. Among other things, it is used for locations
    that are never reached when a program is executed.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`never` 是空集作为类型。在许多情况下，它用于程序执行时永远不会到达的位置。'
- en: '[4.6.1 The wildcard type `any`](#the-wildcard-type-any)'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.6.1 通配符类型 `any`](#the-wildcard-type-any)'
- en: 'If the type of a storage location is neither explicitly specified nor inferrable,
    TypeScript uses the type `any` for it. `any` is the type of all values and a wildcard
    type: If a value has that type, TypeScript does not limit us in any way.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存储位置的类型既没有明确指定也没有可推断，TypeScript 会使用类型 `any`。`any` 是所有值的类型，也是一个通配符类型：如果一个值具有该类型，TypeScript
    不会以任何方式限制我们。
- en: 'If `strict` type checking is enabled, we can only use `any` explicitly: Every
    location must have an explicit or inferred static type. That is safer because
    there are no holes in type checking, no unintended blind spots.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了 `strict` 类型检查，我们只能显式地使用 `any`：每个位置都必须有一个明确的或推断的静态类型。这更安全，因为没有类型检查的漏洞，没有意外的盲点。
- en: 'Let’s look at examples – the type of parameters can usually not be inferred:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看例子——参数的类型通常无法推断：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For `func3`, TypeScript can infer that `arg` has the type `boolean` because
    it has the default value `false`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `func3`，TypeScript 可以推断出 `arg` 的类型为 `boolean`，因为它有默认值 `false`。
- en: '[4.7 Type inference](#type-inference)'
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.7 类型推断](#type-inference)'
- en: In many cases, TypeScript can automatically derive the types of data sources
    or data sinks, without us having to annotate anything. That is called *type inference*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，TypeScript 可以自动推导数据源或数据汇的类型，而无需我们进行任何注释。这被称为 *类型推断*。
- en: 'This is an example of type inference:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个类型推断的例子：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Icon “details”](../Images/837806d7ec89826c3784b2e685feb762.png) **`assertType<T>(v)`
    shows the type `T` of a value `v`**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“详情”](../Images/837806d7ec89826c3784b2e685feb762.png) **`assertType<T>(v)`
    显示值 `v` 的类型 `T`**'
- en: 'In this book, `assertType<T>(v)` is used to show that a value `v` has the type
    `T` – which was either inferred or explicitly assigned. For more information see
    [“Type level: `assertType<T>(v)`” (§5.2)](ch_book-notation.html#notation-assertType).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，`assertType<T>(v)` 用于显示一个值 `v` 的类型 `T` —— 这可能是推断出来的或明确指定的。有关更多信息，请参阅“类型级别：`assertType<T>(v)`”（§5.2）（ch_book-notation.html#notation-assertType）。
- en: 'TypeScript infers that the type of `count` is `14`. It can do so because it
    knows that the value `14` has the type `14`. Interestingly, TypeScript infers
    a more general type when we use `let`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 推断 `count` 的类型为 `14`。它可以这样做，因为它知道值 `14` 的类型是 `14`。有趣的是，当我们使用 `let`
    时，TypeScript 推断一个更通用的类型：
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Why is that? The assumption is that the value of `count` is preliminary and
    that we want to assign other (similar!) values later on. If `count` had the type
    `14` then we wouldn’t be able to do that.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么呢？假设是 `count` 的值是初步的，我们希望稍后分配其他（类似！）的值。如果 `count` 的类型是 `14`，那么我们就无法这样做。
- en: 'Another example of type inference: In this case TypeScript infers that function
    `toString()` has the return type `string`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断的另一个例子：在这种情况下，TypeScript 推断函数 `toString()` 的返回类型为 `string`。
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[4.7.1 The rules of type inference](#the-rules-of-type-inference)'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.7.1 类型推断规则](#the-rules-of-type-inference)'
- en: 'Type inference is not guesswork: It follows clear rules (similar to arithmetic)
    for deriving types where they haven’t been specified explicitly. For example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断不是猜测：它遵循明确的规则（类似于算术）来推导类型，其中没有明确指定。例如：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The inferred type of `strValue` is `string`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 推断出的 `strValue` 类型为 `string`：
- en: '**Step 1:** The inferred type of `32` is `32`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1**：推断出的 `32` 的类型是 `32`。'
- en: '**Step 2:** `String` used as a function has the following type (simplified):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2**：`String` 作为函数使用时具有以下类型（简化版）：'
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This type notation is used for functions and means:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型表示法用于函数，其含义为：
- en: The function has one parameter, `value`. That parameter has the type `any`.
    If a parameter has that type, it accepts any kind of value. (More on `any` soon.)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数有一个参数，`value`。该参数的类型为 `any`。如果一个参数具有该类型，它接受任何类型的值。（关于 `any` 的更多信息将在后面介绍。）
- en: The function returns values of type `string`.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数返回`string`类型的值。
- en: '**Step 3:** By combining the results of step 1 and step 2, TypeScript can infer
    that `strValue` has the type `string`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 3**：通过结合步骤 1 和步骤 2 的结果，TypeScript 可以推断出 `strValue` 的类型为 `string`。'
- en: '[4.8 Type aliases](#type-aliases)'
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.8 类型别名](#type-aliases)'
- en: 'With `type` we can create a new name (an alias) for an existing type:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`type`我们可以为现有类型创建一个新名称（别名）：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[4.9 Compound types](#compound-types)'
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.9 复合类型](#compound-types)'
- en: 'Compound types have other types inside them – which makes them very expressive.
    These are a few examples:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 复合类型内部包含其他类型，这使得它们非常具有表现力。以下是一些例子：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next, we’ll explore all of these compound types and more.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索所有这些复合类型以及更多。
- en: '[4.10 Typing Arrays](#typing-arrays)'
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.10 数组类型](#typing-arrays)'
- en: 'TypeScript has two different ways of typing Arrays:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 有两种不同的方式来为数组进行类型注解：
- en: An *Array type* `T[]` or `Array<T>` is used if an Array is a collection of values
    that all have the same type `T`.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数组是一个具有相同类型 `T` 的值集合时，使用 *数组类型* `T[]` 或 `Array<T>`。
- en: A *tuple type* `[T0, T1, ···]` is used if the index of an Array element determines
    its type.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数组元素的索引确定其类型时，使用 *元组类型* `[T0, T1, ···]`。
- en: '[4.10.1 Array types: `T[]` and `Array<T>`](#array-types-t-and-array-t)'
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.10.1 数组类型：`T[]` 和 `Array<T>`](#array-types-t-and-array-t)'
- en: 'For historical reasons, there are two equivalent ways of expressing the fact
    that `arr` is an Array, used to manage a sequence of numbers (think list, stack,
    queue, etc.):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因，表达`arr`是一个数组的事实有两种等效的方式，用于管理一系列数字（例如列表、栈、队列等）：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Normally, TypeScript can infer the type of a variable if there is an assignment.
    In this case, we have to help it because with an empty Array, it can’t determine
    the type of the elements.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，TypeScript可以在存在赋值的情况下推断变量的类型。在这种情况下，我们必须帮助它，因为对于一个空数组，它无法确定元素的类型。
- en: 'We’ll explore the angle brackets notation of `Array<number>` in more detail
    later (spoiler: `Array` is a *generic type* and `number` is a *type parameter*).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后更详细地探讨 `Array<number>` 的尖括号表示法（剧透：`Array` 是一个 *泛型类型*，而 `number` 是一个 *类型参数*）。
- en: 'In JavaScript’s standard library, `Object.keys()` returns an array:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 的标准库中，`Object.keys()` 返回一个数组：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[4.10.2 Tuple types: `[T0, T1, ···]`](#tuple-types-t0-t1)'
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.10.2 元组类型：`[T0, T1, ···]`](#tuple-types-t0-t1)'
- en: 'The following variable `entry` has a tuple type:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下变量`entry`具有元组类型：
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can use it to create an object via `Object.fromEntries()`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用它通过`Object.fromEntries()`创建一个对象：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'What is the nature of `entry`? At the JavaScript level, it’s also an Array,
    but it is used differently:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`entry`的本质是什么？在JavaScript级别上，它也是一个数组，但它被不同地使用：'
- en: 'The length is fixed: `2`.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长度是固定的：`2`。
- en: 'The index of an element determines its meaning and its type:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素的索引决定了它的意义和类型：
- en: At index 0, there are keys whose type is `string`.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在索引0处，存在类型为`string`的键。
- en: At index 1, there are values whose type is `number`.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在索引1处，存在类型为`number`的值。
- en: '[4.11 Function types](#function-types)'
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.11 函数类型](#function-types)'
- en: 'This is an example of a function type:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个函数类型的例子：
- en: '[PRE25]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This type comprises every function that accepts a single parameter of type
    number and returns a string. Let’s use this type in a type annotation:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型包括接受单个类型为数字的参数并返回字符串的每个函数。让我们在类型注解中使用这个类型：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Because TypeScript knows that `toString` has the type `NumToStr`, we do not
    need type annotations inside the arrow function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因为TypeScript知道`toString`的类型是`NumToStr`，所以我们不需要在箭头函数内添加类型注解。
- en: '[4.11.1 Inferring function types](#inferring-function-types)'
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.11.1 推断函数类型](#inferring-function-types)'
- en: 'We can also define `toString` like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以这样定义`toString`：
- en: '[PRE27]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note that we specified both a type for the parameter `num` and a return type.
    The inferred type of `toString` is:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们为参数`num`指定了类型，并且指定了返回类型。`toString`推断出的类型是：
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[4.11.2 Example: a function whose parameter is a function](#example-a-function-whose-parameter-is-a-function)'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.11.2 示例：参数为函数的函数](#example-a-function-whose-parameter-is-a-function)'
- en: 'The following function has a parameter `callback` whose type is a function:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数有一个类型为函数的参数`callback`：
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Due to the type of the parameter `callback`, TypeScript rejects the following
    function call:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`callback`参数的类型，TypeScript拒绝以下函数调用：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'But it accepts this function call:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 但它接受这个函数调用：
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can also use an arrow function to implement `stringify123()`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用箭头函数来实现`stringify123()`：
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[4.11.3 Inferring the return types of functions](#inferring-the-return-types-of-functions)'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.11.3 推断函数的返回类型](#inferring-the-return-types-of-functions)'
- en: 'TypeScript is good at inferring the return types of functions, but specifying
    them explicitly is recommended: It makes intentions clearer, enables additional
    consistency checks and helps external tools with generating declaration files
    (those tools usually can’t infer return types).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript擅长推断函数的返回类型，但显式指定它们是推荐的：它使意图更清晰，启用额外的一致性检查，并帮助外部工具生成声明文件（这些工具通常无法推断返回类型）。
- en: '[4.11.4 The special return type `void`](#the-special-return-type-void)'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.11.4 特殊的返回类型`void`](#the-special-return-type-void)'
- en: '`void` is a special return type for a function: It tells TypeScript that the
    function always returns `undefined`.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`void`是函数的一个特殊返回类型：它告诉TypeScript该函数总是返回`undefined`。'
- en: 'It may do so explicitly:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能明确地这样做：
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Or it may do so implicitly:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它可能隐式地这样做：
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'However, such a function cannot explicitly return values other than `undefined`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样的函数不能明确地返回除了`undefined`之外的其他值：
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[4.11.5 Optional parameters](#optional-parameters)'
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.11.5 可选参数](#optional-parameters)'
- en: 'A question mark after an identifier means that the parameter is optional. For
    example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符后面的问号表示该参数是可选的。例如：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: TypeScript only lets us make the function call in line A if we make sure that
    `callback` isn’t `undefined` (which it is if the parameter was omitted).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript只允许我们在行A处调用函数，前提是我们确保`callback`不是`undefined`（如果省略了参数，它就是`undefined`）。
- en: '[4.11.6 Parameter default values](#parameter-default-values)'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.11.6 参数默认值](#parameter-default-values)'
- en: 'TypeScript supports [parameter default values](https://exploringjs.com/js/book/ch_callables.html#parameter-default-values):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript支持[参数默认值](https://exploringjs.com/js/book/ch_callables.html#parameter-default-values)：
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Default values make parameters optional. We can usually omit type annotations,
    because TypeScript can infer the types. For example, it can infer that `x` and
    `y` both have the type `number`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值使参数可选。我们通常可以省略类型注解，因为TypeScript可以推断类型。例如，它可以推断出`x`和`y`都具有`number`类型。
- en: If we wanted to add type annotations, that would look as follows.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要添加类型注解，它看起来会是这样。
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[4.11.7 Rest parameters](#rest-parameters)'
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.11.7 剩余参数](#rest-parameters)'
- en: 'We can also use [rest parameters](https://exploringjs.com/js/book/ch_callables.html#rest-parameters)
    in TypeScript parameter definitions. Their static types must be Arrays or tuples:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在TypeScript参数定义中使用[剩余参数](https://exploringjs.com/js/book/ch_callables.html#rest-parameters)。它们的静态类型必须是数组或元组：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[4.12 Typing objects](#typing-objects)'
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.12 对象类型化](#typing-objects)'
- en: 'Similarly to Arrays, objects can be used in two ways in JavaScript (that are
    occasionally mixed):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于数组，在JavaScript中（偶尔混合使用）对象可以用两种方式使用：
- en: 'Fixed-layout object: A fixed number of properties that are known at development
    time. Each property can have a different type.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定布局对象：在开发时已知的固定数量的属性。每个属性可以有不同的类型。
- en: 'Dictionary object: An arbitrary number of properties whose names are not known
    at development time. All properties have the same type.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典对象：在开发时不知道名称的任意数量的属性。所有属性具有相同的类型。
- en: 'We are ignoring dictionary objects in this chapter – they are covered in [“Index
    signatures: objects as dictionaries” (§18.7)](ch_typing-objects.html#index-signatures).
    As an aside, Maps are usually a better choice for dictionaries, anyway.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们忽略了字典对象——它们在“索引签名：对象作为字典”（§18.7）中有所涉及。顺便提一下，Map通常比字典是一个更好的选择。
- en: '[4.12.1 Typing fixed-layout objects via object literal types](#typing-fixed-layout-objects-via-object-literal-types)'
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.12.1 通过对象字面量类型对固定布局对象进行类型化](#typing-fixed-layout-objects-via-object-literal-types)'
- en: 'Object literal types describe fixed-layout objects – e.g.:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量类型描述了固定布局的对象——例如：
- en: '[PRE40]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We can also use semicolons instead of commas to separate members, but the latter
    are more common.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用分号而不是逗号来分隔成员，但后者更常见。
- en: The members can also be separated by semicolons instead of commas but since
    the syntax of object literals types is related to the syntax of object literals
    (where members must be separated by commas), commas are used more often.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 成员也可以用分号而不是逗号来分隔，但由于对象字面量类型的语法与对象字面量（成员必须用逗号分隔）的语法相关，逗号的使用更为频繁。
- en: '[4.12.2 Interfaces as an alternative to object literal types](#interfaces-as-an-alternative-to-object-literal-types)'
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.12.2 接口作为对象字面量类型的替代方案](#interfaces-as-an-alternative-to-object-literal-types)'
- en: 'Interfaces are mostly equivalent to object literal types but have become less
    popular over time. This is what an interface looks like:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接口基本上等同于对象字面量类型，但随时间推移变得不那么受欢迎。接口看起来是这样的：
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The members can also be separated by commas instead of semicolons but since
    the syntax of interfaces is related to the syntax of classes (where members must
    be separated by semicolons), semicolons are used more often.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 成员也可以用逗号而不是分号来分隔，但由于接口的语法与类的语法（成员必须用分号分隔）相关，分号的使用更为频繁。
- en: '[4.12.3 TypeScript’s structural typing vs. nominal typing](#typescript-s-structural-typing-vs-nominal-typing)'
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.12.3 TypeScript的结构化类型与名义化类型](#typescript-s-structural-typing-vs-nominal-typing)'
- en: 'One big advantage of TypeScript’s type system is that it works *structurally*,
    not *nominally*. That is, the type `Point` matches all objects that have the appropriate
    structure:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的类型系统的一个重大优势是它是**结构化**的，而不是**名义化**的。也就是说，类型`Point`与所有具有适当结构的对象匹配：
- en: '[PRE42]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Conversely, in Java’s nominal type system, we must explicitly declare with each
    class which interfaces it implements. Therefore, a class can only implement interfaces
    that exist at its creation time.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在Java的名义类型系统中，我们必须在每个类中显式声明它实现了哪些接口。因此，一个类只能实现其创建时存在的接口。
- en: '[4.12.4 Optional properties](#optional-properties)'
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.12.4 可选属性](#optional-properties)'
- en: 'If a property can be omitted, we put a question mark after its name:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个属性可以省略，我们在其名称后加上一个问号：
- en: '[PRE43]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the following example, both `john` and `jane` match the type `Person`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`john`和`jane`都匹配类型`Person`：
- en: '[PRE44]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[4.12.5 Methods](#methods)'
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.12.5 方法](#methods)'
- en: 'Object literal types can also contain methods:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量类型也可以包含方法：
- en: '[PRE45]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As far as TypeScript’s type system is concerned, method definitions and properties
    whose values are functions, are equivalent:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 就TypeScript的类型系统而言，方法定义和值是函数的属性是等效的：
- en: '[PRE46]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: My recommendation is to use whichever syntax best expresses how a property should
    be set up.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是使用最能表达属性设置方式的语法。
- en: '[4.13 Union types](#union-types)'
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.13 联合类型](#union-types)'
- en: 'The values that are held by a variable (one value at a time) may be members
    of different types. In that case, we need a *union type*. For example, in the
    following code, `stringOrNumber` is either of type `string` or of type `number`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 变量所持有的值（每次一个值）可能是不同类型的成员。在这种情况下，我们需要一个**联合类型**。例如，在以下代码中，`stringOrNumber`可以是`string`类型或`number`类型：
- en: '[PRE47]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`stringOrNumber` has the type `string|number`. The result of the type expression
    `s|t` is the set-theoretic union of the types `s` and `t` (interpreted as sets).'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`stringOrNumber` 的类型是 `string|number`。类型表达式 `s|t` 的结果是类型 `s` 和 `t` 的集合论并集（解释为集合）。'
- en: '[4.13.1 Adding `undefined` and `null` to types](#adding-undefined-and-null-to-types)'
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.13.1 将 `undefined` 和 `null` 添加到类型中](#adding-undefined-and-null-to-types)'
- en: 'In TypeScript, the values `undefined` and `null` are not included in any type
    (other than the types `undefined`, `null`, `any` and `unknown`). That is common
    in statically type languages (with one notable exception being Java). We need
    union types such as `undefined|string` and `null|string` if we want to allow those
    values:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，`undefined` 和 `null` 不包含在任何类型中（除了 `undefined`、`null`、`any` 和
    `unknown` 类型）。这在静态类型语言中很常见（一个值得注意的例外是 Java）。如果我们想允许这些值，我们需要使用联合类型，例如 `undefined|string`
    和 `null|string`：
- en: '[PRE48]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Otherwise, we get an error:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们会得到一个错误：
- en: '[PRE49]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Note that TypeScript does not force us to initialize immediately (as long as
    we don’t read from the variable before initializing it):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，TypeScript 不会强迫我们立即初始化（只要我们在初始化之前不读取变量）：
- en: '[PRE50]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[4.13.2 Unions of string literal types](#unions-of-string-literal-types)'
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.13.2 字符串字面量类型的联合](#unions-of-string-literal-types)'
- en: 'Unions of string literals provide a quick way of defining a type with a limited
    set of values. For example, this is how the Node.js types define the buffer encoding
    that you can use (e.g.) with `fs.readFileSync()`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面量类型的联合提供了一种快速定义具有有限值集合的类型的方法。例如，这就是 Node.js 类型定义可以用于（例如）`fs.readFileSync()`
    的缓冲区编码的方式：
- en: '[PRE51]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: It’s neat that we get auto-completion for such unions ([figure 4.1](#fig:buffer-encoding-auto-completion)).
    We can also rename the elements of the union everywhere they are used – via the
    same refactoring that also changes function names.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 获得这样的联合类型的自动完成功能很方便（[图 4.1](#fig:buffer-encoding-auto-completion)）。我们还可以在联合类型被使用的地方重命名其元素——通过相同的重构，这也会改变函数名。
- en: '![](../Images/e83419228addc1b19a19dd9cd54dc537.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e83419228addc1b19a19dd9cd54dc537.png)'
- en: 'Figure 4.1: The auto-completion for `BufferEncoding` shows all elements of
    the union type.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：`BufferEncoding` 的自动完成显示了联合类型的所有元素。
- en: '[4.14 Intersection types](#intersection-types)'
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.14 交集类型](#intersection-types)'
- en: 'Where a union type computes the union of two types, viewed as sets, an intersection
    type computes the intersection:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当联合类型计算两个类型的并集时，视为集合，交集类型计算的是交集：
- en: '[PRE52]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '![Icon “details”](../Images/837806d7ec89826c3784b2e685feb762.png) **The generic
    type `Assert<B>` is for comparing types**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“详情”](../Images/837806d7ec89826c3784b2e685feb762.png) **泛型类型 `Assert<B>`
    用于比较类型**'
- en: In this book, types are compared via the generic type `Assert<B>` ([more information](ch_book-notation.html#notation-generic-type-Assert)).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，类型是通过泛型类型 `Assert<B>` 来比较的（更多信息请参阅 [ch_book-notation.html#notation-generic-type-Assert]）。
- en: One key use case for intersection types is combining object types ([more information](ch_intersections-object-types.html#ch_intersections-object-types)).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 交集类型的一个关键用途是组合对象类型（更多信息请参阅 [ch_intersections-object-types.html#ch_intersections-object-types]）。
- en: '[4.15 Type guards and narrowing](#type-guards-and-narrowing)'
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.15 类型守卫和缩小](#type-guards-and-narrowing)'
- en: Sometimes we are faced with types that are overly general. Then we need to use
    conditions with so-called *type guards* to make them small enough so that we can
    use them. That process is called *narrowing*.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们会遇到过于通用的类型。然后我们需要使用所谓的 *类型守卫* 的条件来使它们足够小，以便我们可以使用它们。这个过程被称为 *缩小*。
- en: 'In the following code, we narrow the type of `value` via the type guard `typeof`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们通过类型守卫 `typeof` 来缩小 `value` 的类型：
- en: '[PRE53]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It’s interesting to see how the type of `value` changes, due to us using `typeof`
    in the condition of an `if` statement:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 看到由于我们在 `if` 语句的条件中使用 `typeof`，`value` 的类型是如何变化的，这很有趣：
- en: Initially, the type of `value` is `string | number` (line A).
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始时，`value` 的类型是 `string | number`（行 A）。
- en: That’s why we can’t access property `.length` in line B.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这就是为什么我们无法在行 B 中访问属性 `.length` 的原因。
- en: Inside the true branch of the `if` statement, the type of `value` is `string`
    (line C).
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `if` 语句的真分支中，`value` 的类型是 `string`（行 C）。
- en: Now we can access property `.length` (line D).
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们可以访问属性 `.length`（行 D）。
- en: Because we return from inside the true branch, TypeScript knows that `value`
    has type `number` in line E.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们在真分支中返回，TypeScript 知道在行 E 中 `value` 的类型是 `number`。
- en: '[4.16 Type variables and generic types](#type-variables-and-generic-types)'
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.16 类型变量和泛型类型](#type-variables-and-generic-types)'
- en: 'Recall [the two language levels of TypeScript](#language-levels):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下 [TypeScript 的两种语言级别](#language-levels)：
- en: Values exist at the *dynamic level*.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值存在于 *动态级别*。
- en: Types exist at the *static level*.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型存在于*静态级别*。
- en: 'Similarly:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地：
- en: 'Normal functions exist at the dynamic level, are factories for values and have
    parameters representing values. Parameters are declared between parentheses:'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常函数存在于动态级别，是值的工厂，并且有代表值的参数。参数在括号之间声明：
- en: '[PRE54]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '*Generic types* exist at the static level, are factories for types and have
    parameters representing types. Parameters are declared between angle brackets:'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*泛型类型*存在于静态级别，是类型的工厂，并且有代表类型的参数。参数在尖括号之间声明：'
- en: '[PRE55]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '![Icon “tip”](../Images/0873709827ba4924e4afbb757e47a4df.png) **Naming type
    parameters**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“提示”](../Images/0873709827ba4924e4afbb757e47a4df.png) **命名类型参数**'
- en: In TypeScript, it is common to use a single uppercase character (such as `T`,
    `I`, and `O`) for a type parameter. However, any legal JavaScript identifier is
    allowed and longer names often make code easier to understand.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，通常使用单个大写字母（如`T`、`I`和`O`）作为类型参数。然而，任何合法的JavaScript标识符都是允许的，较长的名称往往使代码更容易理解。
- en: '[4.16.1 Example: a container for values](#example-a-container-for-values)'
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.16.1 示例：值的容器](#example-a-container-for-values)'
- en: '[PRE56]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`Value` is a *type variable*. One or more type variables can be introduced
    between angle brackets.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`Value`是一个*类型变量*。一个或多个类型变量可以在尖括号之间引入。'
- en: '[4.16.2 Example: a generic class](#example-a-generic-class)'
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.16.2 示例：一个泛型类](#example-a-generic-class)'
- en: 'Classes can have type parameters, too:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 类也可以有类型参数：
- en: '[PRE57]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Class `SimpleStack` has the type parameter `Elem`. When we instantiate the
    class, we also provide a value for the type parameter:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 类`SimpleStack`有一个类型参数`Elem`。当我们实例化类时，我们也为类型参数提供一个值：
- en: '[PRE58]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[4.16.3 Example: Maps](#example-maps)'
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.16.3 示例：映射](#example-maps)'
- en: 'Maps are typed generically in TypeScript. For example:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript中的映射是泛型类型的。例如：
- en: '[PRE59]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Thanks to type inference (based on the argument of `new Map()`), we can omit
    the type parameters:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了类型推断（基于`new Map()`的参数），我们可以省略类型参数：
- en: '[PRE60]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[4.16.4 Functions and methods with type parameters](#functions-and-methods-with-type-parameters)'
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.16.4 带类型参数的函数和方法](#functions-and-methods-with-type-parameters)'
- en: 'Function definitions can introduce type variables like this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义可以引入类型变量，如下所示：
- en: '[PRE61]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We use the function as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用该函数：
- en: '[PRE62]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Due to type inference, we can once again omit the type parameter:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型推断，我们再次可以省略类型参数：
- en: '[PRE63]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The type of `num2` is the number literal type `123`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`num2`的类型是数字字面量类型`123`。'
- en: '[4.16.4.1 Arrow functions with type parameters](#arrow-functions-with-type-parameters)'
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[4.16.4.1 带类型参数的箭头函数](#arrow-functions-with-type-parameters)'
- en: 'Arrow functions can also have type parameters:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数也可以有类型参数：
- en: '[PRE64]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[4.16.4.2 Methods with type parameters](#methods-with-type-parameters)'
  id: totrans-332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[4.16.4.2 带类型参数的方法](#methods-with-type-parameters)'
- en: 'This is the type parameter syntax for methods:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这是方法类型参数的语法：
- en: '[PRE65]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[4.16.4.3 A more complicated function example](#a-more-complicated-function-example)'
  id: totrans-335
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[4.16.4.3 更复杂的函数示例](#a-more-complicated-function-example)'
- en: '[PRE66]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The type variable `T` appears four times in this code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 类型变量`T`在这段代码中出现了四次：
- en: It is introduced via `fillArray<T>`. Therefore, its scope is the function.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过`fillArray<T>`引入。因此，它的作用域是函数。
- en: It is used for the first time in the type annotation for the parameter `elem`.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在参数`elem`的类型注解中首次使用。
- en: It is used for the second time to specify the return type of `fillArray()`.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在`fillArray()`的返回类型中第二次使用。
- en: It is also used as a type argument for the constructor `Array()`.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它也被用作构造函数`Array()`的类型参数。
- en: 'We can omit the type parameter when calling `fillArray()` (line A) because
    TypeScript can infer `T` from the parameter `elem`:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`fillArray()`时（行A），我们可以省略类型参数，因为TypeScript可以从参数`elem`推断出`T`：
- en: '[PRE67]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[4.17 Conclusion: understanding the initial example](#conclusion-understanding-the-initial-example)'
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.17 结论：理解初始示例](#conclusion-understanding-the-initial-example)'
- en: 'Let’s use what we have learned to understand the piece of code we have seen
    earlier:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用我们所学的知识来理解我们之前看到的代码片段：
- en: '[PRE68]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This is an interface for Arrays whose elements are of type `T`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个元素类型为`T`的数组接口：
- en: 'method `.concat()`:'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法`.concat()`：
- en: Has zero or more parameters (defined via a rest parameter). Each of those parameters
    has the type `T[]|T`. That is, it is either an Array of `T` values or a single
    `T` value. That means that the values in `items` have the same type `T` as the
    values in `this` (the receiver of the method call).
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有零个或多个参数（通过剩余参数定义）。每个参数的类型为`T[]|T`。也就是说，它要么是一个`T`值的数组，要么是一个单个的`T`值。这意味着`items`中的值与`this`（方法调用的接收者）中的值的类型`T`相同。
- en: Returns an Array whose elements also have the type `T`.
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个元素类型也为 `T` 的数组。
- en: 'method `.reduce()` introduces its own type variable `U`. `U` is used to express
    the fact that the following entities all have the same type:'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法 `.reduce()` 引入了它自己的类型变量 `U`。`U` 用于表达以下实体都具有相同类型的事实：
- en: Parameter `state` of `callback()`
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback()` 的参数 `state`'
- en: Result of `callback()`
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback()` 的结果'
- en: Optional parameter `firstState` of `.reduce()`
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.reduce()` 的可选参数 `firstState`'
- en: Result of `.reduce()`
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.reduce()` 的结果'
- en: 'In addition to `state`, `callback()` has the following parameters:'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了 `state`，`callback()` 还有以下参数：
- en: '`element`: which has the same type `T` as the Array elements'
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`element`：它具有与数组元素相同的类型 `T`'
- en: '`index`: a number'
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`：一个数字'
- en: '[4.18 Next steps](#next-steps)'
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.18 下一步](#next-steps)'
- en: 'Next, you’ll probably want to read [“How TypeScript is used: workflows, tools,
    etc.” (§6)](ch_typescript-workflows.html#ch_typescript-workflows) – which gives
    you a better understanding of how TypeScript is used in practice.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，你可能想阅读[“TypeScript 的使用方式：工作流程、工具等”（§6）](ch_typescript-workflows.html#ch_typescript-workflows)——这能让你更好地理解
    TypeScript 在实际中的应用。
- en: Then you can move on to the rest of the book.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，你可以继续阅读本书的其余部分。
- en: While using TypeScript, keep the following tip in mind.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 TypeScript 时，请记住以下提示。
- en: '[4.18.1 Tip: Use `strict` type checking whenever you can](#tip-use-strict-type-checking-whenever-you-can)'
  id: totrans-363
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[4.18.1 提示：尽可能使用 `strict` 类型检查](#tip-use-strict-type-checking-whenever-you-can)'
- en: 'There are many ways in which the TypeScript compiler can be configured. One
    important group of options controls how strictly the compiler checks TypeScript
    code. My recommendation is:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 编译器可以配置的有很多种方式。其中一组重要的选项控制编译器如何严格检查 TypeScript 代码。我的建议是：
- en: Option `strict` should always be enabled.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项 `strict` 应始终启用。
- en: 'There are a few additional settings that increase strictness even further:
    I’d start with all of them and deactivate those whose errors you don’t like or
    don’t want to deal with.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一些额外的设置可以进一步提高严格性：我会从所有这些设置开始，然后禁用那些你不喜欢的或不想处理的错误。
- en: You may be tempted to use settings that produce fewer compiler errors. However,
    without `strict` checking, TypeScript simply doesn’t work as well and will detect
    far fewer problems in your code.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想使用产生更少编译器错误的设置。然而，没有 `strict` 检查，TypeScript 的表现将大打折扣，并且它将检测你代码中的问题要少得多。
- en: For more information on configuring TypeScript, see [“Guide to `tsconfig.json`”
    (§8)](ch_tsconfig-json.html#ch_tsconfig-json).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于配置 TypeScript 的信息，请参阅[“`tsconfig.json` 指南”（§8）](ch_tsconfig-json.html#ch_tsconfig-json)。
