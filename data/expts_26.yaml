- en: 21 Class definitions in TypeScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 21 TypeScript中的类定义
- en: 原文：[https://exploringjs.com/ts/book/ch_class-definitions.html](https://exploringjs.com/ts/book/ch_class-definitions.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/ts/book/ch_class-definitions.html](https://exploringjs.com/ts/book/ch_class-definitions.html)
- en: (Ad, please don’t block.)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: (Ad, please don’t block.)
- en: '[21.1 Cheat sheet: classes in plain JavaScript](#cheat-sheet-classes-in-plain-javascript)'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.1 纯JavaScript中的类速查表](#cheat-sheet-classes-in-plain-javascript)'
- en: '[21.1.1 Basic members of classes](#basic-members-of-classes)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.1.1 类的基本成员](#basic-members-of-classes)'
- en: '[21.1.2 Modifier: `static`](#modifier-static)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.1.2 修饰符：`static`](#modifier-static)'
- en: '[21.1.3 Modifier-like name prefix: `#` (private)](#modifier-like-name-prefix-private)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.1.3 类似修饰符的名称前缀：`#` (私有)](#modifier-like-name-prefix-private)'
- en: '[21.1.4 Modifiers for accessors: `get` (getter) and `set` (setter)](#modifiers-for-accessors-get-getter-and-set-setter)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.1.4 访问器修饰符：`get` (getter) 和 `set` (setter)](#modifiers-for-accessors-get-getter-and-set-setter)'
- en: '[21.1.5 Modifier for methods: `*` (generator)](#modifier-for-methods-generator)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.1.5 方法修饰符：`*` (生成器)](#modifier-for-methods-generator)'
- en: '[21.1.6 Modifier for methods: `async`](#modifier-for-methods-async)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.1.6 方法修饰符：`async`](#modifier-for-methods-async)'
- en: '[21.1.7 Computed class member names](#computed-class-member-names)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.1.7 计算类成员名称](#computed-class-member-names)'
- en: '[21.1.8 Combinations of modifiers](#combinations-of-modifiers)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.1.8 修饰符的组合](#combinations-of-modifiers)'
- en: '[21.1.9 Under the hood](#under-the-hood)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.1.9 内部机制](#under-the-hood)'
- en: '[21.1.10 More information on class definitions in plain JavaScript](#more-information-on-class-definitions-in-plain-javascript)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.1.10 关于纯JavaScript中类定义的更多信息](#more-information-on-class-definitions-in-plain-javascript)'
- en: '[21.2 Non-public data slots in TypeScript](#non-public-data-slots-in-typescript)'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.2 TypeScript中的非公共数据槽](#non-public-data-slots-in-typescript)'
- en: '[21.2.1 Private properties](#private-properties)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.2.1 私有属性](#private-properties)'
- en: '[21.2.2 Private fields](#private-fields)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.2.2 私有字段](#private-fields)'
- en: '[21.2.3 Private properties vs. private fields](#private-properties-vs-private-fields)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.2.3 私有属性与私有字段](#private-properties-vs-private-fields)'
- en: '[21.2.4 Protected properties](#protected-properties)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.2.4 受保护的属性](#protected-properties)'
- en: '[21.3 Private constructors](#private-constructors)'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.3 私有构造函数](#private-constructors)'
- en: '[21.4 Initializing instance properties](#initializing-instance-properties)'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.4 初始化实例属性](#initializing-instance-properties)'
- en: '[21.4.1 Strict property initialization](#strictPropertyInitialization)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.4.1 严格的属性初始化](#strictPropertyInitialization)'
- en: '[21.5 Convenience features we should avoid](#convenience-features-we-should-avoid)'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.5 我们应该避免的便利特性](#convenience-features-we-should-avoid)'
- en: '[21.5.1 Inferred member types](#inferred-member-types)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.5.1 推断成员类型](#inferred-member-types)'
- en: '[21.5.2 Making constructor parameters `public`, `private` or `protected`](#making-constructor-parameters-public-private-or-protected)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.5.2 将构造函数参数设置为 `public`、`private` 或 `protected`](#making-constructor-parameters-public-private-or-protected)'
- en: '[21.6 Abstract classes](#abstract-classes)'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.6 抽象类](#abstract-classes)'
- en: '[21.7 Keyword `override` for methods](#override)'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.7 方法关键字 `override`](#override)'
- en: '[21.8 Classes vs. object types](#classes-vs-object-types)'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.8 类与对象类型](#classes-vs-object-types)'
- en: '[21.8.1 Class `Counter`](#class-counter)'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.8.1 类 `Counter`](#class-counter)'
- en: '[21.8.2 Object type `Counter`](#object-type-counter)'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.8.2 对象类型 `Counter`](#object-type-counter)'
- en: '[21.8.3 Which one to choose: class or object type?](#which-one-to-choose-class-or-object-type)'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[21.8.3 选择类或对象类型？](#which-one-to-choose-class-or-object-type)'
- en: 'In this chapter, we examine how class definitions work in TypeScript:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨TypeScript中类定义的工作方式：
- en: First, we take a quick look at the features of class definitions in plain JavaScript.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们快速浏览一下纯JavaScript中类定义的特性。
- en: Then we explore what additions TypeScript brings to the table.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们探讨TypeScript带来了哪些新增特性。
- en: '[21.1 Cheat sheet: classes in plain JavaScript](#cheat-sheet-classes-in-plain-javascript)'
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[21.1 纯JavaScript中的类速查表](#cheat-sheet-classes-in-plain-javascript)'
- en: This section is a cheat sheet for class definitions in plain JavaScript.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是关于纯JavaScript中类定义的速查表。
- en: '[21.1.1 Basic members of classes](#basic-members-of-classes)'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[21.1.1 类的基本成员](#basic-members-of-classes)'
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Icon “reading”](../Images/00b0d6029a045810b908b88d1a6733d2.png) **The next
    sections are about modifiers**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![阅读图标](../Images/00b0d6029a045810b908b88d1a6733d2.png) **下一节将介绍修饰符**  '
- en: At the end, there is a table that shows how modifiers can be combined.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个表格显示了修饰符如何组合。
- en: '[21.1.2 Modifier: `static`](#modifier-static)'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[21.1.2 修饰符：`static`](#modifier-static)'
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[21.1.3 Modifier-like name prefix: `#` (private)](#modifier-like-name-prefix-private)'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[21.1.3 类似修饰符的名称前缀：`#` (私有)](#modifier-like-name-prefix-private)'
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[21.1.4 Modifiers for accessors: `get` (getter) and `set` (setter)](#modifiers-for-accessors-get-getter-and-set-setter)'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[21.1.4 访问器的修饰符：`get` (获取器) 和 `set` (设置器)](#modifiers-for-accessors-get-getter-and-set-setter)'
- en: 'Roughly, accessors are prototype methods that are inherited by instances and
    invoked by accessing properties. There are two kinds of accessors: getters and
    setters.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 大概来说，访问器是继承自实例并由属性访问调用的原型方法。有两种类型的访问器：获取器和设置器。
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[21.1.5 Modifier for methods: `*` (generator)](#modifier-for-methods-generator)'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[21.1.5 方法的修饰符：`*` (生成器)](#modifier-for-methods-generator)'
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[21.1.6 Modifier for methods: `async`](#modifier-for-methods-async)'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[21.1.6 方法的修饰符：`async`](#modifier-for-methods-async)'
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[21.1.7 Computed class member names](#computed-class-member-names)'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[21.1.7 计算类成员名称](#computed-class-member-names)'
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Comments:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注释：
- en: The main use case for this feature is symbols such as `Symbol.iterator`. But
    any expression can be used inside the square brackets.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此功能的用例主要是像 `Symbol.iterator` 这样的符号。但任何表达式都可以在方括号内使用。
- en: We can compute the names of fields, methods, and accessors.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以计算字段、方法和访问器的名称。
- en: We cannot compute the names of private members (which are always fixed).
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法计算私有成员（它们始终是固定的）的名称。
- en: '[21.1.8 Combinations of modifiers](#combinations-of-modifiers)'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[21.1.8 修饰符的组合](#combinations-of-modifiers)'
- en: 'Fields:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 字段：
- en: '| Level | Private | Code |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 级别 | 私有 | 代码 |'
- en: '| --- | --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| (instance) |  | `field` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| (实例) |  | `field` |'
- en: '| (instance) | `#` | `#field` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| (实例) | `#` | `#field` |'
- en: '| `static` |  | `static field` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `static` |  | `static field` |'
- en: '| `static` | `#` | `static #field` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `static` | `#` | `static #field` |'
- en: 'Methods (columns: Level, Accessor, Async, Generator, Private, Code – without
    body):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 方法（列：级别、访问器、异步、生成器、私有、代码 - 无主体）：
- en: '| Level | Acc | Async | Gen | Priv | Code |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 级别 | 访问器 | 异步 | 生成器 | 私有 | 代码 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| (prototype) |  |  |  |  | `m()` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| (原型) |  |  |  |  | `m()` |'
- en: '| (prototype) | `get` |  |  |  | `get p()` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| (原型) | `get` |  |  |  | `get p()` |'
- en: '| (prototype) | `set` |  |  |  | `set p(x)` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| (原型) | `set` |  |  |  | `set p(x)` |'
- en: '| (prototype) |  | `async` |  |  | `async m()` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| (原型) |  | `async` |  |  | `async m()` |'
- en: '| (prototype) |  |  | `*` |  | `* m()` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| (原型) |  |  | `*` |  | `* m()` |'
- en: '| (prototype) |  | `async` | `*` |  | `async * m()` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| (原型) |  | `async` | `*` |  | `async * m()` |'
- en: '| (prototype-ish) |  |  |  | `#` | `#m()` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| (原型类似) |  |  |  | `#` | `#m()` |'
- en: '| (prototype-ish) | `get` |  |  | `#` | `get #p()` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| (原型类似) | `get` |  |  | `#` | `get #p()` |'
- en: '| (prototype-ish) | `set` |  |  | `#` | `set #p(x)` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| (原型类似) | `set` |  |  | `#` | `set #p(x)` |'
- en: '| (prototype-ish) |  | `async` |  | `#` | `async #m()` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| (原型类似) |  | `async` |  | `#` | `async #m()` |'
- en: '| (prototype-ish) |  |  | `*` | `#` | `* #m()` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| (原型类似) |  |  | `*` | `#` | `* #m()` |'
- en: '| (prototype-ish) |  | `async` | `*` | `#` | `async * #m()` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| (原型类似) |  | `async` | `*` | `#` | `async * #m()` |'
- en: '| `static` |  |  |  |  | `static m()` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `static` |  |  |  |  | `static m()` |'
- en: '| `static` | `get` |  |  |  | `static get p()` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `static` | `get` |  |  |  | `static get p()` |'
- en: '| `static` | `set` |  |  |  | `static set p(x)` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `static` | `set` |  |  |  | `static set p(x)` |'
- en: '| `static` |  | `async` |  |  | `static async m()` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `static` |  | `async` |  |  | `static async m()` |'
- en: '| `static` |  |  | `*` |  | `static * m()` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `static` |  |  | `*` |  | `static * m()` |'
- en: '| `static` |  | `async` | `*` |  | `static async * m()` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `static` |  | `async` | `*` |  | `static async * m()` |'
- en: '| `static` |  |  |  | `#` | `static #m()` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `static` |  |  |  | `#` | `static #m()` |'
- en: '| `static` | `get` |  |  | `#` | `static get #p()` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `static` | `get` |  |  | `#` | `static get #p()` |'
- en: '| `static` | `set` |  |  | `#` | `static set #p(x)` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `static` | `set` |  |  | `#` | `static set #p(x)` |'
- en: '| `static` |  | `async` |  | `#` | `static async #m()` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `static` |  | `async` |  | `#` | `static async #m()` |'
- en: '| `static` |  |  | `*` | `#` | `static * #m()` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `static` |  |  | `*` | `#` | `static * #m()` |'
- en: '| `static` |  | `async` | `*` | `#` | `static async * #m()` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `static` |  | `async` | `*` | `#` | `static async * #m()` |'
- en: '[21.1.9 Under the hood](#under-the-hood)'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[21.1.9 内部机制](#under-the-hood)'
- en: 'It’s important to keep in mind that with classes, there are two chains of prototype
    objects:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在类中，有两个原型对象链：
- en: The instance chain which starts with an instance.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例链从实例开始。
- en: The static chain which starts with the class of that instance.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态链从该实例的类开始。
- en: 'Consider the following plain JavaScript example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下纯 JavaScript 示例：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Figure 21.1](#fig:class-prototype-chains) shows what the prototype chains
    look like that are created by `ClassA` and `ClassB`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 21.1](#fig:class-prototype-chains) 展示了由 `ClassA` 和 `ClassB` 创建的原型链的样子。'
- en: '![](../Images/820493c8f187cebea74380b7ced1d6f2.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/820493c8f187cebea74380b7ced1d6f2.png)'
- en: 'Figure 21.1: The classes `ClassA` and `ClassB` create two prototype chains:
    One for classes (left-hand side) and one for instances (right-hand side).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.1：类 `ClassA` 和 `ClassB` 创建了两个原型链：一个用于类（左侧），另一个用于实例（右侧）。
- en: '[21.1.10 More information on class definitions in plain JavaScript](#more-information-on-class-definitions-in-plain-javascript)'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[21.1.10 关于纯 JavaScript 中类定义的更多信息](#more-information-on-class-definitions-in-plain-javascript)'
- en: '[Chapter “Classes”](https://exploringjs.com/js/book/ch_classes.html) in “Exploring
    JavaScript”'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Exploring JavaScript”中的“类”章节 [Chapter “Classes”](https://exploringjs.com/js/book/ch_classes.html)
- en: '[21.2 Non-public data slots in TypeScript](#non-public-data-slots-in-typescript)'
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[21.2 TypeScript 中的非公共数据槽位](#non-public-data-slots-in-typescript)'
- en: 'By default, all data slots in TypeScript are public properties. There are two
    ways of keeping data private:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，TypeScript 中的所有数据槽位都是公共属性。有两种方法可以使数据保持私有：
- en: Private properties
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有属性
- en: Private fields
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有字段
- en: We’ll look at both next.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下面查看这两个特性。
- en: Note that TypeScript does not currently support private methods.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，TypeScript 目前不支持私有方法。
- en: '[21.2.1 Private properties](#private-properties)'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[21.2.1 私有属性](#private-properties)'
- en: 'Private properties are a TypeScript-only (static) feature. Any property can
    be made private by prefixing it with the keyword `private` (line A):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 私有属性是 TypeScript 独有的（静态）特性。任何属性都可以通过在它前面加上关键字 `private` 来使其变为私有（行 A）：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We now get compile-time errors if we access that property in the wrong scope
    (line A):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在错误的范围内访问该属性，现在我们将得到编译时错误（行 A）：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However, `private` doesn’t change anything at runtime. There, property `.name`
    is indistinguishable from a public property:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`private` 在运行时并不会改变任何事情。在那里，属性 `.name` 与公共属性没有区别：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also see that private properties aren’t protected at runtime when we
    look at the JavaScript code that the class is compiled to:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看类编译成的 JavaScript 代码，我们可以看到私有属性在运行时并没有受到保护：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[21.2.2 Private fields](#private-fields)'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[21.2.2 私有字段](#private-fields)'
- en: 'Private fields are a new JavaScript feature that TypeScript has supported since
    version 3.8:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 私有字段是 JavaScript 中的一个新特性，TypeScript 从 3.8 版本开始支持：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This version of `Person` is mostly used the same way as the private property
    version:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的 `Person` 主要以与私有属性版本相同的方式使用：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, this time, the data is completely encapsulated. Using the private
    field syntax outside classes is even a JavaScript syntax error. That’s why we
    have to use `eval()` in line A so that we can execute this code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这次，数据是完全封装的。在类外使用私有字段语法甚至会导致 JavaScript 语法错误。这就是为什么我们不得不在行 A 中使用 `eval()`
    来执行此代码的原因：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Compiled to JavaScript, `PersonPrivateField` looks more or less the same:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 编译成 JavaScript 后，`PersonPrivateField` 看起来几乎相同：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[21.2.3 Private properties vs. private fields](#private-properties-vs-private-fields)'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[21.2.3 私有属性与私有字段](#private-properties-vs-private-fields)'
- en: 'Downsides of private properties:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有属性的不利之处：
- en: We can’t reuse the names of private properties in subclasses (because the properties
    aren’t private at runtime).
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能在子类中重用私有属性的名字（因为属性在运行时不是私有的）。
- en: No encapsulation at runtime.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时没有封装。
- en: 'Upsides of private properties:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有属性的优势：
- en: 'Clients can circumvent the encapsulation and access private properties. This
    can be useful if someone needs to work around a bug. In other words: Data being
    completely encapsulated has pros and cons.'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端可以绕过封装并访问私有属性。如果有人需要绕过错误，这可能是有用的。换句话说：数据完全封装既有优点也有缺点。
- en: Some JavaScript helper functions, e.g. for cloning or for serialization to JSON,
    don’t work with private fields.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些 JavaScript 辅助函数，例如用于克隆或序列化为 JSON 的函数，不与私有字段一起工作。
- en: '[21.2.4 Protected properties](#protected-properties)'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[21.2.4 受保护的属性](#protected-properties)'
- en: 'Private fields and private properties can’t be accessed in subclasses (line
    B):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 私有字段和私有属性在子类中无法访问（行 B）：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The keyword `override` is explained [later](#override) – it’s for methods that
    override super-methods.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `override` 将在 [稍后](#override) 解释——它是用于覆盖超类方法的。
- en: 'We can fix the previous example by switching from `private` to `protected`
    in line A (we also switch in line B, for consistency’s sake):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将行 A 中的 `private` 改为 `protected` 来修复前面的例子（为了保持一致性，我们也在行 B 中进行了更改）：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[21.3 Private constructors](#private-constructors)'
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[21.3 私有构造函数](#private-constructors)'
- en: At the moment, JavaScript does not support hash-private constructors. However,
    TypeScript supports `private` for them. That is useful when we have static factory
    methods and want clients to always use those methods, never the constructor directly.
    Static methods can access private class members, which is why the factory methods
    can still use the constructor.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，JavaScript 不支持哈希私有构造函数。但是 TypeScript 支持 `private`。这在我们有静态工厂方法并且希望客户端始终使用这些方法而不是直接使用构造函数时很有用。静态方法可以访问私有类成员，这就是为什么工厂方法仍然可以使用构造函数。
- en: 'In the following code, there is one static factory method `DataContainer.create()`.
    It sets up instances via asynchronously loaded data. Keeping the asynchronous
    code in the factory method enables the actual class to be completely synchronous:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，有一个静态工厂方法 `DataContainer.create()`。它通过异步加载数据设置实例。将异步代码保留在工厂方法中使得实际类可以完全同步：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In real-world code, we would use `fetch()` or a similar Promise-based API to
    load data asynchronously in line A.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际代码中，我们会在行 A 使用 `fetch()` 或类似的基于 Promise 的 API 来异步加载数据。
- en: The private constructor prevents `DataContainer` from being subclassed. If we
    want to allow subclasses, we have to make it `protected`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 私有构造函数阻止 `DataContainer` 被继承。如果我们想允许子类，我们必须将其设置为 `protected`。
- en: '[21.4 Initializing instance properties](#initializing-instance-properties)'
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[21.4 初始化实例属性](#initializing-instance-properties)'
- en: '[21.4.1 Strict property initialization](#strictPropertyInitialization)'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[21.4.1 严格的属性初始化](#strictPropertyInitialization)'
- en: 'If the compiler setting `--strictPropertyInitialization` is switched on (which
    is the case if we use `--strict`), then TypeScript checks if all declared instance
    properties are correctly initialized:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器设置 `--strictPropertyInitialization` 被打开（如果我们使用 `--strict`，则情况如此），那么 TypeScript
    会检查所有声明的实例属性是否已正确初始化：
- en: 'Either via assignments in the constructor:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要么通过构造函数中的赋值：
- en: '[PRE19]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Or via initializers for the property declarations:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者通过属性声明的初始化器：
- en: '[PRE20]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, sometimes we initialize properties in a manner that TypeScript doesn’t
    recognize. Then we can use exclamation marks (*definite assignment assertions*)
    to switch off TypeScript’s warnings (line A and line B):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时我们以 TypeScript 不认可的方式初始化属性。然后我们可以使用感叹号（*确定赋值断言*）来关闭 TypeScript 的警告（行 A
    和行 B）：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[21.4.1.1 Example: setting up instance properties via objects](#example-setting-up-instance-properties-via-objects)'
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[21.4.1.1 示例：通过对象设置实例属性](#example-setting-up-instance-properties-via-objects)'
- en: 'In the following example, we also need definite assignment assertions. Here,
    we set up instance properties via the constructor parameter `props`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们还需要确定赋值断言。在这里，我们通过构造函数参数 `props` 设置实例属性：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Notes:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项：
- en: 'In line B, we initialize all properties: We use `Object.assign()` to copy the
    properties of parameter `props` into `this`.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行 B 中，我们初始化所有属性：我们使用 `Object.assign()` 将参数 `props` 的属性复制到 `this`。
- en: In line A, the `implements` ensures that the class declares all properties that
    are part of interface `CompilerErrorProps`.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行 A 中，`implements` 确保类声明了接口 `CompilerErrorProps` 的所有属性。
- en: '[21.5 Convenience features we should avoid](#convenience-features-we-should-avoid)'
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[21.5 我们应该避免的便利功能](#convenience-features-we-should-avoid)'
- en: '[21.5.1 Inferred member types](#inferred-member-types)'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[21.5.1 推断成员类型](#inferred-member-types)'
- en: '`tsc` can infer the type of the member `.str` because we assign to it in line
    A. However, that is not compatible with the compiler option [`isolatedDeclarations`](ch_tsconfig-json.html#isolatedDeclarations)
    (which enables external tools to generate declarations without doing inference):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`tsc` 可以推断成员 `.str` 的类型，因为我们已经在行 A 中对其进行了赋值。然而，这与编译器选项 `isolatedDeclarations`（它启用外部工具生成声明而不进行推断）不兼容：'
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[21.5.2 Making constructor parameters `public`, `private` or `protected`](#making-constructor-parameters-public-private-or-protected)'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[21.5.2 使构造函数参数为 `public`、`private` 或 `protected`](#making-constructor-parameters-public-private-or-protected)'
- en: JavaScript currently has no equivalent to the TypeScript feature described in
    this subsection – which is why it is illegal if the compiler option [`erasableSyntaxOnly`](ch_tsconfig-json.html#erasableSyntaxOnly)
    is active.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 目前没有与该子节中描述的 TypeScript 功能等效的功能——这就是为什么如果编译器选项 `erasableSyntaxOnly`（在
    ch_tsconfig-json.html#erasableSyntaxOnly 中描述）处于活动状态，这是非法的。
- en: 'If we use the modifier `public` for a constructor parameter `prop`, then TypeScript
    does two things for us:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为一个构造函数参数 `prop` 使用 `public` 修饰符，那么 TypeScript 会为我们做两件事：
- en: It declares a public instance property `.prop`.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它声明了一个公共实例属性 `.prop`。
- en: It assigns the parameter `prop` to that instance property.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将参数 `prop` 赋值给该实例属性。
- en: 'This is an example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we use `private` or `protected` instead of `public`, then the corresponding
    instance properties are private or protected.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `private` 或 `protected` 而不是 `public`，则相应的实例属性将是私有的或受保护的。
- en: 'The TypeScript class `Point` is compiled to the following JavaScript code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 类 `Point` 编译成以下 JavaScript 代码：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[21.6 Abstract classes](#abstract-classes)'
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[21.6 抽象类](#abstract-classes)'
- en: 'Two constructs can be abstract in TypeScript:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 中有两种结构可以是抽象的：
- en: An abstract class can’t be instantiated. Only its subclasses can – if they are
    not abstract, themselves.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类不能被实例化。只有它的子类可以 – 如果它们自身不是抽象的。
- en: An abstract method has no implementation, only a type signature. Each concrete
    subclass must have a concrete method with the same name and a compatible type
    signature.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象方法没有实现，只有类型签名。每个具体的子类都必须有一个具有相同名称和兼容类型签名的具体方法。
- en: If a class has any abstract methods, it must be abstract, too.
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个类有任何抽象方法，它也必须是抽象的。
- en: The following code demonstrates abstract classes and methods.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了抽象类和方法。
- en: 'On one hand, there is the abstract superclass `Printable` and its helper class
    `StringBuilder`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，有抽象超类 `Printable` 和其辅助类 `StringBuilder`：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On the other hand, there are the concrete subclasses `Entries` and `Entry`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有具体的子类 `Entries` 和 `Entry`：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And finally, this is us using `Entries` and `Entry`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是我们使用 `Entries` 和 `Entry` 的例子：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Notes about abstract classes:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 关于抽象类的注意事项：
- en: An abstract class can be seen as an interface where some members already have
    implementations.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类可以被视为一个接口，其中一些成员已经有了实现。
- en: While a class can implement multiple interfaces, it can only extend at most
    one abstract class.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然 class 可以实现多个接口，但它只能扩展最多一个抽象类。
- en: “Abstractness” only exists at compile time. At runtime, abstract classes are
    normal classes and abstract methods don’t exist (due to them only providing compile-time
    information).
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “抽象性”仅在编译时存在。在运行时，抽象类是普通类，抽象方法不存在（因为它们只提供编译时信息）。
- en: Abstract classes can be seen as templates where each abstract method is a blank
    that has to be filled in (implemented) by subclasses.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类可以被视为模板，其中每个抽象方法都是一个需要由子类填充（实现）的空白。
- en: '[21.7 Keyword `override` for methods](#override)'
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[21.7 方法关键字 `override`](#override)'
- en: 'The keyword `override` is for methods that override methods in superclasses
    – e.g.:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `override` 用于覆盖超类中的方法 – 例如：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If the compiler option [`noImplicitOverride`](ch_tsconfig-json.html#noImplicitOverride)
    is active then TypeScript complains if there is no `override` in line A.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器选项 `noImplicitOverride`（在 ch_tsconfig-json.html#noImplicitOverride 中）处于活动状态，那么
    TypeScript 如果在行 A 中没有 `override`，则会报错。
- en: 'We can also use `override` when we implement an abstract method. That’s not
    required but I find it useful information:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现抽象方法时，我们也可以使用 `override`。这不是必需的，但我发现这是一个有用的信息：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[21.8 Classes vs. object types](#classes-vs-object-types)'
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[21.8 类与对象类型](#classes-vs-object-types)'
- en: In JavaScript, we don’t have to use classes, we can also use objects directly.
    TypeScript supports both approaches.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，我们不必使用类，我们也可以直接使用对象。TypeScript 支持这两种方法。
- en: '[21.8.1 Class `Counter`](#class-counter)'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[21.8.1 类 `Counter`](#class-counter)'
- en: 'This is a class that implements a counter:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实现计数器的类：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[21.8.2 Object type `Counter`](#object-type-counter)'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[21.8.2 对象类型 `Counter`](#object-type-counter)'
- en: 'In TypeScript, a class defines both a type and a factory for instances. In
    the following code, both are separate: We have the object type `Counter` and the
    factory `createCounter()`.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，一个类定义了类型和实例工厂。在以下代码中，它们是分开的：我们有对象类型 `Counter` 和工厂 `createCounter()`。
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[21.8.3 Which one to choose: class or object type?](#which-one-to-choose-class-or-object-type)'
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[21.8.3 选择哪个：类或对象类型？](#which-one-to-choose-class-or-object-type)'
- en: 'Benefits of classes:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 类的益处：
- en: 'Everything is specified compactly in one place:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有内容都在一个地方紧凑地指定：
- en: Type
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型
- en: Instance factory
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例工厂
- en: Operations such as `inc`
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inc` 等操作'
- en: The default value of a property being specified close to the definition of that
    property is something I find useful – e.g., `.count` has the default value 0.
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性默认值靠近其定义的地方指定是我想找到的有用之处 – 例如，`.count` 的默认值是 0。
- en: We can check the type of a value via `instanceof` – e.g. to narrow a type.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过 `instanceof` 检查一个值的类型 – 例如，用于缩小类型。
- en: We can use private fields.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用私有字段。
- en: 'Benefits of object types:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对象类型的益处：
- en: 'They work better if objects are cloned: Library functions for cloning can’t
    handle private fields and [`structuredClone()`](https://2ality.com/2022/01/structured-clone.html)
    does not preserve the class of an instance.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象被克隆，它们的工作效果会更好：用于克隆的库函数无法处理私有字段，而[`structuredClone()`](https://2ality.com/2022/01/structured-clone.html)不会保留实例的类。
- en: 'They work better if objects are moved between realms: Each realm has its own
    version of a given class and that makes moving class instances problematic.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象在领域之间移动，它们的工作效果会更好：每个领域都有自己的给定类的版本，这使得移动类实例变得有问题。
- en: 'Serializing and deserializing (to/from JSON etc.) is an interesting use case:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化和反序列化（到/从 JSON 等）是一个有趣的用例：
- en: With object types, deserialization is easier because we can immediate work with
    the result of `JSON.parse()` (potentially after [validating the type via Zod](ch_validating-external-data.html#ch_validating-external-data)).
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象类型，反序列化会更简单，因为我们可以直接使用`JSON.parse()`的结果（可能是在通过 Zod [验证类型](ch_validating-external-data.html#ch_validating-external-data)之后）。
- en: 'Things get more complicated if not all data can be easily serialized and deserialized
    – e.g. if a property contains a `Map`. Then classes have one benefit: We can customize
    serialization by implementing the method `.toJSON()`.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不是所有数据都可以轻松序列化和反序列化，事情会变得更加复杂——例如，如果属性包含一个`Map`。那么，类有一个好处：我们可以通过实现方法`.toJSON()`来自定义序列化。
- en: Apart from these criteria, which one to choose depends on whether you prefer
    code that is more object-oriented or code that is more functional.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些标准之外，选择哪一个取决于你是否更喜欢更面向对象的代码或更函数式的代码。
- en: We have not covered inheritance – where you also have a choice between an object-oriented
    coding style (classes) and a functional coding style (discriminated unions). For
    more information, see [“Class hierarchies vs. discriminated unions” (§19.3)](ch_unions-object-types.html#class-hierarchies-vs-discriminated-unions).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有涵盖继承——在那里，你也有选择面向对象编码风格（类）和函数式编码风格（区分联合）之间的选择。更多信息，请参阅[“类层次结构 vs. 区分联合”（§19.3）](ch_unions-object-types.html#class-hierarchies-vs-discriminated-unions)。
