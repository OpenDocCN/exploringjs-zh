- en: '4 An overview of Node.js: architecture, APIs, event loop, concurrency'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 Node.js概述：架构、API、事件循环、并发性
- en: 原文：[https://exploringjs.com/nodejs-shell-scripting/ch_nodejs-overview.html](https://exploringjs.com/nodejs-shell-scripting/ch_nodejs-overview.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/nodejs-shell-scripting/ch_nodejs-overview.html](https://exploringjs.com/nodejs-shell-scripting/ch_nodejs-overview.html)
- en: '* * *'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 4.1 [The Node.js platform](ch_nodejs-overview.html#the-node.js-platform)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.1 [Node.js平台](ch_nodejs-overview.html#the-node.js-platform)
- en: 4.1.1 [Global Node.js variables](ch_nodejs-overview.html#global-node.js-variables)
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.1.1 [全局Node.js变量](ch_nodejs-overview.html#global-node.js-variables)
- en: 4.1.2 [The built-in Node.js modules](ch_nodejs-overview.html#the-built-in-node.js-modules)
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.1.2 [内置Node.js模块](ch_nodejs-overview.html#the-built-in-node.js-modules)
- en: 4.1.3 [The different styles of Node.js functions](ch_nodejs-overview.html#the-different-styles-of-node.js-functions)
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.1.3 [Node.js函数的不同风格](ch_nodejs-overview.html#the-different-styles-of-node.js-functions)
- en: 4.2 [The Node.js event loop](ch_nodejs-overview.html#the-node.js-event-loop)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.2 [Node.js事件循环](ch_nodejs-overview.html#the-node.js-event-loop)
- en: 4.2.1 [Running to completion makes code simpler](ch_nodejs-overview.html#running-to-completion-makes-code-simpler)
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.2.1 [运行到完成使代码更简单](ch_nodejs-overview.html#running-to-completion-makes-code-simpler)
- en: 4.2.2 [Why does Node.js code run in a single thread?](ch_nodejs-overview.html#why-does-node.js-code-run-in-a-single-thread)
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.2.2 [为什么Node.js代码在单线程中运行？](ch_nodejs-overview.html#why-does-node.js-code-run-in-a-single-thread)
- en: 4.2.3 [The real event loop has multiple phases](ch_nodejs-overview.html#the-real-event-loop-has-multiple-phases)
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.2.3 [真实的事件循环有多个阶段](ch_nodejs-overview.html#the-real-event-loop-has-multiple-phases)
- en: 4.2.4 [Next-tick tasks and microtasks](ch_nodejs-overview.html#next-tick-tasks-and-microtasks)
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.2.4 [Next-tick任务和微任务](ch_nodejs-overview.html#next-tick-tasks-and-microtasks)
- en: 4.2.5 [Comparing different ways of directly scheduling tasks](ch_nodejs-overview.html#comparing-different-ways-of-directly-scheduling-tasks)
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.2.5 [比较直接调度任务的不同方式](ch_nodejs-overview.html#comparing-different-ways-of-directly-scheduling-tasks)
- en: 4.2.6 [When does a Node.js app exit?](ch_nodejs-overview.html#when-does-a-node.js-app-exit)
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.2.6 [Node.js应用程序何时退出？](ch_nodejs-overview.html#when-does-a-node.js-app-exit)
- en: '4.3 [libuv: the cross-platform library that handles asynchronous I/O (and more)
    for Node.js](ch_nodejs-overview.html#libuv-the-cross-platform-library-that-handles-asynchronous-io-and-more-for-node.js)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.3 [libuv：处理Node.js异步I/O（以及更多）的跨平台库](ch_nodejs-overview.html#libuv-the-cross-platform-library-that-handles-asynchronous-io-and-more-for-node.js)
- en: 4.3.1 [How libuv handles asynchronous I/O](ch_nodejs-overview.html#how-libuv-handles-asynchronous-io)
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.3.1 [libuv如何处理异步I/O](ch_nodejs-overview.html#how-libuv-handles-asynchronous-io)
- en: 4.3.2 [How libuv handles blocking I/O](ch_nodejs-overview.html#how-libuv-handles-blocking-io)
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.3.2 [libuv如何处理阻塞I/O](ch_nodejs-overview.html#how-libuv-handles-blocking-io)
- en: 4.3.3 [libuv functionality beyond I/O](ch_nodejs-overview.html#libuv-functionality-beyond-io)
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.3.3 [libuv处理异步I/O之外的功能](ch_nodejs-overview.html#libuv-functionality-beyond-io)
- en: 4.4 [Escaping the main thread with user code](ch_nodejs-overview.html#escaping-the-main-thread-with-user-code)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.4 [通过用户代码逃离主线程](ch_nodejs-overview.html#escaping-the-main-thread-with-user-code)
- en: 4.4.1 [Worker threads](ch_nodejs-overview.html#worker-threads)
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.4.1 [工作线程](ch_nodejs-overview.html#worker-threads)
- en: 4.4.2 [Clusters](ch_nodejs-overview.html#clusters)
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.4.2 [集群](ch_nodejs-overview.html#clusters)
- en: 4.4.3 [Child processes](ch_nodejs-overview.html#child-processes)
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.4.3 [子进程](ch_nodejs-overview.html#child-processes)
- en: 4.5 [Sources of this chapter](ch_nodejs-overview.html#sources-of-this-chapter)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.5 [本章的来源](ch_nodejs-overview.html#sources-of-this-chapter)
- en: 4.5.1 [Acknowledgement](ch_nodejs-overview.html#acknowledgement)
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.5.1 [致谢](ch_nodejs-overview.html#acknowledgement)
- en: '* * *'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'This chapter gives an overview of how Node.js works:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了Node.js的工作原理：
- en: What its architecture looks like.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的架构是什么样的。
- en: How its APIs are structured.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的API是如何结构化的。
- en: A few highlights of its global variables and built-in modules.
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局变量和内置模块的一些亮点。
- en: How it runs JavaScript in a single thread via an *event loop*.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它如何通过*事件循环*在单线程中运行JavaScript。
- en: Options for concurrent JavaScript on this platform.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个平台上并发JavaScript的选项。
- en: 4.1 The Node.js platform
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1 Node.js平台
- en: 'The following diagram provides an overview of how Node.js is structured:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表概述了Node.js的结构：
- en: '![](../Images/a4e5a698987cc980760cc6874988c161.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a4e5a698987cc980760cc6874988c161.png)'
- en: 'The APIs available to a Node.js app consist of:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js应用程序可用的API包括：
- en: The ECMAScript standard library (which is part of the language)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript标准库（它是语言的一部分）
- en: 'Node.js APIs (which are not part of the language proper):'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js的API（不是语言本身的一部分）：
- en: 'Some of the APIs are provided via global variables:'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些API是通过全局变量提供的：
- en: Especially cross-platform web APIs such as `fetch` and `CompressionStream` fall
    into this category.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特别是跨平台的web API，比如`fetch`和`CompressionStream`属于这一类别。
- en: But a few Node.js-only APIs are global, too – for example, `process`.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是一些仅适用于Node.js的API也是全局的，例如`process`。
- en: The remaining Node.js APIs are provided via built-in modules – for example,
    `'node:path'` (functions and constants for handling file system paths) and `'node:fs'`
    (functionality related to the file system).
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余的Node.js API是通过内置模块提供的 - 例如，`'node:path'`（处理文件系统路径的函数和常量）和`'node:fs'`（与文件系统相关的功能）。
- en: The Node.js APIs are partially implemented in JavaScript, partially in C++.
    The latter is needed to interface with the operating system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的API部分是用JavaScript实现的，部分是用C++实现的。后者是为了与操作系统进行接口。
- en: Node.js runs JavaScript via an embedded V8 JavaScript engine (the same engine
    used by Google’s Chrome browser).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js通过嵌入的V8 JavaScript引擎运行JavaScript（与Google的Chrome浏览器使用的相同引擎）。
- en: 4.1.1 Global Node.js variables
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1 [全局Node.js变量](ch_nodejs-overview.html#global-node.js-variables)
- en: 'These are a few highlights of [Node’s global variables](https://nodejs.org/api/globals.html):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是[Node的全局变量](https://nodejs.org/api/globals.html)的一些亮点：
- en: '`crypto` gives us access to a web-compatible [crypto API](https://developer.mozilla.org/en-US/docs/Web/API/crypto_property).'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crypto`让我们可以访问与web兼容的[crypto API](https://developer.mozilla.org/en-US/docs/Web/API/crypto_property)。'
- en: '`console` has much overlap with the same global variable in browsers (`console.log()`
    etc.).'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`console`与浏览器中的全局变量（`console.log()`等）有很多重叠。'
- en: '`fetch()` lets us use [the Fetch browser API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch()`让我们可以使用[Fetch浏览器API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)。'
- en: '`process` contains an instance of [class `Process`](https://nodejs.org/api/process.html)
    and gives us access to command line arguments, standard input, standard out, and
    more.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process`包含一个[类`Process`的实例](https://nodejs.org/api/process.html)，并且让我们访问命令行参数、标准输入、标准输出等。'
- en: '`structuredClone()` is a browser-compatible function for cloning objects.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`structuredClone()`是一个兼容浏览器的用于克隆对象的函数。'
- en: '`URL` is a browser-compatible class for handling URLs.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URL`是一个处理URL的兼容浏览器的类。'
- en: More global variables are mentioned throughout this chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中还提到了更多的全局变量。
- en: 4.1.1.1 Using modules instead of global variables
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.1.1.1 使用模块而不是全局变量
- en: 'The following built-in modules provide alternatives to global variables:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内置模块提供了全局变量的替代方案：
- en: '`''node:console''` is an alternative to the global variable `console`:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''node:console''`是全局变量`console`的替代方案：'
- en: '[PRE0]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`''node:process''` is an alternative to the global variable `process`:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''node:process''`是全局变量`process`的替代方案：'
- en: '[PRE1]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In principle, using modules is cleaner than using global variables. However,
    using the global variables `console` and `process` are such established patterns
    that deviating from them also has downsides.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，使用模块比使用全局变量更清晰。然而，使用全局变量`console`和`process`是已经建立的模式，偏离这些模式也有缺点。
- en: 4.1.2 The built-in Node.js modules
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2 内置的Node.js模块
- en: 'Most of Node’s APIs are provided via modules. These are a few frequently used
    ones (in alphabetical order):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Node的大多数API都是通过模块提供的。以下是一些经常使用的模块（按字母顺序排列）：
- en: '[`''node:assert/strict''`](https://nodejs.org/api/assert.html): Assertions
    are functions that check if a condition is met and report an error if not. They
    can be used in application code and for unit testing. This is an example of using
    this API:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`''node:assert/strict''`](https://nodejs.org/api/assert.html)：断言是检查条件是否满足并在不满足时报告错误的函数。它们可以用于应用程序代码和单元测试。这是使用此API的一个例子：'
- en: '[PRE2]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[`''node:child_process''`](https://nodejs.org/api/child_process.html) is for
    running native commands synchronously or in separate processes. This module is
    described in [§12 “Running shell commands in child processes”](ch_nodejs-child-process.html).'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`''node:child_process''`](https://nodejs.org/api/child_process.html) 用于同步或在单独的进程中运行本机命令。该模块在[§12“在子进程中运行shell命令”](ch_nodejs-child-process.html)中有描述。'
- en: '[`''node:fs''`](https://nodejs.org/api/fs.html) provides file system operations
    such as reading, writing, copying and deleting files and directories. For more
    information, see [§8 “Working with the file system on Node.js”](ch_nodejs-file-system.html).'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`''node:fs''`](https://nodejs.org/api/fs.html) 提供了文件系统操作，如读取、写入、复制和删除文件和目录。更多信息，请参见[§8“在Node.js上处理文件系统”](ch_nodejs-file-system.html)。'
- en: '[`''node:os''`](https://nodejs.org/api/os.html) contains operating-system-specific
    constants and utility functions. Some of them are explained in [§7 “Working with
    file system paths and file URLs on Node.js”](ch_nodejs-path.html).'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`''node:os''`](https://nodejs.org/api/os.html) 包含特定于操作系统的常量和实用函数。其中一些在[§7“在Node.js上处理文件系统路径和文件URL”](ch_nodejs-path.html)中有解释。'
- en: '[`''node:path''`](https://nodejs.org/api/path.html) is a cross-platform API
    for working with file system paths. It is described in [§7 “Working with file
    system paths and file URLs on Node.js”](ch_nodejs-path.html).'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`''node:path''`](https://nodejs.org/api/path.html) 是一个用于处理文件系统路径的跨平台API。它在[§7“在Node.js上处理文件系统路径和文件URL”](ch_nodejs-path.html)中有描述。'
- en: '[`''node:stream''`](https://nodejs.org/api/stream.html) contains a Node.js-specific
    streams API which are explained in [§9 “Native Node.js streams”](ch_nodejs-streams.html).'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`''node:stream''`](https://nodejs.org/api/stream.html) 包含了一个特定于Node.js的流API，这些流在[§9“原生Node.js流”](ch_nodejs-streams.html)中有解释。'
- en: Node.js also supports [the cross-platform web streams API](https://nodejs.org/api/webstreams.html)
    which is the subject of [§10 “Using web streams on Node.js”](ch_web-streams.html).
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js还支持[跨平台的Web流API](https://nodejs.org/api/webstreams.html)，这是[§10“在Node.js上使用Web流”](ch_web-streams.html)的主题。
- en: '[`''node:util''`](https://nodejs.org/api/util.html) contains various utility
    functions.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`''node:util''`](https://nodejs.org/api/util.html) 包含各种实用函数。'
- en: '[Function `util.parseArgs()`](https://nodejs.org/api/util.html#utilparseargsconfig)
    is described in [§16 “Parsing command line arguments with `util.parseArgs()`”](ch_node-util-parseargs.html).'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[函数`util.parseArgs()`](https://nodejs.org/api/util.html#utilparseargsconfig)在[§16“使用`util.parseArgs()`解析命令行参数”](ch_node-util-parseargs.html)中有描述。'
- en: 'Module `''node:module''` contains function `builtinModules()` which returns
    an Array with the specifiers of all built-in modules:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 模块`'node:module'`包含函数`builtinModules()`，它返回一个包含所有内置模块的规范符号的数组：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 4.1.3 The different styles of Node.js functions
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.3 Node.js函数的不同风格
- en: 'In this section, we use the following import:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用以下导入：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Node’s functions come in three different styles. Let’s look at the built-in
    module `''node:fs''` as an example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Node的函数有三种不同的风格。让我们以内置模块`'node:fs'`为例：
- en: 'A synchronous style with normal functions – for example:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用普通函数的同步风格 - 例如：
- en: '[`fs.readFileSync(path, options?): string|Buffer`](https://nodejs.org/api/fs.html#fsreadfilesyncpath-options)'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`fs.readFileSync(path, options?): string|Buffer`](https://nodejs.org/api/fs.html#fsreadfilesyncpath-options)'
- en: 'Two asynchronous styles:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两种异步风格：
- en: 'An asynchronous style with callback-based functions – for example:'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于回调的异步风格的函数 - 例如：
- en: '[`fs.readFile(path, options?, callback): void`](https://nodejs.org/api/fs.html#fsreadfilepath-options-callback)'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`fs.readFile(path, options?, callback): void`](https://nodejs.org/api/fs.html#fsreadfilepath-options-callback)'
- en: 'An asynchronous style with Promise-based functions – for example:'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于Promise的异步风格的函数 - 例如：
- en: '[`fsPromises.readFile(path, options?): Promise<string|Buffer>`](https://nodejs.org/api/fs.html#fspromisesreadfilepath-options)'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`fsPromises.readFile(path, options?): Promise<string|Buffer>`](https://nodejs.org/api/fs.html#fspromisesreadfilepath-options)'
- en: 'The three examples we have just seen, demonstrate the naming convention for
    functions with similar functionality:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到的三个例子演示了具有类似功能的函数的命名约定：
- en: 'A callback-based function has a base name: `fs.readFile()`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基于回调的函数的基本名称是：`fs.readFile()`
- en: 'Its Promise-based version has the same name, but in a different module: `fsPromises.readFile()`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其基于Promise的版本具有相同的名称，但在不同的模块中：`fsPromises.readFile()`
- en: 'The name of its synchronous version is the base name plus the suffix “Sync”:
    `fs.readFileSync()`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其同步版本的名称是基本名称加上后缀“Sync”：`fs.readFileSync()`
- en: Let’s take a closer look at how these three styles work.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这三种风格是如何工作的。
- en: 4.1.3.1 Synchronous functions
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.1.3.1 同步函数
- en: 'Synchronous functions are simplest – they immediately return values and throw
    errors as exceptions:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 同步函数最简单 - 它们立即返回值并将错误作为异常抛出：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 4.1.3.2 Promise-based functions
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.1.3.2 基于Promise的函数
- en: 'Promise-based functions return Promises that are fulfilled with results and
    rejected with errors:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Promise的函数返回用结果实现的Promise，并用错误拒绝：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note the module specifier in line A: The Promise-based API is located in a
    different module.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第A行中的模块说明符：基于Promise的API位于不同的模块中。
- en: Promises are explained in more detail in [“JavaScript for impatient programmers”](https://exploringjs.com/impatient-js/ch_promises.html).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Promise的更多详细信息，请参阅[“JavaScript for impatient programmers”](https://exploringjs.com/impatient-js/ch_promises.html)。
- en: 4.1.3.3 Callback-based functions
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.1.3.3 基于回调的函数
- en: 'Callback-based functions pass results and errors to callbacks which are their
    last parameters:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 基于回调的函数将结果和错误传递给它们的最后一个参数：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This style is explained in more detail in [the Node.js documentation](https://nodejs.org/en/knowledge/getting-started/control-flow/what-are-callbacks/).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风格在[Node.js文档](https://nodejs.org/en/knowledge/getting-started/control-flow/what-are-callbacks/)中有更详细的解释。
- en: 4.2 The Node.js event loop
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2 Node.js事件循环
- en: 'By default, Node.js executes all JavaScript in a single thread, the *main thread*.
    The main thread continuously runs the *event loop* – a loop that executes chunks
    of JavaScript. Each chunk is a callback and can be considered a cooperatively
    scheduled task. The first task contains the code (coming from a module or standard
    input) that we start Node.js with. Other tasks are usually added later, due to:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Node.js在单个线程中执行所有JavaScript，即*主线程*。主线程不断运行*事件循环* - 一个执行JavaScript块的循环。每个块都是一个回调，可以被视为一个合作调度的任务。第一个任务包含我们使用的代码（来自模块或标准输入）启动Node.js。其他任务通常稍后添加，原因是：
- en: Code manually adding tasks
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动添加任务的代码
- en: I/O (input or output) with the file system, with network sockets, etc.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与文件系统进行I/O（输入或输出），与网络套接字等。
- en: Etc.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等等。
- en: 'A first approximation of the event loop looks like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环的第一个近似值如下：
- en: '![](../Images/51a4aa1ae3b84e71c9266661c852658e.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/51a4aa1ae3b84e71c9266661c852658e.png)'
- en: 'That is, the main thread runs code similar to:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，主线程运行类似于以下代码：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The event loop takes callbacks out of a *task queue* and executes them in the
    main thread. Dequeuing *blocks* (pauses the main thread) if the task queue is
    empty.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环从*任务队列*中取出回调并在主线程中执行它们。如果任务队列为空，则出队*阻塞*（暂停主线程）。
- en: 'We’ll explore two topics later:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将探讨两个主题：
- en: How to exit from the event loop.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从事件循环中退出。
- en: How to get around the limitation of JavaScript running in a single thread.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何绕过JavaScript在单个线程中运行的限制。
- en: Why is this loop called *event loop*? Many tasks are added in response to events,
    e.g. ones sent by the operating system when input data is ready to be processed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这个循环被称为*事件循环*？许多任务是响应事件添加的，例如操作系统发送的事件，当输入数据准备好被处理时。
- en: 'How are callbacks added to the task queue? These are common possibilities:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 回调是如何添加到任务队列中的？这些是常见的可能性：
- en: JavaScript code can add tasks to the queue so that they are executed later.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript代码可以将任务添加到队列中，以便稍后执行。
- en: When an *event emitter* (a source of events) fires an event, the invocations
    of the event listeners are added to the task queue.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当*事件发射器*（事件源）触发事件时，事件监听器的调用将被添加到任务队列中。
- en: 'Callback-based asynchronous operations in the Node.js API follow this pattern:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js API中的基于回调的异步操作遵循这种模式：
- en: We ask for something and give Node.js a callback function with which it can
    report the result to us.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们请求某些东西，并给Node.js一个回调函数，它可以用来向我们报告结果。
- en: Eventually, the operation runs either in the main thread or in an external thread
    (more on that later).
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终，操作要么在主线程中运行，要么在外部线程中运行（稍后详细介绍）。
- en: When it is done, an invocation of the callback is added to the task queue.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成后，回调的调用将被添加到任务队列中。
- en: 'The following code shows an asynchronous callback-based operation in action.
    It reads a text file from the file system:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了异步回调操作的实际操作。它从文件系统中读取文本文件：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is the ouput:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`fs.readFile()` executes the code that reads the file in another thread. In
    this case, the code succeeds and adds this callback to the task queue:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.readFile()`在另一个线程中执行读取文件的代码。在这种情况下，代码成功并将此回调添加到任务队列中：'
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 4.2.1 Running to completion makes code simpler
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1 运行到完成使代码更简单
- en: 'An important rule for how Node.js runs JavaScript code is: Each task finishes
    (“runs to completion”) before other tasks run. We can see that in the previous
    example: `''AFTER''` in line B is logged before the result is logged in line A
    because the initial task finishes before the task with the invocation of `handleResult()`
    runs.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js运行JavaScript代码的一个重要规则是：每个任务在其他任务运行之前都会完成（“运行到完成”）。我们可以在上一个示例中看到这一点：'AFTER'在B行之前被记录，因为初始任务在调用`handleResult()`的任务运行之前完成。
- en: 'Running to completion means that task lifetimes don’t overlap and we don’t
    have to worry about shared data being changed in the background. That simplifies
    Node.js code. The next example demonstrates that. It implements a simple HTTP
    server:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 运行到完成意味着任务的生命周期不重叠，我们不必担心共享数据在后台被更改。这简化了Node.js代码。下一个示例演示了这一点。它实现了一个简单的HTTP服务器：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We run this code via `node server.mjs`. After that, the code starts and waits
    for HTTP requests. We can send them by using a web browser to go to `http://localhost:8080`.
    Each time we reload that HTTP resource, Node.js invokes the callback that starts
    in line A. It serves a message with the current value of variable `requestCount`
    (line B) and increments it (line C).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`node server.mjs`运行此代码。之后，代码启动并等待HTTP请求。我们可以通过使用Web浏览器访问`http://localhost:8080`来发送请求。每次重新加载该HTTP资源时，Node.js会调用从A行开始的回调函数。它提供了变量`requestCount`当前值的消息（B行），并增加它（C行）。
- en: Each invocation of the callback is a new task and variable `requestCount` is
    shared between tasks. Due to running to completion, it is easy to read and update.
    There is no need to synchronize with other concurrently running tasks because
    there aren’t any.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数的每次调用都是一个新任务，变量`requestCount`在任务之间共享。由于运行到完成，它很容易读取和更新。不需要与其他同时运行的任务同步，因为没有其他任务。
- en: 4.2.2 Why does Node.js code run in a single thread?
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.2 为什么Node.js代码在单个线程中运行？
- en: 'Why does Node.js code run in a single thread (with an event loop) by default?
    That has two benefits:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么Node.js代码默认在单个线程（带有事件循环）中运行？这有两个好处：
- en: As we have already seen, sharing data between tasks is simpler if there is only
    a single thread.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，如果只有一个线程，任务之间共享数据会更简单。
- en: In traditional multi-threaded code, an operation that takes longer to complete
    blocks the current thread until the operation is finished. Examples of such operations
    are reading a file or processing HTTP requests. Performing many of these operations
    is expensive because we have to create a new thread each time. With an event loop,
    the per-operation cost is lower, especially if each operation doesn’t do much.
    That’s why event-loop-based web servers can handle higher loads than thread-based
    ones.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在传统的多线程代码中，需要较长时间才能完成的操作会阻塞当前线程，直到操作完成。此类操作的示例包括读取文件或处理HTTP请求。执行许多此类操作是昂贵的，因为每次都必须创建一个新线程。使用事件循环，每次操作的成本更低，特别是如果每个操作都不做太多。这就是为什么基于事件循环的Web服务器可以处理比基于线程的服务器更高的负载。
- en: Given that some of Node’s asynchronous operations run in threads other than
    the main thread (more on that soon) and report back to JavaScript via the task
    queue, Node.js is not really single-threaded. Instead, we use a single thread
    to coordinate operations that run concurrently and asynchronously (in the main
    thread).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于Node的一些异步操作在主线程之外的线程中运行（稍后会详细介绍），并通过任务队列向JavaScript报告，Node.js实际上并不是单线程的。相反，我们使用单个线程来协调并发和异步运行的操作（在主线程中）。
- en: This concludes our first look at the event loop. **Feel free to skip the remainder
    of this section** if a superficial explanation is enough for you. Read on to learn
    more details.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对事件循环的第一次了解。**如果您只需要一个表面的解释，可以随意跳过本节的其余部分**。继续阅读以了解更多细节。
- en: 4.2.3 The real event loop has multiple phases
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.3 真实的事件循环有多个阶段
- en: 'The real event loop has multiple task queues from which it reads in multiple
    phases ([you can check out some of the JavaScript code in the GitHub repository
    `nodejs/node`](https://github.com/nodejs/node/blob/main/lib/internal/process/task_queues.js)).
    The following diagram shows the most important ones of those phases:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的事件循环有多个任务队列，它从中读取多个阶段（[您可以在GitHub存储库`nodejs/node`中查看一些JavaScript代码](https://github.com/nodejs/node/blob/main/lib/internal/process/task_queues.js)）。以下图表显示了其中最重要的阶段：
- en: '![](../Images/5d5cabb99a6fc7037b402c23a71f36e1.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5d5cabb99a6fc7037b402c23a71f36e1.png)'
- en: What do the event loop phases do that are shown in the diagram?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图表中显示的事件循环阶段的作用是什么？
- en: 'Phase “timers” invokes *timed tasks* that were added to its queue by:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “定时器”阶段调用了*定时任务*，这些任务是通过以下方式添加到其队列中的：
- en: '[`setTimeout(task, delay=1)`](https://nodejs.org/api/timers.html#settimeoutcallback-delay-args)
    runs the callback `task` after `delay` milliseconds.'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`setTimeout(task, delay=1)`](https://nodejs.org/api/timers.html#settimeoutcallback-delay-args)会在`delay`毫秒后运行回调函数`task`。'
- en: '[`setInterval(task, delay=1)`](https://nodejs.org/api/timers.html#setintervalcallback-delay-args)
    runs the callback `task` repeatedly, with pauses lasting `delay` milliseconds.'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`setInterval(task, delay=1)`](https://nodejs.org/api/timers.html#setintervalcallback-delay-args)会重复运行回调函数`task`，每次暂停持续`delay`毫秒。'
- en: Phase “poll” retrieves and processes I/O events and runs I/O-related tasks from
    its queue.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “轮询”阶段检索和处理I/O事件，并从其队列中运行与I/O相关的任务。
- en: 'Phase “check” (the “immediate phase”) executes tasks scheduled via:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “检查”阶段（“立即”阶段）执行通过以下方式安排的任务：
- en: '[`setImmediate(task)`](https://nodejs.org/api/timers.html#setimmediatecallback-args)
    runs the callback `task` as soon as possible (“immediately” after phase “poll”).'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`setImmediate(task)`](https://nodejs.org/api/timers.html#setimmediatecallback-args)会尽快运行回调函数`task`（“轮询”阶段之后“立即”）。'
- en: Each phase runs until its queue is empty or until a maximum number of tasks
    was processed. Except for “poll”, each phase waits until its next turn before
    it processes tasks that were added during its run.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每个阶段运行直到其队列为空，或者直到处理了最大数量的任务。除了“轮询”阶段外，每个阶段在处理其运行期间添加的任务之前会等待其下一个轮次。
- en: 4.2.3.1 Phase “poll”
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.2.3.1 “轮询”阶段
- en: If the poll queue is not empty, the poll phase will go through it and run its
    tasks.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果轮询队列不为空，轮询阶段将遍历并运行其任务。
- en: 'Once the poll queue is empty:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦轮询队列为空：
- en: If there are `setImmediate()` tasks, processing advances to the “check” phase.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有`setImmediate()`任务，处理将进入“检查”阶段。
- en: If there are timer tasks that are ready, processing advances to the “timers”
    phase.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有准备好的定时器任务，处理将进入“定时器”阶段。
- en: Otherwise, this phase blocks the whole main thread and waits until new tasks
    are added to the poll queue (or until this phase ends, see below). These are processed
    immediately.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，此阶段将阻塞整个主线程，并等待直到将新任务添加到轮询队列（或直到此阶段结束，见下文）。这些任务会立即处理。
- en: If this phase takes longer than a system-dependent time limit, it ends and the
    next phase runs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此阶段花费的时间超过系统相关的时间限制，它将结束并运行下一个阶段。
- en: 4.2.4 Next-tick tasks and microtasks
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.4 下一个任务和微任务
- en: 'After each invoked task, a “sub-loop” runs that consists of two phases:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次调用任务后，会运行一个“子循环”，其中包括两个阶段：
- en: '![](../Images/433fc416f821b72a5dd9a3168a34f704.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/433fc416f821b72a5dd9a3168a34f704.png)'
- en: 'The sub-phases handle:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 子阶段处理：
- en: Next-tick tasks, as enqueued via `process.nextTick()`.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过process.nextTick()排队的next-tick任务。
- en: Microtasks, as enqueued via `queueMicrotask()`, Promise reactions, etc.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microtasks，通过queueMicrotask()、Promise reactions等方式加入队列。
- en: Next-tick tasks are Node.js-specific, Microtasks are a cross-platform web standard
    (see [MDN’s support table](https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask#browser_compatibility)).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Next-tick任务是Node.js特有的，Microtasks是跨平台的Web标准（参见[MDN的支持表](https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask#browser_compatibility)）。
- en: This sub-loop runs until both queues are empty. Tasks added during its run,
    are processed immediately – the sub-loop does not wait until its next turn.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子循环一直运行，直到两个队列都为空。在其运行期间添加的任务会立即处理 - 子循环不会等到下一轮才执行。
- en: 4.2.5 Comparing different ways of directly scheduling tasks
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.5 比较直接调度任务的不同方式
- en: 'We can use the following functions and methods to add callbacks to one of the
    task queues:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下函数和方法将回调添加到其中一个任务队列中：
- en: Timed tasks (phase “timers”)
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时任务（“timers”阶段）
- en: '`setTimeout()` (web standard)'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: setTimeout()（Web标准）
- en: '`setInterval()` (web standard)'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: setInterval()（Web标准）
- en: Untimed tasks (phase “check”)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非定时任务（“check”阶段）
- en: '`setImmediate()` (Node.js-specific)'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: setImmediate()（Node.js特有）
- en: 'Tasks that run immediately after the current task:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在当前任务之后立即运行的任务：
- en: '`process.nextTick()` (Node.js-specific)'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: process.nextTick()（Node.js特有）
- en: '`queueMicrotask()`: (web standard)'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: queueMicrotask()：（Web标准）
- en: It’s important to note that when timing a task via a delay, we are specifying
    the earliest possible time that the task will run. Node.js cannot always run them
    at exactly the scheduled time because it can only check between tasks if any timed
    tasks are due. Therefore, a long-running task can cause timed tasks to be late.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，通过延迟计划任务时，我们指定了任务将运行的最早可能时间。Node.js并不总是能够在准确的预定时间运行它们，因为它只能在任务之间检查是否有定时任务到期。因此，长时间运行的任务可能会导致定时任务延迟。
- en: 4.2.5.1 Next-tick tasks and microtasks vs. normal tasks
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.2.5.1 Next-tick任务和microtasks vs. normal tasks
- en: 'Consider the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE13]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We use `setImmediate()` to avoid a pecularity of ESM modules: They are executed
    in microtasks, which means that if we enqueue microtasks at the top level of an
    ESM module, they run before next-tick tasks. As we’ll see next, that’s different
    in most other contexts.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用setImmediate()来避免ESM模块的一个特殊情况：它们在microtasks中执行，这意味着如果我们在ESM模块的顶层排队microtasks，它们会在next-tick任务之前运行。正如我们将在接下来看到的，在大多数其他情境中是不同的。
- en: 'This is the output of the previous code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面代码的输出：
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Observations:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 观察：
- en: All next-tick tasks are executed immediately after `enqueueTasks()`.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有next-tick任务都会在enqueueTasks()之后立即执行。
- en: They are followed by all microtasks, including Promise reactions.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们后面是所有的microtasks，包括Promise reactions。
- en: Phase “timers” comes after the immediate phase. That’s when the timed tasks
    are executed.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “timers”阶段在immediate阶段之后。这时定时任务被执行。
- en: We have added immediate tasks during the immediate (“check”) phase (line A and
    line B). They show up last in the output, which means that they were not executed
    during the current phase, but during the next immediate phase.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在immediate（“check”）阶段（A行和B行）添加了immediate任务。它们出现在输出的最后，这意味着它们不是在当前阶段执行的，而是在下一个immediate阶段执行的。
- en: 4.2.5.2 Enqueuing next-tick tasks and microtasks during their phases
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.2.5.2 在它们的阶段排队next-tick任务和microtasks
- en: 'The next code examines what happens if we enqueue a next-tick task during the
    next-tick phase and a microtask during the microtask phase:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码检查了如果我们在next-tick阶段排队next-tick任务，以及在microtask阶段排队microtask会发生什么：
- en: '[PRE15]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is the output:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE16]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Observations:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 观察：
- en: Next-tick tasks are executed first.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Next-tick任务会首先执行。
- en: “nextTick 2” in enqueued during the next-tick phase and immediately executed.
    Execution only continues once the next-tick queue is empty.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “nextTick 2”在next-tick阶段排队并立即执行。只有在next-tick队列为空时，执行才会继续。
- en: The same is true for microtasks.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于microtasks也是如此。
- en: 'We enqueue “nextTick 3” during the microtask phase and execution loops back
    to the next-tick phase. These subphases are repeated until both their queues are
    empty. Only then does execution move on to the next global phases: First the “timers”
    phase (“setTimeout 1”). Then the immediate phase (“setImmediate 1”).'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在microtask阶段排队了“nextTick 3”，执行循环回到了next-tick阶段。这些子阶段会重复，直到它们的队列都为空。然后执行才会移动到下一个全局阶段：首先是“timers”阶段（“setTimeout
    1”）。然后是immediate阶段（“setImmediate 1”）。
- en: 4.2.5.3 Starving out event loop phases
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.2.5.3 饿死事件循环阶段
- en: 'The following code explores which kinds of tasks can *starve out* event loop
    phases (prevent them from running via infinite recursion):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码探讨了哪种类型的任务可以通过无限递归*饿死*事件循环阶段（阻止它们运行）：
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The “timers” phase and the immediate phase don’t execute tasks that are enqueued
    during their phases. That’s why `timers()` and `immediate()` don’t starve out
    `fs.readFile()` which reports back during the “poll” phase (there is also a Promise
    reaction, but let’s ignore that here).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: “timers”阶段和immediate阶段不会执行在它们的阶段排队的任务。这就是为什么timers()和immediate()不会饿死fs.readFile()，后者在“poll”阶段报告回来（这里也有一个Promise
    reaction，但我们在这里忽略它）。
- en: Due to how next-tick tasks and microtasks are scheduled, both `nextTick()` and
    `microtasks()` prevent the output in the last line.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于next-tick任务和microtasks的调度方式，nextTick()和microtasks()都会阻止最后一行的输出。
- en: 4.2.6 When does a Node.js app exit?
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.6 Node.js应用何时退出？
- en: 'At the end of each iteration of the event loop, Node.js checks if it’s time
    to exit. It keeps a reference count of pending *timeouts* (for timed tasks):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件循环的每次迭代结束时，Node.js都会检查是否是退出的时候。它会保持待处理的*超时*（定时任务）的引用计数：
- en: Scheduling a timed task via `setImmediate()`, `setInterval()`, or `setTimeout()`
    increases the reference count.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过setImmediate()、setInterval()或setTimeout()调度定时任务会增加引用计数。
- en: Running a timed task decreases the reference count.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行定时任务会减少引用计数。
- en: If the reference count is zero at the end of an event loop iteration, Node.js
    exits.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果引用计数在事件循环迭代结束时为零，Node.js会退出。
- en: 'We can see that in the following example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在以下示例中：
- en: '[PRE18]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Node.js waits until the Promise returned by `timeout()` is fulfilled. Why? Because
    the task we schedule in line A keeps the event loop alive.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js等待`timeout()`返回的Promise被实现。为什么？因为我们在A行安排的任务使事件循环保持活动状态。
- en: 'In contrast, creating Promises does not increase the reference count:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，创建Promise不会增加引用计数：
- en: '[PRE19]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this case, execution temporarily leaves this (main) task during `await` in
    line A. At the end of the event loop, the reference count is zero and Node.js
    exits. However, the exit is not successful. That is, the exit code is not 0, it
    is 13 ([“Unfinished Top-Level Await”](https://nodejs.org/api/process.html#exit-codes)).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在A行的`await`期间，执行暂时离开了这个（主）任务。在事件循环结束时，引用计数为零，Node.js退出。但是，退出不成功。也就是说，退出代码不是0，而是13（[“未完成的顶级等待”](https://nodejs.org/api/process.html#exit-codes)）。
- en: 'We can manually control whether a timeout keeps the event loop alive: By default,
    tasks scheduled via `setImmediate()`, `setInterval()`, and `setTimeout()` keep
    the event loop alive as long as they are pending. These functions return instances
    of [class `Timeout`](https://nodejs.org/api/timers.html#class-timeout) whose method
    `.unref()` changes that default so that the timeout being active won’t prevent
    Node.js from exiting. Method `.ref()` restores the default.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动控制超时是否保持事件循环活动：默认情况下，通过`setImmediate()`，`setInterval()`和`setTimeout()`安排的任务在挂起状态时会保持事件循环活动。这些函数返回[class
    `Timeout`](https://nodejs.org/api/timers.html#class-timeout)的实例，其方法`.unref()`更改了默认设置，使得活动的超时不会阻止Node.js退出。方法`.ref()`恢复默认设置。
- en: '[Tim Perry mentions a use case for `.unref()`](https://httptoolkit.tech/blog/unblocking-node-with-unref/):
    His library used `setInterval()` to repeatedly run a background task. That task
    prevented applications from exiting. He fixed the issue via `.unref()`.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[Tim Perry提到了`.unref()`的一个用例](https://httptoolkit.tech/blog/unblocking-node-with-unref/)：他的库使用`setInterval()`重复运行后台任务。该任务阻止应用程序退出。他通过`.unref()`解决了这个问题。'
- en: '4.3 libuv: the cross-platform library that handles asynchronous I/O (and more)
    for Node.js'
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3 libuv：处理Node.js异步I/O（以及更多）的跨平台库
- en: libuv is a library written in C that supports many platforms (Windows, macOS,
    Linux, etc.). Node.js uses it to handle I/O and more.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: libuv是用C编写的库，支持许多平台（Windows，macOS，Linux等）。Node.js使用它来处理I/O和更多内容。
- en: 4.3.1 How libuv handles asynchronous I/O
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.1 libuv如何处理异步I/O
- en: 'Network I/O is asynchronous and doesn’t block the current thread. Such I/O
    includes:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 网络I/O是异步的，不会阻塞当前线程。这种I/O包括：
- en: TCP
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP
- en: UDP
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP
- en: Terminal I/O
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端I/O
- en: Pipes (Unix domain sockets, Windows named pipes, etc.)
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道（Unix域套接字，Windows命名管道等）
- en: To handle asynchronous I/O, libuv uses native kernel APIs and subscribes to
    I/O events (epoll on Linux; kqueue on BSD Unix incl. macOS; event ports on SunOS;
    IOCP on Windows). It then gets notifications when they occur. All of these activities,
    including the I/O itself, happen on the main thread.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理异步I/O，libuv使用本机内核API并订阅I/O事件（Linux上的epoll；BSD Unix包括macOS上的kqueue；SunOS上的事件端口；Windows上的IOCP）。然后在发生时得到通知。所有这些活动，包括I/O本身，都发生在主线程上。
- en: 4.3.2 How libuv handles blocking I/O
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.2 libuv如何处理阻塞I/O
- en: Some native I/O APIs are blocking (not asynchronous) – for example, file I/O
    and some DNS services. libuv invokes these APIs from threads in a thread pool
    (the so-called “worker pool”). That enables the main thread to use these APIs
    asynchronously.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一些本机I/O API是阻塞的（不是异步的）-例如，文件I/O和一些DNS服务。libuv从线程池中的线程调用这些API（所谓的“工作池”）。这使得主线程可以异步使用这些API。
- en: 4.3.3 libuv functionality beyond I/O
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.3 libuv功能超出I/O
- en: 'libuv helps Node.js with more than just with I/O. Other functionality includes:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: libuv不仅帮助Node.js处理I/O。其他功能包括：
- en: Running tasks in the thread pool
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线程池中运行任务
- en: Signal handling
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号处理
- en: High resolution clock
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高分辨率时钟
- en: Threading and synchronization primitives
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程和同步原语
- en: As an aside, libuv has its own event loop whose source code you can check out
    in the GitHub repository `libuv/libuv` ([function `uv_run()`](https://github.com/libuv/libuv/blob/v1.x/src/unix/core.c)).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，libuv有自己的事件循环，你可以在GitHub存储库`libuv/libuv`中查看其源代码（[函数`uv_run()`](https://github.com/libuv/libuv/blob/v1.x/src/unix/core.c)）。
- en: 4.4 Escaping the main thread with user code
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4 通过用户代码逃离主线程
- en: 'If we want to keep Node.js responsive to I/O, we should avoid performing long-running
    computations in main-thread tasks. There are two options for doing so:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让Node.js对I/O保持响应，我们应该避免在主线程任务中执行长时间运行的计算。有两种选择：
- en: 'Partitioning: We can split up the computation into smaller pieces and run each
    piece via `setImmediate()`. That enables the event loop to perform I/O between
    the pieces.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区：我们可以将计算分成较小的部分，并通过`setImmediate()`运行每个部分。这使得事件循环能够在这些部分之间执行I/O。
- en: An upside is that we can perform I/O in each piece.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个优点是我们可以在每个部分执行I/O。
- en: A downside is that we still slow down the event loop.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个缺点是我们仍然减慢了事件循环。
- en: 'Offloading: We can perform our computation in a different thread or process.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卸载：我们可以在不同的线程或进程中执行我们的计算。
- en: Downsides are that we can’t perform I/O from threads other than the main thread
    and that communicating with outside code becomes more complicated.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺点是我们不能从主线程以外的线程执行I/O，与外部代码的通信变得更加复杂。
- en: Upsides are that we don’t slow down the event loop, that we can make better
    use of multiple processor cores, and that errors in other threads don’t affect
    the main thread.
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优点是我们不会减慢事件循环，我们可以更好地利用多个处理器核心，并且其他线程中的错误不会影响主线程。
- en: The next subsections cover a few options for offloading.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的小节涵盖了一些卸载的选项。
- en: 4.4.1 Worker threads
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.1 Worker线程
- en: '[Worker Threads](https://nodejs.org/api/worker_threads.html) implement [the
    cross-platform Web Workers API](https://developer.mozilla.org/en-US/docs/Web/API/Worker#browser_compatibility)
    with a few differences – e.g.:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[Worker Threads](https://nodejs.org/api/worker_threads.html)实现了[跨平台Web Workers
    API](https://developer.mozilla.org/en-US/docs/Web/API/Worker#browser_compatibility)，但有一些区别-例如：'
- en: Worker Threads have to be imported from a module, Web Workers are accessed via
    a global variable.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须从模块导入Worker Threads，通过全局变量访问Web Workers。
- en: Inside a worker, listening to messages and posting messages is done via methods
    of the global object in browsers. On Node.js, we import `parentPort` instead.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工作线程中，通过浏览器全局对象的方法来监听消息和发布消息。在Node.js中，我们使用`parentPort`进行导入。
- en: We can use most Node.js APIs from workers. In browsers, our choice is more limited
    (we can’t use the DOM, etc.).
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以从工作线程中使用大多数Node.js API。在浏览器中，我们的选择更有限（无法使用DOM等）。
- en: On Node.js, more objects are transferable ([all objects whose classes extend
    the internal class `JSTransferable`](https://github.com/nodejs/node/issues/37080))
    than in browsers.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Node.js中，可以传输更多的对象（[所有类扩展内部类`JSTransferable`的对象](https://github.com/nodejs/node/issues/37080)）比在浏览器中。
- en: 'On one hand, Worker Threads really are threads: They are more lightweight than
    processes and run in the same process as the main thread.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，Worker Threads确实是线程：它们比进程更轻量，并在同一进程中运行。
- en: 'On the other hand:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面：
- en: Each worker runs its own event loop.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个工作线程都运行自己的事件循环。
- en: Each worker has its own JavaScript engine instance and its own Node.js instance
    – including separate global variables.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个工作线程都有自己的JavaScript引擎实例和自己的Node.js实例 - 包括单独的全局变量。
- en: (Specifically, each worker is an [*V8 isolate*](https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/bindings/core/v8/V8BindingDesign.md)
    that has its own JavaScript heap but shares its operating system heap with other
    threads.)
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: （具体来说，每个工作线程都是一个[*V8隔离*](https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/bindings/core/v8/V8BindingDesign.md)，它有自己的JavaScript堆，但与其他线程共享操作系统堆。）
- en: 'Sharing data between threads is limited:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程之间共享数据是有限的：
- en: We can share binary data/numbers via SharedArrayBuffers.
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过SharedArrayBuffers共享二进制数据/数字。
- en: '[`Atomics`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics)
    offers atomic operations and synchronization primitives that help when using SharedArrayBuffers.'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Atomics`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics)提供原子操作和同步原语，有助于使用SharedArrayBuffers时。'
- en: '[The Channel Messaging API](https://developer.mozilla.org/en-US/docs/Web/API/Channel_Messaging_API)
    lets us send data (“messages”) over two-way channels. The data is either *cloned*
    (copied) or *transferred* (moved). The latter is more efficient and only supported
    by [a few data structures](https://developer.mozilla.org/en-US/docs/Glossary/Transferable_objects#supported_objects).'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[通道消息API](https://developer.mozilla.org/en-US/docs/Web/API/Channel_Messaging_API)允许我们通过双向通道发送数据（“消息”）。数据可以是*克隆*（复制）或*传输*（移动）。后者更有效，并且仅受[少数数据结构](https://developer.mozilla.org/en-US/docs/Glossary/Transferable_objects#supported_objects)支持。'
- en: For more information, see [the Node.js documentation on worker threads](https://nodejs.org/api/worker_threads.html).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅[worker threads的Node.js文档](https://nodejs.org/api/worker_threads.html)。
- en: 4.4.2 Clusters
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.2 集群
- en: '[Cluster](https://nodejs.org/api/cluster.html) is a Node.js-specific API. It
    lets us run *clusters* of Node.js processes that we can use to distribute workloads.
    The processes are fully isolated but share server ports. They can communicate
    by passing JSON data over channels.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[Cluster](https://nodejs.org/api/cluster.html)是一个Node.js特定的API。它允许我们运行Node.js进程的*集群*，我们可以用来分发工作负载。这些进程是完全隔离的，但共享服务器端口。它们可以通过通道传递JSON数据进行通信。'
- en: If we don’t need process isolation, we can use Worker Threads which are more
    lightweight.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不需要进程隔离，可以使用更轻量的Worker Threads。
- en: 4.4.3 Child processes
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.3 子进程
- en: '[Child process](https://nodejs.org/api/child_process.html) is another Node.js-specific
    API. It lets us spawn new processes that run native commands (often via native
    shells). This API is covered in [§12 “Running shell commands in child processes”](ch_nodejs-child-process.html).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[Child process](https://nodejs.org/api/child_process.html)是另一个Node.js特定的API。它允许我们生成运行本机命令（通常通过本机shell）的新进程。此API在[§12“在子进程中运行shell命令”](ch_nodejs-child-process.html)中有介绍。'
- en: 4.5 Sources of this chapter
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5 本章的来源
- en: 'Node.js event loop:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js事件循环：
- en: 'Node.js documentation: [“The Node.js Event Loop, Timers, and `process.nextTick()`”](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js文档：[“Node.js事件循环，定时器和`process.nextTick()`”](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)
- en: '[“What you should know to really understand the Node.js Event Loop”](https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c)
    by Daniel Khan'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“要真正理解Node.js事件循环，你应该知道的事情”](https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c)
    by Daniel Khan'
- en: '[“How does Node.js decide whether to exit the event loop or go around again?”](https://stackoverflow.com/questions/46914025/node-exits-without-error-and-doesnt-await-promise-event-callback/46916601#46916601)
    by Mark Meyer'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“Node.js如何决定是退出事件循环还是再次运行？”](https://stackoverflow.com/questions/46914025/node-exits-without-error-and-doesnt-await-promise-event-callback/46916601#46916601)
    by Mark Meyer'
- en: 'Videos on the event loop (which refresh some of the background knowledge needed
    for this chapter):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环的视频（刷新了本章所需的一些背景知识）：
- en: '[“Node’s Event Loop From the Inside Out”](https://www.youtube.com/watch?v=P9csgxBgaZ8)
    (by Sam Roberts) explains why operating systems added support for asynchronous
    I/O; which operations are asynchronous and which aren’t (and have to run in the
    thread pool); etc.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“Node的事件循环从内部到外部”](https://www.youtube.com/watch?v=P9csgxBgaZ8)（由Sam Roberts）解释了为什么操作系统增加了对异步I/O的支持；哪些操作是异步的，哪些不是（必须在线程池中运行）等。'
- en: '[“The Node.js Event Loop: Not So Single Threaded”](https://www.youtube.com/watch?v=zphcsoSJMvM)
    (by Bryan Hughes) contains a brief history of multitasking (cooperative multitasking,
    preemptive multitasking, symmteric multi-threading, asynchronous multitasking);
    processes vs. threads; running I/O synchronously vs. in the thread pool; etc.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“Node.js事件循环：并非单线程”](https://www.youtube.com/watch?v=zphcsoSJMvM)（由Bryan Hughes）包含了多任务处理的简要历史（协作多任务处理，抢占式多任务处理，对称多线程，异步多任务处理）；进程与线程；同步运行I/O与在线程池中运行等。'
- en: 'libuv:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: libuv：
- en: 'libuv documentation:'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: libuv文档：
- en: '[“Design overview”](http://docs.libuv.org/en/latest/design.html)'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“设计概述”](http://docs.libuv.org/en/latest/design.html)'
- en: '[“Basics of libuv”](http://docs.libuv.org/en/latest/guide/basics.html)'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“libuv基础知识”](http://docs.libuv.org/en/latest/guide/basics.html)'
- en: '[“A deep dive into libuv”](https://www.youtube.com/watch?v=sGTRmPiXD4Y) by
    Saúl Ibarra Corretgé'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“深入了解libuv”](https://www.youtube.com/watch?v=sGTRmPiXD4Y) 由Saúl Ibarra Corretgé'
- en: '[“I/O multiplexing (select vs. poll vs. epoll/kqueue) - problems and algorithms”](https://nima101.github.io/io_multiplexing)
    by Nima Aghdaii'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“I/O多路复用（select vs. poll vs. epoll/kqueue）-问题和算法”](https://nima101.github.io/io_multiplexing)
    由Nima Aghdaii'
- en: '[“Developer Initiates I/O Operation. You Won’t Believe What Happens Next.”](https://cjihrig.com/node_libuv_io)
    by Colin J. Ihrig'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“开发人员启动I/O操作。接下来会发生什么，你将不会相信。”](https://cjihrig.com/node_libuv_io) 由Colin
    J. Ihrig'
- en: Traces a JavaScript function call as it goes from JavaScript to Node’s core
    to libuv and back.
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪JavaScript函数调用，从JavaScript到Node的核心再到libuv，然后返回。
- en: 'JavaScript concurrency:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript并发：
- en: '[Section “Complex calculations without blocking the Event Loop”](https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#complex-calculations-without-blocking-the-event-loop)
    in “Don’t Block the Event Loop (or the Worker Pool)” in the Node.js documentation'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Node.js文档中“不要阻塞事件循环（或工作线程池）”中的部分[“不阻塞事件循环的复杂计算”](https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#complex-calculations-without-blocking-the-event-loop)
- en: '[“Understanding Worker Threads in Node.js”](https://nodesource.com/blog/worker-threads-nodejs/)
    by Liz Parody'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“理解Node.js中的工作线程”](https://nodesource.com/blog/worker-threads-nodejs/) 由Liz
    Parody'
- en: '[“The State Of Web Workers In 2021”](https://www.smashingmagazine.com/2021/06/web-workers-2021/)
    by Surma'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“2021年Web Workers的现状”](https://www.smashingmagazine.com/2021/06/web-workers-2021/)
    由Surma'
- en: 'Video [“Node.js: The Road to Workers”](https://www.youtube.com/watch?v=-ssCzHoUI7M)
    by Anna Henningsen'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频[“Node.js：通往工作线程的道路”](https://www.youtube.com/watch?v=-ssCzHoUI7M) 由Anna Henningsen
- en: 4.5.1 Acknowledgement
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.1 致谢
- en: I’m much obliged to [Dominic Elm](https://twitter.com/elmd_) for reviewing this
    chapter and providing important feedback.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我非常感谢[Dominic Elm](https://twitter.com/elmd_)审阅本章并提供重要反馈。
- en: '[Comments](https://github.com/rauschma/nodejs-shell-scripting/issues/4)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[评论](https://github.com/rauschma/nodejs-shell-scripting/issues/4)'
