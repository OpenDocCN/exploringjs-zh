- en: 39 Testing types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 39 测试类型
- en: 原文：[https://exploringjs.com/ts/book/ch_testing-types.html](https://exploringjs.com/ts/book/ch_testing-types.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/ts/book/ch_testing-types.html](https://exploringjs.com/ts/book/ch_testing-types.html)
- en: (Ad, please don’t block.)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: （广告，请勿拦截。）
- en: '[39.1 Asserting at the type level](#asserting-at-the-type-level)'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[39.1 在类型级别进行断言](#asserting-at-the-type-level)'
- en: '[39.2 How to check if a type is `any`?](#checking-if-type-is-any)'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[39.2 如何检查类型是否为 `any`？](#checking-if-type-is-any)'
- en: '[39.3 How to check if two types are equal?](#checking-type-equality)'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[39.3 如何检查两个类型是否相等？](#checking-type-equality)'
- en: '[39.3.1 A first attempt: `TMutuallyAssignable`](#a-first-attempt-tmutuallyassignable)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[39.3.1 第一次尝试：`TMutuallyAssignable`](#a-first-attempt-tmutuallyassignable)'
- en: '[39.3.2 Disabling distribution](#disabling-distribution)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[39.3.2 禁用分发](#disabling-distribution)'
- en: '[39.3.3 Ensuring the `any` is only equal to itself](#TEqual)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[39.3.3 确保任何类型仅等于自身](#TEqual)'
- en: '[39.4 How do we assert that something must be `true`?](#how-do-we-assert-that-something-must-be-true)'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[39.4 如何断言某物必须是 `true`？](#how-do-we-assert-that-something-must-be-true)'
- en: '[39.4.1 `Not`: utility type for boolean negation](#not-utility-type-for-boolean-negation)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[39.4.1 `Not`：用于布尔取反的实用类型](#not-utility-type-for-boolean-negation)'
- en: '[39.5 Asserting errors](#asserting-errors)'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[39.5 断言错误](#asserting-errors)'
- en: '[39.5.1 A more complex example](#a-more-complex-example)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[39.5.1 一个更复杂的例子](#a-more-complex-example)'
- en: '[39.6 Asserting the type of a value](#asserting-the-type-of-a-value)'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[39.6 断言值的类型](#asserting-the-type-of-a-value)'
- en: '[39.7 A use case for a type-level assertion in normal code](#type-level-assertions-in-normal-code)'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[39.7 在普通代码中使用类型级别断言的用例](#type-level-assertions-in-normal-code)'
- en: '[39.8 Running type-level tests](#running-type-level-tests)'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[39.8 运行类型级别测试](#running-type-level-tests)'
- en: '[39.9 Further reading](#further-reading-11)'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[39.9 进一步阅读](#further-reading-11)'
- en: In this chapter, we explore how we can test that complicated TypeScript types
    work as expected. To do that, we need assertions at the type level and other tools.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了我们如何测试复杂的 TypeScript 类型是否按预期工作。为此，我们需要类型级别的断言和其他工具。
- en: '[39.1 Asserting at the type level](#asserting-at-the-type-level)'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[39.1 在类型级别进行断言](#asserting-at-the-type-level)'
- en: 'Writing more complicated types is like programming at a different level:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 编写更复杂的类型就像在不同的级别上进行编程：
- en: 'At the program level, we use JavaScript – e.g.:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在程序级别，我们使用 JavaScript – 例如：
- en: Values
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值
- en: Functions with parameters
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有参数的函数
- en: 'At the type level, we use (non-JavaScript) TypeScript – e.g.:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类型级别，我们使用（非 JavaScript）TypeScript – 例如：
- en: Types
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型
- en: Generic types with type parameters
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有类型参数的泛型类型
- en: 'At the program level, we can use assertions such as [`assert.deepEqual()`](https://nodejs.org/api/assert.html#assertdeepequalactual-expected-message)
    to test our code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序级别，我们可以使用断言，如 `assert.deepEqual()`（[https://nodejs.org/api/assert.html#assertdeepequalactual-expected-message](https://nodejs.org/api/assert.html#assertdeepequalactual-expected-message)）来测试我们的代码：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So how can we test type-level code – which is important for complicated types?
    We also need assertions – e.g.:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们如何测试类型级别的代码 – 这对于复杂的类型非常重要？我们还需要断言 – 例如：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The generic types `Assert` and `Equal` are part of my npm package [`asserttt`](https://github.com/rauschma/asserttt).
    In this chapter, we’ll use this package in two ways:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型 `Assert` 和 `Equal` 是我 npm 包 `asserttt` 的一部分。在本章中，我们将以两种方式使用此包：
- en: On one hand, we reimplement its API to see how it works.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一方面，我们重新实现其 API 以查看其工作原理。
- en: On the other hand, we use its API to check that what we have implemented works
    as desired.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，我们使用其 API 来检查我们所实现的功能是否按预期工作。
- en: 'To avoid confusion, the names of our types always start with `T`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免混淆，我们类型的名称总是以 `T` 开头：
- en: '`asserttt` type: `MutuallyAssignable`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asserttt` 类型：`MutuallyAssignable`'
- en: 'Our version: `TMutuallyAssignable`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的版本：`TMutuallyAssignable`
- en: '[39.2 How to check if a type is `any`?](#checking-if-type-is-any)'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[39.2 如何检查类型是否为 `any`？](#checking-if-type-is-any)'
- en: In this section, we explore how to check if a given type is `any`. That will
    help us later with defining `TEqual<X, Y>`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨如何检查给定的类型是否为 `any` 类型。这将有助于我们稍后定义 `TEqual<X, Y>`。
- en: 'How can we detect `any` by only checking assignability via `extends`? Special
    types we have to consider:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何仅通过检查通过 `extends` 的可赋性来检测 `any` 类型？需要考虑的特殊类型有：
- en: '`any` is assignable to and from any type – with one exception: It’s not assignable
    to `never`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any` 可以赋值给任何类型，也可以从任何类型赋值 – 唯一的例外是它不能赋值给 `never`。'
- en: Any type is assignable to `unknown`. `unknown` is not assignable to any type
    (other than `unknown` and `any`).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何类型都可以赋值给 `unknown`。`unknown` 不能赋值给任何类型（除了 `unknown` 和 `any`）。
- en: '`never` is assignable to any type. No type (other than `never`) is assignable
    to `never`; not even `any` can be assigned to `never`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`never` 可以赋值给任何类型。没有类型（除了 `never`）可以赋值给 `never`；甚至 `any` 也不能赋值给 `never`。'
- en: 'Therefore, a type `T` is `any` if both:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个类型 `T` 是 `any` 如果且仅当：
- en: '`T` is assignable to the number literal type `1`.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`T` 可以赋值给数字字面量类型 `1`。'
- en: The number literal type `2` is assignable to `T`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数字字面量类型 `2` 可以赋值给 `T`。
- en: 'After check 1, `T` can be `1`, `never` or `any`. Check 2 excludes `1` and `never`.
    This is an implementation of the two checks:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查 1 之后，`T` 可以是 `1`、`never` 或 `any`。检查 2 排除了 `1` 和 `never`。这是两个检查的实现：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[An even more concise solution](https://stackoverflow.com/questions/49927523/disallow-call-with-any/49928360#49928360)
    was proposed by Joe Calzaretta:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[一个更简洁的解决方案](https://stackoverflow.com/questions/49927523/disallow-call-with-any/49928360#49928360)
    由 Joe Calzaretta 提出：'
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How does this code work?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是如何工作的？
- en: The condition `0 extends 1` fails. It checks if `0` is a subset of `1` (if `0`
    is assignable to `1`).
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件 `0 extends 1` 失败。它检查 `0` 是否是 `1` 的子集（如果 `0` 可以赋值给 `1`）。
- en: For all normal types `T`, the intersection `1 & T` is as big as the type `1`
    or smaller. Therefore, the result of the check stays the same.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有正常类型 `T`，交集 `1 & T` 的大小与类型 `1` 或更小。因此，检查的结果保持不变。
- en: Only the type `any` is different, because `1 & any` is `any` and `0` is a subset
    of `any`.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有类型 `any` 是不同的，因为 `1 & any` 是 `any`，而 `0` 是 `any` 的子集。
- en: '[PRE4]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[39.3 How to check if two types are equal?](#checking-type-equality)'
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[39.3 如何检查两个类型是否相等？](#checking-type-equality)'
- en: The most important part of a type-level assertion API is checking whether two
    types are equal. As it turns out, that is surprisingly difficult.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类型级断言 API 最重要的部分是检查两个类型是否相等。结果证明，这出奇地困难。
- en: '[39.3.1 A first attempt: `TMutuallyAssignable`](#a-first-attempt-tmutuallyassignable)'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[39.3.1 第一次尝试：`TMutuallyAssignable`](#a-first-attempt-tmutuallyassignable)'
- en: 'What does two `X` and `Y` being equal actually mean? One reasonable definition
    is:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 `X` 和 `Y` 相等实际上意味着什么？一个合理的定义是：
- en: '`X` is assignable to `Y` and'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X` 可以赋值给 `Y`，'
- en: '`Y` is assignable to `X`.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Y` 可以赋值给 `X`。'
- en: 'We check assignability via `extends`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 `extends` 来检查赋值性：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The test cases start off well: line A and line B produce the expected results
    and even the more tricky check in line C works correctly.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例开始得很好：第 A 行和第 B 行产生了预期的结果，甚至第 C 行的更复杂的检查也正确无误。
- en: Alas, in line D, the result is both `true` and `false`. Why is that? `TMutuallyAssignable`
    is defined using conditional types and those are distributive over union types
    ([more information](ch_conditional-types.html#distributivity-of-conditional-types)).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，在第 D 行，结果既是 `true` 也是 `false`。为什么是这样？`TMutuallyAssignable` 是使用条件类型定义的，而这些类型在联合类型上是分配的（[更多信息](ch_conditional-types.html#distributivity-of-conditional-types)）。
- en: '[39.3.2 Disabling distribution](#disabling-distribution)'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[39.3.2 禁用分配](#disabling-distribution)'
- en: 'In order for `TMutuallyAssignable` to work as desired, we need to switch off
    distribution. A conditional type is only distributive if the left-hand side of
    `extends` is a bare type variable ([more information](ch_conditional-types.html#preventing-distributivity)).
    Therefore, we can disable distribution by turning both sides of `extends` into
    single-element tuples:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 `TMutuallyAssignable` 如预期那样工作，我们需要关闭分配。一个条件类型只有在 `extends` 的左侧是一个裸类型变量时才是分配的（[更多信息](ch_conditional-types.html#preventing-distributivity)）。因此，我们可以通过将
    `extends` 的两边都变成单元素元组来禁用分配：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can simplify this `TMutuallyAssignable` a little by doing both `extends`
    checks at the same time (the square brackets still ensure that no distribution
    happens):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过同时进行两个 `extends` 检查来稍微简化这个 `TMutuallyAssignable`（方括号仍然确保不会发生分配）：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s test the non-distributive version of `TMutuallyAssignable`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试 `TMutuallyAssignable` 的非分配版本：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we can also handle union types correctly (line A). However, one problem
    remains (line B): `any` is equal to any other type:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们也可以正确处理联合类型（第 A 行）。然而，一个问题仍然存在（第 B 行）：`any` 等于任何其他类型：
- en: If the expected type is `any` then all actual types are equal to it.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果期望的类型是 `any`，那么所有实际类型都与它相等。
- en: If we expect a specific type then the actual type `any` will always be equal,
    too.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们期望一个特定的类型，那么实际的类型 `any` 也总是相等的。
- en: '[39.3.3 Ensuring the `any` is only equal to itself](#TEqual)'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[39.3.3 确保 `any` 只等于自身](#TEqual)'
- en: 'We can use `TMutuallyAssignable` to define a generic type `TEqual` that fixes
    the issues with `any` (we use the utility `TIsAny` from earlier):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `TMutuallyAssignable` 来定义一个泛型类型 `TEqual`，以解决 `any` 的问题（我们使用之前提到的实用工具
    `TIsAny`）：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our approach is:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法是：
- en: If both `X` and `Y` are `any`, they are equal.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `X` 和 `Y` 都是 `any`，它们是相等的。
- en: If neither `X` nor `Y` is `any`, they are equal if they are mutually assignable.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `X` 和 `Y` 都不是 `any`，它们如果可以相互赋值，则它们是相等的。
- en: Otherwise, only `X` or only `Y` is `any` and they are not equal.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，只有 `X` 或只有 `Y` 是 `any`，它们不相等。
- en: '`TEqual` passes all of the following tests:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`TEqual`通过了以下所有测试：'
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`TEqual` passes the test in line A, which `TMutuallyAssignable` failed. Line
    B contains an addition check for `any` – to make sure everything works correctly.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`TEqual`通过了A行测试，而`TMutuallyAssignable`失败了。B行包含了对`any`的附加检查，以确保一切正常工作。'
- en: '[39.4 How do we assert that something must be `true`?](#how-do-we-assert-that-something-must-be-true)'
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[39.4 我们如何断言某物必须是`true`？](#how-do-we-assert-that-something-must-be-true)'
- en: 'At the program/JavaScript level, we can throw an exception if an assertion
    fails:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序/JavaScript级别，如果断言失败，我们可以抛出异常：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Alas, there is no way to fail at compile time in TypeScript. If there were,
    it could look like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在TypeScript中，没有在编译时失败的方法。如果有，它可能看起来像这样：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This type has the same result as a `void` function if `B` is `true`. If it is
    `false` then it fails at the type level, via the invented directive `fail`. The
    closest thing to `fail` that TypeScript currently has, is returning `never`. However,
    `never` does not immediately cause type checking errors.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`B`为`true`，则此类型具有与`void`函数相同的结果。如果它是`false`，则通过发明的指令`fail`在类型级别失败。TypeScript当前最接近`fail`的是返回`never`。然而，`never`不会立即导致类型检查错误。
- en: 'Thankfully, there is a decent workaround that mostly gives us what we want:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个相当不错的解决方案，基本上满足了我们的需求：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When we pass arguments to a generic type, the `extends` constraints of all
    of its parameters must be fulfilled. Otherwise, we get a type-level failure. That’s
    what we use in line A: The value we pass to `AssertType2` must be `true` or the
    type checker complains.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将参数传递给泛型类型时，所有参数的`extends`约束都必须得到满足。否则，我们将得到类型级别的失败。这就是我们在A行中使用的方法：传递给`AssertType2`的值必须是`true`，否则类型检查器会报错。
- en: 'This workaround has limits, though. The following functionality can only be
    implemented via `fail`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案有其局限性。以下功能只能通过`fail`实现：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[39.4.1 `Not`: utility type for boolean negation](#not-utility-type-for-boolean-negation)'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[39.4.1 `Not`：布尔否定实用类型](#not-utility-type-for-boolean-negation)'
- en: 'Once we have `Equal` and `Assert`, we can implement more helper types – e.g.
    `Not<B>`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`Equal`和`Assert`，我们就可以实现更多的辅助类型——例如`Not<B>`：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The square brackets around `B` prevent distribution. `TNot` enables us to assert
    that one type is *not* equal to another type:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`B`周围的方括号防止了分配。`TNot`使我们能够断言一个类型不等于另一个类型：'
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A generic type whose result is `true` or `false` is called a *predicate*. Such
    types can be used with `Assert`. `Equal` and `Not` are predicates. But more predicates
    are conceivable and useful – e.g.:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 结果为`true`或`false`的泛型类型被称为*谓词*。这些类型可以与`Assert`一起使用。`Equal`和`Not`是谓词。但可以设想和使用的谓词更多——例如：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`asserttt` defines [more predicates](https://github.com/rauschma/asserttt/blob/main/src/asserttt.ts).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`asserttt`定义了[更多谓词](https://github.com/rauschma/asserttt/blob/main/src/asserttt.ts)。'
- en: '[39.5 Asserting errors](#asserting-errors)'
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[39.5 断言错误](#asserting-errors)'
- en: 'Sometimes, we need to test that an error happens where we expect it. At the
    JavaScript level, we can use functions such as `assert.throws()`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要测试在预期的地方发生错误。在JavaScript级别，我们可以使用如`assert.throws()`之类的函数：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'At the type level, we can use `@ts-expect-error`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型级别，我们可以使用`@ts-expect-error`：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By default, `@ts-expect-error` only checks *that* an error exists not which
    error it is. To check the latter, we can use a tool such as [ts-expect-error](https://www.npmjs.com/package/ts-expect-error).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`@ts-expect-error`只检查*存在*错误，而不是错误的类型。要检查后者，我们可以使用像[ts-expect-error](https://www.npmjs.com/package/ts-expect-error)这样的工具。
- en: '[39.5.1 A more complex example](#a-more-complex-example)'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[39.5.1 一个更复杂的例子](#a-more-complex-example)'
- en: 'For fun, let’s compare another JavaScript-level test with its analog at the
    type level. This is the JavaScript code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了娱乐，让我们比较一下JavaScript级别的测试与其类型级别的对应项。这是JavaScript代码：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For the type-level code, I’m omitting the runtime type check – even though that
    can often still make sense.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类型级别的代码，我省略了运行时类型检查——即使这通常仍然有意义。
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[39.6 Asserting the type of a value](#asserting-the-type-of-a-value)'
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[39.6 断言值的类型](#asserting-the-type-of-a-value)'
- en: 'When testing types, we also may want to check if a value has a given type –
    as provided via inference or a generic type. One way of doing so is via the `typeof`
    operator (line A):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试类型时，我们还想检查一个值是否具有给定的类型——如通过推断或泛型类型提供。这样做的一种方法是通过`typeof`运算符（A行）：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Another option is via a helper function `assertType()`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是通过辅助函数`assertType()`：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Using a program-level function makes this check less verbose because we can
    directly accept program-level values, we don’t have to convert them to type-level
    values via `typeof`. This is what `assertType()` looks like:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用程序级函数可以使这个检查不那么冗长，因为我们可以直接接受程序级值，我们不需要通过 `typeof` 将它们转换为类型级值。这就是 `assertType()`
    的样子：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We don’t do anything with the parameter `_value`; we only statically check
    if it is assignable to the type parameter `T`. One limitation of `assertType()`
    is that it only checks assignability; it does not check type equality. For example,
    we can’t check that a value has the type `string` and not a more specific type:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对参数 `_value` 没有做任何事情；我们只静态检查它是否可以赋值给类型参数 `T`。`assertType()` 的一个限制是它只检查可赋性；它不检查类型相等性。例如，我们无法检查一个值是否具有
    `string` 类型而不是更具体的类型：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In line A, the type of `value_abc` is assignable to `string` but it is not equal
    to `string`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 A 中，`value_abc` 的类型可以赋值给 `string`，但它并不等于 `string`。
- en: 'In contrast, `Equal` enables us to check that a value does not have a type
    that is more specific than `string`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`Equal` 允许我们检查一个值是否不具有比 `string` 更具体的类型：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[39.7 A use case for a type-level assertion in normal code](#type-level-assertions-in-normal-code)'
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[39.7   正常代码中类型级断言的一个用例](#type-level-assertions-in-normal-code)'
- en: 'Occasionally, type-level assertions are even useful in normal (non-test) code.
    For example, consider the following enum pattern:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，类型级断言在常规（非测试）代码中也非常有用。例如，考虑以下枚举模式：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let’s assume we want to use [Zod](ch_validating-external-data.html#ch_validating-external-data)
    to validate a JSON property whose value is one of the keys of `OutputFormat`.
    Then we need an Array that we can pass to [`z.enum()`](https://zod.dev/?id=zod-enums):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想使用 [Zod](ch_validating-external-data.html#ch_validating-external-data)
    验证一个 JSON 属性，其值是 `OutputFormat` 的键之一。然后我们需要一个可以传递给 `z.enum()` 的数组（[更多信息](https://zod.dev/?id=zod-enums)）：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Why don’t we create `OUTPUT_FORMAT_KEYS` via `Object.keys()`? Zod needs a tuple
    so that it can infer a static type.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么不通过 `Object.keys()` 创建 `OUTPUT_FORMAT_KEYS`？Zod 需要一个元组以便它可以推断静态类型。
- en: 'To ensure that `OUTPUT_FORMAT_KEYS` is consistent with `OutputFormatKey`, we
    can use the following type-level assertion:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保 `OUTPUT_FORMAT_KEYS` 与 `OutputFormatKey` 一致，我们可以使用以下类型级断言：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In line A, we use an indexed access type `T[K]` to convert the Array `OUTPUT_FORMAT_KEYS`
    to a union of the types of its elements ([more information](ch_computing-with-tuple-types.html#from-tuple-to-union)).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 A 中，我们使用索引访问类型 `T[K]` 将数组 `OUTPUT_FORMAT_KEYS` 转换为其元素的类型联合（[更多信息](ch_computing-with-tuple-types.html#from-tuple-to-union)）。
- en: '[39.8 Running type-level tests](#running-type-level-tests)'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[39.8   运行类型级测试](#running-type-level-tests)'
- en: 'To run normal tests written in TypeScript, we run the transpiled JavaScript.
    If tests include type-level assertions, we need to additionally type check them.
    Two options are:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行用 TypeScript 编写的常规测试，我们运行编译后的 JavaScript。如果测试包含类型级断言，我们还需要额外进行类型检查。有两种选择：
- en: First run the JavaScript. Then type-check the tests via `tsc`.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先运行 JavaScript。然后通过 `tsc` 对测试进行类型检查。
- en: Run the tests via a tool such as [tsx](https://tsx.is) that type checks code
    before running it.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过像 [tsx](https://tsx.is) 这样的工具运行测试，这些工具在运行代码之前进行类型检查。
- en: '[39.9 Further reading](#further-reading-11)'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[39.9   进一步阅读](#further-reading-11)'
- en: 'Overview of various type testing approaches: 2ality blog post [“Testing static
    types in TypeScript”](https://2ality.com/2022/11/testing-static-types-typescript.html)'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种类型测试方法的概述：2ality 博客文章 “在 TypeScript 中测试静态类型”（[更多信息](https://2ality.com/2022/11/testing-static-types-typescript.html)）
