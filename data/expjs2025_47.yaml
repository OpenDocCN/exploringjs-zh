- en: 40 Destructuring ES6
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 40 ES6 解构
- en: 原文：[https://exploringjs.com/js/book/ch_destructuring.html](https://exploringjs.com/js/book/ch_destructuring.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/js/book/ch_destructuring.html](https://exploringjs.com/js/book/ch_destructuring.html)
- en: '[40.1 A first taste of destructuring](#a-first-taste-of-destructuring)'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.1 解构的第一印象](#a-first-taste-of-destructuring)'
- en: '[40.2 Constructing vs. extracting](#constructing-vs-extracting)'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.2 构造与提取](#constructing-vs-extracting)'
- en: '[40.3 Where can we destructure?](#destructuring-locations)'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.3 在哪里可以进行解构？](#destructuring-locations)'
- en: '[40.4 Object-destructuring](#object-destructuring)'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.4 对象解构](#object-destructuring)'
- en: '[40.4.1 Property value shorthands](#property-value-shorthands)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.4.1 属性值简写](#property-value-shorthands)'
- en: '[40.4.2 Rest properties](#rest-properties)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.4.2 剩余属性](#rest-properties)'
- en: '[40.4.3 Syntax pitfall: assigning via object destructuring](#assigning-via-object-destructuring)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.4.3 语法陷阱：通过对象解构进行赋值](#assigning-via-object-destructuring)'
- en: '[40.5 Array-destructuring](#array-destructuring)'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.5 数组解构](#array-destructuring)'
- en: '[40.5.1 Array-destructuring works with any iterable](#arraydestructuring-works-with-any-iterable)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.5.1 数组解构与任何可迭代对象一起工作](#arraydestructuring-works-with-any-iterable)'
- en: '[40.5.2 Rest elements](#rest-elements)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.5.2 剩余元素](#rest-elements)'
- en: '[40.6 Examples of destructuring](#examples-of-destructuring)'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.6 解构的示例](#examples-of-destructuring)'
- en: '[40.6.1 Array-destructuring: swapping variable values](#arraydestructuring-swapping-variable-values)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.6.1 数组解构：交换变量值](#arraydestructuring-swapping-variable-values)'
- en: '[40.6.2 Array-destructuring: operations that return Arrays](#arraydestructuring-operations-that-return-arrays)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.6.2 数组解构：返回数组的操作](#arraydestructuring-operations-that-return-arrays)'
- en: '[40.6.3 Object-destructuring: multiple return values](#objectdestructuring-multiple-return-values)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.6.3 对象解构：多个返回值](#objectdestructuring-multiple-return-values)'
- en: '[40.7 What happens if a pattern part does not match anything?](#what-happens-if-a-pattern-part-does-not-match-anything)'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.7 如果模式部分没有匹配到任何内容会发生什么？](#what-happens-if-a-pattern-part-does-not-match-anything)'
- en: '[40.7.1 Object-destructuring and missing properties](#objectdestructuring-and-missing-properties)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.7.1 对象解构和缺失的属性](#objectdestructuring-and-missing-properties)'
- en: '[40.7.2 Array-destructuring and missing elements](#arraydestructuring-and-missing-elements)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.7.2 数组解构和缺失的元素](#arraydestructuring-and-missing-elements)'
- en: '[40.8 What values can’t be destructured?](#what-values-cant-be-destructured)'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.8 哪些值不能解构？](#what-values-cant-be-destructured)'
- en: '[40.8.1 We can’t object-destructure `undefined` and `null`](#values-that-cannot-be-object-destructured)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.8.1 我们无法对 `undefined` 和 `null` 进行对象解构](#values-that-cannot-be-object-destructured)'
- en: '[40.8.2 We can’t Array-destructure non-iterable values](#values-that-cannot-be-array-destructured)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.8.2 我们无法对非可迭代值进行数组解构](#values-that-cannot-be-array-destructured)'
- en: '[40.9 (Advanced)](#advanced-3)'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.9 (高级)](#advanced-3)'
- en: '[40.10 Default values](#default-values)'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.10 默认值](#default-values)'
- en: '[40.10.1 Default values in Array-destructuring](#default-values-in-arraydestructuring)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.10.1 数组解构中的默认值](#default-values-in-arraydestructuring)'
- en: '[40.10.2 Default values in object-destructuring](#default-values-in-objectdestructuring)'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.10.2 对象解构中的默认值](#default-values-in-objectdestructuring)'
- en: '[40.11 Parameter definitions are similar to destructuring](#parameter-definitions-are-similar-to-destructuring)'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.11 参数定义与解构类似](#parameter-definitions-are-similar-to-destructuring)'
- en: '[40.12 Nested destructuring](#nested-destructuring)'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[40.12 嵌套解构](#nested-destructuring)'
- en: '[40.1 A first taste of destructuring](#a-first-taste-of-destructuring)'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[40.1 解构的第一印象](#a-first-taste-of-destructuring)'
- en: 'With normal assignment, we extract one piece of data at a time – for example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用常规赋值，我们一次提取一个数据片段——例如：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With destructuring, we can extract multiple pieces of data at the same time
    via patterns in locations that receive data. The left-hand side of `=` in the
    previous code is one such location. In the following code, the square brackets
    in line A are a destructuring pattern:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用解构，我们可以通过接收数据的位置上的模式同时提取多个数据片段。上一段代码中 `=` 的左侧是一个这样的位置。在以下代码中，行 A 中的方括号是一个解构模式：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code does the same as the previous code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与上一段代码执行相同的操作。
- en: 'Note that the pattern is “smaller” than the data: we are only extracting what
    we need.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意模式“小于”数据：我们只提取所需的内容。
- en: '[40.2 Constructing vs. extracting](#constructing-vs-extracting)'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[40.2 构造与提取](#constructing-vs-extracting)'
- en: 'In order to understand what destructuring is, consider that JavaScript has
    two kinds of operations that are opposites:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解解构是什么，考虑 JavaScript 有两种相反的操作：
- en: We can *construct* compound data, for example, by setting properties and via
    object literals.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过设置属性和对象字面量来*构造*复合数据。
- en: We can *extract* data out of compound data, for example, by getting properties.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以从复合数据中提取数据，例如，通过获取属性。
- en: 'Constructing data looks as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 数据构造看起来如下：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Extracting data looks as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数据提取看起来如下：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The operation in line A is new: we declare two variables `f2` and `l2` and
    initialize them via *destructuring* (multivalue extraction).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 行A的操作是新的：我们声明了两个变量`f2`和`l2`，并通过*解构*（多值提取）来初始化它们。
- en: 'The following part of line A is a *destructuring pattern*:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 行A的以下部分是一个*解构模式*：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Destructuring patterns are syntactically similar to the literals that are used
    for multivalue construction. But they appear where data is received (e.g., at
    the left-hand sides of assignments), not where data is created (e.g., at the right-hand
    sides of assignments).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 解构模式在语法上与用于多值构造的字面量相似。但它们出现在数据接收的地方（例如，在赋值的左侧），而不是数据创建的地方（例如，在赋值的右侧）。
- en: '[40.3 Where can we destructure?](#destructuring-locations)'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[40.3 在哪里可以进行解构？](#destructuring-locations)'
- en: 'Destructuring patterns can be used at “data sink locations” such as:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 解构模式可以在“数据接收位置”使用，例如：
- en: 'Variable declarations:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量声明：
- en: '[PRE5]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Assignments:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值：
- en: '[PRE6]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Parameter definitions:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数定义：
- en: '[PRE7]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that variable declarations include `const` and `let` declarations in `for-of`
    loops:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，变量声明包括`const`和`let`声明在`for-of`循环中：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the next two sections, we’ll look deeper into the two kinds of destructuring:
    object-destructuring and Array-destructuring.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分中，我们将更深入地探讨两种解构类型：对象解构和数组解构。
- en: '[40.4 Object-destructuring](#object-destructuring)'
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[40.4 对象解构](#object-destructuring)'
- en: '*Object-destructuring* lets us batch-extract values of properties via patterns
    that look like object literals:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象解构* 允许我们通过类似于对象字面量的模式批量提取属性值：'
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can think of the pattern as a transparent sheet that we place over the data:
    the pattern key `''street''` has a match in the data. Therefore, the data value
    `''Evergreen Terrace''` is assigned to the pattern variable `s`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将模式视为放置在数据上的一张透明纸：模式键`'street'`在数据中有匹配项。因此，数据值`'Evergreen Terrace'`被分配给模式变量`s`。
- en: 'We can also object-destructure primitive values:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以对原始值进行对象解构：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And we can object-destructure Arrays:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以对数组进行对象解构：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Why does that work? [Array indices are also properties](ch_arrays.html#array-indices).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这样工作？[数组索引也是属性](ch_arrays.html#array-indices)。
- en: '[40.4.1 Property value shorthands](#property-value-shorthands)'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[40.4.1 属性值缩写](#property-value-shorthands)'
- en: 'Object literals support property value shorthands and so do object patterns:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量支持属性值缩写，对象模式也是如此：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Object-destructuring**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“练习”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：对象解构**'
- en: '`exercises/destructuring/object_destructuring_exrc.mjs`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/destructuring/object_destructuring_exrc.mjs`'
- en: '[40.4.2 Rest properties](#rest-properties)'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[40.4.2 剩余属性](#rest-properties)'
- en: 'In object literals, we can have spread properties. In object patterns, we can
    have rest properties (which must come last):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象字面量中，我们可以有扩展属性。在对象模式中，我们可以有剩余属性（必须放在最后）：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A rest property variable, such as `remaining` (line A), is assigned an object
    with all data properties whose keys are not mentioned in the pattern.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个剩余属性变量，如`remaining`（行A），被分配了一个包含所有数据属性的对象，其键在模式中未提及。
- en: '`remaining` can also be viewed as the result of non-destructively removing
    property `a` from `obj`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`remaining`也可以被视为从`obj`中非破坏性地移除属性`a`的结果。'
- en: '[40.4.3 Syntax pitfall: assigning via object destructuring](#assigning-via-object-destructuring)'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[40.4.3 通过对象解构进行赋值：语法陷阱](#assigning-via-object-destructuring)'
- en: 'If we object-destructure in an assignment, we are facing a pitfall caused by
    [syntactic ambiguity](ch_syntax.html#ambiguous-syntax) – we can’t start a statement
    with a curly brace because then JavaScript thinks we are starting a block:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在赋值时进行对象解构，我们将面临由[语法歧义](ch_syntax.html#ambiguous-syntax)引起的陷阱——我们不能以大括号开始一个语句，因为这样JavaScript会认为我们正在开始一个块：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **Why `eval()`?**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“详情”](../Images/38ba63de820aae6f94a019538ae0f222.png) **为什么使用`eval()`？**'
- en: '[`eval()`](ch_dynamic-code-evaluation.html#eval) delays parsing (and therefore
    the `SyntaxError`) until the callback of `assert.throws()` is executed. If we
    didn’t use it, we’d already get an error when this code is parsed and `assert.throws()`
    wouldn’t even be executed.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[`eval()`](ch_dynamic-code-evaluation.html#eval) 延迟解析（因此`SyntaxError`），直到`assert.throws()`的回调执行。如果我们不使用它，当这段代码被解析时，我们就会得到错误，而`assert.throws()`甚至不会被执行。'
- en: 'The workaround is to put the whole assignment in parentheses:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将整个赋值放在括号中：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[40.5 Array-destructuring](#array-destructuring)'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[40.5 数组解构](#array-destructuring)'
- en: '*Array-destructuring* lets us batch-extract values of Array elements via patterns
    that look like Array literals:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组解构*允许我们通过类似于数组字面量的模式批量提取数组元素的值：'
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can skip elements by putting holes in Array patterns:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在数组模式中放置空位来跳过元素：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The Array pattern in line A starts with a hole, which is why the Array element
    at index 0 is ignored.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 行 A 中的数组模式以一个空位开始，这就是为什么索引 0 的数组元素被忽略。
- en: '[40.5.1 Array-destructuring works with any iterable](#arraydestructuring-works-with-any-iterable)'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[40.5.1 数组解构与任何可迭代对象一起工作](#arraydestructuring-works-with-any-iterable)'
- en: 'Array-destructuring can be applied to any value that is iterable, not just
    to Arrays:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 数组解构可以应用于任何可迭代的值，而不仅仅是数组：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[40.5.2 Rest elements](#rest-elements)'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[40.5.2 剩余元素](#rest-elements)'
- en: 'In Array literals, we can have spread elements. In Array patterns, we can have
    rest elements (which must come last):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组字面量中，我们可以有扩展元素。在数组模式中，我们可以有剩余元素（必须放在最后）：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A rest element variable, such as `remaining` (line A), is assigned an Array
    with all elements of the destructured value that were not mentioned yet.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余元素变量，如 `remaining`（行 A），被分配一个数组，其中包含尚未提到的解构值的所有元素。
- en: '[40.6 Examples of destructuring](#examples-of-destructuring)'
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[40.6 解构示例](#examples-of-destructuring)'
- en: '[40.6.1 Array-destructuring: swapping variable values](#arraydestructuring-swapping-variable-values)'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[40.6.1 数组解构：交换变量值](#arraydestructuring-swapping-variable-values)'
- en: 'We can use Array-destructuring to swap the values of two variables without
    needing a temporary variable:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用数组解构来交换两个变量的值，而无需使用临时变量：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[40.6.2 Array-destructuring: operations that return Arrays](#arraydestructuring-operations-that-return-arrays)'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[40.6.2 数组解构：返回数组的操作](#arraydestructuring-operations-that-return-arrays)'
- en: 'Array-destructuring is useful when operations return Arrays, as does, for example,
    the regular expression method `.exec()`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作返回数组时，数组解构很有用，例如正则表达式的 `.exec()` 方法：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[40.6.3 Object-destructuring: multiple return values](#objectdestructuring-multiple-return-values)'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[40.6.3 对象解构：多个返回值](#objectdestructuring-multiple-return-values)'
- en: Destructuring is very useful if a function returns multiple values – either
    packaged as an Array or packaged as an object.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数返回多个值——无论是作为数组还是作为对象包装，解构都非常有用。
- en: 'Consider a function `findElement()` that finds elements in an Array:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个 `findElement()` 函数，该函数在数组中查找元素：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Its second parameter is a function that receives the value and index of an element
    and returns a boolean indicating if this is the element the caller is looking
    for.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 其第二个参数是一个函数，该函数接收元素的值和索引，并返回一个布尔值，指示这是否是调用者正在寻找的元素。
- en: 'We are now faced with a dilemma: Should `findElement()` return the value of
    the element it found or the index? One solution would be to create two separate
    functions, but that would result in duplicated code because both functions would
    be very similar.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在面临一个困境：`findElement()` 应该返回它找到的元素的值还是索引？一个解决方案是创建两个单独的函数，但这会导致代码重复，因为这两个函数非常相似。
- en: 'The following implementation avoids duplication by returning an object that
    contains both index and value of the element that is found:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下实现通过返回一个包含找到的元素的索引和值的对象来避免重复：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Destructuring helps us with processing the result of `findElement()`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 解构帮助我们处理 `findElement()` 的结果：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As we are working with property keys, the order in which we mention `value`
    and `index` doesn’t matter:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在处理属性键，所以 `value` 和 `index` 的提及顺序并不重要：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The kicker is that destructuring also serves us well if we are only interested
    in one of the two results:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是，如果我们只对两个结果中的一个感兴趣，解构也能很好地为我们服务：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: All of these conveniences combined make this way of handling multiple return
    values quite versatile.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些便利性结合起来，使得处理多个返回值的方式非常灵活。
- en: '[40.7 What happens if a pattern part does not match anything?](#what-happens-if-a-pattern-part-does-not-match-anything)'
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[40.7 如果模式部分不匹配会发生什么？](#what-happens-if-a-pattern-part-does-not-match-anything)'
- en: 'What happens if there is no match for part of a pattern? The same thing that
    happens if we use non-batch operators: We get `undefined`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模式的一部分没有匹配，会发生什么？这与我们使用非批量操作时发生的情况相同：我们得到 `undefined`。
- en: '[40.7.1 Object-destructuring and missing properties](#objectdestructuring-and-missing-properties)'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[40.7.1 对象解构和缺失属性](#objectdestructuring-and-missing-properties)'
- en: 'If a property in an object pattern has no match on the right-hand side, we
    get `undefined`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象模式右侧没有匹配的属性，我们得到 `undefined`：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[40.7.2 Array-destructuring and missing elements](#arraydestructuring-and-missing-elements)'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[40.7.2 数组解构和缺失元素](#arraydestructuring-and-missing-elements)'
- en: 'If an element in an Array pattern has no match on the right-hand side, we get
    `undefined`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组模式右侧没有匹配的元素，我们得到 `undefined`：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[40.8 What values can’t be destructured?](#what-values-cant-be-destructured)'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[40.8 哪些值不能解构？](#what-values-cant-be-destructured)'
- en: '[40.8.1 We can’t object-destructure `undefined` and `null`](#values-that-cannot-be-object-destructured)'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[40.8.1 我们不能解构 `undefined` 和 `null`](#values-that-cannot-be-object-destructured)'
- en: Object-destructuring only fails if the value to be destructured is either `undefined`
    or `null`. That is, it fails whenever accessing a property via the dot operator
    would fail too.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对象解构只有在要解构的值是 `undefined` 或 `null` 时才会失败。也就是说，当通过点操作符访问属性会失败时，它也会失败。
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Therefore, destructuring a value with an empty object pattern means “throw
    an exception if the value is `undefined` or `null`”:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用空对象模式解构值意味着“如果值是 `undefined` 或 `null`，则抛出异常”：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[40.8.2 We can’t Array-destructure non-iterable values](#values-that-cannot-be-array-destructured)'
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[40.8.2 我们不能解构非可迭代值](#values-that-cannot-be-array-destructured)'
- en: 'Array-destructuring demands that the destructured value be iterable. Therefore,
    we can’t Array-destructure `undefined` and `null`. But we can’t Array-destructure
    non-iterable primitives and objects either:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 数组解构要求解构的值是可迭代的。因此，我们不能解构 `undefined` 和 `null`。但我们也不能解构非可迭代的基本类型和对象：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Therefore, destructuring a value with an empty Array pattern means “throw an
    exception if the value is not iterable”:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用空数组模式解构值意味着“如果值不可迭代，则抛出异常”：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[40.9 (Advanced)](#advanced-3)'
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[40.9 (高级)](#advanced-3)'
- en: All of the remaining sections are advanced.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 所有剩余的部分都是高级的。
- en: '[40.10 Default values](#default-values)'
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[40.10 默认值](#default-values)'
- en: 'Normally, if a pattern has no match, the corresponding variable is set to `undefined`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果模式没有匹配，相应的变量将被设置为 `undefined`：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we want a different value to be used, we need to specify a *default value*
    (via `=`):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用不同的值，我们需要指定一个 *默认值*（通过 `=`）：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In line A, we specify the default value for `p` to be `123`. That default is
    used because the data that we are destructuring has no property named `prop`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 A 中，我们指定 `p` 的默认值为 `123`。这个默认值被使用，因为我们正在解构的数据没有名为 `prop` 的属性。
- en: '[40.10.1 Default values in Array-destructuring](#default-values-in-arraydestructuring)'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[40.10.1 数组解构中的默认值](#default-values-in-arraydestructuring)'
- en: Here, we have two default values that are assigned to the variables `x` and
    `y` because the corresponding elements don’t exist in the Array that is destructured.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有两个默认值被分配给变量 `x` 和 `y`，因为相应的元素不存在于解构的数组中。
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The default value for the first element of the Array pattern is `1`; the default
    value for the second element is `2`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 数组模式中第一个元素的默认值是 `1`；第二个元素的默认值是 `2`。
- en: '[40.10.2 Default values in object-destructuring](#default-values-in-objectdestructuring)'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[40.10.2 对象解构中的默认值](#default-values-in-objectdestructuring)'
- en: 'We can also specify default values for object-destructuring:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以为对象解构指定默认值：
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Neither property key `first` nor property key `last` exist in the object that
    is destructured. Therefore, the default values are used.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在解构的对象中，既不存在属性键 `first` 也不存在属性键 `last`。因此，使用了默认值。
- en: 'With property value shorthands, this code becomes simpler:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性值简写，这段代码变得更简单：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[40.11 Parameter definitions are similar to destructuring](#parameter-definitions-are-similar-to-destructuring)'
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[40.11 参数定义与解构类似](#parameter-definitions-are-similar-to-destructuring)'
- en: 'Considering what we have learned in this chapter, parameter definitions have
    much in common with an Array pattern (rest elements, default values, etc.). In
    fact, the following two function declarations are equivalent:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们在本章中学到的内容，参数定义与数组模式有很多共同之处（剩余元素、默认值等）。事实上，以下两个函数声明是等价的：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[40.12 Nested destructuring](#nested-destructuring)'
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[40.12 嵌套解构](#nested-destructuring)'
- en: 'Until now, we have only used variables as *assignment targets* (data sinks)
    inside destructuring patterns. But we can also use patterns as assignment targets,
    which enables us to nest patterns to arbitrary depths:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在使用解构模式内部作为 *赋值目标*（数据汇）时使用了变量。但我们可以也将模式用作赋值目标，这使得我们可以将模式嵌套到任意深度：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Inside the Array pattern in line A, there is a nested object pattern at index
    1.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在行A的Array模式内部，存在一个索引为1的嵌套对象模式。
- en: Nested patterns can become difficult to understand, so they are best used in
    moderation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套模式可能会变得难以理解，因此最好适度使用。
