- en: 41 A roadmap for asynchronous programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 41 异步编程路线图
- en: 原文：[https://exploringjs.com/js/book/ch_async-roadmap.html](https://exploringjs.com/js/book/ch_async-roadmap.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/js/book/ch_async-roadmap.html](https://exploringjs.com/js/book/ch_async-roadmap.html)
- en: '[41.1 The next chapters](#the-next-chapters)'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[41.1 下一章](#the-next-chapters)'
- en: '[41.2 Synchronous functions](#synchronous-functions)'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[41.2 同步函数](#synchronous-functions)'
- en: '[41.3 JavaScript executes tasks sequentially in a single process](#javascript-executes-tasks-sequentially-in-a-single-process)'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[41.3 JavaScript 在单个进程中按顺序执行任务](#javascript-executes-tasks-sequentially-in-a-single-process)'
- en: '[41.4 Callback-based asynchronous functions](#roadmap-callbacks-for-async)'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[41.4 基于回调的异步函数](#roadmap-callbacks-for-async)'
- en: '[41.5 Promise-based asynchronous functions](#promisebased-asynchronous-functions)'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[41.5 基于Promise的异步函数](#promisebased-asynchronous-functions)'
- en: '[41.6 Async functions](#roadmap-async-functions)'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[41.6 异步函数](#roadmap-async-functions)'
- en: This chapter is a brief roadmap for asynchronous programming.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这章是异步编程的简要路线图。
- en: '[41.1 The next chapters](#the-next-chapters)'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[41.1 下一章](#the-next-chapters)'
- en: 'The next chapters explain asynchronous programming in JavaScript:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将解释 JavaScript 中的异步编程：
- en: '[“Foundations of asynchronous programming in JavaScript” (§42)](ch_async-js.html#ch_async-js):'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“JavaScript 异步编程基础” (§42)](ch_async-js.html#ch_async-js):'
- en: We’ll see how synchronous function calls work.
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将了解同步函数调用是如何工作的。
- en: We’ll also explore JavaScript’s way of executing code in a single process, via
    its *event loop*.
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将探索 JavaScript 在单个进程中执行代码的方式，通过其 *事件循环*。
- en: '[Asynchronicity via callbacks](ch_async-js.html#callback-pattern) is also described
    in that chapter.'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[通过回调实现异步](ch_async-js.html#callback-pattern) 在该章节中也有描述。'
- en: '[“Promises for asynchronous programming ^(ES6)” (§43)](ch_promises.html#ch_promises)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“异步编程的Promises^(ES6)” (§43)](ch_promises.html#ch_promises)'
- en: '[“Async functions ^(ES2017)” (§44)](ch_async-functions.html#ch_async-functions)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“Async函数^(ES2017)” (§44)](ch_async-functions.html#ch_async-functions)'
- en: '[“Asynchronous iteration ^(ES2018)” (§45)](ch_async-iteration.html#ch_async-iteration)
    concludes this series of chapters on asynchronous programming. Asynchronous iteration
    is similar to [synchronous iteration](ch_sync-iteration.html#ch_sync-iteration),
    but iterated values are delivered asynchronously.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“异步迭代^(ES2018)” (§45)](ch_async-iteration.html#ch_async-iteration) 总结了这一系列关于异步编程的章节。异步迭代类似于
    [同步迭代](ch_sync-iteration.html#ch_sync-iteration)，但迭代值是异步提供的。'
- en: The remainder of this chapter gives you some first ideas of what all of that
    means.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的剩余部分将给你一些关于这一切意味着什么的初步想法。
- en: '![Icon “reading”](../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png) **Don’t worry
    about the details!**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![阅读图标](../Images/0fb62b2fc33a72829ae9fb174dedd0d2.png) **不必担心细节！**'
- en: Don’t worry if you don’t understand everything yet. This is just a quick peek
    at what’s coming up. Everything is explained in much more detail in the next chapters.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在还不完全理解，不要担心。这只是对即将发生的事情的一个快速预览。所有内容将在下一章中详细解释。
- en: '[41.2 Synchronous functions](#synchronous-functions)'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[41.2 同步函数](#synchronous-functions)'
- en: 'Normal functions are *synchronous*: the caller waits until the callee is finished
    with its computation. `divideSync()` in line A is a synchronous function call:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正常函数是 *同步的*：调用者等待被调用者完成其计算。行 A 中的 `divideSync()` 是一个同步函数调用：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[41.3 JavaScript executes tasks sequentially in a single process](#javascript-executes-tasks-sequentially-in-a-single-process)'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[41.3 JavaScript 在单个进程中按顺序执行任务](#javascript-executes-tasks-sequentially-in-a-single-process)'
- en: 'By default, JavaScript *tasks* are functions that are executed sequentially
    in a single process. That looks like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，JavaScript *任务* 是在单个进程中按顺序执行的函数。这看起来是这样的：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This loop is also called the *event loop* because events, such as clicking a
    mouse, add tasks to the queue.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环也被称为 *事件循环*，因为事件，例如点击鼠标，会将任务添加到队列中。
- en: Due to this style of cooperative multitasking, we don’t want a task to block
    other tasks from being executed while, for example, it waits for results coming
    from a server. The next subsection explores how to handle this case.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种协作多任务处理风格，我们不希望任务在等待来自服务器的结果时阻塞其他任务的执行。下一小节将探讨如何处理这种情况。
- en: '[41.4 Callback-based asynchronous functions](#roadmap-callbacks-for-async)'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[41.4 基于回调的异步函数](#roadmap-callbacks-for-async)'
- en: 'What if `divide()` needs a server to compute its result? Then the result should
    be delivered in a different manner: The caller shouldn’t have to wait (synchronously)
    until the result is ready; it should be notified (asynchronously) when it is.
    One way of delivering the result asynchronously is by giving `divide()` a callback
    function that it uses to notify the caller.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `divide()` 需要服务器来计算其结果呢？那么结果应该以不同的方式交付：调用者不需要（同步地）等待结果准备就绪；它应该在结果就绪时被通知（异步地）。异步交付结果的一种方式是给
    `divide()` 提供一个回调函数，它使用该回调函数来通知调用者。
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When there is an asynchronous function call:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当有异步函数调用时：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then the following steps happen:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后发生以下步骤：
- en: '`divideCallback()` sends a request to a server.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`divideCallback()` 向服务器发送请求。'
- en: Then the current task `main()` is finished and other tasks can be executed.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后当前任务 `main()` 完成，其他任务可以执行。
- en: 'When a response from the server arrives, it is either:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当服务器响应到达时，它要么是：
- en: 'An error `err`: Then the following task is added to the queue.'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个错误 `err`：然后以下任务被添加到队列中。
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A `result` value: Then the following task is added to the queue.'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `result` 值：然后以下任务被添加到队列中。
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[41.5 Promise-based asynchronous functions](#promisebased-asynchronous-functions)'
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[41.5 基于 Promise 的异步函数](#promisebased-asynchronous-functions)'
- en: 'Promises are two things:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Promise 是两件事：
- en: A standard pattern that makes working with callbacks easier.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种标准模式，使得使用回调函数变得更加容易。
- en: The mechanism on which *async functions* (the topic of the next subsection)
    are built.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步函数（下一小节的主题）所基于的机制。
- en: Invoking a Promise-based function looks as follows.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个基于 Promise 的函数看起来如下。
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[41.6 Async functions](#roadmap-async-functions)'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[41.6 异步函数](#roadmap-async-functions)'
- en: 'One way of looking at async functions is as better syntax for Promise-based
    code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 观察异步函数的一种方式是将其视为基于 Promise 代码的更好语法：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `dividePromise()` we are calling in line A is the same Promise-based function
    as in the previous section. But we now have synchronous-looking syntax for handling
    the call. `await` can only be used inside a special kind of function, an *async
    function* (note the keyword `async` in front of the keyword `function`). `await`
    pauses the current async function and returns from it. Once the awaited result
    is ready, the execution of the function continues where it left off.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 A 行调用的 `dividePromise()` 与前一部分中的相同，是基于 Promise 的函数。但现在我们有了一种看起来同步的语法来处理调用。`await`
    只能在一种特殊类型的函数中使用，即 *异步函数*（注意 `function` 关键字前的 `async` 关键字）。`await` 会暂停当前的异步函数并从中返回。一旦等待的结果准备就绪，函数的执行将继续从上次停止的地方继续。
