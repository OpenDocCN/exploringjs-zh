- en: 13 Alternatives to enums in TypeScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13 [TypeScript中枚举的替代方案]
- en: 原文：[https://exploringjs.com/tackling-ts/ch_enum-alternatives.html](https://exploringjs.com/tackling-ts/ch_enum-alternatives.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/tackling-ts/ch_enum-alternatives.html](https://exploringjs.com/tackling-ts/ch_enum-alternatives.html)
- en: '* * *'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 13.1 [Unions of singleton values](ch_enum-alternatives.html#unions-of-singleton-values)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 13.1 [单例值的联合](ch_enum-alternatives.html#unions-of-singleton-values)
- en: 13.1.1 [Primitive literal types](ch_enum-alternatives.html#primitive-literal-types)
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 13.1.1 [原始文字类型](ch_enum-alternatives.html#primitive-literal-types)
- en: 13.1.2 [Unions of string literal types](ch_enum-alternatives.html#unions-of-string-literal-types)
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 13.1.2 [字符串文字类型的联合](ch_enum-alternatives.html#unions-of-string-literal-types)
- en: 13.1.3 [Unions of symbol singleton types](ch_enum-alternatives.html#unions-of-symbol-singleton-types)
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 13.1.3 [符号单例类型的联合](ch_enum-alternatives.html#unions-of-symbol-singleton-types)
- en: '13.1.4 [Conclusion of this section: union types vs. enums](ch_enum-alternatives.html#conclusion-of-this-section-union-types-vs.-enums)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 13.1.4 [本节的结论：联合类型 vs. 枚举](ch_enum-alternatives.html#conclusion-of-this-section-union-types-vs.-enums)
- en: 13.2 [Discriminated unions](ch_enum-alternatives.html#discriminated-union)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 13.2 [鉴别联合](ch_enum-alternatives.html#discriminated-union)
- en: '13.2.1 [Step 1: the syntax tree as a class hierarchy](ch_enum-alternatives.html#step-1-the-syntax-tree-as-a-class-hierarchy)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 13.2.1 [步骤1：将语法树作为类层次结构](ch_enum-alternatives.html#step-1-the-syntax-tree-as-a-class-hierarchy)
- en: '13.2.2 [Step 2: the syntax tree as a union type of classes](ch_enum-alternatives.html#step-2-the-syntax-tree-as-a-union-type-of-classes)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 13.2.2 [步骤2：将语法树作为类的联合类型](ch_enum-alternatives.html#step-2-the-syntax-tree-as-a-union-type-of-classes)
- en: '13.2.3 [Step 3: the syntax tree as a discriminated union](ch_enum-alternatives.html#step-3-the-syntax-tree-as-a-discriminated-union)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 13.2.3 [步骤3：将语法树作为鉴别联合](ch_enum-alternatives.html#step-3-the-syntax-tree-as-a-discriminated-union)
- en: 13.2.4 [Discriminated unions vs. normal union types](ch_enum-alternatives.html#discriminated-unions-vs.-normal-union-types)
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 13.2.4 [鉴别联合 vs. 普通联合类型](ch_enum-alternatives.html#discriminated-unions-vs.-normal-union-types)
- en: 13.3 [Object literals as enums](ch_enum-alternatives.html#object-literals-as-enums)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 13.3 [对象字面量作为枚举](ch_enum-alternatives.html#object-literals-as-enums)
- en: 13.3.1 [Object literals with string-valued properties](ch_enum-alternatives.html#object-literals-with-string-valued-properties)
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 13.3.1 [具有字符串值属性的对象字面量](ch_enum-alternatives.html#object-literals-with-string-valued-properties)
- en: 13.3.2 [Upsides and downsides of using object literals as enums](ch_enum-alternatives.html#upsides-and-downsides-of-using-object-literals-as-enums)
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 13.3.2 [使用对象字面量作为枚举的优缺点](ch_enum-alternatives.html#upsides-and-downsides-of-using-object-literals-as-enums)
- en: 13.4 [Enum pattern](ch_enum-alternatives.html#enum-pattern)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 13.4 [枚举模式](ch_enum-alternatives.html#enum-pattern)
- en: 13.5 [Summary of enums and enum alternatives](ch_enum-alternatives.html#summary-of-enums-and-enum-alternatives)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 13.5 [枚举和枚举替代方案的总结](ch_enum-alternatives.html#summary-of-enums-and-enum-alternatives)
- en: 13.6 [Acknowledgement](ch_enum-alternatives.html#acknowledgement)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 13.6 [致谢](ch_enum-alternatives.html#acknowledgement)
- en: '* * *'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[The previous chapter](ch_enums.html) explored how TypeScript enums work. In
    this chapter, we take a look at alternatives to enums.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[上一章](ch_enums.html)探讨了TypeScript枚举的工作原理。在本章中，我们将看看枚举的替代方案。'
- en: 13.1 Unions of singleton values
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1 [单例值的联合](ch_enum-alternatives.html#unions-of-singleton-values)
- en: An enum maps member names to member values. If we don’t need or want the indirection,
    we can use a union of so-called *primitive literal types* – one per value. Before
    we can go into details, we need to learn about primitive literal types.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举将成员名称映射到成员值。如果我们不需要或不想要间接引用，我们可以使用所谓的*原始文字类型*的联合 - 每个值一个。在我们能够深入了解细节之前，我们需要了解原始文字类型。
- en: 13.1.1 Primitive literal types
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.1 [原始文字类型](ch_enum-alternatives.html#primitive-literal-types)
- en: '[Quick recap](ch_typescript-essentials.html#types-in-typescript): We can consider
    types to be sets of values.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[快速回顾](ch_typescript-essentials.html#types-in-typescript)：我们可以将类型视为值的集合。'
- en: 'A *singleton type* is a type with one element. Primitive literal types are
    singleton types:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*单例类型*是具有一个元素的类型。原始文字类型是单例类型：'
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`UndefinedLiteralType` is the type with the single element `undefined`, etc.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`UndefinedLiteralType`是具有单个元素`undefined`的类型，等等。'
- en: 'It is important to be aware of the two language levels at play here (we have
    already encountered those levels [earlier in this book](ch_typescript-essentials.html#language-levels)).
    Consider the following variable declaration:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意两个语言级别（我们在本书的[早些时候](ch_typescript-essentials.html#language-levels)已经遇到了这些级别）。考虑以下变量声明：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first `'abc'` represents a type (a string literal type).
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个'abc'表示一种类型（字符串文字类型）。
- en: The second `'abc'` represents a value.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个'abc'表示一个值。
- en: 'Two use cases for primitive literal types are:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 原始文字类型的两个用例是：
- en: '[Overloading on string parameters](ch_typing-functions.html#overloading-on-string-parameters)
    which enables the first argument of the following method call to determine the
    type of the second argument:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[字符串参数的重载](ch_typing-functions.html#overloading-on-string-parameters)使得以下方法调用的第一个参数决定第二个参数的类型：'
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can use a union of primitive literal types to define a type by enumerating
    its members:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用原始文字类型的联合来定义类型，通过列举其成员：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Read on for more information about the second use case.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 继续阅读有关第二个用例的更多信息。
- en: 13.1.2 Unions of string literal types
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.2 [字符串文字类型的联合](ch_enum-alternatives.html#unions-of-string-literal-types)
- en: We’ll start with an enum and convert it to a union of string literal types.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从枚举开始，然后将其转换为字符串文字类型的联合。
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`NoYesStrings` is the union type version of `NoYesEnum`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`NoYesStrings`是`NoYesEnum`的联合类型版本：'
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The type `NoYesStrings` is the union of the string literal types `'No'` and
    `'Yes'`. The union type operator `|` is related to the set-theoretic union operator
    `∪`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 类型`NoYesStrings`是字符串文字类型`'No'`和`'Yes'`的联合。联合类型运算符`|`与集合论的联合运算符`∪`相关。
- en: 13.1.2.1 Unions of string literal types can be checked for exhaustiveness
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.1.2.1 字符串文字类型的联合可以进行穷尽性检查
- en: 'The following code demonstrates that exhaustiveness checks work for unions
    of string literal types:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了对字符串文字类型的联合进行穷尽性检查：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We forgot the case for `'No'` and TypeScript warns us that the function may
    return values that are not strings.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忘记了'No'的情况，TypeScript警告我们该函数可能返回不是字符串的值。
- en: 'We could have also checked exhaustiveness more explicitly:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以更明确地检查穷尽性：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now TypeScript warns us that we reach the `default` case if `value` is `'No'`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 TypeScript 警告我们，如果 `value` 是 `'No'`，则会到达 `default` 情况。
- en: '![](../Images/65d35c0a2478236e12cc4321e1b02db6.png)  **More information on
    exhaustiveness checking**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/65d35c0a2478236e12cc4321e1b02db6.png)  **有关穷尽性检查的更多信息**'
- en: For more information on this topic, see [§12.7.2.2 “Protecting against forgetting
    cases via exhaustiveness checks”](ch_enums.html#exhaustiveness-checks).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此主题的更多信息，请参见[§12.7.2.2 “通过穷尽性检查防止遗漏情况”](ch_enums.html#exhaustiveness-checks)。
- en: '13.1.2.2 Downside: unions of string literals are less type-safe'
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.1.2.2 缺点：字符串文字的联合类型在类型安全性上不如其他类型
- en: 'One downside of string literal unions is that non-member values can mistaken
    for members:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串文字联合的一个缺点是非成员值可能被误认为是成员：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is logical because the Spanish `'no'` and the English `'no'` are the same
    value. The actual problem is that there is no way to give them different identities.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是合理的，因为西班牙语的 `'no'` 和英语的 `'no'` 是相同的值。实际问题在于没有办法给它们不同的标识。
- en: 13.1.3 Unions of symbol singleton types
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.3 符号单例类型的联合
- en: '13.1.3.1 Example: `LogLevel`'
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.1.3.1 示例：`LogLevel`
- en: 'Instead of unions of string literal types, we can also use unions of symbol
    singleton types. Let’s start with a different enum this time:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用符号单例类型的联合，而不是字符串文字类型的联合。这次让我们从一个不同的枚举开始：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Translated to a union of symbol singleton types, it looks as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为符号单例类型的联合，如下所示：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Why do we need `typeof` here? `off` etc. are values and can’t appear in type
    equations. The type operator `typeof` fixes this issue by converting values to
    types.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们在这里需要 `typeof`？`off` 等是值，不能出现在类型方程中。类型运算符 `typeof` 通过将值转换为类型来解决此问题。
- en: Let’s consider two variations of the previous example.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑前面示例的两种变体。
- en: '13.1.3.2 Variation #1: inlined symbols'
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '13.1.3.2 变体 #1：内联符号'
- en: 'Can we inline the symbols (instead of referring to separate `const` declarations)?
    Alas, the operand of the type operator `typeof` must be an identifier or a “path”
    of identifiers separated by dots. Therefore, this syntax is illegal:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以内联符号（而不是引用单独的 `const` 声明）吗？遗憾的是，类型运算符 `typeof` 的操作数必须是标识符或由点分隔的标识符“路径”。因此，这种语法是非法的：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '13.1.3.3 Variation #2: `let` instead of `const`'
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '13.1.3.3 变体 #2：`let` 而不是 `const`'
- en: Can we use `let` instead of `const` to declare the variables? (That’s not necessarily
    an improvement but still an interesting question.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `let` 而不是 `const` 来声明变量吗？（这不一定是一种改进，但仍然是一个有趣的问题。）
- en: 'We can’t because we need the narrower types that TypeScript infers for `const`-declared
    variables:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能这样做，因为我们需要 TypeScript 为 `const` 声明的变量推断出更窄的类型：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With `let`, `LogLevel` would simply have been an alias for `symbol`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `let`，`LogLevel` 只是 `symbol` 的别名。
- en: '`const` assertions normally solve this kind of problem. But they don’t work
    in this case:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`const` 断言通常解决这种问题。但在这种情况下不起作用：'
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 13.1.3.4 Using `LogLevel` in a function
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.1.3.4 在函数中使用 `LogLevel`
- en: 'The following function translates members of `LogLevel` to strings:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数将 `LogLevel` 的成员转换为字符串：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 13.1.3.5 Unions of symbol singleton types vs. unions of string literal types
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.1.3.5 符号单例类型的联合 vs. 字符串文字类型的联合
- en: How do the two approaches compare?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法如何比较？
- en: Exhaustiveness checks work for both.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 穷尽性检查对两者都适用。
- en: Using symbols is more verbose.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用符号更加冗长。
- en: Each symbol “literal” creates a unique symbol that can’t be confused with any
    other symbol. That’s not true for string literals. Read on for details.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个符号“文字”都创建一个独特的符号，不会与任何其他符号混淆。对于字符串文字来说并非如此。详情请继续阅读。
- en: 'Recall this example where the Spanish `''no''` was confused with the English
    `''no''`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下西班牙语的 `'no'` 被误认为是英语的 `'no'` 的例子：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we use symbols, we don’t have this problem:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用符号，我们就不会有这个问题：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '13.1.4 Conclusion of this section: union types vs. enums'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.4 本节的结论：联合类型 vs. 枚举
- en: 'Union types and enums have some things in common:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 联合类型和枚举有一些共同点：
- en: 'We can auto-complete member values. However, we do it differently:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以自动完成成员值。但我们做法不同：
- en: With enums, we get auto-completion after the enum name and a dot.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用枚举后，我们在枚举名称和点之后获得自动完成。
- en: With union types, we have to explicitly trigger auto-completion.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用联合类型，我们必须显式触发自动完成。
- en: Exhaustiveness checks also work for both.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 穷尽性检查对两者也适用。
- en: 'But they also differ. Downsides of unions of symbol singleton types are:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但它们也有不同之处。联合符号单例类型的缺点是：
- en: They are slightly verbose.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们稍微冗长。
- en: There is no namespace for their members.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们没有成员的命名空间。
- en: 'It’s slightly harder to migrate from them to different constructs (should it
    be necessary): It’s easier to find where enum member values are mentioned.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从它们迁移到不同的结构（如果有必要的话）稍微困难一些：更容易找到枚举成员值被提及的地方。
- en: 'Upsides of unions of symbol singleton types are:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 联合符号单例类型的优势是：
- en: They are not a custom TypeScript language construct and therefore closer to
    plain JavaScript.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不是自定义的 TypeScript 语言构造，因此更接近纯 JavaScript。
- en: String enums are only type-safe at compile time. Unions of symbol singleton
    types are additionally type-safe at runtime.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串枚举只在编译时是类型安全的。符号单例类型的联合在运行时也是类型安全的。
- en: This matters especially if our compiled TypeScript code interacts with plain
    JavaScript code.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这一点尤其重要，如果我们编译后的 TypeScript 代码与纯 JavaScript 代码交互。
- en: 13.2 Discriminated unions
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2 辨别联合
- en: '[Discriminated unions](https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions)
    are related to [algebraic data types](https://wiki.haskell.org/Algebraic_data_type)
    in functional programming languages.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[辨别联合](https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions)与函数式编程语言中的[代数数据类型](https://wiki.haskell.org/Algebraic_data_type)相关。'
- en: 'To understand how they work, consider the data structure *syntax tree* that
    represents expressions such as:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解它们的工作原理，请考虑表示表达式的数据结构 *语法树*：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A syntax tree is either:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 语法树要么是：
- en: A number
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数字
- en: The addition of two syntax trees
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个语法树的相加
- en: 'Next steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步：
- en: We’ll start by creating an object-oriented class hierarchy for syntax trees.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先为语法树创建一个面向对象的类层次结构。
- en: Then we’ll transform it into something slightly more functional.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将把它转换为稍微更加功能化的东西。
- en: And finally, we’ll end up with a discriminated union.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将得到一个歧视联合。
- en: '13.2.1 Step 1: the syntax tree as a class hierarchy'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.1 第1步：将语法树作为类层次结构
- en: 'This is a typical object-oriented implementation of a syntax tree:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的面向对象的语法树实现：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`SyntaxTree1` is the superclass of `NumberValue1` and `Addition1`. The keyword
    `public` is syntactic sugar for:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`SyntaxTree1`是`NumberValue1`和`Addition1`的超类。关键字`public`在语法上是为了方便：'
- en: Declaring the instance property `.numberValue`
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明实例属性`.numberValue`
- en: Initializing this property via the parameter `numberValue`
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过参数`numberValue`初始化该属性
- en: 'This is an example of using `SyntaxTree1`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`SyntaxTree1`的示例：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note: [Trailing commas in argument lists](https://exploringjs.com/es2016-es2017/ch_trailing-comma-parameters.html)
    are allowed in JavaScript since ECMAScript 2016.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：[JavaScript中允许在参数列表中使用尾随逗号](https://exploringjs.com/es2016-es2017/ch_trailing-comma-parameters.html)
    自ECMAScript 2016以来。
- en: '13.2.2 Step 2: the syntax tree as a union type of classes'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.2 第2步：将语法树作为类的联合类型
- en: 'If we define the syntax tree via a union type (line A), we don’t need object-oriented
    inheritance:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过联合类型定义语法树（行A），我们就不需要面向对象的继承：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Since `NumberValue2` and `Addition2` don’t have a superclass, they don’t need
    to invoke `super()` in their constructors.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`NumberValue2`和`Addition2`没有超类，它们不需要在它们的构造函数中调用`super()`。
- en: 'Interestingly, we create trees in the same manner as before:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们以与以前相同的方式创建树：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '13.2.3 Step 3: the syntax tree as a discriminated union'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.3 第3步：将语法树作为歧视联合
- en: 'Finally, we get to discriminated unions. These are the type definitions for
    `SyntaxTree3`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们转向了歧视联合。这些是`SyntaxTree3`的类型定义：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have switched from classes to interfaces and therefore from instances of
    classes to plain objects.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从类切换到了接口，因此从类的实例切换到了普通对象。
- en: The interfaces of a discriminated union must have at least one property in common
    and that property must have a different value for each one of them. That property
    is called the *discriminant* or *tag*. The discriminant of `SyntaxTree3` is `.kind`.
    Its types are [string literal types](ch_enum-alternatives.html#primitive-literal-types).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 歧视联合的接口必须至少有一个共同的属性，并且该属性必须对每个属性具有不同的值。该属性称为*歧视器*或*标签*。`SyntaxTree3`的歧视器是`.kind`。它的类型是[字符串字面类型](ch_enum-alternatives.html#primitive-literal-types)。
- en: 'Compare:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 比较：
- en: The direct class of an instance is determined by its prototype.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例的直接类由其原型确定。
- en: The type of a member of a discriminated union is determined by its discriminant.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 歧视联合的成员类型由其歧视器确定。
- en: 'This is an object that matches `SyntaxTree3`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个与`SyntaxTree3`匹配的对象：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We don’t need the type annotation in line A, but it helps ensure that the data
    has the correct structure. If we don’t do it here, we’ll find out about problems
    later.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在A行不需要类型注释，但它有助于确保数据具有正确的结构。如果我们不在这里这样做，我们以后会发现问题。
- en: 'In the next example, the type of `tree` is a discriminated union. Every time
    we check its discriminant (line C), TypeScript updates its static type accordingly:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，`tree`的类型是歧视联合。每次检查其歧视器（行C）时，TypeScript都会相应地更新其静态类型：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In line A, we haven’t checked the discriminant `.kind`, yet. Therefore, the
    current type of `tree` is still `SyntaxTree3` and we can’t access property `.numberValue`
    in line B (because only one of the types of the union has this property).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在A行，我们还没有检查过歧视器`.kind`。因此，`tree`的当前类型仍然是`SyntaxTree3`，我们无法在B行访问属性`.numberValue`（因为联合类型的类型只有一个具有此属性）。
- en: In line D, TypeScript knows that `.kind` is `'number-value'` and can therefore
    infer the type `NumberValue3` for `tree`. That’s why accessing `.numberValue`
    in the next line is OK, this time.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在D行，TypeScript知道`.kind`是`'number-value'`，因此可以推断出`tree`的类型为`NumberValue3`。这就是为什么在下一行访问`.numberValue`是可以的，这次。
- en: 13.2.3.1 Implementing functions for discriminated unions
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.2.3.1 实现歧视联合的函数
- en: We conclude this step with an example of how to implement functions for discriminated
    unions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用一个实现歧视联合的函数示例来结束这一步。
- en: 'If there is an operation that can be applied to members of all subtypes, the
    approaches for classes and discriminated unions differ:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个操作可以应用于所有子类型的成员，则类和歧视联合的方法不同：
- en: 'Object-oriented approach: With classes, it is common to use a polymorphic method
    where each class has a different implementation.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象的方法：使用类时，通常使用多态方法，其中每个类都有不同的实现。
- en: 'Functional approach: With discriminated unions, it is common to use a single
    function that handles all possibles cases and decides what to do by examining
    the discriminant of its parameter.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能方法：使用歧视联合时，通常使用一个处理所有可能情况并通过检查其参数的歧视器来决定要执行什么操作的单个函数。
- en: The following example demonstrates the functional approach. The discriminant
    is examined in line A and determines which of the two `switch` cases is executed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了功能方法。歧视器在A行进行检查，并确定执行哪个`switch`情况。
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note that TypeScript performs exhaustiveness checking for discriminated unions:
    If we forget a case, TypeScript will warn us.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，TypeScript对歧视联合执行穷尽性检查：如果我们忘记了某种情况，TypeScript会警告我们。
- en: 'This is the object-oriented version of the previous code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是先前代码的面向对象版本：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '13.2.3.2 Extensibility: object-oriented approach vs. functional approach'
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.2.3.2 可扩展性：面向对象的方法 vs. 功能方法
- en: 'Each approach does one kind of extensibility well:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都很好地实现了一种可扩展性：
- en: With the object-oriented approach, we have to modify each class if we want to
    add a new operation. However, adding a new type does not require any changes to
    existing code.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用面向对象的方法，如果我们想要添加新操作，就必须修改每个类。但是，添加新类型不需要对现有代码进行任何更改。
- en: With the functional approach, we have to modify each function if we want to
    add a new type. In contrast, adding new operations is simple.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用功能方法时，如果我们想要添加新类型，就必须修改每个函数。相反，添加新操作很简单。
- en: 13.2.4 Discriminated unions vs. normal union types
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.4 歧视联合 vs. 普通联合类型
- en: 'Discriminated unions and normal union types have two things in common:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 辨别联合和普通联合类型有两个共同点：
- en: There is no namespace for member values.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有成员值的命名空间。
- en: TypeScript performs exhaustiveness checking.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript执行穷举检查。
- en: 'The next two subsections explore two advantages of discriminated unions over
    normal unions:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个小节探讨了辨别联合相对于普通联合的两个优势：
- en: '13.2.4.1 Benefit: descriptive property names'
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.2.4.1 好处：描述性属性名称
- en: 'With discriminated unions, values get descriptive property names. Let’s compare:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过辨别联合，值得到了描述性的属性名称。让我们比较一下：
- en: 'Normal union:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 普通联合：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Discriminated union:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 辨别联合：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now people who read the source code immediately know what the string is: a
    native pathname.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在阅读源代码的人立即知道字符串是什么：一个本地路径名。
- en: '13.2.4.2 Benefit: We can also use it when the parts are indistinguishable'
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.2.4.2 好处：当部分是无法区分时，我们也可以使用它
- en: The following discriminated union cannot be implemented as a normal union because
    we can’t distinguish the types of the union in TypeScript.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下辨别联合不能作为普通联合实现，因为我们无法在TypeScript中区分联合的类型。
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 13.3 Object literals as enums
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3 对象文字作为枚举
- en: 'The following pattern for implementing enums is common in JavaScript:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，实现枚举的常见模式如下：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can attempt to use it in TypeScript as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试在TypeScript中使用它如下：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Alas, the type of each property of `Color` is `symbol` (line A) and `TColor`
    (line B) is an alias for `symbol`. As a consequence, we can pass any symbol to
    `toGerman()` and TypeScript won’t complain at compile time:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，`Color`的每个属性的类型都是`symbol`（A行），而`TColor`（B行）是`symbol`的别名。因此，我们可以将任何符号传递给`toGerman()`，TypeScript在编译时不会抱怨：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'A `const` assertion often helps in this kind of situation but not this time:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`断言通常在这种情况下有所帮助，但这次不行：'
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The only way to fix this is via constants:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一修复这个问题的方法是通过常量：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 13.3.1 Object literals with string-valued properties
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.1 具有字符串值属性的对象文字
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We need [`as const`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions)
    in line A so that the properties of `Color` don’t have the more general type `string`.
    Then `TColor` also has a type that is more specific than `string`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在A行使用[`as const`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions)，这样`Color`的属性就不会有更一般的`string`类型。然后`TColor`也有一个比`string`更具体的类型。
- en: 'Compared to using an object with symbol-valued properties as an enum, string-valued
    properties are:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用具有符号值属性的对象作为枚举相比，具有字符串值属性的对象为：
- en: Better at development time because we get exhaustiveness checks and can derive
    a narrow type for the values (without using external constants).
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发时更好，因为我们得到穷举检查，并且可以为值派生一个狭窄的类型（不使用外部常量）。
- en: Worse at runtime because strings can be mistaken for enum values.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时更糟糕，因为字符串可能被误认为是枚举值。
- en: 13.3.2 Upsides and downsides of using object literals as enums
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.2 使用对象文字作为枚举的优势和劣势
- en: 'Upsides:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 优势：
- en: We have a namespace for the values.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个值的命名空间。
- en: We don’t use a custom construct and are closer to plain JavaScript.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不使用自定义构造，更接近纯JavaScript。
- en: We can derive a narrow type for enum values (if we use string-valued properties).
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以为枚举值派生一个狭窄的类型（如果我们使用字符串值属性）。
- en: Exhaustiveness checks are performed for such a type.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对这种类型执行穷举检查。
- en: 'Downsides:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 劣势：
- en: No dynamic membership check is possible (without extra work).
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有动态成员检查（没有额外工作）。
- en: Non-enum values can be mistaken for enum values statically or at runtime (if
    we use string-valued properties).
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非枚举值可以在静态或运行时被误认为是枚举值（如果我们使用字符串值属性）。
- en: 13.4 Enum pattern
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4 枚举模式
- en: 'The following example demonstrates [a Java-inspired enum pattern](https://2ality.com/2020/01/enum-pattern.html)
    that works in plain JavaScript and TypeScript:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了[受Java启发的枚举模式](https://2ality.com/2020/01/enum-pattern.html)，它适用于纯JavaScript和TypeScript：
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Alas, TypeScript doesn’t perform exhaustiveness checks, which is why we get
    an error in line A.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，TypeScript不执行穷举检查，这就是为什么我们在A行得到一个错误的原因。
- en: 13.5 Summary of enums and enum alternatives
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5 枚举和枚举替代方案的总结
- en: 'The following table summarizes the characteristics of enums and their alternatives
    in TypeScript:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了TypeScript中枚举及其替代方案的特点：
- en: '|  | Unique | Namesp. | Iter. | Mem. CT | Mem. RT | Exhaust. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '|  | 唯一 | 命名空间 | 迭代 | 内存 CT | 内存 RT | 穷举 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| Number enums | `-` | `✔` | `✔` | `✔` | `-` | `✔` |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 数字枚举 | `-` | `✔` | `✔` | `✔` | `-` | `✔` |'
- en: '| String enums | `✔` | `✔` | `✔` | `✔` | `-` | `✔` |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 字符串枚举 | `✔` | `✔` | `✔` | `✔` | `-` | `✔` |'
- en: '| String unions | `-` | `-` | `-` | `✔` | `-` | `✔` |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 字符串联合 | `-` | `-` | `-` | `✔` | `-` | `✔` |'
- en: '| Symbol unions | `✔` | `-` | `-` | `✔` | `-` | `✔` |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 符号联合 | `✔` | `-` | `-` | `✔` | `-` | `✔` |'
- en: '| Discrim. unions | `-` (1) | `-` | `-` | `✔` | `-` (2) | `✔` |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 辨别联合 | `-`（1） | `-` | `-` | `✔` | `-`（2） | `✔` |'
- en: '| Symbol properties | `✔` | `✔` | `✔` | `-` | `-` | `-` |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 符号属性 | `✔` | `✔` | `✔` | `-` | `-` | `-` |'
- en: '| String properties | `-` | `✔` | `✔` | `✔` | `-` | `✔` |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 字符串属性 | `-` | `✔` | `✔` | `✔` | `-` | `✔` |'
- en: '| Enum pattern | `✔` | `✔` | `✔` | `✔` | `✔` | `-` |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 枚举模式 | `✔` | `✔` | `✔` | `✔` | `✔` | `-` |'
- en: 'Titles of table columns:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 表格列的标题：
- en: 'Unique values: No non-enum value can be mistaken for an enum value.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一值：没有非枚举值可以被误认为是枚举值。
- en: Namespace for enum keys
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举键的命名空间
- en: Is it possible to iterate over enum values?
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否可以遍历枚举值？
- en: 'Membership check for values at compile time: Is there a narrow type for the
    enum values?'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译时值的成员检查：是否有枚举值的狭窄类型？
- en: 'Membership check for values at runtime:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时值的成员检查：
- en: For the enum pattern, the runtime membership test is `instanceof`.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于枚举模式，运行时成员检查是`instanceof`。
- en: Note that a membership test can be implemented relatively easily if it is possible
    to iterate over enum values.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，如果可以遍历枚举值，成员检查可以相对容易地实现。
- en: Exhaustiveness check (statically by TypeScript)
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 穷举检查（TypeScript静态检查）
- en: 'Footnotes in table cells:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 表格单元格中的脚注：
- en: Discriminated unions are not really unique, but mistaking values for union members
    is relatively unlikely (especially if we use a unique name for the discriminant
    property).
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 辨别联合并不是真正独特的，但是将值误认为联合成员的可能性相对较小（特别是如果我们为辨别属性使用唯一的名称）。
- en: If the discriminant property has a unique enough name, it can be used to check
    membership.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果辨别属性有一个足够独特的名称，它可以用来检查成员资格。
- en: 13.6 Acknowledgement
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.6 致谢
- en: Thanks to [Kirill Sukhomlin](https://twitter.com/kirilloid_ru) for his suggestion
    on how to define `TColor` for an object literal.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 感谢[Kirill Sukhomlin](https://twitter.com/kirilloid_ru)提出了如何为对象文字定义`TColor`的建议。
- en: '[Comments](https://github.com/rauschma/tackling-ts/issues/13)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[评论](https://github.com/rauschma/tackling-ts/issues/13)'
