- en: 27 Typing functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 27 函数类型化
- en: 原文：[https://exploringjs.com/ts/book/ch_typing-functions.html](https://exploringjs.com/ts/book/ch_typing-functions.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/ts/book/ch_typing-functions.html](https://exploringjs.com/ts/book/ch_typing-functions.html)
- en: (Ad, please don’t block.)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: (广告，请勿拦截。)
- en: '[27.1 Defining statically typed functions](#defining-statically-typed-functions)'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.1 定义静态类型函数](#defining-statically-typed-functions)'
- en: '[27.1.1 Function declarations](#function-declarations)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.1.1 函数声明](#function-declarations)'
- en: '[27.1.2 Arrow functions](#arrow-functions)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.1.2 箭头函数](#arrow-functions)'
- en: '[27.2 Types for functions](#types-for-functions)'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.2 函数类型](#types-for-functions)'
- en: '[27.2.1 Function type signatures](#function-type-signatures)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.2.1 函数类型签名](#function-type-signatures)'
- en: '[27.2.2 Interfaces with call signatures](#call-signatures)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.2.2 具有调用签名的接口](#call-signatures)'
- en: '[27.2.3 Checking if a callable value matches a function type](#checking-if-a-callable-value-matches-a-function-type)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.2.3 检查可调用值是否匹配函数类型](#checking-if-a-callable-value-matches-a-function-type)'
- en: '[27.3 Parameters](#parameters)'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.3 参数](#parameters)'
- en: '[27.3.1 When do parameters have to be type-annotated?](#when-do-parameters-have-to-be-type-annotated)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.3.1 何时需要为参数添加类型注解？](#when-do-parameters-have-to-be-type-annotated)'
- en: '[27.3.2 Optional parameters](#optional-parameters-1)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.3.2 可选参数](#optional-parameters-1)'
- en: '[27.3.3 Rest parameters](#rest-parameters-1)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.3.3 剩余参数](#rest-parameters-1)'
- en: '[27.3.4 Named parameters](#named-parameters)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.3.4 命名参数](#named-parameters)'
- en: '[27.3.5 `this` as a parameter (advanced)](#this-as-a-parameter-advanced)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.3.5 `this`作为参数（高级）](#this-as-a-parameter-advanced)'
- en: '[27.4 Return type `never`: functions that don’t return](#return-type-never)'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.4 返回类型`never`：不返回的函数](#return-type-never)'
- en: '[27.4.1 Reasons against the return type `never | T`](#reasons-against-the-return-type-never-t)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.4.1 反对返回类型`never | T`的原因](#reasons-against-the-return-type-never-t)'
- en: '[27.4.2 The return type `never` in `@types/node`](#the-return-type-never-in-types-node)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.4.2 `@types/node`中的返回类型`never`](#the-return-type-never-in-types-node)'
- en: '[27.5 Overloading (advanced)](#overloading-advanced)'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.5 重载（高级）](#overloading-advanced)'
- en: '[27.5.1 Overloading function declarations](#overloading-function-declarations)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.5.1 重载函数声明](#overloading-function-declarations)'
- en: '[27.5.2 Overloading functions via a union of tuple types](#overloading-functions-via-a-union-of-tuple-types)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.5.2 通过元组类型的联合重载函数](#overloading-functions-via-a-union-of-tuple-types)'
- en: '[27.5.3 Overloading functions via interfaces](#overloading-functions-via-interfaces)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.5.3 通过接口重载函数](#overloading-functions-via-interfaces)'
- en: '[27.5.4 Overloading on string parameters (event handling etc.)](#overloading-on-string-parameters)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.5.4 基于字符串参数的重载（事件处理等）](#overloading-on-string-parameters)'
- en: '[27.5.5 Overloading methods](#overloading-methods)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.5.5 重载方法](#overloading-methods)'
- en: '[27.6 Assignability (advanced)](#assignability)'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.6 可赋值性（高级）](#assignability)'
- en: '[27.6.1 The rules for assignability](#the-rules-for-assignability)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.6.1 可赋值性的规则](#the-rules-for-assignability)'
- en: '[27.6.2 Consequences of the assignment rules for functions](#consequences-of-the-assignment-rules-for-functions)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.6.2 函数赋值规则的影响](#consequences-of-the-assignment-rules-for-functions)'
- en: '[27.7 Further reading and sources of this chapter](#further-reading-and-sources-of-this-chapter)'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[27.7 本章的进一步阅读和资源](#further-reading-and-sources-of-this-chapter)'
- en: This chapter explores static typing for functions in TypeScript.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了TypeScript中函数的静态类型。
- en: '![Icon “reading”](../Images/00b0d6029a045810b908b88d1a6733d2.png) **in this
    chapter, “function” means “function or method or constructor”**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“阅读”](../Images/00b0d6029a045810b908b88d1a6733d2.png) **在本章中，“函数”指的是“函数、方法或构造函数”**'
- en: In this chapter, most things that are said about functions (especially w.r.t.
    parameter handling), also apply to methods and constructors.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，关于函数的大部分内容（尤其是关于参数处理的内容），也适用于方法和构造函数。
- en: '[27.1 Defining statically typed functions](#defining-statically-typed-functions)'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[27.1 定义静态类型函数](#defining-statically-typed-functions)'
- en: '[27.1.1 Function declarations](#function-declarations)'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.1.1 函数声明](#function-declarations)'
- en: 'This is an example of a function declaration in TypeScript:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个TypeScript中函数声明的示例：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Parameters: If the compiler option `--noImplicitAny` is on (which it is if
    `--strict` is on), then the type of each parameter must be either inferrable or
    explicitly specified. (We’ll take a closer look at inference later.) For parameters,
    no inference is possible, which is why `str` and `times` have type annotations.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数：如果编译器选项`--noImplicitAny`开启（如果`--strict`开启，则默认开启），则每个参数的类型必须是可推断的或显式指定的。（我们稍后会详细探讨推断。）对于参数，无法进行推断，这就是为什么`str`和`times`有类型注解。
- en: 'Return type: By default, the return type of functions is inferred. That is
    usually good enough. We opted to explicitly specify that `repeat1()` has the return
    type `string` (last type annotation in line A).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回类型：函数的默认返回类型是推断的。这通常足够好。我们选择显式指定 `repeat1()` 的返回类型为 `string`（行 A 中的最后一个类型注解）。
- en: '[27.1.2 Arrow functions](#arrow-functions)'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.1.2 箭头函数](#arrow-functions)'
- en: 'The arrow function version of `repeat1()` looks as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat1()` 的箭头函数版本如下所示：'
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Arrow functions can also have expression bodies:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数也可以有表达式体：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[27.2 Types for functions](#types-for-functions)'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[27.2 函数类型](#types-for-functions)'
- en: '[27.2.1 Function type signatures](#function-type-signatures)'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.2.1 函数类型签名](#function-type-signatures)'
- en: 'We can define types for functions via function type signatures:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过函数类型签名来定义函数类型：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The name of this function type is `Repeat`. It has:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数类型的名称是 `Repeat`。它有：
- en: Two parameters whose types are `string` and `number`. We need to name parameters
    in function type signatures, but the names are ignored when checking if two function
    types are compatible.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个类型为 `string` 和 `number` 的参数。我们需要在函数类型签名中命名参数，但在检查两个函数类型是否兼容时，这些名称会被忽略。
- en: The return type `string`. Note that this time, the type is separated by an arrow
    and can’t be omitted.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回类型 `string`。注意，这次类型是由箭头分隔的，不能省略。
- en: Which functions are assignable to this type? At least those that have the same
    parameter types and return type. But some others are assignable too. We’ll see
    which ones, when we explore the rules for [*assignability*](#assignability) later
    in this chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些函数可以分配给这个类型？至少是那些具有相同参数类型和返回类型的函数。但还有一些其他的函数也可以分配。我们将在本章后面探索可分配性规则时看到哪些。
- en: '[27.2.2 Interfaces with call signatures](#call-signatures)'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.2.2 具有调用签名的接口](#call-signatures)'
- en: 'We can also use interfaces to define function types:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用接口来定义函数类型：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: The interface member in line A is a *call signature*. It looks similar to a
    method signature, but doesn’t have a name.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 A 中的接口成员是一个 *调用签名*。它看起来类似于方法签名，但没有名称。
- en: The type of the result is separated by a colon (not an arrow) and can’t be omitted.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果的类型由冒号（而不是箭头）分隔，不能省略。
- en: 'On one hand, interfaces are more verbose. On the other hand, they let us specify
    properties of functions (which is rare, but does happen):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，接口更冗长。另一方面，它们允许我们指定函数的属性（虽然很少见，但确实会发生）：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can also specify properties via an intersection type (`&`) of a function
    signature type and an object literal type:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过函数签名类型和对象字面量类型的交集类型（`&`）来指定属性：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[27.2.3 Checking if a callable value matches a function type](#checking-if-a-callable-value-matches-a-function-type)'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.2.3 检查可调用值是否匹配函数类型](#checking-if-a-callable-value-matches-a-function-type)'
- en: 'As an example, consider this scenario: A library exports the following function
    type.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下场景：一个库导出以下函数类型。
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We want to define a function whose type is compatible with `StringPredicate`.
    And we want to check immediately if that’s indeed the case (vs. finding out later
    when we use it for the first time).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想定义一个与 `StringPredicate` 兼容类型的函数，并且我们想立即检查这确实是这样（而不是在我们第一次使用它时才发现）。
- en: '[27.2.3.1 Checking arrow functions](#checking-arrow-functions)'
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[27.2.3.1 检查箭头函数](#checking-arrow-functions)'
- en: 'If we declare a variable via `const`, we can perform the check via a type annotation:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过 `const` 声明一个变量，我们可以通过类型注解来执行检查：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that we don’t need to specify the type of parameter `str` because TypeScript
    can use `StringPredicate` to infer it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要指定参数 `str` 的类型，因为 TypeScript 可以使用 `StringPredicate` 来推断它。
- en: '[27.2.3.2 Checking function declarations (simple)](#checking-function-declarations-simple)'
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[27.2.3.2 检查函数声明（简单）](#checking-function-declarations-simple)'
- en: 'Checking function declarations is more complicated. Consider the following
    function declaration:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 检查函数声明更复杂。考虑以下函数声明：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These are two built-in ways in which we can check assignability:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们检查可分配性的两种内置方式：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`satisfies` is explained in [“The `satisfies` operator” (§29)](ch_satisfies.html#ch_satisfies).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`satisfies` 在 [“`satisfies` 操作符”（§29）](ch_satisfies.html#ch_satisfies) 中解释。'
- en: 'The following two checks require the library `asserttt`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个检查需要库 `asserttt`：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that all checks but the last one produce unnecessary JavaScript code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了最后一个检查之外，所有检查都会产生不必要的 JavaScript 代码。
- en: '[27.2.3.3 Checking function declarations (extravagant)](#checking-function-declarations-extravagant)'
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[27.2.3.3 检查函数声明（奢侈）](#checking-function-declarations-extravagant)'
- en: 'The following solution is something you’d usually not do – so no worries if
    you don’t fully understand it. But it nicely demonstrates several advanced features:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下解决方案是你通常不会做的事情——所以如果你不完全理解它，请不要担心。但它很好地展示了几个高级功能：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Parameters: We use the utility type `Parameters<>` to extract a tuple with
    the parameter types. The three dots declare a rest parameter, which collects all
    parameters in a tuple/Array. `[str]` destructures that tuple. (More on rest parameters
    later in this chapter.)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数：我们使用实用类型 `Parameters<>` 来提取一个包含参数类型的元组。三个点声明了一个剩余参数，它收集所有参数到一个元组/数组中。`[str]`
    解构这个元组。（关于剩余参数的更多内容将在本章后面介绍。）
- en: 'Return value: We use the utility type `ReturnType<>` to extract the return
    type.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值：我们使用实用类型 `ReturnType<>` 来提取返回类型。
- en: The built-in utility types `Parameters<>` and `ReturnType<>` are explained in
    [“Extracting parts of function types via `infer`” (§35.3.1)](ch_infer-keyword.html#extracting-parts-of-function-types).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 内置实用类型 `Parameters<>` 和 `ReturnType<>` 在 [“通过 `infer` 提取函数类型的一部分” (§35.3.1)](ch_infer-keyword.html#extracting-parts-of-function-types)
    中进行了解释。
- en: '[27.3 Parameters](#parameters)'
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[27.3 参数](#parameters)'
- en: '[27.3.1 When do parameters have to be type-annotated?](#when-do-parameters-have-to-be-type-annotated)'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.3.1 参数何时需要类型注解？](#when-do-parameters-have-to-be-type-annotated)'
- en: 'Recap: If `--noImplicitAny` is switched on (`--strict` switches it on), the
    type of each parameter must either be inferrable or explicitly specified.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾：如果 `--noImplicitAny` 被打开（`--strict` 会打开它），每个参数的类型必须是可以推断的或必须显式指定。
- en: 'In the following example, TypeScript can’t infer the type of `str` and we must
    specify it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，TypeScript 无法推断 `str` 的类型，我们必须指定它：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In line A, TypeScript can use the type `StringMapFunction` to infer the type
    of `str` and we don’t need to add a type annotation:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 A 中，TypeScript 可以使用类型 `StringMapFunction` 来推断 `str` 的类型，我们不需要添加类型注解：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, TypeScript can use the type of `.map()` to infer the type of `str`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，TypeScript 可以使用 `.map()` 的类型来推断 `str` 的类型：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is the type of `.map()`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种 `.map()` 类型：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[27.3.2 Optional parameters](#optional-parameters-1)'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.3.2 可选参数](#optional-parameters-1)'
- en: In this section, we look at several ways in which we can allow parameters to
    be omitted.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了几种允许省略参数的方法。
- en: '[27.3.2.1 Optional parameter: `str?: string`](#optional-parameter-str-string)'
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[27.3.2.1 可选参数：`str?: string`](#optional-parameter-str-string)'
- en: 'If we put a question mark after the name of a parameter, that parameter becomes
    optional and can be omitted when calling the function:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在参数名称后加上问号，该参数变为可选的，在调用函数时可以省略：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is how `trim1()` can be invoked:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是调用 `trim1()` 的方法：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As an aside, the following two types are equal (`Equal<>` is a strict check)
    because the optional modifier (`?`) implies the type `undefined`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，以下两种类型是相等的（`Equal<>` 是严格检查）因为可选修饰符（`?`）意味着类型 `undefined`：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[27.3.2.2 Union type: `str: string | undefined`](#union-type-str-string-undefined)'
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[27.3.2.2 联合类型：`str: string | undefined`](#union-type-str-string-undefined)'
- en: Externally, parameter `str` of `trim1()` has the type `string | undefined`.
    Therefore, `trim1()` is mostly equivalent to the following function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 外部，`trim1()` 的参数 `str` 类型为 `string | undefined`。因此，`trim1()` 主要等同于以下函数。
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The only way in which `trim2()` is different from `trim1()` is that the parameter
    can’t be omitted in function calls (line A). In other words: We must be explicit
    when omitting a parameter whose type is `T|undefined`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`trim2()` 与 `trim1()` 的唯一区别是参数在函数调用中不能省略（行 A）。换句话说：当我们省略类型为 `T|undefined` 的参数时，我们必须明确。'
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[27.3.2.3 Parameter default value: `str = ''''`](#parameter-default-value-str)'
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[27.3.2.3 参数默认值：`str = ''''`](#parameter-default-value-str)'
- en: 'If we specify a parameter default value for `str`, we don’t need to provide
    a type annotation because TypeScript can infer the type:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为 `str` 指定默认值，我们不需要提供类型注解，因为 TypeScript 可以推断类型：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The internal type of `str` is `string` because the default value ensures that
    it is never `undefined`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`str` 的内部类型是 `string`，因为默认值确保它永远不会是 `undefined`。'
- en: 'Let’s invoke `trim3()`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们调用 `trim3()`:'
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[27.3.2.4 Parameter default value plus type annotation](#parameter-default-value-plus-type-annotation)'
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[27.3.2.4 参数默认值加上类型注解](#parameter-default-value-plus-type-annotation)'
- en: 'We can also specify both a type and a default value:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以同时指定类型和默认值：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[27.3.3 Rest parameters](#rest-parameters-1)'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.3.3 剩余参数](#rest-parameters-1)'
- en: A rest parameter collects all remaining parameters in an Array. Therefore, its
    static type is an Array or a tuple.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余参数收集所有剩余的参数到一个数组中。因此，它的静态类型是数组或元组。
- en: '[27.3.3.1 Rest parameters with Array types](#rest-parameters-with-array-types)'
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[27.3.3.1 带有数组类型的剩余参数](#rest-parameters-with-array-types)'
- en: 'In the following example, the rest parameter `parts` has an Array type:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，剩余参数 `parts` 具有数组类型：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[27.3.3.2 Rest parameters with tuple types](#rest-parameters-with-tuple-types)'
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[27.3.3.2 带有元组类型的剩余参数](#rest-parameters-with-tuple-types)'
- en: 'The next example demonstrates two features:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例演示了两个功能：
- en: We use the tuple type `[string, number]` for a rest parameter.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用元组类型 `[string, number]` 作为剩余参数。
- en: We destructure the rest parameter – which is a JavaScript feature.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们解构剩余参数 – 这是一个 JavaScript 功能。
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`repeat1()` is equivalent to the following function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat1()` 等同于以下函数：'
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[27.3.4 Named parameters](#named-parameters)'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.3.4 命名参数](#named-parameters)'
- en: '[*Named parameters*](https://exploringjs.com/js/book/ch_callables.html#named-parameters)
    are a popular pattern in JavaScript where an object literal is used to give each
    parameter a name. That looks as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[*命名参数*](https://exploringjs.com/js/book/ch_callables.html#named-parameters)
    是 JavaScript 中的一种流行模式，其中使用对象字面量为每个参数命名。其外观如下：'
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In plain JavaScript, functions can use destructuring to access named parameter
    values. Alas, in TypeScript, we additionally have to specify a type for the object
    literal and that leads to redundancies:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯 JavaScript 中，函数可以使用解构来访问命名参数值。然而，在 TypeScript 中，我们还需要为对象字面量指定一个类型，这会导致冗余：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that the destructuring (incl. the default value for `fillStr`) all happens
    in line A, while line B is exclusively about TypeScript.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，解构（包括 `fillStr` 的默认值）都在行 A 中完成，而行 B 则完全关于 TypeScript。
- en: 'We can also define a separate type instead of the inlined object literal type
    that we used in line B:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以定义一个单独的类型，而不是在行 B 中使用的内联对象字面量类型：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: An upside is that the function declaration is less cluttered. A downside that
    we have to look elsewhere to see the types.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优点是函数声明更加简洁。一个缺点是我们必须在其他地方查看类型。
- en: '[27.3.5 `this` as a parameter (advanced)](#this-as-a-parameter-advanced)'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.3.5 `this` 作为参数（高级）](#this-as-a-parameter-advanced)'
- en: 'Each ordinary function always has the implicit parameter `this` – which enables
    it to be used as a method in objects. Sometimes we need to specify a type for
    `this`. There is TypeScript-only syntax for this use case: One of the parameters
    of an ordinary function can have the name `this`. Such a parameter only exists
    at compile time and disappears at runtime.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每个普通函数始终都有一个隐式参数 `this` – 这使得它可以在对象中用作方法。有时我们需要为 `this` 指定一个类型。对于这种情况，TypeScript
    提供了专门的语法：普通函数的一个参数可以命名为 `this`。这样的参数仅在编译时存在，在运行时消失。
- en: 'As an example, consider the following interface for DOM event sources (in a
    slightly simplified version):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下 DOM 事件源的接口（在略微简化的版本中）：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `this` of the callback `listener` is always an instance of `EventSource`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 回调 `listener` 的 `this` 总是 `EventSource` 的一个实例。
- en: 'The next example demonstrates that TypeScript uses the type information provided
    by the `this` parameter to check the first argument of `.call()` (line A and line
    B):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例演示 TypeScript 如何使用 `this` 参数提供的类型信息来检查 `.call()` 的第一个参数（行 A 和行 B）：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Additionally, we can’t invoke `toIsoString()` as a method of an object `obj`
    because then its receiver isn’t an instance of `Date`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们无法将 `toIsoString()` 作为对象 `obj` 的方法调用，因为这样它的接收者不是 `Date` 的实例：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[27.4 Return type `never`: functions that don’t return](#return-type-never)'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[27.4 返回类型 `never`：不返回的函数](#return-type-never)'
- en: '`never` also serves as a marker for functions that never return – e.g.:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`never` 还可以作为永远不会返回的函数的标记 – 例如：'
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: TypeScript’s type inference takes such functions into consideration. For example,
    the inferred return type of `returnStringIfTrue()` is `string` because we invoke
    `throwError()` in line A.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的类型推断会考虑这样的函数。例如，`returnStringIfTrue()` 推断的返回类型是 `string`，因为我们调用了行
    A 中的 `throwError()`。
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we omit line A then we get an error and the inferred return type is `''abc''
    | undefined`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们省略行 A，则会得到一个错误，并且推断的返回类型是 `'abc' | undefined`：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[27.4.1 Reasons against the return type `never | T`](#reasons-against-the-return-type-never-t)'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.4.1 反对返回类型 `never | T` 的理由](#reasons-against-the-return-type-never-t)'
- en: 'In principle we could use the type `never | T` for a function that, in some
    cases, throws an exception and does not return normally. However there are two
    reasons against doing that:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，我们可以使用类型 `never | T` 来表示一个函数，在某些情况下会抛出异常而不是正常返回。然而，有两大理由反对这样做：
- en: Throwing an exception normally does not change the return type of a function.
    That’s why it’s called an *exception*.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出异常通常不会改变函数的返回类型。这就是为什么它被称为*异常*。
- en: '`never | T` is the same as `T` (as we have seen previously in this chapter).'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`never | T` 与 `T` 相同（如我们在这章前面所见）。'
- en: '[27.4.2 The return type `never` in `@types/node`](#the-return-type-never-in-types-node)'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.4.2 `@types/node`中的返回类型`never`](#the-return-type-never-in-types-node)'
- en: 'In Node.js, the following functions have the return type `never`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，以下函数的返回类型为`never`：
- en: '`process.exit()`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process.exit()`'
- en: '`process.abort()`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process.abort()`'
- en: '`assert.fail()`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert.fail()`'
- en: '[27.5 Overloading (advanced)](#overloading-advanced)'
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[27.5 重载（高级）](#overloading-advanced)'
- en: Sometimes a single type signature does not adequately describe how a function
    works.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，单个类型签名不足以充分描述函数的工作方式。
- en: '[27.5.1 Overloading function declarations](#overloading-function-declarations)'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.5.1 函数声明重载](#overloading-function-declarations)'
- en: 'Consider function `getFullName()` which we are calling in the following example
    (line A and line B):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下例子中我们调用的函数`getFullName()`（行A和行B）：
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'How would we implement `getFullName()`? The following implementation works
    for the two function calls in the previous example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如何实现`getFullName()`？以下实现适用于前面例子中的两个函数调用：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'However, with this type signature, function calls are legal at compile time
    that produce runtime errors:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用这个类型签名，编译时合法的函数调用在运行时会产生错误：
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following code fixes these issues:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码解决了这些问题：
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'What is going on here? The type signature of `getFullName()` is overloaded:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？`getFullName()` 的类型签名被重载了：
- en: 'The function has two external *overload signatures*: type signatures without
    implementations (line A and line B).'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数有两个外部*重载签名*：没有实现的类型签名（行A和行B）。
- en: 'It also has one *implementation signature*: the type signature of the actual
    implementation, which is internal and must be compatible with both external signatures.
    Incidentally, it is the same as in the previous example.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还有一个*实现签名*：实际实现的类型签名，它是内部的，并且必须与外部签名兼容。顺便提一下，它与前面的例子相同。
- en: 'My advice is to only use overloading when it can’t be avoided. One alternative
    is to split an overloaded function into multiple functions with different names
    – for example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是只有在无法避免的情况下才使用重载。一个替代方案是将重载的函数拆分成多个具有不同名称的函数——例如：
- en: '`getFullName()`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFullName()`'
- en: '`getFullNameViaMap()`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFullNameViaMap()`'
- en: '[27.5.2 Overloading functions via a union of tuple types](#overloading-functions-via-a-union-of-tuple-types)'
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.5.2 通过元组类型的联合重载函数](#overloading-functions-via-a-union-of-tuple-types)'
- en: 'We can also overload a function via a union of tuple types (line A):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过元组类型的联合来重载函数（行A）：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Keep in mind that this kind of overloading only works if the return type is
    the same for all cases.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这种重载只有在所有情况下的返回类型都相同的情况下才有效。
- en: 'Note the labels for the elements of the tuple types:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意元组类型元素的标签：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'These labels are optional and mostly ignored, but may show up in auto-completions
    and type hints. In other words: They work more like comments. The previous two
    types are equivalent to:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标签是可选的，通常会被忽略，但可能会出现在自动完成和类型提示中。换句话说：它们更像注释。前两种类型等同于：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For more information, see [“Labeled tuple elements” (§37.1.3)](ch_computing-with-tuple-types.html#labeled-tuple-elements).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅“标记元组元素”（§37.1.3）。
- en: '[27.5.3 Overloading functions via interfaces](#overloading-functions-via-interfaces)'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.5.3 通过接口重载函数](#overloading-functions-via-interfaces)'
- en: 'In interfaces, we can have multiple, different call signatures. That enables
    us to use the interface `GetFullName` for overloading in the following example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在接口中，我们可以有多个不同的调用签名。这使得我们能够在以下例子中使用接口`GetFullName`进行重载：
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[27.5.4 Overloading on string parameters (event handling etc.)](#overloading-on-string-parameters)'
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.5.4 基于字符串参数的重载（事件处理等）](#overloading-on-string-parameters)'
- en: 'In the next example, we overload and use string literal types (such as `''click''`).
    That allows us to change the type of parameter `listener` depending on the value
    of parameter `type`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，我们重载并使用了字符串字面量类型（如`'click'`）。这允许我们根据`type`参数的值改变`listener`参数的类型：
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this case, it is relatively difficult to get the types of the implementation
    (starting in line A) right, so that the statement in the body (line B) works.
    As a last resort, we used the type `any` for parameter `event` of `listener`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，正确获取实现（从行 A 开始）的类型相对困难，以便使体中的语句（行 B）生效。作为最后的手段，我们在 `listener` 的参数 `event`
    上使用了类型 `any`。
- en: '[27.5.5 Overloading methods](#overloading-methods)'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.5.5 重载方法](#overloading-methods)'
- en: '[27.5.5.1 Overloading concrete methods](#overloading-concrete-methods)'
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[27.5.5.1 重载具体方法](#overloading-concrete-methods)'
- en: 'The next example demonstrates overloading of methods: Method `.add()` is overloaded.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例演示了方法的重载：方法 `.add()` 被重载。
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[27.5.5.2 Overloading interface methods](#overloading-interface-methods)'
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[27.5.5.2 重载接口方法](#overloading-interface-methods)'
- en: 'The type definition for `Array.from()` is an example of an overloaded interface
    method:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.from()` 的类型定义是重载接口方法的例子：'
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the first signature, the returned Array has the same element type as the
    parameter.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个签名中，返回的 Array 的元素类型与参数相同。
- en: In the second signature, the elements of the returned Array have the same type
    as the result of `mapfn`. This version of `Array.from()` is similar to `Array.prototype.map()`.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二个签名中，返回的 Array 的元素类型与 `mapfn` 的结果相同。这个版本的 `Array.from()` 与 `Array.prototype.map()`
    类似。
- en: '[27.6 Assignability (advanced)](#assignability)'
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[27.6 赋值（高级）](#assignability)'
- en: 'In this section we look at the type compatibility rules for *assignability*:
    Can functions of type `Src` be transferred to storage locations (variables, object
    properties, parameters, etc.) of type `Trg`?'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨赋值规则的类型兼容性：类型 `Src` 的函数能否转移到类型 `Trg` 的存储位置（变量、对象属性、参数等）？
- en: 'Understanding assignability helps us answer questions such as:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 理解赋值规则有助于我们回答诸如以下问题：
- en: Given the function type signature of a formal parameter, which functions can
    be passed as actual parameters in function calls?
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个形式参数的函数类型签名，哪些函数可以作为实际参数在函数调用中传递？
- en: Given the function type signature of a property, which functions can be assigned
    to it?
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个属性的函数类型签名，哪些函数可以分配给它？
- en: '[27.6.1 The rules for assignability](#the-rules-for-assignability)'
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.6.1 赋值规则](#the-rules-for-assignability)'
- en: In this subsection, we examine general rules for assignability (including the
    rules for functions). In the next subsection, we explore what those rules mean
    for functions.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们检查赋值规则的一般规则（包括函数的规则）。在下一个小节中，我们将探讨这些规则对函数的意义。
- en: 'A type `Src` is *assignable* to a type `Trg` if one of the following conditions
    is true:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以下条件之一成立，则类型 `Src` 可以赋值给类型 `Trg`：
- en: '`Src` and `Trg` are identical types.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Src` 和 `Trg` 是相同类型。'
- en: '`Src` or `Trg` is the `any` type.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Src` 或 `Trg` 是 `any` 类型。'
- en: '`Src` is a string literal type and `Trg` is the primitive type String.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Src` 是一个字符串字面量类型，而 `Trg` 是原始类型 String。'
- en: '`Src` is a union type and each constituent type of `Src` is assignable to `Trg`.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Src` 是一个联合类型，并且 `Src` 的每个组成部分类型都可以赋值给 `Trg`。'
- en: '`Src` and `Trg` are function types and:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Src` 和 `Trg` 是函数类型，并且：'
- en: '`Trg` has a rest parameter or the number of required parameters of `Src` is
    less than or equal to the total number of parameters of `Trg`.'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trg` 有剩余参数或 `Src` 所需的参数数量小于或等于 `Trg` 的总参数数量。'
- en: For parameters that are present in both signatures, each parameter type in `Trg`
    is assignable to the corresponding parameter type in `Src`.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于在两个签名中都存在的参数，`Trg` 中的每个参数类型都可以赋值给 `Src` 中相应的参数类型。
- en: The return type of `Trg` is `void` or the return type of `Src` is assignable
    to the return type of `Trg`.
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trg` 的返回类型是 `void` 或 `Src` 的返回类型可以赋值给 `Trg` 的返回类型。'
- en: (Remaining conditions omitted.)
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （省略剩余条件。）
- en: '[27.6.2 Consequences of the assignment rules for functions](#consequences-of-the-assignment-rules-for-functions)'
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[27.6.2 函数赋值规则的影响](#consequences-of-the-assignment-rules-for-functions)'
- en: 'In this subsection, we look at what the assignment rules mean for the following
    two functions `targetFunc` and `sourceFunc`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们探讨赋值规则对以下两个函数 `targetFunc` 和 `sourceFunc` 的意义：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[27.6.2.1 Types of parameters and results](#types-of-parameters-and-results)'
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[27.6.2.1 参数和结果类型](#types-of-parameters-and-results)'
- en: Target parameter types must be assignable to corresponding source parameter
    types.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标参数类型必须可以赋值给相应的源参数类型。
- en: Why? Anything that the target accepts must also be accepted by the source.
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么？目标接受的一切也必须被源接受。
- en: The source return type must be assignable to target return type.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源返回类型必须可以赋值给目标返回类型。
- en: Why? Anything that the source returns must be compatible with the expectations
    set by the target.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么？源返回的任何内容都必须与目标设定的期望相兼容。
- en: 'Example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The following example demonstrates that if the target return type is `void`,
    then the source return type doesn’t matter. Why is that? `void` results are always
    ignored in TypeScript.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如果目标返回类型是 `void`，则源返回类型无关紧要。为什么是这样？TypeScript 中总是忽略 `void` 类型的结果。
- en: '[PRE50]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[27.6.2.2 Numbers of parameters](#numbers-of-parameters)'
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[27.6.2.2 参数数量](#numbers-of-parameters)'
- en: 'The source must not have more parameters than the target:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 源不能比目标有更多的参数：
- en: '[PRE51]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The source can have fewer parameters than the target:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 源可以比目标有更少的参数：
- en: '[PRE52]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Why is that? The target specifies the expectations for the source: It must
    accept the parameter `x`. Which it does (but it ignores it). This permissiveness
    enables:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是这样？目标指定了源期望：它必须接受参数 `x`。它确实做到了（但它忽略了它）。这种宽容性使得：
- en: '[PRE53]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The callback for `.map()` only has one of the three parameters that are mentioned
    in the type signature of `.map()`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`.map()` 的回调函数只包含 `.map()` 类型签名中提到的三个参数之一：'
- en: '[PRE54]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[27.7 Further reading and sources of this chapter](#further-reading-and-sources-of-this-chapter)'
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[27.7 进一步阅读和本章来源](#further-reading-and-sources-of-this-chapter)'
- en: '[TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/basic-types.html)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[TypeScript 手册](https://www.typescriptlang.org/docs/handbook/basic-types.html)'
- en: '[Chapter “Callable values”](https://exploringjs.com/js/book/ch_callables.html)
    in “Exploring JavaScript”'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“可调用值”章节](https://exploringjs.com/js/book/ch_callables.html) 在 “Exploring
    JavaScript”'
