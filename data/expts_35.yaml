- en: 28 Type assertions (related to casting)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 28 类型断言（与转换相关）
- en: 原文：[https://exploringjs.com/ts/book/ch_type-assertions.html](https://exploringjs.com/ts/book/ch_type-assertions.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/ts/book/ch_type-assertions.html](https://exploringjs.com/ts/book/ch_type-assertions.html)
- en: (Ad, please don’t block.)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: （广告，请勿拦截。）
- en: '[28.1 Type assertions](#type-assertions)'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[28.1 类型断言](#type-assertions)'
- en: '[28.1.1 Obsolete alternative syntax for type assertions](#obsolete-alternative-syntax-for-type-assertions)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[28.1.1 类型断言的已弃用替代语法](#obsolete-alternative-syntax-for-type-assertions)'
- en: '[28.1.2 Example: asserting an index signature](#example-asserting-an-index-signature)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[28.1.2 示例：断言索引签名](#example-asserting-an-index-signature)'
- en: '[28.1.3 Example: `as any`](#example-as-any)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[28.1.3 示例：`as any`](#example-as-any)'
- en: '[28.2 Constructs related to type assertions](#constructs-related-to-type-assertions)'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[28.2 与类型断言相关的构造](#constructs-related-to-type-assertions)'
- en: '[28.2.1 Non-nullish assertion operator (postfix `!`)](#non-nullish-assertion-operator-postfix)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[28.2.1 非空断言操作符（后缀 `!`)](#non-nullish-assertion-operator-postfix)'
- en: '[28.2.2 Definite assignment assertions](#definite-assignment-assertions)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[28.2.2 确定赋值断言](#definite-assignment-assertions)'
- en: '[28.2.3 Const assertions (`as const`)](#const-assertions-as-const)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[28.2.3 常量断言 (`as const`)](#const-assertions-as-const)'
- en: '[28.2.4 `satisfies` operator](#satisfies-operator)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[28.2.4 `satisfies` 操作符](#satisfies-operator)'
- en: This chapter is about *type assertions* in TypeScript, which are related to
    type casts in other languages and performed via the `as` operator.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍 TypeScript 中的 *类型断言*，这与其他语言中的类型转换相关，并且通过 `as` 操作符执行。
- en: '[28.1 Type assertions](#type-assertions)'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[28.1 类型断言](#type-assertions)'
- en: A type assertion lets us override a static type that TypeScript has computed
    for a value. That is useful for working around limitations of the type system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 类型断言让我们可以覆盖 TypeScript 为一个值计算出的静态类型。这对于解决类型系统的局限性是有用的。
- en: Type assertions are related to type casts in other languages, but they don’t
    throw exceptions and don’t do anything at runtime (they do perform a few minimal
    checks statically).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 类型断言与其他语言的类型转换相关，但它们不会抛出异常，也不会在运行时执行任何操作（它们在静态时执行一些最小的检查）。
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Comments:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注释：
- en: In line A, we widen the type of the Array to `object`.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行 A 中，我们将 Array 的类型扩展为 `object`。
- en: In line B, we see that this type doesn’t let us access any properties ([details](ch_typing-objects.html#general-types-for-objects)).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行 B 中，我们看到这个类型不允许我们访问任何属性（[详情](ch_typing-objects.html#general-types-for-objects)）。
- en: In line C, we use a type assertion (the operator `as`) to tell TypeScript that
    `data` is an Array. Now we can access property `.length`.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行 C 中，我们使用类型断言（操作符 `as`）告诉 TypeScript `data` 是一个 Array。现在我们可以访问属性 `.length`。
- en: Type assertions are a last resort and should be avoided as much as possible.
    They remove the safety net that the static type system normally gives us.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 类型断言是最后的手段，应尽可能避免。它们移除了静态类型系统通常为我们提供的保障。
- en: 'Note that, in line A, we also overrode TypeScript’s type. But we did it via
    a type annotation. This way of overriding is safer than type assertions because
    we are more constrained: TypeScript’s type must be assignable to the type of the
    annotation.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在行 A 中，我们同样覆盖了 TypeScript 的类型。但我们是通过类型注解来实现的。这种覆盖方式比类型断言更安全，因为我们受到更多的约束：TypeScript
    的类型必须可以赋值给注解的类型。
- en: '[28.1.1 Obsolete alternative syntax for type assertions](#obsolete-alternative-syntax-for-type-assertions)'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[28.1.1 类型断言的已弃用替代语法](#obsolete-alternative-syntax-for-type-assertions)'
- en: 'TypeScript has an alternative “angle-bracket” syntax for type assertions:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 有一个用于类型断言的替代“尖括号”语法：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'I recommend avoiding this syntax:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议避免这种语法：
- en: It has grown out of style.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方式已经过时了。
- en: It is not compatible with React JSX code (in `.tsx` files).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与 React JSX 代码（在 `.tsx` 文件中）不兼容。
- en: It is not allowed if [the compiler option `erasableSyntaxOnly`](ch_tsconfig-json.html#erasableSyntaxOnly)
    is active.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果编译器选项 [erasableSyntaxOnly](ch_tsconfig-json.html#erasableSyntaxOnly) 已激活，则不允许使用。
- en: '[28.1.2 Example: asserting an index signature](#example-asserting-an-index-signature)'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[28.1.2 示例：断言索引签名](#example-asserting-an-index-signature)'
- en: In the following code (line A), we use the type assertion `as Dict`, so that
    we can access the properties of a value whose inferred type is `object`. That
    is, we are overriding the static type `object` with the static type `Dict`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码（行 A）中，我们使用类型断言 `as Dict`，这样我们就可以访问推断类型为 `object` 的值的属性。也就是说，我们正在用 `Dict`
    静态类型覆盖 `object` 静态类型。
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[28.1.3 Example: `as any`](#example-as-any)'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[28.1.3 示例：`as any`](#example-as-any)'
- en: 'In the following example, the computed return type in line A does not match
    the value we return in line B:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，行 A 中的计算返回类型与行 B 中我们返回的值不匹配：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To make the error go away, we use `as any` in line A:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除错误，我们在行 A 使用 `as any`：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is an extreme measure. Alas it’s unavoidable in this case. For more information,
    see [“Computed return types of functions often don’t match returned values” (§33.14)](ch_computing-with-types-overview.html#computed-return-types-dont-match).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个极端的措施。遗憾的是在这种情况下是不可避免的。更多信息，请参阅[“函数的返回类型通常与返回值不匹配”（§33.14）](ch_computing-with-types-overview.html#computed-return-types-dont-match)。
- en: '[28.2 Constructs related to type assertions](#constructs-related-to-type-assertions)'
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[28.2 与类型断言相关的构造](#constructs-related-to-type-assertions)'
- en: '[28.2.1 Non-nullish assertion operator (postfix `!`)](#non-nullish-assertion-operator-postfix)'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[28.2.1 非空断言操作符（后缀 `!`）](#non-nullish-assertion-operator-postfix)'
- en: 'If a value’s type is a union that includes the types `undefined` or `null`,
    the *non-nullish assertion operator* (or *non-null assertion operator*) removes
    these types from the union. We are telling TypeScript: “This value can’t be `undefined`
    or `null`.” As a consequence, we can perform operations that are prevented by
    the types of these two values – for example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个值的类型是包含类型 `undefined` 或 `null` 的联合类型，则 *非空断言操作符*（或 *非空断言操作符*）会从联合中移除这些类型。我们告诉
    TypeScript：“这个值不能是 `undefined` 或 `null`。”因此，我们可以执行被这两个值的类型所阻止的操作——例如：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[28.2.1.1 Example – Maps: `.get()` after `.has()`](#example-maps-get-after-has)'
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[28.2.1.1 示例 - Maps：`.has()` 后的 `.get()`](#example-maps-get-after-has)'
- en: 'After we use the Map method `.has()`, we know that a Map has a given key. Alas,
    the result of `.get()` does not reflect that knowledge, which is why we have to
    use the nullish assertion operator:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用 Map 方法 `.has()` 之后，我们知道 Map 有一个特定的键。遗憾的是，`.get()` 的结果并没有反映这一知识，这就是为什么我们必须使用非空断言操作符的原因：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can avoid the nullish assertion operator whenever the values of a Map can’t
    be `undefined`. Then missing entries can be detected by checking if the result
    of `.get()` is `undefined`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Map 的值不能为 `undefined` 时，我们可以避免使用非空断言操作符。然后可以通过检查 `.get()` 的结果是否为 `undefined`
    来检测缺失条目：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[28.2.2 Definite assignment assertions](#definite-assignment-assertions)'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[28.2.2 确定赋值断言](#definite-assignment-assertions)'
- en: If [*strict property initialization*](ch_class-definitions.html#strictPropertyInitialization)
    is switched on, we occasionally need to tell TypeScript that we do initialize
    certain properties – even though it thinks we don’t.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了[*严格属性初始化*](ch_class-definitions.html#strictPropertyInitialization)，我们有时需要告诉
    TypeScript 我们确实初始化了某些属性——即使它认为我们没有。
- en: 'This is an example where TypeScript complains even though it shouldn’t:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 TypeScript 虽然不应该但仍然抱怨的例子：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The errors go away if we use *definite assignment assertions* (exclamation
    marks) in line A and line B:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在行 A 和行 B 使用 *确定赋值断言*（感叹号），错误就会消失：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[28.2.3 Const assertions (`as const`)](#const-assertions-as-const)'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[28.2.3 常量断言（`as const`）](#const-assertions-as-const)'
- en: 'Const assertions make values read-only and lead to more specific inferred types
    – e.g.:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 常量断言使值只读，并导致更具体的推断类型——例如：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'More information: [“Const assertions (`as const`)” (§25.7)](ch_readonly.html#const-assertions).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息：[“常量断言（`as const`）”（§25.7）](ch_readonly.html#const-assertions)。
- en: '[28.2.4 `satisfies` operator](#satisfies-operator)'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[28.2.4 `satisfies` 操作符](#satisfies-operator)'
- en: 'The `satisfies` operator enforces that a value has a given type but (mostly)
    otherwise does not affect the type of that value – e.g.:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`satisfies` 操作符强制一个值具有给定的类型，但（主要）不会影响该值的类型——例如：'
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `satisfies` operator in line B catches the error in line A but does not
    prevent `TextStyle` from having an object literal type. Therefore, we can extract
    the property keys in line C.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 行 B 中的 `satisfies` 操作符捕获了行 A 中的错误，但不会阻止 `TextStyle` 具有对象字面量类型。因此，我们可以在行 C 中提取属性键。
- en: 'More information: [“The `satisfies` operator” (§29)](ch_satisfies.html#ch_satisfies).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息：[“`satisfies` 操作符”（§29）](ch_satisfies.html#ch_satisfies)。
