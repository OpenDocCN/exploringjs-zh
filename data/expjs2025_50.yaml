- en: 42 Foundations of asynchronous programming in JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 42 JavaScript 异步编程基础
- en: 原文：[https://exploringjs.com/js/book/ch_async-js.html](https://exploringjs.com/js/book/ch_async-js.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/js/book/ch_async-js.html](https://exploringjs.com/js/book/ch_async-js.html)
- en: '[42.1 The event loop](#event-loop)'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[42.1 事件循环](#event-loop)'
- en: '[42.2 How to avoid blocking the JavaScript process](#how-to-avoid-blocking-the-javascript-process)'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[42.2 如何避免阻塞 JavaScript 进程](#how-to-avoid-blocking-the-javascript-process)'
- en: '[42.2.1 The user interface of the browser can be blocked](#blocking-browsers)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[42.2.1 浏览器用户界面可能会被阻塞](#blocking-browsers)'
- en: '[42.2.2 How can we avoid blocking the browser?](#avoiding-blocking-browser)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[42.2.2 如何避免阻塞浏览器？](#avoiding-blocking-browser)'
- en: '[42.2.3 Scheduling new tasks via `setTimeout()`](#setTimeout)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[42.2.3 通过 `setTimeout()` 调度新任务](#setTimeout)'
- en: '[42.2.4 Run-to-completion semantics](#run-to-completion-semantics)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[42.2.4 完成到运行语义](#run-to-completion-semantics)'
- en: '[42.3 Patterns for delivering results asynchronously](#patterns-for-async-results)'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[42.3 异步结果传递模式](#patterns-for-async-results)'
- en: '[42.3.1 Delivering asynchronous results via events](#event-pattern)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[42.3.1 通过事件传递异步结果](#event-pattern)'
- en: '[42.3.2 Delivering asynchronous results via callbacks](#callback-pattern)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[42.3.2 通过回调传递异步结果](#callback-pattern)'
- en: '[42.4 Asynchronous code: the downsides](#async-code-downsides)'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[42.4 异步代码的缺点](#async-code-downsides)'
- en: '[42.5 Resources](#resources)'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[42.5 资源](#resources)'
- en: This chapter explains the foundations of asynchronous programming in JavaScript.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了 JavaScript 异步编程的基础。
- en: '[42.1 The event loop](#event-loop)'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[42.1 事件循环](#event-loop)'
- en: 'Normally JavaScript runs in a single process – in both web browsers and Node.js.
    Inside that single process, *tasks* are run, one at a time. A *task* is a piece
    of code – think function with zero parameters. Tasks are managed via a queue:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常 JavaScript 在单个进程中运行 – 在网页浏览器和 Node.js 中都是如此。在这个单个进程中，*任务* 依次运行。一个 *任务* 是一段代码
    – 想象一下没有参数的函数。任务通过队列进行管理：
- en: The *event loop* runs continuously inside the JavaScript process. During each
    loop iteration, it takes one task out of the queue (if the queue is empty, it
    waits until it isn’t) and executes it. After the task is finished, control goes
    back to the event loop, which then retrieves the next task from the queue and
    executes it. And so on.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*事件循环* 在 JavaScript 进程内部持续运行。在每次循环迭代中，它从队列中取出一个任务（如果队列为空，则等待直到不为空）并执行它。任务完成后，控制权返回到事件循环，然后从队列中检索下一个任务并执行它。如此循环。'
- en: '*Task sources* add tasks to the queue. Some of those sources run concurrently
    to the JavaScript process. For example, one task source takes care of user interface
    events: if a user clicks somewhere and a click listener was registered, then an
    invocation of that listener is added to the task queue.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*任务来源* 将任务添加到队列中。其中一些来源与 JavaScript 进程并发运行。例如，一个任务来源负责用户界面事件：如果用户点击某处并且注册了点击监听器，那么对该监听器的调用就会被添加到任务队列中。'
- en: 'The following JavaScript code is an approximation of the event loop:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 JavaScript 代码是事件循环的近似表示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The event loop is depicted in [figure 42.1](#fig:event_loop).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环在 [图 42.1](#fig:event_loop) 中表示。
- en: '![](../Images/74ee57a8c7fc965c57f47cc602fdd8cf.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/74ee57a8c7fc965c57f47cc602fdd8cf.png)'
- en: 'Figure 42.1: *Task sources* add code to run to the *task queue*, which is emptied
    by the *event loop*.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 42.1：*任务来源* 将要运行的代码添加到 *任务队列* 中，该队列由 *事件循环* 清空。
- en: '[42.2 How to avoid blocking the JavaScript process](#how-to-avoid-blocking-the-javascript-process)'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[42.2 如何避免阻塞 JavaScript 进程](#how-to-avoid-blocking-the-javascript-process)'
- en: '[42.2.1 The user interface of the browser can be blocked](#blocking-browsers)'
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[42.2.1 浏览器用户界面可能会被阻塞](#blocking-browsers)'
- en: 'Many of the user interface mechanisms of browsers also run in the JavaScript
    process (as tasks). Therefore, long-running JavaScript code can block the user
    interface. Let’s look at a web page that demonstrates that. There are two ways
    in which we can try out that page:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器的许多用户界面机制也在 JavaScript 进程中运行（作为任务）。因此，长时间运行的 JavaScript 代码可能会阻塞用户界面。让我们看看一个演示这一点的网页。我们可以通过两种方式尝试这个页面：
- en: We can [run it online](http://rauschma.github.io/async-examples/blocking.html).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在 [在线运行它](http://rauschma.github.io/async-examples/blocking.html)。
- en: 'We can open the following file inside the repository with the exercises: `demos/async-js/blocking.html`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在存储库中打开以下文件进行练习：`demos/async-js/blocking.html`
- en: 'The following HTML is the page’s user interface:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 HTML 是页面的用户界面：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The idea is that we click “Block” and a long-running loop is executed via JavaScript.
    During that loop, we can’t click the button because the browser/JavaScript process
    is blocked.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是点击“Block”，通过 JavaScript 执行一个长时间运行的循环。在循环期间，我们无法点击按钮，因为浏览器/JavaScript 进程被阻塞。
- en: 'A simplified version of the JavaScript code looks like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 简化的 JavaScript 代码看起来像这样：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'These are the key parts of the code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是代码的关键部分：
- en: 'Line A: We tell the browser to call `doBlock()` whenever the HTML element is
    clicked whose ID is `block`.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 A：我们告诉浏览器在点击 ID 为 `block` 的 HTML 元素时调用 `doBlock()`。
- en: '`doBlock()` displays status information and then calls `sleep()` to block the
    JavaScript process for 5000 milliseconds (line B).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doBlock()` 显示状态信息，然后调用 `sleep()` 以阻塞 JavaScript 进程 5000 毫秒（行 B）。'
- en: '`sleep()` blocks the JavaScript process by looping until enough time has passed.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sleep()` 通过循环直到经过足够的时间来阻塞 JavaScript 进程。'
- en: '`displayStatus()` displays status messages inside the `<div>` whose ID is `statusMessage`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`displayStatus()` 在 ID 为 `statusMessage` 的 `<div>` 内显示状态消息。'
- en: '[42.2.2 How can we avoid blocking the browser?](#avoiding-blocking-browser)'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[42.2.2 如何避免阻塞浏览器？](#avoiding-blocking-browser)'
- en: How can we prevent a long-running operation from blocking the browser?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何防止长时间运行的操作阻塞浏览器？
- en: 'The operation can deliver its result *asynchronously*: Some operations, such
    as downloading files, run outside the JavaScript process and concurrently with
    it. If we invoke such an operation, we provide it with a callback. Once the operation
    is done, it calls the callback with the result (by adding a task to the queue).
    This style of delivering a result is called *asynchronous* because the invoker
    isn’t blocked while it waits for the result: It can do other things and is notified
    when the result is ready. Normal function invocations deliver their results synchronously.
    Our own code can also deliver results asynchronously. We’ll learn more about asynchronous
    code soon.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作可以异步地提供其结果：一些操作，如下载文件，在 JavaScript 进程外部运行，并与它并发。如果我们调用这样的操作，我们向它提供一个回调。一旦操作完成，它将通过向队列中添加任务的方式调用回调并返回结果。这种提供结果的方式被称为异步，因为调用者等待结果时不会被阻塞：它可以做其他事情，并在结果准备好时得到通知。正常函数调用同步地提供其结果。我们的代码也可以异步地提供结果。我们很快就会了解更多关于异步代码的内容。
- en: 'The operation can be performed in a separate process: This can be done via
    so-called *Web Workers*. A Web Worker is a heavyweight process that runs concurrently
    to the main process. It has its own runtime environment (global variables, etc.).
    It is completely isolated; communication happens via message passing. See [MDN
    web docs](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API) for
    more information.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作可以在单独的进程中执行：这可以通过所谓的 *Web Workers* 实现。Web Worker 是一个重量级进程，它与主进程并发运行。它有自己的运行时环境（全局变量等）。它是完全隔离的；通信通过消息传递进行。有关更多信息，请参阅
    [MDN 网络文档](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)。
- en: The operation can take breaks and give pending tasks in the queue a chance to
    run – which unblocks the browser. The next subsection explains how that is done.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作可以暂停并给队列中的挂起任务运行的机会——这可以解除浏览器的阻塞。下一小节将解释这是如何实现的。
- en: '[42.2.3 Scheduling new tasks via `setTimeout()`](#setTimeout)'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[42.2.3 通过 `setTimeout()` 调度新任务](#setTimeout)'
- en: 'The following global function executes its parameter `callback` after a delay
    of `ms` milliseconds (the type signature is simplified – `setTimeout()` has more
    features):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下全局函数在延迟 `ms` 毫秒后执行其参数 `callback`（类型签名已简化 - `setTimeout()` 有更多功能）：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The function returns a *handle* (an ID) that can be used to *clear* the timeout
    (cancel the execution of the callback before it happens) via the following global
    function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回一个 *句柄*（一个 ID），可以用来 *清除* 超时（在回调执行之前取消执行）的以下全局函数：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`setTimeout()` is available on both browsers and Node.js. We can view `setTimeout()`
    as scheduling a task for later execution:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout()` 在浏览器和 Node.js 中都可用。我们可以将 `setTimeout()` 视为为稍后执行的任务进行调度：'
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Within the first task, we are scheduling a new task (the callback starting in
    line A) to be run after a delay of zero milliseconds (line B).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个任务中，我们正在调度一个新的任务（从行 A 开始的回调）在零毫秒的延迟后运行（行 B）。
- en: 'Output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There is another way of looking at what happened: **The first task took a break
    and later continued with the second task.**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待发生情况的方式是：**第一个任务暂停了一下，然后继续执行第二个任务**。
- en: The first task runs. While it does, events such as click events may fire and
    cause tasks to be added to the queue. Those tasks can only run after the current
    task is finished.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个任务运行。在它运行的同时，可能会触发事件，如点击事件，并导致任务被添加到队列中。这些任务只能在当前任务完成后才能运行。
- en: The first task ends. Now other tasks can run. We used a delay of zero milliseconds,
    so all tasks that were added to the queue before the second task, will run next.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个任务结束。现在其他任务可以运行。我们使用了零毫秒的延迟，所以所有在第二个任务之前添加到队列中的任务都将接下来运行。
- en: The second task runs, continuing the work of the first task.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个任务运行，继续第一个任务的工作。
- en: 'In other words: The task took a break and gave other tasks a chance to run.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：任务休息了一下，给了其他任务运行的机会。
- en: '[42.2.4 Run-to-completion semantics](#run-to-completion-semantics)'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[42.2.4 运行到完成语义](#run-to-completion-semantics)'
- en: 'JavaScript makes a guarantee for tasks:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript为任务提供保证：
- en: Each task is always finished (“run to completion”) before the next task is executed.
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每个任务总是在执行下一个任务之前完成（“运行到完成”）。
- en: As a consequence, tasks don’t have to worry about their data being changed while
    they are working on it (*concurrent modification*). That simplifies programming
    in JavaScript.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，任务在处理数据时不必担心数据被更改（*并发修改*）。这简化了JavaScript中的编程。
- en: 'We can observe run to completion in the previous example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的例子中观察到运行到完成：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first task ends before the next task starts.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务在下一个任务开始之前就结束了。
- en: '[42.3 Patterns for delivering results asynchronously](#patterns-for-async-results)'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[42.3 异步传递结果的模式](#patterns-for-async-results)'
- en: 'In order to avoid blocking the main process while waiting for a long-running
    operation to finish, results are often delivered asynchronously in JavaScript.
    These are three popular patterns for doing so:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在等待长时间运行的操作完成时阻塞主进程，结果通常在JavaScript中以异步方式传递。以下是三种流行的实现方式：
- en: Events
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Events
- en: Callbacks
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Callbacks
- en: Promises
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Promises
- en: The first two patterns are explained in the next two subsections. Promises are
    explained in [the next chapter](ch_promises.html#ch_promises).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个模式将在接下来的两个小节中解释。Promises将在[下一章](ch_promises.html#ch_promises)中解释。
- en: '[42.3.1 Delivering asynchronous results via events](#event-pattern)'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[42.3.1 通过事件传递异步结果](#event-pattern)'
- en: 'Events as a pattern work as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 事件作为模式的工作方式如下：
- en: They are used to deliver values asynchronously.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们用于异步传递值。
- en: They do so zero or more times.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们零次或多次这样做。
- en: 'There are three roles in this pattern:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个模式中有三个角色：
- en: The *event* (an object) carries the data to be delivered.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件（一个对象）携带要传递的数据。
- en: The *event listener* is a function that receives events via a parameter.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*事件监听器*是一个通过参数接收事件的函数。'
- en: The *event source* sends events and lets us register event listeners.
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*事件源*发送事件并允许我们注册事件监听器。'
- en: Multiple variations of this pattern exist in the world of JavaScript. We’ll
    look at three examples next.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript的世界中，存在多种这种模式的变体。我们将在下面看三个例子。
- en: '[42.3.1.1 Events: IndexedDB](#events-indexeddb)'
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[42.3.1.1 事件：IndexedDB](#events-indexeddb)'
- en: 'IndexedDB is a database that is built into web browsers. This is an example
    of using it:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: IndexedDB是内置在网页浏览器中的数据库。这是一个使用它的例子：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`indexedDB` has an unusual way of invoking operations:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexedDB`调用操作的方式不寻常：'
- en: Each operation has an associated method for creating *request objects*. For
    example, in line A, the operation is “open”, the method is `.open()`, and the
    request object is `openRequest`.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个操作都有一个关联的方法来创建*请求对象*。例如，在行A中，操作是“open”，方法是`.open()`，请求对象是`openRequest`。
- en: The parameters for the operation are provided via the request object, not via
    parameters of the method. For example, the event listeners (functions) are stored
    in the properties `.onsuccess` and `.onerror`.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作的参数通过请求对象提供，而不是通过方法参数提供。例如，事件监听器（函数）存储在属性`.onsuccess`和`.onerror`中。
- en: The invocation of the operation is added to the task queue via the method (in
    line A). That is, we configure the operation *after* its invocation has already
    been added to the queue. Only run-to-completion semantics saves us from race conditions
    here and ensures that the operation runs after the current code fragment is finished.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过方法（在行A中）将操作的调用添加到任务队列中。也就是说，我们在调用已经添加到队列之后配置操作。只有运行到完成语义才能让我们避免竞态条件，并确保操作在当前代码片段完成后运行。
- en: '[42.3.1.2 Events: `XMLHttpRequest`](#XMLHttpRequest)'
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[42.3.1.2 事件：`XMLHttpRequest`](#XMLHttpRequest)'
- en: 'The `XMLHttpRequest` API lets us make downloads from within a web browser.
    This is how we download the file `http://example.com/textfile.txt`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLHttpRequest` API 允许我们在网页浏览器内进行下载。这是下载文件 `http://example.com/textfile.txt`
    的方法：'
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With this API, we first create a request object (line A), then configure it,
    then activate it (line E). The configuration consists of:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此 API，我们首先创建一个请求对象（行 A），然后配置它，然后激活它（行 E）。配置包括：
- en: 'Specifying which HTTP request method to use (line B): `GET`, `POST`, `PUT`,
    etc.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定要使用的 HTTP 请求方法（行 B）："GET"、"POST"、"PUT" 等。
- en: Registering a listener (line C) that is notified if something could be downloaded.
    Inside the listener, we still need to determine if the download contains what
    we requested or informs us of an error. Note that some of the result data is delivered
    via the request object `xhr`. (I’m not a fan of this kind of mixing of input and
    output data.)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册一个监听器（行 C），当可以下载某些内容时被通知。在监听器内部，我们仍然需要确定下载的内容是否包含我们请求的内容或是否通知我们错误。请注意，一些结果数据是通过请求对象
    `xhr` 传递的。（我不是这种输入和输出数据混合的粉丝。）
- en: Registering a listener (line D) that is notified if there was a network error.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册一个监听器（行 D），当发生网络错误时被通知。
- en: '[42.3.1.3 Events: DOM](#events-dom)'
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[42.3.1.3 事件：DOM](#events-dom)'
- en: 'We have already seen DOM events in action in [“The user interface of the browser
    can be blocked” (§42.2.1)](#blocking-browsers). The following code also handles
    `click` events:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [“浏览器用户界面的阻塞”（§42.2.1）](#blocking-browsers) 中看到了 DOM 事件的实际应用。以下代码也处理 `click`
    事件：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We first ask the browser to retrieve the HTML element whose ID is `'my-link'`
    (line A). Then we add a listener for all `click` events (line B). In the listener,
    we first tell the browser not to perform its default action (line C) – going to
    the target of the link. Then we log to the console if the shift key is currently
    pressed (line D).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要求浏览器检索 ID 为 `'my-link'` 的 HTML 元素（行 A）。然后我们添加对所有 `click` 事件的监听器（行 B）。在监听器中，我们首先告诉浏览器不要执行其默认操作（行
    C）——即前往链接的目标。然后我们记录当前是否按下了 shift 键（行 D）。
- en: '[42.3.2 Delivering asynchronous results via callbacks](#callback-pattern)'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[42.3.2 通过回调传递异步结果](#callback-pattern)'
- en: Callbacks are another pattern for handling asynchronous results. They are only
    used for one-off results and have the advantage of being less verbose than events.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 回调是处理异步结果的一种模式。它们仅用于一次性结果，并且比事件更简洁。
- en: 'As an example, consider a function `readFile()` that reads a text file and
    returns its contents asynchronously. This is how we call `readFile()` if it uses
    Node.js-style callbacks:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个名为 `readFile()` 的函数，它异步读取一个文本文件并返回其内容。如果它使用 Node.js 风格的回调，我们这样调用 `readFile()`：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There is a single callback that handles both success and failure. If the first
    parameter is not `null` then an error happened. Otherwise, the result can be found
    in the second parameter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个回调同时处理成功和失败。如果第一个参数不是 `null`，则发生了错误。否则，结果可以在第二个参数中找到。
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercises:
    Callback-based code**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![练习图标 “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：基于回调的代码**'
- en: The following exercises use tests for asynchronous code, which are different
    from tests for synchronous code. See [“Asynchronous tests in Mocha” (§12.2.2)](ch_exercises.html#async-tests-mocha)
    for more information.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习使用异步代码的测试，这些测试与同步代码的测试不同。有关更多信息，请参阅 [“Mocha 中的异步测试”（§12.2.2）](ch_exercises.html#async-tests-mocha)。
- en: 'From synchronous to callback-based code: `exercises/async-js/read_file_cb_exrc.mjs`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从同步到基于回调的代码：`exercises/async-js/read_file_cb_exrc.mjs`
- en: 'Implementing a callback-based version of `.map()`: `exercises/async-js/map_cb_test.mjs`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `.map()` 的基于回调版本：`exercises/async-js/map_cb_test.mjs`
- en: '[42.4 Asynchronous code: the downsides](#async-code-downsides)'
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[42.4 异步代码：缺点](#async-code-downsides)'
- en: 'In many situations, on either browsers or Node.js, we have no choice: We must
    use asynchronous code. In this chapter, we have seen several patterns that such
    code can use. All of them have two disadvantages:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，无论是在浏览器还是 Node.js 中，我们别无选择：我们必须使用异步代码。在本章中，我们看到了这种代码可以使用的一些模式。所有这些模式都有两个缺点：
- en: Asynchronous code is more verbose than synchronous code.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步代码比同步代码更冗长。
- en: If we call asynchronous code, our code must become asynchronous too. That’s
    because we can’t wait synchronously for an asynchronous result. Asynchronous code
    has an infectious quality.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们调用异步代码，我们的代码也必须变为异步。这是因为我们不能同步地等待异步结果。异步代码具有传染性。
- en: The first disadvantage becomes less severe with Promises (covered in [the next
    chapter](ch_promises.html#ch_promises)) and mostly disappears with async functions
    (covered in [the chapter after next](ch_async-functions.html#ch_async-functions)).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个缺点在 Promise（下一章介绍）中变得不那么严重，而在异步函数（下一章介绍）中几乎消失。
- en: Alas, the infectiousness of async code does not go away. But it is mitigated
    by the fact that switching between sync and async is easy with async functions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，异步代码的传染性并没有消失。但通过异步函数，在同步和异步之间切换变得容易，这减轻了这种传染性。
- en: '[42.5 Resources](#resources)'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[42.5 资源](#resources)'
- en: '[“Help, I''m stuck in an event-loop”](https://vimeo.com/96425312) by Philip
    Roberts (video).'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“帮助，我卡在事件循环中”](https://vimeo.com/96425312) by Philip Roberts（视频）。'
- en: '[“Event loops”](https://www.w3.org/TR/html5/webappapis.html#event-loops), section
    in HTML5 spec.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“事件循环”](https://www.w3.org/TR/html5/webappapis.html#event-loops)，HTML5 规范中的章节。'
