- en: 7 Syntax
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 语法
- en: 原文：[https://exploringjs.com/impatient-js/ch_syntax.html](https://exploringjs.com/impatient-js/ch_syntax.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/impatient-js/ch_syntax.html](https://exploringjs.com/impatient-js/ch_syntax.html)
- en: '* * *'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 7.1 [An overview of JavaScript’s syntax](ch_syntax.html#an-overview-of-javascripts-syntax)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.1 [JavaScript语法概述](ch_syntax.html#an-overview-of-javascripts-syntax)
- en: 7.1.1 [Basic constructs](ch_syntax.html#basic-constructs)
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.1.1 [基本结构](ch_syntax.html#basic-constructs)
- en: 7.1.2 [Modules](ch_syntax.html#modules)
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.1.2 [模块](ch_syntax.html#modules)
- en: 7.1.3 [Classes](ch_classes.html#classes)
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.1.3 [类](ch_classes.html#classes)
- en: 7.1.4 [Exception handling](ch_syntax.html#exception-handling)
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.1.4 [异常处理](ch_syntax.html#exception-handling)
- en: 7.1.5 [Legal variable and property names](ch_syntax.html#legal-variable-and-property-names)
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.1.5 [合法的变量和属性名称](ch_syntax.html#legal-variable-and-property-names)
- en: 7.1.6 [Casing styles](ch_syntax.html#casing-styles)
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.1.6 [大小写风格](ch_syntax.html#casing-styles)
- en: 7.1.7 [Capitalization of names](ch_syntax.html#capitalization-of-names)
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.1.7 [名称的大写形式](ch_syntax.html#capitalization-of-names)
- en: 7.1.8 [More naming conventions](ch_syntax.html#more-naming-conventions)
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.1.8 [更多命名约定](ch_syntax.html#more-naming-conventions)
- en: 7.1.9 [Where to put semicolons?](ch_syntax.html#where-to-put-semicolons)
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.1.9 [分号放在哪里？](ch_syntax.html#where-to-put-semicolons)
- en: 7.2 [(Advanced)](ch_syntax.html#advanced)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.2 （高级）
- en: 7.3 [Identifiers](ch_syntax.html#identifiers)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.3 [标识符](ch_syntax.html#identifiers)
- en: 7.3.1 [Valid identifiers (variable names, etc.)](ch_syntax.html#valid-identifiers-variable-names-etc.)
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.3.1 [有效的标识符（变量名等）](ch_syntax.html#valid-identifiers-variable-names-etc.)
- en: 7.3.2 [Reserved words](ch_syntax.html#reserved-words)
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.3.2 [保留字](ch_syntax.html#reserved-words)
- en: 7.4 [Statement vs. expression](ch_syntax.html#statement-vs-expression)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.4 [语句 vs 表达式](ch_syntax.html#statement-vs-expression)
- en: 7.4.1 [Statements](ch_syntax.html#statements)
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.4.1 [语句](ch_syntax.html#statements)
- en: 7.4.2 [Expressions](ch_syntax.html#expressions)
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.4.2 [表达式](ch_syntax.html#expressions)
- en: 7.4.3 [What is allowed where?](ch_syntax.html#what-is-allowed-where)
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.4.3 [允许的位置](ch_syntax.html#what-is-allowed-where)
- en: 7.5 [Ambiguous syntax](ch_syntax.html#ambiguous-syntax)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.5 [模糊的语法](ch_syntax.html#ambiguous-syntax)
- en: '7.5.1 [Same syntax: function declaration and function expression](ch_syntax.html#same-syntax-function-declaration-and-function-expression)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.5.1 [相同的语法：函数声明和函数表达式](ch_syntax.html#same-syntax-function-declaration-and-function-expression)
- en: '7.5.2 [Same syntax: object literal and block](ch_syntax.html#same-syntax-object-literal-and-block)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.5.2 [相同的语法：对象字面量和块](ch_syntax.html#same-syntax-object-literal-and-block)
- en: 7.5.3 [Disambiguation](ch_syntax.html#disambiguation)
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.5.3 [消歧](ch_syntax.html#disambiguation)
- en: 7.6 [Semicolons](ch_syntax.html#semicolons)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.6 分号
- en: 7.6.1 [Rule of thumb for semicolons](ch_syntax.html#rule-of-thumb-for-semicolons)
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.6.1 [分号的经验法则](ch_syntax.html#rule-of-thumb-for-semicolons)
- en: '7.6.2 [Semicolons: control statements](ch_syntax.html#semicolons-control-statements)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.6.2 [分号：控制语句](ch_syntax.html#semicolons-control-statements)
- en: 7.7 [Automatic semicolon insertion (ASI)](ch_syntax.html#automatic-semicolon-insertion-asi)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.7 [自动分号插入（ASI）](ch_syntax.html#automatic-semicolon-insertion-asi)
- en: 7.7.1 [ASI triggered unexpectedly](ch_syntax.html#asi-triggered-unexpectedly)
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.7.1 意外触发的ASI
- en: 7.7.2 [ASI unexpectedly not triggered](ch_syntax.html#asi-unexpectedly-not-triggered)
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.7.2 意外未触发的ASI
- en: '7.8 [Semicolons: best practices](ch_syntax.html#semicolons-best-practices)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.8 [分号：最佳实践](ch_syntax.html#semicolons-best-practices)
- en: 7.9 [Strict mode vs. sloppy mode](ch_syntax.html#strict-mode)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.9 [严格模式 vs 松散模式](ch_syntax.html#strict-mode)
- en: 7.9.1 [Switching on strict mode](ch_syntax.html#switching-on-strict-mode)
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.9.1 [切换到严格模式](ch_syntax.html#switching-on-strict-mode)
- en: 7.9.2 [Improvements in strict mode](ch_syntax.html#improvements-in-strict-mode)
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.9.2 [严格模式的改进](ch_syntax.html#improvements-in-strict-mode)
- en: '* * *'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 7.1 An overview of JavaScript’s syntax
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1 JavaScript语法概述
- en: This is a very first look at JavaScript’s syntax. Don’t worry if some things
    don’t make sense, yet. They will all be explained in more detail later in this
    book.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对JavaScript语法的第一次简要介绍。如果有些东西还不明白，不要担心。它们将在本书的后面更详细地解释。
- en: This overview is not exhaustive, either. It focuses on the essentials.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概述也不是详尽无遗的。它侧重于基本要点。
- en: 7.1.1 Basic constructs
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.1 基本结构
- en: 7.1.1.1 Comments
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.1.1.1 注释
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 7.1.1.2 *Primitive* (atomic) values
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.1.1.2 *原始*（原子）值
- en: '**Booleans:**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**布尔值：**'
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Numbers:**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**数字：**'
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The basic number type is used for both floating point numbers (doubles) and
    integers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 基本数字类型用于浮点数（双精度）和整数。
- en: '**Bigints:**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**大整数：**'
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The basic number type can only properly represent integers within a range of
    53 bits plus sign. Bigints can grow arbitrarily large in size.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 基本数字类型只能在53位加符号的范围内正确表示整数。大整数可以任意增长。
- en: '**Strings:**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符串：**'
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: JavaScript has no extra type for characters. It uses strings to represent them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript没有额外的字符类型。它使用字符串来表示它们。
- en: 7.1.1.3 Assertions
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.1.1.3 断言
- en: 'An *assertion* describes what the result of a computation is expected to look
    like and throws an exception if those expectations aren’t correct. For example,
    the following assertion states that the result of the computation 7 plus 1 must
    be 8:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*断言*描述了计算结果预期的样子，并在这些期望不正确时抛出异常。例如，以下断言说明了计算结果7加1必须是8：'
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`assert.equal()` is a method call (the object is `assert`, the method is `.equal()`)
    with two arguments: the actual result and the expected result. It is part of a
    Node.js assertion API that is explained [later in this book](ch_assertion-api.html).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert.equal()`是一个方法调用（对象是`assert`，方法是`.equal()`），有两个参数：实际结果和期望结果。它是Node.js断言API的一部分，将在本书的[后面解释](ch_assertion-api.html)。'
- en: There is also `assert.deepEqual()` that compares objects deeply.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`assert.deepEqual()`用于深度比较对象。
- en: 7.1.1.4 Logging to the console
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.1.1.4 记录到控制台
- en: 'Logging to [the console](ch_console.html#browser-consoles) of a browser or
    Node.js:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 记录到[控制台](ch_console.html#browser-consoles)的浏览器或Node.js：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 7.1.1.5 Operators
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.1.1.5 运算符
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'JavaScript also has a `==` comparison operator. I recommend to avoid it – why
    is explained in [§13.4.3 “Recommendation: always use strict equality”](ch_operators.html#recommendation-always-strict-equality).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript还有一个`==`比较运算符。我建议避免使用它-原因在[§13.4.3“建议：始终使用严格相等”](ch_operators.html#recommendation-always-strict-equality)中有解释。
- en: 7.1.1.6 Declaring variables
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.1.1.6 声明变量
- en: '`const` creates *immutable variable bindings*: Each variable must be initialized
    immediately and we can’t assign a different value later. However, the value itself
    may be mutable and we may be able to change its contents. In other words: `const`
    does not make values immutable.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`创建*不可变变量绑定*：每个变量必须立即初始化，我们不能以后分配不同的值。但是，值本身可能是可变的，我们可能能够更改其内容。换句话说：`const`不会使值不可变。'
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`let` creates *mutable variable bindings*:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`创建*可变变量绑定*：'
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 7.1.1.7 Ordinary function declarations
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.1.1.7 普通函数声明
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 7.1.1.8 Arrow function expressions
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.1.1.8 箭头函数表达式
- en: 'Arrow function expressions are used especially as arguments of function calls
    and method calls:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数表达式通常用作函数调用和方法调用的参数：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The previous code contains the following two arrow functions (the terms *expression*
    and *statement* are explained [later in this chapter](ch_syntax.html#statement-vs-expression)):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码包含以下两个箭头函数（*表达式*和*语句*的术语在本章的[后面](ch_syntax.html#statement-vs-expression)有解释）：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 7.1.1.9 Plain objects
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.1.1.9 普通对象
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 7.1.1.10 Arrays
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.1.1.10 数组
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 7.1.1.11 Control flow statements
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.1.1.11 控制流语句
- en: 'Conditional statement:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`for-of` loop:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-of`循环：'
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 7.1.2 Modules
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.2 模块
- en: 'Each module is a single file. Consider, for example, the following two files
    with modules in them:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都是单个文件。例如，考虑以下两个包含模块的文件：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The module in `file-tools.mjs` exports its function `isTextFilePath()`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`file-tools.mjs`中的模块导出其函数`isTextFilePath()`：'
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The module in `main.mjs` imports the whole module `path` and the function `isTextFilePath()`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.mjs`中的模块导入整个模块`path`和函数`isTextFilePath()`：'
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 7.1.3 Classes
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.3 类
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 7.1.4 Exception handling
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.4 异常处理
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: '`try-finally` and `try-catch-finally` are also supported.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try-finally`和`try-catch-finally`也受支持。'
- en: We can throw any value, but features such as stack traces are only supported
    by `Error` and its subclasses.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以抛出任何值，但是堆栈跟踪等功能仅由`Error`及其子类支持。
- en: 7.1.5 Legal variable and property names
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.5 合法的变量和属性名
- en: The grammatical category of variable names and property names is called *identifier*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名和属性名的语法类别称为*标识符*。
- en: 'Identifiers are allowed to have the following characters:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符允许具有以下字符：
- en: 'Unicode letters: `A`–`Z`, `a`–`z` (etc.)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unicode字母：`A`–`Z`，`a`–`z`（等等）
- en: '`$`, `_`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`，`_`'
- en: 'Unicode digits: `0`–`9` (etc.)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unicode数字：`0`–`9`（等等）
- en: Variable names can’t start with a digit
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名不能以数字开头
- en: 'Some words have special meaning in JavaScript and are called *reserved*. Examples
    include: `if`, `true`, `const`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一些单词在JavaScript中具有特殊含义，被称为*保留字*。例如：`if`，`true`，`const`。
- en: 'Reserved words can’t be used as variable names:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 保留字不能用作变量名：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'But they are allowed as names of properties:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 但它们允许作为属性的名称：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 7.1.6 Casing styles
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.6 大小写风格
- en: 'Common casing styles for concatenating words are:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 连接单词的常见大小写风格有：
- en: 'Camel case: `threeConcatenatedWords`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驼峰命名法：`threeConcatenatedWords`
- en: 'Underscore case (also called *snake case*): `three_concatenated_words`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下划线命名法（也称为*蛇形命名法*）：`three_concatenated_words`
- en: 'Dash case (also called *kebab case*): `three-concatenated-words`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破折号命名法（也称为*烤肉串命名法*）：`three-concatenated-words`
- en: 7.1.7 Capitalization of names
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.7 名称的大写形式
- en: In general, JavaScript uses camel case, except for constants.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，JavaScript使用驼峰命名法，除了常量。
- en: 'Lowercase:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 小写：
- en: 'Functions, variables: `myFunction`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数，变量：`myFunction`
- en: 'Methods: `obj.myMethod`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法：`obj.myMethod`
- en: 'CSS:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS：
- en: 'CSS entity: `special-class`'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS实体：`special-class`
- en: 'Corresponding JavaScript variable: `specialClass`'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对应的JavaScript变量：`specialClass`
- en: 'Uppercase:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 大写：
- en: 'Classes: `MyClass`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类：`MyClass`
- en: 'Constants: `MY_CONSTANT`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量：`MY_CONSTANT`
- en: 'Constants are also often written in camel case: `myConstant`'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量通常也以驼峰命名法编写：`myConstant`
- en: 7.1.8 More naming conventions
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.8 更多命名约定
- en: The following naming conventions are popular in JavaScript.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命名约定在JavaScript中很受欢迎。
- en: 'If the name of a parameter starts with an underscore (or is an underscore)
    it means that this parameter is not used – for example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数名以下划线开头（或者是下划线），则表示该参数未被使用——例如：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the name of a property of an object starts with an underscore then that
    property is considered private:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象的属性名以下划线开头，则该属性被视为私有：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 7.1.9 Where to put semicolons?
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.9 分号放在哪里？
- en: 'At the end of a statement:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在语句结束时：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'But not if that statement ends with a curly brace:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果该语句以大括号结束，则不是条件语句：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'However, adding a semicolon after such a statement is not a syntax error –
    it is interpreted as an empty statement:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这样的语句后添加分号不是语法错误——它被解释为空语句：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz: basic**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **测验：基础**'
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[测验应用程序](ch_quizzes-exercises.html#quizzes)。
- en: 7.2 (Advanced)
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2（高级）
- en: All remaining sections of this chapter are advanced.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有其余部分都是高级内容。
- en: 7.3 Identifiers
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3 标识符
- en: 7.3.1 Valid identifiers (variable names, etc.)
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.1 有效标识符（变量名等）
- en: 'First character:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首字符：
- en: Unicode letter (including accented characters such as `é` and `ü` and characters
    from non-latin alphabets, such as `α`)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unicode字母（包括重音字符，如`é`和`ü`，以及非拉丁字母的字符，如`α`）
- en: '`$`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`'
- en: '`_`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_`'
- en: 'Subsequent characters:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 后续字符：
- en: Legal first characters
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合法的首字符
- en: Unicode digits (including Eastern Arabic numerals)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unicode数字（包括东阿拉伯数字）
- en: Some other Unicode marks and punctuations
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些其他Unicode标记和标点符号
- en: 'Examples:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例子：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 7.3.2 Reserved words
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.2 保留字
- en: Reserved words can’t be variable names, but they can be property names.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 保留字不能作为变量名，但可以作为属性名。
- en: 'All JavaScript *keywords* are reserved words:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 所有JavaScript *关键字*都是保留字：
- en: '`await` `break` `case` `catch` `class` `const` `continue` `debugger` `default`
    `delete` `do` `else` `export` `extends` `finally` `for` `function` `if` `import`
    `in` `instanceof` `let` `new` `return` `static` `super` `switch` `this` `throw`
    `try` `typeof` `var` `void` `while` `with` `yield`'
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`await` `break` `case` `catch` `class` `const` `continue` `debugger` `default`
    `delete` `do` `else` `export` `extends` `finally` `for` `function` `if` `import`
    `in` `instanceof` `let` `new` `return` `static` `super` `switch` `this` `throw`
    `try` `typeof` `var` `void` `while` `with` `yield`'
- en: 'The following tokens are also keywords, but currently not used in the language:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标记也是关键字，但目前在语言中没有使用：
- en: '`enum` `implements` `package` `protected` `interface` `private` `public`'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`enum` `implements` `package` `protected` `interface` `private` `public`'
- en: 'The following literals are reserved words:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文字是保留字：
- en: '`true` `false` `null`'
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`true` `false` `null`'
- en: 'Technically, these words are not reserved, but you should avoid them, too,
    because they effectively are keywords:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这些词并不是保留字，但你也应该避免使用它们，因为它们实际上是关键字：
- en: '`Infinity` `NaN` `undefined` `async`'
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Infinity` `NaN` `undefined` `async`'
- en: You shouldn’t use the names of global variables (`String`, `Math`, etc.) for
    your own variables and parameters, either.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你也不应该为你自己的变量和参数使用全局变量的名称（`String`，`Math`等）。
- en: 7.4 Statement vs. expression
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4 语句 vs. 表达式
- en: 'In this section, we explore how JavaScript distinguishes two kinds of syntactic
    constructs: *statements* and *expressions*. Afterward, we’ll see that that can
    cause problems because the same syntax can mean different things, depending on
    where it is used.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了JavaScript如何区分两种语法结构：*语句*和*表达式*。之后，我们会看到这可能会引起问题，因为相同的语法在不同的上下文中可能意味着不同的东西。
- en: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png)  **We pretend there are
    only statements and expressions**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/b666ba365e94edaf0ef510fd7e12c7de.png) **我们假装只有语句和表达式**'
- en: For the sake of simplicity, we pretend that there are only statements and expressions
    in JavaScript.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们假设在JavaScript中只有语句和表达式。
- en: 7.4.1 Statements
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.1 语句
- en: 'A *statement* is a piece of code that can be executed and performs some kind
    of action. For example, `if` is a statement:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*语句*是一段可以执行并执行某种操作的代码。例如，`if`是一个语句：'
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'One more example of a statement: a function declaration.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个语句的例子：函数声明。
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 7.4.2 Expressions
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.2 表达式
- en: 'An *expression* is a piece of code that can be *evaluated* to produce a value.
    For example, the code between the parentheses is an expression:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*表达式*是一段可以*评估*产生一个值的代码。例如，括号之间的代码就是一个表达式：'
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The operator `_?_:_` used between the parentheses is called the *ternary operator*.
    It is the expression version of the `if` statement.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 括号之间使用的运算符`_?_:_`称为*三元运算符*。它是`if`语句的表达式版本。
- en: 'Let’s look at more examples of expressions. We enter expressions and the REPL
    evaluates them for us:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看更多表达式的例子。我们输入表达式，REPL为我们评估它们：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 7.4.3 What is allowed where?
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.3 允许在哪里？
- en: 'The current location within JavaScript source code determines which kind of
    syntactic constructs you are allowed to use:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript源代码中的当前位置决定了你可以使用哪种语法结构：
- en: 'The body of a function must be a sequence of statements:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数的主体必须是一系列语句：
- en: '[PRE34]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The arguments of a function call or a method call must be expressions:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数调用或方法调用的参数必须是表达式：
- en: '[PRE35]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'However, expressions can be used as statements. Then they are called *expression
    statements*. The opposite is not true: when the context requires an expression,
    you can’t use a statement.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，表达式可以用作语句。然后它们被称为*表达式语句*。相反的情况并不成立：当上下文要求一个表达式时，你不能使用一个语句。
- en: 'The following code demonstrates that any expression `bar()` can be either expression
    or statement – it depends on the context:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了任何表达式`bar()`都可以是表达式或语句 - 这取决于上下文：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 7.5 Ambiguous syntax
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5 歧义语法
- en: 'JavaScript has several programming constructs that are syntactically ambiguous:
    the same syntax is interpreted differently, depending on whether it is used in
    statement context or in expression context. This section explores the phenomenon
    and the pitfalls it causes.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有几种编程结构在语法上是模棱两可的：相同的语法根据是在语句上下文还是表达式上下文中使用而有不同的解释。本节探讨了这种现象和它引起的陷阱。
- en: '7.5.1 Same syntax: function declaration and function expression'
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.1 相同的语法：函数声明和函数表达式
- en: 'A *function declaration* is a statement:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明是一个语句：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'A *function expression* is an expression (right-hand side of `=`):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数表达式*是一个表达式（`=`的右侧）：'
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '7.5.2 Same syntax: object literal and block'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.2 相同的语法：对象字面量和代码块
- en: 'In the following code, `{}` is an *object literal*: an expression that creates
    an empty object.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，`{}`是一个*对象字面量*：一个创建空对象的表达式。
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is an empty code block (a statement):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个空代码块（一个语句）：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 7.5.3 Disambiguation
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.3 消除歧义
- en: 'The ambiguities are only a problem in statement context: If the JavaScript
    parser encounters ambiguous syntax, it doesn’t know if it’s a plain statement
    or an expression statement. For example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 歧义只在语句上下文中是一个问题：如果JavaScript解析器遇到歧义的语法，它不知道它是一个普通语句还是一个表达式语句。例如：
- en: 'If a statement starts with `function`: Is it a function declaration or a function
    expression?'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个语句以`function`开头：它是函数声明还是函数表达式？
- en: 'If a statement starts with `{`: Is it an object literal or a code block?'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个语句以`{`开头：它是对象字面量还是代码块？
- en: 'To resolve the ambiguity, statements starting with `function` or `{` are never
    interpreted as expressions. If you want an expression statement to start with
    either one of these tokens, you must wrap it in parentheses:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除歧义，以`function`或`{`开头的语句永远不会被解释为表达式。如果你想要一个表达式语句以这些标记之一开头，你必须将其包裹在括号中：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In this code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中：
- en: 'We first create a function via a function expression:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先通过函数表达式创建一个函数：
- en: '[PRE42]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then we invoke that function: `(''abc'')`'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们调用那个函数：`('abc')`
- en: The code fragment shown in (1) is only interpreted as an expression because
    we wrap it in parentheses. If we didn’t, we would get a syntax error because then
    JavaScript expects a function declaration and complains about the missing function
    name. Additionally, you can’t put a function call immediately after a function
    declaration.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在（1）中显示的代码片段之所以被解释为表达式，是因为我们将其包裹在括号中。如果我们不这样做，我们将得到一个语法错误，因为此时JavaScript期望一个函数声明，并抱怨缺少函数名。此外，你不能在函数声明后立即放置一个函数调用。
- en: 'Later in this book, we’ll see more examples of pitfalls caused by syntactic
    ambiguity:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面，我们将看到由语法歧义引起的更多陷阱的例子：
- en: '[Assigning via object destructuring](ch_destructuring.html#assigning-via-object-destructuring)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[通过对象解构赋值](ch_destructuring.html#assigning-via-object-destructuring)'
- en: '[Returning an object literal from an arrow function](ch_callables.html#returning-object-literal-from-arrow-function)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[从箭头函数返回对象文字](ch_callables.html#returning-object-literal-from-arrow-function)'
- en: 7.6 Semicolons
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6 分号
- en: 7.6.1 Rule of thumb for semicolons
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.1 分号的经验法则
- en: 'Each statement is terminated by a semicolon:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 每个语句都以分号结束：
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'except statements ending with blocks:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 除了以块结束的语句：
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following case is slightly tricky:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下情况稍微棘手：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The whole `const` declaration (a statement) ends with a semicolon, but inside
    it, there is an arrow function expression. That is, it’s not the statement per
    se that ends with a curly brace; it’s the embedded arrow function expression.
    That’s why there is a semicolon at the end.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 整个`const`声明（一个语句）以分号结束，但在其中有一个箭头函数表达式。也就是说，结束语句并不是语句本身以花括号结束；而是嵌入的箭头函数表达式。这就是为什么最后有一个分号。
- en: '7.6.2 Semicolons: control statements'
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.2 分号：控制语句
- en: 'The body of a control statement is itself a statement. For example, this is
    the syntax of the `while` loop:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 控制语句的主体本身就是一个语句。例如，这是`while`循环的语法：
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The body can be a single statement:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 主体可以是一个单独的语句：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'But blocks are also statements and therefore legal bodies of control statements:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 但是块也是语句，因此是控制语句的合法主体：
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you want a loop to have an empty body, your first option is an empty statement
    (which is just a semicolon):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让一个循环有一个空主体，你的第一个选择是一个空语句（只是一个分号）：
- en: '[PRE49]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Your second option is an empty block:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你的第二个选择是一个空块：
- en: '[PRE50]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 7.7 Automatic semicolon insertion (ASI)
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7 自动分号插入（ASI）
- en: While I recommend to always write semicolons, most of them are optional in JavaScript.
    The mechanism that makes this possible is called *automatic semicolon insertion*
    (ASI). In a way, it corrects syntax errors.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我建议总是写分号，但在JavaScript中大多数分号是可选的。使这种可能的机制称为*自动分号插入*（ASI）。在某种程度上，它纠正了语法错误。
- en: 'ASI works as follows. Parsing of a statement continues until there is either:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ASI的工作方式如下。语句的解析会一直持续，直到出现以下情况之一：
- en: A semicolon
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个分号
- en: A line terminator followed by an illegal token
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行终止符后跟一个非法标记
- en: In other words, ASI can be seen as inserting semicolons at line breaks. The
    next subsections cover the pitfalls of ASI.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，ASI可以被看作是在换行符处插入分号。接下来的小节将介绍ASI的陷阱。
- en: 7.7.1 ASI triggered unexpectedly
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.7.1 意外触发的ASI
- en: The good news about ASI is that – if you don’t rely on it and always write semicolons
    – there is only one pitfall that you need to be aware of. It is that JavaScript
    forbids line breaks after some tokens. If you do insert a line break, a semicolon
    will be inserted, too.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 关于ASI的好消息是 - 如果你不依赖它并总是写分号 - 那么你需要注意的只有一个陷阱。那就是JavaScript禁止在某些标记后换行。如果你插入一个换行符，分号也会被插入。
- en: 'The token where this is most practically relevant is `return`. Consider, for
    example, the following code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这在实际上最相关的标记是`return`。例如，考虑以下代码：
- en: '[PRE51]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This code is parsed as:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码被解析为：
- en: '[PRE52]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'That is:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说：
- en: 'Return statement without operand: `return;`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有操作数的返回语句：`return;`
- en: 'Start of code block: `{`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码块的开始：`{`
- en: Expression statement `'jane';` with [label](ch_control-flow.html#labels) `first:`
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式语句`'jane';`与[标签](ch_control-flow.html#labels)`first:`
- en: 'End of code block: `}`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码块的结束：`}`
- en: 'Empty statement: `;`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空语句：`;`
- en: Why does JavaScript do this? It protects against accidentally returning a value
    in a line after a `return`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么JavaScript会这样做？它防止在`return`后的行中意外返回一个值。
- en: 7.7.2 ASI unexpectedly not triggered
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.7.2 意外未触发的ASI
- en: In some cases, ASI is *not* triggered when you think it should be. That makes
    life more complicated for people who don’t like semicolons because they need to
    be aware of those cases. The following are three examples. There are more.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，当你认为应该触发ASI时，ASI *没有*被触发。这使得不喜欢分号的人的生活变得更加复杂，因为他们需要注意这些情况。以下是三个例子。还有更多。
- en: '**Example 1:** Unintended function call.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**例1：**意外的函数调用。'
- en: '[PRE53]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Parsed as:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 解析为：
- en: '[PRE54]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**Example 2:** Unintended division.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**例2：**意外的除法。'
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Parsed as:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 解析为：
- en: '[PRE56]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '**Example 3:** Unintended property access.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**例3：**意外的属性访问。'
- en: '[PRE57]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Executed as:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 执行为：
- en: '[PRE58]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '7.8 Semicolons: best practices'
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.8 分号：最佳实践
- en: 'I recommend that you always write semicolons:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你总是写分号：
- en: I like the visual structure it gives code – you clearly see where a statement
    ends.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我喜欢它给代码带来的视觉结构 - 你清楚地看到语句在哪里结束。
- en: There are less rules to keep in mind.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要记住的规则较少。
- en: The majority of JavaScript programmers use semicolons.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数JavaScript程序员使用分号。
- en: 'However, there are also many people who don’t like the added visual clutter
    of semicolons. If you are one of them: Code without them *is* legal. I recommend
    that you use tools to help you avoid mistakes. The following are two examples:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有很多人不喜欢分号增加的视觉混乱。如果你是其中之一：不用它们的代码是合法的。我建议你使用工具来帮助你避免错误。以下是两个例子：
- en: The automatic code formatter [Prettier](https://prettier.io) can be configured
    to not use semicolons. It then automatically fixes problems. For example, if it
    encounters a line that starts with a square bracket, it prefixes that line with
    a semicolon.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动代码格式化程序[Prettier](https://prettier.io)可以配置为不使用分号。它然后会自动修复问题。例如，如果它遇到以方括号开头的行，它会在该行前面加上一个分号。
- en: The static checker [ESLint](https://eslint.org) has [a rule](https://eslint.org/docs/rules/semi)
    that you tell your preferred style (always semicolons or as few semicolons as
    possible) and that warns you about critical issues.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态检查器[ESLint](https://eslint.org)有[一个规则](https://eslint.org/docs/rules/semi)，告诉你首选的风格（总是分号或尽可能少的分号），并警告你关于关键问题。
- en: 7.9 Strict mode vs. sloppy mode
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.9 严格模式与松散模式
- en: 'Starting with ECMAScript 5, JavaScript has two *modes* in which JavaScript
    can be executed:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 从ECMAScript 5开始，JavaScript有两种可以执行的*模式*：
- en: Normal “sloppy” mode is the default in scripts (code fragments that are a precursor
    to modules and supported by browsers).
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常的“松散”模式是脚本的默认模式（作为模块的前导片段，并受浏览器支持）。
- en: Strict mode is the default in modules and classes, and can be switched on in
    scripts (how is explained later). In this mode, several pitfalls of normal mode
    are removed and more exceptions are thrown.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格模式是模块和类的默认模式，并且可以在脚本中打开（稍后会解释）。在此模式下，消除了普通模式的几个陷阱，并且会抛出更多的异常。
- en: You’ll rarely encounter sloppy mode in modern JavaScript code, which is almost
    always located in modules. In this book, I assume that strict mode is always switched
    on.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代JavaScript代码中，您很少会遇到懈怠模式，它几乎总是位于模块中。在本书中，我假设严格模式总是打开的。
- en: 7.9.1 Switching on strict mode
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.9.1 打开严格模式
- en: 'In script files and CommonJS modules, you switch on strict mode for a complete
    file, by putting the following code in the first line:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本文件和CommonJS模块中，您可以通过在第一行放置以下代码来为整个文件切换到严格模式：
- en: '[PRE59]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The neat thing about this “directive” is that ECMAScript versions before 5
    simply ignore it: it’s an expression statement that does nothing.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个“指令”的好处是，ECMAScript 5之前的版本简单地忽略它：它是一个什么都不做的表达式语句。
- en: 'You can also switch on strict mode for just a single function:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以仅为单个函数切换到严格模式：
- en: '[PRE60]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 7.9.2 Improvements in strict mode
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.9.2 严格模式的改进
- en: Let’s look at three things that strict mode does better than sloppy mode. Just
    in this one section, all code fragments are executed in sloppy mode.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看严格模式比懈怠模式做得更好的三件事。在这一部分中，所有代码片段都在懈怠模式下执行。
- en: '7.9.2.1 Sloppy mode pitfall: changing an undeclared variable creates a global
    variable'
  id: totrans-293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.9.2.1 懈怠模式陷阱：更改未声明的变量会创建全局变量
- en: In non-strict mode, changing an undeclared variable creates a global variable.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在非严格模式下，更改未声明的变量会创建一个全局变量。
- en: '[PRE61]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Strict mode does it better and throws a `ReferenceError`. That makes it easier
    to detect typos.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式做得更好，并抛出`ReferenceError`。这样更容易检测拼写错误。
- en: '[PRE62]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `assert.throws()` states that its first argument, a function, throws a `ReferenceError`
    when it is called.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert.throws()`声明其第一个参数，一个函数，在调用时会抛出`ReferenceError`。'
- en: 7.9.2.2 Function declarations are block-scoped in strict mode, function-scoped
    in sloppy mode
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.9.2.2 在严格模式下，函数声明是块作用域的，在懈怠模式下是函数作用域的
- en: 'In strict mode, a variable created via a function declaration only exists within
    the innermost enclosing block:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，通过函数声明创建的变量仅存在于最内层的封闭块中：
- en: '[PRE63]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In sloppy mode, function declarations are function-scoped:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在懈怠模式下，函数声明是函数作用域的：
- en: '[PRE64]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 7.9.2.3 Sloppy mode doesn’t throw exceptions when changing immutable data
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.9.2.3 懈怠模式在更改不可变数据时不会抛出异常
- en: 'In strict mode, you get an exception if you try to change immutable data:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，如果尝试更改不可变数据，会得到一个异常：
- en: '[PRE65]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In sloppy mode, the assignment fails silently:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在懈怠模式下，赋值会悄无声息地失败：
- en: '[PRE66]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '![](../Images/aec4653f22c8cf0e517ff5024759dfe1.png)  **Further reading: sloppy
    mode**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/aec4653f22c8cf0e517ff5024759dfe1.png) **进一步阅读：懈怠模式**'
- en: For more information on how sloppy mode differs from strict mode, see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 有关懈怠模式与严格模式之间的区别的更多信息，请参见[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)。
- en: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png)  **Quiz: advanced**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/4ca05ad97a693bee61e4fd6459232e60.png) **测验：高级**'
- en: See [quiz app](ch_quizzes-exercises.html#quizzes).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[测验应用程序](ch_quizzes-exercises.html#quizzes)。
- en: '[Comments](https://github.com/rauschma/impatient-js/issues/5)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[评论](https://github.com/rauschma/impatient-js/issues/5)'
