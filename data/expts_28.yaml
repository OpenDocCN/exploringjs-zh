- en: 23 Types for classes as values
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 23 类作为值的类型
- en: 原文：[https://exploringjs.com/ts/book/ch_classes-as-values.html](https://exploringjs.com/ts/book/ch_classes-as-values.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/ts/book/ch_classes-as-values.html](https://exploringjs.com/ts/book/ch_classes-as-values.html)
- en: (Ad, please don’t block.)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: （广告，请勿拦截。）
- en: '[23.1 Question: Which type for a class as a value?](#question-which-type-for-a-class-as-a-value)'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.1 问题：类作为值应该使用哪种类型？](#question-which-type-for-a-class-as-a-value)'
- en: '[23.2 Answer: types for classes as values](#answer-types-for-classes-as-values)'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.2 回答：类作为值的类型](#answer-types-for-classes-as-values)'
- en: '[23.2.1 The type operator `typeof`](#type-operator-typeof)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.2.1 类型运算符 `typeof`](#type-operator-typeof)'
- en: '[23.2.2 Constructor type literals](#constructor-type-literals)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.2.2 构造函数类型字面量](#constructor-type-literals)'
- en: '[23.2.3 Object type literals with construct signatures](#construct-signatures)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.2.3 带有构造签名的对象类型字面量](#construct-signatures)'
- en: '[23.3 A generic type for constructors: `Class<T>`](#generic-type-class)'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.3 构造函数的泛型类型：`Class<T>`](#generic-type-class)'
- en: '[23.3.1 Example: creating instances](#example-creating-instances)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.3.1 示例：创建实例](#example-creating-instances)'
- en: '[23.3.2 Example: type-narrowing via `instanceof`](#example-type-narrowing-via-instanceof)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.3.2 示例：通过 `instanceof` 进行类型缩小](#example-type-narrowing-via-instanceof)'
- en: '[23.3.3 Example: casting with runtime checks](#example-casting-with-runtime-checks)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.3.3 示例：带有运行时检查的类型转换](#example-casting-with-runtime-checks)'
- en: '[23.3.4 Example: an assertion function](#example-an-assertion-function)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.3.4 示例：断言函数](#example-an-assertion-function)'
- en: '[23.3.5 Example: Maps that are type-safe at runtime](#example-maps-that-are-type-safe-at-runtime)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.3.5 示例：运行时类型安全的映射](#example-maps-that-are-type-safe-at-runtime)'
- en: '[23.3.6 Pitfall: `Class<T>` does not match abstract classes](#pitfall-class-t-does-not-match-abstract-classes)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[23.3.6 陷阱：`Class<T>` 不匹配抽象类](#pitfall-class-t-does-not-match-abstract-classes)'
- en: 'In this chapter, we explore classes as values:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨类作为值：
- en: What types should we use for such values?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于这样的值，我们应该使用什么类型？
- en: What are the use cases for these types?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些类型的用例是什么？
- en: '[23.1 Question: Which type for a class as a value?](#question-which-type-for-a-class-as-a-value)'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[23.1 问题：类作为值应该使用哪种类型？](#question-which-type-for-a-class-as-a-value)'
- en: 'Consider the following class:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下类：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This function accepts a class and creates an instance of it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个类并创建其实例：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What type `C` should we use for the parameter `PointClass` if we want the function
    to return an instance of `Point`?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让函数返回 `Point` 的实例，我们应该使用什么类型 `C`？
- en: '[23.2 Answer: types for classes as values](#answer-types-for-classes-as-values)'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[23.2 回答：类作为值的类型](#answer-types-for-classes-as-values)'
- en: '[23.2.1 The type operator `typeof`](#type-operator-typeof)'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[23.2.1 类型运算符 `typeof`](#type-operator-typeof)'
- en: 'In [“TypeScript’s two language levels” (§4.4)](ch_typescript-essentials.html#language-levels),
    we explored the two language levels of TypeScript:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“TypeScript 的两种语言级别”（§4.4）](ch_typescript-essentials.html#language-levels)
    中，我们探讨了 TypeScript 的两种语言级别：
- en: 'Dynamic level: JavaScript (code and values)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态级别：JavaScript（代码和值）
- en: 'Static level: TypeScript (static types)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态级别：TypeScript（静态类型）
- en: 'The class `Point` creates two things:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `Point` 创建了两件事：
- en: The constructor function `Point`
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数 `Point`
- en: The interface `Point` for instances of `Point`
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Point` 实例的接口'
- en: 'Depending on where we mention `Point`, it means different things. That’s why
    we can’t use the type `Point` for `PointClass`: It matches *instances* of class
    `Point`, not class `Point` itself.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在哪里提到 `Point`，它意味着不同的事情。这就是为什么我们不能为 `PointClass` 使用类型 `Point`：它匹配类 `Point`
    的*实例*，而不是类 `Point` 本身。
- en: Instead, we need to use the type operator `typeof` (which has the same name
    as a JavaScript operator). `typeof v` stands for the type of the value `v`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们需要使用类型运算符 `typeof`（它与 JavaScript 运算符同名）。`typeof v` 表示值 `v` 的类型。
- en: 'Let’s omit the return type of `createPoint()` and see what TypeScript infers:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们省略 `createPoint()` 的返回类型，看看 TypeScript 如何推断：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As expected, `createPoint()` creates values of type `Point` (line A).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，`createPoint()` 创建了类型为 `Point` 的值（行 A）。
- en: '[23.2.2 Constructor type literals](#constructor-type-literals)'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[23.2.2 构造函数类型字面量](#constructor-type-literals)'
- en: 'A *constructor type literal* is a literal for constructor types: `new` followed
    by a function type literal (line A):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*构造函数类型字面量* 是构造函数类型的字面量：`new` 后跟一个函数类型字面量（行 A）：'
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The prefix `new` of its type indicates that `PointClass` is a function that
    must be invoked via `new`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 其类型的 `new` 前缀表示 `PointClass` 是一个必须通过 `new` 调用的函数。
- en: 'Constructor type literals are quite versatile – e.g., we can demand that a
    constructor function (such as a class):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数类型字面量非常灵活——例如，我们可以要求构造函数（如类）：
- en: Have particular parameters.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有特定的参数。
- en: Return instances with a particular interface (see code below)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回具有特定接口的实例（见下面的代码）
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[23.2.3 Object type literals with construct signatures](#construct-signatures)'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[23.2.3 带有构造签名的对象类型字面量](#construct-signatures)'
- en: Recall that [members of interfaces and object literal types (OLTs)](ch_typing-objects.html#members-of-object-literal-types)
    include method signatures and call signatures. Call signatures enable interfaces
    and OLTs to describe functions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，[接口和对象字面量类型（OLTs）的成员](ch_typing-objects.html#members-of-object-literal-types)包括方法签名和调用签名。调用签名使接口和
    OLTs 能够描述函数。
- en: 'Similarly, *construct signatures* enable interfaces and OLTs to describe constructor
    functions. They look like call signatures with the added prefix `new`. In the
    next example, `PointClass` has an object literal type with a construct signature:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，*构造签名*使接口和 OLTs 能够描述构造函数。它们看起来像调用签名，但添加了前缀 `new`。在下一个示例中，`PointClass` 有一个具有构造签名的对象字面量类型：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[23.3 A generic type for constructors: `Class<T>`](#generic-type-class)'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[23.3 一种用于构造函数的泛型类型：`Class<T>`](#generic-type-class)'
- en: 'With the knowledge we have acquired, we can now create a generic type for classes
    as values – by introducing a type parameter `T`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们所获得的知识，我们现在可以为类创建一个通用的类型作为值——通过引入一个类型参数 `T`：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Instead of a type alias, we can also use an interface:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类型别名，我们还可以使用接口：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Class<T>` is a type for classes whose instances match type `T`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Class<T>` 是一个类型，其实例与类型 `T` 匹配。'
- en: '[23.3.1 Example: creating instances](#example-creating-instances)'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[23.3.1 示例：创建实例](#example-creating-instances)'
- en: '`Class<T>` enables us to write a generic version of `createPoint()`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Class<T>` 使我们能够编写 `createPoint()` 的泛型版本：'
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`createInstance()` is used as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`createInstance()` 的使用方法如下：'
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`createInstance()` is the `new` operator, implemented via a function.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`createInstance()` 是 `new` 操作符，通过一个函数实现。'
- en: '[23.3.2 Example: type-narrowing via `instanceof`](#example-type-narrowing-via-instanceof)'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[23.3.2 示例：通过 `instanceof` 进行类型缩小](#example-type-narrowing-via-instanceof)'
- en: 'In line A, `instanceof` narrows the type of `arg`: Before, it is `unknown`.
    After, it is `T`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 A 中，`instanceof` 缩小了 `arg` 的类型：之前它是 `unknown`，之后它是 `T`。
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[23.3.3 Example: casting with runtime checks](#example-casting-with-runtime-checks)'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[23.3.3 示例：带有运行时检查的类型转换](#example-casting-with-runtime-checks)'
- en: 'We can use `Class<T>` to implement casting:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Class<T>` 来实现类型转换：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With `cast()`, we can change the type of a value to something more specific.
    This is also safe at runtime, because we both statically change the type and perform
    a dynamic check. The following code provides an example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `cast()`，我们可以将一个值的类型更改为更具体的东西。这在运行时也是安全的，因为我们既静态地改变了类型，又执行了动态检查。以下代码提供了一个示例：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[23.3.4 Example: an assertion function](#example-an-assertion-function)'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[23.3.4 示例：断言函数](#example-an-assertion-function)'
- en: 'We can turn function `cast()` from the previous subsection into an [assertion
    function](ch_assertion-functions.html#ch_assertion-functions):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将前一小节中的函数 `cast()` 转换为一个 [断言函数](ch_assertion-functions.html#ch_assertion-functions)：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The return type (line A) makes `throwIfNotInstance()` an assertion function
    that narrows types:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型（行 A）使 `throwIfNotInstance()` 成为一个断言函数，它缩小了类型：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[23.3.5 Example: Maps that are type-safe at runtime](#example-maps-that-are-type-safe-at-runtime)'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[23.3.5 示例：运行时类型安全的映射](#example-maps-that-are-type-safe-at-runtime)'
- en: 'One use case for `Class<T>` and `cast()` is type-safe Maps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Class<T>` 和 `cast()` 的一种用例是类型安全的映射：'
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The key of each entry in a `TypeSafeMap` is a class. That class determines the
    static type of the entry’s value and is also used for checks at runtime.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`TypeSafeMap` 中的每个条目的键是一个类。该类决定了条目值的静态类型，并在运行时进行检查。'
- en: 'This is `TypeSafeMap` in action:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `TypeSafeMap` 在起作用：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[23.3.6 Pitfall: `Class<T>` does not match abstract classes](#pitfall-class-t-does-not-match-abstract-classes)'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[23.3.6 陷阱：`Class<T>` 不匹配抽象类](#pitfall-class-t-does-not-match-abstract-classes)'
- en: 'Consider the following classes:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下类：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`Class<T>` does not match the abstract class `Shape` (last line):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Class<T>` 不匹配抽象类 `Shape`（最后一行）：'
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Why is that? The rationale is that constructor type literals and construct signatures
    should only be used for values that can actually be `new`-invoked.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么呢？理由是构造函数类型字面量和构造签名应该只用于实际上可以被 `new` 调用的值。
- en: 'If we want to `Class<T>` to match both abstract and concrete classes, we can
    use an *abstract construct signature*:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让 `Class<T>` 匹配抽象类和具体类，我们可以使用一个 *抽象构造签名*：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There is once caveat – this type cannot be `new`-invoked:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个注意事项——这个类型不能被 `new` 调用：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, the new `Class<T>` works well for all other use cases, including `instanceof`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，新的 `Class<T>` 对于所有其他用例都工作得很好，包括 `instanceof`：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Therefore, we can rename the old type for classes to `NewableClass<T>` – in
    case we need a class to be `new`-invokable:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将旧类型名称更改为 `NewableClass<T>` – 以便在需要类可被 `new` 调用的情况下使用：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
