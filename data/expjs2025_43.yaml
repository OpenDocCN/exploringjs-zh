- en: 36 Maps (Map) ES6
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 36 Maps (Map) ES6
- en: 原文：[https://exploringjs.com/js/book/ch_maps.html](https://exploringjs.com/js/book/ch_maps.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/js/book/ch_maps.html](https://exploringjs.com/js/book/ch_maps.html)
- en: '[36.1 Using Maps](#using-maps)'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.1 使用 Maps](#using-maps)'
- en: '[36.1.1 Creating Maps](#creating-maps)'
  id: totrans-3
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.1.1 创建 Maps](#creating-maps)'
- en: '[36.1.2 Working with single entries](#working-with-single-entries)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.1.2 处理单个条目](#working-with-single-entries)'
- en: '[36.1.3 Determining the size of a Map and clearing it](#determining-the-size-of-a-map-and-clearing-it)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.1.3 确定 Maps 的大小并清除它](#determining-the-size-of-a-map-and-clearing-it)'
- en: '[36.1.4 Example: Counting characters](#example-counting-characters)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.1.4 示例：计数字符](#example-counting-characters)'
- en: '[36.2 Iterating over Maps](#iterating-over-maps)'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.2 在 Map 上迭代](#iterating-over-maps)'
- en: '[36.2.1 Looping over Maps](#looping-over-maps)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.2.1 在 Map 上循环](#looping-over-maps)'
- en: '[36.2.2 Listed in insertion order: entries, keys, values](#maps-insertion-order-entries)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.2.2 按插入顺序列出：条目、键、值](#maps-insertion-order-entries)'
- en: '[36.3 Converting from and to Maps](#converting-from-and-to-maps)'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.3 从 Maps 转换到和从 Maps 转换](#converting-from-and-to-maps)'
- en: '[36.3.1 Converting keys, values, entries to Arrays](#converting-map-entries-to-arrays)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.3.1 将键、值、条目转换为 Arrays](#converting-map-entries-to-arrays)'
- en: '[36.3.2 Converting between Maps and Objects](#converting-between-maps-and-objects)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.3.2 在 Maps 和 Objects 之间转换](#converting-between-maps-and-objects)'
- en: '[36.4 Processing Maps](#processing-maps)'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.4 处理 Maps](#processing-maps)'
- en: '[36.4.1 Copying Maps](#copying-maps)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.4.1 复制 Maps](#copying-maps)'
- en: '[36.4.2 Combining multiple Maps into a single Map](#combining-maps)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.4.2 将多个 Maps 合并成一个单一 Map](#combining-maps)'
- en: '[36.4.3 Mapping and filtering Maps via iterator methods ^(ES2025)](#mapping-filtering-maps)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.4.3 通过迭代器方法映射和过滤 Maps（ES2025）](#mapping-filtering-maps)'
- en: '[36.5 A few more details about the keys of Maps (advanced)](#a-few-more-details-about-the-keys-of-maps-advanced)'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.5 关于 Maps 键的一些更多细节（高级）](#a-few-more-details-about-the-keys-of-maps-advanced)'
- en: '[36.5.1 What keys are considered equal?](#map-key-equality)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.5.1 哪些键被认为是相等的？](#map-key-equality)'
- en: '[36.6 Quick reference: `Map`](#quickref-maps)'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.6 快速参考：`Map`](#quickref-maps)'
- en: '[36.6.1 `new Map()`](#new-map)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.6.1 `new Map()`](#new-map)'
- en: '[36.6.2 `Map.*`](#map)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.6.2 `Map.*`](#map)'
- en: '[36.6.3 `Map.prototype.*`: handling single entries](#mapprototype-handling-single-entries)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.6.3 `Map.prototype.*`：处理单个条目](#mapprototype-handling-single-entries)'
- en: '[36.6.4 `Map.prototype`: handling all entries](#mapprototype-handling-all-entries)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.6.4 `Map.prototype`：处理所有条目](#mapprototype-handling-all-entries)'
- en: '[36.6.5 `Map.prototype`: iterating and looping](#mapprototype-iterating-and-looping)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.6.5 `Map.prototype`：迭代和循环](#mapprototype-iterating-and-looping)'
- en: '[36.7 FAQ: Maps](#faq-maps)'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.7 FAQ: Maps](#faq-maps)'
- en: '[36.7.1 When should I use a Map, and when should I use an object?](#when-should-i-use-a-map-and-when-should-i-use-an-object)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.7.1 应该何时使用 Map，何时使用对象？](#when-should-i-use-a-map-and-when-should-i-use-an-object)'
- en: '[36.7.2 When would I use an object as a key in a Map?](#when-would-i-use-an-object-as-a-key-in-a-map)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.7.2 当何时在 Map 中使用对象作为键？](#when-would-i-use-an-object-as-a-key-in-a-map)'
- en: '[36.7.3 Why do Maps preserve the insertion order of entries?](#why-do-maps-preserve-the-insertion-order-of-entries)'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.7.3 为什么 Maps 保留条目的插入顺序？](#why-do-maps-preserve-the-insertion-order-of-entries)'
- en: '[36.7.4 Why do Maps have a `.size`, while Arrays have a `.length`?](#collection-size-vs-length)'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[36.7.4 为什么 Maps 有 `.size`，而 Arrays 有 `.length`？](#collection-size-vs-length)'
- en: Before ES6, JavaScript didn’t have a data structure for dictionaries and (ab)used
    objects as dictionaries from strings to arbitrary values. ES6 brought Maps, which
    are dictionaries from arbitrary values to arbitrary values.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 之前，JavaScript 没有字典数据结构，而是将对象从字符串到任意值作为字典（滥用）使用。ES6 引入了 Maps，它是一种从任意值到任意值的字典。
- en: '[36.1 Using Maps](#using-maps)'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[36.1 使用 Maps](#using-maps)'
- en: An instance of `Map` maps keys to values. A single key-value mapping is called
    an *entry*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map` 的一个实例将键映射到值。单个键值映射称为 *条目*。'
- en: '[36.1.1 Creating Maps](#creating-maps)'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[36.1.1 创建 Maps](#creating-maps)'
- en: There are three common ways of creating Maps.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Maps 有三种常见方式。
- en: 'First, we can use the constructor without any parameters to create an empty
    Map:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以使用无参数的构造函数来创建一个空的 Map：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Second, we can pass an iterable (e.g., an Array) over key-value “pairs” (Arrays
    with two elements) to the constructor:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可以将可迭代的（例如，一个数组）传递给构造函数，作为键值“对”（包含两个元素的数组）：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Third, the `.set()` method adds entries to a Map and is chainable:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，`.set()` 方法向 Map 添加条目，并且是可链式的：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[36.1.2 Working with single entries](#working-with-single-entries)'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[36.1.2 处理单个条目](#working-with-single-entries)'
- en: '`map.set()` and `map.get()` are for writing and reading values (given keys).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`map.set()` 和 `map.get()` 用于写入和读取值（给定键）。'
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`map.has()` checks if a Map has an entry with a given key. `map.delete()` removes
    entries.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`map.has()` 检查 Map 是否包含具有给定键的条目。`map.delete()` 删除条目。'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[36.1.3 Determining the size of a Map and clearing it](#determining-the-size-of-a-map-and-clearing-it)'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[36.1.3 确定Map的大小和清除它](#determining-the-size-of-a-map-and-clearing-it)'
- en: '`map.size` contains the number of entries in a Map. `map.clear()` removes all
    entries of a Map.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`map.size` 包含 Map 中的条目数量。`map.clear()` 删除 Map 中的所有条目。'
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[36.1.4 Example: Counting characters](#example-counting-characters)'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[36.1.4 示例：计数字符](#example-counting-characters)'
- en: '`countChars()` returns a Map that maps characters to numbers of occurrences.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`countChars()` 返回一个将字符映射到出现次数的 Map。'
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[36.2 Iterating over Maps](#iterating-over-maps)'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[36.2 遍历Map](#iterating-over-maps)'
- en: 'This is how Maps support iteration:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Map 如何支持迭代的方式：
- en: '`new Map()` accepts an iterable over key-value pairs. That will be useful later
    when we look at processing Maps and at converting from and to Maps.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new Map()` 接受一个键值对的可迭代。这将在我们查看处理 Map 和从 Map 转换时很有用。'
- en: The following methods return iterable iterators – whose methods will be useful
    later when we look at processing Maps.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下方法返回可迭代的迭代器——其方法将在我们查看处理 Map 时很有用。
- en: '`map.keys()`: keys of `map`'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map.keys()`: `map` 的键'
- en: '`map.values()`: values of `map`'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map.values()`: `map` 的值'
- en: '`map.entries()`: entries (key-value pairs) of `map`'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map.entries()`: `map` 的条目（键值对）'
- en: '`map[Symbol.iterator]()`: same as `map.entries()`'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map[Symbol.iterator]()`: 与 `map.entries()` 相同'
- en: This method makes instances of `Map` iterable.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法使 `Map` 的实例可迭代。
- en: '[36.2.1 Looping over Maps](#looping-over-maps)'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[36.2.1 遍历Map](#looping-over-maps)'
- en: 'Maps are iterables over key-value pairs. This is a common way of iterating
    over them:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Map 可以通过键值对进行迭代。这是遍历它们的一种常见方式：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In line A, we use destructuring to access the components of the key-value pairs
    returned by the iterator.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 A 中，我们使用解构来访问迭代器返回的键值对的组件。
- en: 'Output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following example loops over the iterable iterator returned by method `.keys()`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何遍历由方法 `.keys()` 返回的可迭代迭代器：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[36.2.2 Listed in insertion order: entries, keys, values](#maps-insertion-order-entries)'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[36.2.2 按插入顺序列出：条目、键、值](#maps-insertion-order-entries)'
- en: 'Maps record in which order entries were created and honor that order when listing
    keys, values or entries:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Map 记录条目创建的顺序，并在列出键、值或条目时尊重该顺序：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Maps listing their contents in insertion order has two benefits:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 按插入顺序列出内容的 Map 有两个好处：
- en: We can use a Map when we have a use case where insertion order matters.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当插入顺序很重要时，我们可以使用 Map。
- en: In testing, results become more deterministic and easier to check.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试中，结果变得更加确定，更容易检查。
- en: '[36.3 Converting from and to Maps](#converting-from-and-to-maps)'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[36.3 从和到Map的转换](#converting-from-and-to-maps)'
- en: '[36.3.1 Converting keys, values, entries to Arrays](#converting-map-entries-to-arrays)'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[36.3.1 将键、值、条目转换为数组](#converting-map-entries-to-arrays)'
- en: 'On one hand, the values returned by `.keys()`, `.values()` and `.entries()`
    are iterables – which enables us to use `Array.from()`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，`.keys()`、`.values()` 和 `.entries()` 返回的值是可迭代的——这使我们能够使用 `Array.from()`：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'On the other hand, the values returned by `.keys()`, `.values()` and `.entries()`
    are also iterators – which enables us to use the iterator method `.toArray()`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`.keys()`、`.values()` 和 `.entries()` 返回的值也是迭代器——这使我们能够使用迭代器方法 `.toArray()`：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[36.3.2 Converting between Maps and Objects](#converting-between-maps-and-objects)'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[36.3.2 在 Map 和对象之间转换](#converting-between-maps-and-objects)'
- en: 'As long as a Map only uses strings and symbols as keys, we can convert it to
    an object (via [`Object.fromEntries()`](ch_objects.html#Object.fromEntries)):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 只要 Map 只使用字符串和符号作为键，我们就可以将其转换为对象（通过 `Object.fromEntries()`）：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can also convert an object to a Map with string or symbol keys (via [`Object.entries()`](ch_objects.html#Object.entries)):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过 `Object.entries()` 将对象转换为具有字符串或符号键的 Map：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[36.4 Processing Maps](#processing-maps)'
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[36.4 处理Map](#processing-maps)'
- en: '[36.4.1 Copying Maps](#copying-maps)'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[36.4.1 复制Map](#copying-maps)'
- en: 'As we have seen, Maps are iterables over key-value pairs. Therefore, we can
    use the constructor to create a copy of a Map. That copy is *shallow*: keys and
    values are the same; they are not copied/cloned themselves.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Map 可以通过键值对进行迭代。因此，我们可以使用构造函数来创建一个 Map 的副本。这个副本是**浅拷贝**：键和值是相同的；它们自身没有被复制/克隆。
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[36.4.2 Combining multiple Maps into a single Map](#combining-maps)'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[36.4.2 将多个Map合并为单个Map](#combining-maps)'
- en: 'There are no methods for combining Maps, which is why we must use a workaround.
    Let’s combine the following two Maps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 没有合并 Maps 的方法，这就是为什么我们必须使用一种解决方案。让我们合并以下两个 Maps：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To combine `map1` and `map2`, we create a new Array and spread (`...`) the
    entries (key-value pairs) of `map1` and `map2` into it (via iteration). Then we
    convert the Array back into a Map. All of that is done in line A:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要合并 `map1` 和 `map2`，我们创建一个新的数组，并将 `map1` 和 `map2` 的条目（键值对）展开到其中（通过迭代）。然后我们将数组转换回
    Map。所有这些都在行 A 中完成：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Combining Maps**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“练习”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：合并 Maps**'
- en: '`exercises/maps/combine_maps_test.mjs`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/maps/combine_maps_test.mjs`'
- en: '[36.4.3 Mapping and filtering Maps via iterator methods ^(ES2025)](#mapping-filtering-maps)'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[36.4.3 通过迭代器方法映射和过滤 Maps (ES2025)](#mapping-filtering-maps)'
- en: 'We can `.map()` and `.filter()` an Array, but there are no such operations
    for a Map. The solution is:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对数组进行 `.map()` 和 `.filter()` 操作，但对于 Map 没有这样的操作。解决方案是：
- en: Convert the Map to an iterator over [key, value] pairs.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Map 转换为 [键，值] 对的迭代器。
- en: Map or filter the iterator.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Map 或过滤迭代器。
- en: Convert the result back to a Map.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果转换回 Map。
- en: We’ll use the following Map to explore how that works.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下 Map 来探索它是如何工作的。
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Mapping `originalMap`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 映射 `originalMap`：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Filtering `originalMap`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤 `originalMap`：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: What if we can’t use iterator methods? Then we can switch to Array methods,
    by
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不能使用迭代器方法怎么办？那么我们可以通过
- en: replacing `originalMap.entries()`
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换 `originalMap.entries()`
- en: with `Array.from(originalMap)`.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Array.from(originalMap)`。
- en: '[36.5 A few more details about the keys of Maps (advanced)](#a-few-more-details-about-the-keys-of-maps-advanced)'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[36.5 关于 Maps 键的一些更多细节（高级）](#a-few-more-details-about-the-keys-of-maps-advanced)'
- en: 'Any value can be a key, even an object:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 任何值都可以作为键，甚至是一个对象：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[36.5.1 What keys are considered equal?](#map-key-equality)'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[36.5.1 哪些键被认为是相等的？](#map-key-equality)'
- en: Most Map operations need to check whether a value is equal to one of the keys.
    They do so via the internal operation [SameValueZero](https://tc39.es/ecma262/#sec-samevaluezero),
    which works like `===` but considers `NaN` to be equal to itself.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Map 操作都需要检查一个值是否等于键之一。它们通过内部操作 [SameValueZero](https://tc39.es/ecma262/#sec-samevaluezero)
    来这样做，它的工作方式类似于 `===`，但将 `NaN` 视为等于自身。
- en: 'As a consequence, we can use `NaN` as a key in Maps, just like any other value:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以像任何其他值一样在 Maps 中使用 `NaN` 作为键：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Different objects are always considered to be different. That is something that
    can’t be changed (yet – configuring key equality is on TC39’s long-term roadmap).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的对象始终被认为是不同的。这是无法改变的事情（尚无法改变 - 配置键相等性是 TC39 长期路线图上的一个项目）。
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[36.6 Quick reference: `Map`](#quickref-maps)'
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[36.6 快速参考：`Map`](#quickref-maps)'
- en: 'Note: For the sake of conciseness, I’m pretending that all keys have the same
    type `K` and that all values have the same type `V`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了简洁起见，我假设所有键都具有相同的类型 `K`，并且所有值都具有相同的类型 `V`。
- en: '[36.6.1 `new Map()`](#new-map)'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[36.6.1 `new Map()`](#new-map)'
- en: '`new Map(entries?)` ES6'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new Map(entries?)` ES6'
- en: '[PRE28]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we don’t provide the parameter `entries`, then an empty Map is created.
    If we do provide an iterable over [key, value] pairs, then those pairs are added
    as entries to the Map. For example:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们不提供参数 `entries`，则创建一个空 Map。如果我们提供 [键，值] 对的可迭代对象，则将这些对作为条目添加到 Map 中。例如：
- en: '[PRE29]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[36.6.2 `Map.*`](#map)'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[36.6.2 `Map.*`](#map)'
- en: '`Map.groupBy(items, computeGroupKey)` ES2024'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.groupBy(items, computeGroupKey)` ES2024'
- en: '[PRE30]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The callback `computeGroupKey` returns a *group key* for each of the `items`.
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调 `computeGroupKey` 为每个 `items` 返回一个 *分组键*。
- en: 'The result of `Map.groupBy()` is a Map where:'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.groupBy()` 的结果是包含以下内容的 Map：'
- en: The key of each entry is a group key and
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个条目的键是一个分组键，
- en: its value is an Array with all items that have that group key.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其值是一个包含所有具有该分组键的项的数组。
- en: '[PRE31]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[36.6.3 `Map.prototype.*`: handling single entries](#mapprototype-handling-single-entries)'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[36.6.3 `Map.prototype.*`：处理单个条目](#mapprototype-handling-single-entries)'
- en: '`Map.prototype.get(key)` ES6'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.prototype.get(key)` ES6'
- en: Returns the `value` that `key` is mapped to in this Map. If there is no key
    `key` in this Map, `undefined` is returned.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回 `key` 在此 Map 中映射到的 `value`。如果没有在此 Map 中找到键 `key`，则返回 `undefined`。
- en: '[PRE32]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`Map.prototype.set(key, value)` ES6'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.prototype.set(key, value)` ES6'
- en: Maps the given key to the given value.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将给定的键映射到给定的值。
- en: If there is already an entry whose key is `key`, it is updated. Otherwise, a
    new entry is created.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果已经存在一个键为 `key` 的条目，则它将被更新。否则，将创建一个新的条目。
- en: This method returns `this`, which means that we can chain it.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法返回 `this`，这意味着我们可以将其链接。
- en: '[PRE33]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`Map.prototype.has(key)` ES6'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.prototype.has(key)` ES6'
- en: Returns whether the given key exists in this Map.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回给定的键是否存在于此 Map 中。
- en: '[PRE34]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`Map.prototype.delete(key)` ES6'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.prototype.delete(key)` ES6'
- en: If there is an entry whose key is `key`, it is removed and `true` is returned.
    Otherwise, nothing happens and `false` is returned.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果存在一个键为 `key` 的条目，则该条目被移除并返回 `true`。否则，不发生任何操作并返回 `false`。
- en: '[PRE35]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[36.6.4 `Map.prototype`: handling all entries](#mapprototype-handling-all-entries)'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[36.6.4 `Map.prototype`：处理所有条目](#mapprototype-handling-all-entries)'
- en: '`get Map.prototype.size` ES6'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get Map.prototype.size` ES6'
- en: Returns how many entries this Map has.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回此 Map 有多少条目。
- en: '[PRE36]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`Map.prototype.clear()` ES6'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.prototype.clear()` ES6'
- en: Removes all entries from this Map.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从此 Map 中移除所有条目。
- en: '[PRE37]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[36.6.5 `Map.prototype`: iterating and looping](#mapprototype-iterating-and-looping)'
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[36.6.5 `Map.prototype`：迭代和循环](#mapprototype-iterating-and-looping)'
- en: Both iterating and looping happen in the order in which entries were added to
    a Map.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Map 中迭代和循环发生时，顺序与条目添加到 Map 中的顺序一致。
- en: '`Map.prototype.entries()` ES6'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.prototype.entries()` ES6'
- en: Returns an iterable with one [key, value] pair for each entry in this Map. The
    pairs are Arrays of length 2.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回一个包含此 Map 中每个条目的一个 [键，值] 对的可迭代对象。对是长度为 2 的数组。
- en: '[PRE38]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Output:'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE39]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`Map.prototype.forEach(callback, thisArg?)` ES6'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.prototype.forEach(callback, thisArg?)` ES6'
- en: '[PRE40]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The first parameter is a callback that is invoked once for each entry in this
    Map.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是一个回调函数，它为 Map 中的每个条目调用一次。
- en: If `thisArg` is provided, `this` is set to it for each invocation. Otherwise,
    `this` is set to `undefined`.
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提供了 `thisArg`，则对于每次调用，`this` 被设置为它。否则，`this` 被设置为 `undefined`。
- en: '[PRE41]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Output:'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE42]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`Map.prototype.keys()` ES6'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.prototype.keys()` ES6'
- en: Returns an iterable over all keys in this Map.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回一个遍历此 Map 中所有键的可迭代对象。
- en: '[PRE43]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Output:'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE44]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`Map.prototype.values()` ES6'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.prototype.values()` ES6'
- en: Returns an iterable over all values in this Map.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回一个遍历此 Map 中所有值的可迭代对象。
- en: '[PRE45]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Output:'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE46]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`Map.prototype[Symbol.iterator]()` ES6'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.prototype[Symbol.iterator]()` ES6'
- en: The default way of iterating over Maps. Same as `map.entries()`.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 遍历 Maps 的默认方式。与 `map.entries()` 相同。
- en: '[PRE47]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Output:'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE48]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[36.7 FAQ: Maps](#faq-maps)'
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[36.7 FAQ: Maps](#faq-maps)'
- en: '[36.7.1 When should I use a Map, and when should I use an object?](#when-should-i-use-a-map-and-when-should-i-use-an-object)'
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[36.7.1 我应该在何时使用 Map，何时使用对象？](#when-should-i-use-a-map-and-when-should-i-use-an-object)'
- en: 'If we need a dictionary-like data structure with keys that are neither strings
    nor symbols, we have no choice: we must use a Map.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要一个类似字典的数据结构，其键既不是字符串也不是符号，我们别无选择：我们必须使用 Map。
- en: 'If, however, our keys are either strings or symbols, we must decide whether
    or not to use an object. A rough general guideline is:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们的键是字符串或符号，我们必须决定是否使用对象。一个粗略的一般性指南是：
- en: Is there a fixed set of keys (known at development time)?
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有一个固定的键集合（在开发时已知）？
- en: 'Then use an object `obj` and access the values via fixed keys:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后使用一个对象 `obj` 并通过固定的键访问值：
- en: '[PRE49]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Can the set of keys change at runtime?
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键的集合在运行时可以改变吗？
- en: 'Then use a Map `map` and access the values via keys stored in variables:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后使用一个 Map `map` 并通过存储在变量中的键访问值：
- en: '[PRE50]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[36.7.2 When would I use an object as a key in a Map?](#when-would-i-use-an-object-as-a-key-in-a-map)'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[36.7.2 当我应该使用对象作为 Map 的键时？](#when-would-i-use-an-object-as-a-key-in-a-map)'
- en: 'We normally want Map keys to be compared by value (two keys are considered
    equal if they have the same content). That excludes objects. However, there is
    one use case for objects as keys: externally attaching data to objects. But that
    use case is served better by WeakMaps, where entries don’t prevent keys from being
    garbage-collected (for details, see [the next chapter](ch_weakmaps.html#ch_weakmaps)).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常希望 Map 键通过值进行比较（如果两个键的内容相同，则认为它们相等）。这排除了对象。然而，对象作为键有一个用例：将数据外部附加到对象上。但这个用例更适合
    WeakMaps，其中条目不会阻止键被垃圾回收（有关详细信息，请参阅[下一章](ch_weakmaps.html#ch_weakmaps))。
- en: '[36.7.3 Why do Maps preserve the insertion order of entries?](#why-do-maps-preserve-the-insertion-order-of-entries)'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[36.7.3 为什么 Maps 保留条目的插入顺序？](#why-do-maps-preserve-the-insertion-order-of-entries)'
- en: In principle, Maps entries are unordered. The main reason for ordering entries
    is so that operations that list entries, keys, or values are deterministic. That
    helps, for example, with testing.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，Map 条目是无序的。排序条目的主要原因是为了使列出条目、键或值的操作是确定的。这有助于，例如，测试。
- en: '[36.7.4 Why do Maps have a `.size`, while Arrays have a `.length`?](#collection-size-vs-length)'
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[36.7.4 为什么 Maps 有 `.size`，而 Arrays 有 `.length`？](#collection-size-vs-length)'
- en: 'In JavaScript, indexable sequences (such as Arrays and strings) have a `.length`,
    while unindexed collections (such as Maps and Sets) have a `.size`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，可索引序列（如数组和字符串）有 `.length`，而不索引集合（如 Maps 和 Sets）有 `.size`：
- en: '`.length` is based on indices; it is always the highest index plus one.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.length` 基于索引；它始终是最高索引加一。'
- en: '`.size` counts the number of elements in a collection.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.size` 计算集合中元素的数量。'
