- en: 34 Arrays (Array)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 34 数组（数组）
- en: 原文：[https://exploringjs.com/js/book/ch_arrays.html](https://exploringjs.com/js/book/ch_arrays.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/js/book/ch_arrays.html](https://exploringjs.com/js/book/ch_arrays.html)
- en: '[34.1 Cheat sheet: Arrays](#cheat-sheet-arrays)'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.1 速查表：数组](#cheat-sheet-arrays)'
- en: '[34.1.1 Using Arrays](#using-arrays)'
  id: totrans-3
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.1.1 使用数组](#using-arrays)'
- en: '[34.1.2 The most commonly used Array methods](#the-most-commonly-used-array-methods)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.1.2 最常用的数组方法](#the-most-commonly-used-array-methods)'
- en: '[34.2 Ways of using Arrays: fixed layout vs. sequence](#arrays-fixed-layout-vs-sequence)'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.2 使用数组的方式：固定布局与序列](#arrays-fixed-layout-vs-sequence)'
- en: '[34.3 Basic Array operations](#basic-array-operations)'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.3 基本数组操作](#basic-array-operations)'
- en: '[34.3.1 Creating, reading, writing Arrays](#array-literals)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.3.1 创建、读取、写入数组](#array-literals)'
- en: '[34.3.2 The `.length` of an Array](#array-length)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.3.2 数组的 `.length` 属性](#array-length)'
- en: '[34.3.3 Referring to elements via negative indices](#referring-to-elements-via-negative-indices)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.3.3 通过负索引引用元素](#referring-to-elements-via-negative-indices)'
- en: '[34.3.4 Clearing Arrays](#clearing-arrays)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.3.4 清除数组](#clearing-arrays)'
- en: '[34.3.5 Spreading into Array literals](#spreading-into-array-literals)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.3.5 展开到数组字面量中](#spreading-into-array-literals)'
- en: '[34.3.6 Arrays: listing indices and entries](#arrays-listing-indices-and-entries)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.3.6 列出数组的索引和条目](#arrays-listing-indices-and-entries)'
- en: '[34.3.7 Checking if a value is an Array: `Array.isArray()`](#checking-if-a-value-is-an-array-arrayisarray)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.3.7 检查值是否为数组：`Array.isArray()`](#checking-if-a-value-is-an-array-arrayisarray)'
- en: '[34.4 `for-of` and Arrays](#for-of-arrays)'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.4 `for-of` 和数组](#for-of-arrays)'
- en: '[34.4.1 `for-of`: iterating over elements](#forof-iterating-over-elements)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.4.1 `for-of`: 遍历元素](#forof-iterating-over-elements)'
- en: '[34.4.2 `for-of`: iterating over indices](#forof-iterating-over-indices)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.4.2 `for-of`: 遍历索引](#forof-iterating-over-indices)'
- en: '[34.4.3 `for-of`: iterating over [index, element] pairs](#forof-iterating-over-index-element-pairs)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.4.3 `for-of`: 遍历 [索引, 元素] 对](#forof-iterating-over-index-element-pairs)'
- en: '[34.5 Array-like objects](#array-like-objects)'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.5 类似数组的对象](#array-like-objects)'
- en: '[34.6 Converting iterables, iterators and Array-like values to Arrays](#converting-to-array)'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.6 将可迭代对象、迭代器和类似数组值转换为数组](#converting-to-array)'
- en: '[34.6.1 Converting iterables to Arrays via spreading (`...`)](#converting-iterables-to-arrays-via-spreading-)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.6.1 通过展开 (`...`) 将可迭代对象转换为数组](#converting-iterables-to-arrays-via-spreading-)'
- en: '[34.6.2 Converting iterators to Arrays via `.toArray()` ^(ES2025)](#converting-iterators-to-arrays-via-toarray-es2025)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.6.2 通过 `.toArray()` 将迭代器转换为数组（ES2025）](#converting-iterators-to-arrays-via-toarray-es2025)'
- en: '[34.6.3 Converting iterables and Array-like objects to Arrays via `Array.from()`](#Array.from)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.6.3 通过 `Array.from()` 将可迭代对象和类似数组对象转换为数组](#Array.from)'
- en: '[34.7 Copying Arrays](#copying-arrays)'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.7 复制数组](#copying-arrays)'
- en: '[34.8 Creating and filling Arrays with arbitrary lengths](#filling-arrays)'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.8 创建和填充任意长度的数组](#filling-arrays)'
- en: '[34.8.1 Creating an Array and adding elements later](#creating-array-adding-elements-later)'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.8.1 创建数组并在之后添加元素](#creating-array-adding-elements-later)'
- en: '[34.8.2 Creating an Array filled with a primitive value](#creating-array-with-primitives)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.8.2 创建填充原始值的数组](#creating-array-with-primitives)'
- en: '[34.8.3 Creating an Array filled with objects](#creating-array-with-objects)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.8.3 创建填充对象的数组](#creating-array-with-objects)'
- en: '[34.8.4 Creating an Array with a range of integers](#creating-array-with-range-of-integers)'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.8.4 使用整数范围创建数组](#creating-array-with-range-of-integers)'
- en: '[34.8.5 Typed Arrays work well if the elements are all integers or all floats](#typed-arrays-work-well-if-the-elements-are-all-integers-or-all-floats)'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.8.5 如果元素都是整数或浮点数，则类型化数组工作得很好](#typed-arrays-work-well-if-the-elements-are-all-integers-or-all-floats)'
- en: '[34.9 Multidimensional Arrays](#multidimensional-arrays)'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.9 多维数组](#multidimensional-arrays)'
- en: '[34.10 Arrays are actually dictionaries (advanced)](#arrays-are-dictionaries)'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.10 数组实际上是字典（高级）](#arrays-are-dictionaries)'
- en: '[34.10.1 Array indices are (slightly special) property keys](#array-indices)'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.10.1 数组索引是（略微特殊的）属性键](#array-indices)'
- en: '[34.10.2 Arrays can have holes](#array-holes)'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.10.2 数组可以有空洞](#array-holes)'
- en: '[34.11 Destructive vs. non-destructive Array operations](#array-operations-destructive-vs-non-destructive)'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.11 破坏性操作与非破坏性数组操作](#array-operations-destructive-vs-non-destructive)'
- en: '[34.11.1 How to make destructive Array methods non-destructive](#how-to-make-destructive-array-methods-nondestructive)'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.11.1 如何使破坏性数组方法变为非破坏性](#how-to-make-destructive-array-methods-nondestructive)'
- en: '[34.11.2 Non-destructive versions of `.reverse()`, `.sort()`, `.splice()` ^(ES2023)](#nondestructive-versions-of-reverse-sort-splice-es2023)'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.11.2 `.reverse()`, `.sort()`, `.splice()` 的非破坏性版本（ES2023）](#nondestructive-versions-of-reverse-sort-splice-es2023)'
- en: '[34.12 Adding and removing elements at either end of an Array](#adding-and-removing-elements-at-either-end-of-an-array)'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.12 在数组的两端添加和移除元素](#adding-and-removing-elements-at-either-end-of-an-array)'
- en: '[34.12.1 Destructively adding and removing elements at either end of an Array](#array-push-pop-shift-unshift)'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.12.1 在数组的两端破坏性地添加和移除元素](#array-push-pop-shift-unshift)'
- en: '[34.12.2 Non-destructively prepending and appending elements](#nondestructively-prepending-and-appending-elements)'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.12.2 非破坏性地预加和尾加元素](#nondestructively-prepending-and-appending-elements)'
- en: '[34.13 Array methods that accept element callbacks](#array-element-callbacks)'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.13 接受元素回调的数组方法](#array-element-callbacks)'
- en: '[34.14 Transforming with element callbacks: `.map()`, `.filter()`, `.flatMap()`](#transforming-with-element-callbacks-map-filter-flatmap)'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.14 使用元素回调进行转换：`.map()`, `.filter()`, `.flatMap()`](#transforming-with-element-callbacks-map-filter-flatmap)'
- en: '[34.14.1 `.map()`: Each output element is derived from its input element](#map-each-output-element-is-derived-from-its-input-element)'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.14.1 `.map()`: 每个输出元素都由其输入元素派生](#map-each-output-element-is-derived-from-its-input-element)'
- en: '[34.14.2 `.filter()`: Only keep some of the elements](#filter-only-keep-some-of-the-elements)'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.14.2 `.filter()`: 只保留一些元素](#filter-only-keep-some-of-the-elements)'
- en: '[34.14.3 `.flatMap()`: Each input element produces zero or more output elements
    ^(ES2019)](#Array.prototype.flatMap)'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.14.3 `.flatMap()`: 每个输入元素产生零个或多个输出元素^(ES2019)](#Array.prototype.flatMap)'
- en: '[34.15 `.reduce()`: computing a summary for an Array](#Array.prototype.reduce)'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.15 `.reduce()`: 为数组计算摘要](#Array.prototype.reduce)'
- en: '[34.15.1 An overview of how `.reduce()` works](#an-overview-of-how-reduce-works)'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.15.1 `.reduce()`工作概述](#an-overview-of-how-reduce-works)'
- en: '[34.15.2 What happens if we omit `init`?](#what-happens-if-we-omit-init)'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.15.2 如果我们省略`init`会发生什么？](#what-happens-if-we-omit-init)'
- en: '[34.15.3 `.reduceRight()`: the end-to-start version of `.reduce()`](#Array.prototype.reduceRight)'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.15.3 `.reduceRight()`: `.reduce()`的从尾到头的版本](#Array.prototype.reduceRight)'
- en: '[34.16 `.sort()`: sorting Arrays](#Array.prototype.sort)'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.16 `.sort()`: 排序数组](#Array.prototype.sort)'
- en: '[34.16.1 Customizing the sort order](#customizing-array-sorting)'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.16.1 自定义排序顺序](#customizing-array-sorting)'
- en: '[34.16.2 Sorting numbers](#sorting-arrays-with-numbers)'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.16.2 排序数字](#sorting-arrays-with-numbers)'
- en: '[34.16.3 Sorting human-language strings](#sorting-humanlanguage-strings)'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.16.3 排序人类语言字符串](#sorting-humanlanguage-strings)'
- en: '[34.16.4 Sorting objects](#sorting-objects)'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.16.4 排序对象](#sorting-objects)'
- en: '[34.17 Grouping Array elements](#grouping-array-elements)'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.17 分组数组元素](#grouping-array-elements)'
- en: '[34.18 Quick reference: `Array`](#quickref-Array)'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.18 快速参考：`Array`](#quickref-Array)'
- en: '[34.18.1 `new Array()`](#new-array)'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.18.1 `new Array()`](#new-array)'
- en: '[34.18.2 `Array.*`](#array)'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.18.2 `Array.*`](#array)'
- en: '[34.18.3 `Array.prototype.*`: getting, setting and visiting single elements](#arrayprototype-getting-setting-and-visiting-single-elements)'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.18.3 `Array.prototype.*`: 获取、设置和访问单个元素](#arrayprototype-getting-setting-and-visiting-single-elements)'
- en: '[34.18.4 `Array.prototype.*`: keys and values](#arrayprototype-keys-and-values)'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.18.4 `Array.prototype.*`: 键和值](#arrayprototype-keys-and-values)'
- en: '[34.18.5 `Array.prototype.*`: destructively adding or removing elements at
    either end of an Array](#arrayprototype-destructively-adding-or-removing-elements-at-either-end-of-an-array)'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.18.5 `Array.prototype.*`: 在数组的两端破坏性地添加或移除元素](#arrayprototype-destructively-adding-or-removing-elements-at-either-end-of-an-array)'
- en: '[34.18.6 `Array.prototype.*`: combining, extracting and changing sequences
    of elements](#arrayprototype-combining-extracting-and-changing-sequences-of-elements)'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.18.6 `Array.prototype.*`: 合并、提取和更改元素序列](#arrayprototype-combining-extracting-and-changing-sequences-of-elements)'
- en: '[34.18.7 `Array.prototype.*`: searching for elements](#arrayprototype-searching-for-elements)'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.18.7 `Array.prototype.*`: 搜索元素](#arrayprototype-searching-for-elements)'
- en: '[34.18.8 `Array.prototype.*`: filtering and mapping](#arrayprototype-filtering-and-mapping)'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.18.8 `Array.prototype.*`: 过滤和映射](#arrayprototype-filtering-and-mapping)'
- en: '[34.18.9 `Array.prototype.*`: computing summaries](#arrayprototype-computing-summaries)'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.18.9 `Array.prototype.*`: 计算摘要](#arrayprototype-computing-summaries)'
- en: '[34.18.10 `Array.prototype.*`: converting to string](#arrayprototype-converting-to-string)'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.18.10 `Array.prototype.*`: 转换为字符串](#arrayprototype-converting-to-string)'
- en: '[34.18.11 `Array.prototype.*`: sorting and reversing](#arrayprototype-sorting-and-reversing)'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.18.11 `Array.prototype.*`: 排序和反转](#arrayprototype-sorting-and-reversing)'
- en: '[34.18.12 Sources of the quick reference](#sources-of-the-quick-reference)'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[34.18.12 快速参考的来源](#sources-of-the-quick-reference)'
- en: '[34.1 Cheat sheet: Arrays](#cheat-sheet-arrays)'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[34.1 速查表：数组](#cheat-sheet-arrays)'
- en: JavaScript Arrays are a very flexible data structure and used as lists, stacks,
    queues, tuples (e.g. pairs), and more.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 数组是一个非常灵活的数据结构，用作列表、栈、队列、元组（例如，对）等。
- en: Some Array-related operations destructively change Arrays. Others non-destructively
    produce new Arrays with the changes applied to a copy of the original content.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一些与数组相关的操作会破坏性地更改数组。其他非破坏性地产生新的数组，将更改应用于原始内容的副本。
- en: '[34.1.1 Using Arrays](#using-arrays)'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.1.1 使用数组](#using-arrays)'
- en: 'Creating an Array, reading and writing elements:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组，读取和写入元素：
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The length of an Array:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的长度：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Adding elements destructively via `.push()`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `.push()` 非破坏性地添加元素：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Adding elements non-destructively via spreading (`...`):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展（`...`）非破坏性地添加元素：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Looping over elements:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历元素：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Looping over index-value pairs:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历索引-值对：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[34.1.2 The most commonly used Array methods](#the-most-commonly-used-array-methods)'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.1.2 最常用的数组方法](#the-most-commonly-used-array-methods)'
- en: This section demonstrates a few common Array methods. There is [a more comprehensive
    quick reference](#quickref-Array) at the end of this chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本节演示了一些常见的数组方法。在本章末尾有一个更全面的快速参考[Array](#quickref-Array)。
- en: 'Destructively adding or removing an Array element at the start or the end:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始或末尾破坏性地添加或删除数组元素：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finding Array elements:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 查找数组元素：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Transforming Arrays (creating new ones without changing the originals):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 转换数组（创建新的而不改变原始的）：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Copying parts of an Array:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 复制数组的部分：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Concatenating the strings in an Array:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 连接数组中的字符串：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`.sort()` sorts its receiver and returns it (if we don’t want to change the
    receiver, we can use [`.toSorted()`](#qref-Array.prototype.toSorted)):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`.sort()` 对其接收者进行排序并返回它（如果我们不想改变接收者，可以使用 [`.toSorted()`](#qref-Array.prototype.toSorted)）：'
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[34.2 Ways of using Arrays: fixed layout vs. sequence](#arrays-fixed-layout-vs-sequence)'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[34.2 使用数组的方式：固定布局与序列](#arrays-fixed-layout-vs-sequence)'
- en: 'These are the two most common ways of using Arrays in JavaScript:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是两种在JavaScript中使用数组最常见的方式：
- en: 'Fixed-layout Arrays: Used this way, Arrays have a fixed number of indexed elements.
    Each of those elements can have a different type.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定布局数组：以这种方式使用，数组具有固定数量的索引元素。这些元素中的每一个都可以有不同的类型。
- en: 'Sequence Arrays: Used this way, Arrays have a variable number of indexed elements.
    Each of those elements has the same type. Sequence Arrays are very flexible; we
    can use them as (traditional) arrays, stacks, and queues. We’ll see how later.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列数组：以这种方式使用，数组具有可变数量的索引元素。这些元素中的每一个都具有相同的类型。序列数组非常灵活；我们可以将它们用作（传统的）数组、栈和队列。我们将在后面看到。
- en: 'As an example of the difference between the two ways, consider the Array returned
    by `Object.entries()`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 作为两种方式之间差异的例子，考虑由 `Object.entries()` 返回的数组：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It is a sequence of *pairs* – fixed-layout Arrays with a length of two.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一系列 *对* – 长度为二的固定布局数组。
- en: '[34.3 Basic Array operations](#basic-array-operations)'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[34.3 基本数组操作](#basic-array-operations)'
- en: '[34.3.1 Creating, reading, writing Arrays](#array-literals)'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.3.1 创建、读取、写入数组](#array-literals)'
- en: 'The best way to create an Array is via an *Array literal*:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组最佳的方式是通过 *数组字面量*：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The Array literal starts and ends with square brackets `[]`. It creates an
    Array with three *elements*: `''a''`, `''b''`, and `''c''`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 数组字面量以方括号 `[]` 开始和结束。它创建了一个包含三个 *元素* 的数组：`'a'`、`'b'` 和 `'c'`。
- en: 'A comma after the last element is allowed and ignored in an Array literal:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 数组字面量中最后一个元素之后允许并忽略逗号：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To read an Array element, we put an index in square brackets (indices start
    at zero):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取数组元素，我们在方括号中放置一个索引（索引从零开始）：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To change an Array element, we assign to an Array with an index:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改数组元素，我们通过索引分配给数组：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The range of Array indices is 32 bits (excluding the maximum length): [0, 2^(32)−1)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 数组索引的范围是32位（不包括最大长度）：[0, 2^(32)−1)
- en: '[34.3.2 The `.length` of an Array](#array-length)'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.3.2 数组的 `.length`](#array-length)'
- en: Every Array has a property `.length` that can be used to both read and change(!)
    the number of elements in an Array.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数组都有一个属性 `.length`，可以用来读取和更改（！）数组中的元素数量。
- en: 'The length of an Array is always the highest index plus one:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的长度始终是最高索引加一：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we write to the Array at the index of the length, we append an element:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在长度的索引处写入数组，我们将追加一个元素：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we set `.length`, we prune the Array and remove elements:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们设置 `.length`，我们将修剪数组并移除元素：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To (destructively) append an element, we can also use the Array method `.push()`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要（破坏性地）追加一个元素，我们也可以使用数组方法 `.push()`：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Removing empty lines via `.push()`**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![练习图标“exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：通过 `.push()`
    删除空行**'
- en: '`exercises/arrays/remove_empty_lines_push_test.mjs`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/arrays/remove_empty_lines_push_test.mjs`'
- en: '[34.3.3 Referring to elements via negative indices](#referring-to-elements-via-negative-indices)'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.3.3   通过负索引引用元素](#referring-to-elements-via-negative-indices)'
- en: 'Most Array methods support negative indices. If an index is negative, it is
    added to the length of an Array to produce a usable index. Therefore, the following
    two invocations of `.slice()` are equivalent: They both copy `arr` starting at
    the last element.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数组方法支持负索引。如果索引是负数，则将其添加到数组的长度中，以产生一个可用的索引。因此，以下两个 `.slice()` 调用是等效的：它们都从
    `arr` 的最后一个元素开始复制。
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[34.3.3.1 `.at()`: reading single elements (supports negative indices) ^(ES2022)](#Array.prototype.at)'
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[34.3.3.1   `.at()`：读取单个元素（支持负索引）^(ES2022)](#Array.prototype.at)'
- en: 'The Array method `.at()` returns the element at a given index. It supports
    positive and negative indices (`-1` refers to the last element, `-2` refers to
    the second-last element, etc.):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 数组方法 `.at()` 返回给定索引处的元素。它支持正索引和负索引（`-1` 指的是最后一个元素，`-2` 指的是倒数第二个元素等）：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In contrast, the bracket operator `[]` does not support negative indices (and
    can’t be changed because that would break existing code). It interprets them as
    keys of non-element properties:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，方括号运算符 `[]` 不支持负索引（并且不能更改，因为这会破坏现有代码）。它将它们解释为非元素属性的键：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[34.3.4 Clearing Arrays](#clearing-arrays)'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.3.4   清除数组](#clearing-arrays)'
- en: 'We can clear an Array by setting its `.length` to zero:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 `.length` 设置为零来清除数组：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can also assign a new empty Array to the variable storing the Array:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将一个新的空数组赋值给存储数组的变量：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The latter approach has the advantage of not affecting other locations that
    point to the same Array. If, however, we do want to reset a shared Array for everyone,
    then we need the former approach.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 后者方法的优势在于不会影响指向同一数组的其他位置。如果我们确实想为每个人重置共享的数组，则需要使用前者方法。
- en: '[34.3.5 Spreading into Array literals](#spreading-into-array-literals)'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.3.5   展开到数组字面量](#spreading-into-array-literals)'
- en: 'Inside an Array literal, a *spread element* consists of three dots (`...`)
    followed by an expression. It results in the expression being evaluated and then
    iterated over. Each iterated value becomes an additional Array element – for example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组字面量内部，一个 *展开元素* 由三个点 (`...`) 后跟一个表达式组成。它会导致表达式被评估然后迭代。每个迭代的值都成为额外的数组元素 –
    例如：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That means we can convert any iterable to an Array:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以将任何可迭代对象转换为数组：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since Arrays are iterable, we can use spreading to copy them:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组是可迭代的，我们可以使用展开来复制它们：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Spreading is also convenient for concatenating Arrays (and other iterables)
    into Arrays:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 展开对于将数组（和其他可迭代对象）连接到数组中也非常方便：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Due to spreading using iteration, it only works if the value is iterable:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于迭代时的展开，它仅在值是可迭代的时才有效：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[34.3.6 Arrays: listing indices and entries](#arrays-listing-indices-and-entries)'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.3.6   数组：列出索引和条目](#arrays-listing-indices-and-entries)'
- en: 'Method `.keys()` lists the indices of an Array:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `.keys()` 列出数组的索引：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`.keys()` returns an iterator. In line A, we convert that iterator to an Array.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`.keys()` 返回一个迭代器。在行 A 中，我们将该迭代器转换为数组。'
- en: 'Listing Array indices is different from listing properties. The former produces
    numbers; the latter produces stringified numbers (in addition to non-index property
    keys):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列出数组索引与列出属性不同。前者产生数字；后者产生字符串化的数字（以及非索引属性键）：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice that the object property `arr.prop` shows up in the result.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到对象属性 `arr.prop` 出现在结果中。
- en: 'Method `.entries()` lists the contents of an Array as [index, element] pairs:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `.entries()` 列出数组的元素内容，以 [索引, 元素] 对的形式：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`Object.entries()` lists [property key, property value] pairs:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.entries()` 列出 [属性键，属性值] 对：'
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Once again we see `arr.prop` in the result.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次在结果中看到 `arr.prop`。
- en: '[34.3.7 Checking if a value is an Array: `Array.isArray()`](#checking-if-a-value-is-an-array-arrayisarray)'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.3.7   检查值是否为数组：`Array.isArray()`](#checking-if-a-value-is-an-array-arrayisarray)'
- en: '`Array.isArray()` checks if a value is an Array:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.isArray()` 检查一个值是否为数组：'
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can also use `instanceof`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `instanceof`：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'However, `instanceof` has one downside: It doesn’t work if a value comes from
    another *realm*. Roughly, a realm is an instance of JavaScript’s global scope.
    Some realms are isolated from each other (e.g., [Web Workers](ch_async-js.html#web-workers)
    in browsers), but there are also realms between which we can move data – for example,
    same-origin iframes in browsers. `x instanceof Array` checks the prototype chain
    of `x` and therefore returns `false` if `x` is an Array from another realm.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`instanceof` 有一个缺点：如果值来自另一个 *领域*，则它不起作用。大致来说，领域是 JavaScript 全局作用域的一个实例。有些领域是相互隔离的（例如，浏览器中的
    [Web Workers](ch_async-js.html#web-workers)），但也有一些领域之间可以移动数据——例如，浏览器中的同源 iframe。`x
    instanceof Array` 检查 `x` 的原型链，因此如果 `x` 是来自另一个领域的数组，则返回 `false`。
- en: '`typeof` considers Arrays to be objects:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof` 将数组视为对象：'
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[34.4 `for-of` and Arrays](#for-of-arrays)'
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[34.4 `for-of` 和数组](#for-of-arrays)'
- en: We have already encountered the `for-of` loop earlier in this book. This section
    briefly recaps how to use it for Arrays.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面已经遇到了 `for-of` 循环。本节简要回顾了如何使用它来遍历数组。
- en: '[34.4.1 `for-of`: iterating over elements](#forof-iterating-over-elements)'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.4.1 `for-of`：遍历元素](#forof-iterating-over-elements)'
- en: 'The following `for-of` loop iterates over the elements of an Array:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `for-of` 循环遍历数组的元素：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Output:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[34.4.2 `for-of`: iterating over indices](#forof-iterating-over-indices)'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.4.2 `for-of`：遍历索引](#forof-iterating-over-indices)'
- en: 'This `for-of` loop iterates over the indices of an Array:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `for-of` 循环遍历数组的索引：
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Output:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[34.4.3 `for-of`: iterating over [index, element] pairs](#forof-iterating-over-index-element-pairs)'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.4.3 `for-of`：遍历 `[索引, 元素]` 对](#forof-iterating-over-index-element-pairs)'
- en: The following `for-of` loop iterates over [index, element] pairs. Destructuring
    (described [later](ch_destructuring.html#ch_destructuring)), gives us convenient
    syntax for setting up `index` and `element` in the head of `for-of`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `for-of` 循环遍历 `[索引, 元素]` 对。解构（将在 [后面](ch_destructuring.html#ch_destructuring)
    描述），为我们提供了在 `for-of` 循环头部设置 `索引` 和 `元素` 的便捷语法。
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Output:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[34.5 Array-like objects](#array-like-objects)'
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[34.5 类似数组的对象](#array-like-objects)'
- en: 'Some operations that work with Arrays require only the bare minimum: values
    must only be *Array-like*. An Array-like value is an object with the following
    properties:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一些与数组一起工作的操作只需要最基本的内容：值必须是 *类似数组的*。类似数组的值是一个具有以下属性的对象：
- en: '`.length`: holds the length of the Array-like object. If this property is missing,
    the value `0` is used.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.length`：包含类似数组的对象的长度。如果此属性不存在，则使用值 `0`。'
- en: '`[0]`: holds the element at index 0 (etc.). Note that if we use numbers as
    property names, they are always coerced to strings. Therefore, `[0]` retrieves
    the value of the property whose key is `''0''`.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[0]`：包含索引 0 处的元素（等等）。注意，如果我们使用数字作为属性名，它们总是被强制转换为字符串。因此，`[0]` 获取键为 `''0''`
    的属性的值。'
- en: 'For example, `Array.from()` accepts Array-like objects and converts them to
    Arrays:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Array.from()` 接受类似数组的对象并将它们转换为数组：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The TypeScript interface for Array-like objects is:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 中类似数组的对象的接口是：
- en: '[PRE47]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **Array-like
    objects are relatively rare in modern JavaScript**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“详情”](../Images/38ba63de820aae6f94a019538ae0f222.png) **类似数组的对象在现代 JavaScript
    中相对较少**'
- en: Array-like objects used to be more common before ES6; now we don’t see them
    very often.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 之前，类似数组的对象更为常见；现在我们很少看到它们。
- en: '[34.6 Converting iterables, iterators and Array-like values to Arrays](#converting-to-array)'
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[34.6 将可迭代对象、迭代器和类似数组的值转换为数组](#converting-to-array)'
- en: 'In this section we explore how we can convert various values to Array:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何将各种值转换为数组：
- en: Converting iterables to Arrays via spreading (`...`)
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过展开（`...`）将可迭代对象转换为数组
- en: Converting iterators to Arrays via `.toArray()`
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `.toArray()` 将迭代器转换为数组
- en: Converting iterables and Array-like objects to Arrays via `Array.from()`
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `Array.from()` 将可迭代对象和类似数组的对象转换为数组
- en: '[34.6.1 Converting iterables to Arrays via spreading (`...`)](#converting-iterables-to-arrays-via-spreading-)'
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.6.1 通过展开（`...`）将可迭代对象转换为数组](#converting-iterables-to-arrays-via-spreading-)'
- en: 'Inside an Array literal, spreading via `...` converts any iterable object into
    a series of Array elements. For example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组字面量内部，通过 `...` 展开，可以将任何可迭代对象转换为一系列数组元素。例如：
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[34.6.2 Converting iterators to Arrays via `.toArray()` ^(ES2025)](#converting-iterators-to-arrays-via-toarray-es2025)'
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.6.2 通过 `.toArray()` 将迭代器转换为数组（ES2025）](#converting-iterators-to-arrays-via-toarray-es2025)'
- en: 'If we have an iterator, we can use method `.toArray()` to store its values
    in an Array:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个迭代器，我们可以使用方法 `.toArray()` 将其值存储在数组中：
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Instead of `Iterator.from()` we can also use a method that returns an iterator
    (such as `.keys()`, `.values()` and `.entries()`):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Iterator.from()`，我们还可以使用返回迭代器的方法（例如 `.keys()`、`.values()` 和 `.entries()`）：
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[34.6.3 Converting iterables and Array-like objects to Arrays via `Array.from()`](#Array.from)'
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.6.3 通过 `Array.from()` 将可迭代和类似数组的对象转换为数组](#Array.from)'
- en: '`Array.from()` can be used in two modes.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.from()` 可以在两种模式下使用。'
- en: '[34.6.3.1 Mode 1 of `Array.from()`: converting](#mode-1-of-arrayfrom-converting)'
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[34.6.3.1 `Array.from()` 的第一种模式：转换](#mode-1-of-arrayfrom-converting)'
- en: 'The first mode has the following type signature:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种模式具有以下类型签名：
- en: '[PRE51]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Interface `Iterable` is shown [in the chapter on synchronous iteration](ch_sync-iteration.html#iterable-iterator-iteratorresult).
    Interface `ArrayLike` appeared [earlier in this chapter](#array-like-objects).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接口 `Iterable` 在[同步迭代章节](ch_sync-iteration.html#iterable-iterator-iteratorresult)中展示。接口
    `ArrayLike` 在本章[较早的部分](#array-like-objects)出现。
- en: 'With a single parameter, `Array.from()` converts anything iterable or Array-like
    to an Array:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个参数，`Array.from()` 将任何可迭代或类似数组的对象转换为数组：
- en: '[PRE52]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[34.6.3.2 Mode 2 of `Array.from()`: converting and mapping](#mode-2-of-arrayfrom-converting-and-mapping)'
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[34.6.3.2 `Array.from()` 的第二种模式：转换和映射](#mode-2-of-arrayfrom-converting-and-mapping)'
- en: 'The second mode of `Array.from()` involves two parameters:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.from()` 的第二种模式涉及两个参数：'
- en: '[PRE53]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In this mode, `Array.from()` does several things:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模式下，`Array.from()` 做了几件事情：
- en: It iterates over `iterable`.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它遍历 `iterable`。
- en: It calls `mapFunc` with each iterated value. The optional parameter `thisArg`
    specifies a `this` for `mapFunc`.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用每个迭代的值调用 `mapFunc`。可选参数 `thisArg` 指定了 `mapFunc` 的 `this`。
- en: It applies `mapFunc` to each iterated value.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将 `mapFunc` 应用到每个迭代的值上。
- en: It collects the results in a new Array and returns it.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将结果收集到一个新数组中并返回它。
- en: 'In other words: we are going from an iterable with elements of type `T` to
    an Array with elements of type `U`.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：我们从一个元素类型为 `T` 的可迭代对象转换到一个元素类型为 `U` 的数组。
- en: 'This is an example:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE54]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[34.7 Copying Arrays](#copying-arrays)'
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[34.7 复制数组](#copying-arrays)'
- en: 'The following code shows five ways of copying the Array `arr`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了复制数组 `arr` 的五种方式：
- en: '[PRE55]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Only `structuredClone()` produces a *deep copy*. In each other case, the copy
    is *shallow*: It contains copies of the [index, element] entries but the elements
    themselves are shared with the original Array. For more information, including
    the limitations of `structuredClone()`, see [“Copying objects: spreading vs. `Object.assign()`
    vs. `structuredClone()`” (§30.5)](ch_objects.html#copying-objects).'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 只有 `structuredClone()` 产生一个 *深拷贝*。在其他情况下，拷贝是 *浅拷贝*：它包含 [索引，元素] 条目的副本，但元素本身与原始数组共享。有关更多信息，包括
    `structuredClone()` 的限制，请参阅[“复制对象：展开与 `Object.assign()` 与 `structuredClone()`”（§30.5）](ch_objects.html#copying-objects)。
- en: '[34.8 Creating and filling Arrays with arbitrary lengths](#filling-arrays)'
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[34.8 创建和填充任意长度的数组](#filling-arrays)'
- en: 'The best way of creating an Array is via an Array literal. However, we can’t
    always use one: The Array may be too large, we may not know its length during
    development, or we may want to keep its length flexible. Then I recommend the
    following techniques for creating, and possibly filling, Arrays.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组的最佳方式是通过数组字面量。然而，我们并不总是可以使用它：数组可能太大，我们在开发过程中可能不知道它的长度，或者我们可能希望保持其长度灵活。那么，我推荐以下技术来创建，并可能填充，数组。
- en: '[34.8.1 Creating an Array and adding elements later](#creating-array-adding-elements-later)'
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.8.1 创建数组并在之后添加元素](#creating-array-adding-elements-later)'
- en: 'The most common technique for creating an Array and adding elements later,
    is to start with an empty Array and push values into it:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组并在之后添加元素的最常见技术是先从一个空数组开始，然后将值推入其中：
- en: '[PRE56]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[34.8.2 Creating an Array filled with a primitive value](#creating-array-with-primitives)'
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.8.2 创建填充了原始值的数组](#creating-array-with-primitives)'
- en: 'The following code creates an Array that is filled with a primitive value:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个填充了原始值的数组：
- en: '[PRE57]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`.fill()` replaces each Array element or hole with a given value. We use it
    to fill an Array that has 3 holes:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`.fill()` 将每个数组元素或空位替换为给定的值。我们用它来填充一个有 3 个空位的数组：'
- en: '[PRE58]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that the result has [three *holes* (empty slots)](#array-holes) – the last
    comma in an Array literal is always ignored.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，结果有三个 *空位*（空槽）- 数组字面量中的最后一个逗号总是被忽略。
- en: '[34.8.3 Creating an Array filled with objects](#creating-array-with-objects)'
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.8.3 创建填充了对象的数组](#creating-array-with-objects)'
- en: 'If we use `.fill()` with an object, then each Array element will refer to this
    same single object:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `.fill()` 与一个对象，那么每个数组元素都将引用这个相同的单个对象：
- en: '[PRE59]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'How can we fix this? We can use [`Array.from()`](#Array.from):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们该如何解决这个问题？我们可以使用 `Array.from()`：
- en: '[PRE60]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Calling `Array.from()` with two arguments:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个参数调用 `Array.from()`：
- en: extracts the elements of the first argument (which must be iterable or Array-like),
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取第一个参数（必须是可迭代的或类似数组的）的元素，
- en: maps them via the callback in the second argument and
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过第二个参数中的回调函数映射它们，
- en: returns the result in an Array.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果返回为数组。
- en: In contrast to `.fill()`, which reuses the same object multiple times, the previous
    code creates a new object for each element.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `.fill()` 不同，它多次重用同一个对象，之前的代码为每个元素创建了一个新对象。
- en: 'Could we have used `.map()` in this case? Unfortunately not because `.map()`
    ignores but preserves holes (whereas `Array.from()` treats them as `undefined`
    elements):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们能否使用 `.map()`？不幸的是，不能，因为 `.map()` 忽略但保留空位（而 `Array.from()` 将它们视为 `undefined`
    元素）：
- en: '[PRE61]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'For large sizes, the temporary Array in the first argument can consume quite
    a bit of memory. The following approach doesn’t have this downside but is less
    self-descriptive:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较大的尺寸，第一个参数中的临时数组可能会消耗相当多的内存。以下方法没有这个缺点，但描述性较差：
- en: '[PRE62]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Instead of a temporary Array, we are using a temporary [Array-like object](#array-like-objects).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是使用临时数组，而是使用一个临时的 [类似数组的对象](#array-like-objects)。
- en: '[34.8.4 Creating an Array with a range of integers](#creating-array-with-range-of-integers)'
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.8.4 使用一系列整数创建数组](#creating-array-with-range-of-integers)'
- en: 'To create an Array with a range of integers, we use `Array.from()` similarly
    to how we did in the previous subsection:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个包含一系列整数的数组，我们使用 `Array.from()` 的方式与之前小节中的用法类似：
- en: '[PRE63]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here is an alternative, slightly hacky technique for creating integer ranges
    that start at zero:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个创建从零开始的整数范围的替代方法，稍微有点技巧性：
- en: '[PRE64]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This works because `.keys()` treats [*holes*](#array-holes) like `undefined`
    elements and lists their indices.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为 `.keys()` 将 [*空位*](#array-holes) 当作 `undefined` 元素处理，并列出它们的索引。
- en: '[34.8.5 Typed Arrays work well if the elements are all integers or all floats](#typed-arrays-work-well-if-the-elements-are-all-integers-or-all-floats)'
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.8.5 如果元素都是整数或浮点数，则类型化数组工作得很好](#typed-arrays-work-well-if-the-elements-are-all-integers-or-all-floats)'
- en: When dealing with Arrays of integers or floats, we should consider [*Typed Arrays*](ch_typed-arrays.html#ch_typed-arrays),
    which were created for this purpose.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理整数或浮点数数组时，我们应该考虑 [*类型化数组*](ch_typed-arrays.html#ch_typed-arrays)，它们是为了这个目的而创建的。
- en: '[34.9 Multidimensional Arrays](#multidimensional-arrays)'
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[34.9 多维数组](#multidimensional-arrays)'
- en: 'JavaScript does not have real multidimensional Arrays; we need to resort to
    Arrays whose elements are Arrays:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 没有真正的多维数组；我们需要求助于元素也是数组的数组：
- en: '[PRE65]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[34.10 Arrays are actually dictionaries (advanced)](#arrays-are-dictionaries)'
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[34.10 数组实际上是字典（高级）](#arrays-are-dictionaries)'
- en: 'In this section, we examine how exactly Arrays store their elements: in properties.
    We usually don’t need to know that but it helps with understanding a few rarer
    Array phenomena.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们考察数组如何确切地存储它们的元素：在属性中。我们通常不需要知道这一点，但它有助于理解一些较少见的数组现象。
- en: '[34.10.1 Array indices are (slightly special) property keys](#array-indices)'
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.10.1 数组索引是（稍微特殊一点的）属性键](#array-indices)'
- en: 'You’d think that Array elements are special because we are accessing them via
    numbers. But the square brackets operator `[]` for doing so is the same operator
    that is used for accessing properties. It coerces any non-symbol value to a string.
    Therefore, Array elements are (almost) normal properties (line A) and it doesn’t
    matter if we use numbers or strings as indices (line B and line C):'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为数组元素是特殊的，因为我们通过数字访问它们。但用于这样做的方括号运算符 `[]` 与用于访问属性的运算符相同。它将任何非符号值强制转换为字符串。因此，数组元素（几乎）是正常属性（行
    A），我们使用数字或字符串作为索引（行 B 和行 C）并没有关系：
- en: '[PRE66]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Property keys (strings!) that are used for Array elements are called [*indices*](https://tc39.es/ecma262/#integer-index).
    A string `str` is an index if converting it to a 32-bit unsigned integer and back
    results in the original value. Written as a formula:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 用于数组元素的属性键（字符串！）被称为 [*索引*](https://tc39.es/ecma262/#integer-index)。一个字符串 `str`
    是索引，如果将其转换为 32 位无符号整数再转换回来，结果仍然是原始值。用公式表示：
- en: '[PRE67]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[34.10.1.1 Internally, JavaScript engines optimize how Arrays are managed](#internally-javascript-engines-optimize-how-arrays-are-managed)'
  id: totrans-285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[34.10.1.1 内部，JavaScript 引擎优化了数组的管理方式](#internally-javascript-engines-optimize-how-arrays-are-managed)'
- en: When using JavaScript and in the ECMAScript specification, Array elements are
    properties and Array indices are string-valued property keys.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 JavaScript 和 ECMAScript 规范时，数组元素是属性，数组索引是字符串值属性键。
- en: 'However, internally, virtually all JavaScript engines optimize how Arrays are
    managed: They store their elements sequentially and used indices as numeric offsets.
    Engines may switch to a more dictionary-like representation if the elements of
    an Array are not contiguous – if there are holes between them. More on holes in
    Arrays soon.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在内部，几乎所有的 JavaScript 引擎都优化了数组的管理方式：它们按顺序存储元素，并使用索引作为数字偏移量。如果数组的元素不是连续的，引擎可能会切换到更类似字典的表示形式
    – 如果它们之间有空位。关于数组中空位的更多内容将在后面介绍。
- en: '[34.10.1.2 Listing indices](#listing-indices)'
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[34.10.1.2 列出索引](#listing-indices)'
- en: 'When listing property keys, [indices are treated specially](ch_objects.html#order-of-properties)
    – they always come first and are sorted like numbers (`''2''` comes before `''10''`):'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当列出属性键时，[索引被特别处理](ch_objects.html#order-of-properties) – 它们总是排在最前面，并且像数字一样排序（`'2'`
    在 `'10'` 之前）：
- en: '[PRE68]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Note that `.keys()` and `.entries()` treat Array indices as numbers and ignore
    non-index properties:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`.keys()` 和 `.entries()` 将数组索引视为数字，并忽略非索引属性：
- en: '[PRE69]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We used [`Array.from()`](#Array.from) to convert the iterables returned by `.keys()`
    and `.entries()` to Arrays.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `Array.from()` 来将 `.keys()` 和 `.entries()` 返回的可迭代对象转换为数组。
- en: '[34.10.2 Arrays can have holes](#array-holes)'
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.10.2 数组可以有空位](#array-holes)'
- en: 'We distinguish two kinds of Arrays in JavaScript:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，我们区分两种数组：
- en: An Array `arr` is *dense* if all indices `i`, with 0 ≤ `i` < `arr.length`, exist.
    That is, the indices form a contiguous range.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果所有索引 `i`（其中 0 ≤ `i` < `arr.length`）都存在，数组 `arr` 就是 *密集的*。也就是说，索引形成一个连续的范围。
- en: An Array is *sparse* if the range of indices has *holes* in it. That is, some
    indices are missing.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果索引范围中有空位，数组就是 *稀疏的*。也就是说，某些索引缺失。
- en: Arrays can be sparse in JavaScript because Arrays are actually dictionaries
    from indices to values.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组实际上是索引到值的字典，JavaScript 中的数组可以是稀疏的。
- en: '![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Recommendation:
    avoid holes**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“提示”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **建议：避免空位**'
- en: 'So far, we have only seen dense Arrays and it’s indeed recommended to avoid
    holes: They make our code more complicated and are not handled consistently by
    Array methods. Additionally, JavaScript engines optimize dense Arrays, making
    them faster.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了密集数组，并且确实建议避免空位：它们使我们的代码更复杂，并且数组方法处理它们的方式并不一致。此外，JavaScript 引擎优化密集数组，使它们更快。
- en: '[34.10.2.1 Creating Array holes](#creating-array-holes)'
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[34.10.2.1 创建数组空位](#creating-array-holes)'
- en: 'We can create holes by skipping indices when assigning elements:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在分配元素时跳过索引来创建空位：
- en: '[PRE70]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In line A, we are using `Object.keys()` because `arr.keys()` treats holes as
    if they were `undefined` elements and does not reveal them.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 A 中，我们使用 `Object.keys()`，因为 `arr.keys()` 将空位视为 `undefined` 元素，并且不会揭示它们。
- en: 'Another way of creating holes is to skip elements in Array literals:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 创建空位的另一种方法是省略数组字面量中的元素：
- en: '[PRE71]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We can also add holes at the end by increasing `.length`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过增加 `.length` 来在末尾添加空位：
- en: '[PRE72]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Deleting Array elements creates holes, too:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 删除数组元素也会创建空位：
- en: '[PRE73]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[34.10.2.2 How do Array operations treat holes?](#how-do-array-operations-treat-holes)'
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[34.10.2.2 数组操作如何处理空位？](#how-do-array-operations-treat-holes)'
- en: Alas, there are many different ways in which Array operations treat holes.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，数组操作处理空位的方式有很多种。
- en: 'Some Array operations remove holes:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数组操作会移除空位：
- en: '[PRE74]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Some Array operations ignore holes:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数组操作会忽略空位：
- en: '[PRE75]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Some Array operations ignore but preserve holes:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数组操作忽略但保留空位：
- en: '[PRE76]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Some Array operations treat holes as `undefined` elements:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数组操作将空位视为 `undefined` 元素：
- en: '[PRE77]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '`Object.keys()` works differently than `.keys()` (strings vs. numbers, holes
    don’t have keys):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.keys()` 的工作方式与 `.keys()` 不同（字符串 vs. 数字，空位没有键）：'
- en: '[PRE78]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: There is no common rule to remember here. If it ever matters how an Array operation
    treats holes, the best approach is to do a quick test in a console.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有共同的规则可以记住。如果某个数组操作如何处理空位很重要，最佳方法是快速在控制台中测试。
- en: '[34.11 Destructive vs. non-destructive Array operations](#array-operations-destructive-vs-non-destructive)'
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[34.11 数组操作：破坏性 vs. 非破坏性](#array-operations-destructive-vs-non-destructive)'
- en: 'Some Array operations are *destructive*: They change the Array they operate
    on – e.g., setting an element:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数组操作是 *破坏性的*：它们会改变它们操作的数组 – 例如，设置一个元素：
- en: '[PRE79]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Other Array operations are *non-destructive*: They produce new Arrays that
    contain the desired changes and don’t touch the originals – e.g., method `.with()`
    is the non-destructive version of setting elements:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 其他数组操作是非破坏性的：它们产生包含所需更改的新数组，而不触及原始数组 – 例如，方法 `.with()` 是设置元素的不可破坏版本：
- en: '[PRE80]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[34.11.1 How to make destructive Array methods non-destructive](#how-to-make-destructive-array-methods-nondestructive)'
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.11.1 如何使破坏性数组方法变为非破坏性](#how-to-make-destructive-array-methods-nondestructive)'
- en: 'These are three common destructive Array methods:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是三个常见的破坏性数组方法：
- en: '`.reverse()`'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.reverse()`'
- en: '`.sort()`'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.sort()`'
- en: '`.splice()`'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.splice()`'
- en: 'We’ll get to [`.sort()`](#Array.prototype.sort) and [`.splice()`](#qref-Array.prototype.splice)
    later in this chapter. `.reverse()` rearranges an Array so that the order of its
    elements is reversed: The element that was previously last now comes first; the
    second-last element comes second; etc.:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论 [`.sort()`](#Array.prototype.sort) 和 [`.splice()`](#qref-Array.prototype.splice)。`.reverse()`
    重新排列数组，使其元素的顺序颠倒：之前最后的元素现在排在第一位；倒数第二个元素排在第二位；等等：
- en: '[PRE81]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'To prevent a destructive method from changing an Array, we can make a copy
    before using it – e.g.:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止破坏性方法改变数组，我们可以在使用之前创建一个副本 - 例如：
- en: '[PRE82]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Another option is to use the non-destructive version of a destructive method.
    That’s what we’ll explore next.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用破坏性方法的非破坏性版本。这正是我们将要探讨的。
- en: '[34.11.2 Non-destructive versions of `.reverse()`, `.sort()`, `.splice()` ^(ES2023)](#nondestructive-versions-of-reverse-sort-splice-es2023)'
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.11.2 `.reverse()`, `.sort()`, `.splice()` 的非破坏性版本 (ES2023)](#nondestructive-versions-of-reverse-sort-splice-es2023)'
- en: 'These are the non-destructive versions of the destructive Array methods `.reverse()`,
    `.sort()` and `.splice()`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是非破坏性版本的破坏性数组方法 `.reverse()`, `.sort()` 和 `.splice()`：
- en: '`.toReversed(): Array`'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.toReversed(): Array`'
- en: '`.toSorted(compareFn): Array`'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.toSorted(compareFn): Array`'
- en: '`.toSpliced(start, deleteCount, ...items): Array`'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.toSpliced(start, deleteCount, ...items): Array`'
- en: 'We have used `.reverse()` in the previous subsection. Its non-destructive version
    is used like this:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的小节中使用了 `.reverse()`。它的非破坏性版本的使用方式如下：
- en: '[PRE83]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[34.12 Adding and removing elements at either end of an Array](#adding-and-removing-elements-at-either-end-of-an-array)'
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[34.12 在数组两端添加和删除元素](#adding-and-removing-elements-at-either-end-of-an-array)'
- en: '[34.12.1 Destructively adding and removing elements at either end of an Array](#array-push-pop-shift-unshift)'
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.12.1 破坏性地在数组两端添加和删除元素](#array-push-pop-shift-unshift)'
- en: JavaScript’s `Array` is quite flexible and more like a combination of array,
    stack, and queue. Let’s explore ways of destructively adding and removing Array
    elements.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的 `Array` 非常灵活，更像是数组、栈和队列的组合。让我们探讨破坏性地添加和删除数组元素的方法。
- en: '`.push()` adds elements at the end of an Array:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`.push()` 在数组的末尾添加元素：'
- en: '[PRE84]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[Spread arguments (`...`)](ch_callables.html#spread-arguments) are a feature
    of function calls. In line A, we used it to push an Array.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '[展开参数 (`...`)](ch_callables.html#spread-arguments) 是函数调用中的一个特性。在行 A 中，我们使用它来推入一个数组。'
- en: '`.pop()` is the inverse of `.push()` and removes elements at the end of an
    Array:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`.pop()` 是 `.push()` 的逆操作，并从数组的末尾删除元素：'
- en: '[PRE85]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '`.shift()` removes elements at the beginning of an Array:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`.shift()` 从数组的开头删除元素：'
- en: '[PRE86]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '`.unshift()` is the inverse of `.shift()` and adds element at the beginning
    of an Array:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`.unshift()` 是 `.shift()` 的逆操作，并在数组的开头添加元素：'
- en: '[PRE87]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Tip: remembering
    the functionality of `push`, `pop`, `shift` and `unshift`**'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“提示”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **提示：记住 `push`、`pop`、`shift`
    和 `unshift` 的功能**'
- en: 'My recommendation is to focus on remembering the following two methods:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是专注于记住以下两个方法：
- en: '`.push()` is the most frequently used of the four methods. One common use case
    is to assemble an output Array: We first push the element at index 0; then the
    element at index 1; etc.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.push()` 是这四种方法中最常用的。一个常见的用例是组装输出数组：我们首先将索引 0 的元素推入；然后是索引 1 的元素；等等。'
- en: '`.shift()` can be used to consume the elements of an Array: The first time
    we shift, we get the element at index 0; then the element at index 1; etc.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.shift()` 可以用来消耗数组的元素：第一次 shift，我们得到索引 0 的元素；然后是索引 1 的元素；等等。'
- en: The remaining two methods, `pop` and `unshift`, are inverses of these two methods.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的两个方法 `pop` 和 `unshift` 是这两个方法的逆操作。
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Implementing a queue via an Array**'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“练习”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：通过数组实现队列**'
- en: '`exercises/arrays/queue_via_array_test.mjs`'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/arrays/queue_via_array_test.mjs`'
- en: '[34.12.2 Non-destructively prepending and appending elements](#nondestructively-prepending-and-appending-elements)'
  id: totrans-365
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.12.2 非破坏性地在数组两端添加和删除元素](#nondestructively-prepending-and-appending-elements)'
- en: '[Spread elements (`...`)](#spreading-into-array-literals) are a feature of
    Array literals. In this section, we’ll use it to non-destructively prepend and
    append elements to Arrays.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[展开元素 (`...`)](#spreading-into-array-literals) 是数组字面量的一项特性。在本节中，我们将使用它来非破坏性地向数组前缀和后缀添加元素。'
- en: 'Non-destructive prepending:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 非破坏性前缀：
- en: '[PRE88]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Non-destructive appending:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 非破坏性追加：
- en: '[PRE89]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[34.13 Array methods that accept element callbacks](#array-element-callbacks)'
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[34.13 接受元素回调的数组方法](#array-element-callbacks)'
- en: 'The following Array methods accept callbacks to which they feed Array elements:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 以下数组方法接受回调函数，并将数组元素传递给它们：
- en: 'Finding:'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找：
- en: '`.find`'
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.find`'
- en: '`.findLast`'
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.findLast`'
- en: '`.findIndex`'
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.findIndex`'
- en: '`.findLastIndex`'
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.findLastIndex`'
- en: 'Transforming:'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换：
- en: '`.map`'
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.map`'
- en: '`.flatMap`'
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.flatMap`'
- en: '`.filter`'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.filter`'
- en: 'Computing summaries of Arrays:'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算数组的摘要：
- en: '`.every`'
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.every`'
- en: '`.some`'
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.some`'
- en: '`.reduce`'
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.reduce`'
- en: '`.reduceRight`'
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.reduceRight`'
- en: 'Looping over Arrays:'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历数组：
- en: '`.forEach`'
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.forEach`'
- en: 'Element callbacks have type signatures that look as follows:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 元素回调的类型签名如下所示：
- en: '[PRE90]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'That is, the callback gets three parameters (it is free to ignore any of them):'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 即，回调函数得到三个参数（它可以自由忽略任何一个）：
- en: '`value` is the most important one. This parameter holds the Array element that
    is currently being processed.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value` 是最重要的一个。此参数持有当前正在处理的数组元素。'
- en: '`index` can additionally tell the callback what the index of the element is.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index` 可以额外告诉回调函数元素的索引。'
- en: '`array` points to the current Array (the receiver of the method call). Some
    algorithms need to refer to the whole Array – e.g., to search elsewhere additional
    data. This parameter lets us write reusable callbacks for such algorithms.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array` 指向当前数组（方法调用的接收者）。某些算法需要引用整个数组 - 例如，为了搜索其他数据。此参数使我们能够为这样的算法编写可重用的回调函数。'
- en: 'What the callback is expected to return depends on the method it is passed
    to. Possibilities include:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数预期返回的内容取决于传递给它的方法。可能包括：
- en: '`.map()` fills its result with the values returned by its callback:'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.map()` 使用其回调函数返回的值填充其结果：'
- en: '[PRE91]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '`.find()` returns the first Array element for which its callback returns `true`:'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.find()` 返回第一个回调返回 `true` 的数组元素：'
- en: '[PRE92]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[34.14 Transforming with element callbacks: `.map()`, `.filter()`, `.flatMap()`](#transforming-with-element-callbacks-map-filter-flatmap)'
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[34.14 使用元素回调进行转换：`.map()`, `.filter()`, `.flatMap()`](#transforming-with-element-callbacks-map-filter-flatmap)'
- en: In this section, we explore methods that accept [element callbacks](#array-element-callbacks)
    which tell them how to transform an input Array into an output Array.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨接受 [元素回调](#array-element-callbacks) 的方法，这些回调告诉它们如何将输入数组转换为输出数组。
- en: '[34.14.1 `.map()`: Each output element is derived from its input element](#map-each-output-element-is-derived-from-its-input-element)'
  id: totrans-402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.14.1 `.map()`: 每个输出元素是从其输入元素派生出来的](#map-each-output-element-is-derived-from-its-input-element)'
- en: 'Each element of the output Array is the result of applying the callback to
    the corresponding input element:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 输出数组的每个元素都是将回调应用于相应输入元素的结果：
- en: '[PRE93]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '`.map()` can be implemented as follows:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`.map()` 可以实现如下：'
- en: '[PRE94]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Numbering lines via `.map()`**'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：通过
    `.map()` 编号行**'
- en: '`exercises/arrays/number_lines_test.mjs`'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/arrays/number_lines_test.mjs`'
- en: '[34.14.2 `.filter()`: Only keep some of the elements](#filter-only-keep-some-of-the-elements)'
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.14.2 `.filter()`: 只保留一些元素](#filter-only-keep-some-of-the-elements)'
- en: The Array method `.filter()` returns an Array collecting all elements for which
    the callback returns a truthy value.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 数组方法 `.filter()` 返回一个数组，收集所有回调返回真值（truthy value）的元素。
- en: 'For example:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE95]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '`.filter()` can be implemented as follows:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`.filter()` 可以实现如下：'
- en: '[PRE96]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Removing empty lines via `.filter()`**'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：通过
    `.filter()` 删除空行**'
- en: '`exercises/arrays/remove_empty_lines_filter_test.mjs`'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/arrays/remove_empty_lines_filter_test.mjs`'
- en: '[34.14.3 `.flatMap()`: Each input element produces zero or more output elements
    ^(ES2019)](#Array.prototype.flatMap)'
  id: totrans-417
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.14.3 `.flatMap()`: 每个输入元素产生零个或多个输出元素 (ES2019)](#Array.prototype.flatMap)'
- en: 'The type signature of `Array<T>.prototype.flatMap()` is:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array<T>.prototype.flatMap()` 的类型签名是：'
- en: '[PRE97]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Both `.map()` and `.flatMap()` take a function `callback` as a parameter that
    controls how an input Array is translated to an output Array:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`.map()` 和 `.flatMap()` 都接受一个 `callback` 函数作为参数，该参数控制如何将输入数组转换为输出数组：'
- en: With `.map()`, each input Array element is translated to exactly one output
    element. That is, `callback` returns a single value.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.map()`，每个输入数组元素被转换为恰好一个输出元素。也就是说，`callback` 返回一个值。
- en: With `.flatMap()`, each input Array element is translated to zero or more output
    elements. That is, `callback` returns an Array of values (it can also return non-Array
    values, but that is rare).
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.flatMap()`，每个输入数组元素被转换为零个或多个输出元素。也就是说，`callback` 返回一个值数组（它也可以返回非数组值，但这很少见）。
- en: 'This is `.flatMap()` in action:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `.flatMap()` 的实际应用：
- en: '[PRE98]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: We’ll consider use cases next, before exploring how this method could be implemented.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨这个方法如何实现之前，我们将考虑一些用例。
- en: '[34.14.3.1 Use case: filtering and mapping at the same time](#use-case-filtering-and-mapping-at-the-same-time)'
  id: totrans-426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[34.14.3.1 用例：同时进行过滤和映射](#use-case-filtering-and-mapping-at-the-same-time)'
- en: The result of the Array method `.map()` always has the same length as the Array
    it is invoked on. That is, its callback can’t skip Array elements it isn’t interested
    in. The ability of `.flatMap()` to do so is useful in the next example.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 数组方法 `.map()` 的结果总是与它调用的数组具有相同的长度。也就是说，它的回调不能跳过它不感兴趣的数组元素。`.flatMap()` 能够这样做在下一个示例中很有用。
- en: 'Let’s say, we got the following result from [`Promise.allSettled()`](ch_promises.html#Promise.allSettled):'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，我们从 `Promise.allSettled()`（[ch_promises.html#Promise.allSettled](ch_promises.html#Promise.allSettled)）得到了以下结果：
- en: '[PRE99]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We can use `.flatMap()` to extract just the values or just the errors from
    `results`:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `.flatMap()` 从 `results` 中提取仅值或仅错误：
- en: '[PRE100]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[34.14.3.2 Use case: mapping single input values to multiple output values](#use-case-mapping-single-input-values-to-multiple-output-values)'
  id: totrans-432
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[34.14.3.2 用例：将单个输入值映射到多个输出值](#use-case-mapping-single-input-values-to-multiple-output-values)'
- en: The Array method `.map()` maps each input Array element to one output element.
    But what if we want to map it to multiple output elements?
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 数组方法 `.map()` 将每个输入数组元素映射到一个输出元素。但如果我们想将其映射到多个输出元素呢？
- en: 'That becomes necessary in the following example:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，这变得必要：
- en: '[PRE101]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We want to convert an Array of strings to an Array of Unicode characters (code
    points). The following function achieves that via `.flatMap()`:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将字符串数组转换为 Unicode 字符数组（代码点）。以下函数通过 `.flatMap()` 实现了这一点：
- en: '[PRE102]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[34.14.3.3 A simple implementation](#a-simple-implementation)'
  id: totrans-438
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[34.14.3.3 简单实现](#a-simple-implementation)'
- en: 'We can implement `.flatMap()` as follows. Note: This implementation is simpler
    than the built-in version, which, for example, performs more checks.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按以下方式实现 `.flatMap()`。注意：此实现比内置版本简单，例如，它执行了更多的检查。
- en: '[PRE103]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercises:
    `.flatMap()`**'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：`.flatMap()`**'
- en: '`exercises/arrays/convert_to_numbers_test.mjs`'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exercises/arrays/convert_to_numbers_test.mjs`'
- en: '`exercises/arrays/replace_objects_test.mjs`'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exercises/arrays/replace_objects_test.mjs`'
- en: '[34.15 `.reduce()`: computing a summary for an Array](#Array.prototype.reduce)'
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[34.15 `.reduce()`: 计算数组的总结](#Array.prototype.reduce)'
- en: 'Method `.reduce()` is a powerful tool for computing a “summary” of an Array
    `arr`. A summary can be any kind of value:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `.reduce()` 是计算数组 `arr` 的“总结”的强大工具。总结可以是任何类型的值：
- en: A number. For example, the sum of all elements of `arr`.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数字。例如，`arr` 中所有元素的总和。
- en: An Array. For example, a copy of `arr`, where each element is twice the original
    element.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数组。例如，`arr` 的一个副本，其中每个元素是原始元素的两倍。
- en: Etc.
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等等。
- en: '`reduce` is also known as `foldl` (“fold left”) in functional programming and
    popular there. One caveat is that it can make code difficult to understand.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，`reduce` 也被称为 `foldl`（“左折叠”），在那里很受欢迎。一个需要注意的问题是，它可能会使代码难以理解。
- en: '[34.15.1 An overview of how `.reduce()` works](#an-overview-of-how-reduce-works)'
  id: totrans-450
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.15.1 `.reduce()` 的工作原理概述](#an-overview-of-how-reduce-works)'
- en: We’ll start with an overview of how `.reduce()` works. If you find the overview
    difficult to understand, you can skip ahead to the example and come back here
    later.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `.reduce()` 的工作原理概述开始。如果你觉得概述难以理解，你可以跳到示例，稍后再回来。
- en: '`.reduce()` has the following type signature (inside an `Array<T>`):'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`.reduce()` 具有以下类型签名（在 `Array<T>` 内部）：'
- en: '[PRE104]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '`T` is the type of the Array elements, `U` is the type of the summary. The
    two may or may not be different. `accumulator` is just another name for “summary”.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`T` 是数组元素的类型，`U` 是总结的类型。这两个可能相同，也可能不同。`accumulator` 只是“总结”的另一个名称。'
- en: 'To compute the summary of an Array `arr`, `.reduce()` feeds all Array elements
    to its callback one at a time:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算数组 `arr` 的总结，`.reduce()` 将所有数组元素逐个传递给其回调：
- en: '[PRE105]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '`init` provides the initial value for `accumulator`.'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init` 为 `accumulator` 提供初始值。'
- en: The accumulator contains the preliminary result of the reduction. When the callback
    is invoked, it combines the accumulator with the current Array element and returns
    the result. That result becomes the next accumulator.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 累加器包含减法操作的初步结果。当回调函数被调用时，它将累加器与当前数组元素结合并返回结果。该结果成为下一个累加器。
- en: The result of `.reduce()` is the final accumulator – the last result of `callback`
    after it has visited all elements.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.reduce()` 的结果是最终的累加器——在访问所有元素后 `callback` 的最后一个结果。'
- en: 'In other words: `callback` does most of the work; `.reduce()` just invokes
    it in a useful manner.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：`callback` 执行了大部分工作；`.reduce()` 只是按有用方式调用它。
- en: We could say that the callback folds Array elements into the accumulator. That’s
    why this operation is called “fold” in functional programming.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说回调将数组元素折叠到累加器中。这就是为什么在函数式编程中这个操作被称为“折叠”。
- en: '[Example: applying a binary operator to a whole Array](#example-applying-a-binary-operator-to-a-whole-array)'
  id: totrans-462
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[示例：对整个数组应用二元运算符](#example-applying-a-binary-operator-to-a-whole-array)'
- en: 'Let’s look at an example of `.reduce()` in action: function `addAll()` computes
    the sum of all numbers in an Array `arr`.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `.reduce()` 的一个实际例子：函数 `addAll()` 计算数组 `arr` 中所有数字的总和。
- en: '[PRE106]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: In this case, the accumulator holds the sum of all Array elements that `callback`
    has already visited.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，累加器包含 `callback` 已经访问过的所有数组元素的总和。
- en: 'How was the result `6` derived from the Array in line A? Via the following
    invocations of `callback`:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 如何从 A 行的数组中推导出结果 `6`？通过以下 `callback` 的调用：
- en: '[PRE107]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Notes:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: The first parameters are the current accumulators (starting with parameter `init`
    of `.reduce()`).
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先的参数是当前累加器（从 `.reduce()` 的参数 `init` 开始）。
- en: The second parameters are the current Array elements.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是当前数组元素。
- en: The results are the next accumulators.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果是下一个累加器。
- en: The last result of `callback` is also the result of `.reduce()`.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback` 的最后一个结果也是 `.reduce()` 的结果。'
- en: 'Alternatively, we could have implemented `addAll()` via a `for-of` loop:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以通过 `for-of` 循环来实现 `addAll()`：
- en: '[PRE108]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'It’s hard to say which of the two implementations is “better”: the one based
    on `.reduce()` is a little more concise, while the one based on `for-of` may be
    a little easier to understand – especially if someone is not familiar with functional
    programming.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 很难说哪一种实现方式是“更好”的：基于 `.reduce()` 的实现方式稍微简洁一些，而基于 `for-of` 的实现可能更容易理解——特别是如果某人不太熟悉函数式编程的话。
- en: '[34.15.2 What happens if we omit `init`?](#what-happens-if-we-omit-init)'
  id: totrans-476
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.15.2 如果省略 `init` 会发生什么？](#what-happens-if-we-omit-init)'
- en: 'If we pass the parameter `init` to `.reduce()`, it is the initial value of
    the accumulator:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将参数 `init` 传递给 `.reduce()`，它就是累加器的初始值：
- en: '[PRE109]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: If the Array is empty, the result of `.reduce()` is `init`.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组为空，`.reduce()` 的结果就是 `init`。
- en: 'If we omit `init` then `.reduce()` initializes the accumulator with the first
    Array element:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们省略 `init`，那么 `.reduce()` 将使用第一个数组元素初始化累加器：
- en: '[PRE110]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: If the Array only has one element, the result of `.reduce()` is that element.
    If the Array is empty, `.reduce()` doesn’t have a value to return and throws an
    exception.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组只有一个元素，`.reduce()` 的结果就是该元素。如果数组为空，`.reduce()` 没有返回值，并抛出异常。
- en: 'The following interaction demonstrates the initial value of the `accumulator`
    with and without `init`:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 以下交互演示了带有和没有 `init` 的 `accumulator` 的初始值：
- en: '[PRE111]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[Example: finding indices via `.reduce()`](#example-finding-indices-via-reduce)'
  id: totrans-485
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[示例：通过 `.reduce()` 查找索引](#example-finding-indices-via-reduce)'
- en: 'The following function is an implementation of the Array method `.indexOf()`.
    It returns the first index at which the given `searchValue` appears inside the
    Array `arr`:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数是数组方法 `.indexOf()` 的一个实现。它返回给定 `searchValue` 在数组 `arr` 中首次出现的位置索引：
- en: '[PRE112]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: One limitation of `.reduce()` is that we can’t finish early. In a `for-of` loop,
    we can immediately return the result once we have found it.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '`.reduce()` 的一个限制是我们不能提前结束。在 `for-of` 循环中，一旦找到结果，我们就可以立即返回。'
- en: '[Example: doubling Array elements](#example-doubling-array-elements)'
  id: totrans-489
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[示例：加倍数组元素](#example-doubling-array-elements)'
- en: 'Function `double(arr)` returns a copy of `inArr` whose elements are all multiplied
    by 2:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `double(arr)` 返回 `inArr` 的一个副本，其元素都乘以 2：
- en: '[PRE113]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'We modify the initial value `[]` by pushing into it. A non-destructive, more
    functional version of `double()` looks as follows:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过向其中推送来修改初始值 `[]`。`double()` 的一个非破坏性、更函数式的版本如下：
- en: '[PRE114]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: This version is more elegant but also slower and uses more memory.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本更优雅，但速度更慢，并且使用更多的内存。
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercises:
    `.reduce()`**'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“练习”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：`.reduce()`**'
- en: '`map()` via `.reduce()`: `exercises/arrays/map_via_reduce_test.mjs`'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map()` 通过 `.reduce()`：`exercises/arrays/map_via_reduce_test.mjs`'
- en: '`filter()` via `.reduce()`: `exercises/arrays/filter_via_reduce_test.mjs`'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter()` 通过 `.reduce()`：`exercises/arrays/filter_via_reduce_test.mjs`'
- en: '`countMatches()` via `.reduce()`: `exercises/arrays/count_matches_via_reduce_test.mjs`'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`countMatches()` 通过 `.reduce()`：`exercises/arrays/count_matches_via_reduce_test.mjs`'
- en: '[34.15.3 `.reduceRight()`: the end-to-start version of `.reduce()`](#Array.prototype.reduceRight)'
  id: totrans-499
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.15.3 `.reduceRight()`：`.reduce()` 的末尾到开头版本](#Array.prototype.reduceRight)'
- en: '`.reduce()` visits elements from start to end:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '`.reduce()` 从开始到结束访问元素：'
- en: '[PRE115]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '`.reduceRight()` has the same functionality but visits elements from end to
    start:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '`.reduceRight()` 具有相同的功能，但按从末尾到开头的顺序访问元素：'
- en: '[PRE116]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[34.16 `.sort()`: sorting Arrays](#Array.prototype.sort)'
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[34.16 `.sort()`：排序数组](#Array.prototype.sort)'
- en: '`.sort()` has the following type definition:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`.sort()` 有以下类型定义：'
- en: '[PRE117]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: By default, `.sort()` sorts string representations of the elements. These representations
    are compared via `<`. This operator compares code unit values (char codes) *lexicographically*
    (the first characters are most significant).
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`.sort()` 对元素的字符串表示进行排序。这些表示通过 `<` 进行比较。此运算符按字典顺序比较代码单元值（字符码）：
- en: '`.sort()` sorts *in place*; it changes and returns its receiver:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '`.sort()` 在原地排序；它改变并返回其接收者：'
- en: '[PRE118]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '![Icon “details”](../Images/38ba63de820aae6f94a019538ae0f222.png) **`.sort()`
    is stable**'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“细节”](../Images/38ba63de820aae6f94a019538ae0f222.png) **`.sort()` 是稳定的**'
- en: 'Since ECMAScript 2019, sorting is guaranteed to be *stable*: If elements are
    considered equal by sorting, then sorting does not change the order of those elements
    (relative to each other).'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 ECMAScript 2019 以来，排序保证是稳定的：如果元素在排序中被认为是相等的，那么排序不会改变这些元素的顺序（相对于彼此）。
- en: '[34.16.1 Customizing the sort order](#customizing-array-sorting)'
  id: totrans-512
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.16.1 自定义排序顺序](#customizing-array-sorting)'
- en: 'We can customize the sort order via the parameter `compareFunc`, which must
    return a number that is:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过参数 `compareFunc` 自定义排序顺序，该参数必须返回一个数字，该数字是：
- en: negative if `a` is less than `b`
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `a` 小于 `b`，则返回负数
- en: zero if `a` is equal to `b`
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `a` 等于 `b`，则返回零
- en: positive if `a` is greater than `b`
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `a` 大于 `b`，则返回正数
- en: We’ll see an example of a compare function in the next subsection.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一小节中看到一个比较函数的例子。
- en: '![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Tip for remembering
    these rules**'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“提示”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **记住这些规则的提示**'
- en: A negative number is *less than* zero (etc.).
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 负数小于零（等等）。
- en: '[34.16.2 Sorting numbers](#sorting-arrays-with-numbers)'
  id: totrans-520
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.16.2 按数字排序数组](#sorting-arrays-with-numbers)'
- en: 'Lexicographical sorting doesn’t work well for numbers:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 字典序排序对数字来说效果不佳：
- en: '[PRE119]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'We can fix this by writing a compare function:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过编写一个比较函数来解决这个问题：
- en: '[PRE120]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '![Icon “question”](../Images/3decb3ca67c240d2bb04742c1f28af18.png) **Why doesn’t
    `.sort()` automatically pick the right sorting approach for numbers?**'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“问题”](../Images/3decb3ca67c240d2bb04742c1f28af18.png) **为什么 `.sort()` 不会自动选择正确的排序方法来处理数字？**'
- en: It would have to examine all Array elements and make sure that they are numbers
    before switching from lexicographical sorting to numeric sorting.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 它必须检查所有数组元素并确保它们是数字，然后才能从字典序排序切换到数值排序。
- en: '[34.16.2.1 A trick for sorting numbers](#a-trick-for-sorting-numbers)'
  id: totrans-527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[34.16.2.1 排序数字的一个技巧](#a-trick-for-sorting-numbers)'
- en: 'The following trick uses the fact that (e.g.) the result for “less than” can
    be any negative number:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 以下技巧利用了（例如）“小于”的结果可以是任何负数的事实：
- en: '[PRE121]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'This time, we call the parameters `a` and `z` because that enables a mnemonic:
    The callback sorts ascendingly, “from `a` to `z`” (`a - z`).'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这次，我们称参数为 `a` 和 `z`，因为这可以提供一个助记符：回调函数按升序排序，“从 `a` 到 `z`” (`a - z`)。
- en: A downside of this trick is that we might get an arithmetic overflow if a large
    positive and a large negative number are compared.
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种技巧的缺点是，如果比较一个大的正数和一个大的负数，我们可能会得到算术溢出。
- en: '[34.16.3 Sorting human-language strings](#sorting-humanlanguage-strings)'
  id: totrans-532
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.16.3 按人类语言字符串排序](#sorting-humanlanguage-strings)'
- en: 'When sorting human-language strings, we need to be aware that they are compared
    according to their code unit values (char codes):'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 当排序人类语言字符串时，我们需要意识到它们是根据它们的代码单元值（字符码）进行比较的：
- en: '[PRE122]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'All unaccented uppercase letters come before all unaccented lowercase letters,
    which come before all accented letters. We can use `Intl`, [the JavaScript internationalization
    API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl)
    if we want proper sorting for human languages:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 所有无重音的大写字母都排在所有无重音的小写字母之前，而所有带重音的字母都排在无重音字母之前。如果我们想要为人类语言进行适当的排序，可以使用 `Intl`，[JavaScript
    国际化 API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl)：
- en: '[PRE123]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[34.16.4 Sorting objects](#sorting-objects)'
  id: totrans-537
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.16.4 排序对象](#sorting-objects)'
- en: We also need to use a compare function if we want to sort objects. As an example,
    the following code shows how to sort objects by age.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要对对象进行排序，我们还需要使用比较函数。以下代码示例展示了如何按年龄对对象进行排序。
- en: '[PRE124]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Sorting objects by name**'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“练习”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：按名称排序对象**'
- en: '`exercises/arrays/sort_objects_test.mjs`'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/arrays/sort_objects_test.mjs`'
- en: '[34.17 Grouping Array elements](#grouping-array-elements)'
  id: totrans-542
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[34.17 分组数组元素](#grouping-array-elements)'
- en: 'Grouping via `Object.groupBy()` and `Map.groupBy()` works for any iterable
    object and therefore for Arrays:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `Object.groupBy()` 和 `Map.groupBy()` 进行分组适用于任何可迭代对象，因此也适用于数组：
- en: '[PRE125]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'More information: [“Grouping iterables ^(ES2024)” (§32.8)](ch_sync-iteration.html#grouping-sync-iterables)'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息：[“分组可迭代对象 (ES2024)” (§32.8)](ch_sync-iteration.html#grouping-sync-iterables)
- en: '[34.18 Quick reference: `Array`](#quickref-Array)'
  id: totrans-546
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[34.18 快速参考：`Array`](#quickref-Array)'
- en: 'Legend:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 图例：
- en: '`R`: method does not change the Array (non-destructive).'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R`：方法不改变数组（非破坏性）。'
- en: '`W`: method changes the Array (destructive).'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`W`：方法改变数组（破坏性）。'
- en: '**Negative indices:** If a method supports negative indices that means that
    such indices are added to `.length` before they are used: `-1` becomes `this.length-1`,
    etc. In other words: `-1` refers to the last element, `-2` to the second-last
    element, etc. `.at()` is one method that supports negative indices:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '**负索引**：如果一个方法支持负索引，这意味着在它们被使用之前，这些索引会被添加到 `.length` 上：`-1` 变为 `this.length-1`
    等。换句话说：`-1` 指的是最后一个元素，`-2` 指的是倒数第二个元素，等等。`.at()` 是支持负索引的一个方法：'
- en: '[PRE126]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[34.18.1 `new Array()`](#new-array)'
  id: totrans-552
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.18.1 `new Array()`](#new-array)'
- en: '`new Array(len = 0)` ES1'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new Array(len = 0)` ES1'
- en: 'Creates an Array of length `len` that only contains holes:'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个长度为 `len` 的数组，其中只包含空位：
- en: '[PRE127]'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[34.18.2 `Array.*`](#array)'
  id: totrans-556
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.18.2 `Array.*`](#array)'
- en: '`Array.from(iterableOrArrayLike, mapFunc?)` ES6'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.from(iterableOrArrayLike, mapFunc?)` ES6'
- en: '[PRE128]'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Converts an iterable or [an Array-like object](#array-like-objects) to an Array.
  id: totrans-559
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可迭代对象或 [类似数组的对象](#array-like-objects) 转换为数组。
- en: Optionally, the input values can be translated via `mapFunc` before they are
    added to the output Array.
  id: totrans-560
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入值可以通过 `mapFunc` 在它们被添加到输出数组之前进行翻译。
- en: 'Examples:'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE129]'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '`Array.of(...items)` ES6'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.of(...items)` ES6'
- en: '[PRE130]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'This static method is mainly useful for subclasses of `Array`, where it serves
    as a custom Array literal:'
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个静态方法主要用于 `Array` 的子类，其中它充当自定义数组字面量：
- en: '[PRE131]'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[34.18.3 `Array.prototype.*`: getting, setting and visiting single elements](#arrayprototype-getting-setting-and-visiting-single-elements)'
  id: totrans-567
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.18.3 `Array.prototype.*`：获取、设置和访问单个元素](#arrayprototype-getting-setting-and-visiting-single-elements)'
- en: '`Array.prototype.at(index)`'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.at(index)`'
- en: ES2022 | Non-mutating
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES2022 | 非破坏性
- en: Returns the Array element at `index`. If there is no such element, it returns
    `undefined`.
  id: totrans-570
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回 `index` 处的数组元素。如果没有这样的元素，则返回 `undefined`。
- en: 'This method is mostly equivalent to getting elements via square brackets:'
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法基本上等同于通过方括号获取元素：
- en: '[PRE132]'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'One reason for using `.at()` is that it supports [negative indices](#negative-array-indices):'
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `.at()` 的一个原因是因为它支持 [负索引](#negative-array-indices)：
- en: '[PRE133]'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '`Array.prototype.with(index, value)`'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.with(index, value)`'
- en: ES2023 | Non-mutating
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES2023 | 非破坏性
- en: 'Returns the receiver of the method call, with one different element: At `index`,
    there is now `value`.'
  id: totrans-577
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回方法调用接收者的一个不同元素：在 `index` 处现在有 `value`。
- en: 'This method is the non-destructive version of setting elements via square brackets.
    It supports negative indices:'
  id: totrans-578
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法是通过方括号设置元素的不可破坏版本。它支持负索引：
- en: '[PRE134]'
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '`Array.prototype.forEach(callback)`'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.forEach(callback)`'
- en: ES5 | Non-mutating
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES5 | 非破坏性
- en: '[PRE135]'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Calls `callback` for each element.
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为每个元素调用 `callback`。
- en: '[PRE136]'
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Output:'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE137]'
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'A `for-of` loop is usually a better choice: it’s faster, supports `break` and
    can iterate over arbitrary iterables.'
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`for-of` 循环通常是一个更好的选择：它更快，支持 `break`，并且可以遍历任意可迭代对象。'
- en: '[34.18.4 `Array.prototype.*`: keys and values](#arrayprototype-keys-and-values)'
  id: totrans-588
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.18.4 `Array.prototype.*`：键和值](#arrayprototype-keys-and-values)'
- en: '`Array.prototype.keys()`'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.keys()`'
- en: ES6 | Non-mutating
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES6 | 非破坏性
- en: Returns an iterable over the keys of the receiver.
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回接收者键的可迭代对象。
- en: '[PRE138]'
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '`Array.prototype.values()`'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.values()`'
- en: ES6 | Non-mutating
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES6 | 非修改
- en: Returns an iterable over the values of the receiver.
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回接收者值的可迭代对象。
- en: '[PRE139]'
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '`Array.prototype.entries()`'
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.entries()`'
- en: ES6 | Non-mutating
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES6 | 非修改
- en: Returns an iterable over [index, element] pairs.
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回一个包含接收者元素的索引对的可迭代对象。
- en: '[PRE140]'
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[34.18.5 `Array.prototype.*`: destructively adding or removing elements at
    either end of an Array](#arrayprototype-destructively-adding-or-removing-elements-at-either-end-of-an-array)'
  id: totrans-601
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.18.5 `Array.prototype.*`: 在数组的两端破坏性地添加或删除元素](#arrayprototype-destructively-adding-or-removing-elements-at-either-end-of-an-array)'
- en: '`Array.prototype.pop()`'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.pop()`'
- en: ES3 | Mutating
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES3 | 修改
- en: Removes and returns the last element of the receiver. That is, it treats the
    end of the receiver as a stack. The opposite of `.push()`.
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 移除并返回接收者的最后一个元素。也就是说，它将接收者的末尾视为栈。是 `.push()` 的相反操作。
- en: '[PRE141]'
  id: totrans-605
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '`Array.prototype.push(...items)`'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.push(...items)`'
- en: ES3 | Mutating
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES3 | 修改
- en: Adds zero or more `items` to the end of the receiver. That is, it treats the
    end of the receiver as a stack. The return value is the length of the receiver
    after the change. The opposite of `.pop()`.
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 向接收者的末尾添加零个或多个 `items`。也就是说，它将接收者的末尾视为栈。这是 `.pop()` 的相反操作。
- en: '[PRE142]'
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'We can push an Array by spreading (`...`) it into arguments:'
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过将数组展开（`...`）到参数中来推送一个数组：
- en: '[PRE143]'
  id: totrans-611
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '`Array.prototype.shift()`'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.shift()`'
- en: ES3 | Mutating
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES3 | 修改
- en: Removes and returns the first element of the receiver. The inverse of `.unshift()`.
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 移除并返回接收者的第一个元素。是 `.unshift()` 的逆操作。
- en: '[PRE144]'
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '`Array.prototype.unshift(...items)`'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.unshift(...items)`'
- en: ES3 | Mutating
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES3 | 修改
- en: Inserts the `items` at the beginning of the receiver and returns its length
    after this modification.
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `start` 索引处插入 `items` 并返回修改后的长度。
- en: '[PRE145]'
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'We can push an Array by spreading (`...`) it into arguments:'
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过将数组展开（`...`）到参数中来推送一个数组：
- en: '[PRE146]'
  id: totrans-621
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[34.18.6 `Array.prototype.*`: combining, extracting and changing sequences
    of elements](#arrayprototype-combining-extracting-and-changing-sequences-of-elements)'
  id: totrans-622
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.18.6 `Array.prototype.*`: 合并、提取和更改元素序列](#arrayprototype-combining-extracting-and-changing-sequences-of-elements)'
- en: '![Icon “tip”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **Tip: telling
    `.slice()` and `.splice()` apart**'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '![图标“提示”](../Images/8440b17bb8219cda9f9405ac83c36db0.png) **提示：区分 `.slice()`
    和 `.splice()`**'
- en: '`.slice()` is much more commonly used. The verb “slice” is also much more common
    than the verb “splice”.'
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.slice()` 更常用。动词“slice”也比动词“splice”更常见。'
- en: 'Using `.splice()` is rare: Elements are more commonly (non-destructively) removed
    via `.filter()`. “Splice” has one letter more than “slice” and the method also
    does more.'
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.splice()` 很少见：元素通常通过 `.filter()`（非破坏性）移除。“Splice” 比 “slice” 多一个字母，该方法也做了更多。
- en: '`Array.prototype.concat(...items)`'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.concat(...items)`'
- en: ES3 | Non-mutating
  id: totrans-627
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES3 | 非修改
- en: Returns a new Array that is the concatenation of the receiver and all `items`.
    Non-Array parameters (such as `'b'` in the following example) are treated as if
    they were Arrays with single elements.
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回一个新的数组，它是接收者和所有 `items` 的连接。非数组参数（如以下示例中的 `'b'`）被视为具有单个元素的数组。
- en: '[PRE147]'
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '`Array.prototype.slice(start?, end?)`'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.slice(start?, end?)`'
- en: ES3 | Non-mutating
  id: totrans-631
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES3 | 非修改
- en: Returns a new Array containing the elements of the receiver whose indices are
    between (including) `start` and (excluding) `end`.
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回一个新的数组，包含接收者的元素，其索引在（包括）`start` 和（不包括）`end` 之间。
- en: '[PRE148]'
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '`.slice()` supports [negative indices](#negative-array-indices):'
  id: totrans-634
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`.slice()` 支持 [负索引](#negative-array-indices)：'
- en: '[PRE149]'
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'It can be used to (shallowly) copy Arrays:'
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它可以用作（浅度）复制数组：
- en: '[PRE150]'
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '`Array.prototype.splice(start?, deleteCount?, ...items)`'
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.splice(start?, deleteCount?, ...items)`'
- en: ES3 | Mutating
  id: totrans-639
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES3 | 修改
- en: At index `start`,
  id: totrans-640
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在索引 `start`，
- en: 'removes `deleteCount` elements (default: all remaining elements) and'
  id: totrans-641
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除 `deleteCount` 个元素（默认：所有剩余元素），
- en: replaces them with `items`.
  id: totrans-642
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将它们替换为 `items`。
- en: It returns the deleted elements.
  id: totrans-643
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它返回被删除的元素。
- en: The non-destructive version of this method is [`.toSpliced()`](#qref-Array.prototype.toSpliced).
  id: totrans-644
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法的非破坏性版本是 [`.toSpliced()`](#qref-Array.prototype.toSpliced)。
- en: '[PRE151]'
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'If `deleteCount` is missing, `.splice()` deletes until the end of the Array:'
  id: totrans-646
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果缺少 `deleteCount`，`.splice()` 会删除直到数组末尾：
- en: '[PRE152]'
  id: totrans-647
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '`start` can be [negative](#negative-array-indices):'
  id: totrans-648
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`start` 可以是 [负数](#negative-array-indices)：'
- en: '[PRE153]'
  id: totrans-649
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '`Array.prototype.toSpliced(start?, deleteCount?, ...items)`'
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.toSpliced(start?, deleteCount?, ...items)`'
- en: ES2023 | Non-mutating
  id: totrans-651
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES2023 | 非修改
- en: Creates a new Array where, starting at index `start`, `deleteCount` elements
    are replaced with `items`.
  id: totrans-652
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的数组，从索引 `start` 开始，`deleteCount` 个元素被 `items` 替换。
- en: If `deleteCount` is missing, all elements from `start` until the end are deleted.
  id: totrans-653
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `deleteCount` 缺失，则删除从 `start` 到末尾的所有元素。
- en: The destructive version of this method is [`.splice()`](#qref-Array.prototype.splice).
  id: totrans-654
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法的破坏性版本是 [`.splice()`](#qref-Array.prototype.splice)。
- en: '[PRE154]'
  id: totrans-655
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '`start` can be [negative](#negative-array-indices):'
  id: totrans-656
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`start` 可以是 [负数](#negative-array-indices)：'
- en: '[PRE155]'
  id: totrans-657
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '`Array.prototype.fill(start=0, end=this.length)`'
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.fill(start=0, end=this.length)`'
- en: ES6 | Mutating
  id: totrans-659
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES6 | 修改
- en: Returns `this`.
  id: totrans-660
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回 `this`。
- en: Assigns `value` to every index between (including) `start` and (excluding) `end`.
  id: totrans-661
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `value` 赋值给从（包括）`start` 到（不包括）`end` 之间的每个索引。
- en: '[PRE156]'
  id: totrans-662
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Caveat: Don’t use this method to fill an Array with an object `obj`; then each
    element will refer to the same value (sharing it). In this case, it’s better to
    [use `Array.from()`](#filling-arrays).'
  id: totrans-663
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：不要使用此方法用对象 `obj` 填充数组；然后每个元素都将引用相同的值（共享它）。在这种情况下，最好 [使用 `Array.from()`](#filling-arrays)。
- en: '`Array.prototype.copyWithin(target, start, end=this.length)`'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.copyWithin(target, start, end=this.length)`'
- en: ES6 | Mutating
  id: totrans-665
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES6 | 修改
- en: Returns `this`.
  id: totrans-666
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回 `this`。
- en: Copies the elements whose indices range from (including) `start` to (excluding)
    `end` to indices starting with `target`. Overlapping is handled correctly.
  id: totrans-667
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将索引范围从（包括）`start` 到（不包括）`end` 的元素复制到以 `target` 开始的索引。正确处理重叠。
- en: '[PRE157]'
  id: totrans-668
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '`start` or `end` can be [negative](#negative-array-indices).'
  id: totrans-669
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`start` 或 `end` 可以是 [负数](#negative-array-indices)。'
- en: '[34.18.7 `Array.prototype.*`: searching for elements](#arrayprototype-searching-for-elements)'
  id: totrans-670
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.18.7 `Array.prototype.*`: 搜索元素](#arrayprototype-searching-for-elements)'
- en: '`Array.prototype.includes(searchElement, fromIndex)`'
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.includes(searchElement, fromIndex)`'
- en: ES2016 | Non-mutating
  id: totrans-672
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES2016 | 非修改
- en: Returns `true` if the receiver has an element whose value is `searchElement`
    and `false`, otherwise. Searching starts at index `fromIndex`.
  id: totrans-673
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果接收器有一个元素的值是 `searchElement`，则返回 `true`，否则返回 `false`。搜索从索引 `fromIndex` 开始。
- en: '[PRE158]'
  id: totrans-674
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '`Array.prototype.indexOf(searchElement, fromIndex)`'
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.indexOf(searchElement, fromIndex)`'
- en: ES5 | Non-mutating
  id: totrans-676
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES5 | 非修改
- en: Returns the index of the first element that is strictly equal to `searchElement`.
    Returns `-1` if there is no such element. Starts searching at index `fromIndex`,
    visiting higher indices next.
  id: totrans-677
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回第一个严格等于 `searchElement` 的元素的索引。如果没有这样的元素，则返回 `-1`。从索引 `fromIndex` 开始搜索，然后访问更高的索引。
- en: '[PRE159]'
  id: totrans-678
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '`Array.prototype.lastIndexOf(searchElement, fromIndex)`'
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.lastIndexOf(searchElement, fromIndex)`'
- en: ES5 | Non-mutating
  id: totrans-680
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES5 | 非修改
- en: Returns the index of the last element that is strictly equal to `searchElement`.
    Returns `-1` if there is no such element. Starts searching at index `fromIndex`,
    visiting lower indices next.
  id: totrans-681
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回最后一个严格等于 `searchElement` 的元素的索引。如果没有这样的元素，则返回 `-1`。从索引 `fromIndex` 开始搜索，然后访问较低的索引。
- en: '[PRE160]'
  id: totrans-682
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '`Array.prototype.find(predicate, thisArg?)`'
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.find(predicate, thisArg?)`'
- en: ES6 | Non-mutating
  id: totrans-684
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES6 | 非修改
- en: '[PRE161]'
  id: totrans-685
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Traverses an Array from start to end.
  id: totrans-686
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数组的开始到末尾遍历。
- en: Returns the value of the first element for which `predicate` returns a truthy
    value.
  id: totrans-687
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回第一个使 `predicate` 返回真值的元素的值。
- en: If there is no such element, it returns `undefined`.
  id: totrans-688
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有这样的元素，则返回 `undefined`。
- en: '[PRE162]'
  id: totrans-689
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '`Array.prototype.findLast(predicate, thisArg?)`'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.findLast(predicate, thisArg?)`'
- en: ES2023 | Non-mutating
  id: totrans-691
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES2023 | 非修改
- en: '[PRE163]'
  id: totrans-692
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Traverses an Array from end to start.
  id: totrans-693
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数组的末尾开始遍历数组。
- en: Returns the value of the first element for which `predicate` returns a truthy
    value.
  id: totrans-694
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回第一个使 `predicate` 返回真值的元素的值。
- en: If there is no such element, it returns `undefined`.
  id: totrans-695
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有这样的元素，则返回 `undefined`。
- en: '[PRE164]'
  id: totrans-696
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '`Array.prototype.findIndex(predicate, thisArg?)`'
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.findIndex(predicate, thisArg?)`'
- en: ES6 | Non-mutating
  id: totrans-698
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES6 | 非修改
- en: '[PRE165]'
  id: totrans-699
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Traverses an Array from start to end.
  id: totrans-700
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数组的开始到末尾遍历。
- en: Returns the index of the first element for which `predicate` returns a truthy
    value.
  id: totrans-701
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回第一个使 `predicate` 返回真值的元素的索引。
- en: If there is no such element, it returns `-1`.
  id: totrans-702
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有这样的元素，则返回 `-1`。
- en: '[PRE166]'
  id: totrans-703
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '`Array.prototype.findLastIndex(predicate, thisArg?)`'
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.findLastIndex(predicate, thisArg?)`'
- en: ES2023 | Non-mutating
  id: totrans-705
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES2023 | 非修改
- en: '[PRE167]'
  id: totrans-706
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Traverses an Array from end to start.
  id: totrans-707
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数组的末尾开始遍历。
- en: Returns the index of the first element for which `predicate` returns a truthy
    value.
  id: totrans-708
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回第一个使 `predicate` 返回真值的元素的索引。
- en: If there is no such element, it returns `-1`.
  id: totrans-709
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有这样的元素，则返回 `-1`。
- en: '[PRE168]'
  id: totrans-710
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[34.18.8 `Array.prototype.*`: filtering and mapping](#arrayprototype-filtering-and-mapping)'
  id: totrans-711
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.18.8 `Array.prototype.*`: 过滤和映射](#arrayprototype-filtering-and-mapping)'
- en: '`Array.prototype.filter(predicate, thisArg?)`'
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.filter(predicate, thisArg?)`'
- en: ES5 | Non-mutating
  id: totrans-713
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES5 | 非修改
- en: '[PRE169]'
  id: totrans-714
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Returns an Array with only those elements for which `predicate` returns a truthy
    value.
  id: totrans-715
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回一个只包含那些使 `predicate` 返回真值的元素的数组。
- en: '[PRE170]'
  id: totrans-716
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '`Array.prototype.map(callback, thisArg?)`'
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.map(callback, thisArg?)`'
- en: ES5 | Non-mutating
  id: totrans-718
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES5 | 非修改
- en: '[PRE171]'
  id: totrans-719
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Returns a new Array, in which every element is the result of `mapFunc` being
    applied to the corresponding element of the receiver.
  id: totrans-720
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回一个新的数组，其中每个元素都是将 `mapFunc` 应用到接收器相应元素的结果。
- en: '[PRE172]'
  id: totrans-721
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '`Array.prototype.flatMap(callback, thisArg?)`'
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.flatMap(callback, thisArg?)`'
- en: ES2019 | Non-mutating
  id: totrans-723
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES2019 | 非修改
- en: '[PRE173]'
  id: totrans-724
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: The result is produced by invoking `callback()` for each element of the original
    Array and concatenating the Arrays it returns.
  id: totrans-725
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果是通过为原始数组的每个元素调用 `callback()` 并连接它返回的数组来生成的。
- en: '[PRE174]'
  id: totrans-726
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '`Array.prototype.flat(depth = 1)`'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.flat(depth = 1)`'
- en: ES2019 | Non-mutating
  id: totrans-728
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES2019 | 非修改
- en: '“Flattens” an Array: It descends into the Arrays that are nested inside the
    input Array and creates a copy where all values it finds at level `depth` or lower
    are moved to the top level.'
  id: totrans-729
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: “扁平化”一个数组：它进入输入数组内部嵌套的数组，并创建一个副本，其中所有在 `depth` 级别或以下找到的值都移动到顶层。
- en: '[PRE175]'
  id: totrans-730
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[34.18.9 `Array.prototype.*`: computing summaries](#arrayprototype-computing-summaries)'
  id: totrans-731
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.18.9 `Array.prototype.*`: 计算摘要](#arrayprototype-computing-summaries)'
- en: '`Array.prototype.every(predicate, thisArg?)`'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.every(predicate, thisArg?)`'
- en: ES5 | Non-mutating
  id: totrans-733
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES5 | 非修改
- en: '[PRE176]'
  id: totrans-734
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Returns `true` if `predicate` returns a truthy value for every element. Otherwise,
    it returns `false`:'
  id: totrans-735
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 `predicate` 对每个元素都返回一个真值，则返回 `true`。否则，返回 `false`：
- en: '[PRE177]'
  id: totrans-736
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Stops traversing an Array if the predicate returns a falsy value (because then
    the result is guaranteed to be `false`).
  id: totrans-737
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `predicate` 返回一个假值，则停止遍历数组（因为结果保证为 `false`）。
- en: Corresponds to universal quantification (“for all”, ∀) in mathematics.
  id: totrans-738
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对应于数学中的全称量化（“所有”，∀）。
- en: 'Related method: [`.some()`](#qref-Array.prototype.some) (“exists”).'
  id: totrans-739
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关方法：[`.some()`](#qref-Array.prototype.some)（“存在”）。
- en: '`Array.prototype.some(predicate, thisArg?)`'
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.some(predicate, thisArg?)`'
- en: ES5 | Non-mutating
  id: totrans-741
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES5 | 非修改
- en: '[PRE178]'
  id: totrans-742
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Returns `true` if `predicate` returns a truthy value for at least one element.
    Otherwise, it returns `false`.
  id: totrans-743
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 `predicate` 对至少一个元素返回一个真值，则返回 `true`。否则，返回 `false`。
- en: '[PRE179]'
  id: totrans-744
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Stops traversing an Array if the predicate returns a truthy value (because then
    the result is guaranteed to be `true`).
  id: totrans-745
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `predicate` 返回一个真值，则停止遍历数组（因为结果保证为 `true`）。
- en: Corresponds to existential quantification (“exists”, ∃) in mathematics.
  id: totrans-746
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对应于存在量化（“存在”，∃）在数学中。
- en: 'Related method: [`.every()`](#qref-Array.prototype.every) (“for all”).'
  id: totrans-747
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关方法：[`.every()`](#qref-Array.prototype.every)（“所有”）。
- en: '`Array.prototype.reduce(callback, initialValue?)`'
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.reduce(callback, initialValue?)`'
- en: ES5 | Non-mutating
  id: totrans-749
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES5 | 非修改
- en: '[PRE180]'
  id: totrans-750
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'This method produces a summary of the receiver: it feeds all Array elements
    to `callback`, which combines a current summary (in parameter `accumulator`) with
    the current Array element and returns the next `accumulator`:'
  id: totrans-751
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法生成接收器的摘要：它将所有数组元素传递给 `callback`，该 `callback` 将当前摘要（在参数 `accumulator` 中）与当前数组元素结合，并返回下一个
    `accumulator`：
- en: '[PRE181]'
  id: totrans-752
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: The result of `.reduce()` is the last result of `callback` after it has visited
    all Array elements.
  id: totrans-753
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`.reduce()` 的结果是 `callback` 访问所有数组元素后的最后一个结果。'
- en: '[PRE182]'
  id: totrans-754
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: If no `initialValue` is provided, the Array element at index 0 is used and the
    element at index 1 is visited first. Therefore, the Array must have at least length
    1.
  id: totrans-755
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果没有提供 `initialValue`，则使用索引 0 的数组元素，并首先访问索引 1 的元素。因此，数组必须至少有长度 1。
- en: '`Array.prototype.reduceRight(callback, initialValue?)`'
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.reduceRight(callback, initialValue?)`'
- en: ES5 | Non-mutating
  id: totrans-757
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES5 | 非修改
- en: '[PRE183]'
  id: totrans-758
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Works like `.reduce()`, but visits the Array elements backward, starting with
    the last element.
  id: totrans-759
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与 `.reduce()` 类似，但按反向顺序遍历数组元素，从最后一个元素开始。
- en: '[PRE184]'
  id: totrans-760
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[34.18.10 `Array.prototype.*`: converting to string](#arrayprototype-converting-to-string)'
  id: totrans-761
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.18.10 `Array.prototype.*`: 转换为字符串](#arrayprototype-converting-to-string)'
- en: '`Array.prototype.join(separator = '','')`'
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.join(separator = '','')`'
- en: ES1 | Non-mutating
  id: totrans-763
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES1 | 非修改
- en: Creates a string by concatenating string representations of all elements, separating
    them with `separator`.
  id: totrans-764
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过将所有元素的字符串表示连接起来，并用 `separator` 分隔它们来创建一个字符串。
- en: '[PRE185]'
  id: totrans-765
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '`Array.prototype.toString()`'
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.toString()`'
- en: ES1 | Non-mutating
  id: totrans-767
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES1 | 非修改
- en: Converts all elements to strings via `String()`, concatenates them while separating
    them with commas, and returns the result.
  id: totrans-768
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过 `String()` 将所有元素转换为字符串，在用逗号分隔的同时连接它们，并返回结果。
- en: '[PRE186]'
  id: totrans-769
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '`Array.prototype.toLocaleString()`'
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.toLocaleString()`'
- en: ES3 | Non-mutating
  id: totrans-771
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES3 | 非修改
- en: Works like [`.toString()`](#qref-Array.prototype.toString) but converts its
    elements to strings via `.toLocaleString()` (not via `.toString()`) before separating
    them via commas and concatenating them to a single string – that it returns.
  id: totrans-772
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与 `.toString()` 类似，但在将元素通过逗号分隔并连接成单个字符串之前，通过 `.toLocaleString()` 将其元素转换为字符串（而不是通过
    `.toString()`）。
- en: '[34.18.11 `Array.prototype.*`: sorting and reversing](#arrayprototype-sorting-and-reversing)'
  id: totrans-773
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.18.11 `Array.prototype.*`: 排序和反转](#arrayprototype-sorting-and-reversing)'
- en: '`Array.prototype.sort(compareFunc?)`'
  id: totrans-774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.sort(compareFunc?)`'
- en: ES1 | Mutating
  id: totrans-775
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES1 | 破坏性
- en: '[PRE187]'
  id: totrans-776
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Sorts the receiver and returns it.
  id: totrans-777
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对接收者进行排序并返回它。
- en: The non-destructive version of this method is [`.toSorted()`](#qref-Array.prototype.toSorted).
  id: totrans-778
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法的非破坏性版本是[`.toSorted()`](#qref-Array.prototype.toSorted)。
- en: Sorts string representations of the elements lexicographically.
  id: totrans-779
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按字典顺序对元素的字符串表示进行排序。
- en: 'Sorting numbers:'
  id: totrans-780
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 排序数字：
- en: '[PRE188]'
  id: totrans-781
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Sorting strings: By default, strings are sorted by code unit values (char codes),
    where, e.g., all unaccented uppercase letters come before all unaccented lowercase
    letters:'
  id: totrans-782
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 排序字符串：默认情况下，字符串按代码单元值（字符码）排序，例如，所有无重音的大写字母都排在所有无重音的小写字母之前：
- en: '[PRE189]'
  id: totrans-783
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'For human languages, we can use [`Intl.Collator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Collator):'
  id: totrans-784
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于人类语言，我们可以使用[`Intl.Collator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Collator)：
- en: '[PRE190]'
  id: totrans-785
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '`Array.prototype.toSorted(compareFunc?)`'
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.toSorted(compareFunc?)`'
- en: ES2023 | Non-mutating
  id: totrans-787
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES2023 | 非破坏性
- en: '[PRE191]'
  id: totrans-788
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Returns a sorted copy of the current Array.
  id: totrans-789
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回当前数组的排序副本。
- en: The destructive version of this method is [`.sort()`](#qref-Array.prototype.sort).
  id: totrans-790
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法的破坏性版本是[`.sort()`](#qref-Array.prototype.sort)。
- en: '[PRE192]'
  id: totrans-791
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: See the description of [`.sort()`](#qref-Array.prototype.sort) for more information
    on how to use this method.
  id: totrans-792
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关如何使用此方法的更多信息，请参阅[`.sort()`](#qref-Array.prototype.sort)的描述。
- en: '`Array.prototype.reverse()`'
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.reverse()`'
- en: ES1 | Mutating
  id: totrans-794
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES1 | 破坏性
- en: Rearranges the elements of the receiver so that they are in reverse order and
    then returns the receiver.
  id: totrans-795
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将接收者的元素重新排列，使它们按逆序排列，然后返回接收者。
- en: '[PRE193]'
  id: totrans-796
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: The non-destructive version of this method is [`.toReversed()`](#qref-Array.prototype.toReversed).
  id: totrans-797
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法的非破坏性版本是[`.toReversed()`](#qref-Array.prototype.toReversed)。
- en: '`Array.prototype.toReversed()`'
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.toReversed()`'
- en: ES2023 | Non-mutating
  id: totrans-799
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ES2023 | 非破坏性
- en: Returns a reversed copy of the current Array.
  id: totrans-800
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回当前数组的反转副本。
- en: The destructive version of this method is [`.reverse()`](#qref-Array.prototype.reverse).
  id: totrans-801
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法的破坏性版本是[`.reverse()`](#qref-Array.prototype.reverse)。
- en: '[PRE194]'
  id: totrans-802
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[34.18.12 Sources of the quick reference](#sources-of-the-quick-reference)'
  id: totrans-803
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[34.18.12 快速参考的来源](#sources-of-the-quick-reference)'
- en: '[ECMAScript language specification](https://tc39.es/ecma262/)'
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ECMAScript 语言规范](https://tc39.es/ecma262/)'
- en: '[TypeScript’s built-in typings](https://github.com/microsoft/TypeScript/tree/main/src/lib/)'
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[TypeScript 内置类型定义](https://github.com/microsoft/TypeScript/tree/main/src/lib/)'
- en: '[MDN web docs for JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)'
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MDN 网络文档 for JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)'
