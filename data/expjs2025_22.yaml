- en: 18 Numbers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18 数字
- en: 原文：[https://exploringjs.com/js/book/ch_numbers.html](https://exploringjs.com/js/book/ch_numbers.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://exploringjs.com/js/book/ch_numbers.html](https://exploringjs.com/js/book/ch_numbers.html)
- en: '[18.1 Numbers are used for both floating point numbers and integers](#numbers-are-used-for-both-floating-point-numbers-and-integers)'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.1 数字用于浮点数和整数](#numbers-are-used-for-both-floating-point-numbers-and-integers)'
- en: '[18.2 Number literals](#number-literals)'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.2 数字字面量](#number-literals)'
- en: '[18.2.1 Integer literals](#integer-literals)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.2.1 整数字面量](#integer-literals)'
- en: '[18.2.2 Floating point literals](#floating-point-literals)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.2.2 浮点数字面量](#floating-point-literals)'
- en: '[18.2.3 Syntactic pitfall: properties of decimal integer literals](#properties-of-decimal-integer-literals)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.2.3 语法陷阱：十进制整数字面量的属性](#properties-of-decimal-integer-literals)'
- en: '[18.2.4 Underscores (`_`) as separators in number literals ^(ES2021)](#numeric-separator-number-literals)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.2.4 下划线（`_`）作为数字字面量的分隔符（ES2021）](#numeric-separator-number-literals)'
- en: '[18.3 Arithmetic operators](#arithmetic-operators)'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.3 算术运算符](#arithmetic-operators)'
- en: '[18.3.1 Binary arithmetic operators](#binary-arithmetic-operators)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.3.1 二进制算术运算符](#binary-arithmetic-operators)'
- en: '[18.3.2 Unary plus (`+`) and negation (`-`)](#unary-plus--and-negation-)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.3.2 一元加号（`+`）和一元减号（`-`）](#unary-plus--and-negation-)'
- en: '[18.3.3 Incrementing (`++`) and decrementing (`--`)](#incrementing--and-decrementing-)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.3.3 增量（`++`）和减少（`--`）](#incrementing--and-decrementing-)'
- en: '[18.4 Converting to number](#converting-to-number)'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.4 转换为数字](#converting-to-number)'
- en: '[18.5 The numeric error values `NaN` and `Infinity`](#numeric-error-values)'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.5 数字错误值 `NaN` 和 `Infinity`](#numeric-error-values)'
- en: '[18.5.1 Error value: `NaN`](#NaN)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.5.1 错误值：`NaN`](#NaN)'
- en: '[18.5.2 Error value: `Infinity`](#error-value-infinity)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.5.2 错误值：`Infinity`](#error-value-infinity)'
- en: '[18.6 The precision of numbers: careful with decimal fractions](#the-precision-of-numbers-careful-with-decimal-fractions)'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.6 数字的精度：小心处理小数](#the-precision-of-numbers-careful-with-decimal-fractions)'
- en: '[18.7 (Advanced)](#advanced-2)'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.7 （高级）](#advanced-2)'
- en: '[18.8 Background: floating point precision](#floating-point-precision)'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.8 背景：浮点数精度](#floating-point-precision)'
- en: '[18.8.1 A simplified representation of floating point numbers](#a-simplified-representation-of-floating-point-numbers)'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.8.1 浮点数的简化表示](#a-simplified-representation-of-floating-point-numbers)'
- en: '[18.9 Integer numbers in JavaScript](#integer-numbers)'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.9 JavaScript中的整数数字](#integer-numbers)'
- en: '[18.9.1 How are integers different from floating point numbers with fractions?](#how-are-integers-different-from-floating-point-numbers-with-fractions)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.9.1 整数与带分数的浮点数有何不同？](#how-are-integers-different-from-floating-point-numbers-with-fractions)'
- en: '[18.9.2 Converting to integer](#converting-to-integer)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.9.2 转换为整数](#converting-to-integer)'
- en: '[18.9.3 Ranges of integer numbers in JavaScript](#ranges-of-integer-numbers-in-javascript)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.9.3 JavaScript中整数数字的范围](#ranges-of-integer-numbers-in-javascript)'
- en: '[18.9.4 Safe integers](#safe-integers)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.9.4 安全整数](#safe-integers)'
- en: '[18.10 Bitwise operators (advanced)](#bitwise-operators-advanced)'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.10 位运算符（高级）](#bitwise-operators-advanced)'
- en: '[18.10.1 Internally, bitwise operators work with 32-bit integers](#bitwise-operators-32-bit-operands)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.10.1 内部位运算符使用32位整数](#bitwise-operators-32-bit-operands)'
- en: '[18.10.2 Bitwise Not](#bitwise-not)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.10.2 位非运算](#bitwise-not)'
- en: '[18.10.3 Binary bitwise operators](#binary-bitwise-operators)'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.10.3 二进制位运算符](#binary-bitwise-operators)'
- en: '[18.10.4 Bitwise shift operators](#bitwise-shift-operators)'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.10.4 位运算符](#bitwise-shift-operators)'
- en: '[18.10.5 `b32()`: displaying unsigned 32-bit integers in binary notation](#b32)'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.10.5 `b32()`: 以二进制表示法显示无符号32位整数](#b32)'
- en: '[18.11 Quick reference: numbers](#quick-reference-numbers)'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.11 快速参考：数字](#quick-reference-numbers)'
- en: '[18.11.1 Global functions for numbers](#global-functions-for-numbers)'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.11.1 数字的全局函数](#global-functions-for-numbers)'
- en: '[18.11.2 `Number.*`: data properties](#number-data-properties)'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.11.2 `Number.*`: 数据属性](#number-data-properties)'
- en: '[18.11.3 `Number.*`: methods](#number-methods)'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.11.3 `Number.*`: 方法](#number-methods)'
- en: '[18.11.4 `Number.prototype.*`](#numberprototype)'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.11.4 `Number.prototype.*`](#numberprototype)'
- en: '[18.11.5 `Number.*`: data properties and methods for integers](#number-data-properties-and-methods-for-integers)'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.11.5 `Number.*`: 整数的属性和方法](#number-data-properties-and-methods-for-integers)'
- en: '[18.11.6 Sources](#sources)'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[18.11.6 来源](#sources)'
- en: 'JavaScript has two kinds of numeric values:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有两种数值类型：
- en: '*Numbers* are *doubles* – 64-bit floating point numbers implemented according
    to the *IEEE Standard for Floating-Point Arithmetic* (IEEE 754).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数字*是*双精度浮点数* - 根据*IEEE浮点算术标准*（IEEE 754）实现的64位浮点数。'
- en: They are also used for smaller integers within a range of plus/minus 53 bits.
    For more information, see [“Integer numbers in JavaScript” (§18.9)](#integer-numbers).
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们也用于范围在±53位内的较小整数。更多信息，请参阅[“JavaScript中的整数数字”（§18.9）](#integer-numbers)。
- en: '*Bigints* represent integers with an arbitrary precision.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*大整数*用任意精度表示整数。'
- en: This chapter covers numbers. Bigints are covered [later in this book](ch_bigints.html#ch_bigints).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了数字。大整数将在本书的后面部分介绍[大整数](ch_bigints.html#ch_bigints)。
- en: '[18.1 Numbers are used for both floating point numbers and integers](#numbers-are-used-for-both-floating-point-numbers-and-integers)'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[18.1 数字用于浮点数和整数](#numbers-are-used-for-both-floating-point-numbers-and-integers)'
- en: 'The type `number` is used for both floating point numbers and integers in JavaScript:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，类型`number`用于浮点数和整数：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, all numbers are floating point numbers. Integer numbers are simply
    floating point numbers without a decimal fraction:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所有数字都是浮点数。整数数字只是没有小数部分的浮点数：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[18.2 Number literals](#number-literals)'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[18.2 数字字面量](#number-literals)'
- en: Let’s examine literals for numbers.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查数字字面量。
- en: '[18.2.1 Integer literals](#integer-literals)'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.2.1 整数字面量](#integer-literals)'
- en: 'Several *integer literals* let us express integers with various bases:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 几个*整数字面量*让我们可以用不同的基数表示整数：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[18.2.2 Floating point literals](#floating-point-literals)'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.2.2 浮点字面量](#floating-point-literals)'
- en: Floating point numbers can only be expressed in base 10.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数只能用10进制表示。
- en: 'Fractions:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 分数：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Exponent: `eN` means ×10^N'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 指数：`eN`表示×10^N
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[18.2.3 Syntactic pitfall: properties of decimal integer literals](#properties-of-decimal-integer-literals)'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.2.3 语法陷阱：十进制整数字面量的属性](#properties-of-decimal-integer-literals)'
- en: 'Accessing a property of an decimal integer literal entails a pitfall: If the
    decimal integer literal is immediately followed by a dot, then that dot is interpreted
    as a decimal dot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 访问十进制整数字面量的属性存在一个陷阱：如果十进制整数字面量后面紧跟着一个点，那么这个点被解释为小数点：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are four ways to work around this pitfall:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种方法可以绕过这个陷阱：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that non-decimal integer literals don’t have this pitfall:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，非十进制整数字面量没有这个陷阱：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[18.2.4 Underscores (`_`) as separators in number literals ^(ES2021)](#numeric-separator-number-literals)'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.2.4 数字字面量中的下划线（`_`）作为分隔符（ES2021）](#numeric-separator-number-literals)'
- en: 'Grouping digits to make long numbers more readable has a long tradition. For
    example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字分组以使长数字更易于阅读有着悠久的历史。例如：
- en: In 1825, London had 1,335,000 inhabitants.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1825年，伦敦有133.5万人。
- en: The distance between Earth and Sun is 149,600,000 km.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地球与太阳之间的距离是1亿4千960万公里。
- en: 'Since ES2021, we can use underscores as separators in number literals:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 自从ES2021以来，我们可以在数字字面量中使用下划线作为分隔符：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With other bases, grouping is important, too:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他基数中，分组也很重要：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can also use the separator in fractions and exponents:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在分数和指数中使用分隔符：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[18.2.4.1 Where can we put separators?](#where-can-we-put-separators)'
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[18.2.4.1 分隔符可以放在哪里？](#where-can-we-put-separators)'
- en: 'The locations of separators are restricted in two ways:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔符的位置受到两种方式的限制：
- en: 'We can only put underscores between two digits. Therefore, all of the following
    number literals are illegal:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只能在两个数字之间放置下划线。因此，以下所有数字字面量都是非法的：
- en: '[PRE11]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can’t use more than one underscore in a row:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能在行内使用多个下划线：
- en: '[PRE12]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The motivation behind these restrictions is to keep parsing simple and to avoid
    strange edge cases.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制背后的动机是为了保持解析简单并避免奇怪的边缘情况。
- en: '[18.2.4.2 Parsing numbers with separators](#parsing-numbers-with-separators)'
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[18.2.4.2 带有分隔符的数字解析](#parsing-numbers-with-separators)'
- en: 'The following functions for parsing numbers do not support separators:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下用于解析数字的函数不支持分隔符：
- en: '`Number()`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number()`'
- en: '`Number.parseInt()`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number.parseInt()`'
- en: '`Number.parseFloat()`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number.parseFloat()`'
- en: 'For example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The rationale is that numeric separators are for code. Other kinds of input
    should be processed differently.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 理由是数字分隔符是为了代码。其他类型的输入应该以不同的方式处理。
- en: '[18.3 Arithmetic operators](#arithmetic-operators)'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[18.3 算术运算符](#arithmetic-operators)'
- en: '[18.3.1 Binary arithmetic operators](#binary-arithmetic-operators)'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.3.1 二进制算术运算符](#binary-arithmetic-operators)'
- en: '[Table 18.1](#tbl:binary-arithmetic-operators) lists JavaScript’s binary arithmetic
    operators.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[表18.1](#tbl:binary-arithmetic-operators)列出了JavaScript的二进制算术运算符。'
- en: '| Operator | Name |  | Example |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 名称 |  | 示例 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `n + m` | Addition | ES1 | `3 + 4` → `7` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `n + m` | 加法 | ES1 | `3 + 4` → `7` |'
- en: '| `n - m` | Subtraction | ES1 | `9 - 1` → `8` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `n - m` | 减法 | ES1 | `9 - 1` → `8` |'
- en: '| `n * m` | Multiplication | ES1 | `3 * 2.25` → `6.75` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `n * m` | 乘法 | ES1 | `3 * 2.25` → `6.75` |'
- en: '| `n / m` | Division | ES1 | `5.625 / 5` → `1.125` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `n / m` | 除法 | ES1 | `5.625 / 5` → `1.125` |'
- en: '| `n % m` | Remainder | ES1 | `8 % 5` → `3` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `n % m` | 余数 | ES1 | `8 % 5` → `3` |'
- en: '|  |  |  | `-8 % 5` → `-3` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  | `-8 % 5` → `-3` |'
- en: '| `n ** m` | Exponentiation | ES2016 | `4 ** 2` → `16` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `n ** m` | 幂运算 | ES2016 | `4 ** 2` → `16` |'
- en: 'Table 18.1: Binary arithmetic operators.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 表18.1：二进制算术操作符。
- en: '[18.3.1.1 `%` is a remainder operator](#-is-a-remainder-operator)'
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[18.3.1.1 `%` 是余数操作符](#-is-a-remainder-operator)'
- en: '`%` is a remainder operator, not a modulo operator. Its result has the sign
    of the first operand:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`%` 是余数操作符，而不是取模操作符。其结果具有第一个操作数的符号：'
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For more information on the difference between remainder and modulo, see the
    blog post [“Remainder operator vs. modulo operator (with JavaScript code)”](https://2ality.com/2019/08/remainder-vs-modulo.html)
    on 2ality.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 关于余数和取模之间的区别的更多信息，请参阅2ality上的博客文章“余数操作符 vs. 取模操作符（带JavaScript代码）”[“Remainder
    operator vs. modulo operator (with JavaScript code)”](https://2ality.com/2019/08/remainder-vs-modulo.html)。
- en: '[18.3.2 Unary plus (`+`) and negation (`-`)](#unary-plus--and-negation-)'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.3.2 一元加号(`+`)和一元负号(`-`)](#unary-plus--and-negation-)'
- en: '[Table 18.2](#tbl:unary-plus-negation) summarizes the two operators *unary
    plus* (`+`) and *negation* (`-`).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[表18.2](#tbl:unary-plus-negation)总结了两个操作符一元加号(`+`)和一元负号(`-`)。'
- en: '| Operator | Name |  | Example |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 名称 |  | 示例 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `+n` | Unary plus | ES1 | `+(-7)` → `-7` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `+n` | 一元加号 | ES1 | `+(-7)` → `-7` |'
- en: '| `-n` | Unary negation | ES1 | `-(-7)` → `7` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `-n` | 一元负号 | ES1 | `-(-7)` → `7` |'
- en: 'Table 18.2: The operators unary plus (`+`) and negation (`-`).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 表18.2：一元加号(`+`)和一元负号(`-`)操作符。
- en: 'Both operators coerce their operands to numbers:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 两个操作符都将它们的操作数强制转换为数字：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Thus, unary plus lets us convert arbitrary values to numbers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一元加号允许我们将任意值转换为数字。
- en: '[18.3.3 Incrementing (`++`) and decrementing (`--`)](#incrementing--and-decrementing-)'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.3.3 增量(`++`)和减量(`--`)](#incrementing--and-decrementing-)'
- en: The incrementation operator `++` exists in a prefix version and a suffix version.
    In both versions, it destructively adds one to its operand. Therefore, its operand
    must be a storage location that can be changed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 增量操作符 `++` 存在前缀版本和后缀版本。在这两种版本中，它都会破坏性地将其操作数增加一。因此，其操作数必须是可以改变的存储位置。
- en: The decrementation operator `--` works the same, but subtracts one from its
    operand. The next two examples explain the difference between the prefix and the
    suffix version.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 减量操作符 `--` 作用相同，但会从其操作数中减去一个。以下两个示例解释了前缀和后缀版本之间的区别。
- en: '[Table 18.3](#tbl:incrementing-decrementing) summarizes the incrementation
    and decrementation operators.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[表18.3](#tbl:incrementing-decrementing)总结了增量操作符和减量操作符。'
- en: '| Operator | Name |  | Example |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 名称 |  | 示例 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `v++` | Increment | ES1 | `let v=0; [v++, v]` → `[0, 1]` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `v++` | 增量 | ES1 | `let v=0; [v++, v]` → `[0, 1]` |'
- en: '| `++v` | Increment | ES1 | `let v=0; [++v, v]` → `[1, 1]` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `++v` | 增量 | ES1 | `let v=0; [++v, v]` → `[1, 1]` |'
- en: '| `v--` | Decrement | ES1 | `let v=1; [v--, v]` → `[1, 0]` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `v--` | 减量 | ES1 | `let v=1; [v--, v]` → `[1, 0]` |'
- en: '| `--v` | Decrement | ES1 | `let v=1; [--v, v]` → `[0, 0]` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `--v` | 减量 | ES1 | `let v=1; [--v, v]` → `[0, 0]` |'
- en: 'Table 18.3: Incrementation operators and decrementation operators.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 表18.3：增量操作符和减量操作符。
- en: Next, we’ll look at examples of these operators in use.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看这些操作符的使用示例。
- en: Prefix `++` and prefix `--` change their operands and then return them.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀 `++` 和前缀 `--` 改变它们的操作数然后返回它们。
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Suffix `++` and suffix `--` return their operands and then change them.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 后缀 `++` 和后缀 `--` 返回它们的操作数然后改变它们。
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[18.3.3.1 Operands: not just variables](#operands-not-just-variables)'
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[18.3.3.1 操作数：不仅仅是变量](#operands-not-just-variables)'
- en: 'We can also apply these operators to property values:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将这些操作符应用于属性值：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And to Array elements:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 并且应用于数组元素：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Number operators**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![练习图标](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：数字操作符**'
- en: '`exercises/numbers/is_odd_test.mjs`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/numbers/is_odd_test.mjs`'
- en: '[18.4 Converting to number](#converting-to-number)'
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[18.4 转换为数字](#converting-to-number)'
- en: 'These are three ways of converting values to numbers:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种方法可以将值转换为数字：
- en: '`Number(value)`: has a descriptive name and is therefore recommended. [Table
    18.4](#tbl:converting-values-to-numbers) summarizes how it works.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number(value)`: 有一个描述性的名称，因此推荐使用。[表18.4](#tbl:converting-values-to-numbers)总结了其工作方式。'
- en: '`+value`: is equivalent to `Number(value)`.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+value`: 等同于 `Number(value)`。'
- en: '`parseFloat(value)`: has [quirks](#qref-Number.parseFloat) and should be avoided.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parseFloat(value)`: 具有异常行为[quirks](#qref-Number.parseFloat)并且应该避免使用。'
- en: '| `x` | `Number(x)` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `x` | `Number(x)` |'
- en: '| --- | --- |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `undefined` | `NaN` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `undefined` | `NaN` |'
- en: '| `null` | `0` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `null` | `0` |'
- en: '| boolean | `false` → `0`, `true` → `1` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 布尔值 | `false` → `0`, `true` → `1` |'
- en: '| number | `x` (no change) |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 数字 | `x`（无变化） |'
- en: '| bigint | `-1n` → `-1`, `1n` → `1`, etc. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 大整数 | `-1n` → `-1`, `1n` → `1`等。 |'
- en: '| string | `''''` → `0` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | `''''` → `0` |'
- en: '|  | Other → parsed number, ignoring leading/trailing whitespace |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|  | 其他 → 解析的数字，忽略前导/尾随空格 |'
- en: '| symbol | Throws `TypeError` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | 抛出`TypeError` |'
- en: '| object | Configurable (e.g. via `.valueOf()`) |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 对象 | 可配置的（例如，通过`.valueOf()`） |'
- en: 'Table 18.4: Converting values to numbers.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 表18.4：将值转换为数字。
- en: 'Examples:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'How objects are converted to numbers can be configured – for example, by overriding
    `.valueOf()`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对象转换为数字的方式可以配置——例如，通过重写`.valueOf()`：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Converting to number**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![练习图标](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：转换为数字**'
- en: '`exercises/numbers/parse_number_test.mjs`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/numbers/parse_number_test.mjs`'
- en: '[18.5 The numeric error values `NaN` and `Infinity`](#numeric-error-values)'
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[18.5 数值错误值`NaN`和`Infinity`](#numeric-error-values)'
- en: 'JavaScript has two numeric error values:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有两个数值错误值：
- en: '`NaN`:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NaN`：'
- en: Returned if parsing a number doesn’t work or an operation can’t be performed.
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果解析数字失败或无法执行操作，将返回。
- en: Detected via `Number.isNaN()`. `NaN` is not strictly equal to itself.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`Number.isNaN()`检测。`NaN`不严格等于自身。
- en: '`Infinity`:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Infinity`：'
- en: Returned if a number is too large or if a number is divided by zero.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个数字太大或除以零，将返回。
- en: Detected via `Number.isFinite()` or by comparing via `===`.
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`Number.isFinite()`或通过`===`比较检测。
- en: '[18.5.1 Error value: `NaN`](#NaN)'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.5.1 错误值：`NaN`](#NaN)'
- en: '`NaN` is an abbreviation of “not a number”. Ironically, JavaScript considers
    it to be a number:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`NaN`是“不是一个数字”（not a number）的缩写。讽刺的是，JavaScript将其视为一个数字：'
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When is `NaN` returned?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 何时返回`NaN`？
- en: '`NaN` is returned if a number can’t be parsed:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个数字无法解析，将返回`NaN`：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`NaN` is returned if an operation can’t be performed:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作无法执行，将返回`NaN`：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`NaN` is returned if an operand or argument is `NaN` (to propagate errors):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作数或参数是`NaN`，将返回`NaN`（以传播错误）：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[18.5.1.1 Checking for `NaN`](#checking-for-nan)'
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[18.5.1.1 检查`NaN`](#checking-for-nan)'
- en: '`NaN` is the only JavaScript value that is not strictly equal to itself:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`NaN`是唯一一个不严格等于自身的JavaScript值：'
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'These are several ways of checking if a value `x` is `NaN`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是检查值`x`是否为`NaN`的几种方法：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the last line, we use the comparison quirk to detect `NaN`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，我们使用比较怪癖来检测`NaN`。
- en: '[18.5.1.2 Finding `NaN` in Arrays](#finding-nan-in-arrays)'
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[18.5.1.2 在数组中查找`NaN`](#finding-nan-in-arrays)'
- en: 'Some Array methods can’t find `NaN`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数组方法无法找到`NaN`：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Others can:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法可以：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Alas, there is no simple rule of thumb. We have to check for each method how
    it handles `NaN`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，没有简单的经验法则。我们必须检查每个方法如何处理`NaN`。
- en: '[18.5.2 Error value: `Infinity`](#error-value-infinity)'
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.5.2 错误值：`Infinity`](#error-value-infinity)'
- en: When is the error value `Infinity` returned?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 何时返回错误值`Infinity`？
- en: '`Infinity` is returned if a number is too large:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个数字太大，将返回`Infinity`：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`Infinity` is returned if there is a division by zero:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生除以零，将返回`Infinity`：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[18.5.2.1 `Infinity` as a default value](#infinity-as-a-default-value)'
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[18.5.2.1 `Infinity`作为默认值](#infinity-as-a-default-value)'
- en: '`Infinity` is larger than all other numbers (except `NaN`), making it a good
    default value:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Infinity`大于所有其他数字（除了`NaN`），因此它是一个很好的默认值：'
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This explains the following result:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了以下结果：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[18.5.2.2 Checking for `Infinity`](#checking-for-infinity)'
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[18.5.2.2 检查`Infinity`](#checking-for-infinity)'
- en: 'These are two common ways of checking if a value `x` is `Infinity`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是检查值`x`是否为`Infinity`的两种常见方式：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Comparing numbers**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![练习图标](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：比较数字**'
- en: '`exercises/numbers/find_max_test.mjs`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/numbers/find_max_test.mjs`'
- en: '[18.6 The precision of numbers: careful with decimal fractions](#the-precision-of-numbers-careful-with-decimal-fractions)'
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[18.6 数字的精度：小心处理小数](#the-precision-of-numbers-careful-with-decimal-fractions)'
- en: 'Internally, JavaScript floating point numbers are represented with base 2 (according
    to the IEEE 754 standard). That means that decimal fractions (base 10) can’t always
    be represented precisely:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，JavaScript浮点数使用2为基数（根据IEEE 754标准表示）。这意味着十进制小数（10为基数）不能总是精确表示：
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We therefore need to take rounding errors into consideration when performing
    arithmetic in JavaScript.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在JavaScript中进行算术运算时，我们需要考虑舍入误差。
- en: Read on for an explanation of this phenomenon.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 继续阅读以了解这一现象的解释。
- en: '[18.7 (Advanced)](#advanced-2)'
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[18.7 (高级)](#advanced-2)'
- en: All remaining sections of this chapter are advanced.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有剩余部分都是高级内容。
- en: '[18.8 Background: floating point precision](#floating-point-precision)'
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[18.8 背景信息：浮点精度](#floating-point-precision)'
- en: 'In JavaScript, computations with numbers don’t always produce correct results
    – for example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，数字的计算并不总是产生正确的结果——例如：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To understand why, we need to explore how JavaScript represents floating point
    numbers internally. It uses three integers to do so, which take up a total of
    64 bits of storage (double precision):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么，我们需要探索JavaScript内部如何表示浮点数。它使用三个整数来这样做，总共占用64位存储空间（双精度）：
- en: '| Component | Size | Integer range |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 成分 | 大小 | 整数范围 |'
- en: '| --- | --- | --- |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Sign | 1 bit | [0, 1] |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | 1位 | [0, 1] |'
- en: '| Fraction | 52 bits | [0, 2^(52)−1] |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 分数 | 52位 | [0, 2^(52)−1] |'
- en: '| Exponent | 11 bits | [−1023, 1024] |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 指数 | 11位 | [−1023, 1024] |'
- en: 'The floating point number represented by these integers is computed as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这些整数表示的浮点数是这样计算的：
- en: (–1)^(sign) × 0b1.fraction × 2^(exponent)
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (–1)^(符号) × 0b1.尾数 × 2^(指数)
- en: This representation can’t encode a zero because its second component (involving
    the fraction) always has a leading 1\. Therefore, a zero is encoded via the special
    exponent −1023 and a fraction 0.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示方法不能编码零，因为它的第二个组件（涉及分数）总是以1开头。因此，零通过特殊的指数−1023和分数0进行编码。
- en: '[18.8.1 A simplified representation of floating point numbers](#a-simplified-representation-of-floating-point-numbers)'
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.8.1 浮点数的简化表示](#a-simplified-representation-of-floating-point-numbers)'
- en: 'To make further discussions easier, we simplify the previous representation:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使进一步的讨论更容易，我们简化了前面的表示：
- en: Instead of base 2 (binary), we use base 10 (decimal) because that’s what most
    people are more familiar with.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用10（十进制）而不是2（二进制），因为大多数人更熟悉十进制。
- en: The *fraction* is a natural number that is interpreted as a fraction (digits
    after a point). We switch to a *mantissa*, an integer that is interpreted as itself.
    As a consequence, the exponent is used differently, but its fundamental role doesn’t
    change.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分数*是一个自然数，被解释为分数（小数点后的数字）。我们切换到*mantissa*，一个被解释为自身的整数。因此，指数的使用方式不同，但其基本作用没有改变。'
- en: As the mantissa is an integer (with its own sign), we don’t need a separate
    sign, anymore.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于尾数是一个整数（具有自己的符号），我们不再需要单独的符号。
- en: 'The new representation works like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 新的表示方法如下：
- en: mantissa × 10^(exponent)
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尾数 × 10^(指数)
- en: Let’s try out this representation for a few floating point numbers.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用几个浮点数来测试这种表示方法。
- en: 'To encode the integer 123, we use the mantissa 123 and multiply it with 1 (10⁰):'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要编码整数123，我们使用尾数123并将其乘以1（10⁰）：
- en: '[PRE37]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To encode the integer −45, we use the mantissa −45 and, again, the exponent
    zero:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要编码整数−45，我们使用尾数−45，再次使用指数零：
- en: '[PRE38]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For the number 1.5, we imagine there being a point after the mantissa. We use
    the negative exponent −1 to move that point one digit to the left:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于数字1.5，我们想象在尾数后面有一个点。我们使用负指数−1将那个点向左移动一位：
- en: '[PRE39]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For the number 0.25, we move the point two digits to the left:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于数字0.25，我们将小数点向左移动两位：
- en: '[PRE40]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In other words: As soon as we have decimal digits, the exponent becomes negative.
    We can also write such a number as a fraction:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：一旦我们有了小数位，指数就变为负数。我们也可以将这样的数字写成分数的形式：
- en: 'Numerator (above the horizontal fraction bar): the mantissa'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分子（在水平分数线上方）：尾数
- en: 'Denominator (below the horizontal fraction bar): a 10 with a positive exponent
    ≥ 1.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分母（在水平分数线下方）：一个指数为正且≥1的10。
- en: 'For example:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE41]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'These fractions help with understanding why there are numbers that our encoding
    cannot represent:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分数有助于理解为什么有些数字我们的编码无法表示：
- en: '`1/10` can be represented. It already has the required format: a power of 10
    in the denominator.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1/10` 可以表示。它已经具有所需的格式：分母中的10的幂次。'
- en: '`1/2` can be represented as `5/10`. We turned the 2 in the denominator into
    a power of 10 by multiplying the numerator and denominator by 5.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1/2` 可以表示为 `5/10`。我们将分母中的2转换成10的幂次，通过将分子和分母都乘以5来实现。'
- en: '`1/4` can be represented as `25/100`. We turned the 4 in the denominator into
    a power of 10 by multiplying the numerator and denominator by 25.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1/4` 可以表示为 `25/100`。我们将分母中的4转换成10的幂次，通过将分子和分母都乘以25来实现。'
- en: '`1/3` cannot be represented. There is no way to turn the denominator into a
    power of 10\. (The prime factors of 10 are 2 and 5\. Therefore, any denominator
    that only has these prime factors can be converted to a power of 10, by multiplying
    both the numerator and denominator by enough twos and fives. If a denominator
    has a different prime factor, then there’s nothing we can do.)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1/3` 不能表示。没有方法可以将分母转换为10的幂。（10的质因数是2和5。因此，任何只有这些质因数的分母可以通过将分子和分母乘以足够的2和5来转换为10的幂。如果一个分母有不同的质因数，那么我们就无能为力了。）'
- en: 'To conclude our excursion, we switch back to base 2:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束我们的探索，我们切换回二进制：
- en: '`0.5 = 1/2` can be represented with base 2 because the denominator is already
    a power of 2.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.5 = 1/2` 可以用二进制表示，因为分母已经是2的幂。'
- en: '`0.25 = 1/4` can be represented with base 2 because the denominator is already
    a power of 2.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.25 = 1/4` 可以用二进制表示，因为分母已经是2的幂。'
- en: '`0.1 = 1/10` cannot be represented because the denominator cannot be converted
    to a power of 2.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.1 = 1/10` 不能表示，因为分母不能转换为2的幂。'
- en: '`0.2 = 2/10` cannot be represented because the denominator cannot be converted
    to a power of 2.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.2 = 2/10` 不能表示，因为分母不能转换为2的幂。'
- en: 'Now we can see why `0.1 + 0.2` doesn’t produce a correct result: internally,
    neither of the two operands can be represented precisely.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到为什么 `0.1 + 0.2` 不会产生正确的结果：内部，两个操作数都无法精确表示。
- en: 'The only way to compute precisely with decimal fractions is by internally switching
    to base 10\. For many programming languages, base 2 is the default and base 10
    an option. For example:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用小数精确计算的唯一方法是通过内部切换到十进制。对于许多编程语言，默认是二进制，十进制是选项。例如：
- en: Java has the class [`BigDecimal`](https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html).
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 有 `BigDecimal` 类[`BigDecimal`](https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html)。
- en: Python has the module [`decimal`](https://docs.python.org/3/library/decimal.html).
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 有 `decimal` 模块[`decimal`](https://docs.python.org/3/library/decimal.html)。
- en: 'There are plans to add something similar to JavaScript: [the ECMAScript proposal
    “Decimal”](https://github.com/tc39/proposal-decimal). Until that happens, we can
    use libraries such as [big.js](https://github.com/MikeMcl/big.js/).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 有计划添加类似于 JavaScript 的东西：[ECMAScript 提案“十进制”](https://github.com/tc39/proposal-decimal)。直到那时，我们可以使用像
    [big.js](https://github.com/MikeMcl/big.js/) 这样的库。
- en: '[18.9 Integer numbers in JavaScript](#integer-numbers)'
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[18.9 整数在 JavaScript 中的表示](#integer-numbers)'
- en: 'Integer numbers are normal (floating point) numbers without decimal fractions:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 整数是正常（浮点）数，没有小数部分：
- en: '[PRE42]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this section, we’ll look at a few tools for working with these pseudo-integers.
    JavaScript also supports [*bigints*](ch_bigints.html#ch_bigints), which are real
    integers.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些用于处理这些伪整数的工具。JavaScript 也支持 [*大整数*](ch_bigints.html#ch_bigints)，它们是真正的整数。
- en: '[18.9.1 How are integers different from floating point numbers with fractions?](#how-are-integers-different-from-floating-point-numbers-with-fractions)'
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.9.1 整数与带分数的浮点数有何不同？](#how-are-integers-different-from-floating-point-numbers-with-fractions)'
- en: 'As we have seen, JavaScript (non-bigint) integers are simply floating point
    numbers without decimal fractions. But they are different in the following ways:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，JavaScript（非大整数）整数只是没有小数部分的浮点数。但它们在以下方面有所不同：
- en: 'In some locations, only integers are allowed – e.g., the `Array` constructor
    only accepts integers as lengths:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些位置，只允许整数 – 例如，`Array` 构造函数只接受整数作为长度：
- en: '[PRE43]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In some locations, numbers with fractions are coerced to numbers without fractions
    – e.g., the bitwise Or (`|`) operation coerces its operands to 32-bit integers:'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些位置，带分数的数字会被强制转换为不带分数的数字 – 例如，位或（`|`）操作将操作数强制转换为32位整数：
- en: '[PRE44]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'JavaScript has several constants and operations for working with integers:'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 有几个常量和操作用于处理整数：
- en: '[PRE45]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Non-decimal integer literals can’t have fractions (the suffix `.1` is interpreted
    as reading a property – whose name illegally starts with a digit):'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非十进制整数字面量不能有分数（后缀 `.1` 被解释为读取属性 – 其名称非法以数字开头）：
- en: '[PRE46]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Some JavaScript engines internally represent smaller integers differently –
    as real integers. For example, V8 does this for the following “small integer”
    ranges ([source](https://medium.com/fhinkel/v8-internals-how-small-is-a-small-integer-e0badc18b6da)):'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些 JavaScript 引擎内部以不同的方式表示较小的整数 – 作为真正的整数。例如，V8 对以下“小整数”范围这样做（[来源](https://medium.com/fhinkel/v8-internals-how-small-is-a-small-integer-e0badc18b6da)）：
- en: '32-bit systems: 30 bits plus sign'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 32位系统：30位加上符号位
- en: '64-bit systems: 31 bits plus sign'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 64位系统：31位加上符号位
- en: '[18.9.2 Converting to integer](#converting-to-integer)'
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.9.2 转换为整数](#converting-to-integer)'
- en: 'The recommended way of converting numbers to integers is to use one of the
    rounding methods of the `Math` object:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字转换为整数的推荐方法是使用 `Math` 对象的舍入方法之一：
- en: '`Math.floor(n)`: returns the largest integer `i` ≤ `n`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Math.floor(n)`: 返回小于等于 `n` 的最大整数 `i`'
- en: '[PRE47]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`Math.ceil(n)`: returns the smallest integer `i` ≥ `n`'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Math.ceil(n)`: 返回大于等于 `n` 的最小整数 `i`'
- en: '[PRE48]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`Math.round(n)`: returns the integer that is “closest” to `n` with `__.5` being
    rounded up – for example:'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Math.round(n)`: 返回与 `n` “最接近”的整数，其中 `.5` 被向上舍入——例如：'
- en: '[PRE49]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`Math.trunc(n)`: removes any decimal fraction (after the point) that `n` has,
    therefore turning it into an integer.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Math.trunc(n)`: 移除 `n` 中的任何小数部分（小数点后），因此将其转换为整数。'
- en: '[PRE50]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: For more information on rounding, see [“Rounding” (§19.3)](ch_math.html#math-rounding).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于四舍五入的信息，请参阅[“四舍五入”（§19.3）](ch_math.html#math-rounding)。
- en: '[18.9.3 Ranges of integer numbers in JavaScript](#ranges-of-integer-numbers-in-javascript)'
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.9.3 JavaScript中整数数字的范围](#ranges-of-integer-numbers-in-javascript)'
- en: 'These are important ranges of integer numbers in JavaScript:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是JavaScript中整数数字的重要范围：
- en: '**Safe integers:** can be represented “safely” by JavaScript (more on what
    that means in the next subsection)'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全整数**：可以安全地由JavaScript表示（关于这意味着什么将在下一小节中详细介绍）'
- en: 'Precision: 53 bits plus sign'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精度：53位加符号
- en: 'Range: (−2^(53), 2^(53))'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围：(-2^53, 2^53)
- en: '**Array indices**'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组索引**'
- en: 'Precision: 32 bits, unsigned'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精度：32位，无符号
- en: 'Range: [0, 2^(32)−1) (excluding the maximum length)'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围：[0, 2^32-1)（不包括最大长度）
- en: Typed Arrays have a larger range of 53 bits (safe and unsigned)
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型化数组有更大的范围，53位（安全且无符号）
- en: '**Bitwise operators** (bitwise Or, etc.)'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位运算符**（位或等）'
- en: 'Precision: 32 bits'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精度：32位
- en: 'Range of unsigned right shift (`>>>`): unsigned, [0, 2^(32))'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无符号右移运算符（`>>>`）的范围：无符号，[0, 2^32)
- en: 'Range of all other bitwise operators: signed, [−2^(31), 2^(31))'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他位运算符的范围：有符号，[-2^31, 2^31)
- en: '[18.9.4 Safe integers](#safe-integers)'
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.9.4 安全整数](#safe-integers)'
- en: 'This is the range of integer numbers that are *safe* in JavaScript (53 bits
    plus a sign):'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这是JavaScript中整数数字的安全范围（53位加符号）：
- en: '[–(2^(53))+1, 2^(53)–1]'
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[–(2^53)+1, 2^(53)-1]'
- en: An integer is *safe* if it is represented by exactly one JavaScript number.
    Given that JavaScript numbers are encoded as a fraction multiplied by 2 to the
    power of an exponent, higher integers can also be represented, but then there
    are gaps between them.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 一个整数如果是精确地由一个JavaScript数字表示，则它是*安全的*。鉴于JavaScript数字是以分数形式乘以2的指数编码的，因此也可以表示更高的整数，但它们之间会有间隔。
- en: 'For example (18014398509481984 is 2^(54)):'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 例如（18014398509481984 是 2^54）：
- en: '[PRE51]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following mathematical integers are therefore not safe:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下数学整数是不安全的：
- en: 'The mathematical integer 18014398509481984 is represented by these JavaScript
    numbers:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学整数 18014398509481984 是由以下JavaScript数字表示的：
- en: '18014398509481983'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '18014398509481983'
- en: '18014398509481984'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '18014398509481984'
- en: '18014398509481985'
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '18014398509481985'
- en: '18014398509481986'
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '18014398509481986'
- en: The mathematical integer 18014398509481985 is not represented by any JavaScript
    number.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学整数 18014398509481985 不能由任何JavaScript数字表示。
- en: 'The following properties of `Number` help determine if an integer is safe:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `Number` 对象的属性有助于确定一个整数是否安全：
- en: '[PRE52]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '![Icon “exercise”](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **Exercise:
    Detecting safe integers**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '![练习图标](../Images/4fc2ec98bb44cc1f4de7c6a46d9dd043.png) **练习：检测安全整数**'
- en: '`exercises/numbers/is_safe_integer_test.mjs`'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises/numbers/is_safe_integer_test.mjs`'
- en: '[18.9.4.1 Safe computations](#safe-computations)'
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[18.9.4.1 安全计算](#safe-computations)'
- en: Let’s look at computations involving unsafe integers.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看涉及不安全整数的计算。
- en: 'The following result is incorrect and unsafe, even though both of its operands
    are safe:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是不正确的且不安全的，尽管它的两个操作数都是安全的：
- en: '[PRE53]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following result is safe, but incorrect. The first operand is unsafe; the
    second operand is safe:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是安全的，但是不正确的。第一个操作数是不安全的；第二个操作数是安全的：
- en: '[PRE54]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Therefore, the result of an expression `a op b` is correct if and only if:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，表达式 `a op b` 的结果是正确的，当且仅当：
- en: '[PRE55]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: That is, both operands and the result must be safe.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 即，操作数和结果都必须是安全的。
- en: '[18.10 Bitwise operators (advanced)](#bitwise-operators-advanced)'
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[18.10 位运算符（高级）](#bitwise-operators-advanced)'
- en: '[18.10.1 Internally, bitwise operators work with 32-bit integers](#bitwise-operators-32-bit-operands)'
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.10.1 内部位运算符使用32位整数](#bitwise-operators-32-bit-operands)'
- en: 'Internally, JavaScript’s bitwise operators work with 32-bit integers. They
    produce their results in the following steps:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，JavaScript的位运算符使用32位整数进行操作。它们按照以下步骤产生结果：
- en: 'Input (JavaScript numbers): The 1–2 operands are first converted to JavaScript
    numbers (64-bit floating point numbers) and then to 32-bit integers.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入（JavaScript 数字）：1-2 个操作数首先被转换为 JavaScript 数字（64 位浮点数），然后转换为 32 位整数。
- en: 'Computation (32-bit integers): The actual operation processes 32-bit integers
    and produces a 32-bit integer.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算（32 位整数）：实际操作处理 32 位整数并产生一个 32 位整数。
- en: 'Output (JavaScript number): Before returning the result, it is converted back
    to a JavaScript number.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出（JavaScript 数字）：在返回结果之前，它被转换回 JavaScript 数字。
- en: '[18.10.1.1 The types of operands and results](#the-types-of-operands-and-results)'
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[18.10.1.1 操作数和结果的类型](#the-types-of-operands-and-results)'
- en: 'For each bitwise operator, this book mentions the types of its operands and
    its result. Each type is always one of the following two:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个按位运算符，本书都提到了其操作数的类型及其结果。每个类型始终是以下两种之一：
- en: '| Type | Description | Size | Range |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 | 大小 | 范围 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Int32 | signed 32-bit integer | 32 bits incl. sign | [−2^(31), 2^(31)) |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| Int32 | 有符号 32 位整数 | 32 位，包括符号 | [−2^(31), 2^(31)) |'
- en: '| Uint32 | unsigned 32-bit integer | 32 bits | [0, 2^(32)) |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| Uint32 | 无符号 32 位整数 | 32 位 | [0, 2^(32)) |'
- en: Considering the previously mentioned steps, I recommend to pretend that bitwise
    operators internally work with unsigned 32-bit integers (step “computation”) and
    that Int32 and Uint32 only affect how JavaScript numbers are converted to and
    from integers (steps “input” and “output”).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到前面提到的步骤，我建议假设按位运算符在内部以无符号 32 位整数（计算步骤）工作，而 Int32 和 Uint32 只影响 JavaScript
    数字转换为整数以及从整数转换回 JavaScript 数字的方式（输入和输出步骤）。
- en: '[18.10.1.2 Displaying JavaScript numbers as unsigned 32-bit integers](#displaying-javascript-numbers-as-unsigned-32bit-integers)'
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[18.10.1.2 显示 JavaScript 数字为无符号 32 位整数](#displaying-javascript-numbers-as-unsigned-32bit-integers)'
- en: 'While exploring the bitwise operators, it occasionally helps to display JavaScript
    numbers as unsigned 32-bit integers in binary notation. That’s what `b32()` does
    (whose implementation is shown later):'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索按位运算符时，有时将 JavaScript 数字以二进制形式显示为无符号 32 位整数会有所帮助。这正是 `b32()` 所做的（其实现将在后面展示）：
- en: '[PRE56]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[18.10.2 Bitwise Not](#bitwise-not)'
  id: totrans-348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.10.2 按位非](#bitwise-not)'
- en: '| Operation | Name | Type signature |  |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 名称 | 类型签名 |  |'
- en: '| --- | --- | --- | --- |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `~num` | Bitwise Not, *ones’ complement* | Int32 → Int32 | ES1 |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `~num` | 按位非，*补码* | Int32 → Int32 | ES1 |'
- en: 'Table 18.5: The bitwise Not operator.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 表 18.5：按位非运算符。
- en: 'The bitwise Not operator ([table 18.5](#tbl:bitwise-not)) inverts each binary
    digit of its operand:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 按位非运算符（[表 18.5](#tbl:bitwise-not)）反转其操作数的每个二进制位：
- en: '[PRE57]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This so-called *ones’ complement* is similar to a negative for some arithmetic
    operations. For example, adding an integer to its ones’ complement is always `-1`:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这种所谓的 *补码* 对于某些算术操作类似于负数。例如，将一个整数与其补码相加总是 `-1`：
- en: '[PRE58]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[18.10.3 Binary bitwise operators](#binary-bitwise-operators)'
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.10.3 二进制按位运算符](#binary-bitwise-operators)'
- en: '| Operation | Name | Type signature |  |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 名称 | 类型签名 |  |'
- en: '| --- | --- | --- | --- |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `num1 & num2` | Bitwise And | Int32 × Int32 → Int32 | ES1 |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| `num1 & num2` | 按位与 | Int32 × Int32 → Int32 | ES1 |'
- en: '| `num1 ¦ num2` | Bitwise Or | Int32 × Int32 → Int32 | ES1 |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| `num1 ¦ num2` | 按位或 | Int32 × Int32 → Int32 | ES1 |'
- en: '| `num1 ^ num2` | Bitwise Xor | Int32 × Int32 → Int32 | ES1 |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| `num1 ^ num2` | 按位异或 | Int32 × Int32 → Int32 | ES1 |'
- en: 'Table 18.6: Binary bitwise operators.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 表 18.6：二进制按位运算符。
- en: 'The binary bitwise operators ([table 18.6](#tbl:binary-bitwise-operators))
    combine the bits of their operands to produce their results:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制按位运算符（[表 18.6](#tbl:binary-bitwise-operators)）将它们的操作数的位组合起来以产生结果：
- en: '[PRE59]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[18.10.4 Bitwise shift operators](#bitwise-shift-operators)'
  id: totrans-366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.10.4 按位移位运算符](#bitwise-shift-operators)'
- en: '| Operation | Name | Type signature |  |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 名称 | 类型签名 |  |'
- en: '| --- | --- | --- | --- |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `num << count` | Left shift | Int32 × Uint32 → Int32 | ES1 |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| `num << count` | 左移 | Int32 × Uint32 → Int32 | ES1 |'
- en: '| `num >> count` | Signed right shift | Int32 × Uint32 → Int32 | ES1 |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| `num >> count` | 有符号右移 | Int32 × Uint32 → Int32 | ES1 |'
- en: '| `num >>> count` | Unsigned right shift | Uint32 × Uint32 → Uint32 | ES1 |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| `num >>> count` | 无符号右移 | Uint32 × Uint32 → Uint32 | ES1 |'
- en: 'Table 18.7: Bitwise shift operators.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 表 18.7：按位移位运算符。
- en: 'The shift operators ([table 18.7](#tbl:bitwise-shift-operators-short)) move
    binary digits to the left or to the right:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 移位运算符（[表 18.7](#tbl:bitwise-shift-operators-short)）将二进制位向左或向右移动：
- en: '[PRE60]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`>>` preserves highest bit, `>>>` doesn’t:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>` 保留最高位，`>>>` 不保留：'
- en: '[PRE61]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[18.10.5 `b32()`: displaying unsigned 32-bit integers in binary notation](#b32)'
  id: totrans-377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.10.5 `b32()`：以二进制形式显示无符号 32 位整数](#b32)'
- en: 'We have now used `b32()` a few times. The following code is an implementation
    of it:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次使用了 `b32()`。以下代码是它的实现：
- en: '[PRE62]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`n >>> 0` means that we are shifting `n` zero bits to the right. Therefore,
    in principle, the `>>>` operator does nothing, but it still coerces `n` to an
    unsigned 32-bit integer:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`n >>> 0` 表示我们将 `n` 向右移动 0 位。因此，原则上，`>>>` 运算符什么都不做，但它仍然将 `n` 强制转换为无符号 32 位整数：'
- en: '[PRE63]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[18.11 Quick reference: numbers](#quick-reference-numbers)'
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[18.11 快速参考：数字](#quick-reference-numbers)'
- en: '[18.11.1 Global functions for numbers](#global-functions-for-numbers)'
  id: totrans-383
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.11.1 数字的全局函数](#global-functions-for-numbers)'
- en: 'JavaScript has the following four global functions for numbers:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 有以下四个用于数字的全局函数：
- en: '`isFinite()`'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isFinite()`'
- en: '`isNaN()`'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isNaN()`'
- en: '`parseFloat()`'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parseFloat()`'
- en: '`parseInt()`'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parseInt()`'
- en: However, it is better to use the corresponding methods of `Number` (`Number.isFinite()`,
    etc.), which have fewer pitfalls. They were introduced with ES6 and are discussed
    below.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最好使用 `Number` 的相应方法（如 `Number.isFinite()` 等），这些方法有更少的陷阱。它们是在 ES6 中引入的，下面将讨论。
- en: '[18.11.2 `Number.*`: data properties](#number-data-properties)'
  id: totrans-390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.11.2 `Number.*`: 数据属性](#number-data-properties)'
- en: '`Number.EPSILON` ES6'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number.EPSILON` ES6'
- en: The difference between 1 and the next representable floating point number. In
    general, [a machine epsilon](https://en.wikipedia.org/wiki/Machine_epsilon) provides
    an upper bound for rounding errors in floating point arithmetic.
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1 和下一个可表示的浮点数之间的差异。一般来说，[机器精度](https://en.wikipedia.org/wiki/Machine_epsilon)为浮点数算术中的舍入误差提供了一个上限。
- en: 'Approximately: 2.2204460492503130808472633361816 × 10^(-16)'
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大约：2.2204460492503130808472633361816 × 10^(-16)
- en: '`Number.MAX_VALUE` ES1'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number.MAX_VALUE` ES1'
- en: The largest positive finite JavaScript number.
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最大的正有限 JavaScript 数字。
- en: 'Approximately: 1.7976931348623157 × 10^(308)'
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大约：1.7976931348623157 × 10^(308)
- en: '`Number.MIN_VALUE` ES1'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number.MIN_VALUE` ES1'
- en: The smallest positive JavaScript number. Approximately 5 × 10^(−324).
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最小的正 JavaScript 数字。大约 5 × 10^(−324)。
- en: '`Number.NaN` ES1'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number.NaN` ES1'
- en: The same as the global variable `NaN`.
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与全局变量 `NaN` 相同。
- en: '`Number.NEGATIVE_INFINITY` ES1'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number.NEGATIVE_INFINITY` ES1'
- en: The same as `-Number.POSITIVE_INFINITY`.
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与 `-Number.POSITIVE_INFINITY` 相同。
- en: '`Number.POSITIVE_INFINITY` ES1'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number.POSITIVE_INFINITY` ES1'
- en: The same as the global variable `Infinity`.
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与全局变量 `Infinity` 相同。
- en: '[18.11.3 `Number.*`: methods](#number-methods)'
  id: totrans-405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.11.3 `Number.*`: 方法](#number-methods)'
- en: '`Number.isFinite(num)` ES6'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number.isFinite(num)` ES6'
- en: Returns `true` if `num` is an actual number (neither `Infinity` nor `-Infinity`
    nor `NaN`).
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 `num` 是一个实际的数字（既不是 `Infinity` 也不是 `-Infinity` 也不是 `NaN`），则返回 `true`。
- en: '[PRE64]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`Number.isNaN(num)` ES6'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number.isNaN(num)` ES6'
- en: 'Returns `true` if `num` is the value `NaN`:'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 `num` 的值是 `NaN`，则返回 `true`：
- en: '[PRE65]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`Number.parseFloat(str)` ES6'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number.parseFloat(str)` ES6'
- en: 'Coerces its parameter to string and parses it as a floating point number. It
    ignores leading whitespace and illegal trailing characters:'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将其参数强制转换为字符串，并将其解析为浮点数。它忽略前导空白和非法尾随字符：
- en: '[PRE66]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'That can hide problems. Thus, for converting strings to numbers, `Number()`
    is usually a better choice because it only ignores leading and trailing whitespace:'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可能会隐藏问题。因此，对于将字符串转换为数字，`Number()` 通常是一个更好的选择，因为它只忽略前导和尾随空白：
- en: '[PRE67]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[18.11.4 `Number.prototype.*`](#numberprototype)'
  id: totrans-417
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.11.4 `Number.prototype.*`](#numberprototype)'
- en: (`Number.prototype` is where the methods of numbers are stored.)
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: (`Number.prototype` 是存储数字方法的区域。)
- en: '`Number.prototype.toExponential(fractionDigits?)` ES3'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number.prototype.toExponential(fractionDigits?)` ES3'
- en: Returns a string that represents the number via exponential notation.
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个表示数字的字符串，通过指数表示法。
- en: With `fractionDigits`, we can specify, how many digits should be shown of the
    number that is multiplied with the exponent.
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `fractionDigits`，我们可以指定乘以指数的数字应该显示多少位数字。
- en: The default is to show as many digits as necessary.
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，显示所需的所有数字。
- en: 'Example: number too small to get a positive exponent via `.toString()`.'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例：数字太小，无法通过 `.toString()` 获取正指数。
- en: '[PRE68]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Example: fraction not small enough to get a negative exponent via `.toString()`.'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例：分数不够小，无法通过 `.toString()` 获取负指数。
- en: '[PRE69]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`Number.prototype.toFixed(fractionDigits=0)` ES3'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number.prototype.toFixed(fractionDigits=0)` ES3'
- en: Returns an exponent-free string representation of the number, rounded to `fractionDigits`
    digits.
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回一个不带指数的数字字符串表示形式，四舍五入到 `fractionDigits` 位数字。
- en: '[PRE70]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'If the number is 10^(21) or greater, even `.toFixed()` uses an exponent:'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果数字是 10^(21) 或更大，即使是 `.toFixed()` 也使用指数：
- en: '[PRE71]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`Number.prototype.toPrecision(precision?)` ES3'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number.prototype.toPrecision(precision?)` ES3'
- en: Works like `.toString()`, but `precision` specifies how many digits should be
    shown overall.
  id: totrans-433
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `.toString()` 类似，但 `precision` 指定了总共应该显示多少位数字。
- en: If `precision` is missing, `.toString()` is used.
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果缺少`precision`，则使用`.toString()`。
- en: '[PRE72]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`Number.prototype.toString(radix=10)` ES1'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number.prototype.toString(radix=10)` ES1'
- en: Returns a string representation of the number.
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回数字的字符串表示形式。
- en: 'By default, we get a base 10 numeral as a result:'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，我们得到一个基数为10的数字：
- en: '[PRE73]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If we want the numeral to have a different base, we can specify it via `radix`:'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们想使数字有不同的基数，我们可以通过`radix`指定它：
- en: '[PRE74]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`Number.parseInt()` provides the inverse operation: it converts a string that
    contains an integer (no fraction!) numeral with a given base, to a number.'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Number.parseInt()`提供逆操作：它将包含整数字符（没有分数！）的字符串（给定基数）转换为数字。'
- en: '[PRE75]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[18.11.5 `Number.*`: data properties and methods for integers](#number-data-properties-and-methods-for-integers)'
  id: totrans-444
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.11.5 `Number.*`：整数的数据属性和方法](#number-data-properties-and-methods-for-integers)'
- en: '`Number.MIN_SAFE_INTEGER` ES6'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number.MIN_SAFE_INTEGER` ES6'
- en: The smallest integer that JavaScript can represent unambiguously (−2^(53)+1).
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JavaScript可以无歧义表示的最小整数（-2^(53)+1）。
- en: '`Number.MAX_SAFE_INTEGER` ES6'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number.MAX_SAFE_INTEGER` ES6'
- en: The largest integer that JavaScript can represent unambiguously (2^(53)−1).
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JavaScript可以无歧义表示的最大整数（2^(53)−1）。
- en: '`Number.isInteger(num)` ES6'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number.isInteger(num)` ES6'
- en: Returns `true` if `num` is a number and does not have a decimal fraction.
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`num`是一个数字并且没有小数部分，则返回`true`。
- en: '[PRE76]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '`Number.isSafeInteger(num)` ES6'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number.isSafeInteger(num)` ES6'
- en: Returns `true` if `num` is a number and unambiguously represents an integer.
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`num`是一个数字并且无歧义地表示一个整数，则返回`true`。
- en: '`Number.parseInt(str, radix=10)` ES6'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number.parseInt(str, radix=10)` ES6'
- en: 'Coerces its parameter to string and parses it as an integer, ignoring leading
    whitespace and illegal trailing characters:'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将其参数强制转换为字符串并将其解析为整数，忽略前导空白和非法尾随字符：
- en: '[PRE77]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The parameter `radix` specifies the base of the number to be parsed:'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数`radix`指定要解析的数字的基数：
- en: '[PRE78]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Do not use this method to convert numbers to integers: coercing to string is
    inefficient. And stopping before the first non-digit is not a good algorithm for
    removing the fraction of a number. Here is an example where it goes wrong:'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要使用这种方法将数字转换为整数：将数字强制转换为字符串是不高效的。并且在第一个非数字字符之前停止并不是移除数字分数的好算法。以下是一个出错示例：
- en: '[PRE79]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'It is better to use one of the rounding functions of `Math` to convert a number
    to an integer:'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`Math`的其中一个舍入函数将数字转换为整数更好：
- en: '[PRE80]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[18.11.6 Sources](#sources)'
  id: totrans-463
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[18.11.6 源](#sources)'
- en: Wikipedia
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科
- en: '[TypeScript’s built-in typings](https://github.com/microsoft/TypeScript/tree/main/src/lib/)'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[TypeScript内置类型定义](https://github.com/microsoft/TypeScript/tree/main/src/lib/)'
- en: '[MDN web docs for JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MDN Web文档中的JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)'
- en: '[ECMAScript language specification](https://tc39.es/ecma262/)'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ECMAScript语言规范](https://tc39.es/ecma262/)'
